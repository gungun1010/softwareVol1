
softwareVol1.elf:     file format elf32-littlenios2
softwareVol1.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0d00019c

Program Header:
    LOAD off    0x00001020 vaddr 0x00080020 paddr 0x00080020 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001060 vaddr 0x00080060 paddr 0x0d000000 align 2**12
         filesz 0x0000019c memsz 0x0000019c flags r-x
    LOAD off    0x0000219c vaddr 0x0d00019c paddr 0x0d00019c align 2**12
         filesz 0x0005263c memsz 0x0005263c flags r-x
    LOAD off    0x000547d8 vaddr 0x0d0527d8 paddr 0x0d0549d4 align 2**12
         filesz 0x000021fc memsz 0x000021fc flags rw-
    LOAD off    0x00056bd0 vaddr 0x0d056bd0 paddr 0x0d056bd0 align 2**12
         filesz 0x00000000 memsz 0x0000ac40 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00080020  00080020  00001020  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000019c  00080060  0d000000  00001060  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004c5c8  0d00019c  0d00019c  0000219c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00006074  0d04c764  0d04c764  0004e764  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000021fc  0d0527d8  0d0549d4  000547d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000ac40  0d056bd0  0d056bd0  00056bd0  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  000569d4  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001b78  00000000  00000000  000569f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00005cc3  00000000  00000000  00058570  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0008384e  00000000  00000000  0005e233  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000122fe  00000000  00000000  000e1a81  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00043422  00000000  00000000  000f3d7f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00006cd4  00000000  00000000  001371a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003b7d  00000000  00000000  0013de78  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0001450b  00000000  00000000  001419f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000050  00000000  00000000  00155f00  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000009f8  00000000  00000000  00155f50  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000006  00000000  00000000  00161ba9  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  00161baf  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  00161bb2  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  00161bb3  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  00161bb7  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  00161bbb  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  00161bbf  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  00161bc8  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  00161bd1  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000010  00000000  00000000  00161bda  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000005f  00000000  00000000  00161bea  2**0
                  CONTENTS, READONLY
 28 .jdi          00008e6a  00000000  00000000  00161c49  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     000a4443  00000000  00000000  0016aab3  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00080020 l    d  .entry	00000000 .entry
00080060 l    d  .exceptions	00000000 .exceptions
0d00019c l    d  .text	00000000 .text
0d04c764 l    d  .rodata	00000000 .rodata
0d0527d8 l    d  .rwdata	00000000 .rwdata
0d056bd0 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
0d0001d4 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
0d056bdc l     O .bss	00000004 SSSCommand.4583
0d056dec l     O .bss	000005f0 conn.4710
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 ctype_.c
0d04d98d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
0d052910 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
0d0034e0 l     F .text	00000058 __sprint_r
0d04e32e l     O .rodata	00000010 blanks.3452
0d04e31e l     O .rodata	00000010 zeroes.3453
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
0d0056a8 l     F .text	00000244 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0d0070d0 l     F .text	00000058 std
0d0071dc l     F .text	00000008 __fp_lock
0d0071e4 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
0d05488c l     O .rwdata	00000004 charset
0d04e360 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 mprec.c
0d04e4a8 l     O .rodata	0000000c p05.2458
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0d00a22c l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
0d00b6a4 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0d00c7d0 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0d00d17c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0d00d2a0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0d00d380 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0d00d4e0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0d0548a0 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
0d0548a4 l     O .rwdata	00000004 lockid
0d056c14 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
0d0548a8 l     O .rwdata	00000004 lockid
0d056c1c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0d00f09c l     F .text	00000044 OS_InitMisc
0d00f0e0 l     F .text	0000006c OS_InitRdyList
0d00f244 l     F .text	000000e0 OS_InitTCBList
0d00efc0 l     F .text	000000dc OS_InitEventList
0d00f14c l     F .text	0000007c OS_InitTaskIdle
0d00f1c8 l     F .text	0000007c OS_InitTaskStat
0d00f4b8 l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
0d0113d8 l     F .text	00000110 OS_FlagTaskRdy
0d011130 l     F .text	000001c4 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0d053124 l     O .rwdata	000000d8 ext_flash
0d0531fc l     O .rwdata	000000c8 epcs_flash_controller_0
0d0532c4 l     O .rwdata	0000106c jtag_uart
0d054330 l     O .rwdata	00000030 sgdma_rx
0d054360 l     O .rwdata	00000030 sgdma_tx
0d054390 l     O .rwdata	00000124 tristate_lcd
0d015f84 l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
0d016058 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
0d016e48 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0d017dc4 l     F .text	00000288 alt_epcs_flash_query
0d017d8c l     F .text	00000038 alt_flash_device_register
0d01804c l     F .text	00000108 alt_epcs_flash_memcmp
0d0184d4 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0d01899c l     F .text	000002c4 altera_avalon_jtag_uart_irq
0d018c60 l     F .text	00000114 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0d019b48 l     F .text	00000060 alt_get_errno
0d01a0f0 l     F .text	000000c0 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0d01a25c l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 epcs_commands.c
0d01a4b4 l     F .text	00000038 epcs_await_wip_released
0d01a4ec l     F .text	00000038 epcs_test_wip
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 tristate_avalon_lcd_16207.c
0d05492c l     O .rwdata	00000004 colstart
0d01c2d8 l     F .text	000000b8 lcd_write_command
0d01c390 l     F .text	000000d4 lcd_write_data
0d01c464 l     F .text	000000d8 lcd_clear_screen
0d01c53c l     F .text	00000214 lcd_repaint_screen
0d01c750 l     F .text	000000e0 lcd_scroll_up
0d01c830 l     F .text	000002e4 lcd_handle_escape
0d01d07c l     F .text	000000cc alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 tristate_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
0d056c88 l     O .bss	00000004 nclosers
0d057404 l     O .bss	0000003c closers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
0d05493c l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
0d057440 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
0d023be4 l     F .text	000000cc dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
0d025a4c l       .text	00000000 done
0d0258dc l       .text	00000000 asm1
0d025a08 l       .text	00000000 loop0
0d025904 l       .text	00000000 loop
0d025a24 l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
0d056ce8 l     O .bss	00000004 kbd_init.3746
0d056cf4 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
0d056d28 l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
0d02a174 l     F .text	00000098 sockargs
0d0293b0 l     F .text	000001fc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
0d0324d0 l     F .text	000000e8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0d0350e4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0d035184 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0d035264 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0d03571c l     F .text	000000d8 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0d03586c l     F .text	000000f8 alt_file_locked
0d035af0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_read.c
0d035c74 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0d036214 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_irq.c
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0d036b30 l     F .text	000000bc alt_write_word_amd
0d036a08 l     F .text	00000128 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0d036de4 l     F .text	00000190 alt_unlock_block_intel
0d036f74 l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0d056d5e l     O .bss	00000001 tse_system_count.4487
0d056d5f l     O .bss	00000001 is_init.4851
00000000 l    df *ABS*	00000000 allports.c
0d056d64 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0d03cb6c l     F .text	000001d8 check_interval_timers
0d056d70 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
0d056d74 l     O .bss	00000004 arp_timer
0d056d8c l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
0d0549bc l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
0d056dbc l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
0d0549c4 l     O .rwdata	00000004 iCounter.4504
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
0d057458 l     O .bss	0000001e nearBuf.4182
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
0d04a77c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 icmp.c
0d054864 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 calloc.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0d04c540 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
0d04c6f4 l     F .text	00000040 alt_sim_halt
0d002b04 g     F .text	0000001c putchar
0d06115c g     O .bss	00000014 soq
0d008df4 g     F .text	00000094 _mprec_log10
0d038644 g     F .text	000000e0 alt_tse_get_mac_info
0d0548f6 g     O .rwdata	00000002 OSTaskNameSize
0d0183d4 g     F .text	00000090 alt_epcs_flash_get_info
0d008ee0 g     F .text	00000088 __any_on
0d00a878 g     F .text	00000070 _isatty_r
0d04e480 g     O .rodata	00000028 __mprec_tinytens
0d03eaf8 g     F .text	00000780 ip_write_internal
0d00d540 g     F .text	000000c8 alt_main
0d04beb8 g     F .text	0000008c strcpy
0d0251a0 g     F .text	000000ac pk_free
0d002b28 g     F .text	000000a0 _puts_r
0d016908 g     F .text	00000048 alt_read_query_entry_32bit
0d061308 g     O .bss	00000100 alt_irq
0d054704 g     O .rwdata	00000009 rtp_priority
0d00a8e8 g     F .text	00000078 _lseek_r
0d04ba14 g     F .text	00000334 icmp_timex
0d026b50 g     F .text	00000044 m_freem
0d049f80 g     F .text	00000048 vgetc
0d025bc8 g     F .text	0000001c clock_c
0d056d40 g     O .bss	00000004 tcp_optionbuf
0d03e5ac g     F .text	00000084 if_getbynum
0d011ccc g     F .text	000000d4 OS_MemInit
0d056ce0 g     O .bss	00000004 dsc_rlyerrs
0d056cd0 g     O .bss	00000004 dsc_releases
0d016090 g     F .text	000002c0 alt_flash_cfi_write
0d02159c g     F .text	00000074 TK_OSTaskQuery
0d0258bc g       .text	00000000 asm_cksum
0d03c53c g     F .text	00000100 marvell_cfg_rgmii
0d0549d4 g       *ABS*	00000000 __flash_rwdata_start
0d015c2c g     F .text	00000064 OSTimeSet
0d049e60 g     F .text	00000120 vgetc_locked
0d02642c g     F .text	00000020 post_task_setup
0d042500 g     F .text	00000354 ipr_stats
0d033e3c g     F .text	00000134 tcp_attach
0d05494c g     O .rwdata	00000004 reqlist_len
0d027ffc g     F .text	00000084 tcp_tick
0d02079c g     F .text	00000074 print_ipad
0d02147c g     F .text	00000120 tcp_wakeup
0d00c1c4 g     F .text	00000088 __eqdf2
0d056bd4 g     O .bss	00000004 last_flash_sector_offset
0d056c8c g     O .bss	00000004 igmp_timers_are_running
0d000e74 g     F .text	000000ec led_bit_toggle
0d030d4c g     F .text	0000012c tcp_pulloutofband
0d039bb0 g     F .text	000001f0 alt_tse_phy_print_profile
0d00dc18 g     F .text	000006b4 OSEventPendMulti
0d061810 g       *ABS*	00000000 __alt_heap_start
0d036674 g     F .text	00000020 OSTaskCreateHook
0d03c2ac g     F .text	000000a8 marvell_phy_cfg
0d024954 g     F .text	0000008c dhc_ifacedone
0d0428a8 g     F .text	00000400 ip_rcv
0d049bb0 g     F .text	0000017c vfseek
0d02cb9c g     F .text	00000120 soqremque
0d04470c g     F .text	00000858 udpdemux
0d01c1c0 g     F .text	00000118 tse_mac_close
0d0028a0 g     F .text	00000044 printf
0d056d90 g     O .bss	00000004 rt_mib
0d0548ce g     O .rwdata	00000002 OSMboxEn
0d02484c g     F .text	00000060 dhc_state_init
0d04c3e8 g     F .text	00000024 vsprintf
0d0195b4 g     F .text	00000124 alt_avalon_sgdma_do_sync_transfer
0d00e320 g     F .text	0000007c OSIntEnter
0d00a330 g     F .text	00000068 __sseek
0d007138 g     F .text	000000a4 __sinit
0d04384c g     F .text	00000118 in_delmulti
0d005420 g     F .text	00000130 __swbuf_r
0d056da8 g     O .bss	00000004 so_evtmap_create
0d0548de g     O .rwdata	00000002 OSQEn
0d048130 g     F .text	00000094 in_pcballoc
0d054968 g     O .rwdata	00000002 socket_defaults
0d007f90 g     F .text	00000084 _setlocale_r
0d03d3d8 g     F .text	00000498 send_arp
0d007238 g     F .text	0000009c __sfmoreglue
0d048c1c g     F .text	00000368 vfopen_locked
0d056be0 g     O .bss	00000004 SSSLEDCommandQ
0d00d8d4 g     F .text	000000d0 __malloc_unlock
0d0366d0 g     F .text	0000001c OSTaskStatHook
0d03ca50 g     F .text	00000058 prep_modules
0d01fcb8 g     F .text	000001b8 bsd_i_sockoptlen
0d056c24 g     O .bss	00000001 OSLockNesting
0d054944 g     O .rwdata	00000004 xids
0d002df0 g     F .text	00000674 strerror
0d0388a8 g     F .text	00000e08 getPHYSpeed
0d04917c g     F .text	00000040 vfclose
0d0611fc g     O .bss	0000002c tcb
0d05491c g     O .rwdata	00000002 OSDataSize
0d035d4c g     F .text	00000038 alt_remap_cached
0d056c25 g     O .bss	00000001 OSRunning
0d03e2e0 g     F .text	000002cc grat_arp
0d001210 g     F .text	0000006c get_ip_addr
0d047b3c g     F .text	000000ac inet_pton
0d03e710 g     F .text	0000009c reg_type
0d060d00 g     O .bss	000000f0 dhc_states
0d01eac4 g     F .text	00000198 igmp_fasttimo
0d049340 g     F .text	0000005c vunlink_flag_open_files
0d0245b4 g     F .text	00000098 dhc_halt
0d019d08 g     F .text	000003e8 alt_avalon_sgdma_construct_descriptor_burst
0d056cc4 g     O .bss	00000004 dsc_acks
0d061228 g     O .bss	000000e0 tcpstat
0d041db0 g     F .text	0000035c ip_reasm_copy_queued_fragments_into_reassy_buffer
0d0270e0 g     F .text	000000a8 dtom
0d0323d4 g     F .text	000000fc tcp_setpersist
0d029788 g     F .text	000001a4 t_getsockopt
0d0026a8 g     F .text	000000e0 memmove
0d056cd4 g     O .bss	00000004 dsc_naks
0d027584 g     F .text	000005f8 ip_output
0d036714 g     F .text	0000001c OSInitHookBegin
0d04bd48 g     F .text	00000054 icmp_du
0d054940 g     O .rwdata	00000004 num_net_tasks
0d056dcc g     O .bss	00000004 vfiles
0d054914 g     O .rwdata	00000002 OSTmrSize
0d047228 g     F .text	00000104 dhc_main_ipset
0d007228 g     F .text	00000010 _cleanup
0d040ea8 g     F .text	000002e0 ip_reasm_process_first_fragment
0d008f68 g     F .text	000000bc _Balloc
0d001754 g     F .text	0000015c get_board_mac_addr
0d056c28 g     O .bss	00000004 OSIdleCtr
0d056be4 g     O .bss	00000004 SSSLEDLightshowSem
0d03b570 g     F .text	00000194 alt_tse_phy_set_adv_1000
0d0549a4 g     O .rwdata	00000001 max_mac_system
0d046138 g     F .text	000005f0 ip_setmoptions
0d0377c0 g     F .text	00000ad0 alt_tse_system_add_sys
0d00c2d4 g     F .text	00000088 __gtdf2
0d0475fc g     F .text	0000002c md_fseek
0d036340 g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
0d00f7ec g     F .text	000002e0 OS_TCBInit
0d01a3bc g     F .text	000000f8 epcs_sector_erase
0d041188 g     F .text	000000a0 ip_reassm
0d02464c g     F .text	00000200 dhc_reclaim
0d016a94 g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
0d061608 g     O .bss	00000010 udp_mib
00080020 g     F .entry	0000001c __reset
0d029fc0 g     F .text	000000e4 t_shutdown
0d001fc4 g     F .text	000001ec sss_handle_receive
0d029a1c g     F .text	00000150 t_recvfrom
0d05491a g     O .rwdata	00000002 OSTmrWheelTblSize
0d04691c g     F .text	0000067c u_mctest_run
0d01981c g     F .text	00000070 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
0d0439d4 g     F .text	00000094 prep_ifaces
0d000000 g       *ABS*	00000000 __flash_exceptions_start
0d056ca8 g     O .bss	00000001 to_netmain
0d024e0c g     F .text	000000dc pk_alloc
0d0548ba g     O .rwdata	00000002 OSEventSize
0d000a94 g     F .text	000002ec alt_SSSErrorHandler
0d056c2c g     O .bss	00000001 OSPrioHighRdy
0d00a804 g     F .text	00000074 _fstat_r
0d0527f0 g     O .rwdata	00000120 tse_mac_device
0d0211cc g     F .text	0000004c tk_nettick
0d036694 g     F .text	00000020 OSTaskDelHook
0d0165ac g     F .text	000002d8 alt_flash_program_block
0d056c04 g     O .bss	00000004 errno
0d002c28 g     F .text	00000014 __srget
0d02ded0 g     F .text	000000cc in_pcbnotify
0d036320 g       .text	00000000 OSStartHighRdy
0d060df0 g     O .bss	00000014 lilfreeq
0d0001d8 g     F .text	00000624 alt_uCOSIIErrorHandler
0d043a90 g     F .text	00000028 evtmap_setup
0d0143e4 g     F .text	00000200 OSTaskCreateExt
0d056cac g     O .bss	00000004 tcp_sleep_timeout
0d02d5c8 g     F .text	000001d0 sbdrop
0d056da4 g     O .bss	00000004 net_system_exit
0d061618 g     O .bss	00000068 icmp_mib
0d03bdc8 g     F .text	000004e4 alt_tse_phy_set_common_speed
0d032f28 g     F .text	00000078 tcp_getseq
0d043ea0 g     F .text	000000cc ip_raw_alloc
0d010c4c g     F .text	00000068 OSFlagPendGetFlagsRdy
0d0548fa g     O .rwdata	00000002 OSTaskStatStkSize
0d061408 g     O .bss	00000010 pmac_groups
0d022b54 g     F .text	00000bf4 dhc_request
0d02b254 g     F .text	000007e4 soreceive
0d00fc58 g     F .text	00000334 OSFlagAccept
0d012408 g     F .text	000000c8 OSQFlush
0d011da0 g     F .text	00000154 OSQAccept
0d056c0c g     O .bss	00000004 alt_argv
0d05c87c g       *ABS*	00000000 _gp
0d042854 g     F .text	00000054 ip_reasm_send_icmp_timex
0d035fd0 g     F .text	00000120 usleep
0d0491bc g     F .text	00000048 vfflush
0d061104 g     O .bss	00000040 resid_semaphore
0d020654 g     F .text	00000148 hexdump
0d040d60 g     F .text	000000a8 ip_reasm_incr_mem_useage
0d026484 g     F .text	00000034 calloc2
0d01f170 g     F .text	0000007c igmp_leavegroup
0d014210 g     F .text	000001d4 OSTaskCreate
0d013c9c g     F .text	00000574 OSTaskChangePrio
0d056c20 g     O .bss	00000004 alt_heapsem
0d032d74 g     F .text	000000e8 tcp_close
0d00facc g     F .text	0000018c OSDebugInit
0d0145e4 g     F .text	0000040c OSTaskDel
0d04a3dc g     F .text	0000006c vferror
0d035f6c g     F .text	00000064 alt_uncached_malloc
0d0372b4 g     F .text	00000060 tse_mac_initTransInfo2
0d04541c g     F .text	000000c0 udp_alloc
0d05456c g     O .rwdata	00000180 alt_fd_list
0d05d4f0 g     O .bss	00000370 OSFlagTbl
0d056d2c g     O .bss	00000008 mbstat
0d002578 g     F .text	00000090 _getc_r
0d0024e0 g     F .text	00000098 getc
0d002b20 g     F .text	00000008 _putchar_r
0d00ed9c g     F .text	000000b8 OS_EventTaskRemove
0d01a6c0 g     F .text	00000064 epcs_write_status_register
0d045d28 g     F .text	00000158 igmpv2_chk_set_timer
0d021218 g     F .text	0000002c TK_OSTimeDly
0d03538c g     F .text	00000094 alt_find_dev
0d002608 g     F .text	000000a0 memcpy
0d03753c g     F .text	00000058 tse_mac_setMIImode
0d056cdc g     O .bss	00000004 dsc_rebind
0d03cfdc g     F .text	00000080 task_stats
0d028aac g     F .text	0000004c DOMAIN_CHECK
0d027b7c g     F .text	00000040 in_broadcast
0d0548e4 g     O .rwdata	00000002 OSRdyTblSize
0d0396b0 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
0d056dc8 g     O .bss	00000004 vfsystems
0d04534c g     F .text	000000d0 udp_socket
0d056c7c g     O .bss	00000004 MaxMtu
0d02db5c g     F .text	00000160 sock_selscan
0d01aa30 g     F .text	0000017c triple_speed_ethernet_init
0d00721c g     F .text	0000000c _cleanup_r
0d00c46c g     F .text	000000f8 __floatsidf
0d040b0c g     F .text	000000d0 ip_reasm_match_frag_with_ire
0d02cd0c g     F .text	00000050 socantrcvmore
0d037314 g     F .text	000000f0 tse_mac_sTxWrite
0d001e20 g     F .text	000001a4 sss_exec_command
0d00288c g     F .text	00000014 perror
0d0357f4 g     F .text	00000078 alt_io_redirect
0d00c3e4 g     F .text	00000088 __ltdf2
0d056d08 g     O .bss	00000004 netq_intmask
0d01cb14 g     F .text	00000568 tristate_avalon_lcd_16207_write
0d047acc g     F .text	00000070 hextoa
0d04c764 g       *ABS*	00000000 __DTOR_END__
0d029d98 g     F .text	00000228 t_send
0d034fe4 g     F .text	00000100 alt_close
0d056d34 g     O .bss	00000002 select_wait
0d002bc8 g     F .text	00000014 puts
0d020ce8 g     F .text	00000044 std_out
0d0607f4 g     O .bss	00000030 tse_iniche_dev_driver_data
0d049fc8 g     F .text	00000138 vfslookup_locked
0d02aa3c g     F .text	0000009c soaccept
0d00d9a4 g     F .text	00000130 OSEventNameGet
0d0548c8 g     O .rwdata	00000002 OSFlagMax
0d036274 g     F .text	00000020 altera_nios2_irq_init
0d061170 g     O .bss	0000003c tcpmib
0d02a20c g     F .text	0000009c t_errno
0d043ab8 g     F .text	000000f0 ip_raw_open
0d018568 g     F .text	0000011c alt_epcs_flash_write_block
0d023acc g     F .text	00000118 dhc_decline
0d008d44 g     F .text	000000b0 __ratio
0d00e39c g     F .text	00000100 OSIntExit
0d0549c0 g     O .rwdata	00000004 ipRoutes
0d0492e8 g     F .text	00000058 vfeof
0d033240 g     F .text	0000005c tcp_canceltimers
0d0222b8 g     F .text	00000230 dhc_buildheader
0d054902 g     O .rwdata	00000002 OSTCBSize
0d019900 g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
0d056c2d g     O .bss	00000001 OSPrioCur
0d018edc g     F .text	000002c0 altera_avalon_jtag_uart_read
0d04be30 g     F .text	00000014 malloc
0d056dc4 g     O .bss	00000004 inpcb_cachemiss
0d0028e4 g     F .text	00000034 _printf_r
0d047cd4 g     F .text	000000c4 inet46_addr
0d056dc0 g     O .bss	00000004 inpcb_cachehits
0d00c90c g     F .text	00000008 __udivsi3
0d05452c g     O .rwdata	0000000b tcp_outflags
0d060824 g     O .bss	00000130 tse
0d00d1dc g     F .text	000000c4 isatty
0d038290 g     F .text	00000198 alt_tse_sys_enable_mdio_sharing
0d0548e8 g     O .rwdata	00000002 OSStkWidth
0d04e390 g     O .rodata	000000c8 __mprec_tens
0d048a78 g     F .text	0000007c vf_alloc_and_link_vop
0d0548dc g     O .rwdata	00000002 OSPtrSize
0d056d94 g     O .bss	00000004 ipr_curr_mem
0d01e750 g     F .text	0000006c exit_hook
0d0385b8 g     F .text	0000008c alt_tse_get_mac_info_index
0d056c90 g     O .bss	00000004 igmp_cticks
0d056d1c g     O .bss	00000004 mheap_sem_ptr
0d0310e4 g     F .text	00000048 ip4_tcpmss
0d007f6c g     F .text	00000008 __locale_charset
0d0548bc g     O .rwdata	00000002 OSEventTblSize
0d06158c g     O .bss	00000014 netlist
0d02ba38 g     F .text	000000a8 soshutdown
0d036294 g       .text	00000000 OSCtxSw
0d03c9e0 g     F .text	0000004c packet_check
0d023748 g     F .text	000002a0 dhc_setip
0d04aa00 g     F .text	00000090 alt_icache_flush
0d0611ac g     O .bss	00000014 mbufq
0d02a9ec g     F .text	00000050 soabort
0d056bf8 g     O .bss	00000004 __malloc_top_pad
0d056c30 g     O .bss	00000004 OSTCBList
0d025490 g     F .text	00000110 qdel
0d03c840 g     F .text	0000015c station_state
0d044008 g     F .text	00000190 rt_lookup
0d056d4c g     O .bss	00000004 alt_fd_list_lock
0d054888 g     O .rwdata	00000004 __mb_cur_max
0d01f1ec g     F .text	0000035c igmp_validate
0d007f74 g     F .text	0000000c _localeconv_r
0d01e460 g     F .text	000002f0 ip_startup
0d028de8 g     F .text	00000298 t_accept
0d02c78c g     F .text	0000008c soisdisconnecting
0d0096cc g     F .text	0000003c __i2b
0d007950 g     F .text	0000049c __sfvwrite_r
0d019a28 g     F .text	00000058 alt_avalon_sgdma_stop
0d01de18 g     F .text	000003d4 pktdemux
0d05d860 g     O .bss	00000c30 OSMemTbl
0d056c34 g     O .bss	00000001 OSTickStepState
0d03974c g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0d025a80 g     F .text	000000ac kbhit
0d0295ac g     F .text	000001dc t_setsockopt
0d00a2b8 g     F .text	00000070 _sbrk_r
0d036bec g     F .text	00000084 alt_program_intel
0d0546ec g     O .rwdata	00000018 icmpdu_types
0d039da0 g     F .text	00000718 alt_tse_mac_group_init
0d04939c g     F .text	00000220 vunlink
0d01ae38 g     F .text	00000bb0 tse_mac_init
0d0548e0 g     O .rwdata	00000002 OSQMax
0d020494 g     F .text	000000b0 ccksum
0d048af4 g     F .text	000000d8 vf_alloc_buffer
0d056db8 g     O .bss	00000004 cachedRoute
0d054950 g     O .rwdata	00000004 lilbufs
0d05e490 g     O .bss	00000800 OSTaskStatStk
0d047628 g     F .text	00000024 md_ftell
0d020544 g     F .text	00000068 cksum
0d0118b4 g     F .text	0000010c OSMemNameGet
0d02a5c0 g     F .text	00000130 sofree
0d056c84 g     O .bss	00000004 ifNumber
0d0548c0 g     O .rwdata	00000002 OSFlagEn
0d00a960 g     F .text	00000078 _read_r
0d054906 g     O .rwdata	00000002 OSTimeTickHookEn
0d035144 g     F .text	00000024 alt_dcache_flush
0d0114e8 g     F .text	000000ac OS_FlagUnlink
0d01296c g     F .text	00000180 OSQPost
0d052d10 g     O .rwdata	0000000c __lc_ctype
0d054990 g     O .rwdata	00000004 alt_max_fd
0d016884 g     F .text	00000040 alt_read_query_entry_8bit
0d00f378 g     F .text	0000006c OS_MemCopy
0d054958 g     O .rwdata	00000004 bigbufs
0d033f70 g     F .text	000000d4 tcp_disconnect
0d00f3e4 g     F .text	000000d4 OS_Sched
0d00cdd4 g     F .text	00000138 __unpack_d
0d00a6e0 g     F .text	00000110 _fclose_r
0d0117b0 g     F .text	00000104 OSMemGet
0d014d18 g     F .text	000001c4 OSTaskNameSet
0d036c70 g     F .text	00000174 alt_erase_block_intel
0d00709c g     F .text	00000034 fflush
0d056bfc g     O .bss	00000004 __malloc_max_sbrked_mem
0d056c38 g     O .bss	00000004 OSCtxSwCtr
0d060c78 g     O .bss	00000064 igmpstats
0d0366ec g     F .text	00000028 OSTimeTickHook
0d022a38 g     F .text	0000011c dhc_rx_offer
0d01fe70 g     F .text	00000120 bsd_getsockopt
0d0548ca g     O .rwdata	00000002 OSFlagNameSize
0d0615f0 g     O .bss	00000018 ire_stats
0d000fd4 g     F .text	000001e4 LEDManagementTask
0d0341e0 g     F .text	000001b8 udp_soinput
0d0253e0 g     F .text	000000b0 putq
0d00ee54 g     F .text	00000104 OS_EventTaskRemoveMulti
0d056ca4 g     O .bss	00000004 iniche_net_ready
0d00bb34 g     F .text	00000074 __adddf3
0d00ec48 g     F .text	00000154 OS_EventTaskWaitMulti
0d04a394 g     F .text	00000048 isvfile
0d02bbe0 g     F .text	000004c0 sosetopt
0d021048 g     F .text	000000fc netmain
0d03112c g     F .text	0000011c tcp_mss
0d018464 g     F .text	00000070 alt_epcs_flash_erase_block
0d008c24 g     F .text	00000120 __b2d
0d047748 g     F .text	0000031c parse_ipad
0d048a58 g     F .text	00000020 get_vfopen_error
0d0548e2 g     O .rwdata	00000002 OSQSize
0d00b044 g     F .text	00000660 __umoddi3
0d00d3ec g     F .text	000000f4 lseek
0d03caa8 g     F .text	000000c4 inet_timer
0d013548 g     F .text	0000027c OSSemPend
0d039938 g     F .text	00000278 alt_tse_phy_add_profile_default
0d03b030 g     F .text	00000540 alt_tse_phy_get_cap
0d001bd0 g     F .text	00000190 sss_send_menu
0d054884 g     O .rwdata	00000004 _global_impure_ptr
0d020980 g     F .text	00000164 print_eth
0d01a9d8 g     F .text	00000058 epcs_exit_4_bytes_mode
0d048f84 g     F .text	00000050 vfopen
0d035b50 g     F .text	00000124 alt_read
0d009a74 g     F .text	000005f4 _realloc_r
0d0007fc g     F .text	00000298 alt_NetworkErrorHandler
0d0548cc g     O .rwdata	00000002 OSLowestPrio
0d061810 g       *ABS*	00000000 __bss_end
0d035624 g     F .text	000000f8 alt_iic_isr_register
0d019478 g     F .text	0000013c alt_avalon_sgdma_do_async_transfer
0d026a1c g     F .text	00000134 m_free
0d036768 g     F .text	00000020 OSTCBInitHook
0d01c180 g     F .text	00000040 tse_mac_stats
0d024ee8 g     F .text	000002b8 pk_validate
0d054912 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0d035e5c g     F .text	00000110 alt_tick
0d0487d4 g     F .text	0000025c in_pcblookup
0d024ab0 g     F .text	000000cc find_opt
0d00a9d8 g     F .text	0000066c __udivdi3
0d026874 g     F .text	000001a8 m_getnbuf
0d02526c g     F .text	000000ac dump_buf_estats
0d03aeec g     F .text	00000144 alt_tse_phy_check_link
0d056d88 g     O .bss	00000004 arpRepsOut
0d0548b4 g     O .rwdata	00000002 OSEventEn
0d04e458 g     O .rodata	00000028 __mprec_bigtens
0d009954 g     F .text	00000120 __s2b
0d05490e g     O .rwdata	00000002 OSTmrCfgNameSize
0d00c63c g     F .text	00000194 __floatunsidf
0d03c6bc g     F .text	000000fc netmain_init
0d03c448 g     F .text	000000f4 marvell_cfg_sgmii
0d03ad3c g     F .text	000001b0 alt_tse_phy_restart_an
0d008b44 g     F .text	00000060 __mcmp
0d056cc0 g     O .bss	00000004 dsc_requests
0d032728 g     F .text	00000488 tcp_respond
0d03461c g     F .text	0000033c udp4_sockbind
0d05487c g     O .rwdata	00000004 __ctype_ptr
0d056d0c g     O .bss	00000004 old_mode
0d01ef04 g     F .text	0000026c igmp_joingroup
0d027ca4 g     F .text	00000358 so_icmpdu
0d007204 g     F .text	00000018 __fp_lock_all
0d056dd8 g     O .bss	00000004 vfs_dir_stale
0d0355dc g     F .text	00000048 alt_ic_irq_enabled
0d061418 g     O .bss	00000010 pphy_profiles
0d04210c g     F .text	000000e4 ip_reasm_process_timer_tick
0d04a448 g     F .text	0000005c vclearerr
0d0203a8 g     F .text	000000ec bsd_setsockopt
0d027088 g     F .text	00000058 mbuf_len
0d0112f4 g     F .text	000000e4 OS_FlagInit
0d035dc4 g     F .text	00000098 alt_alarm_stop
0d04a148 g     F .text	000001e8 strippath
0d054948 g     O .rwdata	00000004 reqlist
0d0212b4 g     F .text	000001c8 tcp_sleep
0d04c340 g     F .text	00000024 strtol
0d0219f8 g     F .text	000008c0 dhc_upcall
0d034044 g     F .text	000000e0 tcp_usrclosed
00001000 g       *ABS*	00000000 __alt_mem_descriptor_memory
0d056cf8 g     O .bss	00000004 cticks_factor
0d0548f0 g     O .rwdata	00000002 OSTaskIdleStkSize
0d048218 g     F .text	00000254 in_pcbbind
0d056d50 g     O .bss	00000004 alt_irq_active
0d0130d4 g     F .text	000000c0 OSSemAccept
0d011ae0 g     F .text	000000f0 OSMemPut
0d011594 g     F .text	0000021c OSMemCreate
0d056c3c g     O .bss	00000004 OSIdleCtrMax
0008012c g     F .exceptions	000000d0 alt_irq_handler
0d054544 g     O .rwdata	00000028 alt_dev_null
0d05496a g     O .rwdata	00000001 tcprexmtthresh
0d054904 g     O .rwdata	00000002 OSTicksPerSec
0d03e7ac g     F .text	00000098 if_killsocks
0d03f278 g     F .text	00000248 ip_write
0d042ca8 g     F .text	0000060c ip_rcv_phase2
0d02936c g     F .text	00000044 t_getsockname
0d029080 g     F .text	000002a8 t_connect
0d054964 g     O .rwdata	00000004 TCPTV_MSL
0d060e04 g     O .bss	00000010 memestats
0d03ac28 g     F .text	00000114 alt_tse_phy_init
0d025b2c g     F .text	00000060 getch
0d016d9c g     F .text	000000ac alt_set_flash_algorithm_func
0d0547e4 g     O .rwdata	00000080 vfs_root_path
0d029328 g     F .text	00000044 t_getpeername
0d019a80 g     F .text	00000070 alt_avalon_sgdma_check_descriptor_status
0d040e08 g     F .text	000000a0 ip_reasm_decr_mem_useage
0d02ce98 g     F .text	00000080 soreserve
0d036294 g       .text	00000000 OSIntCtxSw
0d0264b8 g     F .text	000000f4 npalloc
0d035168 g     F .text	0000001c alt_dcache_flush_all
0d008a10 g     F .text	00000070 __hi0bits
0d056db4 g     O .bss	00000004 ipraw_eps
0d024b7c g     F .text	00000290 pk_init
0d0473ec g     F .text	00000180 md_fread
0d04bdc8 g     F .text	0000001c calloc
0d01b9e8 g     F .text	000002f8 tse_mac_raw_send
0d00c564 g     F .text	000000d8 __fixdfsi
0d061428 g     O .bss	00000064 intimers
0d02cf78 g     F .text	00000048 sbrelease
0d02e004 g     F .text	000000f0 ifd_clr
0d02d8a8 g     F .text	00000094 sbdroprecord
0d020ae4 g     F .text	00000080 uslash
0d0360f0 g     F .text	00000124 alt_write
0d016950 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
0d056d84 g     O .bss	00000004 arpRepsIn
0d021844 g     F .text	00000090 dhc_get_srv_ipaddr
0d03cd44 g     F .text	000001bc in_timerset
0d056c40 g     O .bss	00000004 OSTCBFreeList
0d0549d4 g       *ABS*	00000000 __ram_rwdata_end
0d0137c4 g     F .text	0000017c OSSemPendAbort
0d031248 g     F .text	0000118c tcp_output
0d056d60 g     O .bss	00000004 activehost
0d054988 g     O .rwdata	00000008 alt_dev_list
0d020e1c g     F .text	0000022c parse_args
0d056d10 g     O .bss	00000004 global_TCPwakeup_setIndx
0d007428 g     F .text	00000058 _fputc_r
0d01d514 g     F .text	00000070 write
0d019c30 g     F .text	0000007c alt_avalon_sgdma_enable_desc_poll
0d0265ac g     F .text	000000b8 npfree
0d002a1c g     F .text	000000e8 _putc_r
0d03db2c g     F .text	00000294 arpReply
0d0205d8 g     F .text	0000007c nextarg
0d054908 g     O .rwdata	00000002 OSVersionNbr
0d0417b8 g     F .text	00000594 ip_reasm_process_subsequent_fragments
0d0549cc g     O .rwdata	00000004 pton_error
0d056cb4 g     O .bss	00000004 dsc_errors
0d057478 g     O .bss	00002000 SSSInitialTaskStk
0d060954 g     O .bss	00000014 rcvdq
0d02df9c g     F .text	00000068 tcp_notify
0d0527d8 g       *ABS*	00000000 __ram_rodata_end
0d00d0a4 g     F .text	000000d8 fstat
0d002394 g     F .text	0000002c fprintf
0d02aad8 g     F .text	000000d4 soconnect
0d043fac g     F .text	0000005c ip_raw_maxalloc
0d03c63c g     F .text	00000080 DP83848C_link_status_read
0d0224e8 g     F .text	00000550 dhc_discover
0d017c5c g     F .text	000000dc alt_check_primary_table
0d0019f4 g     F .text	000000a8 SSSCreateOSDataStructs
0d048758 g     F .text	0000007c in_setpeeraddr
0d0548b0 g     O .rwdata	00000004 OSEndiannessTest
0d025b8c g     F .text	0000003c clock_init
0d049204 g     F .text	000000e4 vfgets
0d03d160 g     F .text	0000017c et_send
0d009834 g     F .text	00000120 __pow5mult
0d056bec g     O .bss	00000004 __nlocale_changed
0d00c914 g     F .text	00000008 __umodsi3
0d0163e0 g     F .text	00000068 alt_flash_cfi_read
0d016b24 g     F .text	00000034 alt_write_native_8bit
0d047a64 g     F .text	00000068 inet_addr
0d040cc8 g     F .text	00000098 ip_reasm_check_mem_useage
0d02bae0 g     F .text	00000100 sorflush
0d04c378 g     F .text	00000020 vprintf
0d060f18 g     O .bss	000000fc global_tcb_ext
0d03f948 g     F .text	00000488 ip_fragment_lc
0d060968 g     O .bss	00000300 netstatic
0d01a894 g     F .text	0000006c epcs_read_electronic_signature
0d028b88 g     F .text	0000017c t_bind
0d01988c g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_stream_desc
0d0548c2 g     O .rwdata	00000002 OSFlagGrpSize
0d0257d8 g     F .text	000000e4 udp_close
0d019984 g     F .text	00000050 alt_avalon_sgdma_register_callback
0d026178 g     F .text	00000240 alt_iniche_init
0d061810 g       *ABS*	00000000 end
0d025db0 g     F .text	00000088 UNLOCK_NET_RESOURCE
0d01abac g     F .text	0000028c prep_tse_mac
0d02992c g     F .text	000000f0 t_recv
0d01698c g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
0d000000 g       *ABS*	00000000 __alt_mem_ssram
0d0495bc g     F .text	000001ac vfread
0d01dd30 g     F .text	000000e8 netclose
0d0021b0 g     F .text	000001ac SSSSimpleSocketServerTask
0d04bdb0 g     F .text	0000000c _atoi_r
0d0375e8 g     F .text	000001d8 alt_tse_phy_add_profile
0d016ec4 g     F .text	000005ec alt_read_cfi_table
0d054974 g     O .rwdata	00000004 tcp_keepintvl
0d018864 g     F .text	00000138 altera_avalon_jtag_uart_init
0d00f65c g     F .text	000000c8 OS_TaskStat
0d056cb8 g     O .bss	00000004 dsc_discovers
0d054920 g     O .rwdata	00000004 tse_mac_name
0d0544e4 g     O .rwdata	00000018 tcp_protosw
0d04c760 g       *ABS*	00000000 __CTOR_LIST__
0d056dd4 g     O .bss	00000004 vfopen_error
0d200000 g       *ABS*	00000000 __alt_stack_pointer
0d056d44 g     O .bss	00000004 tcp_maxidle
0d056ce4 g     O .bss	00000004 firstudp
0d019cac g     F .text	0000005c alt_avalon_sgdma_disable_desc_poll
0d01a2cc g     F .text	00000090 alt_avalon_timer_sc_init
0d00ca40 g     F .text	00000080 __clzsi2
0d01919c g     F .text	000002dc altera_avalon_jtag_uart_write
0d0196d8 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
0d015fbc g     F .text	0000009c alt_flash_cfi_init
0d007128 g     F .text	00000004 __sfp_lock_acquire
0d008904 g     F .text	000000e4 memchr
0d00f324 g     F .text	00000054 OS_MemClr
0d003538 g     F .text	00001ec4 ___vfprintf_internal_r
0d036364 g     F .text	00000310 OSTaskStkInit
0d002cb0 g     F .text	00000060 _sprintf_r
0d0197c8 g     F .text	00000054 alt_avalon_sgdma_construct_stream_to_mem_desc
0d00763c g     F .text	00000314 _free_r
0d045e80 g     F .text	00000170 igmpv2_chk4_rtr_alert_opt
0d02a0a4 g     F .text	000000d0 t_socketclose
0d059478 g     O .bss	00002000 LED7SegLightshowTaskStk
0d00e9a4 g     F .text	00000194 OS_EventTaskRdy
0d04c544 g     F .text	000001b0 __call_exitprocs
0d002bdc g     F .text	0000004c __srget_r
0d01bce0 g     F .text	000000a8 tse_sgdmaRx_isr
0d056c44 g     O .bss	00000001 OSCPUUsage
0d060c68 g     O .bss	00000010 nets
0d025cf0 g     F .text	000000c0 LOCK_NET_RESOURCE
0d0239e8 g     F .text	000000e4 dhc_resetip
0d056bf0 g     O .bss	00000004 __mlocale_changed
0d01bf30 g     F .text	00000250 tse_mac_rcv
0d028af8 g     F .text	00000090 t_socket
0d054894 g     O .rwdata	00000004 __malloc_sbrk_base
0d00019c g     F .text	0000003c _start
0d03d10c g     F .text	00000054 etainit
0d056d54 g     O .bss	00000004 _alt_tick_rate
0d03ca2c g     F .text	00000024 mcastlist
0d0124d0 g     F .text	00000320 OSQPend
0d060e14 g     O .bss	000000f0 pktlog
0d045990 g     F .text	0000014c igmpv2_process_report
0d02e168 g     F .text	00000080 ifd_isset
0d0445c4 g     F .text	00000148 del_route
0d019af0 g     F .text	00000058 alt_avalon_sgdma_open
0d0034d8 g     F .text	00000008 _user_strerror
0d0156dc g     F .text	0000014c OSTimeDly
0d0011b8 g     F .text	00000058 get_mac_addr
0d02a4d0 g     F .text	000000f0 solisten
0d00932c g     F .text	0000014c __lshift
0d037050 g     F .text	00000238 alt_avalon_spi_command
0d056d58 g     O .bss	00000004 _alt_nticks
0d039874 g     F .text	000000c4 alt_tse_phy_rd_mdio_reg
0d01d49c g     F .text	00000078 read
0d015cc4 g     F .text	000002c0 alt_sys_init
0d032e5c g     F .text	0000004c tcp_quench
0d020b64 g     F .text	00000184 ns_printf
0d03e630 g     F .text	000000e0 isbcast
0d025e38 g     F .text	00000214 TK_NEWTASK
0d04c40c g     F .text	00000134 __register_exitproc
0d056c45 g     O .bss	00000001 OSTaskCtr
0d040bdc g     F .text	000000ec ip_reasm_determine_type_of_frag
0d056d5c g     O .bss	00000001 phy_profile_count
0d04bf44 g     F .text	000000f0 strncmp
0d038538 g     F .text	00000080 alt_tse_get_mac_group_index
0d0168c4 g     F .text	00000044 alt_read_query_entry_16bit
0d015828 g     F .text	00000190 OSTimeDlyHMSM
0d035d84 g     F .text	00000040 alt_remap_uncached
0d043ba8 g     F .text	000000c0 ip_raw_close
0d009478 g     F .text	00000254 __multiply
0d054734 g     O .rwdata	000000b0 mdlist
0d018d74 g     F .text	00000074 altera_avalon_jtag_uart_close
0d01e9cc g     F .text	000000f8 igmp_input
0d00235c g     F .text	00000038 __mulsi3
0d03f870 g     F .text	000000d8 ip_raw_write
0d0527d8 g       *ABS*	00000000 __ram_rwdata_start
0d049768 g     F .text	000003e8 vfwrite_locked
0d04c034 g     F .text	000000bc strncpy
0d04c764 g       *ABS*	00000000 __ram_rodata_start
0d056cbc g     O .bss	00000004 dsc_offers
0d0573dc g     O .bss	00000028 __malloc_current_mallinfo
0d0548b6 g     O .rwdata	00000002 OSEventMax
0d047d98 g     F .text	00000074 inet_setport
0d016bbc g     F .text	000001e0 alt_set_flash_width_func
0d009024 g     F .text	0000017c __d2b
0d013940 g     F .text	00000128 OSSemPost
0d030bbc g     F .text	00000190 tcp_dooptions
0d056be8 g     O .bss	00000004 SSSLEDEventFlag
0d01a35c g     F .text	00000060 epcs_read_status_register
0d02c690 g     F .text	000000fc soisconnected
0d00e528 g     F .text	000000e4 OSSchedUnlock
0d043a68 g     F .text	00000028 netexit
0d00127c g     F .text	000001e0 get_serial_number
0d056ca0 g     O .bss	00000004 nettick_wakes
0d0396f8 g     F .text	00000054 alt_tse_phy_wr_mdio_addr
0d056d38 g     O .bss	00000001 tcpprintfs
0d03cf00 g     F .text	000000b8 in_timerkill
0d045830 g     F .text	00000160 igmpv2_input
0d056ccc g     O .bss	00000004 dsc_declines
0d01871c g     F .text	00000058 altera_avalon_jtag_uart_read_fd
0d0205ac g     F .text	0000002c do_trap
0d04a8fc g     F .text	00000104 alt_get_fd
0d01ff90 g     F .text	00000104 bsd_ioctl
0d056c48 g     O .bss	00000004 OSMemFreeList
0d00e67c g     F .text	000000ac OSStatInit
0d027398 g     F .text	000001ec tcp_rcv
0d02093c g     F .text	00000044 panic
0d056ddc g     O .bss	00000004 vfs_open_files
0d04a4c8 g     F .text	0000015c alt_busy_sleep
0d01e2bc g     F .text	000001a4 ip2mac
0d01105c g     F .text	000000d4 OSFlagQuery
0d00cf0c g     F .text	000000c8 __fpcmp_parts_d
0d02dcbc g     F .text	00000214 sock_select
0d046f98 g     F .text	00000290 dhc_setup
0d0325b8 g     F .text	00000058 tcp_init
0d056d14 g     O .bss	00000004 cticks
0d056ca9 g     O .bss	00000001 to_nettick
0d0548ec g     O .rwdata	00000002 OSTaskCreateExtEn
0d00a670 g     F .text	00000070 _close_r
0d01d584 g     F .text	0000064c Netinit
0d02644c g     F .text	00000038 prep_armintcp
0d0436e4 g     F .text	00000168 in_addmulti
0d032610 g     F .text	00000118 tcp_template
0d03baac g     F .text	0000031c alt_tse_phy_get_common_speed
0d027188 g     F .text	00000070 remque
0d0367f0 g     F .text	00000218 alt_erase_block_amd
0d04c364 g     F .text	00000014 _vprintf_r
0d02e258 g     F .text	00000408 tcp_reass
0d047f64 g     F .text	000001cc tcp_cksum
0d034958 g     F .text	000003dc udp4_socksend
0d01a900 g     F .text	00000080 epcs_read_device_id
0d048fd4 g     F .text	000001a8 vfclose_locked
0d02e0f4 g     F .text	00000074 ifd_set
0d04be44 g     F .text	00000074 memcmp
0d00e988 g     F .text	0000001c OS_Dummy
0d0187cc g     F .text	00000048 altera_avalon_jtag_uart_close_fd
0d0249e0 g     F .text	000000d0 dhc_set_state
0d056c80 g     O .bss	00000004 NDEBUG
0d061810 g       *ABS*	00000000 __alt_stack_base
0d056bd8 g     O .bss	00000004 last_flash_sector
0d018814 g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
00002000 g       *ABS*	00000000 __alt_mem_epcs_flash_controller_0
0d02cf18 g     F .text	00000060 sbreserve
0d056d5d g     O .bss	00000001 mac_group_count
0d043c68 g     F .text	00000238 ip_raw_input
0d0023f4 g     F .text	000000ac _fwrite_r
0d054954 g     O .rwdata	00000004 lilbufsiz
0d02e1e8 g     F .text	00000070 ifd_get
0d02cdfc g     F .text	0000009c sbwakeup
0d00556c g     F .text	0000013c __swsetup_r
0d0174b0 g     F .text	000007ac alt_read_cfi_width
0d05ec90 g     O .bss	000001e0 OSQTbl
0d030e78 g     F .text	0000026c tcp_xmit_timer
0d01bd88 g     F .text	000001a8 tse_sgdma_read_init
0d00bf6c g     F .text	00000258 __divdf3
0d0072d4 g     F .text	000000f0 __sfp
0d001620 g     F .text	00000134 generate_mac_addr
0d03e954 g     F .text	000001a4 ip_bldhead
0d008e88 g     F .text	00000058 __copybits
0d02cfc0 g     F .text	000000a8 sbappend
0d052d1c g     O .rwdata	00000408 __malloc_av_
0d007134 g     F .text	00000004 __sinit_lock_release
0d056c4c g     O .bss	00000004 OSTCBHighRdy
0d00bba8 g     F .text	000003c4 __muldf3
0d03f4c0 g     F .text	000003b0 ip_write2
0d00a414 g     F .text	00000060 __sread
0d0549b8 g     O .rwdata	00000004 arp_ageout
0d056c50 g     O .bss	00000004 OSQFreeList
0d03a4b8 g     F .text	00000418 alt_tse_mac_get_phy
0d03e844 g     F .text	00000110 ip_init
0d04a7dc g     F .text	00000120 alt_find_file
0d043f6c g     F .text	00000040 ip_raw_free
0d03da18 g     F .text	00000114 make_arp_entry
0d0351b0 g     F .text	000000b4 alt_dev_llist_insert
0d00d7cc g     F .text	00000108 __malloc_lock
0d0023c0 g     F .text	00000034 _fprintf_r
0d00d608 g     F .text	000000bc sbrk
0d034170 g     F .text	00000070 udp_lookup
0d0199d4 g     F .text	00000054 alt_avalon_sgdma_start
0d00dad4 g     F .text	00000144 OSEventNameSet
0d006ea0 g     F .text	000001fc _fflush_r
0d038810 g     F .text	00000098 alt_tse_mac_set_duplex
0d00a5a8 g     F .text	000000c8 _calloc_r
0d056c54 g     O .bss	00000001 OSRdyGrp
0d0473a4 g     F .text	00000028 md_fopen
0d0544fc g     O .rwdata	00000018 udp_protosw
0d054898 g     O .rwdata	00000008 alt_flash_dev_list
0d016a50 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
0d0486dc g     F .text	0000007c in_setsockaddr
0d056bd0 g       *ABS*	00000000 __bss_start
0d000f60 g     F .text	00000074 LED7SegLightshowTask
0d02d068 g     F .text	000000e0 sbappendrecord
0d0615a0 g     O .bss	00000050 ip_mib
0d002788 g     F .text	00000098 memset
0d02abac g     F .text	000000a0 sodisconnect
0d000df8 g     F .text	0000007c main
0d056c10 g     O .bss	00000004 alt_envp
0d056c00 g     O .bss	00000004 __malloc_max_total_mem
0d001b60 g     F .text	00000070 sss_reset_connection
0d026eb8 g     F .text	000001d0 m_adj
0d018774 g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0d005550 g     F .text	0000001c __swbuf
0d04764c g     F .text	000000d8 md_fgetc
0d04e5d8 g     O .rodata	00000100 OSUnMapTbl
0d0404b0 g     F .text	000002b8 ip_dump
0d02163c g     F .text	00000208 tk_stats
0d054930 g     O .rwdata	00000008 alt_iniche_dev_list
0d05b478 g     O .bss	00000078 SSSLEDCommandQTbl
0d054924 g     O .rwdata	00000008 alt_sgdma_list
0d0548e6 g     O .rwdata	00000002 OSSemEn
0d056cfc g     O .bss	00000004 OS_TPS
0d0282c4 g     F .text	000007e8 rawip_usrreq
0d010cb4 g     F .text	000003a8 OSFlagPost
0d00a328 g     F .text	00000008 __sclose
0d047c74 g     F .text	00000060 print46_addr
0d200000 g       *ABS*	00000000 __alt_heap_limit
0d00a7f0 g     F .text	00000014 fclose
0d00eb38 g     F .text	00000110 OS_EventTaskWait
0d04c0f0 g     F .text	00000250 _strtol_r
0d020810 g     F .text	0000012c print_uptime
0d00f724 g     F .text	000000c8 OS_TaskStatStkChk
0d061680 g     O .bss	00000190 _atexit0
0d01d2ac g     F .text	00000058 tristate_avalon_lcd_16207_write_fd
0d0149f0 g     F .text	00000170 OSTaskDelReq
0d0058ec g     F .text	000015b4 _dtoa_r
0d0081c4 g     F .text	00000740 _malloc_r
0d047724 g     F .text	00000024 md_unlink
0d0374a8 g     F .text	00000094 tse_mac_SwReset
0d0481c4 g     F .text	00000054 in_pcbdetach
0d054994 g     O .rwdata	00000004 alt_errno
0d0549c8 g     O .rwdata	00000004 mdlist_size
0d00e60c g     F .text	00000070 OSStart
0d016adc g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
0d0468ec g     F .text	00000030 u_mctest_init
0d00d770 g     F .text	0000005c __env_unlock
0d007eb4 g     F .text	000000b8 _fwalk
0d014edc g     F .text	00000218 OSTaskResume
0d011bd0 g     F .text	000000fc OSMemQuery
0d047e0c g     F .text	00000158 convert_ip
0d03d870 g     F .text	000001a8 find_oldest_arp
0d0548f8 g     O .rwdata	00000002 OSTaskStatEn
0d056d7c g     O .bss	00000004 arpReqsIn
0d048bcc g     F .text	00000050 vf_free_buffer
0d016448 g     F .text	00000164 alt_write_value_to_flash
0d04a624 g     F .text	00000158 alt_fcntl
0d0548d2 g     O .rwdata	00000002 OSMemMax
0d012aec g     F .text	00000188 OSQPostFront
0d016b58 g     F .text	00000034 alt_write_native_16bit
0d025a50 g     F .text	00000030 dtrap
0d054960 g     O .rwdata	00000004 kb_last
0d002918 g     F .text	00000104 putc
0d00c84c g     F .text	00000060 __divsi3
0d038468 g     F .text	00000048 alt_tse_mac_set_common_speed
0d056c55 g     O .bss	00000003 OSRdyTbl
0d0548ac g     O .rwdata	00000002 OSDebugEn
0d04e4b4 g     O .rodata	00000014 __thenan_df
0d01e7bc g     F .text	000000d0 ip_exit
0d007510 g     F .text	0000012c _malloc_trim_r
0d04c764 g       *ABS*	00000000 __CTOR_END__
0d0548c4 g     O .rwdata	00000002 OSFlagNodeSize
0d056cb0 g     O .bss	00000004 dhc_conn
0d01d148 g     F .text	00000164 tristate_avalon_lcd_16207_init
0d025be4 g     F .text	0000006c cticks_hook
0d05490c g     O .rwdata	00000002 OSTmrCfgMax
0d03c99c g     F .text	00000044 sysuptime
0d018154 g     F .text	00000280 alt_epcs_flash_write
0d00a474 g     F .text	000000bc strcmp
0d00145c g     F .text	000001c4 generate_and_store_mac_addr
0d0421f0 g     F .text	000001c8 ip_reasm_delete_ire
0d011ef4 g     F .text	00000214 OSQCreate
0d025c50 g     F .text	0000005c irq_Mask
0d014b60 g     F .text	000001b8 OSTaskNameGet
0d056d68 g     O .bss	00000004 nextppp
0d056cf0 g     O .bss	00000004 irq_level
0d01dbd0 g     F .text	00000160 fixup_subnet_mask
0d04c764 g       *ABS*	00000000 __flash_rodata_start
0d012c74 g     F .text	00000234 OSQPostOpt
0d00e728 g     F .text	00000240 OSTimeTick
0d0409d4 g     F .text	00000138 ip_copypkt
0d0248ac g     F .text	000000a8 dhc_alldone
0d0548f4 g     O .rwdata	00000002 OSTaskMax
0d04c764 g       *ABS*	00000000 __DTOR_LIST__
0d013194 g     F .text	00000114 OSSemCreate
0d056c94 g     O .bss	00000004 igmp_all_hosts_group
0d054918 g     O .rwdata	00000002 OSTmrWheelSize
0d02cd5c g     F .text	00000038 sbselqueue
0d056c9c g     O .bss	00000004 netmain_wakes
0d03ddc0 g     F .text	00000260 arprcv
0d021244 g     F .text	00000070 TK_OSTaskResume
0d01f548 g     F .text	000003e0 igmp_print_stats
0d00c24c g     F .text	00000088 __nedf2
0d026704 g     F .text	000000a0 pffindtype
0d0548ee g     O .rwdata	00000002 OSTaskDelEn
0d054978 g     O .rwdata	00000004 tcp_sendspace
0d049d2c g     F .text	00000134 vftell
0d060cdc g     O .bss	00000012 eth_prt_buf
0d013a68 g     F .text	00000130 OSSemQuery
0d012108 g     F .text	00000300 OSQDel
0d0127f0 g     F .text	0000017c OSQPendAbort
0d015c90 g     F .text	00000034 alt_irq_init
0d038428 g     F .text	00000040 alt_tse_mac_get_common_speed
0d061144 g     O .bss	00000018 app_semaphore
0d035cd4 g     F .text	00000078 alt_release_fd
0d026100 g     F .text	00000078 post_app_sem
0d01e91c g     F .text	000000b0 igmp_init
0d002c3c g     F .text	00000074 sprintf
0d04e4c8 g     O .rodata	00000100 __clz_tab
0d056cd8 g     O .bss	00000004 dsc_renew
0d04756c g     F .text	00000090 md_fwrite
0d056bf4 g     O .bss	00000004 _PathLocale
0d056d00 g     O .bss	00000004 tcp_sleep_count
0d0271f8 g     F .text	0000007c insque
0d04bd9c g     F .text	00000014 atexit
0d056dd0 g     O .bss	00000004 vfsfiles
0d00a530 g     F .text	00000078 _write_r
0d04c398 g     F .text	00000050 _vsprintf_r
0d044f64 g     F .text	000002b8 udp_send
0d00e49c g     F .text	0000008c OSSchedLock
0d01ec5c g     F .text	000002a8 igmp_send
0d008014 g     F .text	0000001c setlocale
0d00ff8c g     F .text	0000013c OSFlagCreate
0d05b4f0 g     O .bss	00002000 LEDManagementTaskStk
0d025cac g     F .text	00000044 irq_Unmask
0d028d04 g     F .text	000000e4 t_listen
0d054880 g     O .rwdata	00000004 _impure_ptr
0d0527d8 g     O .rwdata	00000018 ssstask
0d056c08 g     O .bss	00000004 alt_argc
0d033738 g     F .text	00000704 tcp_usrreq
0d034398 g     F .text	00000284 udp_usrreq
0d026664 g     F .text	00000054 ncpalloc
0d035328 g     F .text	00000064 _do_dtors
0d0548be g     O .rwdata	00000002 OSEventMultiEn
0d0549b0 g     O .rwdata	00000004 pingdelay
0d03d364 g     F .text	00000074 arp_send_pending
0d060714 g     O .bss	000000e0 tse_mac_if
0d045548 g     F .text	000002e8 igmpv1_input
0d00a068 g     F .text	000001c4 __srefill_r
0d0263b8 g     F .text	00000074 pre_task_setup
0d056d20 g     O .bss	00000004 rcvdq_sem_ptr
0d01fb8c g     F .text	0000012c bsd_getsockname
0d0423b8 g     F .text	00000148 ip_reasm_mark_compact_rfq
0d0018b0 g     F .text	00000144 FindLastFlashSectorOffset
0d0100c8 g     F .text	000002a8 OSFlagDel
0d056c58 g     O .bss	00000004 OSEventFreeList
0d0219a0 g     F .text	00000058 dhc_set_callback
00080060 g       .exceptions	00000000 alt_irq_entry
0d056d78 g     O .bss	00000004 arpcache
0d04b6c4 g     F .text	00000350 icmp_destun
0d043964 g     F .text	00000070 lookup_mcast
0d04a100 g     F .text	00000048 vfslookup
0d0432b4 g     F .text	00000430 ip_demux
0d008ba4 g     F .text	00000080 __ulp
0d00a248 g     F .text	00000040 __isinfd
0d056d04 g     O .bss	00000004 tcp_wakeup_count
0d010608 g     F .text	00000644 OSFlagPend
0d05490a g     O .rwdata	00000002 OSTmrEn
0d0071ec g     F .text	00000018 __fp_unlock_all
0d02604c g     F .text	000000b4 wait_app_sem
0d0073c4 g     F .text	00000064 fputc
0d054938 g     O .rwdata	00000004 ipmcfail_str
0d056d18 g     O .bss	00000004 memtrapsize
0d026b94 g     F .text	00000324 m_copy
0d054980 g     O .rwdata	00000008 alt_fs_list
0d0611c0 g     O .bss	00000014 mfreeq
0d00f528 g     F .text	00000080 OS_StrCopy
0d02a474 g     F .text	0000005c sobind
0d04732c g     F .text	00000078 init_memdev
0d056bd0 g     O .bss	00000001 to_ssstask
0d016a08 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
0d027274 g     F .text	00000124 nptcp_init
0d0548d4 g     O .rwdata	00000002 OSMemNameSize
0d061014 g     O .bss	000000f0 global_TCPwakeup_set
0d036730 g     F .text	0000001c OSInitHookEnd
0d02c818 g     F .text	000000bc soisdisconnected
00080060 g       *ABS*	00000000 __ram_exceptions_start
0d03d2dc g     F .text	00000088 arp_free_pending
0d054900 g     O .rwdata	00000002 OSTCBPrioTblMax
0d007f80 g     F .text	00000010 localeconv
0d02a6f0 g     F .text	000002fc soclose
0d01a524 g     F .text	0000014c epcs_read_buffer
0d060f04 g     O .bss	00000014 bigfreeq
0d0548fc g     O .rwdata	00000002 OSTaskStatStkChkEn
0d0549ac g     O .rwdata	00000004 prompt
0d017d38 g     F .text	00000054 alt_epcs_flash_init
0d03b914 g     F .text	00000198 alt_tse_phy_set_adv_10
0d054970 g     O .rwdata	00000004 tcp_keepidle
0d0280f0 g     F .text	000001d4 rawip_soinput
0d035450 g     F .text	00000050 alt_ic_isr_register
0d049b50 g     F .text	00000060 vfwrite
0d0548d0 g     O .rwdata	00000002 OSMemEn
0d02caf0 g     F .text	000000ac soqinsque
0d056dac g     O .bss	00000004 so_evtmap_delete
0d0024a0 g     F .text	00000040 fwrite
0d0548da g     O .rwdata	00000002 OSMutexEn
0d056d98 g     O .bss	00000004 h_ireq
0d0549d4 g       *ABS*	00000000 _edata
0d03fdd0 g     F .text	00000634 ip_fragment
0d01d358 g     F .text	00000144 iniche_devices_init
0d0611d4 g     O .bss	00000028 tcp_saveti
0d020d2c g     F .text	000000f0 con_page
0d061810 g       *ABS*	00000000 _end
0d02c0a0 g     F .text	00000540 sogetopt
0d00cfd4 g     F .text	0000007c alt_flash_open_dev
0d056c5c g     O .bss	00000001 OSIntNesting
0d03a8d0 g     F .text	00000238 alt_tse_mac_associate_phy
0d0544b4 g     O .rwdata	00000030 nettasks
0d02524c g     F .text	00000020 pk_get_max_intrsafe_buf_len
0d040768 g     F .text	0000026c iproute
0d027bbc g     F .text	000000e8 np_stripoptions
0d056db0 g     O .bss	00000001 so_evtmap
000801fc g       *ABS*	00000000 __ram_exceptions_end
0d018de8 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
0d007480 g     F .text	00000074 _fputs_r
0d0159b8 g     F .text	00000210 OSTimeDlyResume
0d001a9c g     F .text	000000c4 SSSCreateTasks
0d044198 g     F .text	0000042c add_route
0d0104b4 g     F .text	00000154 OSFlagNameSet
0d01e1ec g     F .text	000000d0 c_older
0d02d538 g     F .text	00000090 sbflush
0d0473cc g     F .text	00000020 md_fclose
0d021610 g     F .text	0000002c tk_yield
0d001d60 g     F .text	000000c0 sss_handle_accept
0d0150f4 g     F .text	000001fc OSTaskStkChk
0d03553c g     F .text	000000a0 alt_ic_irq_disable
0d02ac4c g     F .text	00000608 sosend
0d01a980 g     F .text	00000058 epcs_enter_4_bytes_mode
0d0548d6 g     O .rwdata	00000002 OSMemSize
0d040404 g     F .text	000000ac ip_mymach
0d019ba8 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
0d00a398 g     F .text	0000007c __swrite
0d056cec g     O .bss	00000004 cticks_initialized
0d0549b4 g     O .rwdata	00000004 deflength
0d029b6c g     F .text	0000022c t_sendto
0d054890 g     O .rwdata	00000004 __malloc_trim_threshold
0d002820 g     F .text	0000006c _perror_r
0d056c60 g     O .bss	00000004 OSTCBCur
0d02a2a8 g     F .text	000001cc socreate
0d04bde4 g     F .text	00000038 exit
0d06148c g     O .bss	00000100 arp_table
0d056de8 g     O .bss	00000004 icmpdu_hook
0d0548d8 g     O .rwdata	00000002 OSMemTblSize
0d007dec g     F .text	000000c8 _fwalk_reent
0d03cfb8 g     F .text	00000024 create_apptasks
0d05496c g     O .rwdata	00000004 tcp_ttl
0d0091a0 g     F .text	0000018c __mdiff
0d00d050 g     F .text	00000054 alt_flash_close_dev
0d0266b8 g     F .text	0000004c ncpfree
0d00c8ac g     F .text	00000060 __modsi3
0d056c78 g     O .bss	00000004 MaxLnh
0d037594 g     F .text	00000054 tse_mac_setGMIImode
0d047be8 g     F .text	0000008c inet_ntop
0d0454dc g     F .text	0000002c udp_maxalloc
0d03c354 g     F .text	000000f4 marvell_cfg_gmii
0d200000 g       *ABS*	00000000 __alt_data_end
00080060 g     F .exceptions	00000000 alt_exception
0d00712c g     F .text	00000004 __sfp_lock_release
0d00e2cc g     F .text	00000054 OSInit
0d03ab08 g     F .text	00000120 alt_tse_phy_cfg_pcs
0d01551c g     F .text	00000144 OSTaskQuery
0d03c7b8 g     F .text	00000088 icmp_port_du
0d056d48 g     O .bss	00000004 tcp_iss
0d013028 g     F .text	000000ac OS_QInit
0d04bdbc g     F .text	0000000c atoi
0d05495c g     O .rwdata	00000004 bigbufsiz
0d00f5a8 g     F .text	00000058 OS_StrLen
0d032ea8 g     F .text	00000080 tcp_putseq
0d0119c0 g     F .text	00000120 OSMemNameSet
0d04d88c g     O .rodata	00000101 _ctype_
00080000 g       *ABS*	00000000 __alt_mem_onchip_ram
0d02d148 g     F .text	00000208 sbappendaddr
08000000 g       *ABS*	00000000 __alt_mem_ext_flash
0d056de0 g     O .bss	00000004 vfs_total_rw_space
0d046728 g     F .text	00000140 ip_getmoptions
0d0548f2 g     O .rwdata	00000002 OSTaskProfileEn
0d04521c g     F .text	00000130 udpswap
0d056c64 g     O .bss	00000004 OSTime
0d056d24 g     O .bss	00000004 nextslow
0d032fa0 g     F .text	000002a0 tcp_slowtimo
0d032bb0 g     F .text	00000118 tcp_newtcpcb
0d03e020 g     F .text	000001a8 send_via_arp
0d0218d4 g     F .text	000000cc dhc_init
0d041d4c g     F .text	00000064 ip_reasm_find_ire
0d05ee70 g     O .bss	00000800 OSTaskIdleStk
0d04c734 g     F .text	0000002c _exit
0d04a330 g     F .text	00000064 isvfile_locked
0d00a288 g     F .text	00000030 __isnand
0d020224 g     F .text	00000184 bsd_select
0d034e90 g     F .text	00000154 alt_alarm_start
0d010370 g     F .text	00000144 OSFlagNameGet
0d045508 g     F .text	00000040 udp_free
0d025318 g     F .text	000000c8 getq
0d04a4a4 g     F .text	00000024 prep_vfs
0d015bc8 g     F .text	00000064 OSTimeGet
0d0549a8 g     O .rwdata	00000004 name
0d02d798 g     F .text	00000110 sbdropend
0d00c91c g     F .text	00000124 __muldi3
0d008030 g     F .text	00000194 __smakebuf_r
0d016b8c g     F .text	00000030 alt_write_native_32bit
0d03e1c8 g     F .text	00000118 cb_arpent_tmo
0d003464 g     F .text	00000074 strlen
0d045ff0 g     F .text	00000148 IPADDR_TO_NETP
0d01a670 g     F .text	00000050 epcs_write_enable
0d020094 g     F .text	00000030 bsd_inet_ntoa
0d0366b4 g     F .text	0000001c OSTaskSwHook
0d035964 g     F .text	0000018c open
0d0255a0 g     F .text	00000238 udp_open
0d05f670 g     O .bss	00000b40 OSEventTbl
0d02ccbc g     F .text	00000050 socantsendmore
0d056de4 g     O .bss	00000004 vfs_total_dyna_files
0d00c35c g     F .text	00000088 __gedf2
0d0601b0 g     O .bss	00000510 OSTCBTbl
0d056d80 g     O .bss	00000004 arpReqsOut
0d013b98 g     F .text	00000104 OSSemSet
0d0549d0 g     O .rwdata	00000004 http_root_path
0d023cb0 g     F .text	000002e8 dhc_extract_opts
0d041228 g     F .text	00000590 ip_reasm_compute_overlap
0d016350 g     F .text	00000090 alt_flash_cfi_get_info
0d037404 g     F .text	000000a4 tse_mac_aRxRead
0d035420 g     F .text	00000030 alt_icache_flush_all
0d002d10 g     F .text	000000e0 strchr
0d060cee g     O .bss	00000012 ipreturn
0d056da0 g     O .bss	00000004 port_prep
0d054537 g     O .rwdata	0000000d tcp_backoff
0d02c624 g     F .text	0000006c soisconnecting
0d000d80 g     F .text	00000078 SSSInitialTask
0d0074f4 g     F .text	0000001c fputs
0d054998 g     O .rwdata	00000004 alt_priority_mask
0d045adc g     F .text	0000024c igmpv2_process_query
0d02d93c g     F .text	00000220 t_select
0d0132a8 g     F .text	000002a0 OSSemDel
0d034d34 g     F .text	0000015c udp4_sockaddr
0d056c68 g     O .bss	00000004 OSFlagFreeList
0d04846c g     F .text	00000210 in_pcbconnect
0d056d3c g     O .bss	00000004 dropline
0d056d9c g     O .bss	00000004 ire_cticks
0d0354a0 g     F .text	0000009c alt_ic_irq_enable
0d0548b8 g     O .rwdata	00000002 OSEventNameSize
0d0053fc g     F .text	00000024 __vfprintf_internal
0d021144 g     F .text	00000088 tk_netmain
0d04867c g     F .text	00000060 in_pcbdisconnect
0d056c6c g     O .bss	00000001 OSStatRdy
0d0606c0 g     O .bss	00000054 OSTCBPrioTbl
0d00d6c4 g     F .text	000000ac __env_lock
0d0548fe g     O .rwdata	00000002 OSTaskSwHookEn
0d054710 g     O .rwdata	00000024 mdio
0d038724 g     F .text	000000ec alt_tse_mac_set_speed
0d019748 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0d01f928 g     F .text	00000138 bsd_accept
0d05497c g     O .rwdata	00000004 tcp_recvspace
0d00bab4 g     F .text	00000080 __subdf3
0d034124 g     F .text	0000004c tcpinit
0d056c98 g     O .bss	00000004 igmp_all_rtrs_group
0d028080 g     F .text	00000070 rawip_lookup
0d018684 g     F .text	00000098 alt_epcs_flash_read
0d03d05c g     F .text	000000b0 fcntl
0d008a80 g     F .text	000000c4 __lo0bits
0d02d350 g     F .text	000001e8 sbcompress
0d05499c g     O .rwdata	00000008 alt_alarm_list
0d032cc8 g     F .text	000000ac tcp_drop
0d0548c6 g     O .rwdata	00000002 OSFlagWidth
0d0352c4 g     F .text	00000064 _do_ctors
0d03b704 g     F .text	00000210 alt_tse_phy_set_adv_100
0d03329c g     F .text	0000049c tcp_timers
0d01e88c g     F .text	00000090 if_netnumber
0d046868 g     F .text	00000084 ip_freemoptions
0d02c5e0 g     F .text	00000044 sohasoutofband
0d02e660 g     F .text	0000255c tcp_input
0d01fa60 g     F .text	0000012c bsd_getpeername
0d0200c4 g     F .text	00000160 bsd_recvfrom
0d01d304 g     F .text	00000054 close
0d056cc8 g     O .bss	00000004 dsc_bpreplys
0d036788 g     F .text	00000068 alt_program_amd
0d056c18 g     O .bss	00000004 alt_envsem
0d056c70 g     O .bss	00000004 OSIdleCtrRun
0d00e968 g     F .text	00000020 OSVersion
0d054910 g     O .rwdata	00000002 OSTmrCfgWheelSize
0d00d300 g     F .text	00000080 alt_load
0d015660 g     F .text	0000007c OS_TaskStkClr
0d048a30 g     F .text	00000028 set_vfopen_error
0d00cac0 g     F .text	00000314 __pack_d
0d0548ea g     O .rwdata	00000002 OSTaskCreateEn
0d0384b0 g     F .text	00000088 alt_tse_get_system_index
0d054514 g     O .rwdata	00000018 rawip_protosw
0d02cd94 g     F .text	00000068 sbwait
0d00ef58 g     F .text	00000068 OS_EventWaitListInit
0d023f98 g     F .text	0000061c dhc_second
0d01a1b0 g     F .text	000000ac alt_avalon_sgdma_init
0d056d6c g     O .bss	00000004 port_1s_callout
0d03674c g     F .text	0000001c OSTaskIdleHook
0d04be1c g     F .text	00000014 free
0d007130 g     F .text	00000004 __sinit_lock_acquire
0d01a724 g     F .text	00000170 epcs_write_buffer
0d056c74 g     O .bss	00000001 number_of_tse_mac
0d009708 g     F .text	0000012c __multadd
0d0152f0 g     F .text	0000022c OSTaskSuspend
0d0089e8 g     F .text	00000028 _Bfree
0d037288 g     F .text	0000002c no_printf
0d02c8d4 g     F .text	0000021c sonewconn
0d04aa90 g     F .text	00000c34 icmprcv
0d0267a4 g     F .text	000000d0 pffindproto
0d00f600 g     F .text	0000005c OS_TaskIdle
0d054916 g     O .rwdata	00000002 OSTmrTblSize
0d012ea8 g     F .text	00000180 OSQQuery



Disassembly of section .entry:

00080020 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   80020:	00808014 	movui	r2,512
#endif

0:
    initi r2
   80024:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   80028:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   8002c:	00bffd16 	blt	zero,r2,80024 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   80030:	00434034 	movhi	at,3328
    ori r1, r1, %lo(_start)
   80034:	08406714 	ori	at,at,412
    jmp r1
   80038:	0800683a 	jmp	at
   8003c:	00000000 	call	0 <OSTCBStkPtr_OFFSET>

Disassembly of section .exceptions:

00080060 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
   80060:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
   80064:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
   80068:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   8006c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   80070:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   80074:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   80078:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   8007c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   80080:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
   80084:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
   80088:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   8008c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   80090:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   80094:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   80098:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   8009c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   800a0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   800a4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   800a8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   800ac:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   800b0:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   800b4:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   800b8:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   800bc:	10000326 	beq	r2,zero,800cc <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   800c0:	20000226 	beq	r4,zero,800cc <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   800c4:	008012c0 	call	8012c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   800c8:	00000306 	br	800d8 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
   800cc:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
   800d0:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
   800d4:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   800d8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   800dc:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   800e0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   800e4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   800e8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   800ec:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   800f0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   800f4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   800f8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   800fc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   80100:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
   80104:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   80108:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   8010c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   80110:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   80114:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   80118:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   8011c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   80120:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
   80124:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   80128:	ef80083a 	eret

0008012c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   8012c:	defff904 	addi	sp,sp,-28
   80130:	dfc00615 	stw	ra,24(sp)
   80134:	df000515 	stw	fp,20(sp)
   80138:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   8013c:	d00e3200 	call	d00e320 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   80140:	0005313a 	rdctl	r2,ipending
   80144:	e0bffc15 	stw	r2,-16(fp)

  return active;
   80148:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   8014c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
   80150:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   80154:	00800044 	movi	r2,1
   80158:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   8015c:	e0ffff17 	ldw	r3,-4(fp)
   80160:	e0bffe17 	ldw	r2,-8(fp)
   80164:	1884703a 	and	r2,r3,r2
   80168:	1005003a 	cmpeq	r2,r2,zero
   8016c:	1000161e 	bne	r2,zero,801c8 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   80170:	e0bffd17 	ldw	r2,-12(fp)
   80174:	00c341b4 	movhi	r3,3334
   80178:	18c4c204 	addi	r3,r3,4872
   8017c:	100490fa 	slli	r2,r2,3
   80180:	10c5883a 	add	r2,r2,r3
   80184:	11400017 	ldw	r5,0(r2)
   80188:	e0bffd17 	ldw	r2,-12(fp)
   8018c:	00c341b4 	movhi	r3,3334
   80190:	18c4c204 	addi	r3,r3,4872
   80194:	100490fa 	slli	r2,r2,3
   80198:	10c5883a 	add	r2,r2,r3
   8019c:	10800104 	addi	r2,r2,4
   801a0:	11000017 	ldw	r4,0(r2)
   801a4:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   801a8:	0005313a 	rdctl	r2,ipending
   801ac:	e0bffb15 	stw	r2,-20(fp)

  return active;
   801b0:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
   801b4:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
   801b8:	e0bfff17 	ldw	r2,-4(fp)
   801bc:	1004c03a 	cmpne	r2,r2,zero
   801c0:	103fe31e 	bne	r2,zero,80150 <alt_irq_handler+0x24>
   801c4:	00000706 	br	801e4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
   801c8:	e0bffe17 	ldw	r2,-8(fp)
   801cc:	1085883a 	add	r2,r2,r2
   801d0:	e0bffe15 	stw	r2,-8(fp)
      i++;
   801d4:	e0bffd17 	ldw	r2,-12(fp)
   801d8:	10800044 	addi	r2,r2,1
   801dc:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   801e0:	003fde06 	br	8015c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   801e4:	d00e39c0 	call	d00e39c <OSIntExit>
}
   801e8:	e037883a 	mov	sp,fp
   801ec:	dfc00117 	ldw	ra,4(sp)
   801f0:	df000017 	ldw	fp,0(sp)
   801f4:	dec00204 	addi	sp,sp,8
   801f8:	f800283a 	ret

Disassembly of section .text:

0d00019c <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 d00019c:	06c34834 	movhi	sp,3360
    ori sp, sp, %lo(__alt_stack_pointer)
 d0001a0:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 d0001a4:	06834174 	movhi	gp,3333
    ori gp, gp, %lo(_gp)
 d0001a8:	d6b21f14 	ori	gp,gp,51324
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 d0001ac:	00834174 	movhi	r2,3333
    ori r2, r2, %lo(__bss_start)
 d0001b0:	109af414 	ori	r2,r2,27600

    movhi r3, %hi(__bss_end)
 d0001b4:	00c341b4 	movhi	r3,3334
    ori r3, r3, %lo(__bss_end)
 d0001b8:	18c60414 	ori	r3,r3,6160

    beq r2, r3, 1f
 d0001bc:	10c00326 	beq	r2,r3,d0001cc <_start+0x30>

0:
    stw zero, (r2)
 d0001c0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 d0001c4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 d0001c8:	10fffd36 	bltu	r2,r3,d0001c0 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 d0001cc:	d00d3000 	call	d00d300 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 d0001d0:	d00d5400 	call	d00d540 <alt_main>

0d0001d4 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 d0001d4:	003fff06 	br	d0001d4 <alt_after_alt_main>

0d0001d8 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 d0001d8:	defff904 	addi	sp,sp,-28
 d0001dc:	dfc00615 	stw	ra,24(sp)
 d0001e0:	df000515 	stw	fp,20(sp)
 d0001e4:	df000504 	addi	fp,sp,20
 d0001e8:	e17ffd15 	stw	r5,-12(fp)
 d0001ec:	e13ffc05 	stb	r4,-16(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 d0001f0:	e0bffc03 	ldbu	r2,-16(fp)
 d0001f4:	1005003a 	cmpeq	r2,r2,zero
 d0001f8:	10017b1e 	bne	r2,zero,d0007e8 <alt_uCOSIIErrorHandler+0x610>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 d0001fc:	00800084 	movi	r2,2
 d000200:	e0bffb15 	stw	r2,-20(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 d000204:	d00e49c0 	call	d00e49c <OSSchedLock>
      
   switch (error_code)
 d000208:	e0bffc03 	ldbu	r2,-16(fp)
 d00020c:	e0bffe15 	stw	r2,-8(fp)
 d000210:	e0fffe17 	ldw	r3,-8(fp)
 d000214:	18800a20 	cmpeqi	r2,r3,40
 d000218:	1000371e 	bne	r2,zero,d0002f8 <alt_uCOSIIErrorHandler+0x120>
 d00021c:	e0fffe17 	ldw	r3,-8(fp)
 d000220:	18800a48 	cmpgei	r2,r3,41
 d000224:	10001a1e 	bne	r2,zero,d000290 <alt_uCOSIIErrorHandler+0xb8>
 d000228:	e0fffe17 	ldw	r3,-8(fp)
 d00022c:	18800120 	cmpeqi	r2,r3,4
 d000230:	1000761e 	bne	r2,zero,d00040c <alt_uCOSIIErrorHandler+0x234>
 d000234:	e0fffe17 	ldw	r3,-8(fp)
 d000238:	18800148 	cmpgei	r2,r3,5
 d00023c:	10000a1e 	bne	r2,zero,d000268 <alt_uCOSIIErrorHandler+0x90>
 d000240:	e0fffe17 	ldw	r3,-8(fp)
 d000244:	188000a0 	cmpeqi	r2,r3,2
 d000248:	1000911e 	bne	r2,zero,d000490 <alt_uCOSIIErrorHandler+0x2b8>
 d00024c:	e0fffe17 	ldw	r3,-8(fp)
 d000250:	188000c8 	cmpgei	r2,r3,3
 d000254:	1000771e 	bne	r2,zero,d000434 <alt_uCOSIIErrorHandler+0x25c>
 d000258:	e0fffe17 	ldw	r3,-8(fp)
 d00025c:	18800060 	cmpeqi	r2,r3,1
 d000260:	10005e1e 	bne	r2,zero,d0003dc <alt_uCOSIIErrorHandler+0x204>
 d000264:	0000d806 	br	d0005c8 <alt_uCOSIIErrorHandler+0x3f0>
 d000268:	e0fffe17 	ldw	r3,-8(fp)
 d00026c:	18800520 	cmpeqi	r2,r3,20
 d000270:	10004f1e 	bne	r2,zero,d0003b0 <alt_uCOSIIErrorHandler+0x1d8>
 d000274:	e0fffe17 	ldw	r3,-8(fp)
 d000278:	188007a0 	cmpeqi	r2,r3,30
 d00027c:	1000ad1e 	bne	r2,zero,d000534 <alt_uCOSIIErrorHandler+0x35c>
 d000280:	e0fffe17 	ldw	r3,-8(fp)
 d000284:	188002a0 	cmpeqi	r2,r3,10
 d000288:	1000761e 	bne	r2,zero,d000464 <alt_uCOSIIErrorHandler+0x28c>
 d00028c:	0000ce06 	br	d0005c8 <alt_uCOSIIErrorHandler+0x3f0>
 d000290:	e0fffe17 	ldw	r3,-8(fp)
 d000294:	18801020 	cmpeqi	r2,r3,64
 d000298:	10009c1e 	bne	r2,zero,d00050c <alt_uCOSIIErrorHandler+0x334>
 d00029c:	e0fffe17 	ldw	r3,-8(fp)
 d0002a0:	18801048 	cmpgei	r2,r3,65
 d0002a4:	10000a1e 	bne	r2,zero,d0002d0 <alt_uCOSIIErrorHandler+0xf8>
 d0002a8:	e0fffe17 	ldw	r3,-8(fp)
 d0002ac:	18800f60 	cmpeqi	r2,r3,61
 d0002b0:	10008b1e 	bne	r2,zero,d0004e0 <alt_uCOSIIErrorHandler+0x308>
 d0002b4:	e0fffe17 	ldw	r3,-8(fp)
 d0002b8:	18800fa0 	cmpeqi	r2,r3,62
 d0002bc:	10007e1e 	bne	r2,zero,d0004b8 <alt_uCOSIIErrorHandler+0x2e0>
 d0002c0:	e0fffe17 	ldw	r3,-8(fp)
 d0002c4:	18800aa0 	cmpeqi	r2,r3,42
 d0002c8:	1000151e 	bne	r2,zero,d000320 <alt_uCOSIIErrorHandler+0x148>
 d0002cc:	0000be06 	br	d0005c8 <alt_uCOSIIErrorHandler+0x3f0>
 d0002d0:	e0fffe17 	ldw	r3,-8(fp)
 d0002d4:	18801920 	cmpeqi	r2,r3,100
 d0002d8:	1000a11e 	bne	r2,zero,d000560 <alt_uCOSIIErrorHandler+0x388>
 d0002dc:	e0fffe17 	ldw	r3,-8(fp)
 d0002e0:	18803fe0 	cmpeqi	r2,r3,255
 d0002e4:	1000aa1e 	bne	r2,zero,d000590 <alt_uCOSIIErrorHandler+0x3b8>
 d0002e8:	e0fffe17 	ldw	r3,-8(fp)
 d0002ec:	188010a0 	cmpeqi	r2,r3,66
 d0002f0:	10001d1e 	bne	r2,zero,d000368 <alt_uCOSIIErrorHandler+0x190>
 d0002f4:	0000b406 	br	d0005c8 <alt_uCOSIIErrorHandler+0x3f0>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 d0002f8:	00834174 	movhi	r2,3333
 d0002fc:	10922004 	addi	r2,r2,18560
 d000300:	10800017 	ldw	r2,0(r2)
 d000304:	11c00317 	ldw	r7,12(r2)
 d000308:	01034174 	movhi	r4,3333
 d00030c:	2131d904 	addi	r4,r4,-14492
 d000310:	01400044 	movi	r5,1
 d000314:	01800c44 	movi	r6,49
 d000318:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d00031c:	0000c106 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 d000320:	00834174 	movhi	r2,3333
 d000324:	10922004 	addi	r2,r2,18560
 d000328:	10800017 	ldw	r2,0(r2)
 d00032c:	11c00317 	ldw	r7,12(r2)
 d000330:	01034174 	movhi	r4,3333
 d000334:	2131e604 	addi	r4,r4,-14440
 d000338:	01400044 	movi	r5,1
 d00033c:	01800c44 	movi	r6,49
 d000340:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 d000344:	00834174 	movhi	r2,3333
 d000348:	10922004 	addi	r2,r2,18560
 d00034c:	10800017 	ldw	r2,0(r2)
 d000350:	11000317 	ldw	r4,12(r2)
 d000354:	01434174 	movhi	r5,3333
 d000358:	2971f304 	addi	r5,r5,-14388
 d00035c:	01800504 	movi	r6,20
 d000360:	d0023940 	call	d002394 <fprintf>
            OS_LOWEST_PRIO);
         break;
 d000364:	0000af06 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 d000368:	00834174 	movhi	r2,3333
 d00036c:	10922004 	addi	r2,r2,18560
 d000370:	10800017 	ldw	r2,0(r2)
 d000374:	11c00317 	ldw	r7,12(r2)
 d000378:	01034174 	movhi	r4,3333
 d00037c:	21320004 	addi	r4,r4,-14336
 d000380:	01400044 	movi	r5,1
 d000384:	01800a04 	movi	r6,40
 d000388:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 d00038c:	00834174 	movhi	r2,3333
 d000390:	10922004 	addi	r2,r2,18560
 d000394:	10800017 	ldw	r2,0(r2)
 d000398:	11000317 	ldw	r4,12(r2)
 d00039c:	01434174 	movhi	r5,3333
 d0003a0:	29720b04 	addi	r5,r5,-14292
 d0003a4:	01800284 	movi	r6,10
 d0003a8:	d0023940 	call	d002394 <fprintf>
         break;
 d0003ac:	00009d06 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_MBOX_FULL:
         fault_level = NONE;
 d0003b0:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 d0003b4:	00834174 	movhi	r2,3333
 d0003b8:	10922004 	addi	r2,r2,18560
 d0003bc:	10800017 	ldw	r2,0(r2)
 d0003c0:	11c00317 	ldw	r7,12(r2)
 d0003c4:	01034174 	movhi	r4,3333
 d0003c8:	21321404 	addi	r4,r4,-14256
 d0003cc:	01400044 	movi	r5,1
 d0003d0:	01800c84 	movi	r6,50
 d0003d4:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d0003d8:	00009206 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 d0003dc:	00800044 	movi	r2,1
 d0003e0:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, 
 d0003e4:	00834174 	movhi	r2,3333
 d0003e8:	10922004 	addi	r2,r2,18560
 d0003ec:	10800017 	ldw	r2,0(r2)
 d0003f0:	11c00317 	ldw	r7,12(r2)
 d0003f4:	01034174 	movhi	r4,3333
 d0003f8:	21322104 	addi	r4,r4,-14204
 d0003fc:	01400044 	movi	r5,1
 d000400:	01801244 	movi	r6,73
 d000404:	d0024a00 	call	d0024a0 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 d000408:	00008606 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 d00040c:	00834174 	movhi	r2,3333
 d000410:	10922004 	addi	r2,r2,18560
 d000414:	10800017 	ldw	r2,0(r2)
 d000418:	11c00317 	ldw	r7,12(r2)
 d00041c:	01034174 	movhi	r4,3333
 d000420:	21323404 	addi	r4,r4,-14128
 d000424:	01400044 	movi	r5,1
 d000428:	01800c44 	movi	r6,49
 d00042c:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d000430:	00007c06 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 d000434:	00800044 	movi	r2,1
 d000438:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 d00043c:	00834174 	movhi	r2,3333
 d000440:	10922004 	addi	r2,r2,18560
 d000444:	10800017 	ldw	r2,0(r2)
 d000448:	11c00317 	ldw	r7,12(r2)
 d00044c:	01034174 	movhi	r4,3333
 d000450:	21324104 	addi	r4,r4,-14076
 d000454:	01400044 	movi	r5,1
 d000458:	01800a44 	movi	r6,41
 d00045c:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d000460:	00007006 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TIMEOUT:
         fault_level = NONE;
 d000464:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 d000468:	00834174 	movhi	r2,3333
 d00046c:	10922004 	addi	r2,r2,18560
 d000470:	10800017 	ldw	r2,0(r2)
 d000474:	11c00317 	ldw	r7,12(r2)
 d000478:	01034174 	movhi	r4,3333
 d00047c:	21324c04 	addi	r4,r4,-14032
 d000480:	01400044 	movi	r5,1
 d000484:	01800a04 	movi	r6,40
 d000488:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d00048c:	00006506 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 d000490:	00834174 	movhi	r2,3333
 d000494:	10922004 	addi	r2,r2,18560
 d000498:	10800017 	ldw	r2,0(r2)
 d00049c:	11c00317 	ldw	r7,12(r2)
 d0004a0:	01034174 	movhi	r4,3333
 d0004a4:	21325704 	addi	r4,r4,-13988
 d0004a8:	01400044 	movi	r5,1
 d0004ac:	01800b04 	movi	r6,44
 d0004b0:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d0004b4:	00005b06 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 d0004b8:	00834174 	movhi	r2,3333
 d0004bc:	10922004 	addi	r2,r2,18560
 d0004c0:	10800017 	ldw	r2,0(r2)
 d0004c4:	11c00317 	ldw	r7,12(r2)
 d0004c8:	01034174 	movhi	r4,3333
 d0004cc:	21326304 	addi	r4,r4,-13940
 d0004d0:	01400044 	movi	r5,1
 d0004d4:	01800884 	movi	r6,34
 d0004d8:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d0004dc:	00005106 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 d0004e0:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 d0004e4:	00834174 	movhi	r2,3333
 d0004e8:	10922004 	addi	r2,r2,18560
 d0004ec:	10800017 	ldw	r2,0(r2)
 d0004f0:	11c00317 	ldw	r7,12(r2)
 d0004f4:	01034174 	movhi	r4,3333
 d0004f8:	21326c04 	addi	r4,r4,-13904
 d0004fc:	01400044 	movi	r5,1
 d000500:	01800bc4 	movi	r6,47
 d000504:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d000508:	00004606 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 d00050c:	00834174 	movhi	r2,3333
 d000510:	10922004 	addi	r2,r2,18560
 d000514:	10800017 	ldw	r2,0(r2)
 d000518:	11c00317 	ldw	r7,12(r2)
 d00051c:	01034174 	movhi	r4,3333
 d000520:	21327804 	addi	r4,r4,-13856
 d000524:	01400044 	movi	r5,1
 d000528:	018009c4 	movi	r6,39
 d00052c:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d000530:	00003c06 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_Q_FULL:
         fault_level = NONE;
 d000534:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 d000538:	00834174 	movhi	r2,3333
 d00053c:	10922004 	addi	r2,r2,18560
 d000540:	10800017 	ldw	r2,0(r2)
 d000544:	11c00317 	ldw	r7,12(r2)
 d000548:	01034174 	movhi	r4,3333
 d00054c:	21328204 	addi	r4,r4,-13816
 d000550:	01400044 	movi	r5,1
 d000554:	01800a84 	movi	r6,42
 d000558:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d00055c:	00003106 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 d000560:	00800044 	movi	r2,1
 d000564:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 d000568:	00834174 	movhi	r2,3333
 d00056c:	10922004 	addi	r2,r2,18560
 d000570:	10800017 	ldw	r2,0(r2)
 d000574:	11c00317 	ldw	r7,12(r2)
 d000578:	01034174 	movhi	r4,3333
 d00057c:	21328d04 	addi	r4,r4,-13772
 d000580:	01400044 	movi	r5,1
 d000584:	01800c04 	movi	r6,48
 d000588:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d00058c:	00002506 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 d000590:	00800084 	movi	r2,2
 d000594:	e0bffb15 	stw	r2,-20(fp)
         printf(
 d000598:	01034174 	movhi	r4,3333
 d00059c:	21329a04 	addi	r4,r4,-13720
 d0005a0:	d0028a00 	call	d0028a0 <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 d0005a4:	00834174 	movhi	r2,3333
 d0005a8:	10922004 	addi	r2,r2,18560
 d0005ac:	10800017 	ldw	r2,0(r2)
 d0005b0:	11000317 	ldw	r4,12(r2)
 d0005b4:	e1bffd17 	ldw	r6,-12(fp)
 d0005b8:	01434174 	movhi	r5,3333
 d0005bc:	2972aa04 	addi	r5,r5,-13656
 d0005c0:	d0023940 	call	d002394 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 d0005c4:	00001706 	br	d000624 <alt_uCOSIIErrorHandler+0x44c>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 d0005c8:	01034174 	movhi	r4,3333
 d0005cc:	2132b504 	addi	r4,r4,-13612
 d0005d0:	d002bc80 	call	d002bc8 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 d0005d4:	00834174 	movhi	r2,3333
 d0005d8:	10922004 	addi	r2,r2,18560
 d0005dc:	10800017 	ldw	r2,0(r2)
 d0005e0:	11c00317 	ldw	r7,12(r2)
 d0005e4:	01034174 	movhi	r4,3333
 d0005e8:	2132c304 	addi	r4,r4,-13556
 d0005ec:	01400044 	movi	r5,1
 d0005f0:	01800404 	movi	r6,16
 d0005f4:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 d0005f8:	00834174 	movhi	r2,3333
 d0005fc:	10922004 	addi	r2,r2,18560
 d000600:	10800017 	ldw	r2,0(r2)
 d000604:	11000317 	ldw	r4,12(r2)
 d000608:	e1bffc03 	ldbu	r6,-16(fp)
 d00060c:	01434174 	movhi	r5,3333
 d000610:	2972c804 	addi	r5,r5,-13536
 d000614:	d0023940 	call	d002394 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 d000618:	01034174 	movhi	r4,3333
 d00061c:	2132cd04 	addi	r4,r4,-13516
 d000620:	d00288c0 	call	d00288c <perror>

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 d000624:	e0bffb17 	ldw	r2,-20(fp)
 d000628:	e0bfff15 	stw	r2,-4(fp)
 d00062c:	e0ffff17 	ldw	r3,-4(fp)
 d000630:	18800060 	cmpeqi	r2,r3,1
 d000634:	1000071e 	bne	r2,zero,d000654 <alt_uCOSIIErrorHandler+0x47c>
 d000638:	e0ffff17 	ldw	r3,-4(fp)
 d00063c:	18800070 	cmpltui	r2,r3,1
 d000640:	10003f1e 	bne	r2,zero,d000740 <alt_uCOSIIErrorHandler+0x568>
 d000644:	e0ffff17 	ldw	r3,-4(fp)
 d000648:	188000a0 	cmpeqi	r2,r3,2
 d00064c:	10001d1e 	bne	r2,zero,d0006c4 <alt_uCOSIIErrorHandler+0x4ec>
 d000650:	00005806 	br	d0007b4 <alt_uCOSIIErrorHandler+0x5dc>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 d000654:	01034174 	movhi	r4,3333
 d000658:	2132db04 	addi	r4,r4,-13460
 d00065c:	d0028a00 	call	d0028a0 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 d000660:	00834174 	movhi	r2,3333
 d000664:	10922004 	addi	r2,r2,18560
 d000668:	10800017 	ldw	r2,0(r2)
 d00066c:	11c00317 	ldw	r7,12(r2)
 d000670:	01034174 	movhi	r4,3333
 d000674:	2132e804 	addi	r4,r4,-13408
 d000678:	01400044 	movi	r5,1
 d00067c:	01800904 	movi	r6,36
 d000680:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 d000684:	00834174 	movhi	r2,3333
 d000688:	10922004 	addi	r2,r2,18560
 d00068c:	10800017 	ldw	r2,0(r2)
 d000690:	11c00317 	ldw	r7,12(r2)
 d000694:	01034174 	movhi	r4,3333
 d000698:	2132f204 	addi	r4,r4,-13368
 d00069c:	01400044 	movi	r5,1
 d0006a0:	01800a04 	movi	r6,40
 d0006a4:	d0024a00 	call	d0024a0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 d0006a8:	d00e5280 	call	d00e528 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 d0006ac:	01003fc4 	movi	r4,255
 d0006b0:	d0145e40 	call	d0145e4 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 d0006b4:	e13ffc03 	ldbu	r4,-16(fp)
 d0006b8:	000b883a 	mov	r5,zero
 d0006bc:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
         break;
 d0006c0:	00004806 	br	d0007e4 <alt_uCOSIIErrorHandler+0x60c>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 d0006c4:	01034174 	movhi	r4,3333
 d0006c8:	2132fd04 	addi	r4,r4,-13324
 d0006cc:	d0028a00 	call	d0028a0 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 d0006d0:	00834174 	movhi	r2,3333
 d0006d4:	10922004 	addi	r2,r2,18560
 d0006d8:	10800017 	ldw	r2,0(r2)
 d0006dc:	11c00317 	ldw	r7,12(r2)
 d0006e0:	01034174 	movhi	r4,3333
 d0006e4:	21330b04 	addi	r4,r4,-13268
 d0006e8:	01400044 	movi	r5,1
 d0006ec:	01800984 	movi	r6,38
 d0006f0:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 d0006f4:	00834174 	movhi	r2,3333
 d0006f8:	10922004 	addi	r2,r2,18560
 d0006fc:	10800017 	ldw	r2,0(r2)
 d000700:	11c00317 	ldw	r7,12(r2)
 d000704:	01034174 	movhi	r4,3333
 d000708:	21331504 	addi	r4,r4,-13228
 d00070c:	01400044 	movi	r5,1
 d000710:	01800bc4 	movi	r6,47
 d000714:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 d000718:	00834174 	movhi	r2,3333
 d00071c:	10922004 	addi	r2,r2,18560
 d000720:	10800017 	ldw	r2,0(r2)
 d000724:	11c00317 	ldw	r7,12(r2)
 d000728:	01034174 	movhi	r4,3333
 d00072c:	21332104 	addi	r4,r4,-13180
 d000730:	01400044 	movi	r5,1
 d000734:	01800cc4 	movi	r6,51
 d000738:	d0024a00 	call	d0024a0 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 d00073c:	003fff06 	br	d00073c <alt_uCOSIIErrorHandler+0x564>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 d000740:	00834174 	movhi	r2,3333
 d000744:	10922004 	addi	r2,r2,18560
 d000748:	10800017 	ldw	r2,0(r2)
 d00074c:	11c00317 	ldw	r7,12(r2)
 d000750:	01034174 	movhi	r4,3333
 d000754:	21332e04 	addi	r4,r4,-13128
 d000758:	01400044 	movi	r5,1
 d00075c:	01800904 	movi	r6,36
 d000760:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 d000764:	00834174 	movhi	r2,3333
 d000768:	10922004 	addi	r2,r2,18560
 d00076c:	10800017 	ldw	r2,0(r2)
 d000770:	11c00317 	ldw	r7,12(r2)
 d000774:	01034174 	movhi	r4,3333
 d000778:	21333804 	addi	r4,r4,-13088
 d00077c:	01400044 	movi	r5,1
 d000780:	01800c84 	movi	r6,50
 d000784:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, 
 d000788:	00834174 	movhi	r2,3333
 d00078c:	10922004 	addi	r2,r2,18560
 d000790:	10800017 	ldw	r2,0(r2)
 d000794:	11c00317 	ldw	r7,12(r2)
 d000798:	01034174 	movhi	r4,3333
 d00079c:	21334504 	addi	r4,r4,-13036
 d0007a0:	01400044 	movi	r5,1
 d0007a4:	01800f84 	movi	r6,62
 d0007a8:	d0024a00 	call	d0024a0 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 d0007ac:	d00e5280 	call	d00e528 <OSSchedUnlock>
         return;   
 d0007b0:	00000d06 	br	d0007e8 <alt_uCOSIIErrorHandler+0x610>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 d0007b4:	01034174 	movhi	r4,3333
 d0007b8:	21335504 	addi	r4,r4,-12972
 d0007bc:	d002bc80 	call	d002bc8 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 d0007c0:	00834174 	movhi	r2,3333
 d0007c4:	10922004 	addi	r2,r2,18560
 d0007c8:	10800017 	ldw	r2,0(r2)
 d0007cc:	11c00317 	ldw	r7,12(r2)
 d0007d0:	01034174 	movhi	r4,3333
 d0007d4:	21336304 	addi	r4,r4,-12916
 d0007d8:	01400044 	movi	r5,1
 d0007dc:	01800ac4 	movi	r6,43
 d0007e0:	d0024a00 	call	d0024a0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 d0007e4:	003fff06 	br	d0007e4 <alt_uCOSIIErrorHandler+0x60c>
}
 d0007e8:	e037883a 	mov	sp,fp
 d0007ec:	dfc00117 	ldw	ra,4(sp)
 d0007f0:	df000017 	ldw	fp,0(sp)
 d0007f4:	dec00204 	addi	sp,sp,8
 d0007f8:	f800283a 	ret

0d0007fc <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 d0007fc:	defffa04 	addi	sp,sp,-24
 d000800:	dfc00515 	stw	ra,20(sp)
 d000804:	df000415 	stw	fp,16(sp)
 d000808:	df000404 	addi	fp,sp,16
 d00080c:	e17ffe15 	stw	r5,-8(fp)
 d000810:	e13ffd05 	stb	r4,-12(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 d000814:	e0bffd03 	ldbu	r2,-12(fp)
 d000818:	1005003a 	cmpeq	r2,r2,zero
 d00081c:	1000981e 	bne	r2,zero,d000a80 <alt_NetworkErrorHandler+0x284>
   {
      return;
   }

   fault_level = SYSTEM;   
 d000820:	00800084 	movi	r2,2
 d000824:	e0bffc15 	stw	r2,-16(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 d000828:	d00e49c0 	call	d00e49c <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 d00082c:	e0bffd03 	ldbu	r2,-12(fp)
 d000830:	10803fd8 	cmpnei	r2,r2,255
 d000834:	1000111e 	bne	r2,zero,d00087c <alt_NetworkErrorHandler+0x80>
   {
      fault_level = SYSTEM;
 d000838:	00800084 	movi	r2,2
 d00083c:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 d000840:	01034174 	movhi	r4,3333
 d000844:	21336e04 	addi	r4,r4,-12872
 d000848:	d0028a00 	call	d0028a0 <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 d00084c:	00834174 	movhi	r2,3333
 d000850:	10922004 	addi	r2,r2,18560
 d000854:	10800017 	ldw	r2,0(r2)
 d000858:	11000317 	ldw	r4,12(r2)
 d00085c:	e1bffe17 	ldw	r6,-8(fp)
 d000860:	01434174 	movhi	r5,3333
 d000864:	29737d04 	addi	r5,r5,-12812
 d000868:	d0023940 	call	d002394 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 d00086c:	01034174 	movhi	r4,3333
 d000870:	21338104 	addi	r4,r4,-12796
 d000874:	d00288c0 	call	d00288c <perror>
 d000878:	00001006 	br	d0008bc <alt_NetworkErrorHandler+0xc0>
   }
   else 
   {
      fault_level = TASK;
 d00087c:	00800044 	movi	r2,1
 d000880:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR.\n");    
 d000884:	01034174 	movhi	r4,3333
 d000888:	21338704 	addi	r4,r4,-12772
 d00088c:	d002bc80 	call	d002bc8 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 d000890:	00834174 	movhi	r2,3333
 d000894:	10922004 	addi	r2,r2,18560
 d000898:	10800017 	ldw	r2,0(r2)
 d00089c:	11000317 	ldw	r4,12(r2)
 d0008a0:	e1bffd03 	ldbu	r6,-12(fp)
 d0008a4:	01434174 	movhi	r5,3333
 d0008a8:	29738d04 	addi	r5,r5,-12748
 d0008ac:	d0023940 	call	d002394 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 d0008b0:	01034174 	movhi	r4,3333
 d0008b4:	21338104 	addi	r4,r4,-12796
 d0008b8:	d00288c0 	call	d00288c <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 d0008bc:	e0bffc17 	ldw	r2,-16(fp)
 d0008c0:	e0bfff15 	stw	r2,-4(fp)
 d0008c4:	e0ffff17 	ldw	r3,-4(fp)
 d0008c8:	18800060 	cmpeqi	r2,r3,1
 d0008cc:	1000071e 	bne	r2,zero,d0008ec <alt_NetworkErrorHandler+0xf0>
 d0008d0:	e0ffff17 	ldw	r3,-4(fp)
 d0008d4:	18800070 	cmpltui	r2,r3,1
 d0008d8:	10003f1e 	bne	r2,zero,d0009d8 <alt_NetworkErrorHandler+0x1dc>
 d0008dc:	e0ffff17 	ldw	r3,-4(fp)
 d0008e0:	188000a0 	cmpeqi	r2,r3,2
 d0008e4:	10001d1e 	bne	r2,zero,d00095c <alt_NetworkErrorHandler+0x160>
 d0008e8:	00005806 	br	d000a4c <alt_NetworkErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 d0008ec:	01034174 	movhi	r4,3333
 d0008f0:	21339404 	addi	r4,r4,-12720
 d0008f4:	d0028a00 	call	d0028a0 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 d0008f8:	00834174 	movhi	r2,3333
 d0008fc:	10922004 	addi	r2,r2,18560
 d000900:	10800017 	ldw	r2,0(r2)
 d000904:	11c00317 	ldw	r7,12(r2)
 d000908:	01034174 	movhi	r4,3333
 d00090c:	2133a004 	addi	r4,r4,-12672
 d000910:	01400044 	movi	r5,1
 d000914:	018007c4 	movi	r6,31
 d000918:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 d00091c:	00834174 	movhi	r2,3333
 d000920:	10922004 	addi	r2,r2,18560
 d000924:	10800017 	ldw	r2,0(r2)
 d000928:	11c00317 	ldw	r7,12(r2)
 d00092c:	01034174 	movhi	r4,3333
 d000930:	2133a804 	addi	r4,r4,-12640
 d000934:	01400044 	movi	r5,1
 d000938:	018008c4 	movi	r6,35
 d00093c:	d0024a00 	call	d0024a0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 d000940:	d00e5280 	call	d00e528 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 d000944:	01003fc4 	movi	r4,255
 d000948:	d0145e40 	call	d0145e4 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 d00094c:	e13ffd03 	ldbu	r4,-12(fp)
 d000950:	000b883a 	mov	r5,zero
 d000954:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
         break;
 d000958:	00004806 	br	d000a7c <alt_NetworkErrorHandler+0x280>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 d00095c:	01034174 	movhi	r4,3333
 d000960:	2133b104 	addi	r4,r4,-12604
 d000964:	d0028a00 	call	d0028a0 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 d000968:	00834174 	movhi	r2,3333
 d00096c:	10922004 	addi	r2,r2,18560
 d000970:	10800017 	ldw	r2,0(r2)
 d000974:	11c00317 	ldw	r7,12(r2)
 d000978:	01034174 	movhi	r4,3333
 d00097c:	2133bd04 	addi	r4,r4,-12556
 d000980:	01400044 	movi	r5,1
 d000984:	01800884 	movi	r6,34
 d000988:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 d00098c:	00834174 	movhi	r2,3333
 d000990:	10922004 	addi	r2,r2,18560
 d000994:	10800017 	ldw	r2,0(r2)
 d000998:	11c00317 	ldw	r7,12(r2)
 d00099c:	01034174 	movhi	r4,3333
 d0009a0:	2133c604 	addi	r4,r4,-12520
 d0009a4:	01400044 	movi	r5,1
 d0009a8:	01800a84 	movi	r6,42
 d0009ac:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 d0009b0:	00834174 	movhi	r2,3333
 d0009b4:	10922004 	addi	r2,r2,18560
 d0009b8:	10800017 	ldw	r2,0(r2)
 d0009bc:	11c00317 	ldw	r7,12(r2)
 d0009c0:	01034174 	movhi	r4,3333
 d0009c4:	2133d104 	addi	r4,r4,-12476
 d0009c8:	01400044 	movi	r5,1
 d0009cc:	01800b84 	movi	r6,46
 d0009d0:	d0024a00 	call	d0024a0 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 d0009d4:	003fff06 	br	d0009d4 <alt_NetworkErrorHandler+0x1d8>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 d0009d8:	00834174 	movhi	r2,3333
 d0009dc:	10922004 	addi	r2,r2,18560
 d0009e0:	10800017 	ldw	r2,0(r2)
 d0009e4:	11c00317 	ldw	r7,12(r2)
 d0009e8:	01034174 	movhi	r4,3333
 d0009ec:	2133dd04 	addi	r4,r4,-12428
 d0009f0:	01400044 	movi	r5,1
 d0009f4:	01800804 	movi	r6,32
 d0009f8:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 d0009fc:	00834174 	movhi	r2,3333
 d000a00:	10922004 	addi	r2,r2,18560
 d000a04:	10800017 	ldw	r2,0(r2)
 d000a08:	11c00317 	ldw	r7,12(r2)
 d000a0c:	01034174 	movhi	r4,3333
 d000a10:	2133e604 	addi	r4,r4,-12392
 d000a14:	01400044 	movi	r5,1
 d000a18:	01800d84 	movi	r6,54
 d000a1c:	d0024a00 	call	d0024a0 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 d000a20:	00834174 	movhi	r2,3333
 d000a24:	10922004 	addi	r2,r2,18560
 d000a28:	10800017 	ldw	r2,0(r2)
 d000a2c:	11c00317 	ldw	r7,12(r2)
 d000a30:	01034174 	movhi	r4,3333
 d000a34:	2133f404 	addi	r4,r4,-12336
 d000a38:	01400044 	movi	r5,1
 d000a3c:	01800e44 	movi	r6,57
 d000a40:	d0024a00 	call	d0024a0 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 d000a44:	d00e5280 	call	d00e528 <OSSchedUnlock>
         return;
 d000a48:	00000d06 	br	d000a80 <alt_NetworkErrorHandler+0x284>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 d000a4c:	01034174 	movhi	r4,3333
 d000a50:	21340304 	addi	r4,r4,-12276
 d000a54:	d002bc80 	call	d002bc8 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 d000a58:	00834174 	movhi	r2,3333
 d000a5c:	10922004 	addi	r2,r2,18560
 d000a60:	10800017 	ldw	r2,0(r2)
 d000a64:	11c00317 	ldw	r7,12(r2)
 d000a68:	01034174 	movhi	r4,3333
 d000a6c:	21341004 	addi	r4,r4,-12224
 d000a70:	01400044 	movi	r5,1
 d000a74:	01800984 	movi	r6,38
 d000a78:	d0024a00 	call	d0024a0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 d000a7c:	003fff06 	br	d000a7c <alt_NetworkErrorHandler+0x280>
}
 d000a80:	e037883a 	mov	sp,fp
 d000a84:	dfc00117 	ldw	ra,4(sp)
 d000a88:	df000017 	ldw	fp,0(sp)
 d000a8c:	dec00204 	addi	sp,sp,8
 d000a90:	f800283a 	ret

0d000a94 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 d000a94:	defff804 	addi	sp,sp,-32
 d000a98:	dfc00715 	stw	ra,28(sp)
 d000a9c:	df000615 	stw	fp,24(sp)
 d000aa0:	df000604 	addi	fp,sp,24
 d000aa4:	e17ffc15 	stw	r5,-16(fp)
 d000aa8:	e13ffb05 	stb	r4,-20(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 d000aac:	e0bffb03 	ldbu	r2,-20(fp)
 d000ab0:	1005003a 	cmpeq	r2,r2,zero
 d000ab4:	1000ad1e 	bne	r2,zero,d000d6c <alt_SSSErrorHandler+0x2d8>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 d000ab8:	e0bffb03 	ldbu	r2,-20(fp)
 d000abc:	1004c03a 	cmpne	r2,r2,zero
 d000ac0:	1000021e 	bne	r2,zero,d000acc <alt_SSSErrorHandler+0x38>
 d000ac4:	e03ffe15 	stw	zero,-8(fp)
 d000ac8:	00000206 	br	d000ad4 <alt_SSSErrorHandler+0x40>
 d000acc:	00800084 	movi	r2,2
 d000ad0:	e0bffe15 	stw	r2,-8(fp)
 d000ad4:	e0fffe17 	ldw	r3,-8(fp)
 d000ad8:	e0fffa15 	stw	r3,-24(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 d000adc:	d00e49c0 	call	d00e49c <OSSchedLock>
   switch (error_code)
 d000ae0:	e0bffb03 	ldbu	r2,-20(fp)
 d000ae4:	e0bffd15 	stw	r2,-12(fp)
 d000ae8:	e0fffd17 	ldw	r3,-12(fp)
 d000aec:	188007a0 	cmpeqi	r2,r3,30
 d000af0:	1000121e 	bne	r2,zero,d000b3c <alt_SSSErrorHandler+0xa8>
 d000af4:	e0fffd17 	ldw	r3,-12(fp)
 d000af8:	18803fe0 	cmpeqi	r2,r3,255
 d000afc:	1000011e 	bne	r2,zero,d000b04 <alt_SSSErrorHandler+0x70>
 d000b00:	00001906 	br	d000b68 <alt_SSSErrorHandler+0xd4>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 d000b04:	00800084 	movi	r2,2
 d000b08:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 d000b0c:	01034174 	movhi	r4,3333
 d000b10:	21341a04 	addi	r4,r4,-12184
 d000b14:	d0028a00 	call	d0028a0 <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 d000b18:	00834174 	movhi	r2,3333
 d000b1c:	10922004 	addi	r2,r2,18560
 d000b20:	10800017 	ldw	r2,0(r2)
 d000b24:	11000317 	ldw	r4,12(r2)
 d000b28:	e1bffc17 	ldw	r6,-16(fp)
 d000b2c:	01434174 	movhi	r5,3333
 d000b30:	29742804 	addi	r5,r5,-12128
 d000b34:	d0023940 	call	d002394 <fprintf>
         break;
 d000b38:	00001b06 	br	d000ba8 <alt_SSSErrorHandler+0x114>
         
      case OS_Q_FULL:
         fault_level = NONE;
 d000b3c:	e03ffa15 	stw	zero,-24(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 d000b40:	00834174 	movhi	r2,3333
 d000b44:	10922004 	addi	r2,r2,18560
 d000b48:	10800017 	ldw	r2,0(r2)
 d000b4c:	11c00317 	ldw	r7,12(r2)
 d000b50:	01034174 	movhi	r4,3333
 d000b54:	21342b04 	addi	r4,r4,-12116
 d000b58:	01400044 	movi	r5,1
 d000b5c:	01800c84 	movi	r6,50
 d000b60:	d0024a00 	call	d0024a0 <fwrite>
         break;
 d000b64:	00001006 	br	d000ba8 <alt_SSSErrorHandler+0x114>
      
      default:
         fault_level = SYSTEM;
 d000b68:	00800084 	movi	r2,2
 d000b6c:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR.\n");    
 d000b70:	01034174 	movhi	r4,3333
 d000b74:	21343804 	addi	r4,r4,-12064
 d000b78:	d002bc80 	call	d002bc8 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 d000b7c:	00834174 	movhi	r2,3333
 d000b80:	10922004 	addi	r2,r2,18560
 d000b84:	10800017 	ldw	r2,0(r2)
 d000b88:	11000317 	ldw	r4,12(r2)
 d000b8c:	e1bffb03 	ldbu	r6,-20(fp)
 d000b90:	01434174 	movhi	r5,3333
 d000b94:	29743d04 	addi	r5,r5,-12044
 d000b98:	d0023940 	call	d002394 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 d000b9c:	01034174 	movhi	r4,3333
 d000ba0:	21344304 	addi	r4,r4,-12020
 d000ba4:	d00288c0 	call	d00288c <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 d000ba8:	e0bffa17 	ldw	r2,-24(fp)
 d000bac:	e0bfff15 	stw	r2,-4(fp)
 d000bb0:	e0ffff17 	ldw	r3,-4(fp)
 d000bb4:	18800060 	cmpeqi	r2,r3,1
 d000bb8:	1000071e 	bne	r2,zero,d000bd8 <alt_SSSErrorHandler+0x144>
 d000bbc:	e0ffff17 	ldw	r3,-4(fp)
 d000bc0:	18800070 	cmpltui	r2,r3,1
 d000bc4:	10003f1e 	bne	r2,zero,d000cc4 <alt_SSSErrorHandler+0x230>
 d000bc8:	e0ffff17 	ldw	r3,-4(fp)
 d000bcc:	188000a0 	cmpeqi	r2,r3,2
 d000bd0:	10001d1e 	bne	r2,zero,d000c48 <alt_SSSErrorHandler+0x1b4>
 d000bd4:	00005806 	br	d000d38 <alt_SSSErrorHandler+0x2a4>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 d000bd8:	01034174 	movhi	r4,3333
 d000bdc:	21344804 	addi	r4,r4,-12000
 d000be0:	d0028a00 	call	d0028a0 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 d000be4:	00834174 	movhi	r2,3333
 d000be8:	10922004 	addi	r2,r2,18560
 d000bec:	10800017 	ldw	r2,0(r2)
 d000bf0:	11c00317 	ldw	r7,12(r2)
 d000bf4:	01034174 	movhi	r4,3333
 d000bf8:	21345304 	addi	r4,r4,-11956
 d000bfc:	01400044 	movi	r5,1
 d000c00:	018006c4 	movi	r6,27
 d000c04:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 d000c08:	00834174 	movhi	r2,3333
 d000c0c:	10922004 	addi	r2,r2,18560
 d000c10:	10800017 	ldw	r2,0(r2)
 d000c14:	11c00317 	ldw	r7,12(r2)
 d000c18:	01034174 	movhi	r4,3333
 d000c1c:	21345a04 	addi	r4,r4,-11928
 d000c20:	01400044 	movi	r5,1
 d000c24:	018007c4 	movi	r6,31
 d000c28:	d0024a00 	call	d0024a0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 d000c2c:	d00e5280 	call	d00e528 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 d000c30:	01003fc4 	movi	r4,255
 d000c34:	d0145e40 	call	d0145e4 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 d000c38:	e13ffb03 	ldbu	r4,-20(fp)
 d000c3c:	000b883a 	mov	r5,zero
 d000c40:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
         break;
 d000c44:	00004806 	br	d000d68 <alt_SSSErrorHandler+0x2d4>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 d000c48:	01034174 	movhi	r4,3333
 d000c4c:	21346204 	addi	r4,r4,-11896
 d000c50:	d0028a00 	call	d0028a0 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 d000c54:	00834174 	movhi	r2,3333
 d000c58:	10922004 	addi	r2,r2,18560
 d000c5c:	10800017 	ldw	r2,0(r2)
 d000c60:	11c00317 	ldw	r7,12(r2)
 d000c64:	01034174 	movhi	r4,3333
 d000c68:	21346d04 	addi	r4,r4,-11852
 d000c6c:	01400044 	movi	r5,1
 d000c70:	01800784 	movi	r6,30
 d000c74:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 d000c78:	00834174 	movhi	r2,3333
 d000c7c:	10922004 	addi	r2,r2,18560
 d000c80:	10800017 	ldw	r2,0(r2)
 d000c84:	11c00317 	ldw	r7,12(r2)
 d000c88:	01034174 	movhi	r4,3333
 d000c8c:	21347504 	addi	r4,r4,-11820
 d000c90:	01400044 	movi	r5,1
 d000c94:	01800984 	movi	r6,38
 d000c98:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 d000c9c:	00834174 	movhi	r2,3333
 d000ca0:	10922004 	addi	r2,r2,18560
 d000ca4:	10800017 	ldw	r2,0(r2)
 d000ca8:	11c00317 	ldw	r7,12(r2)
 d000cac:	01034174 	movhi	r4,3333
 d000cb0:	21347f04 	addi	r4,r4,-11780
 d000cb4:	01400044 	movi	r5,1
 d000cb8:	01800a84 	movi	r6,42
 d000cbc:	d0024a00 	call	d0024a0 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 d000cc0:	003fff06 	br	d000cc0 <alt_SSSErrorHandler+0x22c>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 d000cc4:	00834174 	movhi	r2,3333
 d000cc8:	10922004 	addi	r2,r2,18560
 d000ccc:	10800017 	ldw	r2,0(r2)
 d000cd0:	11c00317 	ldw	r7,12(r2)
 d000cd4:	01034174 	movhi	r4,3333
 d000cd8:	21348a04 	addi	r4,r4,-11736
 d000cdc:	01400044 	movi	r5,1
 d000ce0:	018006c4 	movi	r6,27
 d000ce4:	d0024a00 	call	d0024a0 <fwrite>
         fprintf(stderr, 
 d000ce8:	00834174 	movhi	r2,3333
 d000cec:	10922004 	addi	r2,r2,18560
 d000cf0:	10800017 	ldw	r2,0(r2)
 d000cf4:	11c00317 	ldw	r7,12(r2)
 d000cf8:	01034174 	movhi	r4,3333
 d000cfc:	21349104 	addi	r4,r4,-11708
 d000d00:	01400044 	movi	r5,1
 d000d04:	01800f44 	movi	r6,61
 d000d08:	d0024a00 	call	d0024a0 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 d000d0c:	00834174 	movhi	r2,3333
 d000d10:	10922004 	addi	r2,r2,18560
 d000d14:	10800017 	ldw	r2,0(r2)
 d000d18:	11c00317 	ldw	r7,12(r2)
 d000d1c:	01034174 	movhi	r4,3333
 d000d20:	2134a104 	addi	r4,r4,-11644
 d000d24:	01400044 	movi	r5,1
 d000d28:	01800b84 	movi	r6,46
 d000d2c:	d0024a00 	call	d0024a0 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 d000d30:	d00e5280 	call	d00e528 <OSSchedUnlock>
         return;         
 d000d34:	00000d06 	br	d000d6c <alt_SSSErrorHandler+0x2d8>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 d000d38:	01034174 	movhi	r4,3333
 d000d3c:	2134ad04 	addi	r4,r4,-11596
 d000d40:	d002bc80 	call	d002bc8 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 d000d44:	00834174 	movhi	r2,3333
 d000d48:	10922004 	addi	r2,r2,18560
 d000d4c:	10800017 	ldw	r2,0(r2)
 d000d50:	11c00317 	ldw	r7,12(r2)
 d000d54:	01034174 	movhi	r4,3333
 d000d58:	2134b904 	addi	r4,r4,-11548
 d000d5c:	01400044 	movi	r5,1
 d000d60:	01800844 	movi	r6,33
 d000d64:	d0024a00 	call	d0024a0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 d000d68:	003fff06 	br	d000d68 <alt_SSSErrorHandler+0x2d4>
}
 d000d6c:	e037883a 	mov	sp,fp
 d000d70:	dfc00117 	ldw	ra,4(sp)
 d000d74:	df000017 	ldw	fp,0(sp)
 d000d78:	dec00204 	addi	sp,sp,8
 d000d7c:	f800283a 	ret

0d000d80 <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 d000d80:	defffc04 	addi	sp,sp,-16
 d000d84:	dfc00315 	stw	ra,12(sp)
 d000d88:	df000215 	stw	fp,8(sp)
 d000d8c:	df000204 	addi	fp,sp,8
 d000d90:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 d000d94:	d0261780 	call	d026178 <alt_iniche_init>
  netmain(); 
 d000d98:	d0210480 	call	d021048 <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 d000d9c:	00000206 	br	d000da8 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 d000da0:	01000084 	movi	r4,2
 d000da4:	d0156dc0 	call	d0156dc <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 d000da8:	00834174 	movhi	r2,3333
 d000dac:	109b2904 	addi	r2,r2,27812
 d000db0:	10800017 	ldw	r2,0(r2)
 d000db4:	1005003a 	cmpeq	r2,r2,zero
 d000db8:	103ff91e 	bne	r2,zero,d000da0 <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 d000dbc:	01034174 	movhi	r4,3333
 d000dc0:	2134c804 	addi	r4,r4,-11488
 d000dc4:	d002bc80 	call	d002bc8 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 d000dc8:	01034174 	movhi	r4,3333
 d000dcc:	2109f604 	addi	r4,r4,10200
 d000dd0:	d025e380 	call	d025e38 <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 d000dd4:	d0019f40 	call	d0019f4 <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 d000dd8:	d001a9c0 	call	d001a9c <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 d000ddc:	01003fc4 	movi	r4,255
 d000de0:	d0145e40 	call	d0145e4 <OSTaskDel>
 d000de4:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 d000de8:	e13ffe03 	ldbu	r4,-8(fp)
 d000dec:	000b883a 	mov	r5,zero
 d000df0:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 d000df4:	003fff06 	br	d000df4 <SSSInitialTask+0x74>

0d000df8 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 d000df8:	defff504 	addi	sp,sp,-44
 d000dfc:	dfc00a15 	stw	ra,40(sp)
 d000e00:	df000915 	stw	fp,36(sp)
 d000e04:	df000904 	addi	fp,sp,36
 d000e08:	e13ffd15 	stw	r4,-12(fp)
 d000e0c:	e17ffe15 	stw	r5,-8(fp)
 d000e10:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 d000e14:	0009883a 	mov	r4,zero
 d000e18:	d015c2c0 	call	d015c2c <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 d000e1c:	018341b4 	movhi	r6,3334
 d000e20:	31a51e04 	addi	r6,r6,-27528
 d000e24:	00800144 	movi	r2,5
 d000e28:	d8800015 	stw	r2,0(sp)
 d000e2c:	00834174 	movhi	r2,3333
 d000e30:	109d1e04 	addi	r2,r2,29816
 d000e34:	d8800115 	stw	r2,4(sp)
 d000e38:	00820004 	movi	r2,2048
 d000e3c:	d8800215 	stw	r2,8(sp)
 d000e40:	d8000315 	stw	zero,12(sp)
 d000e44:	d8000415 	stw	zero,16(sp)
 d000e48:	01034034 	movhi	r4,3328
 d000e4c:	21036004 	addi	r4,r4,3456
 d000e50:	000b883a 	mov	r5,zero
 d000e54:	01c00144 	movi	r7,5
 d000e58:	d0143e40 	call	d0143e4 <OSTaskCreateExt>
 d000e5c:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 d000e60:	e13ffc03 	ldbu	r4,-16(fp)
 d000e64:	000b883a 	mov	r5,zero
 d000e68:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 d000e6c:	d00e60c0 	call	d00e60c <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 d000e70:	003fff06 	br	d000e70 <main+0x78>

0d000e74 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 d000e74:	defffc04 	addi	sp,sp,-16
 d000e78:	dfc00315 	stw	ra,12(sp)
 d000e7c:	df000215 	stw	fp,8(sp)
 d000e80:	df000204 	addi	fp,sp,8
 d000e84:	e13fff0d 	sth	r4,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 d000e88:	00834174 	movhi	r2,3333
 d000e8c:	109afa04 	addi	r2,r2,27624
 d000e90:	11000017 	ldw	r4,0(r2)
 d000e94:	e17ffe84 	addi	r5,fp,-6
 d000e98:	d01105c0 	call	d01105c <OSFlagQuery>
 d000e9c:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 d000ea0:	e0bffe83 	ldbu	r2,-6(fp)
 d000ea4:	11003fcc 	andi	r4,r2,255
 d000ea8:	000b883a 	mov	r5,zero
 d000eac:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 d000eb0:	e0ffff0b 	ldhu	r3,-4(fp)
 d000eb4:	e0bffe0b 	ldhu	r2,-8(fp)
 d000eb8:	1884703a 	and	r2,r3,r2
 d000ebc:	10bfffcc 	andi	r2,r2,65535
 d000ec0:	1005003a 	cmpeq	r2,r2,zero
 d000ec4:	10000d1e 	bne	r2,zero,d000efc <led_bit_toggle+0x88>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 d000ec8:	00834174 	movhi	r2,3333
 d000ecc:	109afa04 	addi	r2,r2,27624
 d000ed0:	11000017 	ldw	r4,0(r2)
 d000ed4:	e17fff0b 	ldhu	r5,-4(fp)
 d000ed8:	e1fffe84 	addi	r7,fp,-6
 d000edc:	000d883a 	mov	r6,zero
 d000ee0:	d010cb40 	call	d010cb4 <OSFlagPost>
 d000ee4:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 d000ee8:	e0bffe83 	ldbu	r2,-6(fp)
 d000eec:	11003fcc 	andi	r4,r2,255
 d000ef0:	000b883a 	mov	r5,zero
 d000ef4:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
 d000ef8:	00000c06 	br	d000f2c <led_bit_toggle+0xb8>
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 d000efc:	00834174 	movhi	r2,3333
 d000f00:	109afa04 	addi	r2,r2,27624
 d000f04:	11000017 	ldw	r4,0(r2)
 d000f08:	e17fff0b 	ldhu	r5,-4(fp)
 d000f0c:	e1fffe84 	addi	r7,fp,-6
 d000f10:	01800044 	movi	r6,1
 d000f14:	d010cb40 	call	d010cb4 <OSFlagPost>
 d000f18:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 d000f1c:	e0bffe83 	ldbu	r2,-6(fp)
 d000f20:	11003fcc 	andi	r4,r2,255
 d000f24:	000b883a 	mov	r5,zero
 d000f28:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
    }
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
 d000f2c:	e0fffe0b 	ldhu	r3,-8(fp)
 d000f30:	00800404 	movi	r2,16
 d000f34:	10c00035 	stwio	r3,0(r2)
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
 d000f38:	e0bffe0b 	ldhu	r2,-8(fp)
 d000f3c:	11403fcc 	andi	r5,r2,255
 d000f40:	01034174 	movhi	r4,3333
 d000f44:	2134d104 	addi	r4,r4,-11452
 d000f48:	d0028a00 	call	d0028a0 <printf>
    #endif
      
    return;
}
 d000f4c:	e037883a 	mov	sp,fp
 d000f50:	dfc00117 	ldw	ra,4(sp)
 d000f54:	df000017 	ldw	fp,0(sp)
 d000f58:	dec00204 	addi	sp,sp,8
 d000f5c:	f800283a 	ret

0d000f60 <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 d000f60:	defffd04 	addi	sp,sp,-12
 d000f64:	dfc00215 	stw	ra,8(sp)
 d000f68:	df000115 	stw	fp,4(sp)
 d000f6c:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 d000f70:	0009883a 	mov	r4,zero
 d000f74:	000b883a 	mov	r5,zero
 d000f78:	000d883a 	mov	r6,zero
 d000f7c:	01c00c84 	movi	r7,50
 d000f80:	d0158280 	call	d015828 <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 d000f84:	00834174 	movhi	r2,3333
 d000f88:	109af904 	addi	r2,r2,27620
 d000f8c:	11000017 	ldw	r4,0(r2)
 d000f90:	e1bfff84 	addi	r6,fp,-2
 d000f94:	000b883a 	mov	r5,zero
 d000f98:	d0135480 	call	d013548 <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 d000f9c:	e0bfff83 	ldbu	r2,-2(fp)
 d000fa0:	11003fcc 	andi	r4,r2,255
 d000fa4:	000b883a 	mov	r5,zero
 d000fa8:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 d000fac:	00834174 	movhi	r2,3333
 d000fb0:	109af904 	addi	r2,r2,27620
 d000fb4:	11000017 	ldw	r4,0(r2)
 d000fb8:	d0139400 	call	d013940 <OSSemPost>
 d000fbc:	e0bfff85 	stb	r2,-2(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 d000fc0:	e0bfff83 	ldbu	r2,-2(fp)
 d000fc4:	11003fcc 	andi	r4,r2,255
 d000fc8:	000b883a 	mov	r5,zero
 d000fcc:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
      
   }
 d000fd0:	003fe706 	br	d000f70 <LED7SegLightshowTask+0x10>

0d000fd4 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 d000fd4:	defffa04 	addi	sp,sp,-24
 d000fd8:	dfc00515 	stw	ra,20(sp)
 d000fdc:	df000415 	stw	fp,16(sp)
 d000fe0:	df000404 	addi	fp,sp,16
  INT32U led_command; 
  INT16U led_7_seg_val;
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  led_7_seg_val = 0;
 d000fe4:	e03ffc8d 	sth	zero,-14(fp)
  SSSLEDLightshowActive = OS_TRUE;
 d000fe8:	00800044 	movi	r2,1
 d000fec:	e0bffc05 	stb	r2,-16(fp)
 d000ff0:	00000006 	br	d000ff4 <LEDManagementTask+0x20>
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 d000ff4:	00834174 	movhi	r2,3333
 d000ff8:	109af804 	addi	r2,r2,27616
 d000ffc:	11000017 	ldw	r4,0(r2)
 d001000:	e1bffe04 	addi	r6,fp,-8
 d001004:	000b883a 	mov	r5,zero
 d001008:	d0124d00 	call	d0124d0 <OSQPend>
 d00100c:	e0bffd15 	stw	r2,-12(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 d001010:	e0bffe03 	ldbu	r2,-8(fp)
 d001014:	11003fcc 	andi	r4,r2,255
 d001018:	000b883a 	mov	r5,zero
 d00101c:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 d001020:	e0bffd17 	ldw	r2,-12(fp)
 d001024:	10bff404 	addi	r2,r2,-48
 d001028:	e0bfff15 	stw	r2,-4(fp)
 d00102c:	e0ffff17 	ldw	r3,-4(fp)
 d001030:	18800928 	cmpgeui	r2,r3,36
 d001034:	103fef1e 	bne	r2,zero,d000ff4 <LEDManagementTask+0x20>
 d001038:	e13fff17 	ldw	r4,-4(fp)
 d00103c:	e13fff17 	ldw	r4,-4(fp)
 d001040:	2105883a 	add	r2,r4,r4
 d001044:	1087883a 	add	r3,r2,r2
 d001048:	00834034 	movhi	r2,3328
 d00104c:	10841704 	addi	r2,r2,4188
 d001050:	1885883a 	add	r2,r3,r2
 d001054:	10800017 	ldw	r2,0(r2)
 d001058:	1000683a 	jmp	r2
 d00105c:	0d0010ec 	andhi	r20,at,67
 d001060:	0d0010f8 	rdprs	r20,at,67
 d001064:	0d001104 	addi	r20,at,68
 d001068:	0d001110 	cmplti	r20,at,68
 d00106c:	0d00111c 	xori	r20,at,68
 d001070:	0d001128 	cmpgeui	r20,at,68
 d001074:	0d001134 	orhi	r20,at,68
 d001078:	0d001140 	call	d00114 <__ram_exceptions_end+0xc7ff18>
 d00107c:	0d000ff4 	orhi	r20,at,63
 d001080:	0d000ff4 	orhi	r20,at,63
 d001084:	0d000ff4 	orhi	r20,at,63
 d001088:	0d000ff4 	orhi	r20,at,63
 d00108c:	0d000ff4 	orhi	r20,at,63
 d001090:	0d000ff4 	orhi	r20,at,63
 d001094:	0d000ff4 	orhi	r20,at,63
 d001098:	0d000ff4 	orhi	r20,at,63
 d00109c:	0d000ff4 	orhi	r20,at,63
 d0010a0:	0d000ff4 	orhi	r20,at,63
 d0010a4:	0d000ff4 	orhi	r20,at,63
 d0010a8:	0d000ff4 	orhi	r20,at,63
 d0010ac:	0d000ff4 	orhi	r20,at,63
 d0010b0:	0d000ff4 	orhi	r20,at,63
 d0010b4:	0d000ff4 	orhi	r20,at,63
 d0010b8:	0d000ff4 	orhi	r20,at,63
 d0010bc:	0d000ff4 	orhi	r20,at,63
 d0010c0:	0d000ff4 	orhi	r20,at,63
 d0010c4:	0d000ff4 	orhi	r20,at,63
 d0010c8:	0d000ff4 	orhi	r20,at,63
 d0010cc:	0d000ff4 	orhi	r20,at,63
 d0010d0:	0d000ff4 	orhi	r20,at,63
 d0010d4:	0d000ff4 	orhi	r20,at,63
 d0010d8:	0d000ff4 	orhi	r20,at,63
 d0010dc:	0d000ff4 	orhi	r20,at,63
 d0010e0:	0d000ff4 	orhi	r20,at,63
 d0010e4:	0d000ff4 	orhi	r20,at,63
 d0010e8:	0d00114c 	andi	r20,at,69
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 d0010ec:	01000044 	movi	r4,1
 d0010f0:	d000e740 	call	d000e74 <led_bit_toggle>
         break;
 d0010f4:	003fbf06 	br	d000ff4 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 d0010f8:	01000084 	movi	r4,2
 d0010fc:	d000e740 	call	d000e74 <led_bit_toggle>
         break;   
 d001100:	003fbc06 	br	d000ff4 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 d001104:	01000104 	movi	r4,4
 d001108:	d000e740 	call	d000e74 <led_bit_toggle>
         break;
 d00110c:	003fb906 	br	d000ff4 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 d001110:	01000204 	movi	r4,8
 d001114:	d000e740 	call	d000e74 <led_bit_toggle>
         break;
 d001118:	003fb606 	br	d000ff4 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 d00111c:	01000404 	movi	r4,16
 d001120:	d000e740 	call	d000e74 <led_bit_toggle>
         break;
 d001124:	003fb306 	br	d000ff4 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 d001128:	01000804 	movi	r4,32
 d00112c:	d000e740 	call	d000e74 <led_bit_toggle>
         break;
 d001130:	003fb006 	br	d000ff4 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 d001134:	01001004 	movi	r4,64
 d001138:	d000e740 	call	d000e74 <led_bit_toggle>
         break;
 d00113c:	003fad06 	br	d000ff4 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 d001140:	01002004 	movi	r4,128
 d001144:	d000e740 	call	d000e74 <led_bit_toggle>
         break;
 d001148:	003faa06 	br	d000ff4 <LEDManagementTask+0x20>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 d00114c:	e0bffc03 	ldbu	r2,-16(fp)
 d001150:	1004c03a 	cmpne	r2,r2,zero
 d001154:	10000c1e 	bne	r2,zero,d001188 <LEDManagementTask+0x1b4>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 d001158:	00834174 	movhi	r2,3333
 d00115c:	109af904 	addi	r2,r2,27620
 d001160:	11000017 	ldw	r4,0(r2)
 d001164:	d0139400 	call	d013940 <OSSemPost>
 d001168:	e0bffe05 	stb	r2,-8(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 d00116c:	e0bffe03 	ldbu	r2,-8(fp)
 d001170:	11003fcc 	andi	r4,r2,255
 d001174:	000b883a 	mov	r5,zero
 d001178:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 d00117c:	00800044 	movi	r2,1
 d001180:	e0bffc05 	stb	r2,-16(fp)
 d001184:	003f9b06 	br	d000ff4 <LEDManagementTask+0x20>
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 d001188:	00834174 	movhi	r2,3333
 d00118c:	109af904 	addi	r2,r2,27620
 d001190:	11000017 	ldw	r4,0(r2)
 d001194:	e1bffe04 	addi	r6,fp,-8
 d001198:	000b883a 	mov	r5,zero
 d00119c:	d0135480 	call	d013548 <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 d0011a0:	e0bffe03 	ldbu	r2,-8(fp)
 d0011a4:	11003fcc 	andi	r4,r2,255
 d0011a8:	000b883a 	mov	r5,zero
 d0011ac:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 d0011b0:	e03ffc05 	stb	zero,-16(fp)
         break;
      default:     
        /* Discard unknown LED commands. */
        break;
    } /* switch led_command */
  } /* while(1) */
 d0011b4:	003f8f06 	br	d000ff4 <LEDManagementTask+0x20>

0d0011b8 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 d0011b8:	defffb04 	addi	sp,sp,-20
 d0011bc:	dfc00415 	stw	ra,16(sp)
 d0011c0:	df000315 	stw	fp,12(sp)
 d0011c4:	df000304 	addi	fp,sp,12
 d0011c8:	e13ffe15 	stw	r4,-8(fp)
 d0011cc:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 d0011d0:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 d0011d4:	e13fff17 	ldw	r4,-4(fp)
 d0011d8:	d0017540 	call	d001754 <get_board_mac_addr>
 d0011dc:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 d0011e0:	e0bffd17 	ldw	r2,-12(fp)
 d0011e4:	1005003a 	cmpeq	r2,r2,zero
 d0011e8:	1000031e 	bne	r2,zero,d0011f8 <get_mac_addr+0x40>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 d0011ec:	e13fff17 	ldw	r4,-4(fp)
 d0011f0:	d0016200 	call	d001620 <generate_mac_addr>
 d0011f4:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 d0011f8:	e0bffd17 	ldw	r2,-12(fp)
}
 d0011fc:	e037883a 	mov	sp,fp
 d001200:	dfc00117 	ldw	ra,4(sp)
 d001204:	df000017 	ldw	fp,0(sp)
 d001208:	dec00204 	addi	sp,sp,8
 d00120c:	f800283a 	ret

0d001210 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 d001210:	defffb04 	addi	sp,sp,-20
 d001214:	df000415 	stw	fp,16(sp)
 d001218:	df000404 	addi	fp,sp,16
 d00121c:	e13ffc15 	stw	r4,-16(fp)
 d001220:	e17ffd15 	stw	r5,-12(fp)
 d001224:	e1bffe15 	stw	r6,-8(fp)
 d001228:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 d00122c:	e0fffd17 	ldw	r3,-12(fp)
 d001230:	008a7734 	movhi	r2,10716
 d001234:	10876b04 	addi	r2,r2,7596
 d001238:	18800015 	stw	r2,0(r3)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 d00123c:	e0ffff17 	ldw	r3,-4(fp)
 d001240:	00807734 	movhi	r2,476
 d001244:	10876b04 	addi	r2,r2,7596
 d001248:	18800015 	stw	r2,0(r3)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 d00124c:	e0fffe17 	ldw	r3,-8(fp)
 d001250:	00804034 	movhi	r2,256
 d001254:	10bfffc4 	addi	r2,r2,-1
 d001258:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 d00125c:	e0c00117 	ldw	r3,4(fp)
 d001260:	00800044 	movi	r2,1
 d001264:	18800015 	stw	r2,0(r3)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 d001268:	00800044 	movi	r2,1
}
 d00126c:	e037883a 	mov	sp,fp
 d001270:	df000017 	ldw	fp,0(sp)
 d001274:	dec00104 	addi	sp,sp,4
 d001278:	f800283a 	ret

0d00127c <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 d00127c:	defff804 	addi	sp,sp,-32
 d001280:	dfc00715 	stw	ra,28(sp)
 d001284:	df000615 	stw	fp,24(sp)
 d001288:	dc000515 	stw	r16,20(sp)
 d00128c:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 d001290:	e03ffc15 	stw	zero,-16(fp)
    char serial_number[9];
    int i = 0;
 d001294:	e03ffb15 	stw	zero,-20(fp)
    
    while(!ser_num)
 d001298:	00006606 	br	d001434 <get_serial_number+0x1b8>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 d00129c:	01034174 	movhi	r4,3333
 d0012a0:	2134da04 	addi	r4,r4,-11416
 d0012a4:	d002bc80 	call	d002bc8 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 d0012a8:	01034174 	movhi	r4,3333
 d0012ac:	2134ea04 	addi	r4,r4,-11352
 d0012b0:	d002bc80 	call	d002bc8 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 d0012b4:	01034174 	movhi	r4,3333
 d0012b8:	2134fa04 	addi	r4,r4,-11288
 d0012bc:	d0028a00 	call	d0028a0 <printf>
        
        for(i=0; i<9; i++)
 d0012c0:	e03ffb15 	stw	zero,-20(fp)
 d0012c4:	00002806 	br	d001368 <get_serial_number+0xec>
        {
            serial_number[i] = getchar();
 d0012c8:	e43ffb17 	ldw	r16,-20(fp)
 d0012cc:	00834174 	movhi	r2,3333
 d0012d0:	10922004 	addi	r2,r2,18560
 d0012d4:	10800017 	ldw	r2,0(r2)
 d0012d8:	11000117 	ldw	r4,4(r2)
 d0012dc:	d0024e00 	call	d0024e0 <getc>
 d0012e0:	1007883a 	mov	r3,r2
 d0012e4:	e0bffd04 	addi	r2,fp,-12
 d0012e8:	1405883a 	add	r2,r2,r16
 d0012ec:	10c00005 	stb	r3,0(r2)
            putchar(serial_number[i]);
 d0012f0:	e0fffb17 	ldw	r3,-20(fp)
 d0012f4:	e0bffd04 	addi	r2,fp,-12
 d0012f8:	10c5883a 	add	r2,r2,r3
 d0012fc:	10800003 	ldbu	r2,0(r2)
 d001300:	11003fcc 	andi	r4,r2,255
 d001304:	2100201c 	xori	r4,r4,128
 d001308:	213fe004 	addi	r4,r4,-128
 d00130c:	00834174 	movhi	r2,3333
 d001310:	10922004 	addi	r2,r2,18560
 d001314:	10800017 	ldw	r2,0(r2)
 d001318:	11400217 	ldw	r5,8(r2)
 d00131c:	d0029180 	call	d002918 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 d001320:	e0fffb17 	ldw	r3,-20(fp)
 d001324:	e0bffd04 	addi	r2,fp,-12
 d001328:	10c5883a 	add	r2,r2,r3
 d00132c:	10800003 	ldbu	r2,0(r2)
 d001330:	10803fcc 	andi	r2,r2,255
 d001334:	1080201c 	xori	r2,r2,128
 d001338:	10bfe004 	addi	r2,r2,-128
 d00133c:	10800218 	cmpnei	r2,r2,8
 d001340:	1000061e 	bne	r2,zero,d00135c <get_serial_number+0xe0>
 d001344:	e0bffb17 	ldw	r2,-20(fp)
 d001348:	1004803a 	cmplt	r2,r2,zero
 d00134c:	1000031e 	bne	r2,zero,d00135c <get_serial_number+0xe0>
            {
                i--;
 d001350:	e0bffb17 	ldw	r2,-20(fp)
 d001354:	10bfffc4 	addi	r2,r2,-1
 d001358:	e0bffb15 	stw	r2,-20(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 d00135c:	e0bffb17 	ldw	r2,-20(fp)
 d001360:	10800044 	addi	r2,r2,1
 d001364:	e0bffb15 	stw	r2,-20(fp)
 d001368:	e0bffb17 	ldw	r2,-20(fp)
 d00136c:	10800250 	cmplti	r2,r2,9
 d001370:	103fd51e 	bne	r2,zero,d0012c8 <get_serial_number+0x4c>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 d001374:	01000284 	movi	r4,10
 d001378:	d002b040 	call	d002b04 <putchar>
                
        for(i=0; i<9; i++)
 d00137c:	e03ffb15 	stw	zero,-20(fp)
 d001380:	00002906 	br	d001428 <get_serial_number+0x1ac>
        {
            if (isdigit(serial_number[i]))
 d001384:	e0fffb17 	ldw	r3,-20(fp)
 d001388:	e0bffd04 	addi	r2,fp,-12
 d00138c:	10c5883a 	add	r2,r2,r3
 d001390:	10800003 	ldbu	r2,0(r2)
 d001394:	10803fcc 	andi	r2,r2,255
 d001398:	1080201c 	xori	r2,r2,128
 d00139c:	10bfe004 	addi	r2,r2,-128
 d0013a0:	1007883a 	mov	r3,r2
 d0013a4:	00834174 	movhi	r2,3333
 d0013a8:	10921f04 	addi	r2,r2,18556
 d0013ac:	10800017 	ldw	r2,0(r2)
 d0013b0:	1885883a 	add	r2,r3,r2
 d0013b4:	10800003 	ldbu	r2,0(r2)
 d0013b8:	10803fcc 	andi	r2,r2,255
 d0013bc:	1080010c 	andi	r2,r2,4
 d0013c0:	1005003a 	cmpeq	r2,r2,zero
 d0013c4:	1000131e 	bne	r2,zero,d001414 <get_serial_number+0x198>
            {
                ser_num *= 10;
 d0013c8:	e13ffc17 	ldw	r4,-16(fp)
 d0013cc:	01400284 	movi	r5,10
 d0013d0:	d00235c0 	call	d00235c <__mulsi3>
 d0013d4:	e0bffc15 	stw	r2,-16(fp)
                ser_num += serial_number[i] - '0';
 d0013d8:	e0fffb17 	ldw	r3,-20(fp)
 d0013dc:	e0bffd04 	addi	r2,fp,-12
 d0013e0:	10c5883a 	add	r2,r2,r3
 d0013e4:	10800003 	ldbu	r2,0(r2)
 d0013e8:	10c03fcc 	andi	r3,r2,255
 d0013ec:	18c0201c 	xori	r3,r3,128
 d0013f0:	18ffe004 	addi	r3,r3,-128
 d0013f4:	e0bffc17 	ldw	r2,-16(fp)
 d0013f8:	1885883a 	add	r2,r3,r2
 d0013fc:	10bff404 	addi	r2,r2,-48
 d001400:	e0bffc15 	stw	r2,-16(fp)
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 d001404:	e0bffb17 	ldw	r2,-20(fp)
 d001408:	10800044 	addi	r2,r2,1
 d00140c:	e0bffb15 	stw	r2,-20(fp)
 d001410:	00000506 	br	d001428 <get_serial_number+0x1ac>
                ser_num *= 10;
                ser_num += serial_number[i] - '0';
            }
            else
            {
                ser_num = 0;
 d001414:	e03ffc15 	stw	zero,-16(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 d001418:	01034174 	movhi	r4,3333
 d00141c:	21350804 	addi	r4,r4,-11232
 d001420:	d002bc80 	call	d002bc8 <puts>
                break;
 d001424:	00000306 	br	d001434 <get_serial_number+0x1b8>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 d001428:	e0bffb17 	ldw	r2,-20(fp)
 d00142c:	10800250 	cmplti	r2,r2,9
 d001430:	103fd41e 	bne	r2,zero,d001384 <get_serial_number+0x108>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 d001434:	e0bffc17 	ldw	r2,-16(fp)
 d001438:	1005003a 	cmpeq	r2,r2,zero
 d00143c:	103f971e 	bne	r2,zero,d00129c <get_serial_number+0x20>
                break;
            }
        }
    }
    
    return ser_num;
 d001440:	e0bffc17 	ldw	r2,-16(fp)
}
 d001444:	e037883a 	mov	sp,fp
 d001448:	dfc00217 	ldw	ra,8(sp)
 d00144c:	df000117 	ldw	fp,4(sp)
 d001450:	dc000017 	ldw	r16,0(sp)
 d001454:	dec00304 	addi	sp,sp,12
 d001458:	f800283a 	ret

0d00145c <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 d00145c:	deffef04 	addi	sp,sp,-68
 d001460:	dfc01015 	stw	ra,64(sp)
 d001464:	df000f15 	stw	fp,60(sp)
 d001468:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 d00146c:	00bfffc4 	movi	r2,-1
 d001470:	e0bff715 	stw	r2,-36(fp)
    alt_u32 ser_num = 0;
 d001474:	e03ff615 	stw	zero,-40(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 d001478:	01034174 	movhi	r4,3333
 d00147c:	21351704 	addi	r4,r4,-11172
 d001480:	d002bc80 	call	d002bc8 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 d001484:	01034174 	movhi	r4,3333
 d001488:	21352704 	addi	r4,r4,-11108
 d00148c:	d002bc80 	call	d002bc8 <puts>
    printf("static network settings\n\n");
 d001490:	01034174 	movhi	r4,3333
 d001494:	21353804 	addi	r4,r4,-11040
 d001498:	d002bc80 	call	d002bc8 <puts>
    
    ser_num = get_serial_number();
 d00149c:	d00127c0 	call	d00127c <get_serial_number>
 d0014a0:	e0bff615 	stw	r2,-40(fp)
  
    if (ser_num)
 d0014a4:	e0bff617 	ldw	r2,-40(fp)
 d0014a8:	1005003a 	cmpeq	r2,r2,zero
 d0014ac:	1000561e 	bne	r2,zero,d001608 <generate_and_store_mac_addr+0x1ac>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 d0014b0:	00bfff84 	movi	r2,-2
 d0014b4:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 d0014b8:	00801684 	movi	r2,90
 d0014bc:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 d0014c0:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 d0014c4:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 d0014c8:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 d0014cc:	008001c4 	movi	r2,7
 d0014d0:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 d0014d4:	00bffb44 	movi	r2,-19
 d0014d8:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0x19;
 d0014dc:	00800644 	movi	r2,25
 d0014e0:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = 0x06;
 d0014e4:	00800184 	movi	r2,6
 d0014e8:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = 0xa9;
 d0014ec:	00bfea44 	movi	r2,-87
 d0014f0:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 d0014f4:	00bfffc4 	movi	r2,-1
 d0014f8:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 d0014fc:	00bfffc4 	movi	r2,-1
 d001500:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 d001504:	00bfeb04 	movi	r2,-84
 d001508:	e0bffb05 	stb	r2,-20(fp)
        flash_content[13] = IPADDR1;
 d00150c:	00800744 	movi	r2,29
 d001510:	e0bffb45 	stb	r2,-19(fp)
        flash_content[14] = IPADDR2;
 d001514:	00bff704 	movi	r2,-36
 d001518:	e0bffb85 	stb	r2,-18(fp)
        flash_content[15] = IPADDR3;
 d00151c:	00800a44 	movi	r2,41
 d001520:	e0bffbc5 	stb	r2,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 d001524:	00bfffc4 	movi	r2,-1
 d001528:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 d00152c:	00bfffc4 	movi	r2,-1
 d001530:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 d001534:	00bfffc4 	movi	r2,-1
 d001538:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 d00153c:	00bfffc4 	movi	r2,-1
 d001540:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 d001544:	00bfffc4 	movi	r2,-1
 d001548:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 d00154c:	00bfffc4 	movi	r2,-1
 d001550:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 d001554:	00bfffc4 	movi	r2,-1
 d001558:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 d00155c:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 d001560:	00bfeb04 	movi	r2,-84
 d001564:	e0bffe05 	stb	r2,-8(fp)
        flash_content[25] = GWADDR1;
 d001568:	00800744 	movi	r2,29
 d00156c:	e0bffe45 	stb	r2,-7(fp)
        flash_content[26] = GWADDR2;
 d001570:	00bff704 	movi	r2,-36
 d001574:	e0bffe85 	stb	r2,-6(fp)
        flash_content[27] = GWADDR3;
 d001578:	00800044 	movi	r2,1
 d00157c:	e0bffec5 	stb	r2,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 d001580:	00bfffc4 	movi	r2,-1
 d001584:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 d001588:	00bfffc4 	movi	r2,-1
 d00158c:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 d001590:	00bfffc4 	movi	r2,-1
 d001594:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 d001598:	00bfffc4 	movi	r2,-1
 d00159c:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 d0015a0:	01034174 	movhi	r4,3333
 d0015a4:	21353f04 	addi	r4,r4,-11012
 d0015a8:	d00cfd40 	call	d00cfd4 <alt_flash_open_dev>
 d0015ac:	e0bff515 	stw	r2,-44(fp)
        if (flash_handle)
 d0015b0:	e0bff517 	ldw	r2,-44(fp)
 d0015b4:	1005003a 	cmpeq	r2,r2,zero
 d0015b8:	1000131e 	bne	r2,zero,d001608 <generate_and_store_mac_addr+0x1ac>
        {
            alt_write_flash(flash_handle,
 d0015bc:	d0a8d617 	ldw	r2,-23720(gp)
 d0015c0:	1007883a 	mov	r3,r2
 d0015c4:	e0bff517 	ldw	r2,-44(fp)
 d0015c8:	e0bff115 	stw	r2,-60(fp)
 d0015cc:	e0fff215 	stw	r3,-56(fp)
 d0015d0:	e0bff804 	addi	r2,fp,-32
 d0015d4:	e0bff315 	stw	r2,-52(fp)
 d0015d8:	00800804 	movi	r2,32
 d0015dc:	e0bff415 	stw	r2,-48(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 d0015e0:	e0bff117 	ldw	r2,-60(fp)
 d0015e4:	10800517 	ldw	r2,20(r2)
 d0015e8:	e13ff117 	ldw	r4,-60(fp)
 d0015ec:	e17ff217 	ldw	r5,-56(fp)
 d0015f0:	e1bff317 	ldw	r6,-52(fp)
 d0015f4:	e1fff417 	ldw	r7,-48(fp)
 d0015f8:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 d0015fc:	e13ff517 	ldw	r4,-44(fp)
 d001600:	d00d0500 	call	d00d050 <alt_flash_close_dev>
            error = 0;
 d001604:	e03ff715 	stw	zero,-36(fp)
        }
    }

    return error;    
 d001608:	e0bff717 	ldw	r2,-36(fp)
}
 d00160c:	e037883a 	mov	sp,fp
 d001610:	dfc00117 	ldw	ra,4(sp)
 d001614:	df000017 	ldw	fp,0(sp)
 d001618:	dec00204 	addi	sp,sp,8
 d00161c:	f800283a 	ret

0d001620 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 d001620:	defff804 	addi	sp,sp,-32
 d001624:	dfc00715 	stw	ra,28(sp)
 d001628:	df000615 	stw	fp,24(sp)
 d00162c:	df000604 	addi	fp,sp,24
 d001630:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 d001634:	00bfffc4 	movi	r2,-1
 d001638:	e0bffe15 	stw	r2,-8(fp)
    alt_u32 ser_num = 0;
 d00163c:	e03ffd15 	stw	zero,-12(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 d001640:	01034174 	movhi	r4,3333
 d001644:	21354304 	addi	r4,r4,-10996
 d001648:	d002bc80 	call	d002bc8 <puts>
    printf("a MAC address.\n\n");
 d00164c:	01034174 	movhi	r4,3333
 d001650:	21355304 	addi	r4,r4,-10932
 d001654:	d002bc80 	call	d002bc8 <puts>
    
    ser_num = get_serial_number();
 d001658:	d00127c0 	call	d00127c <get_serial_number>
 d00165c:	e0bffd15 	stw	r2,-12(fp)
  
    if (ser_num)
 d001660:	e0bffd17 	ldw	r2,-12(fp)
 d001664:	1005003a 	cmpeq	r2,r2,zero
 d001668:	1000341e 	bne	r2,zero,d00173c <generate_mac_addr+0x11c>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 d00166c:	e0bfff17 	ldw	r2,-4(fp)
 d001670:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 d001674:	e0bfff17 	ldw	r2,-4(fp)
 d001678:	10c00044 	addi	r3,r2,1
 d00167c:	008001c4 	movi	r2,7
 d001680:	18800005 	stb	r2,0(r3)
        mac_addr[2] = 0xed;
 d001684:	e0bfff17 	ldw	r2,-4(fp)
 d001688:	10c00084 	addi	r3,r2,2
 d00168c:	00bffb44 	movi	r2,-19
 d001690:	18800005 	stb	r2,0(r3)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0x19;
 d001694:	e0bfff17 	ldw	r2,-4(fp)
 d001698:	10c000c4 	addi	r3,r2,3
 d00169c:	00800644 	movi	r2,25
 d0016a0:	18800005 	stb	r2,0(r3)
        mac_addr[4] = 0x06;
 d0016a4:	e0bfff17 	ldw	r2,-4(fp)
 d0016a8:	10c00104 	addi	r3,r2,4
 d0016ac:	00800184 	movi	r2,6
 d0016b0:	18800005 	stb	r2,0(r3)
        mac_addr[5] = 0xa9;
 d0016b4:	e0bfff17 	ldw	r2,-4(fp)
 d0016b8:	10c00144 	addi	r3,r2,5
 d0016bc:	00bfea44 	movi	r2,-87
 d0016c0:	18800005 	stb	r2,0(r3)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 d0016c4:	e0bfff17 	ldw	r2,-4(fp)
 d0016c8:	10800003 	ldbu	r2,0(r2)
 d0016cc:	11403fcc 	andi	r5,r2,255
 d0016d0:	e0bfff17 	ldw	r2,-4(fp)
 d0016d4:	10800044 	addi	r2,r2,1
 d0016d8:	10800003 	ldbu	r2,0(r2)
 d0016dc:	11803fcc 	andi	r6,r2,255
 d0016e0:	e0bfff17 	ldw	r2,-4(fp)
 d0016e4:	10800084 	addi	r2,r2,2
 d0016e8:	10800003 	ldbu	r2,0(r2)
 d0016ec:	11c03fcc 	andi	r7,r2,255
 d0016f0:	e0bfff17 	ldw	r2,-4(fp)
 d0016f4:	108000c4 	addi	r2,r2,3
 d0016f8:	10800003 	ldbu	r2,0(r2)
 d0016fc:	10c03fcc 	andi	r3,r2,255
 d001700:	e0bfff17 	ldw	r2,-4(fp)
 d001704:	10800104 	addi	r2,r2,4
 d001708:	10800003 	ldbu	r2,0(r2)
 d00170c:	11003fcc 	andi	r4,r2,255
 d001710:	e0bfff17 	ldw	r2,-4(fp)
 d001714:	10800144 	addi	r2,r2,5
 d001718:	10800003 	ldbu	r2,0(r2)
 d00171c:	10803fcc 	andi	r2,r2,255
 d001720:	d8c00015 	stw	r3,0(sp)
 d001724:	d9000115 	stw	r4,4(sp)
 d001728:	d8800215 	stw	r2,8(sp)
 d00172c:	01034174 	movhi	r4,3333
 d001730:	21355704 	addi	r4,r4,-10916
 d001734:	d0028a00 	call	d0028a0 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 d001738:	e03ffe15 	stw	zero,-8(fp)
    }
  
    return error;    
 d00173c:	e0bffe17 	ldw	r2,-8(fp)
}
 d001740:	e037883a 	mov	sp,fp
 d001744:	dfc00117 	ldw	ra,4(sp)
 d001748:	df000017 	ldw	fp,0(sp)
 d00174c:	dec00204 	addi	sp,sp,8
 d001750:	f800283a 	ret

0d001754 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 d001754:	defff804 	addi	sp,sp,-32
 d001758:	dfc00715 	stw	ra,28(sp)
 d00175c:	df000615 	stw	fp,24(sp)
 d001760:	df000604 	addi	fp,sp,24
 d001764:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 d001768:	e03ffe15 	stw	zero,-8(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 d00176c:	d128d604 	addi	r4,gp,-23720
 d001770:	d0018b00 	call	d0018b0 <FindLastFlashSectorOffset>
 d001774:	e0bffe15 	stw	r2,-8(fp)
    if (!error)
 d001778:	e0bffe17 	ldw	r2,-8(fp)
 d00177c:	1004c03a 	cmpne	r2,r2,zero
 d001780:	1000041e 	bne	r2,zero,d001794 <get_board_mac_addr+0x40>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 d001784:	d0a8d617 	ldw	r2,-23720(gp)
 d001788:	00c20034 	movhi	r3,2048
 d00178c:	10c5883a 	add	r2,r2,r3
 d001790:	d0a8d715 	stw	r2,-23716(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 d001794:	e0bffe17 	ldw	r2,-8(fp)
 d001798:	1004c03a 	cmpne	r2,r2,zero
 d00179c:	1000081e 	bne	r2,zero,d0017c0 <get_board_mac_addr+0x6c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 d0017a0:	d0a8d717 	ldw	r2,-23716(gp)
 d0017a4:	10800037 	ldwio	r2,0(r2)
 d0017a8:	e0bffd15 	stw	r2,-12(fp)
        if (signature != 0x00005afe)
 d0017ac:	e0bffd17 	ldw	r2,-12(fp)
 d0017b0:	1096bfa0 	cmpeqi	r2,r2,23294
 d0017b4:	1000021e 	bne	r2,zero,d0017c0 <get_board_mac_addr+0x6c>
        {
          error = generate_and_store_mac_addr();
 d0017b8:	d00145c0 	call	d00145c <generate_and_store_mac_addr>
 d0017bc:	e0bffe15 	stw	r2,-8(fp)
        }
    }
  
    if (!error)
 d0017c0:	e0bffe17 	ldw	r2,-8(fp)
 d0017c4:	1004c03a 	cmpne	r2,r2,zero
 d0017c8:	1000331e 	bne	r2,zero,d001898 <get_board_mac_addr+0x144>
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
        */
        mac_addr[0] = 0x00;
 d0017cc:	e0bfff17 	ldw	r2,-4(fp)
 d0017d0:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x07;
 d0017d4:	e0bfff17 	ldw	r2,-4(fp)
 d0017d8:	10c00044 	addi	r3,r2,1
 d0017dc:	008001c4 	movi	r2,7
 d0017e0:	18800005 	stb	r2,0(r3)
        mac_addr[2] = 0xed;
 d0017e4:	e0bfff17 	ldw	r2,-4(fp)
 d0017e8:	10c00084 	addi	r3,r2,2
 d0017ec:	00bffb44 	movi	r2,-19
 d0017f0:	18800005 	stb	r2,0(r3)
        mac_addr[3] = 0x19;
 d0017f4:	e0bfff17 	ldw	r2,-4(fp)
 d0017f8:	10c000c4 	addi	r3,r2,3
 d0017fc:	00800644 	movi	r2,25
 d001800:	18800005 	stb	r2,0(r3)
        mac_addr[4] = 0x06;
 d001804:	e0bfff17 	ldw	r2,-4(fp)
 d001808:	10c00104 	addi	r3,r2,4
 d00180c:	00800184 	movi	r2,6
 d001810:	18800005 	stb	r2,0(r3)
        mac_addr[5] = 0xa9;
 d001814:	e0bfff17 	ldw	r2,-4(fp)
 d001818:	10c00144 	addi	r3,r2,5
 d00181c:	00bfea44 	movi	r2,-87
 d001820:	18800005 	stb	r2,0(r3)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 d001824:	e0bfff17 	ldw	r2,-4(fp)
 d001828:	10800003 	ldbu	r2,0(r2)
 d00182c:	11403fcc 	andi	r5,r2,255
 d001830:	e0bfff17 	ldw	r2,-4(fp)
 d001834:	10800044 	addi	r2,r2,1
 d001838:	10800003 	ldbu	r2,0(r2)
 d00183c:	11803fcc 	andi	r6,r2,255
 d001840:	e0bfff17 	ldw	r2,-4(fp)
 d001844:	10800084 	addi	r2,r2,2
 d001848:	10800003 	ldbu	r2,0(r2)
 d00184c:	11c03fcc 	andi	r7,r2,255
 d001850:	e0bfff17 	ldw	r2,-4(fp)
 d001854:	108000c4 	addi	r2,r2,3
 d001858:	10800003 	ldbu	r2,0(r2)
 d00185c:	10c03fcc 	andi	r3,r2,255
 d001860:	e0bfff17 	ldw	r2,-4(fp)
 d001864:	10800104 	addi	r2,r2,4
 d001868:	10800003 	ldbu	r2,0(r2)
 d00186c:	11003fcc 	andi	r4,r2,255
 d001870:	e0bfff17 	ldw	r2,-4(fp)
 d001874:	10800144 	addi	r2,r2,5
 d001878:	10800003 	ldbu	r2,0(r2)
 d00187c:	10803fcc 	andi	r2,r2,255
 d001880:	d8c00015 	stw	r3,0(sp)
 d001884:	d9000115 	stw	r4,4(sp)
 d001888:	d8800215 	stw	r2,8(sp)
 d00188c:	01034174 	movhi	r4,3333
 d001890:	21355704 	addi	r4,r4,-10916
 d001894:	d0028a00 	call	d0028a0 <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 d001898:	e0bffe17 	ldw	r2,-8(fp)
}
 d00189c:	e037883a 	mov	sp,fp
 d0018a0:	dfc00117 	ldw	ra,4(sp)
 d0018a4:	df000017 	ldw	fp,0(sp)
 d0018a8:	dec00204 	addi	sp,sp,8
 d0018ac:	f800283a 	ret

0d0018b0 <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 d0018b0:	defff304 	addi	sp,sp,-52
 d0018b4:	dfc00c15 	stw	ra,48(sp)
 d0018b8:	df000b15 	stw	fp,44(sp)
 d0018bc:	df000b04 	addi	fp,sp,44
 d0018c0:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 d0018c4:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 d0018c8:	01034174 	movhi	r4,3333
 d0018cc:	21353f04 	addi	r4,r4,-11012
 d0018d0:	d00cfd40 	call	d00cfd4 <alt_flash_open_dev>
 d0018d4:	e0bffc15 	stw	r2,-16(fp)
    if (fd <= 0)
 d0018d8:	e0bffc17 	ldw	r2,-16(fp)
 d0018dc:	1004c03a 	cmpne	r2,r2,zero
 d0018e0:	1000021e 	bne	r2,zero,d0018ec <FindLastFlashSectorOffset+0x3c>
        error = -1;
 d0018e4:	00bfffc4 	movi	r2,-1
 d0018e8:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 d0018ec:	e0bff817 	ldw	r2,-32(fp)
 d0018f0:	1004c03a 	cmpne	r2,r2,zero
 d0018f4:	10000d1e 	bne	r2,zero,d00192c <FindLastFlashSectorOffset+0x7c>
 d0018f8:	e0bffc17 	ldw	r2,-16(fp)
 d0018fc:	e0bff515 	stw	r2,-44(fp)
 d001900:	e0bffd04 	addi	r2,fp,-12
 d001904:	e0bff615 	stw	r2,-40(fp)
 d001908:	e0bffe04 	addi	r2,fp,-8
 d00190c:	e0bff715 	stw	r2,-36(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 d001910:	e0bff517 	ldw	r2,-44(fp)
 d001914:	10800717 	ldw	r2,28(r2)
 d001918:	e13ff517 	ldw	r4,-44(fp)
 d00191c:	e17ff617 	ldw	r5,-40(fp)
 d001920:	e1bff717 	ldw	r6,-36(fp)
 d001924:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 d001928:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 d00192c:	e0bff817 	ldw	r2,-32(fp)
 d001930:	1004c03a 	cmpne	r2,r2,zero
 d001934:	1000231e 	bne	r2,zero,d0019c4 <FindLastFlashSectorOffset+0x114>
    {
        pLastRegion = &(regions[0]);
 d001938:	e0bffd17 	ldw	r2,-12(fp)
 d00193c:	e0bffb15 	stw	r2,-20(fp)
        for (n = 1; n < numRegions; n++)
 d001940:	00800044 	movi	r2,1
 d001944:	e0bff915 	stw	r2,-28(fp)
 d001948:	00001206 	br	d001994 <FindLastFlashSectorOffset+0xe4>
        {
            if (regions[n].offset > pLastRegion->offset)
 d00194c:	e0bff917 	ldw	r2,-28(fp)
 d001950:	1004913a 	slli	r2,r2,4
 d001954:	1007883a 	mov	r3,r2
 d001958:	e0bffd17 	ldw	r2,-12(fp)
 d00195c:	1885883a 	add	r2,r3,r2
 d001960:	10c00017 	ldw	r3,0(r2)
 d001964:	e0bffb17 	ldw	r2,-20(fp)
 d001968:	10800017 	ldw	r2,0(r2)
 d00196c:	10c0060e 	bge	r2,r3,d001988 <FindLastFlashSectorOffset+0xd8>
                pLastRegion = &(regions[n]);
 d001970:	e0bff917 	ldw	r2,-28(fp)
 d001974:	1004913a 	slli	r2,r2,4
 d001978:	1007883a 	mov	r3,r2
 d00197c:	e0bffd17 	ldw	r2,-12(fp)
 d001980:	1885883a 	add	r2,r3,r2
 d001984:	e0bffb15 	stw	r2,-20(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 d001988:	e0bff917 	ldw	r2,-28(fp)
 d00198c:	10800044 	addi	r2,r2,1
 d001990:	e0bff915 	stw	r2,-28(fp)
 d001994:	e0fffe17 	ldw	r3,-8(fp)
 d001998:	e0bff917 	ldw	r2,-28(fp)
 d00199c:	10ffeb16 	blt	r2,r3,d00194c <FindLastFlashSectorOffset+0x9c>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 d0019a0:	e0bffb17 	ldw	r2,-20(fp)
 d0019a4:	10c00017 	ldw	r3,0(r2)
 d0019a8:	e0bffb17 	ldw	r2,-20(fp)
 d0019ac:	10800117 	ldw	r2,4(r2)
 d0019b0:	1887883a 	add	r3,r3,r2
 d0019b4:	e0bffb17 	ldw	r2,-20(fp)
 d0019b8:	10800317 	ldw	r2,12(r2)
 d0019bc:	1885c83a 	sub	r2,r3,r2
 d0019c0:	e0bffa15 	stw	r2,-24(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 d0019c4:	e0bff817 	ldw	r2,-32(fp)
 d0019c8:	1004c03a 	cmpne	r2,r2,zero
 d0019cc:	1000031e 	bne	r2,zero,d0019dc <FindLastFlashSectorOffset+0x12c>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 d0019d0:	e0fffa17 	ldw	r3,-24(fp)
 d0019d4:	e0bfff17 	ldw	r2,-4(fp)
 d0019d8:	10c00015 	stw	r3,0(r2)

    return (error);
 d0019dc:	e0bff817 	ldw	r2,-32(fp)
}
 d0019e0:	e037883a 	mov	sp,fp
 d0019e4:	dfc00117 	ldw	ra,4(sp)
 d0019e8:	df000017 	ldw	fp,0(sp)
 d0019ec:	dec00204 	addi	sp,sp,8
 d0019f0:	f800283a 	ret

0d0019f4 <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 d0019f4:	defffd04 	addi	sp,sp,-12
 d0019f8:	dfc00215 	stw	ra,8(sp)
 d0019fc:	df000115 	stw	fp,4(sp)
 d001a00:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 d001a04:	010341b4 	movhi	r4,3334
 d001a08:	212d1e04 	addi	r4,r4,-19336
 d001a0c:	01400784 	movi	r5,30
 d001a10:	d011ef40 	call	d011ef4 <OSQCreate>
 d001a14:	d0a8d915 	stw	r2,-23708(gp)
  if (!SSSLEDCommandQ)
 d001a18:	d0a8d917 	ldw	r2,-23708(gp)
 d001a1c:	1004c03a 	cmpne	r2,r2,zero
 d001a20:	1000041e 	bne	r2,zero,d001a34 <SSSCreateOSDataStructs+0x40>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 d001a24:	01003fc4 	movi	r4,255
 d001a28:	01434174 	movhi	r5,3333
 d001a2c:	29756604 	addi	r5,r5,-10856
 d001a30:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 d001a34:	01000044 	movi	r4,1
 d001a38:	d0131940 	call	d013194 <OSSemCreate>
 d001a3c:	d0a8da15 	stw	r2,-23704(gp)
  if (!SSSLEDLightshowSem)
 d001a40:	d0a8da17 	ldw	r2,-23704(gp)
 d001a44:	1004c03a 	cmpne	r2,r2,zero
 d001a48:	1000041e 	bne	r2,zero,d001a5c <SSSCreateOSDataStructs+0x68>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 d001a4c:	01003fc4 	movi	r4,255
 d001a50:	01434174 	movhi	r5,3333
 d001a54:	29756f04 	addi	r5,r5,-10820
 d001a58:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 d001a5c:	0009883a 	mov	r4,zero
 d001a60:	e17fff04 	addi	r5,fp,-4
 d001a64:	d00ff8c0 	call	d00ff8c <OSFlagCreate>
 d001a68:	d0a8db15 	stw	r2,-23700(gp)
  if (!SSSLEDEventFlag)
 d001a6c:	d0a8db17 	ldw	r2,-23700(gp)
 d001a70:	1004c03a 	cmpne	r2,r2,zero
 d001a74:	1000041e 	bne	r2,zero,d001a88 <SSSCreateOSDataStructs+0x94>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 d001a78:	e0bfff03 	ldbu	r2,-4(fp)
 d001a7c:	11003fcc 	andi	r4,r2,255
 d001a80:	000b883a 	mov	r5,zero
 d001a84:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
  }
}
 d001a88:	e037883a 	mov	sp,fp
 d001a8c:	dfc00117 	ldw	ra,4(sp)
 d001a90:	df000017 	ldw	fp,0(sp)
 d001a94:	dec00204 	addi	sp,sp,8
 d001a98:	f800283a 	ret

0d001a9c <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 d001a9c:	defff804 	addi	sp,sp,-32
 d001aa0:	dfc00715 	stw	ra,28(sp)
 d001aa4:	df000615 	stw	fp,24(sp)
 d001aa8:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 d001aac:	018341b4 	movhi	r6,3334
 d001ab0:	31ad1d04 	addi	r6,r6,-19340
 d001ab4:	00800484 	movi	r2,18
 d001ab8:	d8800015 	stw	r2,0(sp)
 d001abc:	008341b4 	movhi	r2,3334
 d001ac0:	10a51e04 	addi	r2,r2,-27528
 d001ac4:	d8800115 	stw	r2,4(sp)
 d001ac8:	00820004 	movi	r2,2048
 d001acc:	d8800215 	stw	r2,8(sp)
 d001ad0:	d8000315 	stw	zero,12(sp)
 d001ad4:	d8000415 	stw	zero,16(sp)
 d001ad8:	01034034 	movhi	r4,3328
 d001adc:	2103d804 	addi	r4,r4,3936
 d001ae0:	000b883a 	mov	r5,zero
 d001ae4:	01c00484 	movi	r7,18
 d001ae8:	d0143e40 	call	d0143e4 <OSTaskCreateExt>
 d001aec:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 d001af0:	e13fff03 	ldbu	r4,-4(fp)
 d001af4:	000b883a 	mov	r5,zero
 d001af8:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 d001afc:	018341b4 	movhi	r6,3334
 d001b00:	31b53b04 	addi	r6,r6,-11028
 d001b04:	008001c4 	movi	r2,7
 d001b08:	d8800015 	stw	r2,0(sp)
 d001b0c:	008341b4 	movhi	r2,3334
 d001b10:	10ad3c04 	addi	r2,r2,-19216
 d001b14:	d8800115 	stw	r2,4(sp)
 d001b18:	00820004 	movi	r2,2048
 d001b1c:	d8800215 	stw	r2,8(sp)
 d001b20:	d8000315 	stw	zero,12(sp)
 d001b24:	d8000415 	stw	zero,16(sp)
 d001b28:	01034034 	movhi	r4,3328
 d001b2c:	2103f504 	addi	r4,r4,4052
 d001b30:	000b883a 	mov	r5,zero
 d001b34:	01c001c4 	movi	r7,7
 d001b38:	d0143e40 	call	d0143e4 <OSTaskCreateExt>
 d001b3c:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 d001b40:	e13fff03 	ldbu	r4,-4(fp)
 d001b44:	000b883a 	mov	r5,zero
 d001b48:	d0001d80 	call	d0001d8 <alt_uCOSIIErrorHandler>

}
 d001b4c:	e037883a 	mov	sp,fp
 d001b50:	dfc00117 	ldw	ra,4(sp)
 d001b54:	df000017 	ldw	fp,0(sp)
 d001b58:	dec00204 	addi	sp,sp,8
 d001b5c:	f800283a 	ret

0d001b60 <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 d001b60:	defffd04 	addi	sp,sp,-12
 d001b64:	dfc00215 	stw	ra,8(sp)
 d001b68:	df000115 	stw	fp,4(sp)
 d001b6c:	df000104 	addi	fp,sp,4
 d001b70:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 d001b74:	e0bfff17 	ldw	r2,-4(fp)
 d001b78:	1009883a 	mov	r4,r2
 d001b7c:	01817c04 	movi	r6,1520
 d001b80:	000b883a 	mov	r5,zero
 d001b84:	d0027880 	call	d002788 <memset>

  conn->fd = -1;
 d001b88:	e0ffff17 	ldw	r3,-4(fp)
 d001b8c:	00bfffc4 	movi	r2,-1
 d001b90:	18800115 	stw	r2,4(r3)
  conn->state = READY;
 d001b94:	e0bfff17 	ldw	r2,-4(fp)
 d001b98:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 d001b9c:	e0bfff17 	ldw	r2,-4(fp)
 d001ba0:	10c00304 	addi	r3,r2,12
 d001ba4:	e0bfff17 	ldw	r2,-4(fp)
 d001ba8:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 d001bac:	e0bfff17 	ldw	r2,-4(fp)
 d001bb0:	10c00304 	addi	r3,r2,12
 d001bb4:	e0bfff17 	ldw	r2,-4(fp)
 d001bb8:	10c17a15 	stw	r3,1512(r2)
  return;
}
 d001bbc:	e037883a 	mov	sp,fp
 d001bc0:	dfc00117 	ldw	ra,4(sp)
 d001bc4:	df000017 	ldw	fp,0(sp)
 d001bc8:	dec00204 	addi	sp,sp,8
 d001bcc:	f800283a 	ret

0d001bd0 <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 d001bd0:	defe8504 	addi	sp,sp,-1516
 d001bd4:	dfc17a15 	stw	ra,1512(sp)
 d001bd8:	df017915 	stw	fp,1508(sp)
 d001bdc:	df017904 	addi	fp,sp,1508
 d001be0:	e13fff15 	stw	r4,-4(fp)
  alt_u8  tx_buf[SSS_TX_BUF_SIZE];
  alt_u8 *tx_wr_pos = tx_buf;
 d001be4:	e0be8804 	addi	r2,fp,-1504
 d001be8:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 d001bec:	e0be8717 	ldw	r2,-1508(fp)
 d001bf0:	00c34174 	movhi	r3,3333
 d001bf4:	18f57904 	addi	r3,r3,-10780
 d001bf8:	1009883a 	mov	r4,r2
 d001bfc:	180b883a 	mov	r5,r3
 d001c00:	01800904 	movi	r6,36
 d001c04:	d0026080 	call	d002608 <memcpy>
 d001c08:	e0be8717 	ldw	r2,-1508(fp)
 d001c0c:	108008c4 	addi	r2,r2,35
 d001c10:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Nios II Simple Socket Server Menu\n\r");
 d001c14:	e0be8717 	ldw	r2,-1508(fp)
 d001c18:	00c34174 	movhi	r3,3333
 d001c1c:	18f58204 	addi	r3,r3,-10744
 d001c20:	1009883a 	mov	r4,r2
 d001c24:	180b883a 	mov	r5,r3
 d001c28:	01800904 	movi	r6,36
 d001c2c:	d0026080 	call	d002608 <memcpy>
 d001c30:	e0be8717 	ldw	r2,-1508(fp)
 d001c34:	108008c4 	addi	r2,r2,35
 d001c38:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 d001c3c:	e0be8717 	ldw	r2,-1508(fp)
 d001c40:	00c34174 	movhi	r3,3333
 d001c44:	18f57904 	addi	r3,r3,-10780
 d001c48:	1009883a 	mov	r4,r2
 d001c4c:	180b883a 	mov	r5,r3
 d001c50:	01800904 	movi	r6,36
 d001c54:	d0026080 	call	d002608 <memcpy>
 d001c58:	e0be8717 	ldw	r2,-1508(fp)
 d001c5c:	108008c4 	addi	r2,r2,35
 d001c60:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"0-7: Toggle board LEDs D0 - D7\n\r");
 d001c64:	e0be8717 	ldw	r2,-1508(fp)
 d001c68:	00c34174 	movhi	r3,3333
 d001c6c:	18f58b04 	addi	r3,r3,-10708
 d001c70:	1009883a 	mov	r4,r2
 d001c74:	180b883a 	mov	r5,r3
 d001c78:	01800844 	movi	r6,33
 d001c7c:	d0026080 	call	d002608 <memcpy>
 d001c80:	e0be8717 	ldw	r2,-1508(fp)
 d001c84:	10800804 	addi	r2,r2,32
 d001c88:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"S: 7-Segment LED Light Show\n\r");
 d001c8c:	e0be8717 	ldw	r2,-1508(fp)
 d001c90:	00c34174 	movhi	r3,3333
 d001c94:	18f59404 	addi	r3,r3,-10672
 d001c98:	1009883a 	mov	r4,r2
 d001c9c:	180b883a 	mov	r5,r3
 d001ca0:	01800784 	movi	r6,30
 d001ca4:	d0026080 	call	d002608 <memcpy>
 d001ca8:	e0be8717 	ldw	r2,-1508(fp)
 d001cac:	10800744 	addi	r2,r2,29
 d001cb0:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Q: Terminate session\n\r");
 d001cb4:	e0be8717 	ldw	r2,-1508(fp)
 d001cb8:	00c34174 	movhi	r3,3333
 d001cbc:	18f59c04 	addi	r3,r3,-10640
 d001cc0:	1009883a 	mov	r4,r2
 d001cc4:	180b883a 	mov	r5,r3
 d001cc8:	018005c4 	movi	r6,23
 d001ccc:	d0026080 	call	d002608 <memcpy>
 d001cd0:	e0be8717 	ldw	r2,-1508(fp)
 d001cd4:	10800584 	addi	r2,r2,22
 d001cd8:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 d001cdc:	e0be8717 	ldw	r2,-1508(fp)
 d001ce0:	00c34174 	movhi	r3,3333
 d001ce4:	18f57904 	addi	r3,r3,-10780
 d001ce8:	1009883a 	mov	r4,r2
 d001cec:	180b883a 	mov	r5,r3
 d001cf0:	01800904 	movi	r6,36
 d001cf4:	d0026080 	call	d002608 <memcpy>
 d001cf8:	e0be8717 	ldw	r2,-1508(fp)
 d001cfc:	108008c4 	addi	r2,r2,35
 d001d00:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 d001d04:	e0be8717 	ldw	r2,-1508(fp)
 d001d08:	00c34174 	movhi	r3,3333
 d001d0c:	18f5a204 	addi	r3,r3,-10616
 d001d10:	1009883a 	mov	r4,r2
 d001d14:	180b883a 	mov	r5,r3
 d001d18:	01800904 	movi	r6,36
 d001d1c:	d0026080 	call	d002608 <memcpy>
 d001d20:	e0be8717 	ldw	r2,-1508(fp)
 d001d24:	108008c4 	addi	r2,r2,35
 d001d28:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 d001d2c:	e0bfff17 	ldw	r2,-4(fp)
 d001d30:	11000117 	ldw	r4,4(r2)
 d001d34:	e17e8804 	addi	r5,fp,-1504
 d001d38:	e0fe8717 	ldw	r3,-1508(fp)
 d001d3c:	e0be8804 	addi	r2,fp,-1504
 d001d40:	188dc83a 	sub	r6,r3,r2
 d001d44:	000f883a 	mov	r7,zero
 d001d48:	d029d980 	call	d029d98 <t_send>
  
  return;
}
 d001d4c:	e037883a 	mov	sp,fp
 d001d50:	dfc00117 	ldw	ra,4(sp)
 d001d54:	df000017 	ldw	fp,0(sp)
 d001d58:	dec00204 	addi	sp,sp,8
 d001d5c:	f800283a 	ret

0d001d60 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 d001d60:	defff604 	addi	sp,sp,-40
 d001d64:	dfc00915 	stw	ra,36(sp)
 d001d68:	df000815 	stw	fp,32(sp)
 d001d6c:	df000804 	addi	fp,sp,32
 d001d70:	e13ffe15 	stw	r4,-8(fp)
 d001d74:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 d001d78:	00800404 	movi	r2,16
 d001d7c:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 d001d80:	e0bfff17 	ldw	r2,-4(fp)
 d001d84:	10800117 	ldw	r2,4(r2)
 d001d88:	10bfffd8 	cmpnei	r2,r2,-1
 d001d8c:	1000191e 	bne	r2,zero,d001df4 <sss_handle_accept+0x94>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 d001d90:	e17ffa04 	addi	r5,fp,-24
 d001d94:	e1bff904 	addi	r6,fp,-28
 d001d98:	e13ffe17 	ldw	r4,-8(fp)
 d001d9c:	d01f9280 	call	d01f928 <bsd_accept>
 d001da0:	e0bff815 	stw	r2,-32(fp)
 d001da4:	e0bff817 	ldw	r2,-32(fp)
 d001da8:	1004403a 	cmpge	r2,r2,zero
 d001dac:	1000051e 	bne	r2,zero,d001dc4 <sss_handle_accept+0x64>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 d001db0:	01003fc4 	movi	r4,255
 d001db4:	01434174 	movhi	r5,3333
 d001db8:	2975ab04 	addi	r5,r5,-10580
 d001dbc:	d0007fc0 	call	d0007fc <alt_NetworkErrorHandler>
 d001dc0:	00001206 	br	d001e0c <sss_handle_accept+0xac>
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 d001dc4:	e0bfff17 	ldw	r2,-4(fp)
 d001dc8:	e0fff817 	ldw	r3,-32(fp)
 d001dcc:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 d001dd0:	e13fff17 	ldw	r4,-4(fp)
 d001dd4:	d001bd00 	call	d001bd0 <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 d001dd8:	e13ffb17 	ldw	r4,-20(fp)
 d001ddc:	d0200940 	call	d020094 <bsd_inet_ntoa>
 d001de0:	100b883a 	mov	r5,r2
 d001de4:	01034174 	movhi	r4,3333
 d001de8:	2135b404 	addi	r4,r4,-10544
 d001dec:	d0028a00 	call	d0028a0 <printf>
 d001df0:	00000606 	br	d001e0c <sss_handle_accept+0xac>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 d001df4:	e13ffb17 	ldw	r4,-20(fp)
 d001df8:	d0200940 	call	d020094 <bsd_inet_ntoa>
 d001dfc:	100b883a 	mov	r5,r2
 d001e00:	01034174 	movhi	r4,3333
 d001e04:	2135c304 	addi	r4,r4,-10484
 d001e08:	d0028a00 	call	d0028a0 <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
}
 d001e0c:	e037883a 	mov	sp,fp
 d001e10:	dfc00117 	ldw	ra,4(sp)
 d001e14:	df000017 	ldw	fp,0(sp)
 d001e18:	dec00204 	addi	sp,sp,8
 d001e1c:	f800283a 	ret

0d001e20 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 d001e20:	defe8104 	addi	sp,sp,-1532
 d001e24:	dfc17e15 	stw	ra,1528(sp)
 d001e28:	df017d15 	stw	fp,1524(sp)
 d001e2c:	df017d04 	addi	fp,sp,1524
 d001e30:	e13ffe15 	stw	r4,-8(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 d001e34:	e0bffe17 	ldw	r2,-8(fp)
 d001e38:	10817b17 	ldw	r2,1516(r2)
 d001e3c:	1007883a 	mov	r3,r2
 d001e40:	e0bffe17 	ldw	r2,-8(fp)
 d001e44:	10817a17 	ldw	r2,1512(r2)
 d001e48:	1885c83a 	sub	r2,r3,r2
 d001e4c:	e0be8615 	stw	r2,-1512(fp)
   INT8U tx_buf[SSS_TX_BUF_SIZE];
   INT8U *tx_wr_pos = tx_buf;
 d001e50:	e0be8704 	addi	r2,fp,-1508
 d001e54:	e0be8515 	stw	r2,-1516(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 d001e58:	00800c04 	movi	r2,48
 d001e5c:	d0a8d815 	stw	r2,-23712(gp)

   while(bytes_to_process--)
 d001e60:	00004506 	br	d001f78 <sss_exec_command+0x158>
   {
      SSSCommand = toupper(*(conn->rx_rd_pos++));
 d001e64:	e0bffe17 	ldw	r2,-8(fp)
 d001e68:	10c17a17 	ldw	r3,1512(r2)
 d001e6c:	18800003 	ldbu	r2,0(r3)
 d001e70:	10803fcc 	andi	r2,r2,255
 d001e74:	e0be8315 	stw	r2,-1524(fp)
 d001e78:	18c00044 	addi	r3,r3,1
 d001e7c:	e0bffe17 	ldw	r2,-8(fp)
 d001e80:	10c17a15 	stw	r3,1512(r2)
 d001e84:	00834174 	movhi	r2,3333
 d001e88:	10921f04 	addi	r2,r2,18556
 d001e8c:	10c00017 	ldw	r3,0(r2)
 d001e90:	e0be8317 	ldw	r2,-1524(fp)
 d001e94:	1885883a 	add	r2,r3,r2
 d001e98:	10800003 	ldbu	r2,0(r2)
 d001e9c:	10803fcc 	andi	r2,r2,255
 d001ea0:	1080008c 	andi	r2,r2,2
 d001ea4:	1005003a 	cmpeq	r2,r2,zero
 d001ea8:	1000041e 	bne	r2,zero,d001ebc <sss_exec_command+0x9c>
 d001eac:	e0be8317 	ldw	r2,-1524(fp)
 d001eb0:	10bff804 	addi	r2,r2,-32
 d001eb4:	e0bfff15 	stw	r2,-4(fp)
 d001eb8:	00000206 	br	d001ec4 <sss_exec_command+0xa4>
 d001ebc:	e0be8317 	ldw	r2,-1524(fp)
 d001ec0:	e0bfff15 	stw	r2,-4(fp)
 d001ec4:	e0bfff17 	ldw	r2,-4(fp)
 d001ec8:	d0a8d815 	stw	r2,-23712(gp)
    
      if(SSSCommand >= ' ' && SSSCommand <= '~')
 d001ecc:	d0a8d817 	ldw	r2,-23712(gp)
 d001ed0:	10800830 	cmpltui	r2,r2,32
 d001ed4:	1000281e 	bne	r2,zero,d001f78 <sss_exec_command+0x158>
 d001ed8:	d0a8d817 	ldw	r2,-23712(gp)
 d001edc:	10801fe8 	cmpgeui	r2,r2,127
 d001ee0:	1000251e 	bne	r2,zero,d001f78 <sss_exec_command+0x158>
      {
         tx_wr_pos += sprintf(tx_wr_pos,
 d001ee4:	e13e8517 	ldw	r4,-1516(fp)
 d001ee8:	d0a8d817 	ldw	r2,-23712(gp)
 d001eec:	11803fcc 	andi	r6,r2,255
 d001ef0:	3180201c 	xori	r6,r6,128
 d001ef4:	31bfe004 	addi	r6,r6,-128
 d001ef8:	01434174 	movhi	r5,3333
 d001efc:	2975d204 	addi	r5,r5,-10424
 d001f00:	d002c3c0 	call	d002c3c <sprintf>
 d001f04:	1007883a 	mov	r3,r2
 d001f08:	e0be8517 	ldw	r2,-1516(fp)
 d001f0c:	10c5883a 	add	r2,r2,r3
 d001f10:	e0be8515 	stw	r2,-1516(fp)
                              "--> Simple Socket Server Command %c.\n",
                              (char)SSSCommand);
         if (SSSCommand == CMD_QUIT)
 d001f14:	d0a8d817 	ldw	r2,-23712(gp)
 d001f18:	10801458 	cmpnei	r2,r2,81
 d001f1c:	10000e1e 	bne	r2,zero,d001f58 <sss_exec_command+0x138>
         {
            tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 d001f20:	e0be8517 	ldw	r2,-1516(fp)
 d001f24:	00c34174 	movhi	r3,3333
 d001f28:	18f5dc04 	addi	r3,r3,-10384
 d001f2c:	1009883a 	mov	r4,r2
 d001f30:	180b883a 	mov	r5,r3
 d001f34:	018006c4 	movi	r6,27
 d001f38:	d0026080 	call	d002608 <memcpy>
 d001f3c:	e0be8517 	ldw	r2,-1516(fp)
 d001f40:	10800684 	addi	r2,r2,26
 d001f44:	e0be8515 	stw	r2,-1516(fp)
            conn->close = 1;
 d001f48:	e0fffe17 	ldw	r3,-8(fp)
 d001f4c:	00800044 	movi	r2,1
 d001f50:	18800215 	stw	r2,8(r3)
 d001f54:	00000806 	br	d001f78 <sss_exec_command+0x158>
         }
         else
         {
            error_code = OSQPost(SSSLEDCommandQ, (void *)SSSCommand);    
 d001f58:	d128d917 	ldw	r4,-23708(gp)
 d001f5c:	d0a8d817 	ldw	r2,-23712(gp)
 d001f60:	100b883a 	mov	r5,r2
 d001f64:	d01296c0 	call	d01296c <OSQPost>
 d001f68:	e0be8405 	stb	r2,-1520(fp)

            alt_SSSErrorHandler(error_code, 0);
 d001f6c:	e13e8403 	ldbu	r4,-1520(fp)
 d001f70:	000b883a 	mov	r5,zero
 d001f74:	d000a940 	call	d000a94 <alt_SSSErrorHandler>
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;

   while(bytes_to_process--)
 d001f78:	e0be8617 	ldw	r2,-1512(fp)
 d001f7c:	10bfffc4 	addi	r2,r2,-1
 d001f80:	e0be8615 	stw	r2,-1512(fp)
 d001f84:	e0be8617 	ldw	r2,-1512(fp)
 d001f88:	10bfffd8 	cmpnei	r2,r2,-1
 d001f8c:	103fb51e 	bne	r2,zero,d001e64 <sss_exec_command+0x44>
            alt_SSSErrorHandler(error_code, 0);
         }
      }
   }             

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 d001f90:	e0bffe17 	ldw	r2,-8(fp)
 d001f94:	11000117 	ldw	r4,4(r2)
 d001f98:	e17e8704 	addi	r5,fp,-1508
 d001f9c:	e0fe8517 	ldw	r3,-1516(fp)
 d001fa0:	e0be8704 	addi	r2,fp,-1508
 d001fa4:	188dc83a 	sub	r6,r3,r2
 d001fa8:	000f883a 	mov	r7,zero
 d001fac:	d029d980 	call	d029d98 <t_send>
  
  return;
}
 d001fb0:	e037883a 	mov	sp,fp
 d001fb4:	dfc00117 	ldw	ra,4(sp)
 d001fb8:	df000017 	ldw	fp,0(sp)
 d001fbc:	dec00204 	addi	sp,sp,8
 d001fc0:	f800283a 	ret

0d001fc4 <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 d001fc4:	defff904 	addi	sp,sp,-28
 d001fc8:	dfc00615 	stw	ra,24(sp)
 d001fcc:	df000515 	stw	fp,20(sp)
 d001fd0:	df000504 	addi	fp,sp,20
 d001fd4:	e13ffe15 	stw	r4,-8(fp)
  int data_used = 0, rx_code = 0;
 d001fd8:	e03ffd15 	stw	zero,-12(fp)
 d001fdc:	e03ffc15 	stw	zero,-16(fp)
  INT8U *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 d001fe0:	e0bffe17 	ldw	r2,-8(fp)
 d001fe4:	10c00304 	addi	r3,r2,12
 d001fe8:	e0bffe17 	ldw	r2,-8(fp)
 d001fec:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 d001ff0:	e0bffe17 	ldw	r2,-8(fp)
 d001ff4:	10c00304 	addi	r3,r2,12
 d001ff8:	e0bffe17 	ldw	r2,-8(fp)
 d001ffc:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 d002000:	01034174 	movhi	r4,3333
 d002004:	2135e304 	addi	r4,r4,-10356
 d002008:	d002bc80 	call	d002bc8 <puts>
  
  while(conn->state != CLOSE)
 d00200c:	00005706 	br	d00216c <sss_handle_receive+0x1a8>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr(conn->rx_buffer, '\n');
 d002010:	e0bffe17 	ldw	r2,-8(fp)
 d002014:	10800304 	addi	r2,r2,12
 d002018:	1009883a 	mov	r4,r2
 d00201c:	01400284 	movi	r5,10
 d002020:	d002d100 	call	d002d10 <strchr>
 d002024:	e0bffb15 	stw	r2,-20(fp)
      
    if(lf_addr)
 d002028:	e0bffb17 	ldw	r2,-20(fp)
 d00202c:	1005003a 	cmpeq	r2,r2,zero
 d002030:	1000031e 	bne	r2,zero,d002040 <sss_handle_receive+0x7c>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 d002034:	e13ffe17 	ldw	r4,-8(fp)
 d002038:	d001e200 	call	d001e20 <sss_exec_command>
 d00203c:	00001c06 	br	d0020b0 <sss_handle_receive+0xec>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, conn->rx_wr_pos, 
 d002040:	e0bffe17 	ldw	r2,-8(fp)
 d002044:	11000117 	ldw	r4,4(r2)
 d002048:	e0bffe17 	ldw	r2,-8(fp)
 d00204c:	10817b17 	ldw	r2,1516(r2)
 d002050:	100b883a 	mov	r5,r2
 d002054:	e0bffe17 	ldw	r2,-8(fp)
 d002058:	10800304 	addi	r2,r2,12
 d00205c:	1007883a 	mov	r3,r2
 d002060:	e0bffe17 	ldw	r2,-8(fp)
 d002064:	10817b17 	ldw	r2,1516(r2)
 d002068:	1885c83a 	sub	r2,r3,r2
 d00206c:	118176c4 	addi	r6,r2,1499
 d002070:	000f883a 	mov	r7,zero
 d002074:	d02992c0 	call	d02992c <t_recv>
 d002078:	e0bffc15 	stw	r2,-16(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 d00207c:	e0bffc17 	ldw	r2,-16(fp)
 d002080:	10800050 	cmplti	r2,r2,1
 d002084:	10000a1e 	bne	r2,zero,d0020b0 <sss_handle_receive+0xec>
      {
        conn->rx_wr_pos += rx_code;
 d002088:	e0bffe17 	ldw	r2,-8(fp)
 d00208c:	10c17b17 	ldw	r3,1516(r2)
 d002090:	e0bffc17 	ldw	r2,-16(fp)
 d002094:	1887883a 	add	r3,r3,r2
 d002098:	e0bffe17 	ldw	r2,-8(fp)
 d00209c:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 d0020a0:	e0bffe17 	ldw	r2,-8(fp)
 d0020a4:	10817b17 	ldw	r2,1516(r2)
 d0020a8:	10800044 	addi	r2,r2,1
 d0020ac:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 d0020b0:	e0bffe17 	ldw	r2,-8(fp)
 d0020b4:	10800217 	ldw	r2,8(r2)
 d0020b8:	1005003a 	cmpeq	r2,r2,zero
 d0020bc:	1000031e 	bne	r2,zero,d0020cc <sss_handle_receive+0x108>
 d0020c0:	00800084 	movi	r2,2
 d0020c4:	e0bfff15 	stw	r2,-4(fp)
 d0020c8:	00000106 	br	d0020d0 <sss_handle_receive+0x10c>
 d0020cc:	e03fff15 	stw	zero,-4(fp)
 d0020d0:	e0bffe17 	ldw	r2,-8(fp)
 d0020d4:	e0ffff17 	ldw	r3,-4(fp)
 d0020d8:	10c00015 	stw	r3,0(r2)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 d0020dc:	e0bffe17 	ldw	r2,-8(fp)
 d0020e0:	10817a17 	ldw	r2,1512(r2)
 d0020e4:	1007883a 	mov	r3,r2
 d0020e8:	e0bffe17 	ldw	r2,-8(fp)
 d0020ec:	10800304 	addi	r2,r2,12
 d0020f0:	1885c83a 	sub	r2,r3,r2
 d0020f4:	e0bffd15 	stw	r2,-12(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 d0020f8:	e0bffe17 	ldw	r2,-8(fp)
 d0020fc:	11000304 	addi	r4,r2,12
 d002100:	e0bffe17 	ldw	r2,-8(fp)
 d002104:	11417a17 	ldw	r5,1512(r2)
 d002108:	e0bffe17 	ldw	r2,-8(fp)
 d00210c:	10817b17 	ldw	r2,1516(r2)
 d002110:	1007883a 	mov	r3,r2
 d002114:	e0bffe17 	ldw	r2,-8(fp)
 d002118:	10817a17 	ldw	r2,1512(r2)
 d00211c:	1885c83a 	sub	r2,r3,r2
 d002120:	100d883a 	mov	r6,r2
 d002124:	d0026a80 	call	d0026a8 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 d002128:	e0bffe17 	ldw	r2,-8(fp)
 d00212c:	10c00304 	addi	r3,r2,12
 d002130:	e0bffe17 	ldw	r2,-8(fp)
 d002134:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 d002138:	e0bffe17 	ldw	r2,-8(fp)
 d00213c:	10c17b17 	ldw	r3,1516(r2)
 d002140:	e0bffd17 	ldw	r2,-12(fp)
 d002144:	1887c83a 	sub	r3,r3,r2
 d002148:	e0bffe17 	ldw	r2,-8(fp)
 d00214c:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 d002150:	e0bffe17 	ldw	r2,-8(fp)
 d002154:	10817b17 	ldw	r2,1516(r2)
 d002158:	e0fffd17 	ldw	r3,-12(fp)
 d00215c:	1009883a 	mov	r4,r2
 d002160:	180d883a 	mov	r6,r3
 d002164:	000b883a 	mov	r5,zero
 d002168:	d0027880 	call	d002788 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 d00216c:	e0bffe17 	ldw	r2,-8(fp)
 d002170:	10800017 	ldw	r2,0(r2)
 d002174:	10800098 	cmpnei	r2,r2,2
 d002178:	103fa51e 	bne	r2,zero,d002010 <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 d00217c:	01034174 	movhi	r4,3333
 d002180:	2135ed04 	addi	r4,r4,-10316
 d002184:	d002bc80 	call	d002bc8 <puts>
  close(conn->fd);
 d002188:	e0bffe17 	ldw	r2,-8(fp)
 d00218c:	11000117 	ldw	r4,4(r2)
 d002190:	d01d3040 	call	d01d304 <close>
  sss_reset_connection(conn);
 d002194:	e13ffe17 	ldw	r4,-8(fp)
 d002198:	d001b600 	call	d001b60 <sss_reset_connection>
  
  return;
}
 d00219c:	e037883a 	mov	sp,fp
 d0021a0:	dfc00117 	ldw	ra,4(sp)
 d0021a4:	df000017 	ldw	fp,0(sp)
 d0021a8:	dec00204 	addi	sp,sp,8
 d0021ac:	f800283a 	ret

0d0021b0 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 d0021b0:	deffb604 	addi	sp,sp,-296
 d0021b4:	dfc04915 	stw	ra,292(sp)
 d0021b8:	df004815 	stw	fp,288(sp)
 d0021bc:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 d0021c0:	01000084 	movi	r4,2
 d0021c4:	01400044 	movi	r5,1
 d0021c8:	000d883a 	mov	r6,zero
 d0021cc:	d028af80 	call	d028af8 <t_socket>
 d0021d0:	e0bfba15 	stw	r2,-280(fp)
 d0021d4:	e0bfba17 	ldw	r2,-280(fp)
 d0021d8:	1004403a 	cmpge	r2,r2,zero
 d0021dc:	1000041e 	bne	r2,zero,d0021f0 <SSSSimpleSocketServerTask+0x40>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 d0021e0:	01003fc4 	movi	r4,255
 d0021e4:	01434174 	movhi	r5,3333
 d0021e8:	2975f704 	addi	r5,r5,-10276
 d0021ec:	d0007fc0 	call	d0007fc <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 d0021f0:	00800084 	movi	r2,2
 d0021f4:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 d0021f8:	00878004 	movi	r2,7680
 d0021fc:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 d002200:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 d002204:	e17fbb04 	addi	r5,fp,-276
 d002208:	e13fba17 	ldw	r4,-280(fp)
 d00220c:	01800404 	movi	r6,16
 d002210:	d028b880 	call	d028b88 <t_bind>
 d002214:	1004403a 	cmpge	r2,r2,zero
 d002218:	1000041e 	bne	r2,zero,d00222c <SSSSimpleSocketServerTask+0x7c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 d00221c:	01003fc4 	movi	r4,255
 d002220:	01434174 	movhi	r5,3333
 d002224:	29760004 	addi	r5,r5,-10240
 d002228:	d0007fc0 	call	d0007fc <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 d00222c:	e13fba17 	ldw	r4,-280(fp)
 d002230:	01400044 	movi	r5,1
 d002234:	d028d040 	call	d028d04 <t_listen>
 d002238:	1004403a 	cmpge	r2,r2,zero
 d00223c:	1000041e 	bne	r2,zero,d002250 <SSSSimpleSocketServerTask+0xa0>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 d002240:	01003fc4 	movi	r4,255
 d002244:	01434174 	movhi	r5,3333
 d002248:	29760604 	addi	r5,r5,-10216
 d00224c:	d0007fc0 	call	d0007fc <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 d002250:	01034174 	movhi	r4,3333
 d002254:	211b7b04 	addi	r4,r4,28140
 d002258:	d001b600 	call	d001b60 <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 d00225c:	01034174 	movhi	r4,3333
 d002260:	21360d04 	addi	r4,r4,-10188
 d002264:	01400784 	movi	r5,30
 d002268:	d0028a00 	call	d0028a0 <printf>
 d00226c:	00000006 	br	d002270 <SSSSimpleSocketServerTask+0xc0>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 d002270:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 d002274:	e17fbf04 	addi	r5,fp,-260
 d002278:	e13fba17 	ldw	r4,-280(fp)
 d00227c:	d02e0f40 	call	d02e0f4 <ifd_set>
    max_socket = fd_listen+1;
 d002280:	e0bfba17 	ldw	r2,-280(fp)
 d002284:	10800044 	addi	r2,r2,1
 d002288:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 d00228c:	00834174 	movhi	r2,3333
 d002290:	109b7b04 	addi	r2,r2,28140
 d002294:	10800117 	ldw	r2,4(r2)
 d002298:	10bfffe0 	cmpeqi	r2,r2,-1
 d00229c:	10000f1e 	bne	r2,zero,d0022dc <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 d0022a0:	00834174 	movhi	r2,3333
 d0022a4:	109b7b04 	addi	r2,r2,28140
 d0022a8:	11000117 	ldw	r4,4(r2)
 d0022ac:	e17fbf04 	addi	r5,fp,-260
 d0022b0:	d02e0f40 	call	d02e0f4 <ifd_set>
      if (max_socket <= conn.fd)
 d0022b4:	00834174 	movhi	r2,3333
 d0022b8:	109b7b04 	addi	r2,r2,28140
 d0022bc:	10c00117 	ldw	r3,4(r2)
 d0022c0:	e0bfb917 	ldw	r2,-284(fp)
 d0022c4:	18800516 	blt	r3,r2,d0022dc <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 d0022c8:	00834174 	movhi	r2,3333
 d0022cc:	109b7b04 	addi	r2,r2,28140
 d0022d0:	10800117 	ldw	r2,4(r2)
 d0022d4:	10800044 	addi	r2,r2,1
 d0022d8:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 d0022dc:	e17fbf04 	addi	r5,fp,-260
 d0022e0:	d8000015 	stw	zero,0(sp)
 d0022e4:	e13fb917 	ldw	r4,-284(fp)
 d0022e8:	000d883a 	mov	r6,zero
 d0022ec:	000f883a 	mov	r7,zero
 d0022f0:	d0202240 	call	d020224 <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 d0022f4:	e17fbf04 	addi	r5,fp,-260
 d0022f8:	e13fba17 	ldw	r4,-280(fp)
 d0022fc:	d02e1680 	call	d02e168 <ifd_isset>
 d002300:	1005003a 	cmpeq	r2,r2,zero
 d002304:	1000051e 	bne	r2,zero,d00231c <SSSSimpleSocketServerTask+0x16c>
    {
      sss_handle_accept(fd_listen, &conn);
 d002308:	e13fba17 	ldw	r4,-280(fp)
 d00230c:	01434174 	movhi	r5,3333
 d002310:	295b7b04 	addi	r5,r5,28140
 d002314:	d001d600 	call	d001d60 <sss_handle_accept>
 d002318:	003fd506 	br	d002270 <SSSSimpleSocketServerTask+0xc0>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 d00231c:	00834174 	movhi	r2,3333
 d002320:	109b7b04 	addi	r2,r2,28140
 d002324:	10800117 	ldw	r2,4(r2)
 d002328:	10bfffe0 	cmpeqi	r2,r2,-1
 d00232c:	103fd01e 	bne	r2,zero,d002270 <SSSSimpleSocketServerTask+0xc0>
 d002330:	00834174 	movhi	r2,3333
 d002334:	109b7b04 	addi	r2,r2,28140
 d002338:	11000117 	ldw	r4,4(r2)
 d00233c:	e17fbf04 	addi	r5,fp,-260
 d002340:	d02e1680 	call	d02e168 <ifd_isset>
 d002344:	1005003a 	cmpeq	r2,r2,zero
 d002348:	103fc91e 	bne	r2,zero,d002270 <SSSSimpleSocketServerTask+0xc0>
      {
        sss_handle_receive(&conn);
 d00234c:	01034174 	movhi	r4,3333
 d002350:	211b7b04 	addi	r4,r4,28140
 d002354:	d001fc40 	call	d001fc4 <sss_handle_receive>
      }
    }
  } /* while(1) */
 d002358:	003fc506 	br	d002270 <SSSSimpleSocketServerTask+0xc0>

0d00235c <__mulsi3>:
 d00235c:	20000a26 	beq	r4,zero,d002388 <__mulsi3+0x2c>
 d002360:	0007883a 	mov	r3,zero
 d002364:	2080004c 	andi	r2,r4,1
 d002368:	1005003a 	cmpeq	r2,r2,zero
 d00236c:	2008d07a 	srli	r4,r4,1
 d002370:	1000011e 	bne	r2,zero,d002378 <__mulsi3+0x1c>
 d002374:	1947883a 	add	r3,r3,r5
 d002378:	294b883a 	add	r5,r5,r5
 d00237c:	203ff91e 	bne	r4,zero,d002364 <__mulsi3+0x8>
 d002380:	1805883a 	mov	r2,r3
 d002384:	f800283a 	ret
 d002388:	0007883a 	mov	r3,zero
 d00238c:	1805883a 	mov	r2,r3
 d002390:	f800283a 	ret

0d002394 <fprintf>:
 d002394:	defffc04 	addi	sp,sp,-16
 d002398:	dfc00115 	stw	ra,4(sp)
 d00239c:	d9800215 	stw	r6,8(sp)
 d0023a0:	d9c00315 	stw	r7,12(sp)
 d0023a4:	d8800204 	addi	r2,sp,8
 d0023a8:	100d883a 	mov	r6,r2
 d0023ac:	d8800015 	stw	r2,0(sp)
 d0023b0:	d0053fc0 	call	d0053fc <__vfprintf_internal>
 d0023b4:	dfc00117 	ldw	ra,4(sp)
 d0023b8:	dec00404 	addi	sp,sp,16
 d0023bc:	f800283a 	ret

0d0023c0 <_fprintf_r>:
 d0023c0:	defffd04 	addi	sp,sp,-12
 d0023c4:	2807883a 	mov	r3,r5
 d0023c8:	dfc00115 	stw	ra,4(sp)
 d0023cc:	d9c00215 	stw	r7,8(sp)
 d0023d0:	d8800204 	addi	r2,sp,8
 d0023d4:	300b883a 	mov	r5,r6
 d0023d8:	1809883a 	mov	r4,r3
 d0023dc:	100d883a 	mov	r6,r2
 d0023e0:	d8800015 	stw	r2,0(sp)
 d0023e4:	d0053fc0 	call	d0053fc <__vfprintf_internal>
 d0023e8:	dfc00117 	ldw	ra,4(sp)
 d0023ec:	dec00304 	addi	sp,sp,12
 d0023f0:	f800283a 	ret

0d0023f4 <_fwrite_r>:
 d0023f4:	defff604 	addi	sp,sp,-40
 d0023f8:	dc000515 	stw	r16,20(sp)
 d0023fc:	d9400015 	stw	r5,0(sp)
 d002400:	2021883a 	mov	r16,r4
 d002404:	300b883a 	mov	r5,r6
 d002408:	3809883a 	mov	r4,r7
 d00240c:	dcc00815 	stw	r19,32(sp)
 d002410:	dc800715 	stw	r18,28(sp)
 d002414:	dc400615 	stw	r17,24(sp)
 d002418:	dfc00915 	stw	ra,36(sp)
 d00241c:	3825883a 	mov	r18,r7
 d002420:	3027883a 	mov	r19,r6
 d002424:	d00235c0 	call	d00235c <__mulsi3>
 d002428:	1023883a 	mov	r17,r2
 d00242c:	00800044 	movi	r2,1
 d002430:	d8800315 	stw	r2,12(sp)
 d002434:	dc400115 	stw	r17,4(sp)
 d002438:	dc400415 	stw	r17,16(sp)
 d00243c:	dec00215 	stw	sp,8(sp)
 d002440:	80000326 	beq	r16,zero,d002450 <_fwrite_r+0x5c>
 d002444:	80800e17 	ldw	r2,56(r16)
 d002448:	8009883a 	mov	r4,r16
 d00244c:	10001226 	beq	r2,zero,d002498 <_fwrite_r+0xa4>
 d002450:	d9400a17 	ldw	r5,40(sp)
 d002454:	8009883a 	mov	r4,r16
 d002458:	d9800204 	addi	r6,sp,8
 d00245c:	d0079500 	call	d007950 <__sfvwrite_r>
 d002460:	980b883a 	mov	r5,r19
 d002464:	10000426 	beq	r2,zero,d002478 <_fwrite_r+0x84>
 d002468:	d9000417 	ldw	r4,16(sp)
 d00246c:	8909c83a 	sub	r4,r17,r4
 d002470:	d00c90c0 	call	d00c90c <__udivsi3>
 d002474:	1025883a 	mov	r18,r2
 d002478:	9005883a 	mov	r2,r18
 d00247c:	dfc00917 	ldw	ra,36(sp)
 d002480:	dcc00817 	ldw	r19,32(sp)
 d002484:	dc800717 	ldw	r18,28(sp)
 d002488:	dc400617 	ldw	r17,24(sp)
 d00248c:	dc000517 	ldw	r16,20(sp)
 d002490:	dec00a04 	addi	sp,sp,40
 d002494:	f800283a 	ret
 d002498:	d0071380 	call	d007138 <__sinit>
 d00249c:	003fec06 	br	d002450 <_fwrite_r+0x5c>

0d0024a0 <fwrite>:
 d0024a0:	00834174 	movhi	r2,3333
 d0024a4:	10922004 	addi	r2,r2,18560
 d0024a8:	2017883a 	mov	r11,r4
 d0024ac:	11000017 	ldw	r4,0(r2)
 d0024b0:	defffe04 	addi	sp,sp,-8
 d0024b4:	3013883a 	mov	r9,r6
 d0024b8:	2805883a 	mov	r2,r5
 d0024bc:	d9c00015 	stw	r7,0(sp)
 d0024c0:	580b883a 	mov	r5,r11
 d0024c4:	100d883a 	mov	r6,r2
 d0024c8:	480f883a 	mov	r7,r9
 d0024cc:	dfc00115 	stw	ra,4(sp)
 d0024d0:	d0023f40 	call	d0023f4 <_fwrite_r>
 d0024d4:	dfc00117 	ldw	ra,4(sp)
 d0024d8:	dec00204 	addi	sp,sp,8
 d0024dc:	f800283a 	ret

0d0024e0 <getc>:
 d0024e0:	defffd04 	addi	sp,sp,-12
 d0024e4:	dc400115 	stw	r17,4(sp)
 d0024e8:	04434174 	movhi	r17,3333
 d0024ec:	8c522004 	addi	r17,r17,18560
 d0024f0:	88c00017 	ldw	r3,0(r17)
 d0024f4:	dc000015 	stw	r16,0(sp)
 d0024f8:	dfc00215 	stw	ra,8(sp)
 d0024fc:	2021883a 	mov	r16,r4
 d002500:	18000326 	beq	r3,zero,d002510 <getc+0x30>
 d002504:	18800e17 	ldw	r2,56(r3)
 d002508:	1809883a 	mov	r4,r3
 d00250c:	10000e26 	beq	r2,zero,d002548 <getc+0x68>
 d002510:	80800117 	ldw	r2,4(r16)
 d002514:	800b883a 	mov	r5,r16
 d002518:	10bfffc4 	addi	r2,r2,-1
 d00251c:	80800115 	stw	r2,4(r16)
 d002520:	10000f16 	blt	r2,zero,d002560 <getc+0x80>
 d002524:	80c00017 	ldw	r3,0(r16)
 d002528:	18800003 	ldbu	r2,0(r3)
 d00252c:	18c00044 	addi	r3,r3,1
 d002530:	80c00015 	stw	r3,0(r16)
 d002534:	dfc00217 	ldw	ra,8(sp)
 d002538:	dc400117 	ldw	r17,4(sp)
 d00253c:	dc000017 	ldw	r16,0(sp)
 d002540:	dec00304 	addi	sp,sp,12
 d002544:	f800283a 	ret
 d002548:	d0071380 	call	d007138 <__sinit>
 d00254c:	80800117 	ldw	r2,4(r16)
 d002550:	800b883a 	mov	r5,r16
 d002554:	10bfffc4 	addi	r2,r2,-1
 d002558:	80800115 	stw	r2,4(r16)
 d00255c:	103ff10e 	bge	r2,zero,d002524 <getc+0x44>
 d002560:	89000017 	ldw	r4,0(r17)
 d002564:	dfc00217 	ldw	ra,8(sp)
 d002568:	dc400117 	ldw	r17,4(sp)
 d00256c:	dc000017 	ldw	r16,0(sp)
 d002570:	dec00304 	addi	sp,sp,12
 d002574:	d002bdc1 	jmpi	d002bdc <__srget_r>

0d002578 <_getc_r>:
 d002578:	defffd04 	addi	sp,sp,-12
 d00257c:	dc400115 	stw	r17,4(sp)
 d002580:	dc000015 	stw	r16,0(sp)
 d002584:	dfc00215 	stw	ra,8(sp)
 d002588:	2021883a 	mov	r16,r4
 d00258c:	2823883a 	mov	r17,r5
 d002590:	20000226 	beq	r4,zero,d00259c <_getc_r+0x24>
 d002594:	20800e17 	ldw	r2,56(r4)
 d002598:	10000f26 	beq	r2,zero,d0025d8 <_getc_r+0x60>
 d00259c:	88800117 	ldw	r2,4(r17)
 d0025a0:	8009883a 	mov	r4,r16
 d0025a4:	880b883a 	mov	r5,r17
 d0025a8:	10bfffc4 	addi	r2,r2,-1
 d0025ac:	88800115 	stw	r2,4(r17)
 d0025b0:	10001016 	blt	r2,zero,d0025f4 <_getc_r+0x7c>
 d0025b4:	88c00017 	ldw	r3,0(r17)
 d0025b8:	18800003 	ldbu	r2,0(r3)
 d0025bc:	18c00044 	addi	r3,r3,1
 d0025c0:	88c00015 	stw	r3,0(r17)
 d0025c4:	dfc00217 	ldw	ra,8(sp)
 d0025c8:	dc400117 	ldw	r17,4(sp)
 d0025cc:	dc000017 	ldw	r16,0(sp)
 d0025d0:	dec00304 	addi	sp,sp,12
 d0025d4:	f800283a 	ret
 d0025d8:	d0071380 	call	d007138 <__sinit>
 d0025dc:	88800117 	ldw	r2,4(r17)
 d0025e0:	8009883a 	mov	r4,r16
 d0025e4:	880b883a 	mov	r5,r17
 d0025e8:	10bfffc4 	addi	r2,r2,-1
 d0025ec:	88800115 	stw	r2,4(r17)
 d0025f0:	103ff00e 	bge	r2,zero,d0025b4 <_getc_r+0x3c>
 d0025f4:	dfc00217 	ldw	ra,8(sp)
 d0025f8:	dc400117 	ldw	r17,4(sp)
 d0025fc:	dc000017 	ldw	r16,0(sp)
 d002600:	dec00304 	addi	sp,sp,12
 d002604:	d002bdc1 	jmpi	d002bdc <__srget_r>

0d002608 <memcpy>:
 d002608:	01c003c4 	movi	r7,15
 d00260c:	2007883a 	mov	r3,r4
 d002610:	3980032e 	bgeu	r7,r6,d002620 <memcpy+0x18>
 d002614:	2904b03a 	or	r2,r5,r4
 d002618:	108000cc 	andi	r2,r2,3
 d00261c:	10000926 	beq	r2,zero,d002644 <memcpy+0x3c>
 d002620:	30000626 	beq	r6,zero,d00263c <memcpy+0x34>
 d002624:	30cd883a 	add	r6,r6,r3
 d002628:	28800003 	ldbu	r2,0(r5)
 d00262c:	29400044 	addi	r5,r5,1
 d002630:	18800005 	stb	r2,0(r3)
 d002634:	18c00044 	addi	r3,r3,1
 d002638:	30fffb1e 	bne	r6,r3,d002628 <memcpy+0x20>
 d00263c:	2005883a 	mov	r2,r4
 d002640:	f800283a 	ret
 d002644:	3811883a 	mov	r8,r7
 d002648:	200f883a 	mov	r7,r4
 d00264c:	28c00017 	ldw	r3,0(r5)
 d002650:	31bffc04 	addi	r6,r6,-16
 d002654:	38c00015 	stw	r3,0(r7)
 d002658:	28800117 	ldw	r2,4(r5)
 d00265c:	38800115 	stw	r2,4(r7)
 d002660:	28c00217 	ldw	r3,8(r5)
 d002664:	38c00215 	stw	r3,8(r7)
 d002668:	28800317 	ldw	r2,12(r5)
 d00266c:	29400404 	addi	r5,r5,16
 d002670:	38800315 	stw	r2,12(r7)
 d002674:	39c00404 	addi	r7,r7,16
 d002678:	41bff436 	bltu	r8,r6,d00264c <memcpy+0x44>
 d00267c:	008000c4 	movi	r2,3
 d002680:	1180072e 	bgeu	r2,r6,d0026a0 <memcpy+0x98>
 d002684:	1007883a 	mov	r3,r2
 d002688:	28800017 	ldw	r2,0(r5)
 d00268c:	31bfff04 	addi	r6,r6,-4
 d002690:	29400104 	addi	r5,r5,4
 d002694:	38800015 	stw	r2,0(r7)
 d002698:	39c00104 	addi	r7,r7,4
 d00269c:	19bffa36 	bltu	r3,r6,d002688 <memcpy+0x80>
 d0026a0:	3807883a 	mov	r3,r7
 d0026a4:	003fde06 	br	d002620 <memcpy+0x18>

0d0026a8 <memmove>:
 d0026a8:	2807883a 	mov	r3,r5
 d0026ac:	2011883a 	mov	r8,r4
 d0026b0:	29000c2e 	bgeu	r5,r4,d0026e4 <memmove+0x3c>
 d0026b4:	298f883a 	add	r7,r5,r6
 d0026b8:	21c00a2e 	bgeu	r4,r7,d0026e4 <memmove+0x3c>
 d0026bc:	30000726 	beq	r6,zero,d0026dc <memmove+0x34>
 d0026c0:	2187883a 	add	r3,r4,r6
 d0026c4:	198dc83a 	sub	r6,r3,r6
 d0026c8:	39ffffc4 	addi	r7,r7,-1
 d0026cc:	38800003 	ldbu	r2,0(r7)
 d0026d0:	18ffffc4 	addi	r3,r3,-1
 d0026d4:	18800005 	stb	r2,0(r3)
 d0026d8:	19bffb1e 	bne	r3,r6,d0026c8 <memmove+0x20>
 d0026dc:	2005883a 	mov	r2,r4
 d0026e0:	f800283a 	ret
 d0026e4:	01c003c4 	movi	r7,15
 d0026e8:	39800a36 	bltu	r7,r6,d002714 <memmove+0x6c>
 d0026ec:	303ffb26 	beq	r6,zero,d0026dc <memmove+0x34>
 d0026f0:	400f883a 	mov	r7,r8
 d0026f4:	320d883a 	add	r6,r6,r8
 d0026f8:	28800003 	ldbu	r2,0(r5)
 d0026fc:	29400044 	addi	r5,r5,1
 d002700:	38800005 	stb	r2,0(r7)
 d002704:	39c00044 	addi	r7,r7,1
 d002708:	39bffb1e 	bne	r7,r6,d0026f8 <memmove+0x50>
 d00270c:	2005883a 	mov	r2,r4
 d002710:	f800283a 	ret
 d002714:	1904b03a 	or	r2,r3,r4
 d002718:	108000cc 	andi	r2,r2,3
 d00271c:	103ff31e 	bne	r2,zero,d0026ec <memmove+0x44>
 d002720:	3811883a 	mov	r8,r7
 d002724:	180b883a 	mov	r5,r3
 d002728:	200f883a 	mov	r7,r4
 d00272c:	28c00017 	ldw	r3,0(r5)
 d002730:	31bffc04 	addi	r6,r6,-16
 d002734:	38c00015 	stw	r3,0(r7)
 d002738:	28800117 	ldw	r2,4(r5)
 d00273c:	38800115 	stw	r2,4(r7)
 d002740:	28c00217 	ldw	r3,8(r5)
 d002744:	38c00215 	stw	r3,8(r7)
 d002748:	28800317 	ldw	r2,12(r5)
 d00274c:	29400404 	addi	r5,r5,16
 d002750:	38800315 	stw	r2,12(r7)
 d002754:	39c00404 	addi	r7,r7,16
 d002758:	41bff436 	bltu	r8,r6,d00272c <memmove+0x84>
 d00275c:	008000c4 	movi	r2,3
 d002760:	1180072e 	bgeu	r2,r6,d002780 <memmove+0xd8>
 d002764:	1007883a 	mov	r3,r2
 d002768:	28800017 	ldw	r2,0(r5)
 d00276c:	31bfff04 	addi	r6,r6,-4
 d002770:	29400104 	addi	r5,r5,4
 d002774:	38800015 	stw	r2,0(r7)
 d002778:	39c00104 	addi	r7,r7,4
 d00277c:	19bffa36 	bltu	r3,r6,d002768 <memmove+0xc0>
 d002780:	3811883a 	mov	r8,r7
 d002784:	003fd906 	br	d0026ec <memmove+0x44>

0d002788 <memset>:
 d002788:	008000c4 	movi	r2,3
 d00278c:	29403fcc 	andi	r5,r5,255
 d002790:	2007883a 	mov	r3,r4
 d002794:	1180022e 	bgeu	r2,r6,d0027a0 <memset+0x18>
 d002798:	2084703a 	and	r2,r4,r2
 d00279c:	10000826 	beq	r2,zero,d0027c0 <memset+0x38>
 d0027a0:	30000526 	beq	r6,zero,d0027b8 <memset+0x30>
 d0027a4:	2805883a 	mov	r2,r5
 d0027a8:	30cd883a 	add	r6,r6,r3
 d0027ac:	18800005 	stb	r2,0(r3)
 d0027b0:	18c00044 	addi	r3,r3,1
 d0027b4:	19bffd1e 	bne	r3,r6,d0027ac <memset+0x24>
 d0027b8:	2005883a 	mov	r2,r4
 d0027bc:	f800283a 	ret
 d0027c0:	2804923a 	slli	r2,r5,8
 d0027c4:	020003c4 	movi	r8,15
 d0027c8:	200f883a 	mov	r7,r4
 d0027cc:	2884b03a 	or	r2,r5,r2
 d0027d0:	1006943a 	slli	r3,r2,16
 d0027d4:	10c6b03a 	or	r3,r2,r3
 d0027d8:	41800a2e 	bgeu	r8,r6,d002804 <memset+0x7c>
 d0027dc:	4005883a 	mov	r2,r8
 d0027e0:	31bffc04 	addi	r6,r6,-16
 d0027e4:	38c00015 	stw	r3,0(r7)
 d0027e8:	38c00115 	stw	r3,4(r7)
 d0027ec:	38c00215 	stw	r3,8(r7)
 d0027f0:	38c00315 	stw	r3,12(r7)
 d0027f4:	39c00404 	addi	r7,r7,16
 d0027f8:	11bff936 	bltu	r2,r6,d0027e0 <memset+0x58>
 d0027fc:	008000c4 	movi	r2,3
 d002800:	1180052e 	bgeu	r2,r6,d002818 <memset+0x90>
 d002804:	31bfff04 	addi	r6,r6,-4
 d002808:	008000c4 	movi	r2,3
 d00280c:	38c00015 	stw	r3,0(r7)
 d002810:	39c00104 	addi	r7,r7,4
 d002814:	11bffb36 	bltu	r2,r6,d002804 <memset+0x7c>
 d002818:	3807883a 	mov	r3,r7
 d00281c:	003fe006 	br	d0027a0 <memset+0x18>

0d002820 <_perror_r>:
 d002820:	defffe04 	addi	sp,sp,-8
 d002824:	dc000015 	stw	r16,0(sp)
 d002828:	dfc00115 	stw	ra,4(sp)
 d00282c:	2021883a 	mov	r16,r4
 d002830:	28000326 	beq	r5,zero,d002840 <_perror_r+0x20>
 d002834:	28800007 	ldb	r2,0(r5)
 d002838:	2809883a 	mov	r4,r5
 d00283c:	10000c1e 	bne	r2,zero,d002870 <_perror_r+0x50>
 d002840:	81000017 	ldw	r4,0(r16)
 d002844:	d002df00 	call	d002df0 <strerror>
 d002848:	1009883a 	mov	r4,r2
 d00284c:	10000226 	beq	r2,zero,d002858 <_perror_r+0x38>
 d002850:	81400317 	ldw	r5,12(r16)
 d002854:	d0074f40 	call	d0074f4 <fputs>
 d002858:	81400317 	ldw	r5,12(r16)
 d00285c:	01000284 	movi	r4,10
 d002860:	dfc00117 	ldw	ra,4(sp)
 d002864:	dc000017 	ldw	r16,0(sp)
 d002868:	dec00204 	addi	sp,sp,8
 d00286c:	d0073c41 	jmpi	d0073c4 <fputc>
 d002870:	81400317 	ldw	r5,12(r16)
 d002874:	d0074f40 	call	d0074f4 <fputs>
 d002878:	81400317 	ldw	r5,12(r16)
 d00287c:	01034174 	movhi	r4,3333
 d002880:	2136c504 	addi	r4,r4,-9452
 d002884:	d0074f40 	call	d0074f4 <fputs>
 d002888:	003fed06 	br	d002840 <_perror_r+0x20>

0d00288c <perror>:
 d00288c:	00834174 	movhi	r2,3333
 d002890:	10922004 	addi	r2,r2,18560
 d002894:	200b883a 	mov	r5,r4
 d002898:	11000017 	ldw	r4,0(r2)
 d00289c:	d0028201 	jmpi	d002820 <_perror_r>

0d0028a0 <printf>:
 d0028a0:	defffb04 	addi	sp,sp,-20
 d0028a4:	dfc00115 	stw	ra,4(sp)
 d0028a8:	d9400215 	stw	r5,8(sp)
 d0028ac:	d9800315 	stw	r6,12(sp)
 d0028b0:	d9c00415 	stw	r7,16(sp)
 d0028b4:	00834174 	movhi	r2,3333
 d0028b8:	10922004 	addi	r2,r2,18560
 d0028bc:	10c00017 	ldw	r3,0(r2)
 d0028c0:	200b883a 	mov	r5,r4
 d0028c4:	d8800204 	addi	r2,sp,8
 d0028c8:	19000217 	ldw	r4,8(r3)
 d0028cc:	100d883a 	mov	r6,r2
 d0028d0:	d8800015 	stw	r2,0(sp)
 d0028d4:	d0053fc0 	call	d0053fc <__vfprintf_internal>
 d0028d8:	dfc00117 	ldw	ra,4(sp)
 d0028dc:	dec00504 	addi	sp,sp,20
 d0028e0:	f800283a 	ret

0d0028e4 <_printf_r>:
 d0028e4:	defffc04 	addi	sp,sp,-16
 d0028e8:	dfc00115 	stw	ra,4(sp)
 d0028ec:	d9800215 	stw	r6,8(sp)
 d0028f0:	d9c00315 	stw	r7,12(sp)
 d0028f4:	280d883a 	mov	r6,r5
 d0028f8:	21400217 	ldw	r5,8(r4)
 d0028fc:	d8c00204 	addi	r3,sp,8
 d002900:	180f883a 	mov	r7,r3
 d002904:	d8c00015 	stw	r3,0(sp)
 d002908:	d0035380 	call	d003538 <___vfprintf_internal_r>
 d00290c:	dfc00117 	ldw	ra,4(sp)
 d002910:	dec00404 	addi	sp,sp,16
 d002914:	f800283a 	ret

0d002918 <putc>:
 d002918:	defffc04 	addi	sp,sp,-16
 d00291c:	dc800215 	stw	r18,8(sp)
 d002920:	04834174 	movhi	r18,3333
 d002924:	94922004 	addi	r18,r18,18560
 d002928:	90c00017 	ldw	r3,0(r18)
 d00292c:	dc400115 	stw	r17,4(sp)
 d002930:	dc000015 	stw	r16,0(sp)
 d002934:	dfc00315 	stw	ra,12(sp)
 d002938:	2023883a 	mov	r17,r4
 d00293c:	2821883a 	mov	r16,r5
 d002940:	18000226 	beq	r3,zero,d00294c <putc+0x34>
 d002944:	18800e17 	ldw	r2,56(r3)
 d002948:	10001126 	beq	r2,zero,d002990 <putc+0x78>
 d00294c:	80800217 	ldw	r2,8(r16)
 d002950:	10ffffc4 	addi	r3,r2,-1
 d002954:	80c00215 	stw	r3,8(r16)
 d002958:	18001316 	blt	r3,zero,d0029a8 <putc+0x90>
 d00295c:	80800017 	ldw	r2,0(r16)
 d002960:	14400005 	stb	r17,0(r2)
 d002964:	80c00017 	ldw	r3,0(r16)
 d002968:	18800044 	addi	r2,r3,1
 d00296c:	18c00003 	ldbu	r3,0(r3)
 d002970:	80800015 	stw	r2,0(r16)
 d002974:	1805883a 	mov	r2,r3
 d002978:	dfc00317 	ldw	ra,12(sp)
 d00297c:	dc800217 	ldw	r18,8(sp)
 d002980:	dc400117 	ldw	r17,4(sp)
 d002984:	dc000017 	ldw	r16,0(sp)
 d002988:	dec00404 	addi	sp,sp,16
 d00298c:	f800283a 	ret
 d002990:	1809883a 	mov	r4,r3
 d002994:	d0071380 	call	d007138 <__sinit>
 d002998:	80800217 	ldw	r2,8(r16)
 d00299c:	10ffffc4 	addi	r3,r2,-1
 d0029a0:	80c00215 	stw	r3,8(r16)
 d0029a4:	183fed0e 	bge	r3,zero,d00295c <putc+0x44>
 d0029a8:	80800617 	ldw	r2,24(r16)
 d0029ac:	18800f16 	blt	r3,r2,d0029ec <putc+0xd4>
 d0029b0:	80800017 	ldw	r2,0(r16)
 d0029b4:	14400005 	stb	r17,0(r2)
 d0029b8:	81000017 	ldw	r4,0(r16)
 d0029bc:	00800284 	movi	r2,10
 d0029c0:	20c00003 	ldbu	r3,0(r4)
 d0029c4:	18801226 	beq	r3,r2,d002a10 <putc+0xf8>
 d0029c8:	20800044 	addi	r2,r4,1
 d0029cc:	80800015 	stw	r2,0(r16)
 d0029d0:	1805883a 	mov	r2,r3
 d0029d4:	dfc00317 	ldw	ra,12(sp)
 d0029d8:	dc800217 	ldw	r18,8(sp)
 d0029dc:	dc400117 	ldw	r17,4(sp)
 d0029e0:	dc000017 	ldw	r16,0(sp)
 d0029e4:	dec00404 	addi	sp,sp,16
 d0029e8:	f800283a 	ret
 d0029ec:	91000017 	ldw	r4,0(r18)
 d0029f0:	880b883a 	mov	r5,r17
 d0029f4:	800d883a 	mov	r6,r16
 d0029f8:	dfc00317 	ldw	ra,12(sp)
 d0029fc:	dc800217 	ldw	r18,8(sp)
 d002a00:	dc400117 	ldw	r17,4(sp)
 d002a04:	dc000017 	ldw	r16,0(sp)
 d002a08:	dec00404 	addi	sp,sp,16
 d002a0c:	d0054201 	jmpi	d005420 <__swbuf_r>
 d002a10:	91000017 	ldw	r4,0(r18)
 d002a14:	180b883a 	mov	r5,r3
 d002a18:	003ff606 	br	d0029f4 <putc+0xdc>

0d002a1c <_putc_r>:
 d002a1c:	defffc04 	addi	sp,sp,-16
 d002a20:	dc400215 	stw	r17,8(sp)
 d002a24:	dc000115 	stw	r16,4(sp)
 d002a28:	dfc00315 	stw	ra,12(sp)
 d002a2c:	2021883a 	mov	r16,r4
 d002a30:	2823883a 	mov	r17,r5
 d002a34:	20000226 	beq	r4,zero,d002a40 <_putc_r+0x24>
 d002a38:	20800e17 	ldw	r2,56(r4)
 d002a3c:	10001026 	beq	r2,zero,d002a80 <_putc_r+0x64>
 d002a40:	30800217 	ldw	r2,8(r6)
 d002a44:	10ffffc4 	addi	r3,r2,-1
 d002a48:	30c00215 	stw	r3,8(r6)
 d002a4c:	18001316 	blt	r3,zero,d002a9c <_putc_r+0x80>
 d002a50:	30800017 	ldw	r2,0(r6)
 d002a54:	14400005 	stb	r17,0(r2)
 d002a58:	30c00017 	ldw	r3,0(r6)
 d002a5c:	18800044 	addi	r2,r3,1
 d002a60:	18c00003 	ldbu	r3,0(r3)
 d002a64:	30800015 	stw	r2,0(r6)
 d002a68:	1805883a 	mov	r2,r3
 d002a6c:	dfc00317 	ldw	ra,12(sp)
 d002a70:	dc400217 	ldw	r17,8(sp)
 d002a74:	dc000117 	ldw	r16,4(sp)
 d002a78:	dec00404 	addi	sp,sp,16
 d002a7c:	f800283a 	ret
 d002a80:	d9800015 	stw	r6,0(sp)
 d002a84:	d0071380 	call	d007138 <__sinit>
 d002a88:	d9800017 	ldw	r6,0(sp)
 d002a8c:	30800217 	ldw	r2,8(r6)
 d002a90:	10ffffc4 	addi	r3,r2,-1
 d002a94:	30c00215 	stw	r3,8(r6)
 d002a98:	183fed0e 	bge	r3,zero,d002a50 <_putc_r+0x34>
 d002a9c:	30800617 	ldw	r2,24(r6)
 d002aa0:	18800e16 	blt	r3,r2,d002adc <_putc_r+0xc0>
 d002aa4:	30800017 	ldw	r2,0(r6)
 d002aa8:	14400005 	stb	r17,0(r2)
 d002aac:	31000017 	ldw	r4,0(r6)
 d002ab0:	00800284 	movi	r2,10
 d002ab4:	20c00003 	ldbu	r3,0(r4)
 d002ab8:	18800f26 	beq	r3,r2,d002af8 <_putc_r+0xdc>
 d002abc:	20800044 	addi	r2,r4,1
 d002ac0:	30800015 	stw	r2,0(r6)
 d002ac4:	1805883a 	mov	r2,r3
 d002ac8:	dfc00317 	ldw	ra,12(sp)
 d002acc:	dc400217 	ldw	r17,8(sp)
 d002ad0:	dc000117 	ldw	r16,4(sp)
 d002ad4:	dec00404 	addi	sp,sp,16
 d002ad8:	f800283a 	ret
 d002adc:	8009883a 	mov	r4,r16
 d002ae0:	880b883a 	mov	r5,r17
 d002ae4:	dfc00317 	ldw	ra,12(sp)
 d002ae8:	dc400217 	ldw	r17,8(sp)
 d002aec:	dc000117 	ldw	r16,4(sp)
 d002af0:	dec00404 	addi	sp,sp,16
 d002af4:	d0054201 	jmpi	d005420 <__swbuf_r>
 d002af8:	8009883a 	mov	r4,r16
 d002afc:	180b883a 	mov	r5,r3
 d002b00:	003ff806 	br	d002ae4 <_putc_r+0xc8>

0d002b04 <putchar>:
 d002b04:	00834174 	movhi	r2,3333
 d002b08:	10922004 	addi	r2,r2,18560
 d002b0c:	11800017 	ldw	r6,0(r2)
 d002b10:	200b883a 	mov	r5,r4
 d002b14:	3009883a 	mov	r4,r6
 d002b18:	31800217 	ldw	r6,8(r6)
 d002b1c:	d002a1c1 	jmpi	d002a1c <_putc_r>

0d002b20 <_putchar_r>:
 d002b20:	21800217 	ldw	r6,8(r4)
 d002b24:	d002a1c1 	jmpi	d002a1c <_putc_r>

0d002b28 <_puts_r>:
 d002b28:	defff604 	addi	sp,sp,-40
 d002b2c:	dc400715 	stw	r17,28(sp)
 d002b30:	2023883a 	mov	r17,r4
 d002b34:	2809883a 	mov	r4,r5
 d002b38:	dfc00915 	stw	ra,36(sp)
 d002b3c:	dcc00815 	stw	r19,32(sp)
 d002b40:	2827883a 	mov	r19,r5
 d002b44:	d0034640 	call	d003464 <strlen>
 d002b48:	89400217 	ldw	r5,8(r17)
 d002b4c:	00c34174 	movhi	r3,3333
 d002b50:	18f6c604 	addi	r3,r3,-9448
 d002b54:	01c00044 	movi	r7,1
 d002b58:	12000044 	addi	r8,r2,1
 d002b5c:	d8c00515 	stw	r3,20(sp)
 d002b60:	d9c00615 	stw	r7,24(sp)
 d002b64:	d8c00304 	addi	r3,sp,12
 d002b68:	01c00084 	movi	r7,2
 d002b6c:	8809883a 	mov	r4,r17
 d002b70:	d80d883a 	mov	r6,sp
 d002b74:	d8c00015 	stw	r3,0(sp)
 d002b78:	dcc00315 	stw	r19,12(sp)
 d002b7c:	da000215 	stw	r8,8(sp)
 d002b80:	d9c00115 	stw	r7,4(sp)
 d002b84:	d8800415 	stw	r2,16(sp)
 d002b88:	d0079500 	call	d007950 <__sfvwrite_r>
 d002b8c:	00ffffc4 	movi	r3,-1
 d002b90:	10000626 	beq	r2,zero,d002bac <_puts_r+0x84>
 d002b94:	1805883a 	mov	r2,r3
 d002b98:	dfc00917 	ldw	ra,36(sp)
 d002b9c:	dcc00817 	ldw	r19,32(sp)
 d002ba0:	dc400717 	ldw	r17,28(sp)
 d002ba4:	dec00a04 	addi	sp,sp,40
 d002ba8:	f800283a 	ret
 d002bac:	00c00284 	movi	r3,10
 d002bb0:	1805883a 	mov	r2,r3
 d002bb4:	dfc00917 	ldw	ra,36(sp)
 d002bb8:	dcc00817 	ldw	r19,32(sp)
 d002bbc:	dc400717 	ldw	r17,28(sp)
 d002bc0:	dec00a04 	addi	sp,sp,40
 d002bc4:	f800283a 	ret

0d002bc8 <puts>:
 d002bc8:	00834174 	movhi	r2,3333
 d002bcc:	10922004 	addi	r2,r2,18560
 d002bd0:	200b883a 	mov	r5,r4
 d002bd4:	11000017 	ldw	r4,0(r2)
 d002bd8:	d002b281 	jmpi	d002b28 <_puts_r>

0d002bdc <__srget_r>:
 d002bdc:	defffe04 	addi	sp,sp,-8
 d002be0:	dc000015 	stw	r16,0(sp)
 d002be4:	dfc00115 	stw	ra,4(sp)
 d002be8:	2821883a 	mov	r16,r5
 d002bec:	d00a0680 	call	d00a068 <__srefill_r>
 d002bf0:	013fffc4 	movi	r4,-1
 d002bf4:	1000071e 	bne	r2,zero,d002c14 <__srget_r+0x38>
 d002bf8:	80800117 	ldw	r2,4(r16)
 d002bfc:	81000017 	ldw	r4,0(r16)
 d002c00:	10bfffc4 	addi	r2,r2,-1
 d002c04:	20c00044 	addi	r3,r4,1
 d002c08:	80800115 	stw	r2,4(r16)
 d002c0c:	21000003 	ldbu	r4,0(r4)
 d002c10:	80c00015 	stw	r3,0(r16)
 d002c14:	2005883a 	mov	r2,r4
 d002c18:	dfc00117 	ldw	ra,4(sp)
 d002c1c:	dc000017 	ldw	r16,0(sp)
 d002c20:	dec00204 	addi	sp,sp,8
 d002c24:	f800283a 	ret

0d002c28 <__srget>:
 d002c28:	00834174 	movhi	r2,3333
 d002c2c:	10922004 	addi	r2,r2,18560
 d002c30:	200b883a 	mov	r5,r4
 d002c34:	11000017 	ldw	r4,0(r2)
 d002c38:	d002bdc1 	jmpi	d002bdc <__srget_r>

0d002c3c <sprintf>:
 d002c3c:	deffe504 	addi	sp,sp,-108
 d002c40:	2013883a 	mov	r9,r4
 d002c44:	dfc01815 	stw	ra,96(sp)
 d002c48:	d9801915 	stw	r6,100(sp)
 d002c4c:	d9c01a15 	stw	r7,104(sp)
 d002c50:	d8801904 	addi	r2,sp,100
 d002c54:	d8800015 	stw	r2,0(sp)
 d002c58:	00834174 	movhi	r2,3333
 d002c5c:	10922004 	addi	r2,r2,18560
 d002c60:	11000017 	ldw	r4,0(r2)
 d002c64:	d9c00017 	ldw	r7,0(sp)
 d002c68:	00808204 	movi	r2,520
 d002c6c:	00e00034 	movhi	r3,32768
 d002c70:	18ffffc4 	addi	r3,r3,-1
 d002c74:	280d883a 	mov	r6,r5
 d002c78:	d880040d 	sth	r2,16(sp)
 d002c7c:	d9400104 	addi	r5,sp,4
 d002c80:	00bfffc4 	movi	r2,-1
 d002c84:	d8c00615 	stw	r3,24(sp)
 d002c88:	d8c00315 	stw	r3,12(sp)
 d002c8c:	da400515 	stw	r9,20(sp)
 d002c90:	d880048d 	sth	r2,18(sp)
 d002c94:	da400115 	stw	r9,4(sp)
 d002c98:	d0035380 	call	d003538 <___vfprintf_internal_r>
 d002c9c:	d8c00117 	ldw	r3,4(sp)
 d002ca0:	18000005 	stb	zero,0(r3)
 d002ca4:	dfc01817 	ldw	ra,96(sp)
 d002ca8:	dec01b04 	addi	sp,sp,108
 d002cac:	f800283a 	ret

0d002cb0 <_sprintf_r>:
 d002cb0:	deffe604 	addi	sp,sp,-104
 d002cb4:	2813883a 	mov	r9,r5
 d002cb8:	dfc01815 	stw	ra,96(sp)
 d002cbc:	d9c01915 	stw	r7,100(sp)
 d002cc0:	d8801904 	addi	r2,sp,100
 d002cc4:	d8800015 	stw	r2,0(sp)
 d002cc8:	100f883a 	mov	r7,r2
 d002ccc:	00808204 	movi	r2,520
 d002cd0:	00e00034 	movhi	r3,32768
 d002cd4:	18ffffc4 	addi	r3,r3,-1
 d002cd8:	d880040d 	sth	r2,16(sp)
 d002cdc:	d9400104 	addi	r5,sp,4
 d002ce0:	00bfffc4 	movi	r2,-1
 d002ce4:	d8c00615 	stw	r3,24(sp)
 d002ce8:	d8c00315 	stw	r3,12(sp)
 d002cec:	da400515 	stw	r9,20(sp)
 d002cf0:	d880048d 	sth	r2,18(sp)
 d002cf4:	da400115 	stw	r9,4(sp)
 d002cf8:	d0035380 	call	d003538 <___vfprintf_internal_r>
 d002cfc:	d8c00117 	ldw	r3,4(sp)
 d002d00:	18000005 	stb	zero,0(r3)
 d002d04:	dfc01817 	ldw	ra,96(sp)
 d002d08:	dec01a04 	addi	sp,sp,104
 d002d0c:	f800283a 	ret

0d002d10 <strchr>:
 d002d10:	208000cc 	andi	r2,r4,3
 d002d14:	2007883a 	mov	r3,r4
 d002d18:	1000311e 	bne	r2,zero,d002de0 <strchr+0xd0>
 d002d1c:	29c03fcc 	andi	r7,r5,255
 d002d20:	0015883a 	mov	r10,zero
 d002d24:	0007883a 	mov	r3,zero
 d002d28:	01400104 	movi	r5,4
 d002d2c:	5004923a 	slli	r2,r10,8
 d002d30:	18c00044 	addi	r3,r3,1
 d002d34:	3894b03a 	or	r10,r7,r2
 d002d38:	197ffc1e 	bne	r3,r5,d002d2c <strchr+0x1c>
 d002d3c:	200d883a 	mov	r6,r4
 d002d40:	21000017 	ldw	r4,0(r4)
 d002d44:	017fbff4 	movhi	r5,65279
 d002d48:	297fbfc4 	addi	r5,r5,-257
 d002d4c:	02202074 	movhi	r8,32897
 d002d50:	42202004 	addi	r8,r8,-32640
 d002d54:	2145883a 	add	r2,r4,r5
 d002d58:	1204703a 	and	r2,r2,r8
 d002d5c:	0106303a 	nor	r3,zero,r4
 d002d60:	10c4703a 	and	r2,r2,r3
 d002d64:	1000151e 	bne	r2,zero,d002dbc <strchr+0xac>
 d002d68:	2284f03a 	xor	r2,r4,r10
 d002d6c:	1147883a 	add	r3,r2,r5
 d002d70:	1a06703a 	and	r3,r3,r8
 d002d74:	0084303a 	nor	r2,zero,r2
 d002d78:	10c4703a 	and	r2,r2,r3
 d002d7c:	10000f1e 	bne	r2,zero,d002dbc <strchr+0xac>
 d002d80:	2813883a 	mov	r9,r5
 d002d84:	00000106 	br	d002d8c <strchr+0x7c>
 d002d88:	18000c1e 	bne	r3,zero,d002dbc <strchr+0xac>
 d002d8c:	31800104 	addi	r6,r6,4
 d002d90:	30800017 	ldw	r2,0(r6)
 d002d94:	1286f03a 	xor	r3,r2,r10
 d002d98:	124b883a 	add	r5,r2,r9
 d002d9c:	1a49883a 	add	r4,r3,r9
 d002da0:	2a0a703a 	and	r5,r5,r8
 d002da4:	0084303a 	nor	r2,zero,r2
 d002da8:	2208703a 	and	r4,r4,r8
 d002dac:	00c6303a 	nor	r3,zero,r3
 d002db0:	1144703a 	and	r2,r2,r5
 d002db4:	1906703a 	and	r3,r3,r4
 d002db8:	103ff326 	beq	r2,zero,d002d88 <strchr+0x78>
 d002dbc:	3007883a 	mov	r3,r6
 d002dc0:	00000206 	br	d002dcc <strchr+0xbc>
 d002dc4:	38800426 	beq	r7,r2,d002dd8 <strchr+0xc8>
 d002dc8:	18c00044 	addi	r3,r3,1
 d002dcc:	18800003 	ldbu	r2,0(r3)
 d002dd0:	103ffc1e 	bne	r2,zero,d002dc4 <strchr+0xb4>
 d002dd4:	3800041e 	bne	r7,zero,d002de8 <strchr+0xd8>
 d002dd8:	1805883a 	mov	r2,r3
 d002ddc:	f800283a 	ret
 d002de0:	29c03fcc 	andi	r7,r5,255
 d002de4:	003ff906 	br	d002dcc <strchr+0xbc>
 d002de8:	0005883a 	mov	r2,zero
 d002dec:	f800283a 	ret

0d002df0 <strerror>:
 d002df0:	deffff04 	addi	sp,sp,-4
 d002df4:	00802184 	movi	r2,134
 d002df8:	dfc00015 	stw	ra,0(sp)
 d002dfc:	200b883a 	mov	r5,r4
 d002e00:	11008e36 	bltu	r2,r4,d00303c <strerror+0x24c>
 d002e04:	2105883a 	add	r2,r4,r4
 d002e08:	1085883a 	add	r2,r2,r2
 d002e0c:	00c34034 	movhi	r3,3328
 d002e10:	18cb8804 	addi	r3,r3,11808
 d002e14:	10c5883a 	add	r2,r2,r3
 d002e18:	11000017 	ldw	r4,0(r2)
 d002e1c:	2000683a 	jmp	r4
 d002e20:	0d00303c 	xorhi	r20,at,192
 d002e24:	0d003074 	orhi	r20,at,193
 d002e28:	0d003080 	call	d00308 <__ram_exceptions_end+0xc8010c>
 d002e2c:	0d00308c 	andi	r20,at,194
 d002e30:	0d003098 	cmpnei	r20,at,194
 d002e34:	0d0030a4 	muli	r20,at,194
 d002e38:	0d0030b0 	cmpltui	r20,at,194
 d002e3c:	0d0030bc 	xorhi	r20,at,194
 d002e40:	0d0030c8 	cmpgei	r20,at,195
 d002e44:	0d0030d4 	ori	r20,at,195
 d002e48:	0d0030e0 	cmpeqi	r20,at,195
 d002e4c:	0d0030ec 	andhi	r20,at,195
 d002e50:	0d0030f8 	rdprs	r20,at,195
 d002e54:	0d003104 	addi	r20,at,196
 d002e58:	0d003110 	cmplti	r20,at,196
 d002e5c:	0d00311c 	xori	r20,at,196
 d002e60:	0d003128 	cmpgeui	r20,at,196
 d002e64:	0d003134 	orhi	r20,at,196
 d002e68:	0d003140 	call	d00314 <__ram_exceptions_end+0xc80118>
 d002e6c:	0d00314c 	andi	r20,at,197
 d002e70:	0d003158 	cmpnei	r20,at,197
 d002e74:	0d003164 	muli	r20,at,197
 d002e78:	0d003170 	cmpltui	r20,at,197
 d002e7c:	0d00317c 	xorhi	r20,at,197
 d002e80:	0d003188 	cmpgei	r20,at,198
 d002e84:	0d003194 	ori	r20,at,198
 d002e88:	0d0031a0 	cmpeqi	r20,at,198
 d002e8c:	0d0031ac 	andhi	r20,at,198
 d002e90:	0d0031b8 	rdprs	r20,at,198
 d002e94:	0d0031c4 	addi	r20,at,199
 d002e98:	0d0031d0 	cmplti	r20,at,199
 d002e9c:	0d0031dc 	xori	r20,at,199
 d002ea0:	0d0031e8 	cmpgeui	r20,at,199
 d002ea4:	0d0031f4 	orhi	r20,at,199
 d002ea8:	0d003200 	call	d00320 <__ram_exceptions_end+0xc80124>
 d002eac:	0d00320c 	andi	r20,at,200
 d002eb0:	0d003218 	cmpnei	r20,at,200
 d002eb4:	0d00303c 	xorhi	r20,at,192
 d002eb8:	0d00303c 	xorhi	r20,at,192
 d002ebc:	0d00303c 	xorhi	r20,at,192
 d002ec0:	0d00303c 	xorhi	r20,at,192
 d002ec4:	0d00303c 	xorhi	r20,at,192
 d002ec8:	0d00303c 	xorhi	r20,at,192
 d002ecc:	0d00303c 	xorhi	r20,at,192
 d002ed0:	0d00303c 	xorhi	r20,at,192
 d002ed4:	0d003224 	muli	r20,at,200
 d002ed8:	0d003230 	cmpltui	r20,at,200
 d002edc:	0d00303c 	xorhi	r20,at,192
 d002ee0:	0d00303c 	xorhi	r20,at,192
 d002ee4:	0d00303c 	xorhi	r20,at,192
 d002ee8:	0d00303c 	xorhi	r20,at,192
 d002eec:	0d00303c 	xorhi	r20,at,192
 d002ef0:	0d00303c 	xorhi	r20,at,192
 d002ef4:	0d00303c 	xorhi	r20,at,192
 d002ef8:	0d00303c 	xorhi	r20,at,192
 d002efc:	0d00303c 	xorhi	r20,at,192
 d002f00:	0d00303c 	xorhi	r20,at,192
 d002f04:	0d00303c 	xorhi	r20,at,192
 d002f08:	0d00303c 	xorhi	r20,at,192
 d002f0c:	0d00303c 	xorhi	r20,at,192
 d002f10:	0d00323c 	xorhi	r20,at,200
 d002f14:	0d00303c 	xorhi	r20,at,192
 d002f18:	0d003248 	cmpgei	r20,at,201
 d002f1c:	0d003254 	ori	r20,at,201
 d002f20:	0d003260 	cmpeqi	r20,at,201
 d002f24:	0d00326c 	andhi	r20,at,201
 d002f28:	0d003278 	rdprs	r20,at,201
 d002f2c:	0d003284 	addi	r20,at,202
 d002f30:	0d003290 	cmplti	r20,at,202
 d002f34:	0d00329c 	xori	r20,at,202
 d002f38:	0d0032a8 	cmpgeui	r20,at,202
 d002f3c:	0d0032b4 	orhi	r20,at,202
 d002f40:	0d00303c 	xorhi	r20,at,192
 d002f44:	0d00303c 	xorhi	r20,at,192
 d002f48:	0d0032c0 	call	d0032c <__ram_exceptions_end+0xc80130>
 d002f4c:	0d00303c 	xorhi	r20,at,192
 d002f50:	0d00303c 	xorhi	r20,at,192
 d002f54:	0d0032cc 	andi	r20,at,203
 d002f58:	0d00303c 	xorhi	r20,at,192
 d002f5c:	0d00303c 	xorhi	r20,at,192
 d002f60:	0d00303c 	xorhi	r20,at,192
 d002f64:	0d00303c 	xorhi	r20,at,192
 d002f68:	0d00303c 	xorhi	r20,at,192
 d002f6c:	0d0032d8 	cmpnei	r20,at,203
 d002f70:	0d0032e4 	muli	r20,at,203
 d002f74:	0d0032f0 	cmpltui	r20,at,203
 d002f78:	0d0032fc 	xorhi	r20,at,203
 d002f7c:	0d003308 	cmpgei	r20,at,204
 d002f80:	0d003314 	ori	r20,at,204
 d002f84:	0d003320 	cmpeqi	r20,at,204
 d002f88:	0d00332c 	andhi	r20,at,204
 d002f8c:	0d003338 	rdprs	r20,at,204
 d002f90:	0d003344 	addi	r20,at,205
 d002f94:	0d00303c 	xorhi	r20,at,192
 d002f98:	0d00303c 	xorhi	r20,at,192
 d002f9c:	0d003350 	cmplti	r20,at,205
 d002fa0:	0d00303c 	xorhi	r20,at,192
 d002fa4:	0d00303c 	xorhi	r20,at,192
 d002fa8:	0d00303c 	xorhi	r20,at,192
 d002fac:	0d00303c 	xorhi	r20,at,192
 d002fb0:	0d00303c 	xorhi	r20,at,192
 d002fb4:	0d00303c 	xorhi	r20,at,192
 d002fb8:	0d00303c 	xorhi	r20,at,192
 d002fbc:	0d00303c 	xorhi	r20,at,192
 d002fc0:	0d00303c 	xorhi	r20,at,192
 d002fc4:	0d00335c 	xori	r20,at,205
 d002fc8:	0d003368 	cmpgeui	r20,at,205
 d002fcc:	0d003374 	orhi	r20,at,205
 d002fd0:	0d003380 	call	d00338 <__ram_exceptions_end+0xc8013c>
 d002fd4:	0d00338c 	andi	r20,at,206
 d002fd8:	0d003398 	cmpnei	r20,at,206
 d002fdc:	0d0033a4 	muli	r20,at,206
 d002fe0:	0d0033b0 	cmpltui	r20,at,206
 d002fe4:	0d0033bc 	xorhi	r20,at,206
 d002fe8:	0d0033c8 	cmpgei	r20,at,207
 d002fec:	0d0033d4 	ori	r20,at,207
 d002ff0:	0d0033e0 	cmpeqi	r20,at,207
 d002ff4:	0d0033ec 	andhi	r20,at,207
 d002ff8:	0d0033f8 	rdprs	r20,at,207
 d002ffc:	0d003404 	addi	r20,at,208
 d003000:	0d003410 	cmplti	r20,at,208
 d003004:	0d00341c 	xori	r20,at,208
 d003008:	0d003428 	cmpgeui	r20,at,208
 d00300c:	0d003434 	orhi	r20,at,208
 d003010:	0d003440 	call	d00344 <__ram_exceptions_end+0xc80148>
 d003014:	0d00303c 	xorhi	r20,at,192
 d003018:	0d00303c 	xorhi	r20,at,192
 d00301c:	0d00344c 	andi	r20,at,209
 d003020:	0d003458 	cmpnei	r20,at,209
 d003024:	0d00303c 	xorhi	r20,at,192
 d003028:	0d00303c 	xorhi	r20,at,192
 d00302c:	0d00303c 	xorhi	r20,at,192
 d003030:	0d00303c 	xorhi	r20,at,192
 d003034:	0d00303c 	xorhi	r20,at,192
 d003038:	0d003068 	cmpgeui	r20,at,193
 d00303c:	2809883a 	mov	r4,r5
 d003040:	d0034d80 	call	d0034d8 <_user_strerror>
 d003044:	10000326 	beq	r2,zero,d003054 <strerror+0x264>
 d003048:	dfc00017 	ldw	ra,0(sp)
 d00304c:	dec00104 	addi	sp,sp,4
 d003050:	f800283a 	ret
 d003054:	00834174 	movhi	r2,3333
 d003058:	10b8bf04 	addi	r2,r2,-7428
 d00305c:	dfc00017 	ldw	ra,0(sp)
 d003060:	dec00104 	addi	sp,sp,4
 d003064:	f800283a 	ret
 d003068:	00834174 	movhi	r2,3333
 d00306c:	10b78204 	addi	r2,r2,-8696
 d003070:	003ff506 	br	d003048 <strerror+0x258>
 d003074:	00834174 	movhi	r2,3333
 d003078:	10b6d204 	addi	r2,r2,-9400
 d00307c:	003ff206 	br	d003048 <strerror+0x258>
 d003080:	00834174 	movhi	r2,3333
 d003084:	10b6d504 	addi	r2,r2,-9388
 d003088:	003fef06 	br	d003048 <strerror+0x258>
 d00308c:	00834174 	movhi	r2,3333
 d003090:	10b6dc04 	addi	r2,r2,-9360
 d003094:	003fec06 	br	d003048 <strerror+0x258>
 d003098:	00834174 	movhi	r2,3333
 d00309c:	10b6e004 	addi	r2,r2,-9344
 d0030a0:	003fe906 	br	d003048 <strerror+0x258>
 d0030a4:	00834174 	movhi	r2,3333
 d0030a8:	10b6e604 	addi	r2,r2,-9320
 d0030ac:	003fe606 	br	d003048 <strerror+0x258>
 d0030b0:	00834174 	movhi	r2,3333
 d0030b4:	10b6e904 	addi	r2,r2,-9308
 d0030b8:	003fe306 	br	d003048 <strerror+0x258>
 d0030bc:	00834174 	movhi	r2,3333
 d0030c0:	10b6f004 	addi	r2,r2,-9280
 d0030c4:	003fe006 	br	d003048 <strerror+0x258>
 d0030c8:	00834174 	movhi	r2,3333
 d0030cc:	10b6f504 	addi	r2,r2,-9260
 d0030d0:	003fdd06 	br	d003048 <strerror+0x258>
 d0030d4:	00834174 	movhi	r2,3333
 d0030d8:	10b70104 	addi	r2,r2,-9212
 d0030dc:	003fda06 	br	d003048 <strerror+0x258>
 d0030e0:	00834174 	movhi	r2,3333
 d0030e4:	10b70504 	addi	r2,r2,-9196
 d0030e8:	003fd706 	br	d003048 <strerror+0x258>
 d0030ec:	00834174 	movhi	r2,3333
 d0030f0:	10b71004 	addi	r2,r2,-9152
 d0030f4:	003fd406 	br	d003048 <strerror+0x258>
 d0030f8:	00834174 	movhi	r2,3333
 d0030fc:	10b71504 	addi	r2,r2,-9132
 d003100:	003fd106 	br	d003048 <strerror+0x258>
 d003104:	00834174 	movhi	r2,3333
 d003108:	10b71a04 	addi	r2,r2,-9112
 d00310c:	003fce06 	br	d003048 <strerror+0x258>
 d003110:	00834174 	movhi	r2,3333
 d003114:	10b71f04 	addi	r2,r2,-9092
 d003118:	003fcb06 	br	d003048 <strerror+0x258>
 d00311c:	00834174 	movhi	r2,3333
 d003120:	10b72204 	addi	r2,r2,-9080
 d003124:	003fc806 	br	d003048 <strerror+0x258>
 d003128:	00834174 	movhi	r2,3333
 d00312c:	10b72804 	addi	r2,r2,-9056
 d003130:	003fc506 	br	d003048 <strerror+0x258>
 d003134:	00834174 	movhi	r2,3333
 d003138:	10b72e04 	addi	r2,r2,-9032
 d00313c:	003fc206 	br	d003048 <strerror+0x258>
 d003140:	00834174 	movhi	r2,3333
 d003144:	10b73104 	addi	r2,r2,-9020
 d003148:	003fbf06 	br	d003048 <strerror+0x258>
 d00314c:	00834174 	movhi	r2,3333
 d003150:	10b73604 	addi	r2,r2,-9000
 d003154:	003fbc06 	br	d003048 <strerror+0x258>
 d003158:	00834174 	movhi	r2,3333
 d00315c:	10b73a04 	addi	r2,r2,-8984
 d003160:	003fb906 	br	d003048 <strerror+0x258>
 d003164:	00834174 	movhi	r2,3333
 d003168:	10b74a04 	addi	r2,r2,-8920
 d00316c:	003fb606 	br	d003048 <strerror+0x258>
 d003170:	00834174 	movhi	r2,3333
 d003174:	10b74e04 	addi	r2,r2,-8904
 d003178:	003fb306 	br	d003048 <strerror+0x258>
 d00317c:	00834174 	movhi	r2,3333
 d003180:	10b75c04 	addi	r2,r2,-8848
 d003184:	003fb006 	br	d003048 <strerror+0x258>
 d003188:	00834174 	movhi	r2,3333
 d00318c:	10b76404 	addi	r2,r2,-8816
 d003190:	003fad06 	br	d003048 <strerror+0x258>
 d003194:	00834174 	movhi	r2,3333
 d003198:	10b76904 	addi	r2,r2,-8796
 d00319c:	003faa06 	br	d003048 <strerror+0x258>
 d0031a0:	00834174 	movhi	r2,3333
 d0031a4:	10b76f04 	addi	r2,r2,-8772
 d0031a8:	003fa706 	br	d003048 <strerror+0x258>
 d0031ac:	00834174 	movhi	r2,3333
 d0031b0:	10b77304 	addi	r2,r2,-8756
 d0031b4:	003fa406 	br	d003048 <strerror+0x258>
 d0031b8:	00834174 	movhi	r2,3333
 d0031bc:	10b77c04 	addi	r2,r2,-8720
 d0031c0:	003fa106 	br	d003048 <strerror+0x258>
 d0031c4:	00834174 	movhi	r2,3333
 d0031c8:	10b78604 	addi	r2,r2,-8680
 d0031cc:	003f9e06 	br	d003048 <strerror+0x258>
 d0031d0:	00834174 	movhi	r2,3333
 d0031d4:	10b78a04 	addi	r2,r2,-8664
 d0031d8:	003f9b06 	br	d003048 <strerror+0x258>
 d0031dc:	00834174 	movhi	r2,3333
 d0031e0:	10b79004 	addi	r2,r2,-8640
 d0031e4:	003f9806 	br	d003048 <strerror+0x258>
 d0031e8:	00834174 	movhi	r2,3333
 d0031ec:	10b79404 	addi	r2,r2,-8624
 d0031f0:	003f9506 	br	d003048 <strerror+0x258>
 d0031f4:	00834174 	movhi	r2,3333
 d0031f8:	10b79704 	addi	r2,r2,-8612
 d0031fc:	003f9206 	br	d003048 <strerror+0x258>
 d003200:	00834174 	movhi	r2,3333
 d003204:	10b79b04 	addi	r2,r2,-8596
 d003208:	003f8f06 	br	d003048 <strerror+0x258>
 d00320c:	00834174 	movhi	r2,3333
 d003210:	10b7a004 	addi	r2,r2,-8576
 d003214:	003f8c06 	br	d003048 <strerror+0x258>
 d003218:	00834174 	movhi	r2,3333
 d00321c:	10b7a704 	addi	r2,r2,-8548
 d003220:	003f8906 	br	d003048 <strerror+0x258>
 d003224:	00834174 	movhi	r2,3333
 d003228:	10b7ac04 	addi	r2,r2,-8528
 d00322c:	003f8606 	br	d003048 <strerror+0x258>
 d003230:	00834174 	movhi	r2,3333
 d003234:	10b7b504 	addi	r2,r2,-8492
 d003238:	003f8306 	br	d003048 <strerror+0x258>
 d00323c:	00834174 	movhi	r2,3333
 d003240:	10b7b704 	addi	r2,r2,-8484
 d003244:	003f8006 	br	d003048 <strerror+0x258>
 d003248:	00834174 	movhi	r2,3333
 d00324c:	10b7bb04 	addi	r2,r2,-8468
 d003250:	003f7d06 	br	d003048 <strerror+0x258>
 d003254:	00834174 	movhi	r2,3333
 d003258:	10b7c104 	addi	r2,r2,-8444
 d00325c:	003f7a06 	br	d003048 <strerror+0x258>
 d003260:	00834174 	movhi	r2,3333
 d003264:	10b7c604 	addi	r2,r2,-8424
 d003268:	003f7706 	br	d003048 <strerror+0x258>
 d00326c:	00834174 	movhi	r2,3333
 d003270:	10b7ce04 	addi	r2,r2,-8392
 d003274:	003f7406 	br	d003048 <strerror+0x258>
 d003278:	00834174 	movhi	r2,3333
 d00327c:	10b7d104 	addi	r2,r2,-8380
 d003280:	003f7106 	br	d003048 <strerror+0x258>
 d003284:	00834174 	movhi	r2,3333
 d003288:	10b7d604 	addi	r2,r2,-8360
 d00328c:	003f6e06 	br	d003048 <strerror+0x258>
 d003290:	00834174 	movhi	r2,3333
 d003294:	10b7dc04 	addi	r2,r2,-8336
 d003298:	003f6b06 	br	d003048 <strerror+0x258>
 d00329c:	00834174 	movhi	r2,3333
 d0032a0:	10b7e004 	addi	r2,r2,-8320
 d0032a4:	003f6806 	br	d003048 <strerror+0x258>
 d0032a8:	00834174 	movhi	r2,3333
 d0032ac:	10b7e404 	addi	r2,r2,-8304
 d0032b0:	003f6506 	br	d003048 <strerror+0x258>
 d0032b4:	00834174 	movhi	r2,3333
 d0032b8:	10b7e904 	addi	r2,r2,-8284
 d0032bc:	003f6206 	br	d003048 <strerror+0x258>
 d0032c0:	00834174 	movhi	r2,3333
 d0032c4:	10b7f204 	addi	r2,r2,-8248
 d0032c8:	003f5f06 	br	d003048 <strerror+0x258>
 d0032cc:	00834174 	movhi	r2,3333
 d0032d0:	10b7f704 	addi	r2,r2,-8228
 d0032d4:	003f5c06 	br	d003048 <strerror+0x258>
 d0032d8:	00834174 	movhi	r2,3333
 d0032dc:	10b7fa04 	addi	r2,r2,-8216
 d0032e0:	003f5906 	br	d003048 <strerror+0x258>
 d0032e4:	00834174 	movhi	r2,3333
 d0032e8:	10b80404 	addi	r2,r2,-8176
 d0032ec:	003f5606 	br	d003048 <strerror+0x258>
 d0032f0:	00834174 	movhi	r2,3333
 d0032f4:	10b80e04 	addi	r2,r2,-8136
 d0032f8:	003f5306 	br	d003048 <strerror+0x258>
 d0032fc:	00834174 	movhi	r2,3333
 d003300:	10b81604 	addi	r2,r2,-8104
 d003304:	003f5006 	br	d003048 <strerror+0x258>
 d003308:	00834174 	movhi	r2,3333
 d00330c:	10b82604 	addi	r2,r2,-8040
 d003310:	003f4d06 	br	d003048 <strerror+0x258>
 d003314:	00834174 	movhi	r2,3333
 d003318:	10b83004 	addi	r2,r2,-8000
 d00331c:	003f4a06 	br	d003048 <strerror+0x258>
 d003320:	00834174 	movhi	r2,3333
 d003324:	10b83704 	addi	r2,r2,-7972
 d003328:	003f4706 	br	d003048 <strerror+0x258>
 d00332c:	00834174 	movhi	r2,3333
 d003330:	10b83b04 	addi	r2,r2,-7956
 d003334:	003f4406 	br	d003048 <strerror+0x258>
 d003338:	00834174 	movhi	r2,3333
 d00333c:	10b84004 	addi	r2,r2,-7936
 d003340:	003f4106 	br	d003048 <strerror+0x258>
 d003344:	00834174 	movhi	r2,3333
 d003348:	10b84704 	addi	r2,r2,-7908
 d00334c:	003f3e06 	br	d003048 <strerror+0x258>
 d003350:	00834174 	movhi	r2,3333
 d003354:	10b8a704 	addi	r2,r2,-7524
 d003358:	003f3b06 	br	d003048 <strerror+0x258>
 d00335c:	00834174 	movhi	r2,3333
 d003360:	10b84d04 	addi	r2,r2,-7884
 d003364:	003f3806 	br	d003048 <strerror+0x258>
 d003368:	00834174 	movhi	r2,3333
 d00336c:	10b85404 	addi	r2,r2,-7856
 d003370:	003f3506 	br	d003048 <strerror+0x258>
 d003374:	00834174 	movhi	r2,3333
 d003378:	10b86004 	addi	r2,r2,-7808
 d00337c:	003f3206 	br	d003048 <strerror+0x258>
 d003380:	00834174 	movhi	r2,3333
 d003384:	10b86804 	addi	r2,r2,-7776
 d003388:	003f2f06 	br	d003048 <strerror+0x258>
 d00338c:	00834174 	movhi	r2,3333
 d003390:	10b87004 	addi	r2,r2,-7744
 d003394:	003f2c06 	br	d003048 <strerror+0x258>
 d003398:	00834174 	movhi	r2,3333
 d00339c:	10b87604 	addi	r2,r2,-7720
 d0033a0:	003f2906 	br	d003048 <strerror+0x258>
 d0033a4:	00834174 	movhi	r2,3333
 d0033a8:	10b87f04 	addi	r2,r2,-7684
 d0033ac:	003f2606 	br	d003048 <strerror+0x258>
 d0033b0:	00834174 	movhi	r2,3333
 d0033b4:	10b88404 	addi	r2,r2,-7664
 d0033b8:	003f2306 	br	d003048 <strerror+0x258>
 d0033bc:	00834174 	movhi	r2,3333
 d0033c0:	10b88a04 	addi	r2,r2,-7640
 d0033c4:	003f2006 	br	d003048 <strerror+0x258>
 d0033c8:	00834174 	movhi	r2,3333
 d0033cc:	10b7af04 	addi	r2,r2,-8516
 d0033d0:	003f1d06 	br	d003048 <strerror+0x258>
 d0033d4:	00834174 	movhi	r2,3333
 d0033d8:	10b75304 	addi	r2,r2,-8884
 d0033dc:	003f1a06 	br	d003048 <strerror+0x258>
 d0033e0:	00834174 	movhi	r2,3333
 d0033e4:	10b6cc04 	addi	r2,r2,-9424
 d0033e8:	003f1706 	br	d003048 <strerror+0x258>
 d0033ec:	00834174 	movhi	r2,3333
 d0033f0:	10b73e04 	addi	r2,r2,-8968
 d0033f4:	003f1406 	br	d003048 <strerror+0x258>
 d0033f8:	00834174 	movhi	r2,3333
 d0033fc:	10b77704 	addi	r2,r2,-8740
 d003400:	003f1106 	br	d003048 <strerror+0x258>
 d003404:	00834174 	movhi	r2,3333
 d003408:	10b74204 	addi	r2,r2,-8952
 d00340c:	003f0e06 	br	d003048 <strerror+0x258>
 d003410:	00834174 	movhi	r2,3333
 d003414:	10b6fa04 	addi	r2,r2,-9240
 d003418:	003f0b06 	br	d003048 <strerror+0x258>
 d00341c:	00834174 	movhi	r2,3333
 d003420:	10b70804 	addi	r2,r2,-9184
 d003424:	003f0806 	br	d003048 <strerror+0x258>
 d003428:	00834174 	movhi	r2,3333
 d00342c:	10b6c704 	addi	r2,r2,-9444
 d003430:	003f0506 	br	d003048 <strerror+0x258>
 d003434:	00834174 	movhi	r2,3333
 d003438:	10b7ed04 	addi	r2,r2,-8268
 d00343c:	003f0206 	br	d003048 <strerror+0x258>
 d003440:	00834174 	movhi	r2,3333
 d003444:	10b89904 	addi	r2,r2,-7580
 d003448:	003eff06 	br	d003048 <strerror+0x258>
 d00344c:	00834174 	movhi	r2,3333
 d003450:	10b8a004 	addi	r2,r2,-7552
 d003454:	003efc06 	br	d003048 <strerror+0x258>
 d003458:	00834174 	movhi	r2,3333
 d00345c:	10b89304 	addi	r2,r2,-7604
 d003460:	003ef906 	br	d003048 <strerror+0x258>

0d003464 <strlen>:
 d003464:	208000cc 	andi	r2,r4,3
 d003468:	2011883a 	mov	r8,r4
 d00346c:	1000161e 	bne	r2,zero,d0034c8 <strlen+0x64>
 d003470:	20c00017 	ldw	r3,0(r4)
 d003474:	017fbff4 	movhi	r5,65279
 d003478:	297fbfc4 	addi	r5,r5,-257
 d00347c:	01e02074 	movhi	r7,32897
 d003480:	39e02004 	addi	r7,r7,-32640
 d003484:	1945883a 	add	r2,r3,r5
 d003488:	11c4703a 	and	r2,r2,r7
 d00348c:	00c6303a 	nor	r3,zero,r3
 d003490:	1886703a 	and	r3,r3,r2
 d003494:	18000c1e 	bne	r3,zero,d0034c8 <strlen+0x64>
 d003498:	280d883a 	mov	r6,r5
 d00349c:	380b883a 	mov	r5,r7
 d0034a0:	21000104 	addi	r4,r4,4
 d0034a4:	20800017 	ldw	r2,0(r4)
 d0034a8:	1187883a 	add	r3,r2,r6
 d0034ac:	1946703a 	and	r3,r3,r5
 d0034b0:	0084303a 	nor	r2,zero,r2
 d0034b4:	10c4703a 	and	r2,r2,r3
 d0034b8:	103ff926 	beq	r2,zero,d0034a0 <strlen+0x3c>
 d0034bc:	20800007 	ldb	r2,0(r4)
 d0034c0:	10000326 	beq	r2,zero,d0034d0 <strlen+0x6c>
 d0034c4:	21000044 	addi	r4,r4,1
 d0034c8:	20800007 	ldb	r2,0(r4)
 d0034cc:	103ffd1e 	bne	r2,zero,d0034c4 <strlen+0x60>
 d0034d0:	2205c83a 	sub	r2,r4,r8
 d0034d4:	f800283a 	ret

0d0034d8 <_user_strerror>:
 d0034d8:	0005883a 	mov	r2,zero
 d0034dc:	f800283a 	ret

0d0034e0 <__sprint_r>:
 d0034e0:	30800217 	ldw	r2,8(r6)
 d0034e4:	defffe04 	addi	sp,sp,-8
 d0034e8:	dc000015 	stw	r16,0(sp)
 d0034ec:	dfc00115 	stw	ra,4(sp)
 d0034f0:	3021883a 	mov	r16,r6
 d0034f4:	0007883a 	mov	r3,zero
 d0034f8:	1000061e 	bne	r2,zero,d003514 <__sprint_r+0x34>
 d0034fc:	1805883a 	mov	r2,r3
 d003500:	30000115 	stw	zero,4(r6)
 d003504:	dfc00117 	ldw	ra,4(sp)
 d003508:	dc000017 	ldw	r16,0(sp)
 d00350c:	dec00204 	addi	sp,sp,8
 d003510:	f800283a 	ret
 d003514:	d0079500 	call	d007950 <__sfvwrite_r>
 d003518:	1007883a 	mov	r3,r2
 d00351c:	1805883a 	mov	r2,r3
 d003520:	80000115 	stw	zero,4(r16)
 d003524:	80000215 	stw	zero,8(r16)
 d003528:	dfc00117 	ldw	ra,4(sp)
 d00352c:	dc000017 	ldw	r16,0(sp)
 d003530:	dec00204 	addi	sp,sp,8
 d003534:	f800283a 	ret

0d003538 <___vfprintf_internal_r>:
 d003538:	defea404 	addi	sp,sp,-1392
 d00353c:	dd815815 	stw	r22,1376(sp)
 d003540:	dc015215 	stw	r16,1352(sp)
 d003544:	d9c15115 	stw	r7,1348(sp)
 d003548:	dfc15b15 	stw	ra,1388(sp)
 d00354c:	df015a15 	stw	fp,1384(sp)
 d003550:	ddc15915 	stw	r23,1380(sp)
 d003554:	dd415715 	stw	r21,1372(sp)
 d003558:	dd015615 	stw	r20,1368(sp)
 d00355c:	dcc15515 	stw	r19,1364(sp)
 d003560:	dc815415 	stw	r18,1360(sp)
 d003564:	dc415315 	stw	r17,1356(sp)
 d003568:	282d883a 	mov	r22,r5
 d00356c:	3021883a 	mov	r16,r6
 d003570:	d9014f15 	stw	r4,1340(sp)
 d003574:	d007f740 	call	d007f74 <_localeconv_r>
 d003578:	10800017 	ldw	r2,0(r2)
 d00357c:	d9c15117 	ldw	r7,1348(sp)
 d003580:	d8814915 	stw	r2,1316(sp)
 d003584:	d8814f17 	ldw	r2,1340(sp)
 d003588:	10000226 	beq	r2,zero,d003594 <___vfprintf_internal_r+0x5c>
 d00358c:	10800e17 	ldw	r2,56(r2)
 d003590:	10020d26 	beq	r2,zero,d003dc8 <___vfprintf_internal_r+0x890>
 d003594:	b080030b 	ldhu	r2,12(r22)
 d003598:	1080020c 	andi	r2,r2,8
 d00359c:	10020e26 	beq	r2,zero,d003dd8 <___vfprintf_internal_r+0x8a0>
 d0035a0:	b0800417 	ldw	r2,16(r22)
 d0035a4:	10020c26 	beq	r2,zero,d003dd8 <___vfprintf_internal_r+0x8a0>
 d0035a8:	b200030b 	ldhu	r8,12(r22)
 d0035ac:	00800284 	movi	r2,10
 d0035b0:	40c0068c 	andi	r3,r8,26
 d0035b4:	18802f1e 	bne	r3,r2,d003674 <___vfprintf_internal_r+0x13c>
 d0035b8:	b080038f 	ldh	r2,14(r22)
 d0035bc:	10002d16 	blt	r2,zero,d003674 <___vfprintf_internal_r+0x13c>
 d0035c0:	b240038b 	ldhu	r9,14(r22)
 d0035c4:	b2800717 	ldw	r10,28(r22)
 d0035c8:	b2c00917 	ldw	r11,36(r22)
 d0035cc:	d9014f17 	ldw	r4,1340(sp)
 d0035d0:	dc402904 	addi	r17,sp,164
 d0035d4:	d8804004 	addi	r2,sp,256
 d0035d8:	00c10004 	movi	r3,1024
 d0035dc:	423fff4c 	andi	r8,r8,65533
 d0035e0:	800d883a 	mov	r6,r16
 d0035e4:	880b883a 	mov	r5,r17
 d0035e8:	da002c0d 	sth	r8,176(sp)
 d0035ec:	da402c8d 	sth	r9,178(sp)
 d0035f0:	da803015 	stw	r10,192(sp)
 d0035f4:	dac03215 	stw	r11,200(sp)
 d0035f8:	d8802d15 	stw	r2,180(sp)
 d0035fc:	d8c02e15 	stw	r3,184(sp)
 d003600:	d8802915 	stw	r2,164(sp)
 d003604:	d8c02b15 	stw	r3,172(sp)
 d003608:	d8002f15 	stw	zero,188(sp)
 d00360c:	d0035380 	call	d003538 <___vfprintf_internal_r>
 d003610:	d8814b15 	stw	r2,1324(sp)
 d003614:	10000416 	blt	r2,zero,d003628 <___vfprintf_internal_r+0xf0>
 d003618:	d9014f17 	ldw	r4,1340(sp)
 d00361c:	880b883a 	mov	r5,r17
 d003620:	d006ea00 	call	d006ea0 <_fflush_r>
 d003624:	1002321e 	bne	r2,zero,d003ef0 <___vfprintf_internal_r+0x9b8>
 d003628:	d8802c0b 	ldhu	r2,176(sp)
 d00362c:	1080100c 	andi	r2,r2,64
 d003630:	10000326 	beq	r2,zero,d003640 <___vfprintf_internal_r+0x108>
 d003634:	b080030b 	ldhu	r2,12(r22)
 d003638:	10801014 	ori	r2,r2,64
 d00363c:	b080030d 	sth	r2,12(r22)
 d003640:	d8814b17 	ldw	r2,1324(sp)
 d003644:	dfc15b17 	ldw	ra,1388(sp)
 d003648:	df015a17 	ldw	fp,1384(sp)
 d00364c:	ddc15917 	ldw	r23,1380(sp)
 d003650:	dd815817 	ldw	r22,1376(sp)
 d003654:	dd415717 	ldw	r21,1372(sp)
 d003658:	dd015617 	ldw	r20,1368(sp)
 d00365c:	dcc15517 	ldw	r19,1364(sp)
 d003660:	dc815417 	ldw	r18,1360(sp)
 d003664:	dc415317 	ldw	r17,1356(sp)
 d003668:	dc015217 	ldw	r16,1352(sp)
 d00366c:	dec15c04 	addi	sp,sp,1392
 d003670:	f800283a 	ret
 d003674:	0005883a 	mov	r2,zero
 d003678:	0007883a 	mov	r3,zero
 d00367c:	dd401904 	addi	r21,sp,100
 d003680:	d8814215 	stw	r2,1288(sp)
 d003684:	802f883a 	mov	r23,r16
 d003688:	d8c14315 	stw	r3,1292(sp)
 d00368c:	d8014b15 	stw	zero,1324(sp)
 d003690:	d8014815 	stw	zero,1312(sp)
 d003694:	d8014415 	stw	zero,1296(sp)
 d003698:	d8014715 	stw	zero,1308(sp)
 d00369c:	dd400c15 	stw	r21,48(sp)
 d0036a0:	d8000e15 	stw	zero,56(sp)
 d0036a4:	d8000d15 	stw	zero,52(sp)
 d0036a8:	b8800007 	ldb	r2,0(r23)
 d0036ac:	10001926 	beq	r2,zero,d003714 <___vfprintf_internal_r+0x1dc>
 d0036b0:	00c00944 	movi	r3,37
 d0036b4:	10c01726 	beq	r2,r3,d003714 <___vfprintf_internal_r+0x1dc>
 d0036b8:	b821883a 	mov	r16,r23
 d0036bc:	00000106 	br	d0036c4 <___vfprintf_internal_r+0x18c>
 d0036c0:	10c00326 	beq	r2,r3,d0036d0 <___vfprintf_internal_r+0x198>
 d0036c4:	84000044 	addi	r16,r16,1
 d0036c8:	80800007 	ldb	r2,0(r16)
 d0036cc:	103ffc1e 	bne	r2,zero,d0036c0 <___vfprintf_internal_r+0x188>
 d0036d0:	85e7c83a 	sub	r19,r16,r23
 d0036d4:	98000e26 	beq	r19,zero,d003710 <___vfprintf_internal_r+0x1d8>
 d0036d8:	dc800e17 	ldw	r18,56(sp)
 d0036dc:	dc400d17 	ldw	r17,52(sp)
 d0036e0:	008001c4 	movi	r2,7
 d0036e4:	94e5883a 	add	r18,r18,r19
 d0036e8:	8c400044 	addi	r17,r17,1
 d0036ec:	adc00015 	stw	r23,0(r21)
 d0036f0:	dc800e15 	stw	r18,56(sp)
 d0036f4:	acc00115 	stw	r19,4(r21)
 d0036f8:	dc400d15 	stw	r17,52(sp)
 d0036fc:	14428b16 	blt	r2,r17,d00412c <___vfprintf_internal_r+0xbf4>
 d003700:	ad400204 	addi	r21,r21,8
 d003704:	d9014b17 	ldw	r4,1324(sp)
 d003708:	24c9883a 	add	r4,r4,r19
 d00370c:	d9014b15 	stw	r4,1324(sp)
 d003710:	802f883a 	mov	r23,r16
 d003714:	b8800007 	ldb	r2,0(r23)
 d003718:	10013c26 	beq	r2,zero,d003c0c <___vfprintf_internal_r+0x6d4>
 d00371c:	bdc00044 	addi	r23,r23,1
 d003720:	d8000405 	stb	zero,16(sp)
 d003724:	b8c00007 	ldb	r3,0(r23)
 d003728:	04ffffc4 	movi	r19,-1
 d00372c:	d8014c15 	stw	zero,1328(sp)
 d003730:	d8014a15 	stw	zero,1320(sp)
 d003734:	d8c14d15 	stw	r3,1332(sp)
 d003738:	bdc00044 	addi	r23,r23,1
 d00373c:	d9414d17 	ldw	r5,1332(sp)
 d003740:	00801604 	movi	r2,88
 d003744:	28fff804 	addi	r3,r5,-32
 d003748:	10c06036 	bltu	r2,r3,d0038cc <___vfprintf_internal_r+0x394>
 d00374c:	18c5883a 	add	r2,r3,r3
 d003750:	1085883a 	add	r2,r2,r2
 d003754:	00c34034 	movhi	r3,3328
 d003758:	18cdda04 	addi	r3,r3,14184
 d00375c:	10c5883a 	add	r2,r2,r3
 d003760:	11000017 	ldw	r4,0(r2)
 d003764:	2000683a 	jmp	r4
 d003768:	0d0046dc 	xori	r20,at,283
 d00376c:	0d0038cc 	andi	r20,at,227
 d003770:	0d0038cc 	andi	r20,at,227
 d003774:	0d0046c8 	cmpgei	r20,at,283
 d003778:	0d0038cc 	andi	r20,at,227
 d00377c:	0d0038cc 	andi	r20,at,227
 d003780:	0d0038cc 	andi	r20,at,227
 d003784:	0d0038cc 	andi	r20,at,227
 d003788:	0d0038cc 	andi	r20,at,227
 d00378c:	0d0038cc 	andi	r20,at,227
 d003790:	0d0044a8 	cmpgeui	r20,at,274
 d003794:	0d0046b8 	rdprs	r20,at,282
 d003798:	0d0038cc 	andi	r20,at,227
 d00379c:	0d0044c0 	call	d0044c <__ram_exceptions_end+0xc80250>
 d0037a0:	0d004760 	cmpeqi	r20,at,285
 d0037a4:	0d0038cc 	andi	r20,at,227
 d0037a8:	0d00474c 	andi	r20,at,285
 d0037ac:	0d004708 	cmpgei	r20,at,284
 d0037b0:	0d004708 	cmpgei	r20,at,284
 d0037b4:	0d004708 	cmpgei	r20,at,284
 d0037b8:	0d004708 	cmpgei	r20,at,284
 d0037bc:	0d004708 	cmpgei	r20,at,284
 d0037c0:	0d004708 	cmpgei	r20,at,284
 d0037c4:	0d004708 	cmpgei	r20,at,284
 d0037c8:	0d004708 	cmpgei	r20,at,284
 d0037cc:	0d004708 	cmpgei	r20,at,284
 d0037d0:	0d0038cc 	andi	r20,at,227
 d0037d4:	0d0038cc 	andi	r20,at,227
 d0037d8:	0d0038cc 	andi	r20,at,227
 d0037dc:	0d0038cc 	andi	r20,at,227
 d0037e0:	0d0038cc 	andi	r20,at,227
 d0037e4:	0d0038cc 	andi	r20,at,227
 d0037e8:	0d0038cc 	andi	r20,at,227
 d0037ec:	0d0038cc 	andi	r20,at,227
 d0037f0:	0d0038cc 	andi	r20,at,227
 d0037f4:	0d0038cc 	andi	r20,at,227
 d0037f8:	0d003f24 	muli	r20,at,252
 d0037fc:	0d004590 	cmplti	r20,at,278
 d003800:	0d0038cc 	andi	r20,at,227
 d003804:	0d004590 	cmplti	r20,at,278
 d003808:	0d0038cc 	andi	r20,at,227
 d00380c:	0d0038cc 	andi	r20,at,227
 d003810:	0d0038cc 	andi	r20,at,227
 d003814:	0d0038cc 	andi	r20,at,227
 d003818:	0d0046f4 	orhi	r20,at,283
 d00381c:	0d0038cc 	andi	r20,at,227
 d003820:	0d0038cc 	andi	r20,at,227
 d003824:	0d003fd8 	cmpnei	r20,at,255
 d003828:	0d0038cc 	andi	r20,at,227
 d00382c:	0d0038cc 	andi	r20,at,227
 d003830:	0d0038cc 	andi	r20,at,227
 d003834:	0d0038cc 	andi	r20,at,227
 d003838:	0d0038cc 	andi	r20,at,227
 d00383c:	0d004024 	muli	r20,at,256
 d003840:	0d0038cc 	andi	r20,at,227
 d003844:	0d0038cc 	andi	r20,at,227
 d003848:	0d004644 	addi	r20,at,281
 d00384c:	0d0038cc 	andi	r20,at,227
 d003850:	0d0038cc 	andi	r20,at,227
 d003854:	0d0038cc 	andi	r20,at,227
 d003858:	0d0038cc 	andi	r20,at,227
 d00385c:	0d0038cc 	andi	r20,at,227
 d003860:	0d0038cc 	andi	r20,at,227
 d003864:	0d0038cc 	andi	r20,at,227
 d003868:	0d0038cc 	andi	r20,at,227
 d00386c:	0d0038cc 	andi	r20,at,227
 d003870:	0d0038cc 	andi	r20,at,227
 d003874:	0d004618 	cmpnei	r20,at,280
 d003878:	0d003f30 	cmpltui	r20,at,252
 d00387c:	0d004590 	cmplti	r20,at,278
 d003880:	0d004590 	cmplti	r20,at,278
 d003884:	0d004590 	cmplti	r20,at,278
 d003888:	0d00457c 	xorhi	r20,at,277
 d00388c:	0d003f30 	cmpltui	r20,at,252
 d003890:	0d0038cc 	andi	r20,at,227
 d003894:	0d0038cc 	andi	r20,at,227
 d003898:	0d004504 	addi	r20,at,276
 d00389c:	0d0038cc 	andi	r20,at,227
 d0038a0:	0d0044d4 	ori	r20,at,275
 d0038a4:	0d003fe4 	muli	r20,at,255
 d0038a8:	0d004534 	orhi	r20,at,276
 d0038ac:	0d004520 	cmpeqi	r20,at,276
 d0038b0:	0d0038cc 	andi	r20,at,227
 d0038b4:	0d0047c8 	cmpgei	r20,at,287
 d0038b8:	0d0038cc 	andi	r20,at,227
 d0038bc:	0d004030 	cmpltui	r20,at,256
 d0038c0:	0d0038cc 	andi	r20,at,227
 d0038c4:	0d0038cc 	andi	r20,at,227
 d0038c8:	0d0046a8 	cmpgeui	r20,at,282
 d0038cc:	d9014d17 	ldw	r4,1332(sp)
 d0038d0:	2000ce26 	beq	r4,zero,d003c0c <___vfprintf_internal_r+0x6d4>
 d0038d4:	01400044 	movi	r5,1
 d0038d8:	d9800f04 	addi	r6,sp,60
 d0038dc:	d9c14015 	stw	r7,1280(sp)
 d0038e0:	d9414515 	stw	r5,1300(sp)
 d0038e4:	d9814115 	stw	r6,1284(sp)
 d0038e8:	280f883a 	mov	r7,r5
 d0038ec:	d9000f05 	stb	r4,60(sp)
 d0038f0:	d8000405 	stb	zero,16(sp)
 d0038f4:	d8014615 	stw	zero,1304(sp)
 d0038f8:	d8c14c17 	ldw	r3,1328(sp)
 d0038fc:	1880008c 	andi	r2,r3,2
 d003900:	1005003a 	cmpeq	r2,r2,zero
 d003904:	d8815015 	stw	r2,1344(sp)
 d003908:	1000031e 	bne	r2,zero,d003918 <___vfprintf_internal_r+0x3e0>
 d00390c:	d9014517 	ldw	r4,1300(sp)
 d003910:	21000084 	addi	r4,r4,2
 d003914:	d9014515 	stw	r4,1300(sp)
 d003918:	d9414c17 	ldw	r5,1328(sp)
 d00391c:	2940210c 	andi	r5,r5,132
 d003920:	d9414e15 	stw	r5,1336(sp)
 d003924:	28002d1e 	bne	r5,zero,d0039dc <___vfprintf_internal_r+0x4a4>
 d003928:	d9814a17 	ldw	r6,1320(sp)
 d00392c:	d8814517 	ldw	r2,1300(sp)
 d003930:	30a1c83a 	sub	r16,r6,r2
 d003934:	0400290e 	bge	zero,r16,d0039dc <___vfprintf_internal_r+0x4a4>
 d003938:	00800404 	movi	r2,16
 d00393c:	14045e0e 	bge	r2,r16,d004ab8 <___vfprintf_internal_r+0x1580>
 d003940:	dc800e17 	ldw	r18,56(sp)
 d003944:	dc400d17 	ldw	r17,52(sp)
 d003948:	1027883a 	mov	r19,r2
 d00394c:	07034174 	movhi	fp,3333
 d003950:	e738cb84 	addi	fp,fp,-7378
 d003954:	050001c4 	movi	r20,7
 d003958:	00000306 	br	d003968 <___vfprintf_internal_r+0x430>
 d00395c:	843ffc04 	addi	r16,r16,-16
 d003960:	ad400204 	addi	r21,r21,8
 d003964:	9c00130e 	bge	r19,r16,d0039b4 <___vfprintf_internal_r+0x47c>
 d003968:	94800404 	addi	r18,r18,16
 d00396c:	8c400044 	addi	r17,r17,1
 d003970:	af000015 	stw	fp,0(r21)
 d003974:	acc00115 	stw	r19,4(r21)
 d003978:	dc800e15 	stw	r18,56(sp)
 d00397c:	dc400d15 	stw	r17,52(sp)
 d003980:	a47ff60e 	bge	r20,r17,d00395c <___vfprintf_internal_r+0x424>
 d003984:	d9014f17 	ldw	r4,1340(sp)
 d003988:	b00b883a 	mov	r5,r22
 d00398c:	d9800c04 	addi	r6,sp,48
 d003990:	d9c15115 	stw	r7,1348(sp)
 d003994:	d0034e00 	call	d0034e0 <__sprint_r>
 d003998:	d9c15117 	ldw	r7,1348(sp)
 d00399c:	10009e1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d0039a0:	843ffc04 	addi	r16,r16,-16
 d0039a4:	dc800e17 	ldw	r18,56(sp)
 d0039a8:	dc400d17 	ldw	r17,52(sp)
 d0039ac:	dd401904 	addi	r21,sp,100
 d0039b0:	9c3fed16 	blt	r19,r16,d003968 <___vfprintf_internal_r+0x430>
 d0039b4:	9425883a 	add	r18,r18,r16
 d0039b8:	8c400044 	addi	r17,r17,1
 d0039bc:	008001c4 	movi	r2,7
 d0039c0:	af000015 	stw	fp,0(r21)
 d0039c4:	ac000115 	stw	r16,4(r21)
 d0039c8:	dc800e15 	stw	r18,56(sp)
 d0039cc:	dc400d15 	stw	r17,52(sp)
 d0039d0:	1441f516 	blt	r2,r17,d0041a8 <___vfprintf_internal_r+0xc70>
 d0039d4:	ad400204 	addi	r21,r21,8
 d0039d8:	00000206 	br	d0039e4 <___vfprintf_internal_r+0x4ac>
 d0039dc:	dc800e17 	ldw	r18,56(sp)
 d0039e0:	dc400d17 	ldw	r17,52(sp)
 d0039e4:	d8800407 	ldb	r2,16(sp)
 d0039e8:	10000b26 	beq	r2,zero,d003a18 <___vfprintf_internal_r+0x4e0>
 d0039ec:	00800044 	movi	r2,1
 d0039f0:	94800044 	addi	r18,r18,1
 d0039f4:	8c400044 	addi	r17,r17,1
 d0039f8:	a8800115 	stw	r2,4(r21)
 d0039fc:	d8c00404 	addi	r3,sp,16
 d003a00:	008001c4 	movi	r2,7
 d003a04:	a8c00015 	stw	r3,0(r21)
 d003a08:	dc800e15 	stw	r18,56(sp)
 d003a0c:	dc400d15 	stw	r17,52(sp)
 d003a10:	1441da16 	blt	r2,r17,d00417c <___vfprintf_internal_r+0xc44>
 d003a14:	ad400204 	addi	r21,r21,8
 d003a18:	d9015017 	ldw	r4,1344(sp)
 d003a1c:	20000b1e 	bne	r4,zero,d003a4c <___vfprintf_internal_r+0x514>
 d003a20:	d8800444 	addi	r2,sp,17
 d003a24:	94800084 	addi	r18,r18,2
 d003a28:	8c400044 	addi	r17,r17,1
 d003a2c:	a8800015 	stw	r2,0(r21)
 d003a30:	00c00084 	movi	r3,2
 d003a34:	008001c4 	movi	r2,7
 d003a38:	a8c00115 	stw	r3,4(r21)
 d003a3c:	dc800e15 	stw	r18,56(sp)
 d003a40:	dc400d15 	stw	r17,52(sp)
 d003a44:	1441c216 	blt	r2,r17,d004150 <___vfprintf_internal_r+0xc18>
 d003a48:	ad400204 	addi	r21,r21,8
 d003a4c:	d9414e17 	ldw	r5,1336(sp)
 d003a50:	00802004 	movi	r2,128
 d003a54:	2880b126 	beq	r5,r2,d003d1c <___vfprintf_internal_r+0x7e4>
 d003a58:	d8c14617 	ldw	r3,1304(sp)
 d003a5c:	19e1c83a 	sub	r16,r3,r7
 d003a60:	0400260e 	bge	zero,r16,d003afc <___vfprintf_internal_r+0x5c4>
 d003a64:	00800404 	movi	r2,16
 d003a68:	1403cf0e 	bge	r2,r16,d0049a8 <___vfprintf_internal_r+0x1470>
 d003a6c:	1027883a 	mov	r19,r2
 d003a70:	07034174 	movhi	fp,3333
 d003a74:	e738c784 	addi	fp,fp,-7394
 d003a78:	050001c4 	movi	r20,7
 d003a7c:	00000306 	br	d003a8c <___vfprintf_internal_r+0x554>
 d003a80:	843ffc04 	addi	r16,r16,-16
 d003a84:	ad400204 	addi	r21,r21,8
 d003a88:	9c00130e 	bge	r19,r16,d003ad8 <___vfprintf_internal_r+0x5a0>
 d003a8c:	94800404 	addi	r18,r18,16
 d003a90:	8c400044 	addi	r17,r17,1
 d003a94:	af000015 	stw	fp,0(r21)
 d003a98:	acc00115 	stw	r19,4(r21)
 d003a9c:	dc800e15 	stw	r18,56(sp)
 d003aa0:	dc400d15 	stw	r17,52(sp)
 d003aa4:	a47ff60e 	bge	r20,r17,d003a80 <___vfprintf_internal_r+0x548>
 d003aa8:	d9014f17 	ldw	r4,1340(sp)
 d003aac:	b00b883a 	mov	r5,r22
 d003ab0:	d9800c04 	addi	r6,sp,48
 d003ab4:	d9c15115 	stw	r7,1348(sp)
 d003ab8:	d0034e00 	call	d0034e0 <__sprint_r>
 d003abc:	d9c15117 	ldw	r7,1348(sp)
 d003ac0:	1000551e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d003ac4:	843ffc04 	addi	r16,r16,-16
 d003ac8:	dc800e17 	ldw	r18,56(sp)
 d003acc:	dc400d17 	ldw	r17,52(sp)
 d003ad0:	dd401904 	addi	r21,sp,100
 d003ad4:	9c3fed16 	blt	r19,r16,d003a8c <___vfprintf_internal_r+0x554>
 d003ad8:	9425883a 	add	r18,r18,r16
 d003adc:	8c400044 	addi	r17,r17,1
 d003ae0:	008001c4 	movi	r2,7
 d003ae4:	af000015 	stw	fp,0(r21)
 d003ae8:	ac000115 	stw	r16,4(r21)
 d003aec:	dc800e15 	stw	r18,56(sp)
 d003af0:	dc400d15 	stw	r17,52(sp)
 d003af4:	14418216 	blt	r2,r17,d004100 <___vfprintf_internal_r+0xbc8>
 d003af8:	ad400204 	addi	r21,r21,8
 d003afc:	d9014c17 	ldw	r4,1328(sp)
 d003b00:	2080400c 	andi	r2,r4,256
 d003b04:	10004a1e 	bne	r2,zero,d003c30 <___vfprintf_internal_r+0x6f8>
 d003b08:	d9414117 	ldw	r5,1284(sp)
 d003b0c:	91e5883a 	add	r18,r18,r7
 d003b10:	8c400044 	addi	r17,r17,1
 d003b14:	008001c4 	movi	r2,7
 d003b18:	a9400015 	stw	r5,0(r21)
 d003b1c:	a9c00115 	stw	r7,4(r21)
 d003b20:	dc800e15 	stw	r18,56(sp)
 d003b24:	dc400d15 	stw	r17,52(sp)
 d003b28:	14416716 	blt	r2,r17,d0040c8 <___vfprintf_internal_r+0xb90>
 d003b2c:	a8c00204 	addi	r3,r21,8
 d003b30:	d9814c17 	ldw	r6,1328(sp)
 d003b34:	3080010c 	andi	r2,r6,4
 d003b38:	10002826 	beq	r2,zero,d003bdc <___vfprintf_internal_r+0x6a4>
 d003b3c:	d8814a17 	ldw	r2,1320(sp)
 d003b40:	d9014517 	ldw	r4,1300(sp)
 d003b44:	1121c83a 	sub	r16,r2,r4
 d003b48:	0400240e 	bge	zero,r16,d003bdc <___vfprintf_internal_r+0x6a4>
 d003b4c:	00800404 	movi	r2,16
 d003b50:	1404550e 	bge	r2,r16,d004ca8 <___vfprintf_internal_r+0x1770>
 d003b54:	dc400d17 	ldw	r17,52(sp)
 d003b58:	1027883a 	mov	r19,r2
 d003b5c:	07034174 	movhi	fp,3333
 d003b60:	e738cb84 	addi	fp,fp,-7378
 d003b64:	050001c4 	movi	r20,7
 d003b68:	00000306 	br	d003b78 <___vfprintf_internal_r+0x640>
 d003b6c:	843ffc04 	addi	r16,r16,-16
 d003b70:	18c00204 	addi	r3,r3,8
 d003b74:	9c00110e 	bge	r19,r16,d003bbc <___vfprintf_internal_r+0x684>
 d003b78:	94800404 	addi	r18,r18,16
 d003b7c:	8c400044 	addi	r17,r17,1
 d003b80:	1f000015 	stw	fp,0(r3)
 d003b84:	1cc00115 	stw	r19,4(r3)
 d003b88:	dc800e15 	stw	r18,56(sp)
 d003b8c:	dc400d15 	stw	r17,52(sp)
 d003b90:	a47ff60e 	bge	r20,r17,d003b6c <___vfprintf_internal_r+0x634>
 d003b94:	d9014f17 	ldw	r4,1340(sp)
 d003b98:	b00b883a 	mov	r5,r22
 d003b9c:	d9800c04 	addi	r6,sp,48
 d003ba0:	d0034e00 	call	d0034e0 <__sprint_r>
 d003ba4:	10001c1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d003ba8:	843ffc04 	addi	r16,r16,-16
 d003bac:	dc800e17 	ldw	r18,56(sp)
 d003bb0:	dc400d17 	ldw	r17,52(sp)
 d003bb4:	d8c01904 	addi	r3,sp,100
 d003bb8:	9c3fef16 	blt	r19,r16,d003b78 <___vfprintf_internal_r+0x640>
 d003bbc:	9425883a 	add	r18,r18,r16
 d003bc0:	8c400044 	addi	r17,r17,1
 d003bc4:	008001c4 	movi	r2,7
 d003bc8:	1f000015 	stw	fp,0(r3)
 d003bcc:	1c000115 	stw	r16,4(r3)
 d003bd0:	dc800e15 	stw	r18,56(sp)
 d003bd4:	dc400d15 	stw	r17,52(sp)
 d003bd8:	1440cb16 	blt	r2,r17,d003f08 <___vfprintf_internal_r+0x9d0>
 d003bdc:	d8814a17 	ldw	r2,1320(sp)
 d003be0:	d9414517 	ldw	r5,1300(sp)
 d003be4:	1140010e 	bge	r2,r5,d003bec <___vfprintf_internal_r+0x6b4>
 d003be8:	2805883a 	mov	r2,r5
 d003bec:	d9814b17 	ldw	r6,1324(sp)
 d003bf0:	308d883a 	add	r6,r6,r2
 d003bf4:	d9814b15 	stw	r6,1324(sp)
 d003bf8:	90013b1e 	bne	r18,zero,d0040e8 <___vfprintf_internal_r+0xbb0>
 d003bfc:	d9c14017 	ldw	r7,1280(sp)
 d003c00:	dd401904 	addi	r21,sp,100
 d003c04:	d8000d15 	stw	zero,52(sp)
 d003c08:	003ea706 	br	d0036a8 <___vfprintf_internal_r+0x170>
 d003c0c:	d8800e17 	ldw	r2,56(sp)
 d003c10:	1005451e 	bne	r2,zero,d005128 <___vfprintf_internal_r+0x1bf0>
 d003c14:	d8000d15 	stw	zero,52(sp)
 d003c18:	b080030b 	ldhu	r2,12(r22)
 d003c1c:	1080100c 	andi	r2,r2,64
 d003c20:	103e8726 	beq	r2,zero,d003640 <___vfprintf_internal_r+0x108>
 d003c24:	00bfffc4 	movi	r2,-1
 d003c28:	d8814b15 	stw	r2,1324(sp)
 d003c2c:	003e8406 	br	d003640 <___vfprintf_internal_r+0x108>
 d003c30:	d9814d17 	ldw	r6,1332(sp)
 d003c34:	00801944 	movi	r2,101
 d003c38:	11806e16 	blt	r2,r6,d003df4 <___vfprintf_internal_r+0x8bc>
 d003c3c:	d9414717 	ldw	r5,1308(sp)
 d003c40:	00c00044 	movi	r3,1
 d003c44:	1943490e 	bge	r3,r5,d00496c <___vfprintf_internal_r+0x1434>
 d003c48:	d8814117 	ldw	r2,1284(sp)
 d003c4c:	94800044 	addi	r18,r18,1
 d003c50:	8c400044 	addi	r17,r17,1
 d003c54:	a8800015 	stw	r2,0(r21)
 d003c58:	008001c4 	movi	r2,7
 d003c5c:	a8c00115 	stw	r3,4(r21)
 d003c60:	dc800e15 	stw	r18,56(sp)
 d003c64:	dc400d15 	stw	r17,52(sp)
 d003c68:	1441ca16 	blt	r2,r17,d004394 <___vfprintf_internal_r+0xe5c>
 d003c6c:	a8c00204 	addi	r3,r21,8
 d003c70:	d9014917 	ldw	r4,1316(sp)
 d003c74:	00800044 	movi	r2,1
 d003c78:	94800044 	addi	r18,r18,1
 d003c7c:	8c400044 	addi	r17,r17,1
 d003c80:	18800115 	stw	r2,4(r3)
 d003c84:	008001c4 	movi	r2,7
 d003c88:	19000015 	stw	r4,0(r3)
 d003c8c:	dc800e15 	stw	r18,56(sp)
 d003c90:	dc400d15 	stw	r17,52(sp)
 d003c94:	1441b616 	blt	r2,r17,d004370 <___vfprintf_internal_r+0xe38>
 d003c98:	1cc00204 	addi	r19,r3,8
 d003c9c:	d9014217 	ldw	r4,1288(sp)
 d003ca0:	d9414317 	ldw	r5,1292(sp)
 d003ca4:	000d883a 	mov	r6,zero
 d003ca8:	000f883a 	mov	r7,zero
 d003cac:	d00c24c0 	call	d00c24c <__nedf2>
 d003cb0:	10017426 	beq	r2,zero,d004284 <___vfprintf_internal_r+0xd4c>
 d003cb4:	d9414717 	ldw	r5,1308(sp)
 d003cb8:	d9814117 	ldw	r6,1284(sp)
 d003cbc:	8c400044 	addi	r17,r17,1
 d003cc0:	2c85883a 	add	r2,r5,r18
 d003cc4:	14bfffc4 	addi	r18,r2,-1
 d003cc8:	28bfffc4 	addi	r2,r5,-1
 d003ccc:	30c00044 	addi	r3,r6,1
 d003cd0:	98800115 	stw	r2,4(r19)
 d003cd4:	008001c4 	movi	r2,7
 d003cd8:	98c00015 	stw	r3,0(r19)
 d003cdc:	dc800e15 	stw	r18,56(sp)
 d003ce0:	dc400d15 	stw	r17,52(sp)
 d003ce4:	14418e16 	blt	r2,r17,d004320 <___vfprintf_internal_r+0xde8>
 d003ce8:	9cc00204 	addi	r19,r19,8
 d003cec:	d9414817 	ldw	r5,1312(sp)
 d003cf0:	d8800804 	addi	r2,sp,32
 d003cf4:	8c400044 	addi	r17,r17,1
 d003cf8:	9165883a 	add	r18,r18,r5
 d003cfc:	98800015 	stw	r2,0(r19)
 d003d00:	008001c4 	movi	r2,7
 d003d04:	99400115 	stw	r5,4(r19)
 d003d08:	dc800e15 	stw	r18,56(sp)
 d003d0c:	dc400d15 	stw	r17,52(sp)
 d003d10:	1440ed16 	blt	r2,r17,d0040c8 <___vfprintf_internal_r+0xb90>
 d003d14:	98c00204 	addi	r3,r19,8
 d003d18:	003f8506 	br	d003b30 <___vfprintf_internal_r+0x5f8>
 d003d1c:	d9814a17 	ldw	r6,1320(sp)
 d003d20:	d8814517 	ldw	r2,1300(sp)
 d003d24:	30a1c83a 	sub	r16,r6,r2
 d003d28:	043f4b0e 	bge	zero,r16,d003a58 <___vfprintf_internal_r+0x520>
 d003d2c:	00800404 	movi	r2,16
 d003d30:	14043a0e 	bge	r2,r16,d004e1c <___vfprintf_internal_r+0x18e4>
 d003d34:	1027883a 	mov	r19,r2
 d003d38:	07034174 	movhi	fp,3333
 d003d3c:	e738c784 	addi	fp,fp,-7394
 d003d40:	050001c4 	movi	r20,7
 d003d44:	00000306 	br	d003d54 <___vfprintf_internal_r+0x81c>
 d003d48:	843ffc04 	addi	r16,r16,-16
 d003d4c:	ad400204 	addi	r21,r21,8
 d003d50:	9c00130e 	bge	r19,r16,d003da0 <___vfprintf_internal_r+0x868>
 d003d54:	94800404 	addi	r18,r18,16
 d003d58:	8c400044 	addi	r17,r17,1
 d003d5c:	af000015 	stw	fp,0(r21)
 d003d60:	acc00115 	stw	r19,4(r21)
 d003d64:	dc800e15 	stw	r18,56(sp)
 d003d68:	dc400d15 	stw	r17,52(sp)
 d003d6c:	a47ff60e 	bge	r20,r17,d003d48 <___vfprintf_internal_r+0x810>
 d003d70:	d9014f17 	ldw	r4,1340(sp)
 d003d74:	b00b883a 	mov	r5,r22
 d003d78:	d9800c04 	addi	r6,sp,48
 d003d7c:	d9c15115 	stw	r7,1348(sp)
 d003d80:	d0034e00 	call	d0034e0 <__sprint_r>
 d003d84:	d9c15117 	ldw	r7,1348(sp)
 d003d88:	103fa31e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d003d8c:	843ffc04 	addi	r16,r16,-16
 d003d90:	dc800e17 	ldw	r18,56(sp)
 d003d94:	dc400d17 	ldw	r17,52(sp)
 d003d98:	dd401904 	addi	r21,sp,100
 d003d9c:	9c3fed16 	blt	r19,r16,d003d54 <___vfprintf_internal_r+0x81c>
 d003da0:	9425883a 	add	r18,r18,r16
 d003da4:	8c400044 	addi	r17,r17,1
 d003da8:	008001c4 	movi	r2,7
 d003dac:	af000015 	stw	fp,0(r21)
 d003db0:	ac000115 	stw	r16,4(r21)
 d003db4:	dc800e15 	stw	r18,56(sp)
 d003db8:	dc400d15 	stw	r17,52(sp)
 d003dbc:	14416116 	blt	r2,r17,d004344 <___vfprintf_internal_r+0xe0c>
 d003dc0:	ad400204 	addi	r21,r21,8
 d003dc4:	003f2406 	br	d003a58 <___vfprintf_internal_r+0x520>
 d003dc8:	d9014f17 	ldw	r4,1340(sp)
 d003dcc:	d0071380 	call	d007138 <__sinit>
 d003dd0:	d9c15117 	ldw	r7,1348(sp)
 d003dd4:	003def06 	br	d003594 <___vfprintf_internal_r+0x5c>
 d003dd8:	d9014f17 	ldw	r4,1340(sp)
 d003ddc:	b00b883a 	mov	r5,r22
 d003de0:	d9c15115 	stw	r7,1348(sp)
 d003de4:	d00556c0 	call	d00556c <__swsetup_r>
 d003de8:	d9c15117 	ldw	r7,1348(sp)
 d003dec:	103dee26 	beq	r2,zero,d0035a8 <___vfprintf_internal_r+0x70>
 d003df0:	003f8c06 	br	d003c24 <___vfprintf_internal_r+0x6ec>
 d003df4:	d9014217 	ldw	r4,1288(sp)
 d003df8:	d9414317 	ldw	r5,1292(sp)
 d003dfc:	000d883a 	mov	r6,zero
 d003e00:	000f883a 	mov	r7,zero
 d003e04:	d00c1c40 	call	d00c1c4 <__eqdf2>
 d003e08:	1000f21e 	bne	r2,zero,d0041d4 <___vfprintf_internal_r+0xc9c>
 d003e0c:	00834174 	movhi	r2,3333
 d003e10:	10b8c704 	addi	r2,r2,-7396
 d003e14:	94800044 	addi	r18,r18,1
 d003e18:	8c400044 	addi	r17,r17,1
 d003e1c:	a8800015 	stw	r2,0(r21)
 d003e20:	00c00044 	movi	r3,1
 d003e24:	008001c4 	movi	r2,7
 d003e28:	a8c00115 	stw	r3,4(r21)
 d003e2c:	dc800e15 	stw	r18,56(sp)
 d003e30:	dc400d15 	stw	r17,52(sp)
 d003e34:	14430016 	blt	r2,r17,d004a38 <___vfprintf_internal_r+0x1500>
 d003e38:	a8c00204 	addi	r3,r21,8
 d003e3c:	d8800517 	ldw	r2,20(sp)
 d003e40:	d9014717 	ldw	r4,1308(sp)
 d003e44:	11015c0e 	bge	r2,r4,d0043b8 <___vfprintf_internal_r+0xe80>
 d003e48:	dc400d17 	ldw	r17,52(sp)
 d003e4c:	d9814917 	ldw	r6,1316(sp)
 d003e50:	00800044 	movi	r2,1
 d003e54:	94800044 	addi	r18,r18,1
 d003e58:	8c400044 	addi	r17,r17,1
 d003e5c:	18800115 	stw	r2,4(r3)
 d003e60:	008001c4 	movi	r2,7
 d003e64:	19800015 	stw	r6,0(r3)
 d003e68:	dc800e15 	stw	r18,56(sp)
 d003e6c:	dc400d15 	stw	r17,52(sp)
 d003e70:	14431616 	blt	r2,r17,d004acc <___vfprintf_internal_r+0x1594>
 d003e74:	18c00204 	addi	r3,r3,8
 d003e78:	d8814717 	ldw	r2,1308(sp)
 d003e7c:	143fffc4 	addi	r16,r2,-1
 d003e80:	043f2b0e 	bge	zero,r16,d003b30 <___vfprintf_internal_r+0x5f8>
 d003e84:	00800404 	movi	r2,16
 d003e88:	1402a80e 	bge	r2,r16,d00492c <___vfprintf_internal_r+0x13f4>
 d003e8c:	dc400d17 	ldw	r17,52(sp)
 d003e90:	1027883a 	mov	r19,r2
 d003e94:	07034174 	movhi	fp,3333
 d003e98:	e738c784 	addi	fp,fp,-7394
 d003e9c:	050001c4 	movi	r20,7
 d003ea0:	00000306 	br	d003eb0 <___vfprintf_internal_r+0x978>
 d003ea4:	18c00204 	addi	r3,r3,8
 d003ea8:	843ffc04 	addi	r16,r16,-16
 d003eac:	9c02a20e 	bge	r19,r16,d004938 <___vfprintf_internal_r+0x1400>
 d003eb0:	94800404 	addi	r18,r18,16
 d003eb4:	8c400044 	addi	r17,r17,1
 d003eb8:	1f000015 	stw	fp,0(r3)
 d003ebc:	1cc00115 	stw	r19,4(r3)
 d003ec0:	dc800e15 	stw	r18,56(sp)
 d003ec4:	dc400d15 	stw	r17,52(sp)
 d003ec8:	a47ff60e 	bge	r20,r17,d003ea4 <___vfprintf_internal_r+0x96c>
 d003ecc:	d9014f17 	ldw	r4,1340(sp)
 d003ed0:	b00b883a 	mov	r5,r22
 d003ed4:	d9800c04 	addi	r6,sp,48
 d003ed8:	d0034e00 	call	d0034e0 <__sprint_r>
 d003edc:	103f4e1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d003ee0:	dc800e17 	ldw	r18,56(sp)
 d003ee4:	dc400d17 	ldw	r17,52(sp)
 d003ee8:	d8c01904 	addi	r3,sp,100
 d003eec:	003fee06 	br	d003ea8 <___vfprintf_internal_r+0x970>
 d003ef0:	d8802c0b 	ldhu	r2,176(sp)
 d003ef4:	00ffffc4 	movi	r3,-1
 d003ef8:	d8c14b15 	stw	r3,1324(sp)
 d003efc:	1080100c 	andi	r2,r2,64
 d003f00:	103dcc1e 	bne	r2,zero,d003634 <___vfprintf_internal_r+0xfc>
 d003f04:	003dce06 	br	d003640 <___vfprintf_internal_r+0x108>
 d003f08:	d9014f17 	ldw	r4,1340(sp)
 d003f0c:	b00b883a 	mov	r5,r22
 d003f10:	d9800c04 	addi	r6,sp,48
 d003f14:	d0034e00 	call	d0034e0 <__sprint_r>
 d003f18:	103f3f1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d003f1c:	dc800e17 	ldw	r18,56(sp)
 d003f20:	003f2e06 	br	d003bdc <___vfprintf_internal_r+0x6a4>
 d003f24:	d9414c17 	ldw	r5,1328(sp)
 d003f28:	29400414 	ori	r5,r5,16
 d003f2c:	d9414c15 	stw	r5,1328(sp)
 d003f30:	d9814c17 	ldw	r6,1328(sp)
 d003f34:	3080080c 	andi	r2,r6,32
 d003f38:	10014f1e 	bne	r2,zero,d004478 <___vfprintf_internal_r+0xf40>
 d003f3c:	d8c14c17 	ldw	r3,1328(sp)
 d003f40:	1880040c 	andi	r2,r3,16
 d003f44:	1002f01e 	bne	r2,zero,d004b08 <___vfprintf_internal_r+0x15d0>
 d003f48:	d9014c17 	ldw	r4,1328(sp)
 d003f4c:	2080100c 	andi	r2,r4,64
 d003f50:	1002ed26 	beq	r2,zero,d004b08 <___vfprintf_internal_r+0x15d0>
 d003f54:	3880000f 	ldh	r2,0(r7)
 d003f58:	39c00104 	addi	r7,r7,4
 d003f5c:	d9c14015 	stw	r7,1280(sp)
 d003f60:	1023d7fa 	srai	r17,r2,31
 d003f64:	1021883a 	mov	r16,r2
 d003f68:	88037816 	blt	r17,zero,d004d4c <___vfprintf_internal_r+0x1814>
 d003f6c:	01000044 	movi	r4,1
 d003f70:	98000416 	blt	r19,zero,d003f84 <___vfprintf_internal_r+0xa4c>
 d003f74:	d8c14c17 	ldw	r3,1328(sp)
 d003f78:	00bfdfc4 	movi	r2,-129
 d003f7c:	1886703a 	and	r3,r3,r2
 d003f80:	d8c14c15 	stw	r3,1328(sp)
 d003f84:	8444b03a 	or	r2,r16,r17
 d003f88:	10022c1e 	bne	r2,zero,d00483c <___vfprintf_internal_r+0x1304>
 d003f8c:	98022b1e 	bne	r19,zero,d00483c <___vfprintf_internal_r+0x1304>
 d003f90:	20803fcc 	andi	r2,r4,255
 d003f94:	1002a126 	beq	r2,zero,d004a1c <___vfprintf_internal_r+0x14e4>
 d003f98:	d8c01904 	addi	r3,sp,100
 d003f9c:	dd000f04 	addi	r20,sp,60
 d003fa0:	d8c14115 	stw	r3,1284(sp)
 d003fa4:	d8c14117 	ldw	r3,1284(sp)
 d003fa8:	dcc14515 	stw	r19,1300(sp)
 d003fac:	a0c5c83a 	sub	r2,r20,r3
 d003fb0:	11c00a04 	addi	r7,r2,40
 d003fb4:	99c0010e 	bge	r19,r7,d003fbc <___vfprintf_internal_r+0xa84>
 d003fb8:	d9c14515 	stw	r7,1300(sp)
 d003fbc:	dcc14615 	stw	r19,1304(sp)
 d003fc0:	d8800407 	ldb	r2,16(sp)
 d003fc4:	103e4c26 	beq	r2,zero,d0038f8 <___vfprintf_internal_r+0x3c0>
 d003fc8:	d8814517 	ldw	r2,1300(sp)
 d003fcc:	10800044 	addi	r2,r2,1
 d003fd0:	d8814515 	stw	r2,1300(sp)
 d003fd4:	003e4806 	br	d0038f8 <___vfprintf_internal_r+0x3c0>
 d003fd8:	d9814c17 	ldw	r6,1328(sp)
 d003fdc:	31800414 	ori	r6,r6,16
 d003fe0:	d9814c15 	stw	r6,1328(sp)
 d003fe4:	d8c14c17 	ldw	r3,1328(sp)
 d003fe8:	1880080c 	andi	r2,r3,32
 d003fec:	1001271e 	bne	r2,zero,d00448c <___vfprintf_internal_r+0xf54>
 d003ff0:	d9414c17 	ldw	r5,1328(sp)
 d003ff4:	2880040c 	andi	r2,r5,16
 d003ff8:	1002bc1e 	bne	r2,zero,d004aec <___vfprintf_internal_r+0x15b4>
 d003ffc:	d9814c17 	ldw	r6,1328(sp)
 d004000:	3080100c 	andi	r2,r6,64
 d004004:	1002b926 	beq	r2,zero,d004aec <___vfprintf_internal_r+0x15b4>
 d004008:	3c00000b 	ldhu	r16,0(r7)
 d00400c:	0009883a 	mov	r4,zero
 d004010:	39c00104 	addi	r7,r7,4
 d004014:	0023883a 	mov	r17,zero
 d004018:	d9c14015 	stw	r7,1280(sp)
 d00401c:	d8000405 	stb	zero,16(sp)
 d004020:	003fd306 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d004024:	d9014c17 	ldw	r4,1328(sp)
 d004028:	21000414 	ori	r4,r4,16
 d00402c:	d9014c15 	stw	r4,1328(sp)
 d004030:	d9414c17 	ldw	r5,1328(sp)
 d004034:	2880080c 	andi	r2,r5,32
 d004038:	1001081e 	bne	r2,zero,d00445c <___vfprintf_internal_r+0xf24>
 d00403c:	d8c14c17 	ldw	r3,1328(sp)
 d004040:	1880040c 	andi	r2,r3,16
 d004044:	1002b61e 	bne	r2,zero,d004b20 <___vfprintf_internal_r+0x15e8>
 d004048:	d9014c17 	ldw	r4,1328(sp)
 d00404c:	2080100c 	andi	r2,r4,64
 d004050:	1002b326 	beq	r2,zero,d004b20 <___vfprintf_internal_r+0x15e8>
 d004054:	3c00000b 	ldhu	r16,0(r7)
 d004058:	01000044 	movi	r4,1
 d00405c:	39c00104 	addi	r7,r7,4
 d004060:	0023883a 	mov	r17,zero
 d004064:	d9c14015 	stw	r7,1280(sp)
 d004068:	d8000405 	stb	zero,16(sp)
 d00406c:	003fc006 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d004070:	d9014f17 	ldw	r4,1340(sp)
 d004074:	b00b883a 	mov	r5,r22
 d004078:	d9800c04 	addi	r6,sp,48
 d00407c:	d0034e00 	call	d0034e0 <__sprint_r>
 d004080:	103ee51e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004084:	dc800e17 	ldw	r18,56(sp)
 d004088:	d8c01904 	addi	r3,sp,100
 d00408c:	d9814c17 	ldw	r6,1328(sp)
 d004090:	3080004c 	andi	r2,r6,1
 d004094:	1005003a 	cmpeq	r2,r2,zero
 d004098:	103ea51e 	bne	r2,zero,d003b30 <___vfprintf_internal_r+0x5f8>
 d00409c:	00800044 	movi	r2,1
 d0040a0:	dc400d17 	ldw	r17,52(sp)
 d0040a4:	18800115 	stw	r2,4(r3)
 d0040a8:	d8814917 	ldw	r2,1316(sp)
 d0040ac:	94800044 	addi	r18,r18,1
 d0040b0:	8c400044 	addi	r17,r17,1
 d0040b4:	18800015 	stw	r2,0(r3)
 d0040b8:	008001c4 	movi	r2,7
 d0040bc:	dc800e15 	stw	r18,56(sp)
 d0040c0:	dc400d15 	stw	r17,52(sp)
 d0040c4:	1442240e 	bge	r2,r17,d004958 <___vfprintf_internal_r+0x1420>
 d0040c8:	d9014f17 	ldw	r4,1340(sp)
 d0040cc:	b00b883a 	mov	r5,r22
 d0040d0:	d9800c04 	addi	r6,sp,48
 d0040d4:	d0034e00 	call	d0034e0 <__sprint_r>
 d0040d8:	103ecf1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d0040dc:	dc800e17 	ldw	r18,56(sp)
 d0040e0:	d8c01904 	addi	r3,sp,100
 d0040e4:	003e9206 	br	d003b30 <___vfprintf_internal_r+0x5f8>
 d0040e8:	d9014f17 	ldw	r4,1340(sp)
 d0040ec:	b00b883a 	mov	r5,r22
 d0040f0:	d9800c04 	addi	r6,sp,48
 d0040f4:	d0034e00 	call	d0034e0 <__sprint_r>
 d0040f8:	103ec026 	beq	r2,zero,d003bfc <___vfprintf_internal_r+0x6c4>
 d0040fc:	003ec606 	br	d003c18 <___vfprintf_internal_r+0x6e0>
 d004100:	d9014f17 	ldw	r4,1340(sp)
 d004104:	b00b883a 	mov	r5,r22
 d004108:	d9800c04 	addi	r6,sp,48
 d00410c:	d9c15115 	stw	r7,1348(sp)
 d004110:	d0034e00 	call	d0034e0 <__sprint_r>
 d004114:	d9c15117 	ldw	r7,1348(sp)
 d004118:	103ebf1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d00411c:	dc800e17 	ldw	r18,56(sp)
 d004120:	dc400d17 	ldw	r17,52(sp)
 d004124:	dd401904 	addi	r21,sp,100
 d004128:	003e7406 	br	d003afc <___vfprintf_internal_r+0x5c4>
 d00412c:	d9014f17 	ldw	r4,1340(sp)
 d004130:	b00b883a 	mov	r5,r22
 d004134:	d9800c04 	addi	r6,sp,48
 d004138:	d9c15115 	stw	r7,1348(sp)
 d00413c:	d0034e00 	call	d0034e0 <__sprint_r>
 d004140:	d9c15117 	ldw	r7,1348(sp)
 d004144:	103eb41e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004148:	dd401904 	addi	r21,sp,100
 d00414c:	003d6d06 	br	d003704 <___vfprintf_internal_r+0x1cc>
 d004150:	d9014f17 	ldw	r4,1340(sp)
 d004154:	b00b883a 	mov	r5,r22
 d004158:	d9800c04 	addi	r6,sp,48
 d00415c:	d9c15115 	stw	r7,1348(sp)
 d004160:	d0034e00 	call	d0034e0 <__sprint_r>
 d004164:	d9c15117 	ldw	r7,1348(sp)
 d004168:	103eab1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d00416c:	dc800e17 	ldw	r18,56(sp)
 d004170:	dc400d17 	ldw	r17,52(sp)
 d004174:	dd401904 	addi	r21,sp,100
 d004178:	003e3406 	br	d003a4c <___vfprintf_internal_r+0x514>
 d00417c:	d9014f17 	ldw	r4,1340(sp)
 d004180:	b00b883a 	mov	r5,r22
 d004184:	d9800c04 	addi	r6,sp,48
 d004188:	d9c15115 	stw	r7,1348(sp)
 d00418c:	d0034e00 	call	d0034e0 <__sprint_r>
 d004190:	d9c15117 	ldw	r7,1348(sp)
 d004194:	103ea01e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004198:	dc800e17 	ldw	r18,56(sp)
 d00419c:	dc400d17 	ldw	r17,52(sp)
 d0041a0:	dd401904 	addi	r21,sp,100
 d0041a4:	003e1c06 	br	d003a18 <___vfprintf_internal_r+0x4e0>
 d0041a8:	d9014f17 	ldw	r4,1340(sp)
 d0041ac:	b00b883a 	mov	r5,r22
 d0041b0:	d9800c04 	addi	r6,sp,48
 d0041b4:	d9c15115 	stw	r7,1348(sp)
 d0041b8:	d0034e00 	call	d0034e0 <__sprint_r>
 d0041bc:	d9c15117 	ldw	r7,1348(sp)
 d0041c0:	103e951e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d0041c4:	dc800e17 	ldw	r18,56(sp)
 d0041c8:	dc400d17 	ldw	r17,52(sp)
 d0041cc:	dd401904 	addi	r21,sp,100
 d0041d0:	003e0406 	br	d0039e4 <___vfprintf_internal_r+0x4ac>
 d0041d4:	d9000517 	ldw	r4,20(sp)
 d0041d8:	0102580e 	bge	zero,r4,d004b3c <___vfprintf_internal_r+0x1604>
 d0041dc:	d9814717 	ldw	r6,1308(sp)
 d0041e0:	21807a16 	blt	r4,r6,d0043cc <___vfprintf_internal_r+0xe94>
 d0041e4:	d8814117 	ldw	r2,1284(sp)
 d0041e8:	91a5883a 	add	r18,r18,r6
 d0041ec:	8c400044 	addi	r17,r17,1
 d0041f0:	a8800015 	stw	r2,0(r21)
 d0041f4:	008001c4 	movi	r2,7
 d0041f8:	a9800115 	stw	r6,4(r21)
 d0041fc:	dc800e15 	stw	r18,56(sp)
 d004200:	dc400d15 	stw	r17,52(sp)
 d004204:	1442fc16 	blt	r2,r17,d004df8 <___vfprintf_internal_r+0x18c0>
 d004208:	a8c00204 	addi	r3,r21,8
 d00420c:	d9414717 	ldw	r5,1308(sp)
 d004210:	2161c83a 	sub	r16,r4,r5
 d004214:	043f9d0e 	bge	zero,r16,d00408c <___vfprintf_internal_r+0xb54>
 d004218:	00800404 	movi	r2,16
 d00421c:	1402190e 	bge	r2,r16,d004a84 <___vfprintf_internal_r+0x154c>
 d004220:	dc400d17 	ldw	r17,52(sp)
 d004224:	1027883a 	mov	r19,r2
 d004228:	07034174 	movhi	fp,3333
 d00422c:	e738c784 	addi	fp,fp,-7394
 d004230:	050001c4 	movi	r20,7
 d004234:	00000306 	br	d004244 <___vfprintf_internal_r+0xd0c>
 d004238:	18c00204 	addi	r3,r3,8
 d00423c:	843ffc04 	addi	r16,r16,-16
 d004240:	9c02130e 	bge	r19,r16,d004a90 <___vfprintf_internal_r+0x1558>
 d004244:	94800404 	addi	r18,r18,16
 d004248:	8c400044 	addi	r17,r17,1
 d00424c:	1f000015 	stw	fp,0(r3)
 d004250:	1cc00115 	stw	r19,4(r3)
 d004254:	dc800e15 	stw	r18,56(sp)
 d004258:	dc400d15 	stw	r17,52(sp)
 d00425c:	a47ff60e 	bge	r20,r17,d004238 <___vfprintf_internal_r+0xd00>
 d004260:	d9014f17 	ldw	r4,1340(sp)
 d004264:	b00b883a 	mov	r5,r22
 d004268:	d9800c04 	addi	r6,sp,48
 d00426c:	d0034e00 	call	d0034e0 <__sprint_r>
 d004270:	103e691e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004274:	dc800e17 	ldw	r18,56(sp)
 d004278:	dc400d17 	ldw	r17,52(sp)
 d00427c:	d8c01904 	addi	r3,sp,100
 d004280:	003fee06 	br	d00423c <___vfprintf_internal_r+0xd04>
 d004284:	d8814717 	ldw	r2,1308(sp)
 d004288:	143fffc4 	addi	r16,r2,-1
 d00428c:	043e970e 	bge	zero,r16,d003cec <___vfprintf_internal_r+0x7b4>
 d004290:	00800404 	movi	r2,16
 d004294:	1400180e 	bge	r2,r16,d0042f8 <___vfprintf_internal_r+0xdc0>
 d004298:	1029883a 	mov	r20,r2
 d00429c:	07034174 	movhi	fp,3333
 d0042a0:	e738c784 	addi	fp,fp,-7394
 d0042a4:	054001c4 	movi	r21,7
 d0042a8:	00000306 	br	d0042b8 <___vfprintf_internal_r+0xd80>
 d0042ac:	9cc00204 	addi	r19,r19,8
 d0042b0:	843ffc04 	addi	r16,r16,-16
 d0042b4:	a400120e 	bge	r20,r16,d004300 <___vfprintf_internal_r+0xdc8>
 d0042b8:	94800404 	addi	r18,r18,16
 d0042bc:	8c400044 	addi	r17,r17,1
 d0042c0:	9f000015 	stw	fp,0(r19)
 d0042c4:	9d000115 	stw	r20,4(r19)
 d0042c8:	dc800e15 	stw	r18,56(sp)
 d0042cc:	dc400d15 	stw	r17,52(sp)
 d0042d0:	ac7ff60e 	bge	r21,r17,d0042ac <___vfprintf_internal_r+0xd74>
 d0042d4:	d9014f17 	ldw	r4,1340(sp)
 d0042d8:	b00b883a 	mov	r5,r22
 d0042dc:	d9800c04 	addi	r6,sp,48
 d0042e0:	d0034e00 	call	d0034e0 <__sprint_r>
 d0042e4:	103e4c1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d0042e8:	dc800e17 	ldw	r18,56(sp)
 d0042ec:	dc400d17 	ldw	r17,52(sp)
 d0042f0:	dcc01904 	addi	r19,sp,100
 d0042f4:	003fee06 	br	d0042b0 <___vfprintf_internal_r+0xd78>
 d0042f8:	07034174 	movhi	fp,3333
 d0042fc:	e738c784 	addi	fp,fp,-7394
 d004300:	9425883a 	add	r18,r18,r16
 d004304:	8c400044 	addi	r17,r17,1
 d004308:	008001c4 	movi	r2,7
 d00430c:	9f000015 	stw	fp,0(r19)
 d004310:	9c000115 	stw	r16,4(r19)
 d004314:	dc800e15 	stw	r18,56(sp)
 d004318:	dc400d15 	stw	r17,52(sp)
 d00431c:	147e720e 	bge	r2,r17,d003ce8 <___vfprintf_internal_r+0x7b0>
 d004320:	d9014f17 	ldw	r4,1340(sp)
 d004324:	b00b883a 	mov	r5,r22
 d004328:	d9800c04 	addi	r6,sp,48
 d00432c:	d0034e00 	call	d0034e0 <__sprint_r>
 d004330:	103e391e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004334:	dc800e17 	ldw	r18,56(sp)
 d004338:	dc400d17 	ldw	r17,52(sp)
 d00433c:	dcc01904 	addi	r19,sp,100
 d004340:	003e6a06 	br	d003cec <___vfprintf_internal_r+0x7b4>
 d004344:	d9014f17 	ldw	r4,1340(sp)
 d004348:	b00b883a 	mov	r5,r22
 d00434c:	d9800c04 	addi	r6,sp,48
 d004350:	d9c15115 	stw	r7,1348(sp)
 d004354:	d0034e00 	call	d0034e0 <__sprint_r>
 d004358:	d9c15117 	ldw	r7,1348(sp)
 d00435c:	103e2e1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004360:	dc800e17 	ldw	r18,56(sp)
 d004364:	dc400d17 	ldw	r17,52(sp)
 d004368:	dd401904 	addi	r21,sp,100
 d00436c:	003dba06 	br	d003a58 <___vfprintf_internal_r+0x520>
 d004370:	d9014f17 	ldw	r4,1340(sp)
 d004374:	b00b883a 	mov	r5,r22
 d004378:	d9800c04 	addi	r6,sp,48
 d00437c:	d0034e00 	call	d0034e0 <__sprint_r>
 d004380:	103e251e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004384:	dc800e17 	ldw	r18,56(sp)
 d004388:	dc400d17 	ldw	r17,52(sp)
 d00438c:	dcc01904 	addi	r19,sp,100
 d004390:	003e4206 	br	d003c9c <___vfprintf_internal_r+0x764>
 d004394:	d9014f17 	ldw	r4,1340(sp)
 d004398:	b00b883a 	mov	r5,r22
 d00439c:	d9800c04 	addi	r6,sp,48
 d0043a0:	d0034e00 	call	d0034e0 <__sprint_r>
 d0043a4:	103e1c1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d0043a8:	dc800e17 	ldw	r18,56(sp)
 d0043ac:	dc400d17 	ldw	r17,52(sp)
 d0043b0:	d8c01904 	addi	r3,sp,100
 d0043b4:	003e2e06 	br	d003c70 <___vfprintf_internal_r+0x738>
 d0043b8:	d9414c17 	ldw	r5,1328(sp)
 d0043bc:	2880004c 	andi	r2,r5,1
 d0043c0:	1005003a 	cmpeq	r2,r2,zero
 d0043c4:	103dda1e 	bne	r2,zero,d003b30 <___vfprintf_internal_r+0x5f8>
 d0043c8:	003e9f06 	br	d003e48 <___vfprintf_internal_r+0x910>
 d0043cc:	d8c14117 	ldw	r3,1284(sp)
 d0043d0:	9125883a 	add	r18,r18,r4
 d0043d4:	8c400044 	addi	r17,r17,1
 d0043d8:	008001c4 	movi	r2,7
 d0043dc:	a8c00015 	stw	r3,0(r21)
 d0043e0:	a9000115 	stw	r4,4(r21)
 d0043e4:	dc800e15 	stw	r18,56(sp)
 d0043e8:	dc400d15 	stw	r17,52(sp)
 d0043ec:	14426c16 	blt	r2,r17,d004da0 <___vfprintf_internal_r+0x1868>
 d0043f0:	a8c00204 	addi	r3,r21,8
 d0043f4:	d9414917 	ldw	r5,1316(sp)
 d0043f8:	00800044 	movi	r2,1
 d0043fc:	94800044 	addi	r18,r18,1
 d004400:	8c400044 	addi	r17,r17,1
 d004404:	18800115 	stw	r2,4(r3)
 d004408:	008001c4 	movi	r2,7
 d00440c:	19400015 	stw	r5,0(r3)
 d004410:	dc800e15 	stw	r18,56(sp)
 d004414:	dc400d15 	stw	r17,52(sp)
 d004418:	2021883a 	mov	r16,r4
 d00441c:	14425616 	blt	r2,r17,d004d78 <___vfprintf_internal_r+0x1840>
 d004420:	19400204 	addi	r5,r3,8
 d004424:	d9814717 	ldw	r6,1308(sp)
 d004428:	8c400044 	addi	r17,r17,1
 d00442c:	dc400d15 	stw	r17,52(sp)
 d004430:	3107c83a 	sub	r3,r6,r4
 d004434:	d9014117 	ldw	r4,1284(sp)
 d004438:	90e5883a 	add	r18,r18,r3
 d00443c:	28c00115 	stw	r3,4(r5)
 d004440:	8105883a 	add	r2,r16,r4
 d004444:	28800015 	stw	r2,0(r5)
 d004448:	008001c4 	movi	r2,7
 d00444c:	dc800e15 	stw	r18,56(sp)
 d004450:	147f1d16 	blt	r2,r17,d0040c8 <___vfprintf_internal_r+0xb90>
 d004454:	28c00204 	addi	r3,r5,8
 d004458:	003db506 	br	d003b30 <___vfprintf_internal_r+0x5f8>
 d00445c:	3c000017 	ldw	r16,0(r7)
 d004460:	3c400117 	ldw	r17,4(r7)
 d004464:	39800204 	addi	r6,r7,8
 d004468:	01000044 	movi	r4,1
 d00446c:	d9814015 	stw	r6,1280(sp)
 d004470:	d8000405 	stb	zero,16(sp)
 d004474:	003ebe06 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d004478:	3c000017 	ldw	r16,0(r7)
 d00447c:	3c400117 	ldw	r17,4(r7)
 d004480:	38800204 	addi	r2,r7,8
 d004484:	d8814015 	stw	r2,1280(sp)
 d004488:	003eb706 	br	d003f68 <___vfprintf_internal_r+0xa30>
 d00448c:	3c000017 	ldw	r16,0(r7)
 d004490:	3c400117 	ldw	r17,4(r7)
 d004494:	39000204 	addi	r4,r7,8
 d004498:	d9014015 	stw	r4,1280(sp)
 d00449c:	0009883a 	mov	r4,zero
 d0044a0:	d8000405 	stb	zero,16(sp)
 d0044a4:	003eb206 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d0044a8:	38c00017 	ldw	r3,0(r7)
 d0044ac:	39c00104 	addi	r7,r7,4
 d0044b0:	d8c14a15 	stw	r3,1320(sp)
 d0044b4:	1800d70e 	bge	r3,zero,d004814 <___vfprintf_internal_r+0x12dc>
 d0044b8:	00c7c83a 	sub	r3,zero,r3
 d0044bc:	d8c14a15 	stw	r3,1320(sp)
 d0044c0:	d9014c17 	ldw	r4,1328(sp)
 d0044c4:	b8c00007 	ldb	r3,0(r23)
 d0044c8:	21000114 	ori	r4,r4,4
 d0044cc:	d9014c15 	stw	r4,1328(sp)
 d0044d0:	003c9806 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d0044d4:	d9814c17 	ldw	r6,1328(sp)
 d0044d8:	3080080c 	andi	r2,r6,32
 d0044dc:	1001f626 	beq	r2,zero,d004cb8 <___vfprintf_internal_r+0x1780>
 d0044e0:	d9014b17 	ldw	r4,1324(sp)
 d0044e4:	38800017 	ldw	r2,0(r7)
 d0044e8:	39c00104 	addi	r7,r7,4
 d0044ec:	d9c14015 	stw	r7,1280(sp)
 d0044f0:	2007d7fa 	srai	r3,r4,31
 d0044f4:	d9c14017 	ldw	r7,1280(sp)
 d0044f8:	11000015 	stw	r4,0(r2)
 d0044fc:	10c00115 	stw	r3,4(r2)
 d004500:	003c6906 	br	d0036a8 <___vfprintf_internal_r+0x170>
 d004504:	b8c00007 	ldb	r3,0(r23)
 d004508:	00801b04 	movi	r2,108
 d00450c:	18825526 	beq	r3,r2,d004e64 <___vfprintf_internal_r+0x192c>
 d004510:	d9414c17 	ldw	r5,1328(sp)
 d004514:	29400414 	ori	r5,r5,16
 d004518:	d9414c15 	stw	r5,1328(sp)
 d00451c:	003c8506 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d004520:	d9814c17 	ldw	r6,1328(sp)
 d004524:	b8c00007 	ldb	r3,0(r23)
 d004528:	31800814 	ori	r6,r6,32
 d00452c:	d9814c15 	stw	r6,1328(sp)
 d004530:	003c8006 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d004534:	d8814c17 	ldw	r2,1328(sp)
 d004538:	3c000017 	ldw	r16,0(r7)
 d00453c:	00c01e04 	movi	r3,120
 d004540:	10800094 	ori	r2,r2,2
 d004544:	d8814c15 	stw	r2,1328(sp)
 d004548:	39c00104 	addi	r7,r7,4
 d00454c:	01434174 	movhi	r5,3333
 d004550:	2978b004 	addi	r5,r5,-7488
 d004554:	00800c04 	movi	r2,48
 d004558:	0023883a 	mov	r17,zero
 d00455c:	01000084 	movi	r4,2
 d004560:	d9c14015 	stw	r7,1280(sp)
 d004564:	d8c14d15 	stw	r3,1332(sp)
 d004568:	d9414415 	stw	r5,1296(sp)
 d00456c:	d8800445 	stb	r2,17(sp)
 d004570:	d8c00485 	stb	r3,18(sp)
 d004574:	d8000405 	stb	zero,16(sp)
 d004578:	003e7d06 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d00457c:	d8814c17 	ldw	r2,1328(sp)
 d004580:	b8c00007 	ldb	r3,0(r23)
 d004584:	10801014 	ori	r2,r2,64
 d004588:	d8814c15 	stw	r2,1328(sp)
 d00458c:	003c6906 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d004590:	d9414c17 	ldw	r5,1328(sp)
 d004594:	2880020c 	andi	r2,r5,8
 d004598:	1001e526 	beq	r2,zero,d004d30 <___vfprintf_internal_r+0x17f8>
 d00459c:	39800017 	ldw	r6,0(r7)
 d0045a0:	38800204 	addi	r2,r7,8
 d0045a4:	d8814015 	stw	r2,1280(sp)
 d0045a8:	d9814215 	stw	r6,1288(sp)
 d0045ac:	39c00117 	ldw	r7,4(r7)
 d0045b0:	d9c14315 	stw	r7,1292(sp)
 d0045b4:	d9014217 	ldw	r4,1288(sp)
 d0045b8:	d9414317 	ldw	r5,1292(sp)
 d0045bc:	d00a2480 	call	d00a248 <__isinfd>
 d0045c0:	10021d26 	beq	r2,zero,d004e38 <___vfprintf_internal_r+0x1900>
 d0045c4:	d9014217 	ldw	r4,1288(sp)
 d0045c8:	d9414317 	ldw	r5,1292(sp)
 d0045cc:	000d883a 	mov	r6,zero
 d0045d0:	000f883a 	mov	r7,zero
 d0045d4:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d0045d8:	1002d016 	blt	r2,zero,d00511c <___vfprintf_internal_r+0x1be4>
 d0045dc:	d9414d17 	ldw	r5,1332(sp)
 d0045e0:	008011c4 	movi	r2,71
 d0045e4:	11421016 	blt	r2,r5,d004e28 <___vfprintf_internal_r+0x18f0>
 d0045e8:	01834174 	movhi	r6,3333
 d0045ec:	31b8b504 	addi	r6,r6,-7468
 d0045f0:	d9814115 	stw	r6,1284(sp)
 d0045f4:	d9014c17 	ldw	r4,1328(sp)
 d0045f8:	00c000c4 	movi	r3,3
 d0045fc:	00bfdfc4 	movi	r2,-129
 d004600:	2088703a 	and	r4,r4,r2
 d004604:	180f883a 	mov	r7,r3
 d004608:	d8c14515 	stw	r3,1300(sp)
 d00460c:	d9014c15 	stw	r4,1328(sp)
 d004610:	d8014615 	stw	zero,1304(sp)
 d004614:	003e6a06 	br	d003fc0 <___vfprintf_internal_r+0xa88>
 d004618:	38800017 	ldw	r2,0(r7)
 d00461c:	00c00044 	movi	r3,1
 d004620:	39c00104 	addi	r7,r7,4
 d004624:	d9c14015 	stw	r7,1280(sp)
 d004628:	d9000f04 	addi	r4,sp,60
 d00462c:	180f883a 	mov	r7,r3
 d004630:	d8c14515 	stw	r3,1300(sp)
 d004634:	d9014115 	stw	r4,1284(sp)
 d004638:	d8800f05 	stb	r2,60(sp)
 d00463c:	d8000405 	stb	zero,16(sp)
 d004640:	003cac06 	br	d0038f4 <___vfprintf_internal_r+0x3bc>
 d004644:	01434174 	movhi	r5,3333
 d004648:	2978bb04 	addi	r5,r5,-7444
 d00464c:	d9414415 	stw	r5,1296(sp)
 d004650:	d9814c17 	ldw	r6,1328(sp)
 d004654:	3080080c 	andi	r2,r6,32
 d004658:	1000ff26 	beq	r2,zero,d004a58 <___vfprintf_internal_r+0x1520>
 d00465c:	3c000017 	ldw	r16,0(r7)
 d004660:	3c400117 	ldw	r17,4(r7)
 d004664:	38800204 	addi	r2,r7,8
 d004668:	d8814015 	stw	r2,1280(sp)
 d00466c:	d9414c17 	ldw	r5,1328(sp)
 d004670:	2880004c 	andi	r2,r5,1
 d004674:	1005003a 	cmpeq	r2,r2,zero
 d004678:	1000b91e 	bne	r2,zero,d004960 <___vfprintf_internal_r+0x1428>
 d00467c:	8444b03a 	or	r2,r16,r17
 d004680:	1000b726 	beq	r2,zero,d004960 <___vfprintf_internal_r+0x1428>
 d004684:	d9814d17 	ldw	r6,1332(sp)
 d004688:	29400094 	ori	r5,r5,2
 d00468c:	00800c04 	movi	r2,48
 d004690:	01000084 	movi	r4,2
 d004694:	d9414c15 	stw	r5,1328(sp)
 d004698:	d8800445 	stb	r2,17(sp)
 d00469c:	d9800485 	stb	r6,18(sp)
 d0046a0:	d8000405 	stb	zero,16(sp)
 d0046a4:	003e3206 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d0046a8:	01834174 	movhi	r6,3333
 d0046ac:	31b8b004 	addi	r6,r6,-7488
 d0046b0:	d9814415 	stw	r6,1296(sp)
 d0046b4:	003fe606 	br	d004650 <___vfprintf_internal_r+0x1118>
 d0046b8:	00800ac4 	movi	r2,43
 d0046bc:	d8800405 	stb	r2,16(sp)
 d0046c0:	b8c00007 	ldb	r3,0(r23)
 d0046c4:	003c1b06 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d0046c8:	d8814c17 	ldw	r2,1328(sp)
 d0046cc:	b8c00007 	ldb	r3,0(r23)
 d0046d0:	10800054 	ori	r2,r2,1
 d0046d4:	d8814c15 	stw	r2,1328(sp)
 d0046d8:	003c1606 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d0046dc:	d8800407 	ldb	r2,16(sp)
 d0046e0:	10004c1e 	bne	r2,zero,d004814 <___vfprintf_internal_r+0x12dc>
 d0046e4:	00800804 	movi	r2,32
 d0046e8:	d8800405 	stb	r2,16(sp)
 d0046ec:	b8c00007 	ldb	r3,0(r23)
 d0046f0:	003c1006 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d0046f4:	d9814c17 	ldw	r6,1328(sp)
 d0046f8:	b8c00007 	ldb	r3,0(r23)
 d0046fc:	31800214 	ori	r6,r6,8
 d004700:	d9814c15 	stw	r6,1328(sp)
 d004704:	003c0b06 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d004708:	0009883a 	mov	r4,zero
 d00470c:	04000244 	movi	r16,9
 d004710:	01400284 	movi	r5,10
 d004714:	d9c15115 	stw	r7,1348(sp)
 d004718:	d00235c0 	call	d00235c <__mulsi3>
 d00471c:	b9000007 	ldb	r4,0(r23)
 d004720:	d8c14d17 	ldw	r3,1332(sp)
 d004724:	bdc00044 	addi	r23,r23,1
 d004728:	d9014d15 	stw	r4,1332(sp)
 d00472c:	d9414d17 	ldw	r5,1332(sp)
 d004730:	1885883a 	add	r2,r3,r2
 d004734:	113ff404 	addi	r4,r2,-48
 d004738:	28bff404 	addi	r2,r5,-48
 d00473c:	d9c15117 	ldw	r7,1348(sp)
 d004740:	80bff32e 	bgeu	r16,r2,d004710 <___vfprintf_internal_r+0x11d8>
 d004744:	d9014a15 	stw	r4,1320(sp)
 d004748:	003bfc06 	br	d00373c <___vfprintf_internal_r+0x204>
 d00474c:	d8814c17 	ldw	r2,1328(sp)
 d004750:	b8c00007 	ldb	r3,0(r23)
 d004754:	10802014 	ori	r2,r2,128
 d004758:	d8814c15 	stw	r2,1328(sp)
 d00475c:	003bf506 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d004760:	b8c00007 	ldb	r3,0(r23)
 d004764:	00800a84 	movi	r2,42
 d004768:	bdc00044 	addi	r23,r23,1
 d00476c:	18831826 	beq	r3,r2,d0053d0 <___vfprintf_internal_r+0x1e98>
 d004770:	d8c14d15 	stw	r3,1332(sp)
 d004774:	18bff404 	addi	r2,r3,-48
 d004778:	00c00244 	movi	r3,9
 d00477c:	18827b36 	bltu	r3,r2,d00516c <___vfprintf_internal_r+0x1c34>
 d004780:	1821883a 	mov	r16,r3
 d004784:	0009883a 	mov	r4,zero
 d004788:	01400284 	movi	r5,10
 d00478c:	d9c15115 	stw	r7,1348(sp)
 d004790:	d00235c0 	call	d00235c <__mulsi3>
 d004794:	d9414d17 	ldw	r5,1332(sp)
 d004798:	b9800007 	ldb	r6,0(r23)
 d00479c:	d9c15117 	ldw	r7,1348(sp)
 d0047a0:	1145883a 	add	r2,r2,r5
 d0047a4:	113ff404 	addi	r4,r2,-48
 d0047a8:	30bff404 	addi	r2,r6,-48
 d0047ac:	d9814d15 	stw	r6,1332(sp)
 d0047b0:	bdc00044 	addi	r23,r23,1
 d0047b4:	80bff42e 	bgeu	r16,r2,d004788 <___vfprintf_internal_r+0x1250>
 d0047b8:	2027883a 	mov	r19,r4
 d0047bc:	203bdf0e 	bge	r4,zero,d00373c <___vfprintf_internal_r+0x204>
 d0047c0:	04ffffc4 	movi	r19,-1
 d0047c4:	003bdd06 	br	d00373c <___vfprintf_internal_r+0x204>
 d0047c8:	d8000405 	stb	zero,16(sp)
 d0047cc:	39800017 	ldw	r6,0(r7)
 d0047d0:	39c00104 	addi	r7,r7,4
 d0047d4:	d9c14015 	stw	r7,1280(sp)
 d0047d8:	d9814115 	stw	r6,1284(sp)
 d0047dc:	3001c926 	beq	r6,zero,d004f04 <___vfprintf_internal_r+0x19cc>
 d0047e0:	98000e16 	blt	r19,zero,d00481c <___vfprintf_internal_r+0x12e4>
 d0047e4:	d9014117 	ldw	r4,1284(sp)
 d0047e8:	000b883a 	mov	r5,zero
 d0047ec:	980d883a 	mov	r6,r19
 d0047f0:	d0089040 	call	d008904 <memchr>
 d0047f4:	10025926 	beq	r2,zero,d00515c <___vfprintf_internal_r+0x1c24>
 d0047f8:	d8c14117 	ldw	r3,1284(sp)
 d0047fc:	10cfc83a 	sub	r7,r2,r3
 d004800:	99c19e16 	blt	r19,r7,d004e7c <___vfprintf_internal_r+0x1944>
 d004804:	d9c14515 	stw	r7,1300(sp)
 d004808:	38000916 	blt	r7,zero,d004830 <___vfprintf_internal_r+0x12f8>
 d00480c:	d8014615 	stw	zero,1304(sp)
 d004810:	003deb06 	br	d003fc0 <___vfprintf_internal_r+0xa88>
 d004814:	b8c00007 	ldb	r3,0(r23)
 d004818:	003bc606 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d00481c:	d9014117 	ldw	r4,1284(sp)
 d004820:	d0034640 	call	d003464 <strlen>
 d004824:	d8814515 	stw	r2,1300(sp)
 d004828:	100f883a 	mov	r7,r2
 d00482c:	103ff70e 	bge	r2,zero,d00480c <___vfprintf_internal_r+0x12d4>
 d004830:	d8014515 	stw	zero,1300(sp)
 d004834:	d8014615 	stw	zero,1304(sp)
 d004838:	003de106 	br	d003fc0 <___vfprintf_internal_r+0xa88>
 d00483c:	20c03fcc 	andi	r3,r4,255
 d004840:	00800044 	movi	r2,1
 d004844:	18802d26 	beq	r3,r2,d0048fc <___vfprintf_internal_r+0x13c4>
 d004848:	18800e36 	bltu	r3,r2,d004884 <___vfprintf_internal_r+0x134c>
 d00484c:	00800084 	movi	r2,2
 d004850:	1880fa26 	beq	r3,r2,d004c3c <___vfprintf_internal_r+0x1704>
 d004854:	01034174 	movhi	r4,3333
 d004858:	2138c004 	addi	r4,r4,-7424
 d00485c:	d0034640 	call	d003464 <strlen>
 d004860:	100f883a 	mov	r7,r2
 d004864:	dcc14515 	stw	r19,1300(sp)
 d004868:	9880010e 	bge	r19,r2,d004870 <___vfprintf_internal_r+0x1338>
 d00486c:	d8814515 	stw	r2,1300(sp)
 d004870:	00834174 	movhi	r2,3333
 d004874:	10b8c004 	addi	r2,r2,-7424
 d004878:	dcc14615 	stw	r19,1304(sp)
 d00487c:	d8814115 	stw	r2,1284(sp)
 d004880:	003dcf06 	br	d003fc0 <___vfprintf_internal_r+0xa88>
 d004884:	d9401904 	addi	r5,sp,100
 d004888:	dd000f04 	addi	r20,sp,60
 d00488c:	d9414115 	stw	r5,1284(sp)
 d004890:	880a977a 	slli	r5,r17,29
 d004894:	d9814117 	ldw	r6,1284(sp)
 d004898:	8004d0fa 	srli	r2,r16,3
 d00489c:	8806d0fa 	srli	r3,r17,3
 d0048a0:	810001cc 	andi	r4,r16,7
 d0048a4:	2884b03a 	or	r2,r5,r2
 d0048a8:	31bfffc4 	addi	r6,r6,-1
 d0048ac:	21000c04 	addi	r4,r4,48
 d0048b0:	d9814115 	stw	r6,1284(sp)
 d0048b4:	10cab03a 	or	r5,r2,r3
 d0048b8:	31000005 	stb	r4,0(r6)
 d0048bc:	1021883a 	mov	r16,r2
 d0048c0:	1823883a 	mov	r17,r3
 d0048c4:	283ff21e 	bne	r5,zero,d004890 <___vfprintf_internal_r+0x1358>
 d0048c8:	d8c14c17 	ldw	r3,1328(sp)
 d0048cc:	1880004c 	andi	r2,r3,1
 d0048d0:	1005003a 	cmpeq	r2,r2,zero
 d0048d4:	103db31e 	bne	r2,zero,d003fa4 <___vfprintf_internal_r+0xa6c>
 d0048d8:	20803fcc 	andi	r2,r4,255
 d0048dc:	1080201c 	xori	r2,r2,128
 d0048e0:	10bfe004 	addi	r2,r2,-128
 d0048e4:	00c00c04 	movi	r3,48
 d0048e8:	10fdae26 	beq	r2,r3,d003fa4 <___vfprintf_internal_r+0xa6c>
 d0048ec:	31bfffc4 	addi	r6,r6,-1
 d0048f0:	d9814115 	stw	r6,1284(sp)
 d0048f4:	30c00005 	stb	r3,0(r6)
 d0048f8:	003daa06 	br	d003fa4 <___vfprintf_internal_r+0xa6c>
 d0048fc:	88800068 	cmpgeui	r2,r17,1
 d004900:	10002c1e 	bne	r2,zero,d0049b4 <___vfprintf_internal_r+0x147c>
 d004904:	8800021e 	bne	r17,zero,d004910 <___vfprintf_internal_r+0x13d8>
 d004908:	00800244 	movi	r2,9
 d00490c:	14002936 	bltu	r2,r16,d0049b4 <___vfprintf_internal_r+0x147c>
 d004910:	d90018c4 	addi	r4,sp,99
 d004914:	dd000f04 	addi	r20,sp,60
 d004918:	d9014115 	stw	r4,1284(sp)
 d00491c:	d9014117 	ldw	r4,1284(sp)
 d004920:	80800c04 	addi	r2,r16,48
 d004924:	20800005 	stb	r2,0(r4)
 d004928:	003d9e06 	br	d003fa4 <___vfprintf_internal_r+0xa6c>
 d00492c:	dc400d17 	ldw	r17,52(sp)
 d004930:	07034174 	movhi	fp,3333
 d004934:	e738c784 	addi	fp,fp,-7394
 d004938:	9425883a 	add	r18,r18,r16
 d00493c:	8c400044 	addi	r17,r17,1
 d004940:	008001c4 	movi	r2,7
 d004944:	1f000015 	stw	fp,0(r3)
 d004948:	1c000115 	stw	r16,4(r3)
 d00494c:	dc800e15 	stw	r18,56(sp)
 d004950:	dc400d15 	stw	r17,52(sp)
 d004954:	147ddc16 	blt	r2,r17,d0040c8 <___vfprintf_internal_r+0xb90>
 d004958:	18c00204 	addi	r3,r3,8
 d00495c:	003c7406 	br	d003b30 <___vfprintf_internal_r+0x5f8>
 d004960:	01000084 	movi	r4,2
 d004964:	d8000405 	stb	zero,16(sp)
 d004968:	003d8106 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d00496c:	d9814c17 	ldw	r6,1328(sp)
 d004970:	30c4703a 	and	r2,r6,r3
 d004974:	1005003a 	cmpeq	r2,r2,zero
 d004978:	103cb326 	beq	r2,zero,d003c48 <___vfprintf_internal_r+0x710>
 d00497c:	d9014117 	ldw	r4,1284(sp)
 d004980:	94800044 	addi	r18,r18,1
 d004984:	8c400044 	addi	r17,r17,1
 d004988:	008001c4 	movi	r2,7
 d00498c:	a9000015 	stw	r4,0(r21)
 d004990:	a8c00115 	stw	r3,4(r21)
 d004994:	dc800e15 	stw	r18,56(sp)
 d004998:	dc400d15 	stw	r17,52(sp)
 d00499c:	147e6016 	blt	r2,r17,d004320 <___vfprintf_internal_r+0xde8>
 d0049a0:	acc00204 	addi	r19,r21,8
 d0049a4:	003cd106 	br	d003cec <___vfprintf_internal_r+0x7b4>
 d0049a8:	07034174 	movhi	fp,3333
 d0049ac:	e738c784 	addi	fp,fp,-7394
 d0049b0:	003c4906 	br	d003ad8 <___vfprintf_internal_r+0x5a0>
 d0049b4:	dd000f04 	addi	r20,sp,60
 d0049b8:	dc801904 	addi	r18,sp,100
 d0049bc:	8009883a 	mov	r4,r16
 d0049c0:	880b883a 	mov	r5,r17
 d0049c4:	01800284 	movi	r6,10
 d0049c8:	000f883a 	mov	r7,zero
 d0049cc:	d00b0440 	call	d00b044 <__umoddi3>
 d0049d0:	12000c04 	addi	r8,r2,48
 d0049d4:	94bfffc4 	addi	r18,r18,-1
 d0049d8:	8009883a 	mov	r4,r16
 d0049dc:	880b883a 	mov	r5,r17
 d0049e0:	01800284 	movi	r6,10
 d0049e4:	000f883a 	mov	r7,zero
 d0049e8:	92000005 	stb	r8,0(r18)
 d0049ec:	d00a9d80 	call	d00a9d8 <__udivdi3>
 d0049f0:	1009883a 	mov	r4,r2
 d0049f4:	1021883a 	mov	r16,r2
 d0049f8:	18800068 	cmpgeui	r2,r3,1
 d0049fc:	1823883a 	mov	r17,r3
 d004a00:	103fee1e 	bne	r2,zero,d0049bc <___vfprintf_internal_r+0x1484>
 d004a04:	1800021e 	bne	r3,zero,d004a10 <___vfprintf_internal_r+0x14d8>
 d004a08:	00800244 	movi	r2,9
 d004a0c:	113feb36 	bltu	r2,r4,d0049bc <___vfprintf_internal_r+0x1484>
 d004a10:	94bfffc4 	addi	r18,r18,-1
 d004a14:	dc814115 	stw	r18,1284(sp)
 d004a18:	003fc006 	br	d00491c <___vfprintf_internal_r+0x13e4>
 d004a1c:	d9014c17 	ldw	r4,1328(sp)
 d004a20:	2080004c 	andi	r2,r4,1
 d004a24:	10009a1e 	bne	r2,zero,d004c90 <___vfprintf_internal_r+0x1758>
 d004a28:	d9401904 	addi	r5,sp,100
 d004a2c:	dd000f04 	addi	r20,sp,60
 d004a30:	d9414115 	stw	r5,1284(sp)
 d004a34:	003d5b06 	br	d003fa4 <___vfprintf_internal_r+0xa6c>
 d004a38:	d9014f17 	ldw	r4,1340(sp)
 d004a3c:	b00b883a 	mov	r5,r22
 d004a40:	d9800c04 	addi	r6,sp,48
 d004a44:	d0034e00 	call	d0034e0 <__sprint_r>
 d004a48:	103c731e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004a4c:	dc800e17 	ldw	r18,56(sp)
 d004a50:	d8c01904 	addi	r3,sp,100
 d004a54:	003cf906 	br	d003e3c <___vfprintf_internal_r+0x904>
 d004a58:	d8c14c17 	ldw	r3,1328(sp)
 d004a5c:	1880040c 	andi	r2,r3,16
 d004a60:	1000711e 	bne	r2,zero,d004c28 <___vfprintf_internal_r+0x16f0>
 d004a64:	d9014c17 	ldw	r4,1328(sp)
 d004a68:	2080100c 	andi	r2,r4,64
 d004a6c:	10006e26 	beq	r2,zero,d004c28 <___vfprintf_internal_r+0x16f0>
 d004a70:	3c00000b 	ldhu	r16,0(r7)
 d004a74:	0023883a 	mov	r17,zero
 d004a78:	39c00104 	addi	r7,r7,4
 d004a7c:	d9c14015 	stw	r7,1280(sp)
 d004a80:	003efa06 	br	d00466c <___vfprintf_internal_r+0x1134>
 d004a84:	dc400d17 	ldw	r17,52(sp)
 d004a88:	07034174 	movhi	fp,3333
 d004a8c:	e738c784 	addi	fp,fp,-7394
 d004a90:	9425883a 	add	r18,r18,r16
 d004a94:	8c400044 	addi	r17,r17,1
 d004a98:	008001c4 	movi	r2,7
 d004a9c:	1f000015 	stw	fp,0(r3)
 d004aa0:	1c000115 	stw	r16,4(r3)
 d004aa4:	dc800e15 	stw	r18,56(sp)
 d004aa8:	dc400d15 	stw	r17,52(sp)
 d004aac:	147d7016 	blt	r2,r17,d004070 <___vfprintf_internal_r+0xb38>
 d004ab0:	18c00204 	addi	r3,r3,8
 d004ab4:	003d7506 	br	d00408c <___vfprintf_internal_r+0xb54>
 d004ab8:	dc800e17 	ldw	r18,56(sp)
 d004abc:	dc400d17 	ldw	r17,52(sp)
 d004ac0:	07034174 	movhi	fp,3333
 d004ac4:	e738cb84 	addi	fp,fp,-7378
 d004ac8:	003bba06 	br	d0039b4 <___vfprintf_internal_r+0x47c>
 d004acc:	d9014f17 	ldw	r4,1340(sp)
 d004ad0:	b00b883a 	mov	r5,r22
 d004ad4:	d9800c04 	addi	r6,sp,48
 d004ad8:	d0034e00 	call	d0034e0 <__sprint_r>
 d004adc:	103c4e1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004ae0:	dc800e17 	ldw	r18,56(sp)
 d004ae4:	d8c01904 	addi	r3,sp,100
 d004ae8:	003ce306 	br	d003e78 <___vfprintf_internal_r+0x940>
 d004aec:	3c000017 	ldw	r16,0(r7)
 d004af0:	0009883a 	mov	r4,zero
 d004af4:	39c00104 	addi	r7,r7,4
 d004af8:	0023883a 	mov	r17,zero
 d004afc:	d9c14015 	stw	r7,1280(sp)
 d004b00:	d8000405 	stb	zero,16(sp)
 d004b04:	003d1a06 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d004b08:	38800017 	ldw	r2,0(r7)
 d004b0c:	39c00104 	addi	r7,r7,4
 d004b10:	d9c14015 	stw	r7,1280(sp)
 d004b14:	1023d7fa 	srai	r17,r2,31
 d004b18:	1021883a 	mov	r16,r2
 d004b1c:	003d1206 	br	d003f68 <___vfprintf_internal_r+0xa30>
 d004b20:	3c000017 	ldw	r16,0(r7)
 d004b24:	01000044 	movi	r4,1
 d004b28:	39c00104 	addi	r7,r7,4
 d004b2c:	0023883a 	mov	r17,zero
 d004b30:	d9c14015 	stw	r7,1280(sp)
 d004b34:	d8000405 	stb	zero,16(sp)
 d004b38:	003d0d06 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d004b3c:	00834174 	movhi	r2,3333
 d004b40:	10b8c704 	addi	r2,r2,-7396
 d004b44:	94800044 	addi	r18,r18,1
 d004b48:	8c400044 	addi	r17,r17,1
 d004b4c:	a8800015 	stw	r2,0(r21)
 d004b50:	00c00044 	movi	r3,1
 d004b54:	008001c4 	movi	r2,7
 d004b58:	a8c00115 	stw	r3,4(r21)
 d004b5c:	dc800e15 	stw	r18,56(sp)
 d004b60:	dc400d15 	stw	r17,52(sp)
 d004b64:	1440ca16 	blt	r2,r17,d004e90 <___vfprintf_internal_r+0x1958>
 d004b68:	a8c00204 	addi	r3,r21,8
 d004b6c:	2000061e 	bne	r4,zero,d004b88 <___vfprintf_internal_r+0x1650>
 d004b70:	d9414717 	ldw	r5,1308(sp)
 d004b74:	2800041e 	bne	r5,zero,d004b88 <___vfprintf_internal_r+0x1650>
 d004b78:	d9814c17 	ldw	r6,1328(sp)
 d004b7c:	3080004c 	andi	r2,r6,1
 d004b80:	1005003a 	cmpeq	r2,r2,zero
 d004b84:	103bea1e 	bne	r2,zero,d003b30 <___vfprintf_internal_r+0x5f8>
 d004b88:	00800044 	movi	r2,1
 d004b8c:	dc400d17 	ldw	r17,52(sp)
 d004b90:	18800115 	stw	r2,4(r3)
 d004b94:	d8814917 	ldw	r2,1316(sp)
 d004b98:	94800044 	addi	r18,r18,1
 d004b9c:	8c400044 	addi	r17,r17,1
 d004ba0:	18800015 	stw	r2,0(r3)
 d004ba4:	008001c4 	movi	r2,7
 d004ba8:	dc800e15 	stw	r18,56(sp)
 d004bac:	dc400d15 	stw	r17,52(sp)
 d004bb0:	1440ca16 	blt	r2,r17,d004edc <___vfprintf_internal_r+0x19a4>
 d004bb4:	18c00204 	addi	r3,r3,8
 d004bb8:	0121c83a 	sub	r16,zero,r4
 d004bbc:	0400500e 	bge	zero,r16,d004d00 <___vfprintf_internal_r+0x17c8>
 d004bc0:	00800404 	movi	r2,16
 d004bc4:	1400800e 	bge	r2,r16,d004dc8 <___vfprintf_internal_r+0x1890>
 d004bc8:	1027883a 	mov	r19,r2
 d004bcc:	07034174 	movhi	fp,3333
 d004bd0:	e738c784 	addi	fp,fp,-7394
 d004bd4:	050001c4 	movi	r20,7
 d004bd8:	00000306 	br	d004be8 <___vfprintf_internal_r+0x16b0>
 d004bdc:	18c00204 	addi	r3,r3,8
 d004be0:	843ffc04 	addi	r16,r16,-16
 d004be4:	9c007a0e 	bge	r19,r16,d004dd0 <___vfprintf_internal_r+0x1898>
 d004be8:	94800404 	addi	r18,r18,16
 d004bec:	8c400044 	addi	r17,r17,1
 d004bf0:	1f000015 	stw	fp,0(r3)
 d004bf4:	1cc00115 	stw	r19,4(r3)
 d004bf8:	dc800e15 	stw	r18,56(sp)
 d004bfc:	dc400d15 	stw	r17,52(sp)
 d004c00:	a47ff60e 	bge	r20,r17,d004bdc <___vfprintf_internal_r+0x16a4>
 d004c04:	d9014f17 	ldw	r4,1340(sp)
 d004c08:	b00b883a 	mov	r5,r22
 d004c0c:	d9800c04 	addi	r6,sp,48
 d004c10:	d0034e00 	call	d0034e0 <__sprint_r>
 d004c14:	103c001e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004c18:	dc800e17 	ldw	r18,56(sp)
 d004c1c:	dc400d17 	ldw	r17,52(sp)
 d004c20:	d8c01904 	addi	r3,sp,100
 d004c24:	003fee06 	br	d004be0 <___vfprintf_internal_r+0x16a8>
 d004c28:	3c000017 	ldw	r16,0(r7)
 d004c2c:	0023883a 	mov	r17,zero
 d004c30:	39c00104 	addi	r7,r7,4
 d004c34:	d9c14015 	stw	r7,1280(sp)
 d004c38:	003e8c06 	br	d00466c <___vfprintf_internal_r+0x1134>
 d004c3c:	d9401904 	addi	r5,sp,100
 d004c40:	dd000f04 	addi	r20,sp,60
 d004c44:	d9414115 	stw	r5,1284(sp)
 d004c48:	d9814417 	ldw	r6,1296(sp)
 d004c4c:	880a973a 	slli	r5,r17,28
 d004c50:	8004d13a 	srli	r2,r16,4
 d004c54:	810003cc 	andi	r4,r16,15
 d004c58:	3109883a 	add	r4,r6,r4
 d004c5c:	2884b03a 	or	r2,r5,r2
 d004c60:	21400003 	ldbu	r5,0(r4)
 d004c64:	d9014117 	ldw	r4,1284(sp)
 d004c68:	8806d13a 	srli	r3,r17,4
 d004c6c:	1021883a 	mov	r16,r2
 d004c70:	213fffc4 	addi	r4,r4,-1
 d004c74:	d9014115 	stw	r4,1284(sp)
 d004c78:	d9814117 	ldw	r6,1284(sp)
 d004c7c:	10c8b03a 	or	r4,r2,r3
 d004c80:	1823883a 	mov	r17,r3
 d004c84:	31400005 	stb	r5,0(r6)
 d004c88:	203fef1e 	bne	r4,zero,d004c48 <___vfprintf_internal_r+0x1710>
 d004c8c:	003cc506 	br	d003fa4 <___vfprintf_internal_r+0xa6c>
 d004c90:	00800c04 	movi	r2,48
 d004c94:	d98018c4 	addi	r6,sp,99
 d004c98:	dd000f04 	addi	r20,sp,60
 d004c9c:	d88018c5 	stb	r2,99(sp)
 d004ca0:	d9814115 	stw	r6,1284(sp)
 d004ca4:	003cbf06 	br	d003fa4 <___vfprintf_internal_r+0xa6c>
 d004ca8:	dc400d17 	ldw	r17,52(sp)
 d004cac:	07034174 	movhi	fp,3333
 d004cb0:	e738cb84 	addi	fp,fp,-7378
 d004cb4:	003bc106 	br	d003bbc <___vfprintf_internal_r+0x684>
 d004cb8:	d9414c17 	ldw	r5,1328(sp)
 d004cbc:	2880040c 	andi	r2,r5,16
 d004cc0:	10007c26 	beq	r2,zero,d004eb4 <___vfprintf_internal_r+0x197c>
 d004cc4:	38800017 	ldw	r2,0(r7)
 d004cc8:	39c00104 	addi	r7,r7,4
 d004ccc:	d9c14015 	stw	r7,1280(sp)
 d004cd0:	d9814b17 	ldw	r6,1324(sp)
 d004cd4:	d9c14017 	ldw	r7,1280(sp)
 d004cd8:	11800015 	stw	r6,0(r2)
 d004cdc:	003a7206 	br	d0036a8 <___vfprintf_internal_r+0x170>
 d004ce0:	d9014f17 	ldw	r4,1340(sp)
 d004ce4:	b00b883a 	mov	r5,r22
 d004ce8:	d9800c04 	addi	r6,sp,48
 d004cec:	d0034e00 	call	d0034e0 <__sprint_r>
 d004cf0:	103bc91e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004cf4:	dc800e17 	ldw	r18,56(sp)
 d004cf8:	dc400d17 	ldw	r17,52(sp)
 d004cfc:	d8c01904 	addi	r3,sp,100
 d004d00:	d9014717 	ldw	r4,1308(sp)
 d004d04:	d9414117 	ldw	r5,1284(sp)
 d004d08:	8c400044 	addi	r17,r17,1
 d004d0c:	9125883a 	add	r18,r18,r4
 d004d10:	008001c4 	movi	r2,7
 d004d14:	19400015 	stw	r5,0(r3)
 d004d18:	19000115 	stw	r4,4(r3)
 d004d1c:	dc800e15 	stw	r18,56(sp)
 d004d20:	dc400d15 	stw	r17,52(sp)
 d004d24:	147ce816 	blt	r2,r17,d0040c8 <___vfprintf_internal_r+0xb90>
 d004d28:	18c00204 	addi	r3,r3,8
 d004d2c:	003b8006 	br	d003b30 <___vfprintf_internal_r+0x5f8>
 d004d30:	38c00017 	ldw	r3,0(r7)
 d004d34:	39000204 	addi	r4,r7,8
 d004d38:	d9014015 	stw	r4,1280(sp)
 d004d3c:	d8c14215 	stw	r3,1288(sp)
 d004d40:	39c00117 	ldw	r7,4(r7)
 d004d44:	d9c14315 	stw	r7,1292(sp)
 d004d48:	003e1a06 	br	d0045b4 <___vfprintf_internal_r+0x107c>
 d004d4c:	0005883a 	mov	r2,zero
 d004d50:	1409c83a 	sub	r4,r2,r16
 d004d54:	1105803a 	cmpltu	r2,r2,r4
 d004d58:	044bc83a 	sub	r5,zero,r17
 d004d5c:	2885c83a 	sub	r2,r5,r2
 d004d60:	2021883a 	mov	r16,r4
 d004d64:	1023883a 	mov	r17,r2
 d004d68:	01000044 	movi	r4,1
 d004d6c:	00800b44 	movi	r2,45
 d004d70:	d8800405 	stb	r2,16(sp)
 d004d74:	003c7e06 	br	d003f70 <___vfprintf_internal_r+0xa38>
 d004d78:	d9014f17 	ldw	r4,1340(sp)
 d004d7c:	b00b883a 	mov	r5,r22
 d004d80:	d9800c04 	addi	r6,sp,48
 d004d84:	d0034e00 	call	d0034e0 <__sprint_r>
 d004d88:	103ba31e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004d8c:	dc800e17 	ldw	r18,56(sp)
 d004d90:	dc400d17 	ldw	r17,52(sp)
 d004d94:	d9000517 	ldw	r4,20(sp)
 d004d98:	d9401904 	addi	r5,sp,100
 d004d9c:	003da106 	br	d004424 <___vfprintf_internal_r+0xeec>
 d004da0:	d9014f17 	ldw	r4,1340(sp)
 d004da4:	b00b883a 	mov	r5,r22
 d004da8:	d9800c04 	addi	r6,sp,48
 d004dac:	d0034e00 	call	d0034e0 <__sprint_r>
 d004db0:	103b991e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004db4:	dc800e17 	ldw	r18,56(sp)
 d004db8:	dc400d17 	ldw	r17,52(sp)
 d004dbc:	d9000517 	ldw	r4,20(sp)
 d004dc0:	d8c01904 	addi	r3,sp,100
 d004dc4:	003d8b06 	br	d0043f4 <___vfprintf_internal_r+0xebc>
 d004dc8:	07034174 	movhi	fp,3333
 d004dcc:	e738c784 	addi	fp,fp,-7394
 d004dd0:	9425883a 	add	r18,r18,r16
 d004dd4:	8c400044 	addi	r17,r17,1
 d004dd8:	008001c4 	movi	r2,7
 d004ddc:	1f000015 	stw	fp,0(r3)
 d004de0:	1c000115 	stw	r16,4(r3)
 d004de4:	dc800e15 	stw	r18,56(sp)
 d004de8:	dc400d15 	stw	r17,52(sp)
 d004dec:	147fbc16 	blt	r2,r17,d004ce0 <___vfprintf_internal_r+0x17a8>
 d004df0:	18c00204 	addi	r3,r3,8
 d004df4:	003fc206 	br	d004d00 <___vfprintf_internal_r+0x17c8>
 d004df8:	d9014f17 	ldw	r4,1340(sp)
 d004dfc:	b00b883a 	mov	r5,r22
 d004e00:	d9800c04 	addi	r6,sp,48
 d004e04:	d0034e00 	call	d0034e0 <__sprint_r>
 d004e08:	103b831e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004e0c:	dc800e17 	ldw	r18,56(sp)
 d004e10:	d9000517 	ldw	r4,20(sp)
 d004e14:	d8c01904 	addi	r3,sp,100
 d004e18:	003cfc06 	br	d00420c <___vfprintf_internal_r+0xcd4>
 d004e1c:	07034174 	movhi	fp,3333
 d004e20:	e738c784 	addi	fp,fp,-7394
 d004e24:	003bde06 	br	d003da0 <___vfprintf_internal_r+0x868>
 d004e28:	00834174 	movhi	r2,3333
 d004e2c:	10b8b604 	addi	r2,r2,-7464
 d004e30:	d8814115 	stw	r2,1284(sp)
 d004e34:	003def06 	br	d0045f4 <___vfprintf_internal_r+0x10bc>
 d004e38:	d9014217 	ldw	r4,1288(sp)
 d004e3c:	d9414317 	ldw	r5,1292(sp)
 d004e40:	d00a2880 	call	d00a288 <__isnand>
 d004e44:	10003926 	beq	r2,zero,d004f2c <___vfprintf_internal_r+0x19f4>
 d004e48:	d9414d17 	ldw	r5,1332(sp)
 d004e4c:	008011c4 	movi	r2,71
 d004e50:	1140ce16 	blt	r2,r5,d00518c <___vfprintf_internal_r+0x1c54>
 d004e54:	01834174 	movhi	r6,3333
 d004e58:	31b8b704 	addi	r6,r6,-7460
 d004e5c:	d9814115 	stw	r6,1284(sp)
 d004e60:	003de406 	br	d0045f4 <___vfprintf_internal_r+0x10bc>
 d004e64:	d9014c17 	ldw	r4,1328(sp)
 d004e68:	bdc00044 	addi	r23,r23,1
 d004e6c:	b8c00007 	ldb	r3,0(r23)
 d004e70:	21000814 	ori	r4,r4,32
 d004e74:	d9014c15 	stw	r4,1328(sp)
 d004e78:	003a2e06 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d004e7c:	dcc14515 	stw	r19,1300(sp)
 d004e80:	98011016 	blt	r19,zero,d0052c4 <___vfprintf_internal_r+0x1d8c>
 d004e84:	980f883a 	mov	r7,r19
 d004e88:	d8014615 	stw	zero,1304(sp)
 d004e8c:	003c4c06 	br	d003fc0 <___vfprintf_internal_r+0xa88>
 d004e90:	d9014f17 	ldw	r4,1340(sp)
 d004e94:	b00b883a 	mov	r5,r22
 d004e98:	d9800c04 	addi	r6,sp,48
 d004e9c:	d0034e00 	call	d0034e0 <__sprint_r>
 d004ea0:	103b5d1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004ea4:	dc800e17 	ldw	r18,56(sp)
 d004ea8:	d9000517 	ldw	r4,20(sp)
 d004eac:	d8c01904 	addi	r3,sp,100
 d004eb0:	003f2e06 	br	d004b6c <___vfprintf_internal_r+0x1634>
 d004eb4:	d8c14c17 	ldw	r3,1328(sp)
 d004eb8:	1880100c 	andi	r2,r3,64
 d004ebc:	1000a026 	beq	r2,zero,d005140 <___vfprintf_internal_r+0x1c08>
 d004ec0:	38800017 	ldw	r2,0(r7)
 d004ec4:	39c00104 	addi	r7,r7,4
 d004ec8:	d9c14015 	stw	r7,1280(sp)
 d004ecc:	d9014b17 	ldw	r4,1324(sp)
 d004ed0:	d9c14017 	ldw	r7,1280(sp)
 d004ed4:	1100000d 	sth	r4,0(r2)
 d004ed8:	0039f306 	br	d0036a8 <___vfprintf_internal_r+0x170>
 d004edc:	d9014f17 	ldw	r4,1340(sp)
 d004ee0:	b00b883a 	mov	r5,r22
 d004ee4:	d9800c04 	addi	r6,sp,48
 d004ee8:	d0034e00 	call	d0034e0 <__sprint_r>
 d004eec:	103b4a1e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d004ef0:	dc800e17 	ldw	r18,56(sp)
 d004ef4:	dc400d17 	ldw	r17,52(sp)
 d004ef8:	d9000517 	ldw	r4,20(sp)
 d004efc:	d8c01904 	addi	r3,sp,100
 d004f00:	003f2d06 	br	d004bb8 <___vfprintf_internal_r+0x1680>
 d004f04:	00800184 	movi	r2,6
 d004f08:	14c09a36 	bltu	r2,r19,d005174 <___vfprintf_internal_r+0x1c3c>
 d004f0c:	dcc14515 	stw	r19,1300(sp)
 d004f10:	9800010e 	bge	r19,zero,d004f18 <___vfprintf_internal_r+0x19e0>
 d004f14:	d8014515 	stw	zero,1300(sp)
 d004f18:	00834174 	movhi	r2,3333
 d004f1c:	10b8b904 	addi	r2,r2,-7452
 d004f20:	980f883a 	mov	r7,r19
 d004f24:	d8814115 	stw	r2,1284(sp)
 d004f28:	003a7206 	br	d0038f4 <___vfprintf_internal_r+0x3bc>
 d004f2c:	00bfffc4 	movi	r2,-1
 d004f30:	9880e226 	beq	r19,r2,d0052bc <___vfprintf_internal_r+0x1d84>
 d004f34:	d9414d17 	ldw	r5,1332(sp)
 d004f38:	008019c4 	movi	r2,103
 d004f3c:	2880dc26 	beq	r5,r2,d0052b0 <___vfprintf_internal_r+0x1d78>
 d004f40:	008011c4 	movi	r2,71
 d004f44:	2880da26 	beq	r5,r2,d0052b0 <___vfprintf_internal_r+0x1d78>
 d004f48:	d9414c17 	ldw	r5,1328(sp)
 d004f4c:	d9014317 	ldw	r4,1292(sp)
 d004f50:	d9814217 	ldw	r6,1288(sp)
 d004f54:	29404014 	ori	r5,r5,256
 d004f58:	d9414c15 	stw	r5,1328(sp)
 d004f5c:	2000cc16 	blt	r4,zero,d005290 <___vfprintf_internal_r+0x1d58>
 d004f60:	3021883a 	mov	r16,r6
 d004f64:	2023883a 	mov	r17,r4
 d004f68:	0039883a 	mov	fp,zero
 d004f6c:	d9414d17 	ldw	r5,1332(sp)
 d004f70:	00801984 	movi	r2,102
 d004f74:	2880b726 	beq	r5,r2,d005254 <___vfprintf_internal_r+0x1d1c>
 d004f78:	00801184 	movi	r2,70
 d004f7c:	2880b526 	beq	r5,r2,d005254 <___vfprintf_internal_r+0x1d1c>
 d004f80:	00801944 	movi	r2,101
 d004f84:	2880c826 	beq	r5,r2,d0052a8 <___vfprintf_internal_r+0x1d70>
 d004f88:	00801144 	movi	r2,69
 d004f8c:	2880c626 	beq	r5,r2,d0052a8 <___vfprintf_internal_r+0x1d70>
 d004f90:	9829883a 	mov	r20,r19
 d004f94:	d9014f17 	ldw	r4,1340(sp)
 d004f98:	d8800504 	addi	r2,sp,20
 d004f9c:	880d883a 	mov	r6,r17
 d004fa0:	d8800115 	stw	r2,4(sp)
 d004fa4:	d8c00604 	addi	r3,sp,24
 d004fa8:	d8800704 	addi	r2,sp,28
 d004fac:	800b883a 	mov	r5,r16
 d004fb0:	01c00084 	movi	r7,2
 d004fb4:	d8c00215 	stw	r3,8(sp)
 d004fb8:	d8800315 	stw	r2,12(sp)
 d004fbc:	dd000015 	stw	r20,0(sp)
 d004fc0:	d0058ec0 	call	d0058ec <_dtoa_r>
 d004fc4:	d9814d17 	ldw	r6,1332(sp)
 d004fc8:	d8814115 	stw	r2,1284(sp)
 d004fcc:	008019c4 	movi	r2,103
 d004fd0:	30809526 	beq	r6,r2,d005228 <___vfprintf_internal_r+0x1cf0>
 d004fd4:	d8c14d17 	ldw	r3,1332(sp)
 d004fd8:	008011c4 	movi	r2,71
 d004fdc:	18809226 	beq	r3,r2,d005228 <___vfprintf_internal_r+0x1cf0>
 d004fe0:	d9414117 	ldw	r5,1284(sp)
 d004fe4:	d9814d17 	ldw	r6,1332(sp)
 d004fe8:	00801984 	movi	r2,102
 d004fec:	2d25883a 	add	r18,r5,r20
 d004ff0:	30808626 	beq	r6,r2,d00520c <___vfprintf_internal_r+0x1cd4>
 d004ff4:	00801184 	movi	r2,70
 d004ff8:	30808426 	beq	r6,r2,d00520c <___vfprintf_internal_r+0x1cd4>
 d004ffc:	000d883a 	mov	r6,zero
 d005000:	000f883a 	mov	r7,zero
 d005004:	880b883a 	mov	r5,r17
 d005008:	8009883a 	mov	r4,r16
 d00500c:	d00c1c40 	call	d00c1c4 <__eqdf2>
 d005010:	1000751e 	bne	r2,zero,d0051e8 <___vfprintf_internal_r+0x1cb0>
 d005014:	9005883a 	mov	r2,r18
 d005018:	dc800715 	stw	r18,28(sp)
 d00501c:	d9014117 	ldw	r4,1284(sp)
 d005020:	d9414d17 	ldw	r5,1332(sp)
 d005024:	00c019c4 	movi	r3,103
 d005028:	1125c83a 	sub	r18,r2,r4
 d00502c:	28c06826 	beq	r5,r3,d0051d0 <___vfprintf_internal_r+0x1c98>
 d005030:	008011c4 	movi	r2,71
 d005034:	28806626 	beq	r5,r2,d0051d0 <___vfprintf_internal_r+0x1c98>
 d005038:	d9000517 	ldw	r4,20(sp)
 d00503c:	d8c14d17 	ldw	r3,1332(sp)
 d005040:	00801944 	movi	r2,101
 d005044:	10c05516 	blt	r2,r3,d00519c <___vfprintf_internal_r+0x1c64>
 d005048:	213fffc4 	addi	r4,r4,-1
 d00504c:	d9000515 	stw	r4,20(sp)
 d005050:	d8c00805 	stb	r3,32(sp)
 d005054:	2021883a 	mov	r16,r4
 d005058:	2000c116 	blt	r4,zero,d005360 <___vfprintf_internal_r+0x1e28>
 d00505c:	00800ac4 	movi	r2,43
 d005060:	d8800845 	stb	r2,33(sp)
 d005064:	00800244 	movi	r2,9
 d005068:	1400af0e 	bge	r2,r16,d005328 <___vfprintf_internal_r+0x1df0>
 d00506c:	1027883a 	mov	r19,r2
 d005070:	dc400b84 	addi	r17,sp,46
 d005074:	8009883a 	mov	r4,r16
 d005078:	01400284 	movi	r5,10
 d00507c:	d00c8ac0 	call	d00c8ac <__modsi3>
 d005080:	10800c04 	addi	r2,r2,48
 d005084:	8c7fffc4 	addi	r17,r17,-1
 d005088:	8009883a 	mov	r4,r16
 d00508c:	01400284 	movi	r5,10
 d005090:	88800005 	stb	r2,0(r17)
 d005094:	d00c84c0 	call	d00c84c <__divsi3>
 d005098:	1021883a 	mov	r16,r2
 d00509c:	98bff516 	blt	r19,r2,d005074 <___vfprintf_internal_r+0x1b3c>
 d0050a0:	10c00c04 	addi	r3,r2,48
 d0050a4:	d88009c4 	addi	r2,sp,39
 d0050a8:	108001c4 	addi	r2,r2,7
 d0050ac:	897fffc4 	addi	r5,r17,-1
 d0050b0:	88ffffc5 	stb	r3,-1(r17)
 d0050b4:	2880a72e 	bgeu	r5,r2,d005354 <___vfprintf_internal_r+0x1e1c>
 d0050b8:	1009883a 	mov	r4,r2
 d0050bc:	d9800804 	addi	r6,sp,32
 d0050c0:	d8c00884 	addi	r3,sp,34
 d0050c4:	28800003 	ldbu	r2,0(r5)
 d0050c8:	29400044 	addi	r5,r5,1
 d0050cc:	18800005 	stb	r2,0(r3)
 d0050d0:	18c00044 	addi	r3,r3,1
 d0050d4:	293ffb36 	bltu	r5,r4,d0050c4 <___vfprintf_internal_r+0x1b8c>
 d0050d8:	1987c83a 	sub	r3,r3,r6
 d0050dc:	00800044 	movi	r2,1
 d0050e0:	d8c14815 	stw	r3,1312(sp)
 d0050e4:	90cf883a 	add	r7,r18,r3
 d0050e8:	1480960e 	bge	r2,r18,d005344 <___vfprintf_internal_r+0x1e0c>
 d0050ec:	39c00044 	addi	r7,r7,1
 d0050f0:	d9c14515 	stw	r7,1300(sp)
 d0050f4:	38003416 	blt	r7,zero,d0051c8 <___vfprintf_internal_r+0x1c90>
 d0050f8:	e0803fcc 	andi	r2,fp,255
 d0050fc:	1080201c 	xori	r2,r2,128
 d005100:	10bfe004 	addi	r2,r2,-128
 d005104:	10004e26 	beq	r2,zero,d005240 <___vfprintf_internal_r+0x1d08>
 d005108:	00800b44 	movi	r2,45
 d00510c:	dc814715 	stw	r18,1308(sp)
 d005110:	d8014615 	stw	zero,1304(sp)
 d005114:	d8800405 	stb	r2,16(sp)
 d005118:	003bab06 	br	d003fc8 <___vfprintf_internal_r+0xa90>
 d00511c:	00800b44 	movi	r2,45
 d005120:	d8800405 	stb	r2,16(sp)
 d005124:	003d2d06 	br	d0045dc <___vfprintf_internal_r+0x10a4>
 d005128:	d9014f17 	ldw	r4,1340(sp)
 d00512c:	b00b883a 	mov	r5,r22
 d005130:	d9800c04 	addi	r6,sp,48
 d005134:	d0034e00 	call	d0034e0 <__sprint_r>
 d005138:	103ab71e 	bne	r2,zero,d003c18 <___vfprintf_internal_r+0x6e0>
 d00513c:	003ab506 	br	d003c14 <___vfprintf_internal_r+0x6dc>
 d005140:	38800017 	ldw	r2,0(r7)
 d005144:	39c00104 	addi	r7,r7,4
 d005148:	d9c14015 	stw	r7,1280(sp)
 d00514c:	d9414b17 	ldw	r5,1324(sp)
 d005150:	d9c14017 	ldw	r7,1280(sp)
 d005154:	11400015 	stw	r5,0(r2)
 d005158:	00395306 	br	d0036a8 <___vfprintf_internal_r+0x170>
 d00515c:	980f883a 	mov	r7,r19
 d005160:	dcc14515 	stw	r19,1300(sp)
 d005164:	d8014615 	stw	zero,1304(sp)
 d005168:	003b9506 	br	d003fc0 <___vfprintf_internal_r+0xa88>
 d00516c:	0027883a 	mov	r19,zero
 d005170:	00397206 	br	d00373c <___vfprintf_internal_r+0x204>
 d005174:	00c34174 	movhi	r3,3333
 d005178:	18f8b904 	addi	r3,r3,-7452
 d00517c:	100f883a 	mov	r7,r2
 d005180:	d8814515 	stw	r2,1300(sp)
 d005184:	d8c14115 	stw	r3,1284(sp)
 d005188:	0039da06 	br	d0038f4 <___vfprintf_internal_r+0x3bc>
 d00518c:	00834174 	movhi	r2,3333
 d005190:	10b8b804 	addi	r2,r2,-7456
 d005194:	d8814115 	stw	r2,1284(sp)
 d005198:	003d1606 	br	d0045f4 <___vfprintf_internal_r+0x10bc>
 d00519c:	d9414d17 	ldw	r5,1332(sp)
 d0051a0:	00801984 	movi	r2,102
 d0051a4:	28804926 	beq	r5,r2,d0052cc <___vfprintf_internal_r+0x1d94>
 d0051a8:	200f883a 	mov	r7,r4
 d0051ac:	24805716 	blt	r4,r18,d00530c <___vfprintf_internal_r+0x1dd4>
 d0051b0:	d9414c17 	ldw	r5,1328(sp)
 d0051b4:	2880004c 	andi	r2,r5,1
 d0051b8:	10000126 	beq	r2,zero,d0051c0 <___vfprintf_internal_r+0x1c88>
 d0051bc:	21c00044 	addi	r7,r4,1
 d0051c0:	d9c14515 	stw	r7,1300(sp)
 d0051c4:	383fcc0e 	bge	r7,zero,d0050f8 <___vfprintf_internal_r+0x1bc0>
 d0051c8:	d8014515 	stw	zero,1300(sp)
 d0051cc:	003fca06 	br	d0050f8 <___vfprintf_internal_r+0x1bc0>
 d0051d0:	d9000517 	ldw	r4,20(sp)
 d0051d4:	00bfff04 	movi	r2,-4
 d0051d8:	1100480e 	bge	r2,r4,d0052fc <___vfprintf_internal_r+0x1dc4>
 d0051dc:	99004716 	blt	r19,r4,d0052fc <___vfprintf_internal_r+0x1dc4>
 d0051e0:	d8c14d15 	stw	r3,1332(sp)
 d0051e4:	003ff006 	br	d0051a8 <___vfprintf_internal_r+0x1c70>
 d0051e8:	d8800717 	ldw	r2,28(sp)
 d0051ec:	14bf8b2e 	bgeu	r2,r18,d00501c <___vfprintf_internal_r+0x1ae4>
 d0051f0:	9007883a 	mov	r3,r18
 d0051f4:	01000c04 	movi	r4,48
 d0051f8:	11000005 	stb	r4,0(r2)
 d0051fc:	10800044 	addi	r2,r2,1
 d005200:	d8800715 	stw	r2,28(sp)
 d005204:	18bffc1e 	bne	r3,r2,d0051f8 <___vfprintf_internal_r+0x1cc0>
 d005208:	003f8406 	br	d00501c <___vfprintf_internal_r+0x1ae4>
 d00520c:	d8814117 	ldw	r2,1284(sp)
 d005210:	10c00007 	ldb	r3,0(r2)
 d005214:	00800c04 	movi	r2,48
 d005218:	18805b26 	beq	r3,r2,d005388 <___vfprintf_internal_r+0x1e50>
 d00521c:	d9000517 	ldw	r4,20(sp)
 d005220:	9125883a 	add	r18,r18,r4
 d005224:	003f7506 	br	d004ffc <___vfprintf_internal_r+0x1ac4>
 d005228:	d9014c17 	ldw	r4,1328(sp)
 d00522c:	2080004c 	andi	r2,r4,1
 d005230:	1005003a 	cmpeq	r2,r2,zero
 d005234:	103f6a26 	beq	r2,zero,d004fe0 <___vfprintf_internal_r+0x1aa8>
 d005238:	d8800717 	ldw	r2,28(sp)
 d00523c:	003f7706 	br	d00501c <___vfprintf_internal_r+0x1ae4>
 d005240:	d9c14515 	stw	r7,1300(sp)
 d005244:	38004d16 	blt	r7,zero,d00537c <___vfprintf_internal_r+0x1e44>
 d005248:	dc814715 	stw	r18,1308(sp)
 d00524c:	d8014615 	stw	zero,1304(sp)
 d005250:	003b5b06 	br	d003fc0 <___vfprintf_internal_r+0xa88>
 d005254:	d9014f17 	ldw	r4,1340(sp)
 d005258:	d8800504 	addi	r2,sp,20
 d00525c:	d8800115 	stw	r2,4(sp)
 d005260:	d8c00604 	addi	r3,sp,24
 d005264:	d8800704 	addi	r2,sp,28
 d005268:	800b883a 	mov	r5,r16
 d00526c:	880d883a 	mov	r6,r17
 d005270:	01c000c4 	movi	r7,3
 d005274:	d8c00215 	stw	r3,8(sp)
 d005278:	d8800315 	stw	r2,12(sp)
 d00527c:	dcc00015 	stw	r19,0(sp)
 d005280:	9829883a 	mov	r20,r19
 d005284:	d0058ec0 	call	d0058ec <_dtoa_r>
 d005288:	d8814115 	stw	r2,1284(sp)
 d00528c:	003f5106 	br	d004fd4 <___vfprintf_internal_r+0x1a9c>
 d005290:	d8c14217 	ldw	r3,1288(sp)
 d005294:	d9014317 	ldw	r4,1292(sp)
 d005298:	07000b44 	movi	fp,45
 d00529c:	1821883a 	mov	r16,r3
 d0052a0:	2460003c 	xorhi	r17,r4,32768
 d0052a4:	003f3106 	br	d004f6c <___vfprintf_internal_r+0x1a34>
 d0052a8:	9d000044 	addi	r20,r19,1
 d0052ac:	003f3906 	br	d004f94 <___vfprintf_internal_r+0x1a5c>
 d0052b0:	983f251e 	bne	r19,zero,d004f48 <___vfprintf_internal_r+0x1a10>
 d0052b4:	04c00044 	movi	r19,1
 d0052b8:	003f2306 	br	d004f48 <___vfprintf_internal_r+0x1a10>
 d0052bc:	04c00184 	movi	r19,6
 d0052c0:	003f2106 	br	d004f48 <___vfprintf_internal_r+0x1a10>
 d0052c4:	d8014515 	stw	zero,1300(sp)
 d0052c8:	003eee06 	br	d004e84 <___vfprintf_internal_r+0x194c>
 d0052cc:	200f883a 	mov	r7,r4
 d0052d0:	0100370e 	bge	zero,r4,d0053b0 <___vfprintf_internal_r+0x1e78>
 d0052d4:	9800031e 	bne	r19,zero,d0052e4 <___vfprintf_internal_r+0x1dac>
 d0052d8:	d9814c17 	ldw	r6,1328(sp)
 d0052dc:	3080004c 	andi	r2,r6,1
 d0052e0:	103fb726 	beq	r2,zero,d0051c0 <___vfprintf_internal_r+0x1c88>
 d0052e4:	20800044 	addi	r2,r4,1
 d0052e8:	98a7883a 	add	r19,r19,r2
 d0052ec:	dcc14515 	stw	r19,1300(sp)
 d0052f0:	980f883a 	mov	r7,r19
 d0052f4:	983f800e 	bge	r19,zero,d0050f8 <___vfprintf_internal_r+0x1bc0>
 d0052f8:	003fb306 	br	d0051c8 <___vfprintf_internal_r+0x1c90>
 d0052fc:	d9814d17 	ldw	r6,1332(sp)
 d005300:	31bfff84 	addi	r6,r6,-2
 d005304:	d9814d15 	stw	r6,1332(sp)
 d005308:	003f4c06 	br	d00503c <___vfprintf_internal_r+0x1b04>
 d00530c:	0100180e 	bge	zero,r4,d005370 <___vfprintf_internal_r+0x1e38>
 d005310:	00800044 	movi	r2,1
 d005314:	1485883a 	add	r2,r2,r18
 d005318:	d8814515 	stw	r2,1300(sp)
 d00531c:	100f883a 	mov	r7,r2
 d005320:	103f750e 	bge	r2,zero,d0050f8 <___vfprintf_internal_r+0x1bc0>
 d005324:	003fa806 	br	d0051c8 <___vfprintf_internal_r+0x1c90>
 d005328:	80c00c04 	addi	r3,r16,48
 d00532c:	00800c04 	movi	r2,48
 d005330:	d8c008c5 	stb	r3,35(sp)
 d005334:	d9800804 	addi	r6,sp,32
 d005338:	d8c00904 	addi	r3,sp,36
 d00533c:	d8800885 	stb	r2,34(sp)
 d005340:	003f6506 	br	d0050d8 <___vfprintf_internal_r+0x1ba0>
 d005344:	d9014c17 	ldw	r4,1328(sp)
 d005348:	2084703a 	and	r2,r4,r2
 d00534c:	103f9c26 	beq	r2,zero,d0051c0 <___vfprintf_internal_r+0x1c88>
 d005350:	003f6606 	br	d0050ec <___vfprintf_internal_r+0x1bb4>
 d005354:	d9800804 	addi	r6,sp,32
 d005358:	d8c00884 	addi	r3,sp,34
 d00535c:	003f5e06 	br	d0050d8 <___vfprintf_internal_r+0x1ba0>
 d005360:	00800b44 	movi	r2,45
 d005364:	0121c83a 	sub	r16,zero,r4
 d005368:	d8800845 	stb	r2,33(sp)
 d00536c:	003f3d06 	br	d005064 <___vfprintf_internal_r+0x1b2c>
 d005370:	00800084 	movi	r2,2
 d005374:	1105c83a 	sub	r2,r2,r4
 d005378:	003fe606 	br	d005314 <___vfprintf_internal_r+0x1ddc>
 d00537c:	d8014515 	stw	zero,1300(sp)
 d005380:	dc814715 	stw	r18,1308(sp)
 d005384:	003fb106 	br	d00524c <___vfprintf_internal_r+0x1d14>
 d005388:	000d883a 	mov	r6,zero
 d00538c:	000f883a 	mov	r7,zero
 d005390:	8009883a 	mov	r4,r16
 d005394:	880b883a 	mov	r5,r17
 d005398:	d00c24c0 	call	d00c24c <__nedf2>
 d00539c:	103f9f26 	beq	r2,zero,d00521c <___vfprintf_internal_r+0x1ce4>
 d0053a0:	00800044 	movi	r2,1
 d0053a4:	1509c83a 	sub	r4,r2,r20
 d0053a8:	d9000515 	stw	r4,20(sp)
 d0053ac:	003f9b06 	br	d00521c <___vfprintf_internal_r+0x1ce4>
 d0053b0:	98000d1e 	bne	r19,zero,d0053e8 <___vfprintf_internal_r+0x1eb0>
 d0053b4:	d8c14c17 	ldw	r3,1328(sp)
 d0053b8:	1880004c 	andi	r2,r3,1
 d0053bc:	10000a1e 	bne	r2,zero,d0053e8 <___vfprintf_internal_r+0x1eb0>
 d0053c0:	01000044 	movi	r4,1
 d0053c4:	200f883a 	mov	r7,r4
 d0053c8:	d9014515 	stw	r4,1300(sp)
 d0053cc:	003f4a06 	br	d0050f8 <___vfprintf_internal_r+0x1bc0>
 d0053d0:	3cc00017 	ldw	r19,0(r7)
 d0053d4:	39c00104 	addi	r7,r7,4
 d0053d8:	983d0e0e 	bge	r19,zero,d004814 <___vfprintf_internal_r+0x12dc>
 d0053dc:	b8c00007 	ldb	r3,0(r23)
 d0053e0:	04ffffc4 	movi	r19,-1
 d0053e4:	0038d306 	br	d003734 <___vfprintf_internal_r+0x1fc>
 d0053e8:	9cc00084 	addi	r19,r19,2
 d0053ec:	dcc14515 	stw	r19,1300(sp)
 d0053f0:	980f883a 	mov	r7,r19
 d0053f4:	983f400e 	bge	r19,zero,d0050f8 <___vfprintf_internal_r+0x1bc0>
 d0053f8:	003f7306 	br	d0051c8 <___vfprintf_internal_r+0x1c90>

0d0053fc <__vfprintf_internal>:
 d0053fc:	00834174 	movhi	r2,3333
 d005400:	10922004 	addi	r2,r2,18560
 d005404:	2013883a 	mov	r9,r4
 d005408:	11000017 	ldw	r4,0(r2)
 d00540c:	2805883a 	mov	r2,r5
 d005410:	300f883a 	mov	r7,r6
 d005414:	480b883a 	mov	r5,r9
 d005418:	100d883a 	mov	r6,r2
 d00541c:	d0035381 	jmpi	d003538 <___vfprintf_internal_r>

0d005420 <__swbuf_r>:
 d005420:	defffc04 	addi	sp,sp,-16
 d005424:	dc400215 	stw	r17,8(sp)
 d005428:	dc000115 	stw	r16,4(sp)
 d00542c:	dfc00315 	stw	ra,12(sp)
 d005430:	2023883a 	mov	r17,r4
 d005434:	2821883a 	mov	r16,r5
 d005438:	20000226 	beq	r4,zero,d005444 <__swbuf_r+0x24>
 d00543c:	20800e17 	ldw	r2,56(r4)
 d005440:	10002f26 	beq	r2,zero,d005500 <__swbuf_r+0xe0>
 d005444:	3080030b 	ldhu	r2,12(r6)
 d005448:	30c00617 	ldw	r3,24(r6)
 d00544c:	1080020c 	andi	r2,r2,8
 d005450:	30c00215 	stw	r3,8(r6)
 d005454:	10002226 	beq	r2,zero,d0054e0 <__swbuf_r+0xc0>
 d005458:	30c00417 	ldw	r3,16(r6)
 d00545c:	18002026 	beq	r3,zero,d0054e0 <__swbuf_r+0xc0>
 d005460:	31000017 	ldw	r4,0(r6)
 d005464:	30800517 	ldw	r2,20(r6)
 d005468:	20c7c83a 	sub	r3,r4,r3
 d00546c:	18802f0e 	bge	r3,r2,d00552c <__swbuf_r+0x10c>
 d005470:	19400044 	addi	r5,r3,1
 d005474:	30800217 	ldw	r2,8(r6)
 d005478:	84003fcc 	andi	r16,r16,255
 d00547c:	20c00044 	addi	r3,r4,1
 d005480:	10bfffc4 	addi	r2,r2,-1
 d005484:	30800215 	stw	r2,8(r6)
 d005488:	24000005 	stb	r16,0(r4)
 d00548c:	30800517 	ldw	r2,20(r6)
 d005490:	30c00015 	stw	r3,0(r6)
 d005494:	11400c26 	beq	r2,r5,d0054c8 <__swbuf_r+0xa8>
 d005498:	3080030b 	ldhu	r2,12(r6)
 d00549c:	1080004c 	andi	r2,r2,1
 d0054a0:	1005003a 	cmpeq	r2,r2,zero
 d0054a4:	10000626 	beq	r2,zero,d0054c0 <__swbuf_r+0xa0>
 d0054a8:	8005883a 	mov	r2,r16
 d0054ac:	dfc00317 	ldw	ra,12(sp)
 d0054b0:	dc400217 	ldw	r17,8(sp)
 d0054b4:	dc000117 	ldw	r16,4(sp)
 d0054b8:	dec00404 	addi	sp,sp,16
 d0054bc:	f800283a 	ret
 d0054c0:	00800284 	movi	r2,10
 d0054c4:	80bff81e 	bne	r16,r2,d0054a8 <__swbuf_r+0x88>
 d0054c8:	8809883a 	mov	r4,r17
 d0054cc:	300b883a 	mov	r5,r6
 d0054d0:	d006ea00 	call	d006ea0 <_fflush_r>
 d0054d4:	103ff426 	beq	r2,zero,d0054a8 <__swbuf_r+0x88>
 d0054d8:	043fffc4 	movi	r16,-1
 d0054dc:	003ff206 	br	d0054a8 <__swbuf_r+0x88>
 d0054e0:	300b883a 	mov	r5,r6
 d0054e4:	8809883a 	mov	r4,r17
 d0054e8:	d9800015 	stw	r6,0(sp)
 d0054ec:	d00556c0 	call	d00556c <__swsetup_r>
 d0054f0:	d9800017 	ldw	r6,0(sp)
 d0054f4:	1000061e 	bne	r2,zero,d005510 <__swbuf_r+0xf0>
 d0054f8:	30c00417 	ldw	r3,16(r6)
 d0054fc:	003fd806 	br	d005460 <__swbuf_r+0x40>
 d005500:	d9800015 	stw	r6,0(sp)
 d005504:	d0071380 	call	d007138 <__sinit>
 d005508:	d9800017 	ldw	r6,0(sp)
 d00550c:	003fcd06 	br	d005444 <__swbuf_r+0x24>
 d005510:	3080030b 	ldhu	r2,12(r6)
 d005514:	00c00244 	movi	r3,9
 d005518:	043fffc4 	movi	r16,-1
 d00551c:	10801014 	ori	r2,r2,64
 d005520:	3080030d 	sth	r2,12(r6)
 d005524:	88c00015 	stw	r3,0(r17)
 d005528:	003fdf06 	br	d0054a8 <__swbuf_r+0x88>
 d00552c:	300b883a 	mov	r5,r6
 d005530:	8809883a 	mov	r4,r17
 d005534:	d9800015 	stw	r6,0(sp)
 d005538:	d006ea00 	call	d006ea0 <_fflush_r>
 d00553c:	d9800017 	ldw	r6,0(sp)
 d005540:	103fe51e 	bne	r2,zero,d0054d8 <__swbuf_r+0xb8>
 d005544:	31000017 	ldw	r4,0(r6)
 d005548:	01400044 	movi	r5,1
 d00554c:	003fc906 	br	d005474 <__swbuf_r+0x54>

0d005550 <__swbuf>:
 d005550:	01834174 	movhi	r6,3333
 d005554:	31922004 	addi	r6,r6,18560
 d005558:	2007883a 	mov	r3,r4
 d00555c:	31000017 	ldw	r4,0(r6)
 d005560:	280d883a 	mov	r6,r5
 d005564:	180b883a 	mov	r5,r3
 d005568:	d0054201 	jmpi	d005420 <__swbuf_r>

0d00556c <__swsetup_r>:
 d00556c:	00834174 	movhi	r2,3333
 d005570:	10922004 	addi	r2,r2,18560
 d005574:	10c00017 	ldw	r3,0(r2)
 d005578:	defffd04 	addi	sp,sp,-12
 d00557c:	dc400115 	stw	r17,4(sp)
 d005580:	dc000015 	stw	r16,0(sp)
 d005584:	dfc00215 	stw	ra,8(sp)
 d005588:	2023883a 	mov	r17,r4
 d00558c:	2821883a 	mov	r16,r5
 d005590:	18000226 	beq	r3,zero,d00559c <__swsetup_r+0x30>
 d005594:	18800e17 	ldw	r2,56(r3)
 d005598:	10001f26 	beq	r2,zero,d005618 <__swsetup_r+0xac>
 d00559c:	8100030b 	ldhu	r4,12(r16)
 d0055a0:	2080020c 	andi	r2,r4,8
 d0055a4:	10002826 	beq	r2,zero,d005648 <__swsetup_r+0xdc>
 d0055a8:	81400417 	ldw	r5,16(r16)
 d0055ac:	28001d26 	beq	r5,zero,d005624 <__swsetup_r+0xb8>
 d0055b0:	2080004c 	andi	r2,r4,1
 d0055b4:	1005003a 	cmpeq	r2,r2,zero
 d0055b8:	10000b26 	beq	r2,zero,d0055e8 <__swsetup_r+0x7c>
 d0055bc:	2080008c 	andi	r2,r4,2
 d0055c0:	10001226 	beq	r2,zero,d00560c <__swsetup_r+0xa0>
 d0055c4:	0005883a 	mov	r2,zero
 d0055c8:	80800215 	stw	r2,8(r16)
 d0055cc:	28000b26 	beq	r5,zero,d0055fc <__swsetup_r+0x90>
 d0055d0:	0005883a 	mov	r2,zero
 d0055d4:	dfc00217 	ldw	ra,8(sp)
 d0055d8:	dc400117 	ldw	r17,4(sp)
 d0055dc:	dc000017 	ldw	r16,0(sp)
 d0055e0:	dec00304 	addi	sp,sp,12
 d0055e4:	f800283a 	ret
 d0055e8:	80800517 	ldw	r2,20(r16)
 d0055ec:	80000215 	stw	zero,8(r16)
 d0055f0:	0085c83a 	sub	r2,zero,r2
 d0055f4:	80800615 	stw	r2,24(r16)
 d0055f8:	283ff51e 	bne	r5,zero,d0055d0 <__swsetup_r+0x64>
 d0055fc:	2080200c 	andi	r2,r4,128
 d005600:	103ff326 	beq	r2,zero,d0055d0 <__swsetup_r+0x64>
 d005604:	00bfffc4 	movi	r2,-1
 d005608:	003ff206 	br	d0055d4 <__swsetup_r+0x68>
 d00560c:	80800517 	ldw	r2,20(r16)
 d005610:	80800215 	stw	r2,8(r16)
 d005614:	003fed06 	br	d0055cc <__swsetup_r+0x60>
 d005618:	1809883a 	mov	r4,r3
 d00561c:	d0071380 	call	d007138 <__sinit>
 d005620:	003fde06 	br	d00559c <__swsetup_r+0x30>
 d005624:	20c0a00c 	andi	r3,r4,640
 d005628:	00808004 	movi	r2,512
 d00562c:	18bfe026 	beq	r3,r2,d0055b0 <__swsetup_r+0x44>
 d005630:	8809883a 	mov	r4,r17
 d005634:	800b883a 	mov	r5,r16
 d005638:	d0080300 	call	d008030 <__smakebuf_r>
 d00563c:	8100030b 	ldhu	r4,12(r16)
 d005640:	81400417 	ldw	r5,16(r16)
 d005644:	003fda06 	br	d0055b0 <__swsetup_r+0x44>
 d005648:	2080040c 	andi	r2,r4,16
 d00564c:	103fed26 	beq	r2,zero,d005604 <__swsetup_r+0x98>
 d005650:	2080010c 	andi	r2,r4,4
 d005654:	10001226 	beq	r2,zero,d0056a0 <__swsetup_r+0x134>
 d005658:	81400c17 	ldw	r5,48(r16)
 d00565c:	28000526 	beq	r5,zero,d005674 <__swsetup_r+0x108>
 d005660:	80801004 	addi	r2,r16,64
 d005664:	28800226 	beq	r5,r2,d005670 <__swsetup_r+0x104>
 d005668:	8809883a 	mov	r4,r17
 d00566c:	d00763c0 	call	d00763c <_free_r>
 d005670:	80000c15 	stw	zero,48(r16)
 d005674:	8080030b 	ldhu	r2,12(r16)
 d005678:	81400417 	ldw	r5,16(r16)
 d00567c:	80000115 	stw	zero,4(r16)
 d005680:	10bff6cc 	andi	r2,r2,65499
 d005684:	8080030d 	sth	r2,12(r16)
 d005688:	81400015 	stw	r5,0(r16)
 d00568c:	8080030b 	ldhu	r2,12(r16)
 d005690:	10800214 	ori	r2,r2,8
 d005694:	113fffcc 	andi	r4,r2,65535
 d005698:	8080030d 	sth	r2,12(r16)
 d00569c:	003fc306 	br	d0055ac <__swsetup_r+0x40>
 d0056a0:	81400417 	ldw	r5,16(r16)
 d0056a4:	003ff906 	br	d00568c <__swsetup_r+0x120>

0d0056a8 <quorem>:
 d0056a8:	28c00417 	ldw	r3,16(r5)
 d0056ac:	20800417 	ldw	r2,16(r4)
 d0056b0:	defff104 	addi	sp,sp,-60
 d0056b4:	dfc00e15 	stw	ra,56(sp)
 d0056b8:	df000d15 	stw	fp,52(sp)
 d0056bc:	ddc00c15 	stw	r23,48(sp)
 d0056c0:	dd800b15 	stw	r22,44(sp)
 d0056c4:	dd400a15 	stw	r21,40(sp)
 d0056c8:	dd000915 	stw	r20,36(sp)
 d0056cc:	dcc00815 	stw	r19,32(sp)
 d0056d0:	dc800715 	stw	r18,28(sp)
 d0056d4:	dc400615 	stw	r17,24(sp)
 d0056d8:	dc000515 	stw	r16,20(sp)
 d0056dc:	d9000315 	stw	r4,12(sp)
 d0056e0:	d9400415 	stw	r5,16(sp)
 d0056e4:	10c07f16 	blt	r2,r3,d0058e4 <quorem+0x23c>
 d0056e8:	1d3fffc4 	addi	r20,r3,-1
 d0056ec:	d8c00417 	ldw	r3,16(sp)
 d0056f0:	d9000317 	ldw	r4,12(sp)
 d0056f4:	a505883a 	add	r2,r20,r20
 d0056f8:	1085883a 	add	r2,r2,r2
 d0056fc:	1cc00504 	addi	r19,r3,20
 d005700:	25c00504 	addi	r23,r4,20
 d005704:	98ad883a 	add	r22,r19,r2
 d005708:	15c7883a 	add	r3,r2,r23
 d00570c:	b1400017 	ldw	r5,0(r22)
 d005710:	19000017 	ldw	r4,0(r3)
 d005714:	d8c00015 	stw	r3,0(sp)
 d005718:	29400044 	addi	r5,r5,1
 d00571c:	d9000215 	stw	r4,8(sp)
 d005720:	d00c90c0 	call	d00c90c <__udivsi3>
 d005724:	1039883a 	mov	fp,r2
 d005728:	10003d1e 	bne	r2,zero,d005820 <quorem+0x178>
 d00572c:	d9400417 	ldw	r5,16(sp)
 d005730:	d9000317 	ldw	r4,12(sp)
 d005734:	d008b440 	call	d008b44 <__mcmp>
 d005738:	10002c16 	blt	r2,zero,d0057ec <quorem+0x144>
 d00573c:	e7000044 	addi	fp,fp,1
 d005740:	b80f883a 	mov	r7,r23
 d005744:	0011883a 	mov	r8,zero
 d005748:	0009883a 	mov	r4,zero
 d00574c:	99400017 	ldw	r5,0(r19)
 d005750:	38c00017 	ldw	r3,0(r7)
 d005754:	9cc00104 	addi	r19,r19,4
 d005758:	28bfffcc 	andi	r2,r5,65535
 d00575c:	2085883a 	add	r2,r4,r2
 d005760:	11bfffcc 	andi	r6,r2,65535
 d005764:	193fffcc 	andi	r4,r3,65535
 d005768:	1004d43a 	srli	r2,r2,16
 d00576c:	280ad43a 	srli	r5,r5,16
 d005770:	2189c83a 	sub	r4,r4,r6
 d005774:	2209883a 	add	r4,r4,r8
 d005778:	1806d43a 	srli	r3,r3,16
 d00577c:	288b883a 	add	r5,r5,r2
 d005780:	200dd43a 	srai	r6,r4,16
 d005784:	28bfffcc 	andi	r2,r5,65535
 d005788:	1887c83a 	sub	r3,r3,r2
 d00578c:	1987883a 	add	r3,r3,r6
 d005790:	3900000d 	sth	r4,0(r7)
 d005794:	38c0008d 	sth	r3,2(r7)
 d005798:	2808d43a 	srli	r4,r5,16
 d00579c:	39c00104 	addi	r7,r7,4
 d0057a0:	1811d43a 	srai	r8,r3,16
 d0057a4:	b4ffe92e 	bgeu	r22,r19,d00574c <quorem+0xa4>
 d0057a8:	a505883a 	add	r2,r20,r20
 d0057ac:	1085883a 	add	r2,r2,r2
 d0057b0:	b885883a 	add	r2,r23,r2
 d0057b4:	10c00017 	ldw	r3,0(r2)
 d0057b8:	18000c1e 	bne	r3,zero,d0057ec <quorem+0x144>
 d0057bc:	113fff04 	addi	r4,r2,-4
 d0057c0:	b900082e 	bgeu	r23,r4,d0057e4 <quorem+0x13c>
 d0057c4:	10bfff17 	ldw	r2,-4(r2)
 d0057c8:	10000326 	beq	r2,zero,d0057d8 <quorem+0x130>
 d0057cc:	00000506 	br	d0057e4 <quorem+0x13c>
 d0057d0:	20800017 	ldw	r2,0(r4)
 d0057d4:	1000031e 	bne	r2,zero,d0057e4 <quorem+0x13c>
 d0057d8:	213fff04 	addi	r4,r4,-4
 d0057dc:	a53fffc4 	addi	r20,r20,-1
 d0057e0:	b93ffb36 	bltu	r23,r4,d0057d0 <quorem+0x128>
 d0057e4:	d9000317 	ldw	r4,12(sp)
 d0057e8:	25000415 	stw	r20,16(r4)
 d0057ec:	e005883a 	mov	r2,fp
 d0057f0:	dfc00e17 	ldw	ra,56(sp)
 d0057f4:	df000d17 	ldw	fp,52(sp)
 d0057f8:	ddc00c17 	ldw	r23,48(sp)
 d0057fc:	dd800b17 	ldw	r22,44(sp)
 d005800:	dd400a17 	ldw	r21,40(sp)
 d005804:	dd000917 	ldw	r20,36(sp)
 d005808:	dcc00817 	ldw	r19,32(sp)
 d00580c:	dc800717 	ldw	r18,28(sp)
 d005810:	dc400617 	ldw	r17,24(sp)
 d005814:	dc000517 	ldw	r16,20(sp)
 d005818:	dec00f04 	addi	sp,sp,60
 d00581c:	f800283a 	ret
 d005820:	b823883a 	mov	r17,r23
 d005824:	9825883a 	mov	r18,r19
 d005828:	d8000115 	stw	zero,4(sp)
 d00582c:	002b883a 	mov	r21,zero
 d005830:	94000017 	ldw	r16,0(r18)
 d005834:	e009883a 	mov	r4,fp
 d005838:	94800104 	addi	r18,r18,4
 d00583c:	817fffcc 	andi	r5,r16,65535
 d005840:	d00235c0 	call	d00235c <__mulsi3>
 d005844:	800ad43a 	srli	r5,r16,16
 d005848:	e009883a 	mov	r4,fp
 d00584c:	a8a1883a 	add	r16,r21,r2
 d005850:	d00235c0 	call	d00235c <__mulsi3>
 d005854:	89000017 	ldw	r4,0(r17)
 d005858:	80ffffcc 	andi	r3,r16,65535
 d00585c:	8020d43a 	srli	r16,r16,16
 d005860:	217fffcc 	andi	r5,r4,65535
 d005864:	28cbc83a 	sub	r5,r5,r3
 d005868:	d8c00117 	ldw	r3,4(sp)
 d00586c:	2008d43a 	srli	r4,r4,16
 d005870:	1405883a 	add	r2,r2,r16
 d005874:	28cb883a 	add	r5,r5,r3
 d005878:	280dd43a 	srai	r6,r5,16
 d00587c:	10ffffcc 	andi	r3,r2,65535
 d005880:	20c9c83a 	sub	r4,r4,r3
 d005884:	2189883a 	add	r4,r4,r6
 d005888:	8900008d 	sth	r4,2(r17)
 d00588c:	2009d43a 	srai	r4,r4,16
 d005890:	8940000d 	sth	r5,0(r17)
 d005894:	102ad43a 	srli	r21,r2,16
 d005898:	8c400104 	addi	r17,r17,4
 d00589c:	d9000115 	stw	r4,4(sp)
 d0058a0:	b4bfe32e 	bgeu	r22,r18,d005830 <quorem+0x188>
 d0058a4:	d9000217 	ldw	r4,8(sp)
 d0058a8:	203fa01e 	bne	r4,zero,d00572c <quorem+0x84>
 d0058ac:	d8800017 	ldw	r2,0(sp)
 d0058b0:	10ffff04 	addi	r3,r2,-4
 d0058b4:	b8c0082e 	bgeu	r23,r3,d0058d8 <quorem+0x230>
 d0058b8:	10bfff17 	ldw	r2,-4(r2)
 d0058bc:	10000326 	beq	r2,zero,d0058cc <quorem+0x224>
 d0058c0:	00000506 	br	d0058d8 <quorem+0x230>
 d0058c4:	18800017 	ldw	r2,0(r3)
 d0058c8:	1000031e 	bne	r2,zero,d0058d8 <quorem+0x230>
 d0058cc:	18ffff04 	addi	r3,r3,-4
 d0058d0:	a53fffc4 	addi	r20,r20,-1
 d0058d4:	b8fffb36 	bltu	r23,r3,d0058c4 <quorem+0x21c>
 d0058d8:	d8c00317 	ldw	r3,12(sp)
 d0058dc:	1d000415 	stw	r20,16(r3)
 d0058e0:	003f9206 	br	d00572c <quorem+0x84>
 d0058e4:	0005883a 	mov	r2,zero
 d0058e8:	003fc106 	br	d0057f0 <quorem+0x148>

0d0058ec <_dtoa_r>:
 d0058ec:	22001017 	ldw	r8,64(r4)
 d0058f0:	deffda04 	addi	sp,sp,-152
 d0058f4:	dd402115 	stw	r21,132(sp)
 d0058f8:	dd002015 	stw	r20,128(sp)
 d0058fc:	dc801e15 	stw	r18,120(sp)
 d005900:	dc401d15 	stw	r17,116(sp)
 d005904:	dfc02515 	stw	ra,148(sp)
 d005908:	df002415 	stw	fp,144(sp)
 d00590c:	ddc02315 	stw	r23,140(sp)
 d005910:	dd802215 	stw	r22,136(sp)
 d005914:	dcc01f15 	stw	r19,124(sp)
 d005918:	dc001c15 	stw	r16,112(sp)
 d00591c:	d9001615 	stw	r4,88(sp)
 d005920:	3023883a 	mov	r17,r6
 d005924:	2829883a 	mov	r20,r5
 d005928:	d9c01715 	stw	r7,92(sp)
 d00592c:	dc802817 	ldw	r18,160(sp)
 d005930:	302b883a 	mov	r21,r6
 d005934:	40000a26 	beq	r8,zero,d005960 <_dtoa_r+0x74>
 d005938:	20801117 	ldw	r2,68(r4)
 d00593c:	400b883a 	mov	r5,r8
 d005940:	40800115 	stw	r2,4(r8)
 d005944:	20c01117 	ldw	r3,68(r4)
 d005948:	00800044 	movi	r2,1
 d00594c:	10c4983a 	sll	r2,r2,r3
 d005950:	40800215 	stw	r2,8(r8)
 d005954:	d0089e80 	call	d0089e8 <_Bfree>
 d005958:	d8c01617 	ldw	r3,88(sp)
 d00595c:	18001015 	stw	zero,64(r3)
 d005960:	8800a316 	blt	r17,zero,d005bf0 <_dtoa_r+0x304>
 d005964:	90000015 	stw	zero,0(r18)
 d005968:	a8dffc2c 	andhi	r3,r21,32752
 d00596c:	009ffc34 	movhi	r2,32752
 d005970:	18809126 	beq	r3,r2,d005bb8 <_dtoa_r+0x2cc>
 d005974:	000d883a 	mov	r6,zero
 d005978:	000f883a 	mov	r7,zero
 d00597c:	a009883a 	mov	r4,r20
 d005980:	a80b883a 	mov	r5,r21
 d005984:	dd001215 	stw	r20,72(sp)
 d005988:	dd401315 	stw	r21,76(sp)
 d00598c:	d00c24c0 	call	d00c24c <__nedf2>
 d005990:	1000171e 	bne	r2,zero,d0059f0 <_dtoa_r+0x104>
 d005994:	d9802717 	ldw	r6,156(sp)
 d005998:	00800044 	movi	r2,1
 d00599c:	30800015 	stw	r2,0(r6)
 d0059a0:	d8802917 	ldw	r2,164(sp)
 d0059a4:	10029b26 	beq	r2,zero,d006414 <_dtoa_r+0xb28>
 d0059a8:	d9002917 	ldw	r4,164(sp)
 d0059ac:	00834174 	movhi	r2,3333
 d0059b0:	10b8c744 	addi	r2,r2,-7395
 d0059b4:	10ffffc4 	addi	r3,r2,-1
 d0059b8:	20800015 	stw	r2,0(r4)
 d0059bc:	1805883a 	mov	r2,r3
 d0059c0:	dfc02517 	ldw	ra,148(sp)
 d0059c4:	df002417 	ldw	fp,144(sp)
 d0059c8:	ddc02317 	ldw	r23,140(sp)
 d0059cc:	dd802217 	ldw	r22,136(sp)
 d0059d0:	dd402117 	ldw	r21,132(sp)
 d0059d4:	dd002017 	ldw	r20,128(sp)
 d0059d8:	dcc01f17 	ldw	r19,124(sp)
 d0059dc:	dc801e17 	ldw	r18,120(sp)
 d0059e0:	dc401d17 	ldw	r17,116(sp)
 d0059e4:	dc001c17 	ldw	r16,112(sp)
 d0059e8:	dec02604 	addi	sp,sp,152
 d0059ec:	f800283a 	ret
 d0059f0:	d9001617 	ldw	r4,88(sp)
 d0059f4:	d9401217 	ldw	r5,72(sp)
 d0059f8:	d8800104 	addi	r2,sp,4
 d0059fc:	a80d883a 	mov	r6,r21
 d005a00:	d9c00204 	addi	r7,sp,8
 d005a04:	d8800015 	stw	r2,0(sp)
 d005a08:	d0090240 	call	d009024 <__d2b>
 d005a0c:	d8800715 	stw	r2,28(sp)
 d005a10:	a804d53a 	srli	r2,r21,20
 d005a14:	1101ffcc 	andi	r4,r2,2047
 d005a18:	20008626 	beq	r4,zero,d005c34 <_dtoa_r+0x348>
 d005a1c:	d8c01217 	ldw	r3,72(sp)
 d005a20:	00800434 	movhi	r2,16
 d005a24:	10bfffc4 	addi	r2,r2,-1
 d005a28:	ddc00117 	ldw	r23,4(sp)
 d005a2c:	a884703a 	and	r2,r21,r2
 d005a30:	1811883a 	mov	r8,r3
 d005a34:	124ffc34 	orhi	r9,r2,16368
 d005a38:	25bf0044 	addi	r22,r4,-1023
 d005a3c:	d8000815 	stw	zero,32(sp)
 d005a40:	0005883a 	mov	r2,zero
 d005a44:	00cffe34 	movhi	r3,16376
 d005a48:	480b883a 	mov	r5,r9
 d005a4c:	4009883a 	mov	r4,r8
 d005a50:	180f883a 	mov	r7,r3
 d005a54:	100d883a 	mov	r6,r2
 d005a58:	d00bab40 	call	d00bab4 <__subdf3>
 d005a5c:	0218dbf4 	movhi	r8,25455
 d005a60:	4210d844 	addi	r8,r8,17249
 d005a64:	024ff4f4 	movhi	r9,16339
 d005a68:	4a61e9c4 	addi	r9,r9,-30809
 d005a6c:	480f883a 	mov	r7,r9
 d005a70:	400d883a 	mov	r6,r8
 d005a74:	180b883a 	mov	r5,r3
 d005a78:	1009883a 	mov	r4,r2
 d005a7c:	d00bba80 	call	d00bba8 <__muldf3>
 d005a80:	0222d874 	movhi	r8,35681
 d005a84:	42322cc4 	addi	r8,r8,-14157
 d005a88:	024ff1f4 	movhi	r9,16327
 d005a8c:	4a628a04 	addi	r9,r9,-30168
 d005a90:	480f883a 	mov	r7,r9
 d005a94:	400d883a 	mov	r6,r8
 d005a98:	180b883a 	mov	r5,r3
 d005a9c:	1009883a 	mov	r4,r2
 d005aa0:	d00bb340 	call	d00bb34 <__adddf3>
 d005aa4:	b009883a 	mov	r4,r22
 d005aa8:	1021883a 	mov	r16,r2
 d005aac:	1823883a 	mov	r17,r3
 d005ab0:	d00c46c0 	call	d00c46c <__floatsidf>
 d005ab4:	021427f4 	movhi	r8,20639
 d005ab8:	421e7ec4 	addi	r8,r8,31227
 d005abc:	024ff4f4 	movhi	r9,16339
 d005ac0:	4a5104c4 	addi	r9,r9,17427
 d005ac4:	480f883a 	mov	r7,r9
 d005ac8:	400d883a 	mov	r6,r8
 d005acc:	180b883a 	mov	r5,r3
 d005ad0:	1009883a 	mov	r4,r2
 d005ad4:	d00bba80 	call	d00bba8 <__muldf3>
 d005ad8:	180f883a 	mov	r7,r3
 d005adc:	880b883a 	mov	r5,r17
 d005ae0:	100d883a 	mov	r6,r2
 d005ae4:	8009883a 	mov	r4,r16
 d005ae8:	d00bb340 	call	d00bb34 <__adddf3>
 d005aec:	1009883a 	mov	r4,r2
 d005af0:	180b883a 	mov	r5,r3
 d005af4:	1021883a 	mov	r16,r2
 d005af8:	1823883a 	mov	r17,r3
 d005afc:	d00c5640 	call	d00c564 <__fixdfsi>
 d005b00:	000d883a 	mov	r6,zero
 d005b04:	000f883a 	mov	r7,zero
 d005b08:	8009883a 	mov	r4,r16
 d005b0c:	880b883a 	mov	r5,r17
 d005b10:	d8800d15 	stw	r2,52(sp)
 d005b14:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d005b18:	10031716 	blt	r2,zero,d006778 <_dtoa_r+0xe8c>
 d005b1c:	d8c00d17 	ldw	r3,52(sp)
 d005b20:	00800584 	movi	r2,22
 d005b24:	10c1482e 	bgeu	r2,r3,d006048 <_dtoa_r+0x75c>
 d005b28:	01000044 	movi	r4,1
 d005b2c:	d9000c15 	stw	r4,48(sp)
 d005b30:	bd85c83a 	sub	r2,r23,r22
 d005b34:	11bfffc4 	addi	r6,r2,-1
 d005b38:	30030b16 	blt	r6,zero,d006768 <_dtoa_r+0xe7c>
 d005b3c:	d9800a15 	stw	r6,40(sp)
 d005b40:	d8001115 	stw	zero,68(sp)
 d005b44:	d8c00d17 	ldw	r3,52(sp)
 d005b48:	1802ff16 	blt	r3,zero,d006748 <_dtoa_r+0xe5c>
 d005b4c:	d9000a17 	ldw	r4,40(sp)
 d005b50:	d8c00915 	stw	r3,36(sp)
 d005b54:	d8001015 	stw	zero,64(sp)
 d005b58:	20c9883a 	add	r4,r4,r3
 d005b5c:	d9000a15 	stw	r4,40(sp)
 d005b60:	d9001717 	ldw	r4,92(sp)
 d005b64:	00800244 	movi	r2,9
 d005b68:	11004636 	bltu	r2,r4,d005c84 <_dtoa_r+0x398>
 d005b6c:	00800144 	movi	r2,5
 d005b70:	11020416 	blt	r2,r4,d006384 <_dtoa_r+0xa98>
 d005b74:	04400044 	movi	r17,1
 d005b78:	d8c01717 	ldw	r3,92(sp)
 d005b7c:	00800144 	movi	r2,5
 d005b80:	10c1ed36 	bltu	r2,r3,d006338 <_dtoa_r+0xa4c>
 d005b84:	18c5883a 	add	r2,r3,r3
 d005b88:	1085883a 	add	r2,r2,r2
 d005b8c:	00c34034 	movhi	r3,3328
 d005b90:	18d6e804 	addi	r3,r3,23456
 d005b94:	10c5883a 	add	r2,r2,r3
 d005b98:	11000017 	ldw	r4,0(r2)
 d005b9c:	2000683a 	jmp	r4
 d005ba0:	0d005c8c 	andi	r20,at,370
 d005ba4:	0d005c8c 	andi	r20,at,370
 d005ba8:	0d00668c 	andi	r20,at,410
 d005bac:	0d006664 	muli	r20,at,409
 d005bb0:	0d0066a8 	cmpgeui	r20,at,410
 d005bb4:	0d0066b4 	orhi	r20,at,410
 d005bb8:	d9002717 	ldw	r4,156(sp)
 d005bbc:	0089c3c4 	movi	r2,9999
 d005bc0:	20800015 	stw	r2,0(r4)
 d005bc4:	a0001026 	beq	r20,zero,d005c08 <_dtoa_r+0x31c>
 d005bc8:	00c34174 	movhi	r3,3333
 d005bcc:	18f8d304 	addi	r3,r3,-7348
 d005bd0:	d9802917 	ldw	r6,164(sp)
 d005bd4:	303f7926 	beq	r6,zero,d0059bc <_dtoa_r+0xd0>
 d005bd8:	188000c7 	ldb	r2,3(r3)
 d005bdc:	190000c4 	addi	r4,r3,3
 d005be0:	1000101e 	bne	r2,zero,d005c24 <_dtoa_r+0x338>
 d005be4:	d8802917 	ldw	r2,164(sp)
 d005be8:	11000015 	stw	r4,0(r2)
 d005bec:	003f7306 	br	d0059bc <_dtoa_r+0xd0>
 d005bf0:	00a00034 	movhi	r2,32768
 d005bf4:	10bfffc4 	addi	r2,r2,-1
 d005bf8:	00c00044 	movi	r3,1
 d005bfc:	88aa703a 	and	r21,r17,r2
 d005c00:	90c00015 	stw	r3,0(r18)
 d005c04:	003f5806 	br	d005968 <_dtoa_r+0x7c>
 d005c08:	00800434 	movhi	r2,16
 d005c0c:	10bfffc4 	addi	r2,r2,-1
 d005c10:	a884703a 	and	r2,r21,r2
 d005c14:	103fec1e 	bne	r2,zero,d005bc8 <_dtoa_r+0x2dc>
 d005c18:	00c34174 	movhi	r3,3333
 d005c1c:	18f8d004 	addi	r3,r3,-7360
 d005c20:	003feb06 	br	d005bd0 <_dtoa_r+0x2e4>
 d005c24:	d8802917 	ldw	r2,164(sp)
 d005c28:	19000204 	addi	r4,r3,8
 d005c2c:	11000015 	stw	r4,0(r2)
 d005c30:	003f6206 	br	d0059bc <_dtoa_r+0xd0>
 d005c34:	ddc00117 	ldw	r23,4(sp)
 d005c38:	d8800217 	ldw	r2,8(sp)
 d005c3c:	01000804 	movi	r4,32
 d005c40:	b8c10c84 	addi	r3,r23,1074
 d005c44:	18a3883a 	add	r17,r3,r2
 d005c48:	2441b80e 	bge	r4,r17,d00632c <_dtoa_r+0xa40>
 d005c4c:	00c01004 	movi	r3,64
 d005c50:	1c47c83a 	sub	r3,r3,r17
 d005c54:	88bff804 	addi	r2,r17,-32
 d005c58:	a8c6983a 	sll	r3,r21,r3
 d005c5c:	a084d83a 	srl	r2,r20,r2
 d005c60:	1888b03a 	or	r4,r3,r2
 d005c64:	d00c63c0 	call	d00c63c <__floatunsidf>
 d005c68:	1011883a 	mov	r8,r2
 d005c6c:	00bf8434 	movhi	r2,65040
 d005c70:	01000044 	movi	r4,1
 d005c74:	10d3883a 	add	r9,r2,r3
 d005c78:	8dbef344 	addi	r22,r17,-1075
 d005c7c:	d9000815 	stw	r4,32(sp)
 d005c80:	003f6f06 	br	d005a40 <_dtoa_r+0x154>
 d005c84:	d8001715 	stw	zero,92(sp)
 d005c88:	04400044 	movi	r17,1
 d005c8c:	00bfffc4 	movi	r2,-1
 d005c90:	00c00044 	movi	r3,1
 d005c94:	d8800e15 	stw	r2,56(sp)
 d005c98:	d8002615 	stw	zero,152(sp)
 d005c9c:	d8800f15 	stw	r2,60(sp)
 d005ca0:	d8c00b15 	stw	r3,44(sp)
 d005ca4:	1021883a 	mov	r16,r2
 d005ca8:	d8801617 	ldw	r2,88(sp)
 d005cac:	10001115 	stw	zero,68(r2)
 d005cb0:	d8801617 	ldw	r2,88(sp)
 d005cb4:	11401117 	ldw	r5,68(r2)
 d005cb8:	1009883a 	mov	r4,r2
 d005cbc:	d008f680 	call	d008f68 <_Balloc>
 d005cc0:	d8c01617 	ldw	r3,88(sp)
 d005cc4:	d8800515 	stw	r2,20(sp)
 d005cc8:	18801015 	stw	r2,64(r3)
 d005ccc:	00800384 	movi	r2,14
 d005cd0:	14006836 	bltu	r2,r16,d005e74 <_dtoa_r+0x588>
 d005cd4:	8805003a 	cmpeq	r2,r17,zero
 d005cd8:	1000661e 	bne	r2,zero,d005e74 <_dtoa_r+0x588>
 d005cdc:	d9000d17 	ldw	r4,52(sp)
 d005ce0:	0102300e 	bge	zero,r4,d0065a4 <_dtoa_r+0xcb8>
 d005ce4:	208003cc 	andi	r2,r4,15
 d005ce8:	100490fa 	slli	r2,r2,3
 d005cec:	2025d13a 	srai	r18,r4,4
 d005cf0:	00c34174 	movhi	r3,3333
 d005cf4:	18f8e404 	addi	r3,r3,-7280
 d005cf8:	10c5883a 	add	r2,r2,r3
 d005cfc:	90c0040c 	andi	r3,r18,16
 d005d00:	14000017 	ldw	r16,0(r2)
 d005d04:	14400117 	ldw	r17,4(r2)
 d005d08:	18036a1e 	bne	r3,zero,d006ab4 <_dtoa_r+0x11c8>
 d005d0c:	05800084 	movi	r22,2
 d005d10:	90001026 	beq	r18,zero,d005d54 <_dtoa_r+0x468>
 d005d14:	04c34174 	movhi	r19,3333
 d005d18:	9cf91604 	addi	r19,r19,-7080
 d005d1c:	9080004c 	andi	r2,r18,1
 d005d20:	1005003a 	cmpeq	r2,r2,zero
 d005d24:	1000081e 	bne	r2,zero,d005d48 <_dtoa_r+0x45c>
 d005d28:	99800017 	ldw	r6,0(r19)
 d005d2c:	99c00117 	ldw	r7,4(r19)
 d005d30:	880b883a 	mov	r5,r17
 d005d34:	8009883a 	mov	r4,r16
 d005d38:	d00bba80 	call	d00bba8 <__muldf3>
 d005d3c:	1021883a 	mov	r16,r2
 d005d40:	b5800044 	addi	r22,r22,1
 d005d44:	1823883a 	mov	r17,r3
 d005d48:	9025d07a 	srai	r18,r18,1
 d005d4c:	9cc00204 	addi	r19,r19,8
 d005d50:	903ff21e 	bne	r18,zero,d005d1c <_dtoa_r+0x430>
 d005d54:	a80b883a 	mov	r5,r21
 d005d58:	a009883a 	mov	r4,r20
 d005d5c:	880f883a 	mov	r7,r17
 d005d60:	800d883a 	mov	r6,r16
 d005d64:	d00bf6c0 	call	d00bf6c <__divdf3>
 d005d68:	1029883a 	mov	r20,r2
 d005d6c:	182b883a 	mov	r21,r3
 d005d70:	d8c00c17 	ldw	r3,48(sp)
 d005d74:	1805003a 	cmpeq	r2,r3,zero
 d005d78:	1000081e 	bne	r2,zero,d005d9c <_dtoa_r+0x4b0>
 d005d7c:	0005883a 	mov	r2,zero
 d005d80:	00cffc34 	movhi	r3,16368
 d005d84:	180f883a 	mov	r7,r3
 d005d88:	a009883a 	mov	r4,r20
 d005d8c:	a80b883a 	mov	r5,r21
 d005d90:	100d883a 	mov	r6,r2
 d005d94:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d005d98:	1003fe16 	blt	r2,zero,d006d94 <_dtoa_r+0x14a8>
 d005d9c:	b009883a 	mov	r4,r22
 d005da0:	d00c46c0 	call	d00c46c <__floatsidf>
 d005da4:	180b883a 	mov	r5,r3
 d005da8:	1009883a 	mov	r4,r2
 d005dac:	a00d883a 	mov	r6,r20
 d005db0:	a80f883a 	mov	r7,r21
 d005db4:	d00bba80 	call	d00bba8 <__muldf3>
 d005db8:	0011883a 	mov	r8,zero
 d005dbc:	02500734 	movhi	r9,16412
 d005dc0:	1009883a 	mov	r4,r2
 d005dc4:	180b883a 	mov	r5,r3
 d005dc8:	480f883a 	mov	r7,r9
 d005dcc:	400d883a 	mov	r6,r8
 d005dd0:	d00bb340 	call	d00bb34 <__adddf3>
 d005dd4:	d9000f17 	ldw	r4,60(sp)
 d005dd8:	102d883a 	mov	r22,r2
 d005ddc:	00bf3034 	movhi	r2,64704
 d005de0:	18b9883a 	add	fp,r3,r2
 d005de4:	e02f883a 	mov	r23,fp
 d005de8:	20028f1e 	bne	r4,zero,d006828 <_dtoa_r+0xf3c>
 d005dec:	0005883a 	mov	r2,zero
 d005df0:	00d00534 	movhi	r3,16404
 d005df4:	a009883a 	mov	r4,r20
 d005df8:	a80b883a 	mov	r5,r21
 d005dfc:	180f883a 	mov	r7,r3
 d005e00:	100d883a 	mov	r6,r2
 d005e04:	d00bab40 	call	d00bab4 <__subdf3>
 d005e08:	1009883a 	mov	r4,r2
 d005e0c:	e00f883a 	mov	r7,fp
 d005e10:	180b883a 	mov	r5,r3
 d005e14:	b00d883a 	mov	r6,r22
 d005e18:	1025883a 	mov	r18,r2
 d005e1c:	1827883a 	mov	r19,r3
 d005e20:	d00c2d40 	call	d00c2d4 <__gtdf2>
 d005e24:	00834f16 	blt	zero,r2,d006b64 <_dtoa_r+0x1278>
 d005e28:	e0e0003c 	xorhi	r3,fp,32768
 d005e2c:	9009883a 	mov	r4,r18
 d005e30:	980b883a 	mov	r5,r19
 d005e34:	180f883a 	mov	r7,r3
 d005e38:	b00d883a 	mov	r6,r22
 d005e3c:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d005e40:	1000080e 	bge	r2,zero,d005e64 <_dtoa_r+0x578>
 d005e44:	0027883a 	mov	r19,zero
 d005e48:	0025883a 	mov	r18,zero
 d005e4c:	d8802617 	ldw	r2,152(sp)
 d005e50:	df000517 	ldw	fp,20(sp)
 d005e54:	d8000615 	stw	zero,24(sp)
 d005e58:	0084303a 	nor	r2,zero,r2
 d005e5c:	d8800d15 	stw	r2,52(sp)
 d005e60:	00019b06 	br	d0064d0 <_dtoa_r+0xbe4>
 d005e64:	d9801217 	ldw	r6,72(sp)
 d005e68:	d8801317 	ldw	r2,76(sp)
 d005e6c:	3029883a 	mov	r20,r6
 d005e70:	102b883a 	mov	r21,r2
 d005e74:	d8c00217 	ldw	r3,8(sp)
 d005e78:	18008516 	blt	r3,zero,d006090 <_dtoa_r+0x7a4>
 d005e7c:	d9000d17 	ldw	r4,52(sp)
 d005e80:	00800384 	movi	r2,14
 d005e84:	11008216 	blt	r2,r4,d006090 <_dtoa_r+0x7a4>
 d005e88:	200490fa 	slli	r2,r4,3
 d005e8c:	d9802617 	ldw	r6,152(sp)
 d005e90:	00c34174 	movhi	r3,3333
 d005e94:	18f8e404 	addi	r3,r3,-7280
 d005e98:	10c5883a 	add	r2,r2,r3
 d005e9c:	14800017 	ldw	r18,0(r2)
 d005ea0:	14c00117 	ldw	r19,4(r2)
 d005ea4:	30031e16 	blt	r6,zero,d006b20 <_dtoa_r+0x1234>
 d005ea8:	d9000517 	ldw	r4,20(sp)
 d005eac:	d8c00f17 	ldw	r3,60(sp)
 d005eb0:	a823883a 	mov	r17,r21
 d005eb4:	a021883a 	mov	r16,r20
 d005eb8:	192b883a 	add	r21,r3,r4
 d005ebc:	2039883a 	mov	fp,r4
 d005ec0:	00000f06 	br	d005f00 <_dtoa_r+0x614>
 d005ec4:	0005883a 	mov	r2,zero
 d005ec8:	00d00934 	movhi	r3,16420
 d005ecc:	5009883a 	mov	r4,r10
 d005ed0:	580b883a 	mov	r5,r11
 d005ed4:	180f883a 	mov	r7,r3
 d005ed8:	100d883a 	mov	r6,r2
 d005edc:	d00bba80 	call	d00bba8 <__muldf3>
 d005ee0:	180b883a 	mov	r5,r3
 d005ee4:	000d883a 	mov	r6,zero
 d005ee8:	000f883a 	mov	r7,zero
 d005eec:	1009883a 	mov	r4,r2
 d005ef0:	1021883a 	mov	r16,r2
 d005ef4:	1823883a 	mov	r17,r3
 d005ef8:	d00c24c0 	call	d00c24c <__nedf2>
 d005efc:	10004526 	beq	r2,zero,d006014 <_dtoa_r+0x728>
 d005f00:	900d883a 	mov	r6,r18
 d005f04:	980f883a 	mov	r7,r19
 d005f08:	8009883a 	mov	r4,r16
 d005f0c:	880b883a 	mov	r5,r17
 d005f10:	d00bf6c0 	call	d00bf6c <__divdf3>
 d005f14:	180b883a 	mov	r5,r3
 d005f18:	1009883a 	mov	r4,r2
 d005f1c:	d00c5640 	call	d00c564 <__fixdfsi>
 d005f20:	1009883a 	mov	r4,r2
 d005f24:	1029883a 	mov	r20,r2
 d005f28:	d00c46c0 	call	d00c46c <__floatsidf>
 d005f2c:	180f883a 	mov	r7,r3
 d005f30:	9009883a 	mov	r4,r18
 d005f34:	980b883a 	mov	r5,r19
 d005f38:	100d883a 	mov	r6,r2
 d005f3c:	d00bba80 	call	d00bba8 <__muldf3>
 d005f40:	180f883a 	mov	r7,r3
 d005f44:	880b883a 	mov	r5,r17
 d005f48:	8009883a 	mov	r4,r16
 d005f4c:	100d883a 	mov	r6,r2
 d005f50:	d00bab40 	call	d00bab4 <__subdf3>
 d005f54:	1015883a 	mov	r10,r2
 d005f58:	a0800c04 	addi	r2,r20,48
 d005f5c:	e0800005 	stb	r2,0(fp)
 d005f60:	e7000044 	addi	fp,fp,1
 d005f64:	1817883a 	mov	r11,r3
 d005f68:	e57fd61e 	bne	fp,r21,d005ec4 <_dtoa_r+0x5d8>
 d005f6c:	500d883a 	mov	r6,r10
 d005f70:	180f883a 	mov	r7,r3
 d005f74:	5009883a 	mov	r4,r10
 d005f78:	180b883a 	mov	r5,r3
 d005f7c:	d00bb340 	call	d00bb34 <__adddf3>
 d005f80:	100d883a 	mov	r6,r2
 d005f84:	9009883a 	mov	r4,r18
 d005f88:	980b883a 	mov	r5,r19
 d005f8c:	180f883a 	mov	r7,r3
 d005f90:	1021883a 	mov	r16,r2
 d005f94:	1823883a 	mov	r17,r3
 d005f98:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d005f9c:	10000816 	blt	r2,zero,d005fc0 <_dtoa_r+0x6d4>
 d005fa0:	980b883a 	mov	r5,r19
 d005fa4:	800d883a 	mov	r6,r16
 d005fa8:	880f883a 	mov	r7,r17
 d005fac:	9009883a 	mov	r4,r18
 d005fb0:	d00c1c40 	call	d00c1c4 <__eqdf2>
 d005fb4:	1000171e 	bne	r2,zero,d006014 <_dtoa_r+0x728>
 d005fb8:	a080004c 	andi	r2,r20,1
 d005fbc:	10001526 	beq	r2,zero,d006014 <_dtoa_r+0x728>
 d005fc0:	d8800d17 	ldw	r2,52(sp)
 d005fc4:	d8800415 	stw	r2,16(sp)
 d005fc8:	e009883a 	mov	r4,fp
 d005fcc:	213fffc4 	addi	r4,r4,-1
 d005fd0:	20c00007 	ldb	r3,0(r4)
 d005fd4:	00800e44 	movi	r2,57
 d005fd8:	1880081e 	bne	r3,r2,d005ffc <_dtoa_r+0x710>
 d005fdc:	d8800517 	ldw	r2,20(sp)
 d005fe0:	113ffa1e 	bne	r2,r4,d005fcc <_dtoa_r+0x6e0>
 d005fe4:	d8c00417 	ldw	r3,16(sp)
 d005fe8:	d9800517 	ldw	r6,20(sp)
 d005fec:	00800c04 	movi	r2,48
 d005ff0:	18c00044 	addi	r3,r3,1
 d005ff4:	d8c00415 	stw	r3,16(sp)
 d005ff8:	30800005 	stb	r2,0(r6)
 d005ffc:	20800003 	ldbu	r2,0(r4)
 d006000:	d8c00417 	ldw	r3,16(sp)
 d006004:	27000044 	addi	fp,r4,1
 d006008:	10800044 	addi	r2,r2,1
 d00600c:	d8c00d15 	stw	r3,52(sp)
 d006010:	20800005 	stb	r2,0(r4)
 d006014:	d9001617 	ldw	r4,88(sp)
 d006018:	d9400717 	ldw	r5,28(sp)
 d00601c:	d0089e80 	call	d0089e8 <_Bfree>
 d006020:	e0000005 	stb	zero,0(fp)
 d006024:	d9800d17 	ldw	r6,52(sp)
 d006028:	d8c02717 	ldw	r3,156(sp)
 d00602c:	d9002917 	ldw	r4,164(sp)
 d006030:	30800044 	addi	r2,r6,1
 d006034:	18800015 	stw	r2,0(r3)
 d006038:	20029c26 	beq	r4,zero,d006aac <_dtoa_r+0x11c0>
 d00603c:	d8c00517 	ldw	r3,20(sp)
 d006040:	27000015 	stw	fp,0(r4)
 d006044:	003e5d06 	br	d0059bc <_dtoa_r+0xd0>
 d006048:	d9800d17 	ldw	r6,52(sp)
 d00604c:	00c34174 	movhi	r3,3333
 d006050:	18f8e404 	addi	r3,r3,-7280
 d006054:	d9001217 	ldw	r4,72(sp)
 d006058:	300490fa 	slli	r2,r6,3
 d00605c:	d9401317 	ldw	r5,76(sp)
 d006060:	10c5883a 	add	r2,r2,r3
 d006064:	12000017 	ldw	r8,0(r2)
 d006068:	12400117 	ldw	r9,4(r2)
 d00606c:	400d883a 	mov	r6,r8
 d006070:	480f883a 	mov	r7,r9
 d006074:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d006078:	1000030e 	bge	r2,zero,d006088 <_dtoa_r+0x79c>
 d00607c:	d8800d17 	ldw	r2,52(sp)
 d006080:	10bfffc4 	addi	r2,r2,-1
 d006084:	d8800d15 	stw	r2,52(sp)
 d006088:	d8000c15 	stw	zero,48(sp)
 d00608c:	003ea806 	br	d005b30 <_dtoa_r+0x244>
 d006090:	d9000b17 	ldw	r4,44(sp)
 d006094:	202cc03a 	cmpne	r22,r4,zero
 d006098:	b000c71e 	bne	r22,zero,d0063b8 <_dtoa_r+0xacc>
 d00609c:	dc001117 	ldw	r16,68(sp)
 d0060a0:	dc801017 	ldw	r18,64(sp)
 d0060a4:	0027883a 	mov	r19,zero
 d0060a8:	04000b0e 	bge	zero,r16,d0060d8 <_dtoa_r+0x7ec>
 d0060ac:	d8c00a17 	ldw	r3,40(sp)
 d0060b0:	00c0090e 	bge	zero,r3,d0060d8 <_dtoa_r+0x7ec>
 d0060b4:	8005883a 	mov	r2,r16
 d0060b8:	1c011316 	blt	r3,r16,d006508 <_dtoa_r+0xc1c>
 d0060bc:	d9000a17 	ldw	r4,40(sp)
 d0060c0:	d9801117 	ldw	r6,68(sp)
 d0060c4:	80a1c83a 	sub	r16,r16,r2
 d0060c8:	2089c83a 	sub	r4,r4,r2
 d0060cc:	308dc83a 	sub	r6,r6,r2
 d0060d0:	d9000a15 	stw	r4,40(sp)
 d0060d4:	d9801115 	stw	r6,68(sp)
 d0060d8:	d8801017 	ldw	r2,64(sp)
 d0060dc:	0080150e 	bge	zero,r2,d006134 <_dtoa_r+0x848>
 d0060e0:	d8c00b17 	ldw	r3,44(sp)
 d0060e4:	1805003a 	cmpeq	r2,r3,zero
 d0060e8:	1001c91e 	bne	r2,zero,d006810 <_dtoa_r+0xf24>
 d0060ec:	04800e0e 	bge	zero,r18,d006128 <_dtoa_r+0x83c>
 d0060f0:	d9001617 	ldw	r4,88(sp)
 d0060f4:	980b883a 	mov	r5,r19
 d0060f8:	900d883a 	mov	r6,r18
 d0060fc:	d0098340 	call	d009834 <__pow5mult>
 d006100:	d9001617 	ldw	r4,88(sp)
 d006104:	d9800717 	ldw	r6,28(sp)
 d006108:	100b883a 	mov	r5,r2
 d00610c:	1027883a 	mov	r19,r2
 d006110:	d0094780 	call	d009478 <__multiply>
 d006114:	d9001617 	ldw	r4,88(sp)
 d006118:	d9400717 	ldw	r5,28(sp)
 d00611c:	1023883a 	mov	r17,r2
 d006120:	d0089e80 	call	d0089e8 <_Bfree>
 d006124:	dc400715 	stw	r17,28(sp)
 d006128:	d9001017 	ldw	r4,64(sp)
 d00612c:	248dc83a 	sub	r6,r4,r18
 d006130:	30010e1e 	bne	r6,zero,d00656c <_dtoa_r+0xc80>
 d006134:	d9001617 	ldw	r4,88(sp)
 d006138:	04400044 	movi	r17,1
 d00613c:	880b883a 	mov	r5,r17
 d006140:	d0096cc0 	call	d0096cc <__i2b>
 d006144:	d9800917 	ldw	r6,36(sp)
 d006148:	1025883a 	mov	r18,r2
 d00614c:	0180040e 	bge	zero,r6,d006160 <_dtoa_r+0x874>
 d006150:	d9001617 	ldw	r4,88(sp)
 d006154:	100b883a 	mov	r5,r2
 d006158:	d0098340 	call	d009834 <__pow5mult>
 d00615c:	1025883a 	mov	r18,r2
 d006160:	d8801717 	ldw	r2,92(sp)
 d006164:	8880f30e 	bge	r17,r2,d006534 <_dtoa_r+0xc48>
 d006168:	0023883a 	mov	r17,zero
 d00616c:	d9800917 	ldw	r6,36(sp)
 d006170:	30019e1e 	bne	r6,zero,d0067ec <_dtoa_r+0xf00>
 d006174:	00c00044 	movi	r3,1
 d006178:	d9000a17 	ldw	r4,40(sp)
 d00617c:	20c5883a 	add	r2,r4,r3
 d006180:	10c007cc 	andi	r3,r2,31
 d006184:	1800841e 	bne	r3,zero,d006398 <_dtoa_r+0xaac>
 d006188:	00800704 	movi	r2,28
 d00618c:	d9000a17 	ldw	r4,40(sp)
 d006190:	d9801117 	ldw	r6,68(sp)
 d006194:	80a1883a 	add	r16,r16,r2
 d006198:	2089883a 	add	r4,r4,r2
 d00619c:	308d883a 	add	r6,r6,r2
 d0061a0:	d9000a15 	stw	r4,40(sp)
 d0061a4:	d9801115 	stw	r6,68(sp)
 d0061a8:	d8801117 	ldw	r2,68(sp)
 d0061ac:	0080050e 	bge	zero,r2,d0061c4 <_dtoa_r+0x8d8>
 d0061b0:	d9400717 	ldw	r5,28(sp)
 d0061b4:	d9001617 	ldw	r4,88(sp)
 d0061b8:	100d883a 	mov	r6,r2
 d0061bc:	d00932c0 	call	d00932c <__lshift>
 d0061c0:	d8800715 	stw	r2,28(sp)
 d0061c4:	d8c00a17 	ldw	r3,40(sp)
 d0061c8:	00c0050e 	bge	zero,r3,d0061e0 <_dtoa_r+0x8f4>
 d0061cc:	d9001617 	ldw	r4,88(sp)
 d0061d0:	900b883a 	mov	r5,r18
 d0061d4:	180d883a 	mov	r6,r3
 d0061d8:	d00932c0 	call	d00932c <__lshift>
 d0061dc:	1025883a 	mov	r18,r2
 d0061e0:	d9000c17 	ldw	r4,48(sp)
 d0061e4:	2005003a 	cmpeq	r2,r4,zero
 d0061e8:	10016f26 	beq	r2,zero,d0067a8 <_dtoa_r+0xebc>
 d0061ec:	d9000f17 	ldw	r4,60(sp)
 d0061f0:	0102170e 	bge	zero,r4,d006a50 <_dtoa_r+0x1164>
 d0061f4:	d9800b17 	ldw	r6,44(sp)
 d0061f8:	3005003a 	cmpeq	r2,r6,zero
 d0061fc:	1000881e 	bne	r2,zero,d006420 <_dtoa_r+0xb34>
 d006200:	0400050e 	bge	zero,r16,d006218 <_dtoa_r+0x92c>
 d006204:	d9001617 	ldw	r4,88(sp)
 d006208:	980b883a 	mov	r5,r19
 d00620c:	800d883a 	mov	r6,r16
 d006210:	d00932c0 	call	d00932c <__lshift>
 d006214:	1027883a 	mov	r19,r2
 d006218:	8804c03a 	cmpne	r2,r17,zero
 d00621c:	1002541e 	bne	r2,zero,d006b70 <_dtoa_r+0x1284>
 d006220:	980b883a 	mov	r5,r19
 d006224:	dd800517 	ldw	r22,20(sp)
 d006228:	dcc00615 	stw	r19,24(sp)
 d00622c:	a700004c 	andi	fp,r20,1
 d006230:	2827883a 	mov	r19,r5
 d006234:	d9000717 	ldw	r4,28(sp)
 d006238:	900b883a 	mov	r5,r18
 d00623c:	d0056a80 	call	d0056a8 <quorem>
 d006240:	d9000717 	ldw	r4,28(sp)
 d006244:	d9400617 	ldw	r5,24(sp)
 d006248:	1023883a 	mov	r17,r2
 d00624c:	8dc00c04 	addi	r23,r17,48
 d006250:	d008b440 	call	d008b44 <__mcmp>
 d006254:	d9001617 	ldw	r4,88(sp)
 d006258:	900b883a 	mov	r5,r18
 d00625c:	980d883a 	mov	r6,r19
 d006260:	1029883a 	mov	r20,r2
 d006264:	d0091a00 	call	d0091a0 <__mdiff>
 d006268:	102b883a 	mov	r21,r2
 d00626c:	10800317 	ldw	r2,12(r2)
 d006270:	1001281e 	bne	r2,zero,d006714 <_dtoa_r+0xe28>
 d006274:	d9000717 	ldw	r4,28(sp)
 d006278:	a80b883a 	mov	r5,r21
 d00627c:	d008b440 	call	d008b44 <__mcmp>
 d006280:	d9001617 	ldw	r4,88(sp)
 d006284:	1021883a 	mov	r16,r2
 d006288:	a80b883a 	mov	r5,r21
 d00628c:	d0089e80 	call	d0089e8 <_Bfree>
 d006290:	8000041e 	bne	r16,zero,d0062a4 <_dtoa_r+0x9b8>
 d006294:	d8801717 	ldw	r2,92(sp)
 d006298:	1000021e 	bne	r2,zero,d0062a4 <_dtoa_r+0x9b8>
 d00629c:	e004c03a 	cmpne	r2,fp,zero
 d0062a0:	10011726 	beq	r2,zero,d006700 <_dtoa_r+0xe14>
 d0062a4:	a0010616 	blt	r20,zero,d0066c0 <_dtoa_r+0xdd4>
 d0062a8:	a000041e 	bne	r20,zero,d0062bc <_dtoa_r+0x9d0>
 d0062ac:	d8c01717 	ldw	r3,92(sp)
 d0062b0:	1800021e 	bne	r3,zero,d0062bc <_dtoa_r+0x9d0>
 d0062b4:	e004c03a 	cmpne	r2,fp,zero
 d0062b8:	10010126 	beq	r2,zero,d0066c0 <_dtoa_r+0xdd4>
 d0062bc:	04023d16 	blt	zero,r16,d006bb4 <_dtoa_r+0x12c8>
 d0062c0:	b5c00005 	stb	r23,0(r22)
 d0062c4:	d9800517 	ldw	r6,20(sp)
 d0062c8:	d9000f17 	ldw	r4,60(sp)
 d0062cc:	b5800044 	addi	r22,r22,1
 d0062d0:	3105883a 	add	r2,r6,r4
 d0062d4:	b0806526 	beq	r22,r2,d00646c <_dtoa_r+0xb80>
 d0062d8:	d9400717 	ldw	r5,28(sp)
 d0062dc:	d9001617 	ldw	r4,88(sp)
 d0062e0:	01800284 	movi	r6,10
 d0062e4:	000f883a 	mov	r7,zero
 d0062e8:	d0097080 	call	d009708 <__multadd>
 d0062ec:	d8800715 	stw	r2,28(sp)
 d0062f0:	d8800617 	ldw	r2,24(sp)
 d0062f4:	14c10c26 	beq	r2,r19,d006728 <_dtoa_r+0xe3c>
 d0062f8:	d9400617 	ldw	r5,24(sp)
 d0062fc:	d9001617 	ldw	r4,88(sp)
 d006300:	01800284 	movi	r6,10
 d006304:	000f883a 	mov	r7,zero
 d006308:	d0097080 	call	d009708 <__multadd>
 d00630c:	d9001617 	ldw	r4,88(sp)
 d006310:	980b883a 	mov	r5,r19
 d006314:	01800284 	movi	r6,10
 d006318:	000f883a 	mov	r7,zero
 d00631c:	d8800615 	stw	r2,24(sp)
 d006320:	d0097080 	call	d009708 <__multadd>
 d006324:	1027883a 	mov	r19,r2
 d006328:	003fc206 	br	d006234 <_dtoa_r+0x948>
 d00632c:	2445c83a 	sub	r2,r4,r17
 d006330:	a088983a 	sll	r4,r20,r2
 d006334:	003e4b06 	br	d005c64 <_dtoa_r+0x378>
 d006338:	01bfffc4 	movi	r6,-1
 d00633c:	00800044 	movi	r2,1
 d006340:	d9800e15 	stw	r6,56(sp)
 d006344:	d9800f15 	stw	r6,60(sp)
 d006348:	d8800b15 	stw	r2,44(sp)
 d00634c:	d8c01617 	ldw	r3,88(sp)
 d006350:	008005c4 	movi	r2,23
 d006354:	18001115 	stw	zero,68(r3)
 d006358:	1580082e 	bgeu	r2,r22,d00637c <_dtoa_r+0xa90>
 d00635c:	00c00104 	movi	r3,4
 d006360:	0009883a 	mov	r4,zero
 d006364:	18c7883a 	add	r3,r3,r3
 d006368:	18800504 	addi	r2,r3,20
 d00636c:	21000044 	addi	r4,r4,1
 d006370:	b0bffc2e 	bgeu	r22,r2,d006364 <_dtoa_r+0xa78>
 d006374:	d9801617 	ldw	r6,88(sp)
 d006378:	31001115 	stw	r4,68(r6)
 d00637c:	dc000f17 	ldw	r16,60(sp)
 d006380:	003e4b06 	br	d005cb0 <_dtoa_r+0x3c4>
 d006384:	d9801717 	ldw	r6,92(sp)
 d006388:	0023883a 	mov	r17,zero
 d00638c:	31bfff04 	addi	r6,r6,-4
 d006390:	d9801715 	stw	r6,92(sp)
 d006394:	003df806 	br	d005b78 <_dtoa_r+0x28c>
 d006398:	00800804 	movi	r2,32
 d00639c:	10c9c83a 	sub	r4,r2,r3
 d0063a0:	00c00104 	movi	r3,4
 d0063a4:	19005a16 	blt	r3,r4,d006510 <_dtoa_r+0xc24>
 d0063a8:	008000c4 	movi	r2,3
 d0063ac:	113f7e16 	blt	r2,r4,d0061a8 <_dtoa_r+0x8bc>
 d0063b0:	20800704 	addi	r2,r4,28
 d0063b4:	003f7506 	br	d00618c <_dtoa_r+0x8a0>
 d0063b8:	d9801717 	ldw	r6,92(sp)
 d0063bc:	00800044 	movi	r2,1
 d0063c0:	1180a10e 	bge	r2,r6,d006648 <_dtoa_r+0xd5c>
 d0063c4:	d9800f17 	ldw	r6,60(sp)
 d0063c8:	d8c01017 	ldw	r3,64(sp)
 d0063cc:	30bfffc4 	addi	r2,r6,-1
 d0063d0:	1881c616 	blt	r3,r2,d006aec <_dtoa_r+0x1200>
 d0063d4:	18a5c83a 	sub	r18,r3,r2
 d0063d8:	d8800f17 	ldw	r2,60(sp)
 d0063dc:	10026216 	blt	r2,zero,d006d68 <_dtoa_r+0x147c>
 d0063e0:	dc001117 	ldw	r16,68(sp)
 d0063e4:	1007883a 	mov	r3,r2
 d0063e8:	d9800a17 	ldw	r6,40(sp)
 d0063ec:	d8801117 	ldw	r2,68(sp)
 d0063f0:	d9001617 	ldw	r4,88(sp)
 d0063f4:	30cd883a 	add	r6,r6,r3
 d0063f8:	10c5883a 	add	r2,r2,r3
 d0063fc:	01400044 	movi	r5,1
 d006400:	d9800a15 	stw	r6,40(sp)
 d006404:	d8801115 	stw	r2,68(sp)
 d006408:	d0096cc0 	call	d0096cc <__i2b>
 d00640c:	1027883a 	mov	r19,r2
 d006410:	003f2506 	br	d0060a8 <_dtoa_r+0x7bc>
 d006414:	00c34174 	movhi	r3,3333
 d006418:	18f8c704 	addi	r3,r3,-7396
 d00641c:	003d6706 	br	d0059bc <_dtoa_r+0xd0>
 d006420:	dd800517 	ldw	r22,20(sp)
 d006424:	04000044 	movi	r16,1
 d006428:	00000706 	br	d006448 <_dtoa_r+0xb5c>
 d00642c:	d9400717 	ldw	r5,28(sp)
 d006430:	d9001617 	ldw	r4,88(sp)
 d006434:	01800284 	movi	r6,10
 d006438:	000f883a 	mov	r7,zero
 d00643c:	d0097080 	call	d009708 <__multadd>
 d006440:	d8800715 	stw	r2,28(sp)
 d006444:	84000044 	addi	r16,r16,1
 d006448:	d9000717 	ldw	r4,28(sp)
 d00644c:	900b883a 	mov	r5,r18
 d006450:	d0056a80 	call	d0056a8 <quorem>
 d006454:	15c00c04 	addi	r23,r2,48
 d006458:	b5c00005 	stb	r23,0(r22)
 d00645c:	d8c00f17 	ldw	r3,60(sp)
 d006460:	b5800044 	addi	r22,r22,1
 d006464:	80fff116 	blt	r16,r3,d00642c <_dtoa_r+0xb40>
 d006468:	d8000615 	stw	zero,24(sp)
 d00646c:	d9400717 	ldw	r5,28(sp)
 d006470:	d9001617 	ldw	r4,88(sp)
 d006474:	01800044 	movi	r6,1
 d006478:	d00932c0 	call	d00932c <__lshift>
 d00647c:	1009883a 	mov	r4,r2
 d006480:	900b883a 	mov	r5,r18
 d006484:	d8800715 	stw	r2,28(sp)
 d006488:	d008b440 	call	d008b44 <__mcmp>
 d00648c:	00803c0e 	bge	zero,r2,d006580 <_dtoa_r+0xc94>
 d006490:	b009883a 	mov	r4,r22
 d006494:	213fffc4 	addi	r4,r4,-1
 d006498:	21400003 	ldbu	r5,0(r4)
 d00649c:	00800e44 	movi	r2,57
 d0064a0:	28c03fcc 	andi	r3,r5,255
 d0064a4:	18c0201c 	xori	r3,r3,128
 d0064a8:	18ffe004 	addi	r3,r3,-128
 d0064ac:	1881981e 	bne	r3,r2,d006b10 <_dtoa_r+0x1224>
 d0064b0:	d9800517 	ldw	r6,20(sp)
 d0064b4:	21bff71e 	bne	r4,r6,d006494 <_dtoa_r+0xba8>
 d0064b8:	d8800d17 	ldw	r2,52(sp)
 d0064bc:	37000044 	addi	fp,r6,1
 d0064c0:	10800044 	addi	r2,r2,1
 d0064c4:	d8800d15 	stw	r2,52(sp)
 d0064c8:	00800c44 	movi	r2,49
 d0064cc:	30800005 	stb	r2,0(r6)
 d0064d0:	d9001617 	ldw	r4,88(sp)
 d0064d4:	900b883a 	mov	r5,r18
 d0064d8:	d0089e80 	call	d0089e8 <_Bfree>
 d0064dc:	983ecd26 	beq	r19,zero,d006014 <_dtoa_r+0x728>
 d0064e0:	d8c00617 	ldw	r3,24(sp)
 d0064e4:	18000426 	beq	r3,zero,d0064f8 <_dtoa_r+0xc0c>
 d0064e8:	1cc00326 	beq	r3,r19,d0064f8 <_dtoa_r+0xc0c>
 d0064ec:	d9001617 	ldw	r4,88(sp)
 d0064f0:	180b883a 	mov	r5,r3
 d0064f4:	d0089e80 	call	d0089e8 <_Bfree>
 d0064f8:	d9001617 	ldw	r4,88(sp)
 d0064fc:	980b883a 	mov	r5,r19
 d006500:	d0089e80 	call	d0089e8 <_Bfree>
 d006504:	003ec306 	br	d006014 <_dtoa_r+0x728>
 d006508:	1805883a 	mov	r2,r3
 d00650c:	003eeb06 	br	d0060bc <_dtoa_r+0x7d0>
 d006510:	d9800a17 	ldw	r6,40(sp)
 d006514:	d8c01117 	ldw	r3,68(sp)
 d006518:	20bfff04 	addi	r2,r4,-4
 d00651c:	308d883a 	add	r6,r6,r2
 d006520:	1887883a 	add	r3,r3,r2
 d006524:	80a1883a 	add	r16,r16,r2
 d006528:	d9800a15 	stw	r6,40(sp)
 d00652c:	d8c01115 	stw	r3,68(sp)
 d006530:	003f1d06 	br	d0061a8 <_dtoa_r+0x8bc>
 d006534:	a03f0c1e 	bne	r20,zero,d006168 <_dtoa_r+0x87c>
 d006538:	00800434 	movhi	r2,16
 d00653c:	10bfffc4 	addi	r2,r2,-1
 d006540:	a884703a 	and	r2,r21,r2
 d006544:	103f081e 	bne	r2,zero,d006168 <_dtoa_r+0x87c>
 d006548:	a89ffc2c 	andhi	r2,r21,32752
 d00654c:	103f0626 	beq	r2,zero,d006168 <_dtoa_r+0x87c>
 d006550:	d8c01117 	ldw	r3,68(sp)
 d006554:	d9000a17 	ldw	r4,40(sp)
 d006558:	18c00044 	addi	r3,r3,1
 d00655c:	21000044 	addi	r4,r4,1
 d006560:	d8c01115 	stw	r3,68(sp)
 d006564:	d9000a15 	stw	r4,40(sp)
 d006568:	003f0006 	br	d00616c <_dtoa_r+0x880>
 d00656c:	d9400717 	ldw	r5,28(sp)
 d006570:	d9001617 	ldw	r4,88(sp)
 d006574:	d0098340 	call	d009834 <__pow5mult>
 d006578:	d8800715 	stw	r2,28(sp)
 d00657c:	003eed06 	br	d006134 <_dtoa_r+0x848>
 d006580:	1000021e 	bne	r2,zero,d00658c <_dtoa_r+0xca0>
 d006584:	b880004c 	andi	r2,r23,1
 d006588:	103fc11e 	bne	r2,zero,d006490 <_dtoa_r+0xba4>
 d00658c:	b5bfffc4 	addi	r22,r22,-1
 d006590:	b0c00007 	ldb	r3,0(r22)
 d006594:	00800c04 	movi	r2,48
 d006598:	18bffc26 	beq	r3,r2,d00658c <_dtoa_r+0xca0>
 d00659c:	b7000044 	addi	fp,r22,1
 d0065a0:	003fcb06 	br	d0064d0 <_dtoa_r+0xbe4>
 d0065a4:	d9800d17 	ldw	r6,52(sp)
 d0065a8:	018fc83a 	sub	r7,zero,r6
 d0065ac:	3801f726 	beq	r7,zero,d006d8c <_dtoa_r+0x14a0>
 d0065b0:	398003cc 	andi	r6,r7,15
 d0065b4:	300c90fa 	slli	r6,r6,3
 d0065b8:	01434174 	movhi	r5,3333
 d0065bc:	2978e404 	addi	r5,r5,-7280
 d0065c0:	d9001217 	ldw	r4,72(sp)
 d0065c4:	314d883a 	add	r6,r6,r5
 d0065c8:	30c00117 	ldw	r3,4(r6)
 d0065cc:	30800017 	ldw	r2,0(r6)
 d0065d0:	d9401317 	ldw	r5,76(sp)
 d0065d4:	3821d13a 	srai	r16,r7,4
 d0065d8:	100d883a 	mov	r6,r2
 d0065dc:	180f883a 	mov	r7,r3
 d0065e0:	d00bba80 	call	d00bba8 <__muldf3>
 d0065e4:	1011883a 	mov	r8,r2
 d0065e8:	1813883a 	mov	r9,r3
 d0065ec:	1029883a 	mov	r20,r2
 d0065f0:	182b883a 	mov	r21,r3
 d0065f4:	8001e526 	beq	r16,zero,d006d8c <_dtoa_r+0x14a0>
 d0065f8:	05800084 	movi	r22,2
 d0065fc:	04434174 	movhi	r17,3333
 d006600:	8c791604 	addi	r17,r17,-7080
 d006604:	8080004c 	andi	r2,r16,1
 d006608:	1005003a 	cmpeq	r2,r2,zero
 d00660c:	1000081e 	bne	r2,zero,d006630 <_dtoa_r+0xd44>
 d006610:	89800017 	ldw	r6,0(r17)
 d006614:	89c00117 	ldw	r7,4(r17)
 d006618:	480b883a 	mov	r5,r9
 d00661c:	4009883a 	mov	r4,r8
 d006620:	d00bba80 	call	d00bba8 <__muldf3>
 d006624:	1011883a 	mov	r8,r2
 d006628:	b5800044 	addi	r22,r22,1
 d00662c:	1813883a 	mov	r9,r3
 d006630:	8021d07a 	srai	r16,r16,1
 d006634:	8c400204 	addi	r17,r17,8
 d006638:	803ff21e 	bne	r16,zero,d006604 <_dtoa_r+0xd18>
 d00663c:	4029883a 	mov	r20,r8
 d006640:	482b883a 	mov	r21,r9
 d006644:	003dca06 	br	d005d70 <_dtoa_r+0x484>
 d006648:	d9000817 	ldw	r4,32(sp)
 d00664c:	2005003a 	cmpeq	r2,r4,zero
 d006650:	1001f61e 	bne	r2,zero,d006e2c <_dtoa_r+0x1540>
 d006654:	dc001117 	ldw	r16,68(sp)
 d006658:	dc801017 	ldw	r18,64(sp)
 d00665c:	18c10cc4 	addi	r3,r3,1075
 d006660:	003f6106 	br	d0063e8 <_dtoa_r+0xafc>
 d006664:	d8000b15 	stw	zero,44(sp)
 d006668:	d9802617 	ldw	r6,152(sp)
 d00666c:	d8c00d17 	ldw	r3,52(sp)
 d006670:	30800044 	addi	r2,r6,1
 d006674:	18ad883a 	add	r22,r3,r2
 d006678:	b13fffc4 	addi	r4,r22,-1
 d00667c:	d9000e15 	stw	r4,56(sp)
 d006680:	0581f60e 	bge	zero,r22,d006e5c <_dtoa_r+0x1570>
 d006684:	dd800f15 	stw	r22,60(sp)
 d006688:	003f3006 	br	d00634c <_dtoa_r+0xa60>
 d00668c:	d8000b15 	stw	zero,44(sp)
 d006690:	d9002617 	ldw	r4,152(sp)
 d006694:	0101eb0e 	bge	zero,r4,d006e44 <_dtoa_r+0x1558>
 d006698:	202d883a 	mov	r22,r4
 d00669c:	d9000e15 	stw	r4,56(sp)
 d0066a0:	d9000f15 	stw	r4,60(sp)
 d0066a4:	003f2906 	br	d00634c <_dtoa_r+0xa60>
 d0066a8:	01800044 	movi	r6,1
 d0066ac:	d9800b15 	stw	r6,44(sp)
 d0066b0:	003ff706 	br	d006690 <_dtoa_r+0xda4>
 d0066b4:	01000044 	movi	r4,1
 d0066b8:	d9000b15 	stw	r4,44(sp)
 d0066bc:	003fea06 	br	d006668 <_dtoa_r+0xd7c>
 d0066c0:	04000c0e 	bge	zero,r16,d0066f4 <_dtoa_r+0xe08>
 d0066c4:	d9400717 	ldw	r5,28(sp)
 d0066c8:	d9001617 	ldw	r4,88(sp)
 d0066cc:	01800044 	movi	r6,1
 d0066d0:	d00932c0 	call	d00932c <__lshift>
 d0066d4:	1009883a 	mov	r4,r2
 d0066d8:	900b883a 	mov	r5,r18
 d0066dc:	d8800715 	stw	r2,28(sp)
 d0066e0:	d008b440 	call	d008b44 <__mcmp>
 d0066e4:	0081e00e 	bge	zero,r2,d006e68 <_dtoa_r+0x157c>
 d0066e8:	bdc00044 	addi	r23,r23,1
 d0066ec:	00800e84 	movi	r2,58
 d0066f0:	b881a226 	beq	r23,r2,d006d7c <_dtoa_r+0x1490>
 d0066f4:	b7000044 	addi	fp,r22,1
 d0066f8:	b5c00005 	stb	r23,0(r22)
 d0066fc:	003f7406 	br	d0064d0 <_dtoa_r+0xbe4>
 d006700:	00800e44 	movi	r2,57
 d006704:	b8819d26 	beq	r23,r2,d006d7c <_dtoa_r+0x1490>
 d006708:	053ffa0e 	bge	zero,r20,d0066f4 <_dtoa_r+0xe08>
 d00670c:	8dc00c44 	addi	r23,r17,49
 d006710:	003ff806 	br	d0066f4 <_dtoa_r+0xe08>
 d006714:	d9001617 	ldw	r4,88(sp)
 d006718:	a80b883a 	mov	r5,r21
 d00671c:	04000044 	movi	r16,1
 d006720:	d0089e80 	call	d0089e8 <_Bfree>
 d006724:	003edf06 	br	d0062a4 <_dtoa_r+0x9b8>
 d006728:	d9001617 	ldw	r4,88(sp)
 d00672c:	980b883a 	mov	r5,r19
 d006730:	01800284 	movi	r6,10
 d006734:	000f883a 	mov	r7,zero
 d006738:	d0097080 	call	d009708 <__multadd>
 d00673c:	1027883a 	mov	r19,r2
 d006740:	d8800615 	stw	r2,24(sp)
 d006744:	003ebb06 	br	d006234 <_dtoa_r+0x948>
 d006748:	d9801117 	ldw	r6,68(sp)
 d00674c:	d8800d17 	ldw	r2,52(sp)
 d006750:	d8000915 	stw	zero,36(sp)
 d006754:	308dc83a 	sub	r6,r6,r2
 d006758:	0087c83a 	sub	r3,zero,r2
 d00675c:	d9801115 	stw	r6,68(sp)
 d006760:	d8c01015 	stw	r3,64(sp)
 d006764:	003cfe06 	br	d005b60 <_dtoa_r+0x274>
 d006768:	018dc83a 	sub	r6,zero,r6
 d00676c:	d9801115 	stw	r6,68(sp)
 d006770:	d8000a15 	stw	zero,40(sp)
 d006774:	003cf306 	br	d005b44 <_dtoa_r+0x258>
 d006778:	d9000d17 	ldw	r4,52(sp)
 d00677c:	d00c46c0 	call	d00c46c <__floatsidf>
 d006780:	880b883a 	mov	r5,r17
 d006784:	8009883a 	mov	r4,r16
 d006788:	180f883a 	mov	r7,r3
 d00678c:	100d883a 	mov	r6,r2
 d006790:	d00c24c0 	call	d00c24c <__nedf2>
 d006794:	103ce126 	beq	r2,zero,d005b1c <_dtoa_r+0x230>
 d006798:	d9800d17 	ldw	r6,52(sp)
 d00679c:	31bfffc4 	addi	r6,r6,-1
 d0067a0:	d9800d15 	stw	r6,52(sp)
 d0067a4:	003cdd06 	br	d005b1c <_dtoa_r+0x230>
 d0067a8:	d9000717 	ldw	r4,28(sp)
 d0067ac:	900b883a 	mov	r5,r18
 d0067b0:	d008b440 	call	d008b44 <__mcmp>
 d0067b4:	103e8d0e 	bge	r2,zero,d0061ec <_dtoa_r+0x900>
 d0067b8:	d9400717 	ldw	r5,28(sp)
 d0067bc:	d9001617 	ldw	r4,88(sp)
 d0067c0:	01800284 	movi	r6,10
 d0067c4:	000f883a 	mov	r7,zero
 d0067c8:	d0097080 	call	d009708 <__multadd>
 d0067cc:	d9800d17 	ldw	r6,52(sp)
 d0067d0:	d8800715 	stw	r2,28(sp)
 d0067d4:	31bfffc4 	addi	r6,r6,-1
 d0067d8:	d9800d15 	stw	r6,52(sp)
 d0067dc:	b001a71e 	bne	r22,zero,d006e7c <_dtoa_r+0x1590>
 d0067e0:	d8800e17 	ldw	r2,56(sp)
 d0067e4:	d8800f15 	stw	r2,60(sp)
 d0067e8:	003e8006 	br	d0061ec <_dtoa_r+0x900>
 d0067ec:	90800417 	ldw	r2,16(r18)
 d0067f0:	1085883a 	add	r2,r2,r2
 d0067f4:	1085883a 	add	r2,r2,r2
 d0067f8:	1485883a 	add	r2,r2,r18
 d0067fc:	11000417 	ldw	r4,16(r2)
 d006800:	d008a100 	call	d008a10 <__hi0bits>
 d006804:	00c00804 	movi	r3,32
 d006808:	1887c83a 	sub	r3,r3,r2
 d00680c:	003e5a06 	br	d006178 <_dtoa_r+0x88c>
 d006810:	d9400717 	ldw	r5,28(sp)
 d006814:	d9801017 	ldw	r6,64(sp)
 d006818:	d9001617 	ldw	r4,88(sp)
 d00681c:	d0098340 	call	d009834 <__pow5mult>
 d006820:	d8800715 	stw	r2,28(sp)
 d006824:	003e4306 	br	d006134 <_dtoa_r+0x848>
 d006828:	d9800f17 	ldw	r6,60(sp)
 d00682c:	d8800d17 	ldw	r2,52(sp)
 d006830:	d9800315 	stw	r6,12(sp)
 d006834:	d8800415 	stw	r2,16(sp)
 d006838:	d8c00b17 	ldw	r3,44(sp)
 d00683c:	1805003a 	cmpeq	r2,r3,zero
 d006840:	1000e21e 	bne	r2,zero,d006bcc <_dtoa_r+0x12e0>
 d006844:	d9000317 	ldw	r4,12(sp)
 d006848:	0005883a 	mov	r2,zero
 d00684c:	00cff834 	movhi	r3,16352
 d006850:	200c90fa 	slli	r6,r4,3
 d006854:	01034174 	movhi	r4,3333
 d006858:	2138e404 	addi	r4,r4,-7280
 d00685c:	180b883a 	mov	r5,r3
 d006860:	310d883a 	add	r6,r6,r4
 d006864:	327fff17 	ldw	r9,-4(r6)
 d006868:	323ffe17 	ldw	r8,-8(r6)
 d00686c:	1009883a 	mov	r4,r2
 d006870:	480f883a 	mov	r7,r9
 d006874:	400d883a 	mov	r6,r8
 d006878:	d00bf6c0 	call	d00bf6c <__divdf3>
 d00687c:	180b883a 	mov	r5,r3
 d006880:	b00d883a 	mov	r6,r22
 d006884:	b80f883a 	mov	r7,r23
 d006888:	1009883a 	mov	r4,r2
 d00688c:	d00bab40 	call	d00bab4 <__subdf3>
 d006890:	a80b883a 	mov	r5,r21
 d006894:	a009883a 	mov	r4,r20
 d006898:	d8c01915 	stw	r3,100(sp)
 d00689c:	d8801815 	stw	r2,96(sp)
 d0068a0:	d00c5640 	call	d00c564 <__fixdfsi>
 d0068a4:	1009883a 	mov	r4,r2
 d0068a8:	1027883a 	mov	r19,r2
 d0068ac:	d00c46c0 	call	d00c46c <__floatsidf>
 d0068b0:	a80b883a 	mov	r5,r21
 d0068b4:	a009883a 	mov	r4,r20
 d0068b8:	180f883a 	mov	r7,r3
 d0068bc:	100d883a 	mov	r6,r2
 d0068c0:	d00bab40 	call	d00bab4 <__subdf3>
 d0068c4:	d9801817 	ldw	r6,96(sp)
 d0068c8:	1823883a 	mov	r17,r3
 d0068cc:	d8801415 	stw	r2,80(sp)
 d0068d0:	302d883a 	mov	r22,r6
 d0068d4:	d9800517 	ldw	r6,20(sp)
 d0068d8:	9cc00c04 	addi	r19,r19,48
 d0068dc:	dc401515 	stw	r17,84(sp)
 d0068e0:	d8c01917 	ldw	r3,100(sp)
 d0068e4:	34c00005 	stb	r19,0(r6)
 d0068e8:	d8800517 	ldw	r2,20(sp)
 d0068ec:	d9401917 	ldw	r5,100(sp)
 d0068f0:	d9801417 	ldw	r6,80(sp)
 d0068f4:	b009883a 	mov	r4,r22
 d0068f8:	880f883a 	mov	r7,r17
 d0068fc:	182f883a 	mov	r23,r3
 d006900:	17000044 	addi	fp,r2,1
 d006904:	d00c2d40 	call	d00c2d4 <__gtdf2>
 d006908:	00804e16 	blt	zero,r2,d006a44 <_dtoa_r+0x1158>
 d00690c:	d9801417 	ldw	r6,80(sp)
 d006910:	0005883a 	mov	r2,zero
 d006914:	00cffc34 	movhi	r3,16368
 d006918:	180b883a 	mov	r5,r3
 d00691c:	880f883a 	mov	r7,r17
 d006920:	1009883a 	mov	r4,r2
 d006924:	d00bab40 	call	d00bab4 <__subdf3>
 d006928:	d9401917 	ldw	r5,100(sp)
 d00692c:	180f883a 	mov	r7,r3
 d006930:	b009883a 	mov	r4,r22
 d006934:	100d883a 	mov	r6,r2
 d006938:	d00c2d40 	call	d00c2d4 <__gtdf2>
 d00693c:	00bda216 	blt	zero,r2,d005fc8 <_dtoa_r+0x6dc>
 d006940:	d8c00317 	ldw	r3,12(sp)
 d006944:	00800044 	movi	r2,1
 d006948:	10c01216 	blt	r2,r3,d006994 <_dtoa_r+0x10a8>
 d00694c:	003d4506 	br	d005e64 <_dtoa_r+0x578>
 d006950:	d9801417 	ldw	r6,80(sp)
 d006954:	0005883a 	mov	r2,zero
 d006958:	00cffc34 	movhi	r3,16368
 d00695c:	180b883a 	mov	r5,r3
 d006960:	880f883a 	mov	r7,r17
 d006964:	1009883a 	mov	r4,r2
 d006968:	d00bab40 	call	d00bab4 <__subdf3>
 d00696c:	d9c01b17 	ldw	r7,108(sp)
 d006970:	180b883a 	mov	r5,r3
 d006974:	1009883a 	mov	r4,r2
 d006978:	b00d883a 	mov	r6,r22
 d00697c:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d006980:	103d9116 	blt	r2,zero,d005fc8 <_dtoa_r+0x6dc>
 d006984:	d9800517 	ldw	r6,20(sp)
 d006988:	d9000317 	ldw	r4,12(sp)
 d00698c:	3105883a 	add	r2,r6,r4
 d006990:	e0bd3426 	beq	fp,r2,d005e64 <_dtoa_r+0x578>
 d006994:	04500934 	movhi	r17,16420
 d006998:	0021883a 	mov	r16,zero
 d00699c:	b80b883a 	mov	r5,r23
 d0069a0:	b009883a 	mov	r4,r22
 d0069a4:	800d883a 	mov	r6,r16
 d0069a8:	880f883a 	mov	r7,r17
 d0069ac:	d00bba80 	call	d00bba8 <__muldf3>
 d0069b0:	d9401517 	ldw	r5,84(sp)
 d0069b4:	d9001417 	ldw	r4,80(sp)
 d0069b8:	880f883a 	mov	r7,r17
 d0069bc:	000d883a 	mov	r6,zero
 d0069c0:	d8801a15 	stw	r2,104(sp)
 d0069c4:	d8c01b15 	stw	r3,108(sp)
 d0069c8:	d00bba80 	call	d00bba8 <__muldf3>
 d0069cc:	180b883a 	mov	r5,r3
 d0069d0:	1009883a 	mov	r4,r2
 d0069d4:	1823883a 	mov	r17,r3
 d0069d8:	1021883a 	mov	r16,r2
 d0069dc:	d00c5640 	call	d00c564 <__fixdfsi>
 d0069e0:	1009883a 	mov	r4,r2
 d0069e4:	102b883a 	mov	r21,r2
 d0069e8:	d00c46c0 	call	d00c46c <__floatsidf>
 d0069ec:	880b883a 	mov	r5,r17
 d0069f0:	8009883a 	mov	r4,r16
 d0069f4:	180f883a 	mov	r7,r3
 d0069f8:	100d883a 	mov	r6,r2
 d0069fc:	d00bab40 	call	d00bab4 <__subdf3>
 d006a00:	1021883a 	mov	r16,r2
 d006a04:	d9001b17 	ldw	r4,108(sp)
 d006a08:	1823883a 	mov	r17,r3
 d006a0c:	dc001415 	stw	r16,80(sp)
 d006a10:	ad400c04 	addi	r21,r21,48
 d006a14:	dc401515 	stw	r17,84(sp)
 d006a18:	d8801a17 	ldw	r2,104(sp)
 d006a1c:	e5400005 	stb	r21,0(fp)
 d006a20:	202f883a 	mov	r23,r4
 d006a24:	d9c01b17 	ldw	r7,108(sp)
 d006a28:	d9001417 	ldw	r4,80(sp)
 d006a2c:	880b883a 	mov	r5,r17
 d006a30:	100d883a 	mov	r6,r2
 d006a34:	102d883a 	mov	r22,r2
 d006a38:	e7000044 	addi	fp,fp,1
 d006a3c:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d006a40:	103fc30e 	bge	r2,zero,d006950 <_dtoa_r+0x1064>
 d006a44:	d9000417 	ldw	r4,16(sp)
 d006a48:	d9000d15 	stw	r4,52(sp)
 d006a4c:	003d7106 	br	d006014 <_dtoa_r+0x728>
 d006a50:	d9801717 	ldw	r6,92(sp)
 d006a54:	00800084 	movi	r2,2
 d006a58:	11bde60e 	bge	r2,r6,d0061f4 <_dtoa_r+0x908>
 d006a5c:	203cfb1e 	bne	r4,zero,d005e4c <_dtoa_r+0x560>
 d006a60:	d9001617 	ldw	r4,88(sp)
 d006a64:	900b883a 	mov	r5,r18
 d006a68:	01800144 	movi	r6,5
 d006a6c:	000f883a 	mov	r7,zero
 d006a70:	d0097080 	call	d009708 <__multadd>
 d006a74:	d9000717 	ldw	r4,28(sp)
 d006a78:	100b883a 	mov	r5,r2
 d006a7c:	1025883a 	mov	r18,r2
 d006a80:	d008b440 	call	d008b44 <__mcmp>
 d006a84:	00bcf10e 	bge	zero,r2,d005e4c <_dtoa_r+0x560>
 d006a88:	d8c00d17 	ldw	r3,52(sp)
 d006a8c:	d9000517 	ldw	r4,20(sp)
 d006a90:	d8000615 	stw	zero,24(sp)
 d006a94:	18c00044 	addi	r3,r3,1
 d006a98:	d8c00d15 	stw	r3,52(sp)
 d006a9c:	00800c44 	movi	r2,49
 d006aa0:	27000044 	addi	fp,r4,1
 d006aa4:	20800005 	stb	r2,0(r4)
 d006aa8:	003e8906 	br	d0064d0 <_dtoa_r+0xbe4>
 d006aac:	d8c00517 	ldw	r3,20(sp)
 d006ab0:	003bc206 	br	d0059bc <_dtoa_r+0xd0>
 d006ab4:	01834174 	movhi	r6,3333
 d006ab8:	31b91604 	addi	r6,r6,-7080
 d006abc:	30c00917 	ldw	r3,36(r6)
 d006ac0:	30800817 	ldw	r2,32(r6)
 d006ac4:	d9001217 	ldw	r4,72(sp)
 d006ac8:	d9401317 	ldw	r5,76(sp)
 d006acc:	180f883a 	mov	r7,r3
 d006ad0:	100d883a 	mov	r6,r2
 d006ad4:	d00bf6c0 	call	d00bf6c <__divdf3>
 d006ad8:	948003cc 	andi	r18,r18,15
 d006adc:	058000c4 	movi	r22,3
 d006ae0:	1029883a 	mov	r20,r2
 d006ae4:	182b883a 	mov	r21,r3
 d006ae8:	003c8906 	br	d005d10 <_dtoa_r+0x424>
 d006aec:	d9001017 	ldw	r4,64(sp)
 d006af0:	d9800917 	ldw	r6,36(sp)
 d006af4:	0025883a 	mov	r18,zero
 d006af8:	1105c83a 	sub	r2,r2,r4
 d006afc:	2089883a 	add	r4,r4,r2
 d006b00:	308d883a 	add	r6,r6,r2
 d006b04:	d9001015 	stw	r4,64(sp)
 d006b08:	d9800915 	stw	r6,36(sp)
 d006b0c:	003e3206 	br	d0063d8 <_dtoa_r+0xaec>
 d006b10:	28800044 	addi	r2,r5,1
 d006b14:	27000044 	addi	fp,r4,1
 d006b18:	20800005 	stb	r2,0(r4)
 d006b1c:	003e6c06 	br	d0064d0 <_dtoa_r+0xbe4>
 d006b20:	d8800f17 	ldw	r2,60(sp)
 d006b24:	00bce016 	blt	zero,r2,d005ea8 <_dtoa_r+0x5bc>
 d006b28:	d9800f17 	ldw	r6,60(sp)
 d006b2c:	303cc51e 	bne	r6,zero,d005e44 <_dtoa_r+0x558>
 d006b30:	0005883a 	mov	r2,zero
 d006b34:	00d00534 	movhi	r3,16404
 d006b38:	980b883a 	mov	r5,r19
 d006b3c:	180f883a 	mov	r7,r3
 d006b40:	9009883a 	mov	r4,r18
 d006b44:	100d883a 	mov	r6,r2
 d006b48:	d00bba80 	call	d00bba8 <__muldf3>
 d006b4c:	180b883a 	mov	r5,r3
 d006b50:	a80f883a 	mov	r7,r21
 d006b54:	1009883a 	mov	r4,r2
 d006b58:	a00d883a 	mov	r6,r20
 d006b5c:	d00c35c0 	call	d00c35c <__gedf2>
 d006b60:	103cb80e 	bge	r2,zero,d005e44 <_dtoa_r+0x558>
 d006b64:	0027883a 	mov	r19,zero
 d006b68:	0025883a 	mov	r18,zero
 d006b6c:	003fc606 	br	d006a88 <_dtoa_r+0x119c>
 d006b70:	99400117 	ldw	r5,4(r19)
 d006b74:	d9001617 	ldw	r4,88(sp)
 d006b78:	d008f680 	call	d008f68 <_Balloc>
 d006b7c:	99800417 	ldw	r6,16(r19)
 d006b80:	11000304 	addi	r4,r2,12
 d006b84:	99400304 	addi	r5,r19,12
 d006b88:	318d883a 	add	r6,r6,r6
 d006b8c:	318d883a 	add	r6,r6,r6
 d006b90:	31800204 	addi	r6,r6,8
 d006b94:	1023883a 	mov	r17,r2
 d006b98:	d0026080 	call	d002608 <memcpy>
 d006b9c:	d9001617 	ldw	r4,88(sp)
 d006ba0:	880b883a 	mov	r5,r17
 d006ba4:	01800044 	movi	r6,1
 d006ba8:	d00932c0 	call	d00932c <__lshift>
 d006bac:	100b883a 	mov	r5,r2
 d006bb0:	003d9c06 	br	d006224 <_dtoa_r+0x938>
 d006bb4:	00800e44 	movi	r2,57
 d006bb8:	b8807026 	beq	r23,r2,d006d7c <_dtoa_r+0x1490>
 d006bbc:	b8800044 	addi	r2,r23,1
 d006bc0:	b7000044 	addi	fp,r22,1
 d006bc4:	b0800005 	stb	r2,0(r22)
 d006bc8:	003e4106 	br	d0064d0 <_dtoa_r+0xbe4>
 d006bcc:	d8800317 	ldw	r2,12(sp)
 d006bd0:	01834174 	movhi	r6,3333
 d006bd4:	31b8e404 	addi	r6,r6,-7280
 d006bd8:	b009883a 	mov	r4,r22
 d006bdc:	100e90fa 	slli	r7,r2,3
 d006be0:	b80b883a 	mov	r5,r23
 d006be4:	398f883a 	add	r7,r7,r6
 d006be8:	38bffe17 	ldw	r2,-8(r7)
 d006bec:	d9800517 	ldw	r6,20(sp)
 d006bf0:	38ffff17 	ldw	r3,-4(r7)
 d006bf4:	37000044 	addi	fp,r6,1
 d006bf8:	180f883a 	mov	r7,r3
 d006bfc:	100d883a 	mov	r6,r2
 d006c00:	d00bba80 	call	d00bba8 <__muldf3>
 d006c04:	a80b883a 	mov	r5,r21
 d006c08:	a009883a 	mov	r4,r20
 d006c0c:	182f883a 	mov	r23,r3
 d006c10:	102d883a 	mov	r22,r2
 d006c14:	d00c5640 	call	d00c564 <__fixdfsi>
 d006c18:	1009883a 	mov	r4,r2
 d006c1c:	1027883a 	mov	r19,r2
 d006c20:	d00c46c0 	call	d00c46c <__floatsidf>
 d006c24:	a80b883a 	mov	r5,r21
 d006c28:	a009883a 	mov	r4,r20
 d006c2c:	180f883a 	mov	r7,r3
 d006c30:	100d883a 	mov	r6,r2
 d006c34:	d00bab40 	call	d00bab4 <__subdf3>
 d006c38:	180b883a 	mov	r5,r3
 d006c3c:	d8c00517 	ldw	r3,20(sp)
 d006c40:	9cc00c04 	addi	r19,r19,48
 d006c44:	1009883a 	mov	r4,r2
 d006c48:	1cc00005 	stb	r19,0(r3)
 d006c4c:	2021883a 	mov	r16,r4
 d006c50:	d9000317 	ldw	r4,12(sp)
 d006c54:	00800044 	movi	r2,1
 d006c58:	2823883a 	mov	r17,r5
 d006c5c:	20802226 	beq	r4,r2,d006ce8 <_dtoa_r+0x13fc>
 d006c60:	1029883a 	mov	r20,r2
 d006c64:	0005883a 	mov	r2,zero
 d006c68:	00d00934 	movhi	r3,16420
 d006c6c:	180f883a 	mov	r7,r3
 d006c70:	100d883a 	mov	r6,r2
 d006c74:	880b883a 	mov	r5,r17
 d006c78:	8009883a 	mov	r4,r16
 d006c7c:	d00bba80 	call	d00bba8 <__muldf3>
 d006c80:	180b883a 	mov	r5,r3
 d006c84:	1009883a 	mov	r4,r2
 d006c88:	1823883a 	mov	r17,r3
 d006c8c:	1021883a 	mov	r16,r2
 d006c90:	d00c5640 	call	d00c564 <__fixdfsi>
 d006c94:	1009883a 	mov	r4,r2
 d006c98:	102b883a 	mov	r21,r2
 d006c9c:	d00c46c0 	call	d00c46c <__floatsidf>
 d006ca0:	880b883a 	mov	r5,r17
 d006ca4:	8009883a 	mov	r4,r16
 d006ca8:	180f883a 	mov	r7,r3
 d006cac:	100d883a 	mov	r6,r2
 d006cb0:	d00bab40 	call	d00bab4 <__subdf3>
 d006cb4:	180b883a 	mov	r5,r3
 d006cb8:	d8c00517 	ldw	r3,20(sp)
 d006cbc:	1009883a 	mov	r4,r2
 d006cc0:	ad400c04 	addi	r21,r21,48
 d006cc4:	1d05883a 	add	r2,r3,r20
 d006cc8:	15400005 	stb	r21,0(r2)
 d006ccc:	2021883a 	mov	r16,r4
 d006cd0:	d9000317 	ldw	r4,12(sp)
 d006cd4:	a5000044 	addi	r20,r20,1
 d006cd8:	2823883a 	mov	r17,r5
 d006cdc:	a13fe11e 	bne	r20,r4,d006c64 <_dtoa_r+0x1378>
 d006ce0:	e505883a 	add	r2,fp,r20
 d006ce4:	173fffc4 	addi	fp,r2,-1
 d006ce8:	0025883a 	mov	r18,zero
 d006cec:	04cff834 	movhi	r19,16352
 d006cf0:	b009883a 	mov	r4,r22
 d006cf4:	b80b883a 	mov	r5,r23
 d006cf8:	900d883a 	mov	r6,r18
 d006cfc:	980f883a 	mov	r7,r19
 d006d00:	d00bb340 	call	d00bb34 <__adddf3>
 d006d04:	180b883a 	mov	r5,r3
 d006d08:	1009883a 	mov	r4,r2
 d006d0c:	800d883a 	mov	r6,r16
 d006d10:	880f883a 	mov	r7,r17
 d006d14:	d00c3e40 	call	d00c3e4 <__ltdf2>
 d006d18:	103cab16 	blt	r2,zero,d005fc8 <_dtoa_r+0x6dc>
 d006d1c:	0009883a 	mov	r4,zero
 d006d20:	980b883a 	mov	r5,r19
 d006d24:	b80f883a 	mov	r7,r23
 d006d28:	b00d883a 	mov	r6,r22
 d006d2c:	d00bab40 	call	d00bab4 <__subdf3>
 d006d30:	180b883a 	mov	r5,r3
 d006d34:	880f883a 	mov	r7,r17
 d006d38:	1009883a 	mov	r4,r2
 d006d3c:	800d883a 	mov	r6,r16
 d006d40:	d00c2d40 	call	d00c2d4 <__gtdf2>
 d006d44:	00bc470e 	bge	zero,r2,d005e64 <_dtoa_r+0x578>
 d006d48:	00c00c04 	movi	r3,48
 d006d4c:	e73fffc4 	addi	fp,fp,-1
 d006d50:	e0800007 	ldb	r2,0(fp)
 d006d54:	10fffd26 	beq	r2,r3,d006d4c <_dtoa_r+0x1460>
 d006d58:	d9800417 	ldw	r6,16(sp)
 d006d5c:	e7000044 	addi	fp,fp,1
 d006d60:	d9800d15 	stw	r6,52(sp)
 d006d64:	003cab06 	br	d006014 <_dtoa_r+0x728>
 d006d68:	d8c00f17 	ldw	r3,60(sp)
 d006d6c:	d9001117 	ldw	r4,68(sp)
 d006d70:	20e1c83a 	sub	r16,r4,r3
 d006d74:	0007883a 	mov	r3,zero
 d006d78:	003d9b06 	br	d0063e8 <_dtoa_r+0xafc>
 d006d7c:	00800e44 	movi	r2,57
 d006d80:	b0800005 	stb	r2,0(r22)
 d006d84:	b5800044 	addi	r22,r22,1
 d006d88:	003dc106 	br	d006490 <_dtoa_r+0xba4>
 d006d8c:	05800084 	movi	r22,2
 d006d90:	003bf706 	br	d005d70 <_dtoa_r+0x484>
 d006d94:	d9000f17 	ldw	r4,60(sp)
 d006d98:	013c000e 	bge	zero,r4,d005d9c <_dtoa_r+0x4b0>
 d006d9c:	d9800e17 	ldw	r6,56(sp)
 d006da0:	01bc300e 	bge	zero,r6,d005e64 <_dtoa_r+0x578>
 d006da4:	0005883a 	mov	r2,zero
 d006da8:	00d00934 	movhi	r3,16420
 d006dac:	a80b883a 	mov	r5,r21
 d006db0:	180f883a 	mov	r7,r3
 d006db4:	a009883a 	mov	r4,r20
 d006db8:	100d883a 	mov	r6,r2
 d006dbc:	d00bba80 	call	d00bba8 <__muldf3>
 d006dc0:	b1000044 	addi	r4,r22,1
 d006dc4:	1021883a 	mov	r16,r2
 d006dc8:	1823883a 	mov	r17,r3
 d006dcc:	d00c46c0 	call	d00c46c <__floatsidf>
 d006dd0:	880b883a 	mov	r5,r17
 d006dd4:	8009883a 	mov	r4,r16
 d006dd8:	180f883a 	mov	r7,r3
 d006ddc:	100d883a 	mov	r6,r2
 d006de0:	d00bba80 	call	d00bba8 <__muldf3>
 d006de4:	0011883a 	mov	r8,zero
 d006de8:	02500734 	movhi	r9,16412
 d006dec:	180b883a 	mov	r5,r3
 d006df0:	480f883a 	mov	r7,r9
 d006df4:	1009883a 	mov	r4,r2
 d006df8:	400d883a 	mov	r6,r8
 d006dfc:	d00bb340 	call	d00bb34 <__adddf3>
 d006e00:	102d883a 	mov	r22,r2
 d006e04:	00bf3034 	movhi	r2,64704
 d006e08:	10ef883a 	add	r23,r2,r3
 d006e0c:	d8800d17 	ldw	r2,52(sp)
 d006e10:	d8c00e17 	ldw	r3,56(sp)
 d006e14:	8029883a 	mov	r20,r16
 d006e18:	10bfffc4 	addi	r2,r2,-1
 d006e1c:	882b883a 	mov	r21,r17
 d006e20:	d8800415 	stw	r2,16(sp)
 d006e24:	d8c00315 	stw	r3,12(sp)
 d006e28:	003e8306 	br	d006838 <_dtoa_r+0xf4c>
 d006e2c:	d8800117 	ldw	r2,4(sp)
 d006e30:	dc001117 	ldw	r16,68(sp)
 d006e34:	dc801017 	ldw	r18,64(sp)
 d006e38:	00c00d84 	movi	r3,54
 d006e3c:	1887c83a 	sub	r3,r3,r2
 d006e40:	003d6906 	br	d0063e8 <_dtoa_r+0xafc>
 d006e44:	01800044 	movi	r6,1
 d006e48:	3021883a 	mov	r16,r6
 d006e4c:	d9800f15 	stw	r6,60(sp)
 d006e50:	d9802615 	stw	r6,152(sp)
 d006e54:	d9800e15 	stw	r6,56(sp)
 d006e58:	003b9306 	br	d005ca8 <_dtoa_r+0x3bc>
 d006e5c:	b021883a 	mov	r16,r22
 d006e60:	dd800f15 	stw	r22,60(sp)
 d006e64:	003b9006 	br	d005ca8 <_dtoa_r+0x3bc>
 d006e68:	103e221e 	bne	r2,zero,d0066f4 <_dtoa_r+0xe08>
 d006e6c:	b880004c 	andi	r2,r23,1
 d006e70:	1005003a 	cmpeq	r2,r2,zero
 d006e74:	103e1f1e 	bne	r2,zero,d0066f4 <_dtoa_r+0xe08>
 d006e78:	003e1b06 	br	d0066e8 <_dtoa_r+0xdfc>
 d006e7c:	d9001617 	ldw	r4,88(sp)
 d006e80:	980b883a 	mov	r5,r19
 d006e84:	01800284 	movi	r6,10
 d006e88:	000f883a 	mov	r7,zero
 d006e8c:	d0097080 	call	d009708 <__multadd>
 d006e90:	d8c00e17 	ldw	r3,56(sp)
 d006e94:	1027883a 	mov	r19,r2
 d006e98:	d8c00f15 	stw	r3,60(sp)
 d006e9c:	003cd306 	br	d0061ec <_dtoa_r+0x900>

0d006ea0 <_fflush_r>:
 d006ea0:	defffb04 	addi	sp,sp,-20
 d006ea4:	dcc00315 	stw	r19,12(sp)
 d006ea8:	dc800215 	stw	r18,8(sp)
 d006eac:	dfc00415 	stw	ra,16(sp)
 d006eb0:	dc400115 	stw	r17,4(sp)
 d006eb4:	dc000015 	stw	r16,0(sp)
 d006eb8:	2027883a 	mov	r19,r4
 d006ebc:	2825883a 	mov	r18,r5
 d006ec0:	20000226 	beq	r4,zero,d006ecc <_fflush_r+0x2c>
 d006ec4:	20800e17 	ldw	r2,56(r4)
 d006ec8:	10005626 	beq	r2,zero,d007024 <_fflush_r+0x184>
 d006ecc:	9100030b 	ldhu	r4,12(r18)
 d006ed0:	20ffffcc 	andi	r3,r4,65535
 d006ed4:	18e0001c 	xori	r3,r3,32768
 d006ed8:	18e00004 	addi	r3,r3,-32768
 d006edc:	1880020c 	andi	r2,r3,8
 d006ee0:	1000261e 	bne	r2,zero,d006f7c <_fflush_r+0xdc>
 d006ee4:	90c00117 	ldw	r3,4(r18)
 d006ee8:	20820014 	ori	r2,r4,2048
 d006eec:	9080030d 	sth	r2,12(r18)
 d006ef0:	1009883a 	mov	r4,r2
 d006ef4:	00c0400e 	bge	zero,r3,d006ff8 <_fflush_r+0x158>
 d006ef8:	92000a17 	ldw	r8,40(r18)
 d006efc:	40004026 	beq	r8,zero,d007000 <_fflush_r+0x160>
 d006f00:	2084000c 	andi	r2,r4,4096
 d006f04:	10005326 	beq	r2,zero,d007054 <_fflush_r+0x1b4>
 d006f08:	94001417 	ldw	r16,80(r18)
 d006f0c:	9080030b 	ldhu	r2,12(r18)
 d006f10:	1080010c 	andi	r2,r2,4
 d006f14:	1000481e 	bne	r2,zero,d007038 <_fflush_r+0x198>
 d006f18:	91400717 	ldw	r5,28(r18)
 d006f1c:	9809883a 	mov	r4,r19
 d006f20:	800d883a 	mov	r6,r16
 d006f24:	000f883a 	mov	r7,zero
 d006f28:	403ee83a 	callr	r8
 d006f2c:	8080261e 	bne	r16,r2,d006fc8 <_fflush_r+0x128>
 d006f30:	9080030b 	ldhu	r2,12(r18)
 d006f34:	91000417 	ldw	r4,16(r18)
 d006f38:	90000115 	stw	zero,4(r18)
 d006f3c:	10bdffcc 	andi	r2,r2,63487
 d006f40:	10ffffcc 	andi	r3,r2,65535
 d006f44:	18c4000c 	andi	r3,r3,4096
 d006f48:	9080030d 	sth	r2,12(r18)
 d006f4c:	91000015 	stw	r4,0(r18)
 d006f50:	18002b26 	beq	r3,zero,d007000 <_fflush_r+0x160>
 d006f54:	0007883a 	mov	r3,zero
 d006f58:	1805883a 	mov	r2,r3
 d006f5c:	94001415 	stw	r16,80(r18)
 d006f60:	dfc00417 	ldw	ra,16(sp)
 d006f64:	dcc00317 	ldw	r19,12(sp)
 d006f68:	dc800217 	ldw	r18,8(sp)
 d006f6c:	dc400117 	ldw	r17,4(sp)
 d006f70:	dc000017 	ldw	r16,0(sp)
 d006f74:	dec00504 	addi	sp,sp,20
 d006f78:	f800283a 	ret
 d006f7c:	94400417 	ldw	r17,16(r18)
 d006f80:	88001f26 	beq	r17,zero,d007000 <_fflush_r+0x160>
 d006f84:	90800017 	ldw	r2,0(r18)
 d006f88:	18c000cc 	andi	r3,r3,3
 d006f8c:	94400015 	stw	r17,0(r18)
 d006f90:	1461c83a 	sub	r16,r2,r17
 d006f94:	18002526 	beq	r3,zero,d00702c <_fflush_r+0x18c>
 d006f98:	0005883a 	mov	r2,zero
 d006f9c:	90800215 	stw	r2,8(r18)
 d006fa0:	0400170e 	bge	zero,r16,d007000 <_fflush_r+0x160>
 d006fa4:	90c00917 	ldw	r3,36(r18)
 d006fa8:	91400717 	ldw	r5,28(r18)
 d006fac:	880d883a 	mov	r6,r17
 d006fb0:	800f883a 	mov	r7,r16
 d006fb4:	9809883a 	mov	r4,r19
 d006fb8:	183ee83a 	callr	r3
 d006fbc:	88a3883a 	add	r17,r17,r2
 d006fc0:	80a1c83a 	sub	r16,r16,r2
 d006fc4:	00bff616 	blt	zero,r2,d006fa0 <_fflush_r+0x100>
 d006fc8:	9080030b 	ldhu	r2,12(r18)
 d006fcc:	00ffffc4 	movi	r3,-1
 d006fd0:	10801014 	ori	r2,r2,64
 d006fd4:	9080030d 	sth	r2,12(r18)
 d006fd8:	1805883a 	mov	r2,r3
 d006fdc:	dfc00417 	ldw	ra,16(sp)
 d006fe0:	dcc00317 	ldw	r19,12(sp)
 d006fe4:	dc800217 	ldw	r18,8(sp)
 d006fe8:	dc400117 	ldw	r17,4(sp)
 d006fec:	dc000017 	ldw	r16,0(sp)
 d006ff0:	dec00504 	addi	sp,sp,20
 d006ff4:	f800283a 	ret
 d006ff8:	90800f17 	ldw	r2,60(r18)
 d006ffc:	00bfbe16 	blt	zero,r2,d006ef8 <_fflush_r+0x58>
 d007000:	0007883a 	mov	r3,zero
 d007004:	1805883a 	mov	r2,r3
 d007008:	dfc00417 	ldw	ra,16(sp)
 d00700c:	dcc00317 	ldw	r19,12(sp)
 d007010:	dc800217 	ldw	r18,8(sp)
 d007014:	dc400117 	ldw	r17,4(sp)
 d007018:	dc000017 	ldw	r16,0(sp)
 d00701c:	dec00504 	addi	sp,sp,20
 d007020:	f800283a 	ret
 d007024:	d0071380 	call	d007138 <__sinit>
 d007028:	003fa806 	br	d006ecc <_fflush_r+0x2c>
 d00702c:	90800517 	ldw	r2,20(r18)
 d007030:	90800215 	stw	r2,8(r18)
 d007034:	003fda06 	br	d006fa0 <_fflush_r+0x100>
 d007038:	90800117 	ldw	r2,4(r18)
 d00703c:	90c00c17 	ldw	r3,48(r18)
 d007040:	80a1c83a 	sub	r16,r16,r2
 d007044:	183fb426 	beq	r3,zero,d006f18 <_fflush_r+0x78>
 d007048:	90800f17 	ldw	r2,60(r18)
 d00704c:	80a1c83a 	sub	r16,r16,r2
 d007050:	003fb106 	br	d006f18 <_fflush_r+0x78>
 d007054:	91400717 	ldw	r5,28(r18)
 d007058:	9809883a 	mov	r4,r19
 d00705c:	000d883a 	mov	r6,zero
 d007060:	01c00044 	movi	r7,1
 d007064:	403ee83a 	callr	r8
 d007068:	1021883a 	mov	r16,r2
 d00706c:	00bfffc4 	movi	r2,-1
 d007070:	80800226 	beq	r16,r2,d00707c <_fflush_r+0x1dc>
 d007074:	92000a17 	ldw	r8,40(r18)
 d007078:	003fa406 	br	d006f0c <_fflush_r+0x6c>
 d00707c:	98c00017 	ldw	r3,0(r19)
 d007080:	00800744 	movi	r2,29
 d007084:	18bfde26 	beq	r3,r2,d007000 <_fflush_r+0x160>
 d007088:	9080030b 	ldhu	r2,12(r18)
 d00708c:	8007883a 	mov	r3,r16
 d007090:	10801014 	ori	r2,r2,64
 d007094:	9080030d 	sth	r2,12(r18)
 d007098:	003fcf06 	br	d006fd8 <_fflush_r+0x138>

0d00709c <fflush>:
 d00709c:	01434034 	movhi	r5,3328
 d0070a0:	295ba804 	addi	r5,r5,28320
 d0070a4:	2007883a 	mov	r3,r4
 d0070a8:	20000526 	beq	r4,zero,d0070c0 <fflush+0x24>
 d0070ac:	00834174 	movhi	r2,3333
 d0070b0:	10922004 	addi	r2,r2,18560
 d0070b4:	11000017 	ldw	r4,0(r2)
 d0070b8:	180b883a 	mov	r5,r3
 d0070bc:	d006ea01 	jmpi	d006ea0 <_fflush_r>
 d0070c0:	00834174 	movhi	r2,3333
 d0070c4:	10922104 	addi	r2,r2,18564
 d0070c8:	11000017 	ldw	r4,0(r2)
 d0070cc:	d007dec1 	jmpi	d007dec <_fwalk_reent>

0d0070d0 <std>:
 d0070d0:	00834074 	movhi	r2,3329
 d0070d4:	10a8ca04 	addi	r2,r2,-23768
 d0070d8:	20800b15 	stw	r2,44(r4)
 d0070dc:	00834074 	movhi	r2,3329
 d0070e0:	10a90504 	addi	r2,r2,-23532
 d0070e4:	20800815 	stw	r2,32(r4)
 d0070e8:	00c34074 	movhi	r3,3329
 d0070ec:	18e8e604 	addi	r3,r3,-23656
 d0070f0:	00834074 	movhi	r2,3329
 d0070f4:	10a8cc04 	addi	r2,r2,-23760
 d0070f8:	2140030d 	sth	r5,12(r4)
 d0070fc:	2180038d 	sth	r6,14(r4)
 d007100:	20c00915 	stw	r3,36(r4)
 d007104:	20800a15 	stw	r2,40(r4)
 d007108:	20000015 	stw	zero,0(r4)
 d00710c:	20000115 	stw	zero,4(r4)
 d007110:	20000215 	stw	zero,8(r4)
 d007114:	20000415 	stw	zero,16(r4)
 d007118:	20000515 	stw	zero,20(r4)
 d00711c:	20000615 	stw	zero,24(r4)
 d007120:	21000715 	stw	r4,28(r4)
 d007124:	f800283a 	ret

0d007128 <__sfp_lock_acquire>:
 d007128:	f800283a 	ret

0d00712c <__sfp_lock_release>:
 d00712c:	f800283a 	ret

0d007130 <__sinit_lock_acquire>:
 d007130:	f800283a 	ret

0d007134 <__sinit_lock_release>:
 d007134:	f800283a 	ret

0d007138 <__sinit>:
 d007138:	20800e17 	ldw	r2,56(r4)
 d00713c:	defffd04 	addi	sp,sp,-12
 d007140:	dc400115 	stw	r17,4(sp)
 d007144:	dc000015 	stw	r16,0(sp)
 d007148:	dfc00215 	stw	ra,8(sp)
 d00714c:	04400044 	movi	r17,1
 d007150:	01400104 	movi	r5,4
 d007154:	000d883a 	mov	r6,zero
 d007158:	2021883a 	mov	r16,r4
 d00715c:	2200bb04 	addi	r8,r4,748
 d007160:	200f883a 	mov	r7,r4
 d007164:	10000526 	beq	r2,zero,d00717c <__sinit+0x44>
 d007168:	dfc00217 	ldw	ra,8(sp)
 d00716c:	dc400117 	ldw	r17,4(sp)
 d007170:	dc000017 	ldw	r16,0(sp)
 d007174:	dec00304 	addi	sp,sp,12
 d007178:	f800283a 	ret
 d00717c:	21000117 	ldw	r4,4(r4)
 d007180:	00834034 	movhi	r2,3328
 d007184:	109c8704 	addi	r2,r2,29212
 d007188:	00c000c4 	movi	r3,3
 d00718c:	80800f15 	stw	r2,60(r16)
 d007190:	80c0b915 	stw	r3,740(r16)
 d007194:	8200ba15 	stw	r8,744(r16)
 d007198:	84400e15 	stw	r17,56(r16)
 d00719c:	8000b815 	stw	zero,736(r16)
 d0071a0:	d0070d00 	call	d0070d0 <std>
 d0071a4:	81000217 	ldw	r4,8(r16)
 d0071a8:	880d883a 	mov	r6,r17
 d0071ac:	800f883a 	mov	r7,r16
 d0071b0:	01400284 	movi	r5,10
 d0071b4:	d0070d00 	call	d0070d0 <std>
 d0071b8:	81000317 	ldw	r4,12(r16)
 d0071bc:	800f883a 	mov	r7,r16
 d0071c0:	01400484 	movi	r5,18
 d0071c4:	01800084 	movi	r6,2
 d0071c8:	dfc00217 	ldw	ra,8(sp)
 d0071cc:	dc400117 	ldw	r17,4(sp)
 d0071d0:	dc000017 	ldw	r16,0(sp)
 d0071d4:	dec00304 	addi	sp,sp,12
 d0071d8:	d0070d01 	jmpi	d0070d0 <std>

0d0071dc <__fp_lock>:
 d0071dc:	0005883a 	mov	r2,zero
 d0071e0:	f800283a 	ret

0d0071e4 <__fp_unlock>:
 d0071e4:	0005883a 	mov	r2,zero
 d0071e8:	f800283a 	ret

0d0071ec <__fp_unlock_all>:
 d0071ec:	00834174 	movhi	r2,3333
 d0071f0:	10922004 	addi	r2,r2,18560
 d0071f4:	11000017 	ldw	r4,0(r2)
 d0071f8:	01434034 	movhi	r5,3328
 d0071fc:	295c7904 	addi	r5,r5,29156
 d007200:	d007eb41 	jmpi	d007eb4 <_fwalk>

0d007204 <__fp_lock_all>:
 d007204:	00834174 	movhi	r2,3333
 d007208:	10922004 	addi	r2,r2,18560
 d00720c:	11000017 	ldw	r4,0(r2)
 d007210:	01434034 	movhi	r5,3328
 d007214:	295c7704 	addi	r5,r5,29148
 d007218:	d007eb41 	jmpi	d007eb4 <_fwalk>

0d00721c <_cleanup_r>:
 d00721c:	01434074 	movhi	r5,3329
 d007220:	2969fc04 	addi	r5,r5,-22544
 d007224:	d007eb41 	jmpi	d007eb4 <_fwalk>

0d007228 <_cleanup>:
 d007228:	00834174 	movhi	r2,3333
 d00722c:	10922104 	addi	r2,r2,18564
 d007230:	11000017 	ldw	r4,0(r2)
 d007234:	d00721c1 	jmpi	d00721c <_cleanup_r>

0d007238 <__sfmoreglue>:
 d007238:	defffc04 	addi	sp,sp,-16
 d00723c:	dc000015 	stw	r16,0(sp)
 d007240:	2821883a 	mov	r16,r5
 d007244:	dc400115 	stw	r17,4(sp)
 d007248:	01401704 	movi	r5,92
 d00724c:	2023883a 	mov	r17,r4
 d007250:	8009883a 	mov	r4,r16
 d007254:	dfc00315 	stw	ra,12(sp)
 d007258:	dcc00215 	stw	r19,8(sp)
 d00725c:	d00235c0 	call	d00235c <__mulsi3>
 d007260:	11400304 	addi	r5,r2,12
 d007264:	8809883a 	mov	r4,r17
 d007268:	1027883a 	mov	r19,r2
 d00726c:	d0081c40 	call	d0081c4 <_malloc_r>
 d007270:	10c00304 	addi	r3,r2,12
 d007274:	1023883a 	mov	r17,r2
 d007278:	1809883a 	mov	r4,r3
 d00727c:	980d883a 	mov	r6,r19
 d007280:	000b883a 	mov	r5,zero
 d007284:	10000b26 	beq	r2,zero,d0072b4 <__sfmoreglue+0x7c>
 d007288:	14000115 	stw	r16,4(r2)
 d00728c:	10c00215 	stw	r3,8(r2)
 d007290:	10000015 	stw	zero,0(r2)
 d007294:	d0027880 	call	d002788 <memset>
 d007298:	8805883a 	mov	r2,r17
 d00729c:	dfc00317 	ldw	ra,12(sp)
 d0072a0:	dcc00217 	ldw	r19,8(sp)
 d0072a4:	dc400117 	ldw	r17,4(sp)
 d0072a8:	dc000017 	ldw	r16,0(sp)
 d0072ac:	dec00404 	addi	sp,sp,16
 d0072b0:	f800283a 	ret
 d0072b4:	0023883a 	mov	r17,zero
 d0072b8:	8805883a 	mov	r2,r17
 d0072bc:	dfc00317 	ldw	ra,12(sp)
 d0072c0:	dcc00217 	ldw	r19,8(sp)
 d0072c4:	dc400117 	ldw	r17,4(sp)
 d0072c8:	dc000017 	ldw	r16,0(sp)
 d0072cc:	dec00404 	addi	sp,sp,16
 d0072d0:	f800283a 	ret

0d0072d4 <__sfp>:
 d0072d4:	defffd04 	addi	sp,sp,-12
 d0072d8:	00834174 	movhi	r2,3333
 d0072dc:	10922104 	addi	r2,r2,18564
 d0072e0:	dc000015 	stw	r16,0(sp)
 d0072e4:	14000017 	ldw	r16,0(r2)
 d0072e8:	dc400115 	stw	r17,4(sp)
 d0072ec:	dfc00215 	stw	ra,8(sp)
 d0072f0:	80800e17 	ldw	r2,56(r16)
 d0072f4:	2023883a 	mov	r17,r4
 d0072f8:	10002626 	beq	r2,zero,d007394 <__sfp+0xc0>
 d0072fc:	8400b804 	addi	r16,r16,736
 d007300:	80800117 	ldw	r2,4(r16)
 d007304:	81000217 	ldw	r4,8(r16)
 d007308:	10ffffc4 	addi	r3,r2,-1
 d00730c:	18000916 	blt	r3,zero,d007334 <__sfp+0x60>
 d007310:	2080030f 	ldh	r2,12(r4)
 d007314:	10000b26 	beq	r2,zero,d007344 <__sfp+0x70>
 d007318:	017fffc4 	movi	r5,-1
 d00731c:	00000206 	br	d007328 <__sfp+0x54>
 d007320:	2080030f 	ldh	r2,12(r4)
 d007324:	10000726 	beq	r2,zero,d007344 <__sfp+0x70>
 d007328:	18ffffc4 	addi	r3,r3,-1
 d00732c:	21001704 	addi	r4,r4,92
 d007330:	197ffb1e 	bne	r3,r5,d007320 <__sfp+0x4c>
 d007334:	80800017 	ldw	r2,0(r16)
 d007338:	10001926 	beq	r2,zero,d0073a0 <__sfp+0xcc>
 d00733c:	1021883a 	mov	r16,r2
 d007340:	003fef06 	br	d007300 <__sfp+0x2c>
 d007344:	00bfffc4 	movi	r2,-1
 d007348:	00c00044 	movi	r3,1
 d00734c:	2080038d 	sth	r2,14(r4)
 d007350:	20c0030d 	sth	r3,12(r4)
 d007354:	20000015 	stw	zero,0(r4)
 d007358:	20000215 	stw	zero,8(r4)
 d00735c:	20000115 	stw	zero,4(r4)
 d007360:	20000415 	stw	zero,16(r4)
 d007364:	20000515 	stw	zero,20(r4)
 d007368:	20000615 	stw	zero,24(r4)
 d00736c:	20000c15 	stw	zero,48(r4)
 d007370:	20000d15 	stw	zero,52(r4)
 d007374:	20001115 	stw	zero,68(r4)
 d007378:	20001215 	stw	zero,72(r4)
 d00737c:	2005883a 	mov	r2,r4
 d007380:	dfc00217 	ldw	ra,8(sp)
 d007384:	dc400117 	ldw	r17,4(sp)
 d007388:	dc000017 	ldw	r16,0(sp)
 d00738c:	dec00304 	addi	sp,sp,12
 d007390:	f800283a 	ret
 d007394:	8009883a 	mov	r4,r16
 d007398:	d0071380 	call	d007138 <__sinit>
 d00739c:	003fd706 	br	d0072fc <__sfp+0x28>
 d0073a0:	8809883a 	mov	r4,r17
 d0073a4:	01400104 	movi	r5,4
 d0073a8:	d0072380 	call	d007238 <__sfmoreglue>
 d0073ac:	80800015 	stw	r2,0(r16)
 d0073b0:	103fe21e 	bne	r2,zero,d00733c <__sfp+0x68>
 d0073b4:	00800304 	movi	r2,12
 d0073b8:	0009883a 	mov	r4,zero
 d0073bc:	88800015 	stw	r2,0(r17)
 d0073c0:	003fee06 	br	d00737c <__sfp+0xa8>

0d0073c4 <fputc>:
 d0073c4:	defffc04 	addi	sp,sp,-16
 d0073c8:	dc800215 	stw	r18,8(sp)
 d0073cc:	04834174 	movhi	r18,3333
 d0073d0:	94922004 	addi	r18,r18,18560
 d0073d4:	90c00017 	ldw	r3,0(r18)
 d0073d8:	dc400115 	stw	r17,4(sp)
 d0073dc:	dc000015 	stw	r16,0(sp)
 d0073e0:	dfc00315 	stw	ra,12(sp)
 d0073e4:	2021883a 	mov	r16,r4
 d0073e8:	2823883a 	mov	r17,r5
 d0073ec:	18000326 	beq	r3,zero,d0073fc <fputc+0x38>
 d0073f0:	18800e17 	ldw	r2,56(r3)
 d0073f4:	1809883a 	mov	r4,r3
 d0073f8:	10000926 	beq	r2,zero,d007420 <fputc+0x5c>
 d0073fc:	91000017 	ldw	r4,0(r18)
 d007400:	800b883a 	mov	r5,r16
 d007404:	880d883a 	mov	r6,r17
 d007408:	dfc00317 	ldw	ra,12(sp)
 d00740c:	dc800217 	ldw	r18,8(sp)
 d007410:	dc400117 	ldw	r17,4(sp)
 d007414:	dc000017 	ldw	r16,0(sp)
 d007418:	dec00404 	addi	sp,sp,16
 d00741c:	d002a1c1 	jmpi	d002a1c <_putc_r>
 d007420:	d0071380 	call	d007138 <__sinit>
 d007424:	003ff506 	br	d0073fc <fputc+0x38>

0d007428 <_fputc_r>:
 d007428:	defffc04 	addi	sp,sp,-16
 d00742c:	dc800215 	stw	r18,8(sp)
 d007430:	dc400115 	stw	r17,4(sp)
 d007434:	dc000015 	stw	r16,0(sp)
 d007438:	dfc00315 	stw	ra,12(sp)
 d00743c:	2021883a 	mov	r16,r4
 d007440:	2823883a 	mov	r17,r5
 d007444:	3025883a 	mov	r18,r6
 d007448:	20000226 	beq	r4,zero,d007454 <_fputc_r+0x2c>
 d00744c:	20800e17 	ldw	r2,56(r4)
 d007450:	10000926 	beq	r2,zero,d007478 <_fputc_r+0x50>
 d007454:	8009883a 	mov	r4,r16
 d007458:	880b883a 	mov	r5,r17
 d00745c:	900d883a 	mov	r6,r18
 d007460:	dfc00317 	ldw	ra,12(sp)
 d007464:	dc800217 	ldw	r18,8(sp)
 d007468:	dc400117 	ldw	r17,4(sp)
 d00746c:	dc000017 	ldw	r16,0(sp)
 d007470:	dec00404 	addi	sp,sp,16
 d007474:	d002a1c1 	jmpi	d002a1c <_putc_r>
 d007478:	d0071380 	call	d007138 <__sinit>
 d00747c:	003ff506 	br	d007454 <_fputc_r+0x2c>

0d007480 <_fputs_r>:
 d007480:	defff804 	addi	sp,sp,-32
 d007484:	dc000515 	stw	r16,20(sp)
 d007488:	2021883a 	mov	r16,r4
 d00748c:	2809883a 	mov	r4,r5
 d007490:	dc400615 	stw	r17,24(sp)
 d007494:	dfc00715 	stw	ra,28(sp)
 d007498:	3023883a 	mov	r17,r6
 d00749c:	d9400015 	stw	r5,0(sp)
 d0074a0:	d0034640 	call	d003464 <strlen>
 d0074a4:	00c00044 	movi	r3,1
 d0074a8:	d8800115 	stw	r2,4(sp)
 d0074ac:	d8c00315 	stw	r3,12(sp)
 d0074b0:	d8800415 	stw	r2,16(sp)
 d0074b4:	dec00215 	stw	sp,8(sp)
 d0074b8:	80000326 	beq	r16,zero,d0074c8 <_fputs_r+0x48>
 d0074bc:	80800e17 	ldw	r2,56(r16)
 d0074c0:	8009883a 	mov	r4,r16
 d0074c4:	10000926 	beq	r2,zero,d0074ec <_fputs_r+0x6c>
 d0074c8:	8009883a 	mov	r4,r16
 d0074cc:	880b883a 	mov	r5,r17
 d0074d0:	d9800204 	addi	r6,sp,8
 d0074d4:	d0079500 	call	d007950 <__sfvwrite_r>
 d0074d8:	dfc00717 	ldw	ra,28(sp)
 d0074dc:	dc400617 	ldw	r17,24(sp)
 d0074e0:	dc000517 	ldw	r16,20(sp)
 d0074e4:	dec00804 	addi	sp,sp,32
 d0074e8:	f800283a 	ret
 d0074ec:	d0071380 	call	d007138 <__sinit>
 d0074f0:	003ff506 	br	d0074c8 <_fputs_r+0x48>

0d0074f4 <fputs>:
 d0074f4:	01834174 	movhi	r6,3333
 d0074f8:	31922004 	addi	r6,r6,18560
 d0074fc:	2007883a 	mov	r3,r4
 d007500:	31000017 	ldw	r4,0(r6)
 d007504:	280d883a 	mov	r6,r5
 d007508:	180b883a 	mov	r5,r3
 d00750c:	d0074801 	jmpi	d007480 <_fputs_r>

0d007510 <_malloc_trim_r>:
 d007510:	defffb04 	addi	sp,sp,-20
 d007514:	dcc00315 	stw	r19,12(sp)
 d007518:	04c34174 	movhi	r19,3333
 d00751c:	9ccb4704 	addi	r19,r19,11548
 d007520:	dc800215 	stw	r18,8(sp)
 d007524:	dc400115 	stw	r17,4(sp)
 d007528:	dc000015 	stw	r16,0(sp)
 d00752c:	2823883a 	mov	r17,r5
 d007530:	2025883a 	mov	r18,r4
 d007534:	dfc00415 	stw	ra,16(sp)
 d007538:	d00d7cc0 	call	d00d7cc <__malloc_lock>
 d00753c:	98800217 	ldw	r2,8(r19)
 d007540:	9009883a 	mov	r4,r18
 d007544:	000b883a 	mov	r5,zero
 d007548:	10c00117 	ldw	r3,4(r2)
 d00754c:	00bfff04 	movi	r2,-4
 d007550:	18a0703a 	and	r16,r3,r2
 d007554:	8463c83a 	sub	r17,r16,r17
 d007558:	8c43fbc4 	addi	r17,r17,4079
 d00755c:	8822d33a 	srli	r17,r17,12
 d007560:	0083ffc4 	movi	r2,4095
 d007564:	8c7fffc4 	addi	r17,r17,-1
 d007568:	8822933a 	slli	r17,r17,12
 d00756c:	1440060e 	bge	r2,r17,d007588 <_malloc_trim_r+0x78>
 d007570:	d00a2b80 	call	d00a2b8 <_sbrk_r>
 d007574:	98c00217 	ldw	r3,8(r19)
 d007578:	9009883a 	mov	r4,r18
 d00757c:	044bc83a 	sub	r5,zero,r17
 d007580:	80c7883a 	add	r3,r16,r3
 d007584:	10c00926 	beq	r2,r3,d0075ac <_malloc_trim_r+0x9c>
 d007588:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d00758c:	0005883a 	mov	r2,zero
 d007590:	dfc00417 	ldw	ra,16(sp)
 d007594:	dcc00317 	ldw	r19,12(sp)
 d007598:	dc800217 	ldw	r18,8(sp)
 d00759c:	dc400117 	ldw	r17,4(sp)
 d0075a0:	dc000017 	ldw	r16,0(sp)
 d0075a4:	dec00504 	addi	sp,sp,20
 d0075a8:	f800283a 	ret
 d0075ac:	9009883a 	mov	r4,r18
 d0075b0:	d00a2b80 	call	d00a2b8 <_sbrk_r>
 d0075b4:	844dc83a 	sub	r6,r16,r17
 d0075b8:	00ffffc4 	movi	r3,-1
 d0075bc:	9009883a 	mov	r4,r18
 d0075c0:	000b883a 	mov	r5,zero
 d0075c4:	01c34174 	movhi	r7,3333
 d0075c8:	39dcf704 	addi	r7,r7,29660
 d0075cc:	31800054 	ori	r6,r6,1
 d0075d0:	10c00926 	beq	r2,r3,d0075f8 <_malloc_trim_r+0xe8>
 d0075d4:	38800017 	ldw	r2,0(r7)
 d0075d8:	98c00217 	ldw	r3,8(r19)
 d0075dc:	9009883a 	mov	r4,r18
 d0075e0:	1445c83a 	sub	r2,r2,r17
 d0075e4:	38800015 	stw	r2,0(r7)
 d0075e8:	19800115 	stw	r6,4(r3)
 d0075ec:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d0075f0:	00800044 	movi	r2,1
 d0075f4:	003fe606 	br	d007590 <_malloc_trim_r+0x80>
 d0075f8:	d00a2b80 	call	d00a2b8 <_sbrk_r>
 d0075fc:	99800217 	ldw	r6,8(r19)
 d007600:	100f883a 	mov	r7,r2
 d007604:	9009883a 	mov	r4,r18
 d007608:	1187c83a 	sub	r3,r2,r6
 d00760c:	008003c4 	movi	r2,15
 d007610:	19400054 	ori	r5,r3,1
 d007614:	10ffdc0e 	bge	r2,r3,d007588 <_malloc_trim_r+0x78>
 d007618:	00834174 	movhi	r2,3333
 d00761c:	10922504 	addi	r2,r2,18580
 d007620:	10c00017 	ldw	r3,0(r2)
 d007624:	00834174 	movhi	r2,3333
 d007628:	109cf704 	addi	r2,r2,29660
 d00762c:	31400115 	stw	r5,4(r6)
 d007630:	38c7c83a 	sub	r3,r7,r3
 d007634:	10c00015 	stw	r3,0(r2)
 d007638:	003fd306 	br	d007588 <_malloc_trim_r+0x78>

0d00763c <_free_r>:
 d00763c:	defffd04 	addi	sp,sp,-12
 d007640:	dc400115 	stw	r17,4(sp)
 d007644:	dc000015 	stw	r16,0(sp)
 d007648:	dfc00215 	stw	ra,8(sp)
 d00764c:	2821883a 	mov	r16,r5
 d007650:	2023883a 	mov	r17,r4
 d007654:	28005a26 	beq	r5,zero,d0077c0 <_free_r+0x184>
 d007658:	d00d7cc0 	call	d00d7cc <__malloc_lock>
 d00765c:	823ffe04 	addi	r8,r16,-8
 d007660:	41400117 	ldw	r5,4(r8)
 d007664:	00bfff84 	movi	r2,-2
 d007668:	02834174 	movhi	r10,3333
 d00766c:	528b4704 	addi	r10,r10,11548
 d007670:	288e703a 	and	r7,r5,r2
 d007674:	41cd883a 	add	r6,r8,r7
 d007678:	30c00117 	ldw	r3,4(r6)
 d00767c:	51000217 	ldw	r4,8(r10)
 d007680:	00bfff04 	movi	r2,-4
 d007684:	1892703a 	and	r9,r3,r2
 d007688:	5017883a 	mov	r11,r10
 d00768c:	31006726 	beq	r6,r4,d00782c <_free_r+0x1f0>
 d007690:	2880004c 	andi	r2,r5,1
 d007694:	1005003a 	cmpeq	r2,r2,zero
 d007698:	32400115 	stw	r9,4(r6)
 d00769c:	10001a1e 	bne	r2,zero,d007708 <_free_r+0xcc>
 d0076a0:	000b883a 	mov	r5,zero
 d0076a4:	3247883a 	add	r3,r6,r9
 d0076a8:	18800117 	ldw	r2,4(r3)
 d0076ac:	1080004c 	andi	r2,r2,1
 d0076b0:	1000231e 	bne	r2,zero,d007740 <_free_r+0x104>
 d0076b4:	280ac03a 	cmpne	r5,r5,zero
 d0076b8:	3a4f883a 	add	r7,r7,r9
 d0076bc:	2800451e 	bne	r5,zero,d0077d4 <_free_r+0x198>
 d0076c0:	31000217 	ldw	r4,8(r6)
 d0076c4:	00834174 	movhi	r2,3333
 d0076c8:	108b4904 	addi	r2,r2,11556
 d0076cc:	20807b26 	beq	r4,r2,d0078bc <_free_r+0x280>
 d0076d0:	30800317 	ldw	r2,12(r6)
 d0076d4:	3a07883a 	add	r3,r7,r8
 d0076d8:	19c00015 	stw	r7,0(r3)
 d0076dc:	11000215 	stw	r4,8(r2)
 d0076e0:	20800315 	stw	r2,12(r4)
 d0076e4:	38800054 	ori	r2,r7,1
 d0076e8:	40800115 	stw	r2,4(r8)
 d0076ec:	28001a26 	beq	r5,zero,d007758 <_free_r+0x11c>
 d0076f0:	8809883a 	mov	r4,r17
 d0076f4:	dfc00217 	ldw	ra,8(sp)
 d0076f8:	dc400117 	ldw	r17,4(sp)
 d0076fc:	dc000017 	ldw	r16,0(sp)
 d007700:	dec00304 	addi	sp,sp,12
 d007704:	d00d8d41 	jmpi	d00d8d4 <__malloc_unlock>
 d007708:	80bffe17 	ldw	r2,-8(r16)
 d00770c:	50c00204 	addi	r3,r10,8
 d007710:	4091c83a 	sub	r8,r8,r2
 d007714:	41000217 	ldw	r4,8(r8)
 d007718:	388f883a 	add	r7,r7,r2
 d00771c:	20c06126 	beq	r4,r3,d0078a4 <_free_r+0x268>
 d007720:	40800317 	ldw	r2,12(r8)
 d007724:	3247883a 	add	r3,r6,r9
 d007728:	000b883a 	mov	r5,zero
 d00772c:	11000215 	stw	r4,8(r2)
 d007730:	20800315 	stw	r2,12(r4)
 d007734:	18800117 	ldw	r2,4(r3)
 d007738:	1080004c 	andi	r2,r2,1
 d00773c:	103fdd26 	beq	r2,zero,d0076b4 <_free_r+0x78>
 d007740:	38800054 	ori	r2,r7,1
 d007744:	3a07883a 	add	r3,r7,r8
 d007748:	280ac03a 	cmpne	r5,r5,zero
 d00774c:	40800115 	stw	r2,4(r8)
 d007750:	19c00015 	stw	r7,0(r3)
 d007754:	283fe61e 	bne	r5,zero,d0076f0 <_free_r+0xb4>
 d007758:	00807fc4 	movi	r2,511
 d00775c:	11c01f2e 	bgeu	r2,r7,d0077dc <_free_r+0x1a0>
 d007760:	3806d27a 	srli	r3,r7,9
 d007764:	1800481e 	bne	r3,zero,d007888 <_free_r+0x24c>
 d007768:	3804d0fa 	srli	r2,r7,3
 d00776c:	100690fa 	slli	r3,r2,3
 d007770:	1acd883a 	add	r6,r3,r11
 d007774:	31400217 	ldw	r5,8(r6)
 d007778:	31405926 	beq	r6,r5,d0078e0 <_free_r+0x2a4>
 d00777c:	28800117 	ldw	r2,4(r5)
 d007780:	00ffff04 	movi	r3,-4
 d007784:	10c4703a 	and	r2,r2,r3
 d007788:	3880022e 	bgeu	r7,r2,d007794 <_free_r+0x158>
 d00778c:	29400217 	ldw	r5,8(r5)
 d007790:	317ffa1e 	bne	r6,r5,d00777c <_free_r+0x140>
 d007794:	29800317 	ldw	r6,12(r5)
 d007798:	41800315 	stw	r6,12(r8)
 d00779c:	41400215 	stw	r5,8(r8)
 d0077a0:	8809883a 	mov	r4,r17
 d0077a4:	2a000315 	stw	r8,12(r5)
 d0077a8:	32000215 	stw	r8,8(r6)
 d0077ac:	dfc00217 	ldw	ra,8(sp)
 d0077b0:	dc400117 	ldw	r17,4(sp)
 d0077b4:	dc000017 	ldw	r16,0(sp)
 d0077b8:	dec00304 	addi	sp,sp,12
 d0077bc:	d00d8d41 	jmpi	d00d8d4 <__malloc_unlock>
 d0077c0:	dfc00217 	ldw	ra,8(sp)
 d0077c4:	dc400117 	ldw	r17,4(sp)
 d0077c8:	dc000017 	ldw	r16,0(sp)
 d0077cc:	dec00304 	addi	sp,sp,12
 d0077d0:	f800283a 	ret
 d0077d4:	31000217 	ldw	r4,8(r6)
 d0077d8:	003fbd06 	br	d0076d0 <_free_r+0x94>
 d0077dc:	3806d0fa 	srli	r3,r7,3
 d0077e0:	00800044 	movi	r2,1
 d0077e4:	51400117 	ldw	r5,4(r10)
 d0077e8:	180890fa 	slli	r4,r3,3
 d0077ec:	1807d0ba 	srai	r3,r3,2
 d0077f0:	22c9883a 	add	r4,r4,r11
 d0077f4:	21800217 	ldw	r6,8(r4)
 d0077f8:	10c4983a 	sll	r2,r2,r3
 d0077fc:	41000315 	stw	r4,12(r8)
 d007800:	41800215 	stw	r6,8(r8)
 d007804:	288ab03a 	or	r5,r5,r2
 d007808:	22000215 	stw	r8,8(r4)
 d00780c:	8809883a 	mov	r4,r17
 d007810:	51400115 	stw	r5,4(r10)
 d007814:	32000315 	stw	r8,12(r6)
 d007818:	dfc00217 	ldw	ra,8(sp)
 d00781c:	dc400117 	ldw	r17,4(sp)
 d007820:	dc000017 	ldw	r16,0(sp)
 d007824:	dec00304 	addi	sp,sp,12
 d007828:	d00d8d41 	jmpi	d00d8d4 <__malloc_unlock>
 d00782c:	2880004c 	andi	r2,r5,1
 d007830:	3a4d883a 	add	r6,r7,r9
 d007834:	1000071e 	bne	r2,zero,d007854 <_free_r+0x218>
 d007838:	80bffe17 	ldw	r2,-8(r16)
 d00783c:	4091c83a 	sub	r8,r8,r2
 d007840:	41000317 	ldw	r4,12(r8)
 d007844:	40c00217 	ldw	r3,8(r8)
 d007848:	308d883a 	add	r6,r6,r2
 d00784c:	20c00215 	stw	r3,8(r4)
 d007850:	19000315 	stw	r4,12(r3)
 d007854:	00834174 	movhi	r2,3333
 d007858:	10922404 	addi	r2,r2,18576
 d00785c:	11000017 	ldw	r4,0(r2)
 d007860:	30c00054 	ori	r3,r6,1
 d007864:	52000215 	stw	r8,8(r10)
 d007868:	40c00115 	stw	r3,4(r8)
 d00786c:	313fa036 	bltu	r6,r4,d0076f0 <_free_r+0xb4>
 d007870:	00834174 	movhi	r2,3333
 d007874:	109afe04 	addi	r2,r2,27640
 d007878:	11400017 	ldw	r5,0(r2)
 d00787c:	8809883a 	mov	r4,r17
 d007880:	d0075100 	call	d007510 <_malloc_trim_r>
 d007884:	003f9a06 	br	d0076f0 <_free_r+0xb4>
 d007888:	00800104 	movi	r2,4
 d00788c:	10c0072e 	bgeu	r2,r3,d0078ac <_free_r+0x270>
 d007890:	00800504 	movi	r2,20
 d007894:	10c01936 	bltu	r2,r3,d0078fc <_free_r+0x2c0>
 d007898:	188016c4 	addi	r2,r3,91
 d00789c:	100690fa 	slli	r3,r2,3
 d0078a0:	003fb306 	br	d007770 <_free_r+0x134>
 d0078a4:	01400044 	movi	r5,1
 d0078a8:	003f7e06 	br	d0076a4 <_free_r+0x68>
 d0078ac:	3804d1ba 	srli	r2,r7,6
 d0078b0:	10800e04 	addi	r2,r2,56
 d0078b4:	100690fa 	slli	r3,r2,3
 d0078b8:	003fad06 	br	d007770 <_free_r+0x134>
 d0078bc:	22000315 	stw	r8,12(r4)
 d0078c0:	22000215 	stw	r8,8(r4)
 d0078c4:	3a05883a 	add	r2,r7,r8
 d0078c8:	38c00054 	ori	r3,r7,1
 d0078cc:	11c00015 	stw	r7,0(r2)
 d0078d0:	41000215 	stw	r4,8(r8)
 d0078d4:	40c00115 	stw	r3,4(r8)
 d0078d8:	41000315 	stw	r4,12(r8)
 d0078dc:	003f8406 	br	d0076f0 <_free_r+0xb4>
 d0078e0:	1005d0ba 	srai	r2,r2,2
 d0078e4:	00c00044 	movi	r3,1
 d0078e8:	51000117 	ldw	r4,4(r10)
 d0078ec:	1886983a 	sll	r3,r3,r2
 d0078f0:	20c8b03a 	or	r4,r4,r3
 d0078f4:	51000115 	stw	r4,4(r10)
 d0078f8:	003fa706 	br	d007798 <_free_r+0x15c>
 d0078fc:	00801504 	movi	r2,84
 d007900:	10c00436 	bltu	r2,r3,d007914 <_free_r+0x2d8>
 d007904:	3804d33a 	srli	r2,r7,12
 d007908:	10801b84 	addi	r2,r2,110
 d00790c:	100690fa 	slli	r3,r2,3
 d007910:	003f9706 	br	d007770 <_free_r+0x134>
 d007914:	00805504 	movi	r2,340
 d007918:	10c00436 	bltu	r2,r3,d00792c <_free_r+0x2f0>
 d00791c:	3804d3fa 	srli	r2,r7,15
 d007920:	10801dc4 	addi	r2,r2,119
 d007924:	100690fa 	slli	r3,r2,3
 d007928:	003f9106 	br	d007770 <_free_r+0x134>
 d00792c:	00815504 	movi	r2,1364
 d007930:	10c0032e 	bgeu	r2,r3,d007940 <_free_r+0x304>
 d007934:	00801f84 	movi	r2,126
 d007938:	00c0fc04 	movi	r3,1008
 d00793c:	003f8c06 	br	d007770 <_free_r+0x134>
 d007940:	3804d4ba 	srli	r2,r7,18
 d007944:	10801f04 	addi	r2,r2,124
 d007948:	100690fa 	slli	r3,r2,3
 d00794c:	003f8806 	br	d007770 <_free_r+0x134>

0d007950 <__sfvwrite_r>:
 d007950:	30800217 	ldw	r2,8(r6)
 d007954:	defff504 	addi	sp,sp,-44
 d007958:	df000915 	stw	fp,36(sp)
 d00795c:	dd800715 	stw	r22,28(sp)
 d007960:	dc800315 	stw	r18,12(sp)
 d007964:	dfc00a15 	stw	ra,40(sp)
 d007968:	ddc00815 	stw	r23,32(sp)
 d00796c:	dd400615 	stw	r21,24(sp)
 d007970:	dd000515 	stw	r20,20(sp)
 d007974:	dcc00415 	stw	r19,16(sp)
 d007978:	dc400215 	stw	r17,8(sp)
 d00797c:	dc000115 	stw	r16,4(sp)
 d007980:	302d883a 	mov	r22,r6
 d007984:	2039883a 	mov	fp,r4
 d007988:	2825883a 	mov	r18,r5
 d00798c:	10001c26 	beq	r2,zero,d007a00 <__sfvwrite_r+0xb0>
 d007990:	29c0030b 	ldhu	r7,12(r5)
 d007994:	3880020c 	andi	r2,r7,8
 d007998:	10002726 	beq	r2,zero,d007a38 <__sfvwrite_r+0xe8>
 d00799c:	28800417 	ldw	r2,16(r5)
 d0079a0:	10002526 	beq	r2,zero,d007a38 <__sfvwrite_r+0xe8>
 d0079a4:	3880008c 	andi	r2,r7,2
 d0079a8:	b5400017 	ldw	r21,0(r22)
 d0079ac:	10002826 	beq	r2,zero,d007a50 <__sfvwrite_r+0x100>
 d0079b0:	0021883a 	mov	r16,zero
 d0079b4:	0023883a 	mov	r17,zero
 d0079b8:	880d883a 	mov	r6,r17
 d0079bc:	e009883a 	mov	r4,fp
 d0079c0:	00810004 	movi	r2,1024
 d0079c4:	80006e26 	beq	r16,zero,d007b80 <__sfvwrite_r+0x230>
 d0079c8:	800f883a 	mov	r7,r16
 d0079cc:	91400717 	ldw	r5,28(r18)
 d0079d0:	1400012e 	bgeu	r2,r16,d0079d8 <__sfvwrite_r+0x88>
 d0079d4:	100f883a 	mov	r7,r2
 d0079d8:	90c00917 	ldw	r3,36(r18)
 d0079dc:	183ee83a 	callr	r3
 d0079e0:	1007883a 	mov	r3,r2
 d0079e4:	80a1c83a 	sub	r16,r16,r2
 d0079e8:	88a3883a 	add	r17,r17,r2
 d0079ec:	00806d0e 	bge	zero,r2,d007ba4 <__sfvwrite_r+0x254>
 d0079f0:	b0800217 	ldw	r2,8(r22)
 d0079f4:	10c5c83a 	sub	r2,r2,r3
 d0079f8:	b0800215 	stw	r2,8(r22)
 d0079fc:	103fee1e 	bne	r2,zero,d0079b8 <__sfvwrite_r+0x68>
 d007a00:	0009883a 	mov	r4,zero
 d007a04:	2005883a 	mov	r2,r4
 d007a08:	dfc00a17 	ldw	ra,40(sp)
 d007a0c:	df000917 	ldw	fp,36(sp)
 d007a10:	ddc00817 	ldw	r23,32(sp)
 d007a14:	dd800717 	ldw	r22,28(sp)
 d007a18:	dd400617 	ldw	r21,24(sp)
 d007a1c:	dd000517 	ldw	r20,20(sp)
 d007a20:	dcc00417 	ldw	r19,16(sp)
 d007a24:	dc800317 	ldw	r18,12(sp)
 d007a28:	dc400217 	ldw	r17,8(sp)
 d007a2c:	dc000117 	ldw	r16,4(sp)
 d007a30:	dec00b04 	addi	sp,sp,44
 d007a34:	f800283a 	ret
 d007a38:	d00556c0 	call	d00556c <__swsetup_r>
 d007a3c:	1000e41e 	bne	r2,zero,d007dd0 <__sfvwrite_r+0x480>
 d007a40:	91c0030b 	ldhu	r7,12(r18)
 d007a44:	b5400017 	ldw	r21,0(r22)
 d007a48:	3880008c 	andi	r2,r7,2
 d007a4c:	103fd81e 	bne	r2,zero,d0079b0 <__sfvwrite_r+0x60>
 d007a50:	3880004c 	andi	r2,r7,1
 d007a54:	1005003a 	cmpeq	r2,r2,zero
 d007a58:	10005726 	beq	r2,zero,d007bb8 <__sfvwrite_r+0x268>
 d007a5c:	0029883a 	mov	r20,zero
 d007a60:	002f883a 	mov	r23,zero
 d007a64:	a0004226 	beq	r20,zero,d007b70 <__sfvwrite_r+0x220>
 d007a68:	3880800c 	andi	r2,r7,512
 d007a6c:	94000217 	ldw	r16,8(r18)
 d007a70:	10008b26 	beq	r2,zero,d007ca0 <__sfvwrite_r+0x350>
 d007a74:	800d883a 	mov	r6,r16
 d007a78:	a400a536 	bltu	r20,r16,d007d10 <__sfvwrite_r+0x3c0>
 d007a7c:	3881200c 	andi	r2,r7,1152
 d007a80:	10002726 	beq	r2,zero,d007b20 <__sfvwrite_r+0x1d0>
 d007a84:	90800517 	ldw	r2,20(r18)
 d007a88:	92000417 	ldw	r8,16(r18)
 d007a8c:	91400017 	ldw	r5,0(r18)
 d007a90:	1087883a 	add	r3,r2,r2
 d007a94:	1887883a 	add	r3,r3,r2
 d007a98:	1808d7fa 	srli	r4,r3,31
 d007a9c:	2a21c83a 	sub	r16,r5,r8
 d007aa0:	80800044 	addi	r2,r16,1
 d007aa4:	20c9883a 	add	r4,r4,r3
 d007aa8:	2027d07a 	srai	r19,r4,1
 d007aac:	a085883a 	add	r2,r20,r2
 d007ab0:	980d883a 	mov	r6,r19
 d007ab4:	9880022e 	bgeu	r19,r2,d007ac0 <__sfvwrite_r+0x170>
 d007ab8:	1027883a 	mov	r19,r2
 d007abc:	100d883a 	mov	r6,r2
 d007ac0:	3881000c 	andi	r2,r7,1024
 d007ac4:	1000b826 	beq	r2,zero,d007da8 <__sfvwrite_r+0x458>
 d007ac8:	300b883a 	mov	r5,r6
 d007acc:	e009883a 	mov	r4,fp
 d007ad0:	d0081c40 	call	d0081c4 <_malloc_r>
 d007ad4:	10003126 	beq	r2,zero,d007b9c <__sfvwrite_r+0x24c>
 d007ad8:	91400417 	ldw	r5,16(r18)
 d007adc:	1009883a 	mov	r4,r2
 d007ae0:	800d883a 	mov	r6,r16
 d007ae4:	1023883a 	mov	r17,r2
 d007ae8:	d0026080 	call	d002608 <memcpy>
 d007aec:	90c0030b 	ldhu	r3,12(r18)
 d007af0:	00beffc4 	movi	r2,-1025
 d007af4:	1886703a 	and	r3,r3,r2
 d007af8:	18c02014 	ori	r3,r3,128
 d007afc:	90c0030d 	sth	r3,12(r18)
 d007b00:	9c07c83a 	sub	r3,r19,r16
 d007b04:	8c05883a 	add	r2,r17,r16
 d007b08:	a00d883a 	mov	r6,r20
 d007b0c:	a021883a 	mov	r16,r20
 d007b10:	90800015 	stw	r2,0(r18)
 d007b14:	90c00215 	stw	r3,8(r18)
 d007b18:	94400415 	stw	r17,16(r18)
 d007b1c:	94c00515 	stw	r19,20(r18)
 d007b20:	91000017 	ldw	r4,0(r18)
 d007b24:	b80b883a 	mov	r5,r23
 d007b28:	a023883a 	mov	r17,r20
 d007b2c:	d0026a80 	call	d0026a8 <memmove>
 d007b30:	90c00217 	ldw	r3,8(r18)
 d007b34:	90800017 	ldw	r2,0(r18)
 d007b38:	a027883a 	mov	r19,r20
 d007b3c:	1c07c83a 	sub	r3,r3,r16
 d007b40:	1405883a 	add	r2,r2,r16
 d007b44:	90c00215 	stw	r3,8(r18)
 d007b48:	a021883a 	mov	r16,r20
 d007b4c:	90800015 	stw	r2,0(r18)
 d007b50:	b0800217 	ldw	r2,8(r22)
 d007b54:	1405c83a 	sub	r2,r2,r16
 d007b58:	b0800215 	stw	r2,8(r22)
 d007b5c:	103fa826 	beq	r2,zero,d007a00 <__sfvwrite_r+0xb0>
 d007b60:	a469c83a 	sub	r20,r20,r17
 d007b64:	91c0030b 	ldhu	r7,12(r18)
 d007b68:	bcef883a 	add	r23,r23,r19
 d007b6c:	a03fbe1e 	bne	r20,zero,d007a68 <__sfvwrite_r+0x118>
 d007b70:	adc00017 	ldw	r23,0(r21)
 d007b74:	ad000117 	ldw	r20,4(r21)
 d007b78:	ad400204 	addi	r21,r21,8
 d007b7c:	003fb906 	br	d007a64 <__sfvwrite_r+0x114>
 d007b80:	ac400017 	ldw	r17,0(r21)
 d007b84:	ac000117 	ldw	r16,4(r21)
 d007b88:	ad400204 	addi	r21,r21,8
 d007b8c:	003f8a06 	br	d0079b8 <__sfvwrite_r+0x68>
 d007b90:	91400417 	ldw	r5,16(r18)
 d007b94:	e009883a 	mov	r4,fp
 d007b98:	d00763c0 	call	d00763c <_free_r>
 d007b9c:	00800304 	movi	r2,12
 d007ba0:	e0800015 	stw	r2,0(fp)
 d007ba4:	9080030b 	ldhu	r2,12(r18)
 d007ba8:	013fffc4 	movi	r4,-1
 d007bac:	10801014 	ori	r2,r2,64
 d007bb0:	9080030d 	sth	r2,12(r18)
 d007bb4:	003f9306 	br	d007a04 <__sfvwrite_r+0xb4>
 d007bb8:	0027883a 	mov	r19,zero
 d007bbc:	002f883a 	mov	r23,zero
 d007bc0:	d8000015 	stw	zero,0(sp)
 d007bc4:	0029883a 	mov	r20,zero
 d007bc8:	98001e26 	beq	r19,zero,d007c44 <__sfvwrite_r+0x2f4>
 d007bcc:	d8c00017 	ldw	r3,0(sp)
 d007bd0:	1804c03a 	cmpne	r2,r3,zero
 d007bd4:	10005e26 	beq	r2,zero,d007d50 <__sfvwrite_r+0x400>
 d007bd8:	9821883a 	mov	r16,r19
 d007bdc:	a4c0012e 	bgeu	r20,r19,d007be4 <__sfvwrite_r+0x294>
 d007be0:	a021883a 	mov	r16,r20
 d007be4:	91000017 	ldw	r4,0(r18)
 d007be8:	90800417 	ldw	r2,16(r18)
 d007bec:	91800217 	ldw	r6,8(r18)
 d007bf0:	91c00517 	ldw	r7,20(r18)
 d007bf4:	1100022e 	bgeu	r2,r4,d007c00 <__sfvwrite_r+0x2b0>
 d007bf8:	31e3883a 	add	r17,r6,r7
 d007bfc:	8c001616 	blt	r17,r16,d007c58 <__sfvwrite_r+0x308>
 d007c00:	81c03816 	blt	r16,r7,d007ce4 <__sfvwrite_r+0x394>
 d007c04:	90c00917 	ldw	r3,36(r18)
 d007c08:	91400717 	ldw	r5,28(r18)
 d007c0c:	e009883a 	mov	r4,fp
 d007c10:	b80d883a 	mov	r6,r23
 d007c14:	183ee83a 	callr	r3
 d007c18:	1023883a 	mov	r17,r2
 d007c1c:	00bfe10e 	bge	zero,r2,d007ba4 <__sfvwrite_r+0x254>
 d007c20:	a469c83a 	sub	r20,r20,r17
 d007c24:	a0001826 	beq	r20,zero,d007c88 <__sfvwrite_r+0x338>
 d007c28:	b0800217 	ldw	r2,8(r22)
 d007c2c:	1445c83a 	sub	r2,r2,r17
 d007c30:	b0800215 	stw	r2,8(r22)
 d007c34:	103f7226 	beq	r2,zero,d007a00 <__sfvwrite_r+0xb0>
 d007c38:	9c67c83a 	sub	r19,r19,r17
 d007c3c:	bc6f883a 	add	r23,r23,r17
 d007c40:	983fe21e 	bne	r19,zero,d007bcc <__sfvwrite_r+0x27c>
 d007c44:	adc00017 	ldw	r23,0(r21)
 d007c48:	acc00117 	ldw	r19,4(r21)
 d007c4c:	ad400204 	addi	r21,r21,8
 d007c50:	d8000015 	stw	zero,0(sp)
 d007c54:	003fdc06 	br	d007bc8 <__sfvwrite_r+0x278>
 d007c58:	b80b883a 	mov	r5,r23
 d007c5c:	880d883a 	mov	r6,r17
 d007c60:	d0026a80 	call	d0026a8 <memmove>
 d007c64:	90c00017 	ldw	r3,0(r18)
 d007c68:	e009883a 	mov	r4,fp
 d007c6c:	900b883a 	mov	r5,r18
 d007c70:	1c47883a 	add	r3,r3,r17
 d007c74:	90c00015 	stw	r3,0(r18)
 d007c78:	d006ea00 	call	d006ea0 <_fflush_r>
 d007c7c:	103fc91e 	bne	r2,zero,d007ba4 <__sfvwrite_r+0x254>
 d007c80:	a469c83a 	sub	r20,r20,r17
 d007c84:	a03fe81e 	bne	r20,zero,d007c28 <__sfvwrite_r+0x2d8>
 d007c88:	e009883a 	mov	r4,fp
 d007c8c:	900b883a 	mov	r5,r18
 d007c90:	d006ea00 	call	d006ea0 <_fflush_r>
 d007c94:	103fc31e 	bne	r2,zero,d007ba4 <__sfvwrite_r+0x254>
 d007c98:	d8000015 	stw	zero,0(sp)
 d007c9c:	003fe206 	br	d007c28 <__sfvwrite_r+0x2d8>
 d007ca0:	91000017 	ldw	r4,0(r18)
 d007ca4:	90800417 	ldw	r2,16(r18)
 d007ca8:	1100022e 	bgeu	r2,r4,d007cb4 <__sfvwrite_r+0x364>
 d007cac:	8023883a 	mov	r17,r16
 d007cb0:	85003136 	bltu	r16,r20,d007d78 <__sfvwrite_r+0x428>
 d007cb4:	91c00517 	ldw	r7,20(r18)
 d007cb8:	a1c01836 	bltu	r20,r7,d007d1c <__sfvwrite_r+0x3cc>
 d007cbc:	90c00917 	ldw	r3,36(r18)
 d007cc0:	91400717 	ldw	r5,28(r18)
 d007cc4:	e009883a 	mov	r4,fp
 d007cc8:	b80d883a 	mov	r6,r23
 d007ccc:	183ee83a 	callr	r3
 d007cd0:	1021883a 	mov	r16,r2
 d007cd4:	00bfb30e 	bge	zero,r2,d007ba4 <__sfvwrite_r+0x254>
 d007cd8:	1023883a 	mov	r17,r2
 d007cdc:	1027883a 	mov	r19,r2
 d007ce0:	003f9b06 	br	d007b50 <__sfvwrite_r+0x200>
 d007ce4:	b80b883a 	mov	r5,r23
 d007ce8:	800d883a 	mov	r6,r16
 d007cec:	d0026a80 	call	d0026a8 <memmove>
 d007cf0:	90c00217 	ldw	r3,8(r18)
 d007cf4:	90800017 	ldw	r2,0(r18)
 d007cf8:	8023883a 	mov	r17,r16
 d007cfc:	1c07c83a 	sub	r3,r3,r16
 d007d00:	1405883a 	add	r2,r2,r16
 d007d04:	90c00215 	stw	r3,8(r18)
 d007d08:	90800015 	stw	r2,0(r18)
 d007d0c:	003fc406 	br	d007c20 <__sfvwrite_r+0x2d0>
 d007d10:	a00d883a 	mov	r6,r20
 d007d14:	a021883a 	mov	r16,r20
 d007d18:	003f8106 	br	d007b20 <__sfvwrite_r+0x1d0>
 d007d1c:	b80b883a 	mov	r5,r23
 d007d20:	a00d883a 	mov	r6,r20
 d007d24:	d0026a80 	call	d0026a8 <memmove>
 d007d28:	90c00217 	ldw	r3,8(r18)
 d007d2c:	90800017 	ldw	r2,0(r18)
 d007d30:	a021883a 	mov	r16,r20
 d007d34:	1d07c83a 	sub	r3,r3,r20
 d007d38:	1505883a 	add	r2,r2,r20
 d007d3c:	a023883a 	mov	r17,r20
 d007d40:	a027883a 	mov	r19,r20
 d007d44:	90c00215 	stw	r3,8(r18)
 d007d48:	90800015 	stw	r2,0(r18)
 d007d4c:	003f8006 	br	d007b50 <__sfvwrite_r+0x200>
 d007d50:	b809883a 	mov	r4,r23
 d007d54:	01400284 	movi	r5,10
 d007d58:	980d883a 	mov	r6,r19
 d007d5c:	d0089040 	call	d008904 <memchr>
 d007d60:	10001726 	beq	r2,zero,d007dc0 <__sfvwrite_r+0x470>
 d007d64:	15c5c83a 	sub	r2,r2,r23
 d007d68:	15000044 	addi	r20,r2,1
 d007d6c:	00800044 	movi	r2,1
 d007d70:	d8800015 	stw	r2,0(sp)
 d007d74:	003f9806 	br	d007bd8 <__sfvwrite_r+0x288>
 d007d78:	b80b883a 	mov	r5,r23
 d007d7c:	800d883a 	mov	r6,r16
 d007d80:	d0026a80 	call	d0026a8 <memmove>
 d007d84:	90c00017 	ldw	r3,0(r18)
 d007d88:	e009883a 	mov	r4,fp
 d007d8c:	900b883a 	mov	r5,r18
 d007d90:	1c07883a 	add	r3,r3,r16
 d007d94:	90c00015 	stw	r3,0(r18)
 d007d98:	8027883a 	mov	r19,r16
 d007d9c:	d006ea00 	call	d006ea0 <_fflush_r>
 d007da0:	103f6b26 	beq	r2,zero,d007b50 <__sfvwrite_r+0x200>
 d007da4:	003f7f06 	br	d007ba4 <__sfvwrite_r+0x254>
 d007da8:	400b883a 	mov	r5,r8
 d007dac:	e009883a 	mov	r4,fp
 d007db0:	d009a740 	call	d009a74 <_realloc_r>
 d007db4:	103f7626 	beq	r2,zero,d007b90 <__sfvwrite_r+0x240>
 d007db8:	1023883a 	mov	r17,r2
 d007dbc:	003f5006 	br	d007b00 <__sfvwrite_r+0x1b0>
 d007dc0:	00c00044 	movi	r3,1
 d007dc4:	9d000044 	addi	r20,r19,1
 d007dc8:	d8c00015 	stw	r3,0(sp)
 d007dcc:	003f8206 	br	d007bd8 <__sfvwrite_r+0x288>
 d007dd0:	9080030b 	ldhu	r2,12(r18)
 d007dd4:	00c00244 	movi	r3,9
 d007dd8:	013fffc4 	movi	r4,-1
 d007ddc:	10801014 	ori	r2,r2,64
 d007de0:	9080030d 	sth	r2,12(r18)
 d007de4:	e0c00015 	stw	r3,0(fp)
 d007de8:	003f0606 	br	d007a04 <__sfvwrite_r+0xb4>

0d007dec <_fwalk_reent>:
 d007dec:	defff704 	addi	sp,sp,-36
 d007df0:	dcc00315 	stw	r19,12(sp)
 d007df4:	24c0b804 	addi	r19,r4,736
 d007df8:	dd800615 	stw	r22,24(sp)
 d007dfc:	dd400515 	stw	r21,20(sp)
 d007e00:	dfc00815 	stw	ra,32(sp)
 d007e04:	ddc00715 	stw	r23,28(sp)
 d007e08:	dd000415 	stw	r20,16(sp)
 d007e0c:	dc800215 	stw	r18,8(sp)
 d007e10:	dc400115 	stw	r17,4(sp)
 d007e14:	dc000015 	stw	r16,0(sp)
 d007e18:	202b883a 	mov	r21,r4
 d007e1c:	282d883a 	mov	r22,r5
 d007e20:	d0071280 	call	d007128 <__sfp_lock_acquire>
 d007e24:	98002126 	beq	r19,zero,d007eac <_fwalk_reent+0xc0>
 d007e28:	002f883a 	mov	r23,zero
 d007e2c:	9c800117 	ldw	r18,4(r19)
 d007e30:	9c000217 	ldw	r16,8(r19)
 d007e34:	90bfffc4 	addi	r2,r18,-1
 d007e38:	10000d16 	blt	r2,zero,d007e70 <_fwalk_reent+0x84>
 d007e3c:	0023883a 	mov	r17,zero
 d007e40:	053fffc4 	movi	r20,-1
 d007e44:	8080030f 	ldh	r2,12(r16)
 d007e48:	8c400044 	addi	r17,r17,1
 d007e4c:	10000626 	beq	r2,zero,d007e68 <_fwalk_reent+0x7c>
 d007e50:	8080038f 	ldh	r2,14(r16)
 d007e54:	800b883a 	mov	r5,r16
 d007e58:	a809883a 	mov	r4,r21
 d007e5c:	15000226 	beq	r2,r20,d007e68 <_fwalk_reent+0x7c>
 d007e60:	b03ee83a 	callr	r22
 d007e64:	b8aeb03a 	or	r23,r23,r2
 d007e68:	84001704 	addi	r16,r16,92
 d007e6c:	947ff51e 	bne	r18,r17,d007e44 <_fwalk_reent+0x58>
 d007e70:	9cc00017 	ldw	r19,0(r19)
 d007e74:	983fed1e 	bne	r19,zero,d007e2c <_fwalk_reent+0x40>
 d007e78:	d00712c0 	call	d00712c <__sfp_lock_release>
 d007e7c:	b805883a 	mov	r2,r23
 d007e80:	dfc00817 	ldw	ra,32(sp)
 d007e84:	ddc00717 	ldw	r23,28(sp)
 d007e88:	dd800617 	ldw	r22,24(sp)
 d007e8c:	dd400517 	ldw	r21,20(sp)
 d007e90:	dd000417 	ldw	r20,16(sp)
 d007e94:	dcc00317 	ldw	r19,12(sp)
 d007e98:	dc800217 	ldw	r18,8(sp)
 d007e9c:	dc400117 	ldw	r17,4(sp)
 d007ea0:	dc000017 	ldw	r16,0(sp)
 d007ea4:	dec00904 	addi	sp,sp,36
 d007ea8:	f800283a 	ret
 d007eac:	002f883a 	mov	r23,zero
 d007eb0:	003ff106 	br	d007e78 <_fwalk_reent+0x8c>

0d007eb4 <_fwalk>:
 d007eb4:	defff804 	addi	sp,sp,-32
 d007eb8:	dcc00315 	stw	r19,12(sp)
 d007ebc:	24c0b804 	addi	r19,r4,736
 d007ec0:	dd400515 	stw	r21,20(sp)
 d007ec4:	dfc00715 	stw	ra,28(sp)
 d007ec8:	dd800615 	stw	r22,24(sp)
 d007ecc:	dd000415 	stw	r20,16(sp)
 d007ed0:	dc800215 	stw	r18,8(sp)
 d007ed4:	dc400115 	stw	r17,4(sp)
 d007ed8:	dc000015 	stw	r16,0(sp)
 d007edc:	282b883a 	mov	r21,r5
 d007ee0:	d0071280 	call	d007128 <__sfp_lock_acquire>
 d007ee4:	98001f26 	beq	r19,zero,d007f64 <_fwalk+0xb0>
 d007ee8:	002d883a 	mov	r22,zero
 d007eec:	9c800117 	ldw	r18,4(r19)
 d007ef0:	9c000217 	ldw	r16,8(r19)
 d007ef4:	90bfffc4 	addi	r2,r18,-1
 d007ef8:	10000c16 	blt	r2,zero,d007f2c <_fwalk+0x78>
 d007efc:	0023883a 	mov	r17,zero
 d007f00:	053fffc4 	movi	r20,-1
 d007f04:	8080030f 	ldh	r2,12(r16)
 d007f08:	8c400044 	addi	r17,r17,1
 d007f0c:	10000526 	beq	r2,zero,d007f24 <_fwalk+0x70>
 d007f10:	8080038f 	ldh	r2,14(r16)
 d007f14:	8009883a 	mov	r4,r16
 d007f18:	15000226 	beq	r2,r20,d007f24 <_fwalk+0x70>
 d007f1c:	a83ee83a 	callr	r21
 d007f20:	b0acb03a 	or	r22,r22,r2
 d007f24:	84001704 	addi	r16,r16,92
 d007f28:	947ff61e 	bne	r18,r17,d007f04 <_fwalk+0x50>
 d007f2c:	9cc00017 	ldw	r19,0(r19)
 d007f30:	983fee1e 	bne	r19,zero,d007eec <_fwalk+0x38>
 d007f34:	d00712c0 	call	d00712c <__sfp_lock_release>
 d007f38:	b005883a 	mov	r2,r22
 d007f3c:	dfc00717 	ldw	ra,28(sp)
 d007f40:	dd800617 	ldw	r22,24(sp)
 d007f44:	dd400517 	ldw	r21,20(sp)
 d007f48:	dd000417 	ldw	r20,16(sp)
 d007f4c:	dcc00317 	ldw	r19,12(sp)
 d007f50:	dc800217 	ldw	r18,8(sp)
 d007f54:	dc400117 	ldw	r17,4(sp)
 d007f58:	dc000017 	ldw	r16,0(sp)
 d007f5c:	dec00804 	addi	sp,sp,32
 d007f60:	f800283a 	ret
 d007f64:	002d883a 	mov	r22,zero
 d007f68:	003ff206 	br	d007f34 <_fwalk+0x80>

0d007f6c <__locale_charset>:
 d007f6c:	d0a00417 	ldw	r2,-32752(gp)
 d007f70:	f800283a 	ret

0d007f74 <_localeconv_r>:
 d007f74:	00834174 	movhi	r2,3333
 d007f78:	10b8d804 	addi	r2,r2,-7328
 d007f7c:	f800283a 	ret

0d007f80 <localeconv>:
 d007f80:	00834174 	movhi	r2,3333
 d007f84:	10922004 	addi	r2,r2,18560
 d007f88:	11000017 	ldw	r4,0(r2)
 d007f8c:	d007f741 	jmpi	d007f74 <_localeconv_r>

0d007f90 <_setlocale_r>:
 d007f90:	defffc04 	addi	sp,sp,-16
 d007f94:	00c34174 	movhi	r3,3333
 d007f98:	18f6c404 	addi	r3,r3,-9456
 d007f9c:	dc800215 	stw	r18,8(sp)
 d007fa0:	dc400115 	stw	r17,4(sp)
 d007fa4:	dc000015 	stw	r16,0(sp)
 d007fa8:	2023883a 	mov	r17,r4
 d007fac:	2825883a 	mov	r18,r5
 d007fb0:	dfc00315 	stw	ra,12(sp)
 d007fb4:	3021883a 	mov	r16,r6
 d007fb8:	3009883a 	mov	r4,r6
 d007fbc:	180b883a 	mov	r5,r3
 d007fc0:	30000926 	beq	r6,zero,d007fe8 <_setlocale_r+0x58>
 d007fc4:	d00a4740 	call	d00a474 <strcmp>
 d007fc8:	8009883a 	mov	r4,r16
 d007fcc:	01434174 	movhi	r5,3333
 d007fd0:	2978bf04 	addi	r5,r5,-7428
 d007fd4:	10000b1e 	bne	r2,zero,d008004 <_setlocale_r+0x74>
 d007fd8:	8c000d15 	stw	r16,52(r17)
 d007fdc:	8c800c15 	stw	r18,48(r17)
 d007fe0:	00c34174 	movhi	r3,3333
 d007fe4:	18f6c404 	addi	r3,r3,-9456
 d007fe8:	1805883a 	mov	r2,r3
 d007fec:	dfc00317 	ldw	ra,12(sp)
 d007ff0:	dc800217 	ldw	r18,8(sp)
 d007ff4:	dc400117 	ldw	r17,4(sp)
 d007ff8:	dc000017 	ldw	r16,0(sp)
 d007ffc:	dec00404 	addi	sp,sp,16
 d008000:	f800283a 	ret
 d008004:	d00a4740 	call	d00a474 <strcmp>
 d008008:	0007883a 	mov	r3,zero
 d00800c:	103ff226 	beq	r2,zero,d007fd8 <_setlocale_r+0x48>
 d008010:	003ff506 	br	d007fe8 <_setlocale_r+0x58>

0d008014 <setlocale>:
 d008014:	01834174 	movhi	r6,3333
 d008018:	31922004 	addi	r6,r6,18560
 d00801c:	2007883a 	mov	r3,r4
 d008020:	31000017 	ldw	r4,0(r6)
 d008024:	280d883a 	mov	r6,r5
 d008028:	180b883a 	mov	r5,r3
 d00802c:	d007f901 	jmpi	d007f90 <_setlocale_r>

0d008030 <__smakebuf_r>:
 d008030:	2880030b 	ldhu	r2,12(r5)
 d008034:	deffed04 	addi	sp,sp,-76
 d008038:	dc401015 	stw	r17,64(sp)
 d00803c:	1080008c 	andi	r2,r2,2
 d008040:	dc000f15 	stw	r16,60(sp)
 d008044:	dfc01215 	stw	ra,72(sp)
 d008048:	dc801115 	stw	r18,68(sp)
 d00804c:	2821883a 	mov	r16,r5
 d008050:	2023883a 	mov	r17,r4
 d008054:	10000b26 	beq	r2,zero,d008084 <__smakebuf_r+0x54>
 d008058:	28c010c4 	addi	r3,r5,67
 d00805c:	00800044 	movi	r2,1
 d008060:	28800515 	stw	r2,20(r5)
 d008064:	28c00415 	stw	r3,16(r5)
 d008068:	28c00015 	stw	r3,0(r5)
 d00806c:	dfc01217 	ldw	ra,72(sp)
 d008070:	dc801117 	ldw	r18,68(sp)
 d008074:	dc401017 	ldw	r17,64(sp)
 d008078:	dc000f17 	ldw	r16,60(sp)
 d00807c:	dec01304 	addi	sp,sp,76
 d008080:	f800283a 	ret
 d008084:	2940038f 	ldh	r5,14(r5)
 d008088:	28002116 	blt	r5,zero,d008110 <__smakebuf_r+0xe0>
 d00808c:	d80d883a 	mov	r6,sp
 d008090:	d00a8040 	call	d00a804 <_fstat_r>
 d008094:	10001e16 	blt	r2,zero,d008110 <__smakebuf_r+0xe0>
 d008098:	d8800117 	ldw	r2,4(sp)
 d00809c:	00e00014 	movui	r3,32768
 d0080a0:	113c000c 	andi	r4,r2,61440
 d0080a4:	20c03126 	beq	r4,r3,d00816c <__smakebuf_r+0x13c>
 d0080a8:	8080030b 	ldhu	r2,12(r16)
 d0080ac:	00c80004 	movi	r3,8192
 d0080b0:	10820014 	ori	r2,r2,2048
 d0080b4:	8080030d 	sth	r2,12(r16)
 d0080b8:	20c01e26 	beq	r4,r3,d008134 <__smakebuf_r+0x104>
 d0080bc:	04810004 	movi	r18,1024
 d0080c0:	8809883a 	mov	r4,r17
 d0080c4:	900b883a 	mov	r5,r18
 d0080c8:	d0081c40 	call	d0081c4 <_malloc_r>
 d0080cc:	1009883a 	mov	r4,r2
 d0080d0:	10003126 	beq	r2,zero,d008198 <__smakebuf_r+0x168>
 d0080d4:	80c0030b 	ldhu	r3,12(r16)
 d0080d8:	00834034 	movhi	r2,3328
 d0080dc:	109c8704 	addi	r2,r2,29212
 d0080e0:	88800f15 	stw	r2,60(r17)
 d0080e4:	18c02014 	ori	r3,r3,128
 d0080e8:	84800515 	stw	r18,20(r16)
 d0080ec:	80c0030d 	sth	r3,12(r16)
 d0080f0:	81000415 	stw	r4,16(r16)
 d0080f4:	81000015 	stw	r4,0(r16)
 d0080f8:	dfc01217 	ldw	ra,72(sp)
 d0080fc:	dc801117 	ldw	r18,68(sp)
 d008100:	dc401017 	ldw	r17,64(sp)
 d008104:	dc000f17 	ldw	r16,60(sp)
 d008108:	dec01304 	addi	sp,sp,76
 d00810c:	f800283a 	ret
 d008110:	80c0030b 	ldhu	r3,12(r16)
 d008114:	1880200c 	andi	r2,r3,128
 d008118:	10000426 	beq	r2,zero,d00812c <__smakebuf_r+0xfc>
 d00811c:	04801004 	movi	r18,64
 d008120:	18820014 	ori	r2,r3,2048
 d008124:	8080030d 	sth	r2,12(r16)
 d008128:	003fe506 	br	d0080c0 <__smakebuf_r+0x90>
 d00812c:	04810004 	movi	r18,1024
 d008130:	003ffb06 	br	d008120 <__smakebuf_r+0xf0>
 d008134:	8140038f 	ldh	r5,14(r16)
 d008138:	8809883a 	mov	r4,r17
 d00813c:	d00a8780 	call	d00a878 <_isatty_r>
 d008140:	103fde26 	beq	r2,zero,d0080bc <__smakebuf_r+0x8c>
 d008144:	8080030b 	ldhu	r2,12(r16)
 d008148:	80c010c4 	addi	r3,r16,67
 d00814c:	04810004 	movi	r18,1024
 d008150:	10800054 	ori	r2,r2,1
 d008154:	8080030d 	sth	r2,12(r16)
 d008158:	00800044 	movi	r2,1
 d00815c:	80c00415 	stw	r3,16(r16)
 d008160:	80800515 	stw	r2,20(r16)
 d008164:	80c00015 	stw	r3,0(r16)
 d008168:	003fd506 	br	d0080c0 <__smakebuf_r+0x90>
 d00816c:	80c00a17 	ldw	r3,40(r16)
 d008170:	00834074 	movhi	r2,3329
 d008174:	10a8cc04 	addi	r2,r2,-23760
 d008178:	18bfcb1e 	bne	r3,r2,d0080a8 <__smakebuf_r+0x78>
 d00817c:	8080030b 	ldhu	r2,12(r16)
 d008180:	00c10004 	movi	r3,1024
 d008184:	1825883a 	mov	r18,r3
 d008188:	10c4b03a 	or	r2,r2,r3
 d00818c:	8080030d 	sth	r2,12(r16)
 d008190:	80c01315 	stw	r3,76(r16)
 d008194:	003fca06 	br	d0080c0 <__smakebuf_r+0x90>
 d008198:	8100030b 	ldhu	r4,12(r16)
 d00819c:	2080800c 	andi	r2,r4,512
 d0081a0:	103fb21e 	bne	r2,zero,d00806c <__smakebuf_r+0x3c>
 d0081a4:	80c010c4 	addi	r3,r16,67
 d0081a8:	21000094 	ori	r4,r4,2
 d0081ac:	00800044 	movi	r2,1
 d0081b0:	80800515 	stw	r2,20(r16)
 d0081b4:	8100030d 	sth	r4,12(r16)
 d0081b8:	80c00415 	stw	r3,16(r16)
 d0081bc:	80c00015 	stw	r3,0(r16)
 d0081c0:	003faa06 	br	d00806c <__smakebuf_r+0x3c>

0d0081c4 <_malloc_r>:
 d0081c4:	defff604 	addi	sp,sp,-40
 d0081c8:	28c002c4 	addi	r3,r5,11
 d0081cc:	00800584 	movi	r2,22
 d0081d0:	dc800215 	stw	r18,8(sp)
 d0081d4:	dfc00915 	stw	ra,36(sp)
 d0081d8:	df000815 	stw	fp,32(sp)
 d0081dc:	ddc00715 	stw	r23,28(sp)
 d0081e0:	dd800615 	stw	r22,24(sp)
 d0081e4:	dd400515 	stw	r21,20(sp)
 d0081e8:	dd000415 	stw	r20,16(sp)
 d0081ec:	dcc00315 	stw	r19,12(sp)
 d0081f0:	dc400115 	stw	r17,4(sp)
 d0081f4:	dc000015 	stw	r16,0(sp)
 d0081f8:	2025883a 	mov	r18,r4
 d0081fc:	10c01236 	bltu	r2,r3,d008248 <_malloc_r+0x84>
 d008200:	04400404 	movi	r17,16
 d008204:	8940142e 	bgeu	r17,r5,d008258 <_malloc_r+0x94>
 d008208:	00800304 	movi	r2,12
 d00820c:	0007883a 	mov	r3,zero
 d008210:	90800015 	stw	r2,0(r18)
 d008214:	1805883a 	mov	r2,r3
 d008218:	dfc00917 	ldw	ra,36(sp)
 d00821c:	df000817 	ldw	fp,32(sp)
 d008220:	ddc00717 	ldw	r23,28(sp)
 d008224:	dd800617 	ldw	r22,24(sp)
 d008228:	dd400517 	ldw	r21,20(sp)
 d00822c:	dd000417 	ldw	r20,16(sp)
 d008230:	dcc00317 	ldw	r19,12(sp)
 d008234:	dc800217 	ldw	r18,8(sp)
 d008238:	dc400117 	ldw	r17,4(sp)
 d00823c:	dc000017 	ldw	r16,0(sp)
 d008240:	dec00a04 	addi	sp,sp,40
 d008244:	f800283a 	ret
 d008248:	00bffe04 	movi	r2,-8
 d00824c:	18a2703a 	and	r17,r3,r2
 d008250:	883fed16 	blt	r17,zero,d008208 <_malloc_r+0x44>
 d008254:	897fec36 	bltu	r17,r5,d008208 <_malloc_r+0x44>
 d008258:	9009883a 	mov	r4,r18
 d00825c:	d00d7cc0 	call	d00d7cc <__malloc_lock>
 d008260:	00807dc4 	movi	r2,503
 d008264:	14402b2e 	bgeu	r2,r17,d008314 <_malloc_r+0x150>
 d008268:	8806d27a 	srli	r3,r17,9
 d00826c:	18003f1e 	bne	r3,zero,d00836c <_malloc_r+0x1a8>
 d008270:	880cd0fa 	srli	r6,r17,3
 d008274:	300490fa 	slli	r2,r6,3
 d008278:	02c34174 	movhi	r11,3333
 d00827c:	5acb4704 	addi	r11,r11,11548
 d008280:	12cb883a 	add	r5,r2,r11
 d008284:	2c000317 	ldw	r16,12(r5)
 d008288:	580f883a 	mov	r7,r11
 d00828c:	2c00041e 	bne	r5,r16,d0082a0 <_malloc_r+0xdc>
 d008290:	00000a06 	br	d0082bc <_malloc_r+0xf8>
 d008294:	1800860e 	bge	r3,zero,d0084b0 <_malloc_r+0x2ec>
 d008298:	84000317 	ldw	r16,12(r16)
 d00829c:	2c000726 	beq	r5,r16,d0082bc <_malloc_r+0xf8>
 d0082a0:	80800117 	ldw	r2,4(r16)
 d0082a4:	00ffff04 	movi	r3,-4
 d0082a8:	10c8703a 	and	r4,r2,r3
 d0082ac:	2447c83a 	sub	r3,r4,r17
 d0082b0:	008003c4 	movi	r2,15
 d0082b4:	10fff70e 	bge	r2,r3,d008294 <_malloc_r+0xd0>
 d0082b8:	31bfffc4 	addi	r6,r6,-1
 d0082bc:	32400044 	addi	r9,r6,1
 d0082c0:	02834174 	movhi	r10,3333
 d0082c4:	528b4904 	addi	r10,r10,11556
 d0082c8:	54000217 	ldw	r16,8(r10)
 d0082cc:	8280a026 	beq	r16,r10,d008550 <_malloc_r+0x38c>
 d0082d0:	80800117 	ldw	r2,4(r16)
 d0082d4:	00ffff04 	movi	r3,-4
 d0082d8:	10ca703a 	and	r5,r2,r3
 d0082dc:	2c4dc83a 	sub	r6,r5,r17
 d0082e0:	008003c4 	movi	r2,15
 d0082e4:	11808316 	blt	r2,r6,d0084f4 <_malloc_r+0x330>
 d0082e8:	52800315 	stw	r10,12(r10)
 d0082ec:	52800215 	stw	r10,8(r10)
 d0082f0:	30002916 	blt	r6,zero,d008398 <_malloc_r+0x1d4>
 d0082f4:	8147883a 	add	r3,r16,r5
 d0082f8:	18800117 	ldw	r2,4(r3)
 d0082fc:	9009883a 	mov	r4,r18
 d008300:	10800054 	ori	r2,r2,1
 d008304:	18800115 	stw	r2,4(r3)
 d008308:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d00830c:	80c00204 	addi	r3,r16,8
 d008310:	003fc006 	br	d008214 <_malloc_r+0x50>
 d008314:	02c34174 	movhi	r11,3333
 d008318:	5acb4704 	addi	r11,r11,11548
 d00831c:	8ac5883a 	add	r2,r17,r11
 d008320:	14000317 	ldw	r16,12(r2)
 d008324:	580f883a 	mov	r7,r11
 d008328:	8806d0fa 	srli	r3,r17,3
 d00832c:	14006c26 	beq	r2,r16,d0084e0 <_malloc_r+0x31c>
 d008330:	80c00117 	ldw	r3,4(r16)
 d008334:	00bfff04 	movi	r2,-4
 d008338:	81800317 	ldw	r6,12(r16)
 d00833c:	1886703a 	and	r3,r3,r2
 d008340:	80c7883a 	add	r3,r16,r3
 d008344:	18800117 	ldw	r2,4(r3)
 d008348:	81400217 	ldw	r5,8(r16)
 d00834c:	9009883a 	mov	r4,r18
 d008350:	10800054 	ori	r2,r2,1
 d008354:	18800115 	stw	r2,4(r3)
 d008358:	31400215 	stw	r5,8(r6)
 d00835c:	29800315 	stw	r6,12(r5)
 d008360:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d008364:	80c00204 	addi	r3,r16,8
 d008368:	003faa06 	br	d008214 <_malloc_r+0x50>
 d00836c:	00800104 	movi	r2,4
 d008370:	10c0052e 	bgeu	r2,r3,d008388 <_malloc_r+0x1c4>
 d008374:	00800504 	movi	r2,20
 d008378:	10c07836 	bltu	r2,r3,d00855c <_malloc_r+0x398>
 d00837c:	198016c4 	addi	r6,r3,91
 d008380:	300490fa 	slli	r2,r6,3
 d008384:	003fbc06 	br	d008278 <_malloc_r+0xb4>
 d008388:	8804d1ba 	srli	r2,r17,6
 d00838c:	11800e04 	addi	r6,r2,56
 d008390:	300490fa 	slli	r2,r6,3
 d008394:	003fb806 	br	d008278 <_malloc_r+0xb4>
 d008398:	00807fc4 	movi	r2,511
 d00839c:	1140bb36 	bltu	r2,r5,d00868c <_malloc_r+0x4c8>
 d0083a0:	2806d0fa 	srli	r3,r5,3
 d0083a4:	573ffe04 	addi	fp,r10,-8
 d0083a8:	00800044 	movi	r2,1
 d0083ac:	180890fa 	slli	r4,r3,3
 d0083b0:	1807d0ba 	srai	r3,r3,2
 d0083b4:	e1c00117 	ldw	r7,4(fp)
 d0083b8:	5909883a 	add	r4,r11,r4
 d0083bc:	21400217 	ldw	r5,8(r4)
 d0083c0:	10c4983a 	sll	r2,r2,r3
 d0083c4:	81000315 	stw	r4,12(r16)
 d0083c8:	81400215 	stw	r5,8(r16)
 d0083cc:	388eb03a 	or	r7,r7,r2
 d0083d0:	2c000315 	stw	r16,12(r5)
 d0083d4:	24000215 	stw	r16,8(r4)
 d0083d8:	e1c00115 	stw	r7,4(fp)
 d0083dc:	4807883a 	mov	r3,r9
 d0083e0:	4800cd16 	blt	r9,zero,d008718 <_malloc_r+0x554>
 d0083e4:	1807d0ba 	srai	r3,r3,2
 d0083e8:	00800044 	movi	r2,1
 d0083ec:	10c8983a 	sll	r4,r2,r3
 d0083f0:	39004436 	bltu	r7,r4,d008504 <_malloc_r+0x340>
 d0083f4:	21c4703a 	and	r2,r4,r7
 d0083f8:	10000a1e 	bne	r2,zero,d008424 <_malloc_r+0x260>
 d0083fc:	2109883a 	add	r4,r4,r4
 d008400:	00bfff04 	movi	r2,-4
 d008404:	4884703a 	and	r2,r9,r2
 d008408:	3906703a 	and	r3,r7,r4
 d00840c:	12400104 	addi	r9,r2,4
 d008410:	1800041e 	bne	r3,zero,d008424 <_malloc_r+0x260>
 d008414:	2109883a 	add	r4,r4,r4
 d008418:	3904703a 	and	r2,r7,r4
 d00841c:	4a400104 	addi	r9,r9,4
 d008420:	103ffc26 	beq	r2,zero,d008414 <_malloc_r+0x250>
 d008424:	480490fa 	slli	r2,r9,3
 d008428:	4819883a 	mov	r12,r9
 d00842c:	023fff04 	movi	r8,-4
 d008430:	589b883a 	add	r13,r11,r2
 d008434:	6807883a 	mov	r3,r13
 d008438:	014003c4 	movi	r5,15
 d00843c:	1c000317 	ldw	r16,12(r3)
 d008440:	1c00041e 	bne	r3,r16,d008454 <_malloc_r+0x290>
 d008444:	0000a706 	br	d0086e4 <_malloc_r+0x520>
 d008448:	3000ab0e 	bge	r6,zero,d0086f8 <_malloc_r+0x534>
 d00844c:	84000317 	ldw	r16,12(r16)
 d008450:	1c00a426 	beq	r3,r16,d0086e4 <_malloc_r+0x520>
 d008454:	80800117 	ldw	r2,4(r16)
 d008458:	1204703a 	and	r2,r2,r8
 d00845c:	144dc83a 	sub	r6,r2,r17
 d008460:	29bff90e 	bge	r5,r6,d008448 <_malloc_r+0x284>
 d008464:	81000317 	ldw	r4,12(r16)
 d008468:	80c00217 	ldw	r3,8(r16)
 d00846c:	89400054 	ori	r5,r17,1
 d008470:	8445883a 	add	r2,r16,r17
 d008474:	20c00215 	stw	r3,8(r4)
 d008478:	19000315 	stw	r4,12(r3)
 d00847c:	81400115 	stw	r5,4(r16)
 d008480:	1187883a 	add	r3,r2,r6
 d008484:	31000054 	ori	r4,r6,1
 d008488:	50800315 	stw	r2,12(r10)
 d00848c:	50800215 	stw	r2,8(r10)
 d008490:	19800015 	stw	r6,0(r3)
 d008494:	11000115 	stw	r4,4(r2)
 d008498:	12800215 	stw	r10,8(r2)
 d00849c:	12800315 	stw	r10,12(r2)
 d0084a0:	9009883a 	mov	r4,r18
 d0084a4:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d0084a8:	80c00204 	addi	r3,r16,8
 d0084ac:	003f5906 	br	d008214 <_malloc_r+0x50>
 d0084b0:	8109883a 	add	r4,r16,r4
 d0084b4:	20800117 	ldw	r2,4(r4)
 d0084b8:	80c00217 	ldw	r3,8(r16)
 d0084bc:	81400317 	ldw	r5,12(r16)
 d0084c0:	10800054 	ori	r2,r2,1
 d0084c4:	20800115 	stw	r2,4(r4)
 d0084c8:	28c00215 	stw	r3,8(r5)
 d0084cc:	19400315 	stw	r5,12(r3)
 d0084d0:	9009883a 	mov	r4,r18
 d0084d4:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d0084d8:	80c00204 	addi	r3,r16,8
 d0084dc:	003f4d06 	br	d008214 <_malloc_r+0x50>
 d0084e0:	80800204 	addi	r2,r16,8
 d0084e4:	14000317 	ldw	r16,12(r2)
 d0084e8:	143f911e 	bne	r2,r16,d008330 <_malloc_r+0x16c>
 d0084ec:	1a400084 	addi	r9,r3,2
 d0084f0:	003f7306 	br	d0082c0 <_malloc_r+0xfc>
 d0084f4:	88c00054 	ori	r3,r17,1
 d0084f8:	8445883a 	add	r2,r16,r17
 d0084fc:	80c00115 	stw	r3,4(r16)
 d008500:	003fdf06 	br	d008480 <_malloc_r+0x2bc>
 d008504:	e4000217 	ldw	r16,8(fp)
 d008508:	00bfff04 	movi	r2,-4
 d00850c:	80c00117 	ldw	r3,4(r16)
 d008510:	802d883a 	mov	r22,r16
 d008514:	18aa703a 	and	r21,r3,r2
 d008518:	ac401636 	bltu	r21,r17,d008574 <_malloc_r+0x3b0>
 d00851c:	ac49c83a 	sub	r4,r21,r17
 d008520:	008003c4 	movi	r2,15
 d008524:	1100130e 	bge	r2,r4,d008574 <_malloc_r+0x3b0>
 d008528:	88800054 	ori	r2,r17,1
 d00852c:	8447883a 	add	r3,r16,r17
 d008530:	80800115 	stw	r2,4(r16)
 d008534:	20800054 	ori	r2,r4,1
 d008538:	18800115 	stw	r2,4(r3)
 d00853c:	e0c00215 	stw	r3,8(fp)
 d008540:	9009883a 	mov	r4,r18
 d008544:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d008548:	80c00204 	addi	r3,r16,8
 d00854c:	003f3106 	br	d008214 <_malloc_r+0x50>
 d008550:	39c00117 	ldw	r7,4(r7)
 d008554:	573ffe04 	addi	fp,r10,-8
 d008558:	003fa006 	br	d0083dc <_malloc_r+0x218>
 d00855c:	00801504 	movi	r2,84
 d008560:	10c06736 	bltu	r2,r3,d008700 <_malloc_r+0x53c>
 d008564:	8804d33a 	srli	r2,r17,12
 d008568:	11801b84 	addi	r6,r2,110
 d00856c:	300490fa 	slli	r2,r6,3
 d008570:	003f4106 	br	d008278 <_malloc_r+0xb4>
 d008574:	d0a8df17 	ldw	r2,-23684(gp)
 d008578:	d0e00617 	ldw	r3,-32744(gp)
 d00857c:	053fffc4 	movi	r20,-1
 d008580:	10800404 	addi	r2,r2,16
 d008584:	88a7883a 	add	r19,r17,r2
 d008588:	1d000326 	beq	r3,r20,d008598 <_malloc_r+0x3d4>
 d00858c:	98c3ffc4 	addi	r3,r19,4095
 d008590:	00bc0004 	movi	r2,-4096
 d008594:	18a6703a 	and	r19,r3,r2
 d008598:	9009883a 	mov	r4,r18
 d00859c:	980b883a 	mov	r5,r19
 d0085a0:	d00a2b80 	call	d00a2b8 <_sbrk_r>
 d0085a4:	1009883a 	mov	r4,r2
 d0085a8:	15000426 	beq	r2,r20,d0085bc <_malloc_r+0x3f8>
 d0085ac:	854b883a 	add	r5,r16,r21
 d0085b0:	1029883a 	mov	r20,r2
 d0085b4:	11405a2e 	bgeu	r2,r5,d008720 <_malloc_r+0x55c>
 d0085b8:	87000c26 	beq	r16,fp,d0085ec <_malloc_r+0x428>
 d0085bc:	e4000217 	ldw	r16,8(fp)
 d0085c0:	80c00117 	ldw	r3,4(r16)
 d0085c4:	00bfff04 	movi	r2,-4
 d0085c8:	1884703a 	and	r2,r3,r2
 d0085cc:	14400336 	bltu	r2,r17,d0085dc <_malloc_r+0x418>
 d0085d0:	1449c83a 	sub	r4,r2,r17
 d0085d4:	008003c4 	movi	r2,15
 d0085d8:	113fd316 	blt	r2,r4,d008528 <_malloc_r+0x364>
 d0085dc:	9009883a 	mov	r4,r18
 d0085e0:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d0085e4:	0007883a 	mov	r3,zero
 d0085e8:	003f0a06 	br	d008214 <_malloc_r+0x50>
 d0085ec:	05c34174 	movhi	r23,3333
 d0085f0:	bddcf704 	addi	r23,r23,29660
 d0085f4:	b8800017 	ldw	r2,0(r23)
 d0085f8:	988d883a 	add	r6,r19,r2
 d0085fc:	b9800015 	stw	r6,0(r23)
 d008600:	d0e00617 	ldw	r3,-32744(gp)
 d008604:	00bfffc4 	movi	r2,-1
 d008608:	18808e26 	beq	r3,r2,d008844 <_malloc_r+0x680>
 d00860c:	2145c83a 	sub	r2,r4,r5
 d008610:	3085883a 	add	r2,r6,r2
 d008614:	b8800015 	stw	r2,0(r23)
 d008618:	20c001cc 	andi	r3,r4,7
 d00861c:	18005f1e 	bne	r3,zero,d00879c <_malloc_r+0x5d8>
 d008620:	000b883a 	mov	r5,zero
 d008624:	a4c5883a 	add	r2,r20,r19
 d008628:	1083ffcc 	andi	r2,r2,4095
 d00862c:	00c40004 	movi	r3,4096
 d008630:	1887c83a 	sub	r3,r3,r2
 d008634:	28e7883a 	add	r19,r5,r3
 d008638:	9009883a 	mov	r4,r18
 d00863c:	980b883a 	mov	r5,r19
 d008640:	d00a2b80 	call	d00a2b8 <_sbrk_r>
 d008644:	1007883a 	mov	r3,r2
 d008648:	00bfffc4 	movi	r2,-1
 d00864c:	18807a26 	beq	r3,r2,d008838 <_malloc_r+0x674>
 d008650:	1d05c83a 	sub	r2,r3,r20
 d008654:	9885883a 	add	r2,r19,r2
 d008658:	10c00054 	ori	r3,r2,1
 d00865c:	b8800017 	ldw	r2,0(r23)
 d008660:	a021883a 	mov	r16,r20
 d008664:	a0c00115 	stw	r3,4(r20)
 d008668:	9885883a 	add	r2,r19,r2
 d00866c:	b8800015 	stw	r2,0(r23)
 d008670:	e5000215 	stw	r20,8(fp)
 d008674:	b7003626 	beq	r22,fp,d008750 <_malloc_r+0x58c>
 d008678:	018003c4 	movi	r6,15
 d00867c:	35404b36 	bltu	r6,r21,d0087ac <_malloc_r+0x5e8>
 d008680:	00800044 	movi	r2,1
 d008684:	a0800115 	stw	r2,4(r20)
 d008688:	003fcd06 	br	d0085c0 <_malloc_r+0x3fc>
 d00868c:	2808d27a 	srli	r4,r5,9
 d008690:	2000371e 	bne	r4,zero,d008770 <_malloc_r+0x5ac>
 d008694:	2808d0fa 	srli	r4,r5,3
 d008698:	200690fa 	slli	r3,r4,3
 d00869c:	1ad1883a 	add	r8,r3,r11
 d0086a0:	41800217 	ldw	r6,8(r8)
 d0086a4:	41805b26 	beq	r8,r6,d008814 <_malloc_r+0x650>
 d0086a8:	30800117 	ldw	r2,4(r6)
 d0086ac:	00ffff04 	movi	r3,-4
 d0086b0:	10c4703a 	and	r2,r2,r3
 d0086b4:	2880022e 	bgeu	r5,r2,d0086c0 <_malloc_r+0x4fc>
 d0086b8:	31800217 	ldw	r6,8(r6)
 d0086bc:	41bffa1e 	bne	r8,r6,d0086a8 <_malloc_r+0x4e4>
 d0086c0:	32000317 	ldw	r8,12(r6)
 d0086c4:	39c00117 	ldw	r7,4(r7)
 d0086c8:	82000315 	stw	r8,12(r16)
 d0086cc:	81800215 	stw	r6,8(r16)
 d0086d0:	07034174 	movhi	fp,3333
 d0086d4:	e70b4704 	addi	fp,fp,11548
 d0086d8:	34000315 	stw	r16,12(r6)
 d0086dc:	44000215 	stw	r16,8(r8)
 d0086e0:	003f3e06 	br	d0083dc <_malloc_r+0x218>
 d0086e4:	63000044 	addi	r12,r12,1
 d0086e8:	608000cc 	andi	r2,r12,3
 d0086ec:	10005d26 	beq	r2,zero,d008864 <_malloc_r+0x6a0>
 d0086f0:	18c00204 	addi	r3,r3,8
 d0086f4:	003f5106 	br	d00843c <_malloc_r+0x278>
 d0086f8:	8089883a 	add	r4,r16,r2
 d0086fc:	003f6d06 	br	d0084b4 <_malloc_r+0x2f0>
 d008700:	00805504 	movi	r2,340
 d008704:	10c02036 	bltu	r2,r3,d008788 <_malloc_r+0x5c4>
 d008708:	8804d3fa 	srli	r2,r17,15
 d00870c:	11801dc4 	addi	r6,r2,119
 d008710:	300490fa 	slli	r2,r6,3
 d008714:	003ed806 	br	d008278 <_malloc_r+0xb4>
 d008718:	48c000c4 	addi	r3,r9,3
 d00871c:	003f3106 	br	d0083e4 <_malloc_r+0x220>
 d008720:	05c34174 	movhi	r23,3333
 d008724:	bddcf704 	addi	r23,r23,29660
 d008728:	b8800017 	ldw	r2,0(r23)
 d00872c:	988d883a 	add	r6,r19,r2
 d008730:	b9800015 	stw	r6,0(r23)
 d008734:	293fb21e 	bne	r5,r4,d008600 <_malloc_r+0x43c>
 d008738:	2083ffcc 	andi	r2,r4,4095
 d00873c:	103fb01e 	bne	r2,zero,d008600 <_malloc_r+0x43c>
 d008740:	e4000217 	ldw	r16,8(fp)
 d008744:	9d45883a 	add	r2,r19,r21
 d008748:	10800054 	ori	r2,r2,1
 d00874c:	80800115 	stw	r2,4(r16)
 d008750:	b8c00017 	ldw	r3,0(r23)
 d008754:	d0a8e017 	ldw	r2,-23680(gp)
 d008758:	10c0012e 	bgeu	r2,r3,d008760 <_malloc_r+0x59c>
 d00875c:	d0e8e015 	stw	r3,-23680(gp)
 d008760:	d0a8e117 	ldw	r2,-23676(gp)
 d008764:	10ff962e 	bgeu	r2,r3,d0085c0 <_malloc_r+0x3fc>
 d008768:	d0e8e115 	stw	r3,-23676(gp)
 d00876c:	003f9406 	br	d0085c0 <_malloc_r+0x3fc>
 d008770:	00800104 	movi	r2,4
 d008774:	11001e36 	bltu	r2,r4,d0087f0 <_malloc_r+0x62c>
 d008778:	2804d1ba 	srli	r2,r5,6
 d00877c:	11000e04 	addi	r4,r2,56
 d008780:	200690fa 	slli	r3,r4,3
 d008784:	003fc506 	br	d00869c <_malloc_r+0x4d8>
 d008788:	00815504 	movi	r2,1364
 d00878c:	10c01d2e 	bgeu	r2,r3,d008804 <_malloc_r+0x640>
 d008790:	01801f84 	movi	r6,126
 d008794:	0080fc04 	movi	r2,1008
 d008798:	003eb706 	br	d008278 <_malloc_r+0xb4>
 d00879c:	00800204 	movi	r2,8
 d0087a0:	10cbc83a 	sub	r5,r2,r3
 d0087a4:	2169883a 	add	r20,r4,r5
 d0087a8:	003f9e06 	br	d008624 <_malloc_r+0x460>
 d0087ac:	00bffe04 	movi	r2,-8
 d0087b0:	a93ffd04 	addi	r4,r21,-12
 d0087b4:	2088703a 	and	r4,r4,r2
 d0087b8:	b10b883a 	add	r5,r22,r4
 d0087bc:	00c00144 	movi	r3,5
 d0087c0:	28c00215 	stw	r3,8(r5)
 d0087c4:	28c00115 	stw	r3,4(r5)
 d0087c8:	b0800117 	ldw	r2,4(r22)
 d0087cc:	1080004c 	andi	r2,r2,1
 d0087d0:	2084b03a 	or	r2,r4,r2
 d0087d4:	b0800115 	stw	r2,4(r22)
 d0087d8:	313fdd2e 	bgeu	r6,r4,d008750 <_malloc_r+0x58c>
 d0087dc:	b1400204 	addi	r5,r22,8
 d0087e0:	9009883a 	mov	r4,r18
 d0087e4:	d00763c0 	call	d00763c <_free_r>
 d0087e8:	e4000217 	ldw	r16,8(fp)
 d0087ec:	003fd806 	br	d008750 <_malloc_r+0x58c>
 d0087f0:	00800504 	movi	r2,20
 d0087f4:	11001536 	bltu	r2,r4,d00884c <_malloc_r+0x688>
 d0087f8:	210016c4 	addi	r4,r4,91
 d0087fc:	200690fa 	slli	r3,r4,3
 d008800:	003fa606 	br	d00869c <_malloc_r+0x4d8>
 d008804:	8804d4ba 	srli	r2,r17,18
 d008808:	11801f04 	addi	r6,r2,124
 d00880c:	300490fa 	slli	r2,r6,3
 d008810:	003e9906 	br	d008278 <_malloc_r+0xb4>
 d008814:	2009d0ba 	srai	r4,r4,2
 d008818:	01434174 	movhi	r5,3333
 d00881c:	294b4704 	addi	r5,r5,11548
 d008820:	00c00044 	movi	r3,1
 d008824:	28800117 	ldw	r2,4(r5)
 d008828:	1906983a 	sll	r3,r3,r4
 d00882c:	10c4b03a 	or	r2,r2,r3
 d008830:	28800115 	stw	r2,4(r5)
 d008834:	003fa306 	br	d0086c4 <_malloc_r+0x500>
 d008838:	0027883a 	mov	r19,zero
 d00883c:	00c00044 	movi	r3,1
 d008840:	003f8606 	br	d00865c <_malloc_r+0x498>
 d008844:	d1200615 	stw	r4,-32744(gp)
 d008848:	003f7306 	br	d008618 <_malloc_r+0x454>
 d00884c:	00801504 	movi	r2,84
 d008850:	11001936 	bltu	r2,r4,d0088b8 <_malloc_r+0x6f4>
 d008854:	2804d33a 	srli	r2,r5,12
 d008858:	11001b84 	addi	r4,r2,110
 d00885c:	200690fa 	slli	r3,r4,3
 d008860:	003f8e06 	br	d00869c <_malloc_r+0x4d8>
 d008864:	480b883a 	mov	r5,r9
 d008868:	6807883a 	mov	r3,r13
 d00886c:	288000cc 	andi	r2,r5,3
 d008870:	18fffe04 	addi	r3,r3,-8
 d008874:	297fffc4 	addi	r5,r5,-1
 d008878:	10001526 	beq	r2,zero,d0088d0 <_malloc_r+0x70c>
 d00887c:	18800217 	ldw	r2,8(r3)
 d008880:	10fffa26 	beq	r2,r3,d00886c <_malloc_r+0x6a8>
 d008884:	2109883a 	add	r4,r4,r4
 d008888:	393f1e36 	bltu	r7,r4,d008504 <_malloc_r+0x340>
 d00888c:	203f1d26 	beq	r4,zero,d008504 <_malloc_r+0x340>
 d008890:	21c4703a 	and	r2,r4,r7
 d008894:	10000226 	beq	r2,zero,d0088a0 <_malloc_r+0x6dc>
 d008898:	6013883a 	mov	r9,r12
 d00889c:	003ee106 	br	d008424 <_malloc_r+0x260>
 d0088a0:	2109883a 	add	r4,r4,r4
 d0088a4:	3904703a 	and	r2,r7,r4
 d0088a8:	63000104 	addi	r12,r12,4
 d0088ac:	103ffc26 	beq	r2,zero,d0088a0 <_malloc_r+0x6dc>
 d0088b0:	6013883a 	mov	r9,r12
 d0088b4:	003edb06 	br	d008424 <_malloc_r+0x260>
 d0088b8:	00805504 	movi	r2,340
 d0088bc:	11000836 	bltu	r2,r4,d0088e0 <_malloc_r+0x71c>
 d0088c0:	2804d3fa 	srli	r2,r5,15
 d0088c4:	11001dc4 	addi	r4,r2,119
 d0088c8:	200690fa 	slli	r3,r4,3
 d0088cc:	003f7306 	br	d00869c <_malloc_r+0x4d8>
 d0088d0:	0104303a 	nor	r2,zero,r4
 d0088d4:	388e703a 	and	r7,r7,r2
 d0088d8:	e1c00115 	stw	r7,4(fp)
 d0088dc:	003fe906 	br	d008884 <_malloc_r+0x6c0>
 d0088e0:	00815504 	movi	r2,1364
 d0088e4:	1100032e 	bgeu	r2,r4,d0088f4 <_malloc_r+0x730>
 d0088e8:	01001f84 	movi	r4,126
 d0088ec:	00c0fc04 	movi	r3,1008
 d0088f0:	003f6a06 	br	d00869c <_malloc_r+0x4d8>
 d0088f4:	2804d4ba 	srli	r2,r5,18
 d0088f8:	11001f04 	addi	r4,r2,124
 d0088fc:	200690fa 	slli	r3,r4,3
 d008900:	003f6606 	br	d00869c <_malloc_r+0x4d8>

0d008904 <memchr>:
 d008904:	008000c4 	movi	r2,3
 d008908:	29403fcc 	andi	r5,r5,255
 d00890c:	2007883a 	mov	r3,r4
 d008910:	1180022e 	bgeu	r2,r6,d00891c <memchr+0x18>
 d008914:	2084703a 	and	r2,r4,r2
 d008918:	10000b26 	beq	r2,zero,d008948 <memchr+0x44>
 d00891c:	313fffc4 	addi	r4,r6,-1
 d008920:	3000051e 	bne	r6,zero,d008938 <memchr+0x34>
 d008924:	00002c06 	br	d0089d8 <memchr+0xd4>
 d008928:	213fffc4 	addi	r4,r4,-1
 d00892c:	00bfffc4 	movi	r2,-1
 d008930:	18c00044 	addi	r3,r3,1
 d008934:	20802826 	beq	r4,r2,d0089d8 <memchr+0xd4>
 d008938:	18800003 	ldbu	r2,0(r3)
 d00893c:	28bffa1e 	bne	r5,r2,d008928 <memchr+0x24>
 d008940:	1805883a 	mov	r2,r3
 d008944:	f800283a 	ret
 d008948:	0011883a 	mov	r8,zero
 d00894c:	0007883a 	mov	r3,zero
 d008950:	01c00104 	movi	r7,4
 d008954:	4004923a 	slli	r2,r8,8
 d008958:	18c00044 	addi	r3,r3,1
 d00895c:	1151883a 	add	r8,r2,r5
 d008960:	19fffc1e 	bne	r3,r7,d008954 <memchr+0x50>
 d008964:	02bfbff4 	movhi	r10,65279
 d008968:	52bfbfc4 	addi	r10,r10,-257
 d00896c:	02602074 	movhi	r9,32897
 d008970:	4a602004 	addi	r9,r9,-32640
 d008974:	02c000c4 	movi	r11,3
 d008978:	20800017 	ldw	r2,0(r4)
 d00897c:	31bfff04 	addi	r6,r6,-4
 d008980:	200f883a 	mov	r7,r4
 d008984:	1204f03a 	xor	r2,r2,r8
 d008988:	1287883a 	add	r3,r2,r10
 d00898c:	1a46703a 	and	r3,r3,r9
 d008990:	0084303a 	nor	r2,zero,r2
 d008994:	10c4703a 	and	r2,r2,r3
 d008998:	10000b26 	beq	r2,zero,d0089c8 <memchr+0xc4>
 d00899c:	20800003 	ldbu	r2,0(r4)
 d0089a0:	28800f26 	beq	r5,r2,d0089e0 <memchr+0xdc>
 d0089a4:	20800043 	ldbu	r2,1(r4)
 d0089a8:	21c00044 	addi	r7,r4,1
 d0089ac:	28800c26 	beq	r5,r2,d0089e0 <memchr+0xdc>
 d0089b0:	20800083 	ldbu	r2,2(r4)
 d0089b4:	21c00084 	addi	r7,r4,2
 d0089b8:	28800926 	beq	r5,r2,d0089e0 <memchr+0xdc>
 d0089bc:	208000c3 	ldbu	r2,3(r4)
 d0089c0:	21c000c4 	addi	r7,r4,3
 d0089c4:	28800626 	beq	r5,r2,d0089e0 <memchr+0xdc>
 d0089c8:	21000104 	addi	r4,r4,4
 d0089cc:	59bfea36 	bltu	r11,r6,d008978 <memchr+0x74>
 d0089d0:	2007883a 	mov	r3,r4
 d0089d4:	003fd106 	br	d00891c <memchr+0x18>
 d0089d8:	0005883a 	mov	r2,zero
 d0089dc:	f800283a 	ret
 d0089e0:	3805883a 	mov	r2,r7
 d0089e4:	f800283a 	ret

0d0089e8 <_Bfree>:
 d0089e8:	28000826 	beq	r5,zero,d008a0c <_Bfree+0x24>
 d0089ec:	28800117 	ldw	r2,4(r5)
 d0089f0:	21001317 	ldw	r4,76(r4)
 d0089f4:	1085883a 	add	r2,r2,r2
 d0089f8:	1085883a 	add	r2,r2,r2
 d0089fc:	1105883a 	add	r2,r2,r4
 d008a00:	10c00017 	ldw	r3,0(r2)
 d008a04:	28c00015 	stw	r3,0(r5)
 d008a08:	11400015 	stw	r5,0(r2)
 d008a0c:	f800283a 	ret

0d008a10 <__hi0bits>:
 d008a10:	20bfffec 	andhi	r2,r4,65535
 d008a14:	10001426 	beq	r2,zero,d008a68 <__hi0bits+0x58>
 d008a18:	0007883a 	mov	r3,zero
 d008a1c:	20bfc02c 	andhi	r2,r4,65280
 d008a20:	1000021e 	bne	r2,zero,d008a2c <__hi0bits+0x1c>
 d008a24:	2008923a 	slli	r4,r4,8
 d008a28:	18c00204 	addi	r3,r3,8
 d008a2c:	20bc002c 	andhi	r2,r4,61440
 d008a30:	1000021e 	bne	r2,zero,d008a3c <__hi0bits+0x2c>
 d008a34:	2008913a 	slli	r4,r4,4
 d008a38:	18c00104 	addi	r3,r3,4
 d008a3c:	20b0002c 	andhi	r2,r4,49152
 d008a40:	1000031e 	bne	r2,zero,d008a50 <__hi0bits+0x40>
 d008a44:	2105883a 	add	r2,r4,r4
 d008a48:	18c00084 	addi	r3,r3,2
 d008a4c:	1089883a 	add	r4,r2,r2
 d008a50:	20000316 	blt	r4,zero,d008a60 <__hi0bits+0x50>
 d008a54:	2090002c 	andhi	r2,r4,16384
 d008a58:	10000626 	beq	r2,zero,d008a74 <__hi0bits+0x64>
 d008a5c:	18c00044 	addi	r3,r3,1
 d008a60:	1805883a 	mov	r2,r3
 d008a64:	f800283a 	ret
 d008a68:	2008943a 	slli	r4,r4,16
 d008a6c:	00c00404 	movi	r3,16
 d008a70:	003fea06 	br	d008a1c <__hi0bits+0xc>
 d008a74:	00c00804 	movi	r3,32
 d008a78:	1805883a 	mov	r2,r3
 d008a7c:	f800283a 	ret

0d008a80 <__lo0bits>:
 d008a80:	20c00017 	ldw	r3,0(r4)
 d008a84:	188001cc 	andi	r2,r3,7
 d008a88:	10000a26 	beq	r2,zero,d008ab4 <__lo0bits+0x34>
 d008a8c:	1880004c 	andi	r2,r3,1
 d008a90:	1005003a 	cmpeq	r2,r2,zero
 d008a94:	10002126 	beq	r2,zero,d008b1c <__lo0bits+0x9c>
 d008a98:	1880008c 	andi	r2,r3,2
 d008a9c:	1000251e 	bne	r2,zero,d008b34 <__lo0bits+0xb4>
 d008aa0:	1804d0ba 	srli	r2,r3,2
 d008aa4:	01400084 	movi	r5,2
 d008aa8:	20800015 	stw	r2,0(r4)
 d008aac:	2805883a 	mov	r2,r5
 d008ab0:	f800283a 	ret
 d008ab4:	18bfffcc 	andi	r2,r3,65535
 d008ab8:	10001526 	beq	r2,zero,d008b10 <__lo0bits+0x90>
 d008abc:	000b883a 	mov	r5,zero
 d008ac0:	18803fcc 	andi	r2,r3,255
 d008ac4:	1000021e 	bne	r2,zero,d008ad0 <__lo0bits+0x50>
 d008ac8:	1806d23a 	srli	r3,r3,8
 d008acc:	29400204 	addi	r5,r5,8
 d008ad0:	188003cc 	andi	r2,r3,15
 d008ad4:	1000021e 	bne	r2,zero,d008ae0 <__lo0bits+0x60>
 d008ad8:	1806d13a 	srli	r3,r3,4
 d008adc:	29400104 	addi	r5,r5,4
 d008ae0:	188000cc 	andi	r2,r3,3
 d008ae4:	1000021e 	bne	r2,zero,d008af0 <__lo0bits+0x70>
 d008ae8:	1806d0ba 	srli	r3,r3,2
 d008aec:	29400084 	addi	r5,r5,2
 d008af0:	1880004c 	andi	r2,r3,1
 d008af4:	1000031e 	bne	r2,zero,d008b04 <__lo0bits+0x84>
 d008af8:	1806d07a 	srli	r3,r3,1
 d008afc:	18000a26 	beq	r3,zero,d008b28 <__lo0bits+0xa8>
 d008b00:	29400044 	addi	r5,r5,1
 d008b04:	2805883a 	mov	r2,r5
 d008b08:	20c00015 	stw	r3,0(r4)
 d008b0c:	f800283a 	ret
 d008b10:	1806d43a 	srli	r3,r3,16
 d008b14:	01400404 	movi	r5,16
 d008b18:	003fe906 	br	d008ac0 <__lo0bits+0x40>
 d008b1c:	000b883a 	mov	r5,zero
 d008b20:	2805883a 	mov	r2,r5
 d008b24:	f800283a 	ret
 d008b28:	01400804 	movi	r5,32
 d008b2c:	2805883a 	mov	r2,r5
 d008b30:	f800283a 	ret
 d008b34:	1804d07a 	srli	r2,r3,1
 d008b38:	01400044 	movi	r5,1
 d008b3c:	20800015 	stw	r2,0(r4)
 d008b40:	003fda06 	br	d008aac <__lo0bits+0x2c>

0d008b44 <__mcmp>:
 d008b44:	20800417 	ldw	r2,16(r4)
 d008b48:	28c00417 	ldw	r3,16(r5)
 d008b4c:	10cfc83a 	sub	r7,r2,r3
 d008b50:	38000c1e 	bne	r7,zero,d008b84 <__mcmp+0x40>
 d008b54:	18c5883a 	add	r2,r3,r3
 d008b58:	1085883a 	add	r2,r2,r2
 d008b5c:	10c00504 	addi	r3,r2,20
 d008b60:	21000504 	addi	r4,r4,20
 d008b64:	28cb883a 	add	r5,r5,r3
 d008b68:	2085883a 	add	r2,r4,r2
 d008b6c:	10bfff04 	addi	r2,r2,-4
 d008b70:	297fff04 	addi	r5,r5,-4
 d008b74:	11800017 	ldw	r6,0(r2)
 d008b78:	28c00017 	ldw	r3,0(r5)
 d008b7c:	30c0031e 	bne	r6,r3,d008b8c <__mcmp+0x48>
 d008b80:	20bffa36 	bltu	r4,r2,d008b6c <__mcmp+0x28>
 d008b84:	3805883a 	mov	r2,r7
 d008b88:	f800283a 	ret
 d008b8c:	30c00336 	bltu	r6,r3,d008b9c <__mcmp+0x58>
 d008b90:	01c00044 	movi	r7,1
 d008b94:	3805883a 	mov	r2,r7
 d008b98:	f800283a 	ret
 d008b9c:	01ffffc4 	movi	r7,-1
 d008ba0:	003ff806 	br	d008b84 <__mcmp+0x40>

0d008ba4 <__ulp>:
 d008ba4:	295ffc2c 	andhi	r5,r5,32752
 d008ba8:	013f3034 	movhi	r4,64704
 d008bac:	290b883a 	add	r5,r5,r4
 d008bb0:	0145c83a 	sub	r2,zero,r5
 d008bb4:	1007d53a 	srai	r3,r2,20
 d008bb8:	000d883a 	mov	r6,zero
 d008bbc:	0140040e 	bge	zero,r5,d008bd0 <__ulp+0x2c>
 d008bc0:	280f883a 	mov	r7,r5
 d008bc4:	3807883a 	mov	r3,r7
 d008bc8:	3005883a 	mov	r2,r6
 d008bcc:	f800283a 	ret
 d008bd0:	008004c4 	movi	r2,19
 d008bd4:	193ffb04 	addi	r4,r3,-20
 d008bd8:	10c00c0e 	bge	r2,r3,d008c0c <__ulp+0x68>
 d008bdc:	008007c4 	movi	r2,31
 d008be0:	1107c83a 	sub	r3,r2,r4
 d008be4:	00800784 	movi	r2,30
 d008be8:	01400044 	movi	r5,1
 d008bec:	11000216 	blt	r2,r4,d008bf8 <__ulp+0x54>
 d008bf0:	00800044 	movi	r2,1
 d008bf4:	10ca983a 	sll	r5,r2,r3
 d008bf8:	000f883a 	mov	r7,zero
 d008bfc:	280d883a 	mov	r6,r5
 d008c00:	3807883a 	mov	r3,r7
 d008c04:	3005883a 	mov	r2,r6
 d008c08:	f800283a 	ret
 d008c0c:	00800234 	movhi	r2,8
 d008c10:	10cfd83a 	sra	r7,r2,r3
 d008c14:	000d883a 	mov	r6,zero
 d008c18:	3005883a 	mov	r2,r6
 d008c1c:	3807883a 	mov	r3,r7
 d008c20:	f800283a 	ret

0d008c24 <__b2d>:
 d008c24:	20800417 	ldw	r2,16(r4)
 d008c28:	defff904 	addi	sp,sp,-28
 d008c2c:	dd000415 	stw	r20,16(sp)
 d008c30:	1085883a 	add	r2,r2,r2
 d008c34:	25000504 	addi	r20,r4,20
 d008c38:	1085883a 	add	r2,r2,r2
 d008c3c:	dc000015 	stw	r16,0(sp)
 d008c40:	a0a1883a 	add	r16,r20,r2
 d008c44:	dd400515 	stw	r21,20(sp)
 d008c48:	857fff17 	ldw	r21,-4(r16)
 d008c4c:	dc400115 	stw	r17,4(sp)
 d008c50:	dfc00615 	stw	ra,24(sp)
 d008c54:	a809883a 	mov	r4,r21
 d008c58:	2823883a 	mov	r17,r5
 d008c5c:	dcc00315 	stw	r19,12(sp)
 d008c60:	dc800215 	stw	r18,8(sp)
 d008c64:	d008a100 	call	d008a10 <__hi0bits>
 d008c68:	100b883a 	mov	r5,r2
 d008c6c:	00800804 	movi	r2,32
 d008c70:	1145c83a 	sub	r2,r2,r5
 d008c74:	88800015 	stw	r2,0(r17)
 d008c78:	00800284 	movi	r2,10
 d008c7c:	80ffff04 	addi	r3,r16,-4
 d008c80:	11401416 	blt	r2,r5,d008cd4 <__b2d+0xb0>
 d008c84:	008002c4 	movi	r2,11
 d008c88:	1149c83a 	sub	r4,r2,r5
 d008c8c:	a0c02736 	bltu	r20,r3,d008d2c <__b2d+0x108>
 d008c90:	000d883a 	mov	r6,zero
 d008c94:	28800544 	addi	r2,r5,21
 d008c98:	a906d83a 	srl	r3,r21,r4
 d008c9c:	a884983a 	sll	r2,r21,r2
 d008ca0:	1ccffc34 	orhi	r19,r3,16368
 d008ca4:	11a4b03a 	or	r18,r2,r6
 d008ca8:	9005883a 	mov	r2,r18
 d008cac:	9807883a 	mov	r3,r19
 d008cb0:	dfc00617 	ldw	ra,24(sp)
 d008cb4:	dd400517 	ldw	r21,20(sp)
 d008cb8:	dd000417 	ldw	r20,16(sp)
 d008cbc:	dcc00317 	ldw	r19,12(sp)
 d008cc0:	dc800217 	ldw	r18,8(sp)
 d008cc4:	dc400117 	ldw	r17,4(sp)
 d008cc8:	dc000017 	ldw	r16,0(sp)
 d008ccc:	dec00704 	addi	sp,sp,28
 d008cd0:	f800283a 	ret
 d008cd4:	a0c00e36 	bltu	r20,r3,d008d10 <__b2d+0xec>
 d008cd8:	293ffd44 	addi	r4,r5,-11
 d008cdc:	000d883a 	mov	r6,zero
 d008ce0:	20000f26 	beq	r4,zero,d008d20 <__b2d+0xfc>
 d008ce4:	00800804 	movi	r2,32
 d008ce8:	110bc83a 	sub	r5,r2,r4
 d008cec:	a0c01236 	bltu	r20,r3,d008d38 <__b2d+0x114>
 d008cf0:	000f883a 	mov	r7,zero
 d008cf4:	a904983a 	sll	r2,r21,r4
 d008cf8:	3146d83a 	srl	r3,r6,r5
 d008cfc:	3108983a 	sll	r4,r6,r4
 d008d00:	108ffc34 	orhi	r2,r2,16368
 d008d04:	18a6b03a 	or	r19,r3,r2
 d008d08:	3924b03a 	or	r18,r7,r4
 d008d0c:	003fe606 	br	d008ca8 <__b2d+0x84>
 d008d10:	293ffd44 	addi	r4,r5,-11
 d008d14:	81bffe17 	ldw	r6,-8(r16)
 d008d18:	80fffe04 	addi	r3,r16,-8
 d008d1c:	203ff11e 	bne	r4,zero,d008ce4 <__b2d+0xc0>
 d008d20:	accffc34 	orhi	r19,r21,16368
 d008d24:	3025883a 	mov	r18,r6
 d008d28:	003fdf06 	br	d008ca8 <__b2d+0x84>
 d008d2c:	18bfff17 	ldw	r2,-4(r3)
 d008d30:	110cd83a 	srl	r6,r2,r4
 d008d34:	003fd706 	br	d008c94 <__b2d+0x70>
 d008d38:	18bfff17 	ldw	r2,-4(r3)
 d008d3c:	114ed83a 	srl	r7,r2,r5
 d008d40:	003fec06 	br	d008cf4 <__b2d+0xd0>

0d008d44 <__ratio>:
 d008d44:	defff904 	addi	sp,sp,-28
 d008d48:	dc400215 	stw	r17,8(sp)
 d008d4c:	2823883a 	mov	r17,r5
 d008d50:	d80b883a 	mov	r5,sp
 d008d54:	dfc00615 	stw	ra,24(sp)
 d008d58:	dd000515 	stw	r20,20(sp)
 d008d5c:	dcc00415 	stw	r19,16(sp)
 d008d60:	dc800315 	stw	r18,12(sp)
 d008d64:	2025883a 	mov	r18,r4
 d008d68:	d008c240 	call	d008c24 <__b2d>
 d008d6c:	8809883a 	mov	r4,r17
 d008d70:	d9400104 	addi	r5,sp,4
 d008d74:	1027883a 	mov	r19,r2
 d008d78:	1829883a 	mov	r20,r3
 d008d7c:	d008c240 	call	d008c24 <__b2d>
 d008d80:	89000417 	ldw	r4,16(r17)
 d008d84:	91c00417 	ldw	r7,16(r18)
 d008d88:	d9800117 	ldw	r6,4(sp)
 d008d8c:	180b883a 	mov	r5,r3
 d008d90:	390fc83a 	sub	r7,r7,r4
 d008d94:	1009883a 	mov	r4,r2
 d008d98:	d8800017 	ldw	r2,0(sp)
 d008d9c:	380e917a 	slli	r7,r7,5
 d008da0:	2011883a 	mov	r8,r4
 d008da4:	1185c83a 	sub	r2,r2,r6
 d008da8:	11c5883a 	add	r2,r2,r7
 d008dac:	1006953a 	slli	r3,r2,20
 d008db0:	2813883a 	mov	r9,r5
 d008db4:	00800d0e 	bge	zero,r2,d008dec <__ratio+0xa8>
 d008db8:	1d29883a 	add	r20,r3,r20
 d008dbc:	a00b883a 	mov	r5,r20
 d008dc0:	480f883a 	mov	r7,r9
 d008dc4:	9809883a 	mov	r4,r19
 d008dc8:	400d883a 	mov	r6,r8
 d008dcc:	d00bf6c0 	call	d00bf6c <__divdf3>
 d008dd0:	dfc00617 	ldw	ra,24(sp)
 d008dd4:	dd000517 	ldw	r20,20(sp)
 d008dd8:	dcc00417 	ldw	r19,16(sp)
 d008ddc:	dc800317 	ldw	r18,12(sp)
 d008de0:	dc400217 	ldw	r17,8(sp)
 d008de4:	dec00704 	addi	sp,sp,28
 d008de8:	f800283a 	ret
 d008dec:	28d3c83a 	sub	r9,r5,r3
 d008df0:	003ff206 	br	d008dbc <__ratio+0x78>

0d008df4 <_mprec_log10>:
 d008df4:	defffe04 	addi	sp,sp,-8
 d008df8:	008005c4 	movi	r2,23
 d008dfc:	dc000015 	stw	r16,0(sp)
 d008e00:	dfc00115 	stw	ra,4(sp)
 d008e04:	2021883a 	mov	r16,r4
 d008e08:	11000c16 	blt	r2,r4,d008e3c <_mprec_log10+0x48>
 d008e0c:	200490fa 	slli	r2,r4,3
 d008e10:	00c34174 	movhi	r3,3333
 d008e14:	18f8e404 	addi	r3,r3,-7280
 d008e18:	10c5883a 	add	r2,r2,r3
 d008e1c:	12400117 	ldw	r9,4(r2)
 d008e20:	12000017 	ldw	r8,0(r2)
 d008e24:	4807883a 	mov	r3,r9
 d008e28:	4005883a 	mov	r2,r8
 d008e2c:	dfc00117 	ldw	ra,4(sp)
 d008e30:	dc000017 	ldw	r16,0(sp)
 d008e34:	dec00204 	addi	sp,sp,8
 d008e38:	f800283a 	ret
 d008e3c:	0011883a 	mov	r8,zero
 d008e40:	024ffc34 	movhi	r9,16368
 d008e44:	0005883a 	mov	r2,zero
 d008e48:	00d00934 	movhi	r3,16420
 d008e4c:	480b883a 	mov	r5,r9
 d008e50:	4009883a 	mov	r4,r8
 d008e54:	180f883a 	mov	r7,r3
 d008e58:	100d883a 	mov	r6,r2
 d008e5c:	d00bba80 	call	d00bba8 <__muldf3>
 d008e60:	843fffc4 	addi	r16,r16,-1
 d008e64:	1011883a 	mov	r8,r2
 d008e68:	1813883a 	mov	r9,r3
 d008e6c:	803ff51e 	bne	r16,zero,d008e44 <_mprec_log10+0x50>
 d008e70:	4005883a 	mov	r2,r8
 d008e74:	4807883a 	mov	r3,r9
 d008e78:	dfc00117 	ldw	ra,4(sp)
 d008e7c:	dc000017 	ldw	r16,0(sp)
 d008e80:	dec00204 	addi	sp,sp,8
 d008e84:	f800283a 	ret

0d008e88 <__copybits>:
 d008e88:	297fffc4 	addi	r5,r5,-1
 d008e8c:	30800417 	ldw	r2,16(r6)
 d008e90:	280bd17a 	srai	r5,r5,5
 d008e94:	31800504 	addi	r6,r6,20
 d008e98:	1085883a 	add	r2,r2,r2
 d008e9c:	294b883a 	add	r5,r5,r5
 d008ea0:	294b883a 	add	r5,r5,r5
 d008ea4:	1085883a 	add	r2,r2,r2
 d008ea8:	290b883a 	add	r5,r5,r4
 d008eac:	3087883a 	add	r3,r6,r2
 d008eb0:	29400104 	addi	r5,r5,4
 d008eb4:	30c0052e 	bgeu	r6,r3,d008ecc <__copybits+0x44>
 d008eb8:	30800017 	ldw	r2,0(r6)
 d008ebc:	31800104 	addi	r6,r6,4
 d008ec0:	20800015 	stw	r2,0(r4)
 d008ec4:	21000104 	addi	r4,r4,4
 d008ec8:	30fffb36 	bltu	r6,r3,d008eb8 <__copybits+0x30>
 d008ecc:	2140032e 	bgeu	r4,r5,d008edc <__copybits+0x54>
 d008ed0:	20000015 	stw	zero,0(r4)
 d008ed4:	21000104 	addi	r4,r4,4
 d008ed8:	217ffd36 	bltu	r4,r5,d008ed0 <__copybits+0x48>
 d008edc:	f800283a 	ret

0d008ee0 <__any_on>:
 d008ee0:	20800417 	ldw	r2,16(r4)
 d008ee4:	2807d17a 	srai	r3,r5,5
 d008ee8:	21000504 	addi	r4,r4,20
 d008eec:	10c00d0e 	bge	r2,r3,d008f24 <__any_on+0x44>
 d008ef0:	1085883a 	add	r2,r2,r2
 d008ef4:	1085883a 	add	r2,r2,r2
 d008ef8:	208d883a 	add	r6,r4,r2
 d008efc:	2180182e 	bgeu	r4,r6,d008f60 <__any_on+0x80>
 d008f00:	30bfff17 	ldw	r2,-4(r6)
 d008f04:	30ffff04 	addi	r3,r6,-4
 d008f08:	1000041e 	bne	r2,zero,d008f1c <__any_on+0x3c>
 d008f0c:	20c0142e 	bgeu	r4,r3,d008f60 <__any_on+0x80>
 d008f10:	18ffff04 	addi	r3,r3,-4
 d008f14:	18800017 	ldw	r2,0(r3)
 d008f18:	103ffc26 	beq	r2,zero,d008f0c <__any_on+0x2c>
 d008f1c:	00800044 	movi	r2,1
 d008f20:	f800283a 	ret
 d008f24:	18800a0e 	bge	r3,r2,d008f50 <__any_on+0x70>
 d008f28:	294007cc 	andi	r5,r5,31
 d008f2c:	28000826 	beq	r5,zero,d008f50 <__any_on+0x70>
 d008f30:	18c5883a 	add	r2,r3,r3
 d008f34:	1085883a 	add	r2,r2,r2
 d008f38:	208d883a 	add	r6,r4,r2
 d008f3c:	30c00017 	ldw	r3,0(r6)
 d008f40:	1944d83a 	srl	r2,r3,r5
 d008f44:	1144983a 	sll	r2,r2,r5
 d008f48:	18bff41e 	bne	r3,r2,d008f1c <__any_on+0x3c>
 d008f4c:	003feb06 	br	d008efc <__any_on+0x1c>
 d008f50:	18c5883a 	add	r2,r3,r3
 d008f54:	1085883a 	add	r2,r2,r2
 d008f58:	208d883a 	add	r6,r4,r2
 d008f5c:	003fe706 	br	d008efc <__any_on+0x1c>
 d008f60:	0005883a 	mov	r2,zero
 d008f64:	f800283a 	ret

0d008f68 <_Balloc>:
 d008f68:	20c01317 	ldw	r3,76(r4)
 d008f6c:	defffb04 	addi	sp,sp,-20
 d008f70:	dcc00315 	stw	r19,12(sp)
 d008f74:	dc800215 	stw	r18,8(sp)
 d008f78:	dfc00415 	stw	ra,16(sp)
 d008f7c:	2825883a 	mov	r18,r5
 d008f80:	dc400115 	stw	r17,4(sp)
 d008f84:	dc000015 	stw	r16,0(sp)
 d008f88:	2027883a 	mov	r19,r4
 d008f8c:	01800404 	movi	r6,16
 d008f90:	01400104 	movi	r5,4
 d008f94:	18001726 	beq	r3,zero,d008ff4 <_Balloc+0x8c>
 d008f98:	01400044 	movi	r5,1
 d008f9c:	9485883a 	add	r2,r18,r18
 d008fa0:	2ca2983a 	sll	r17,r5,r18
 d008fa4:	1085883a 	add	r2,r2,r2
 d008fa8:	10c7883a 	add	r3,r2,r3
 d008fac:	1c000017 	ldw	r16,0(r3)
 d008fb0:	8c4d883a 	add	r6,r17,r17
 d008fb4:	318d883a 	add	r6,r6,r6
 d008fb8:	9809883a 	mov	r4,r19
 d008fbc:	31800504 	addi	r6,r6,20
 d008fc0:	80001226 	beq	r16,zero,d00900c <_Balloc+0xa4>
 d008fc4:	80800017 	ldw	r2,0(r16)
 d008fc8:	18800015 	stw	r2,0(r3)
 d008fcc:	80000415 	stw	zero,16(r16)
 d008fd0:	80000315 	stw	zero,12(r16)
 d008fd4:	8005883a 	mov	r2,r16
 d008fd8:	dfc00417 	ldw	ra,16(sp)
 d008fdc:	dcc00317 	ldw	r19,12(sp)
 d008fe0:	dc800217 	ldw	r18,8(sp)
 d008fe4:	dc400117 	ldw	r17,4(sp)
 d008fe8:	dc000017 	ldw	r16,0(sp)
 d008fec:	dec00504 	addi	sp,sp,20
 d008ff0:	f800283a 	ret
 d008ff4:	d00a5a80 	call	d00a5a8 <_calloc_r>
 d008ff8:	1007883a 	mov	r3,r2
 d008ffc:	0021883a 	mov	r16,zero
 d009000:	98801315 	stw	r2,76(r19)
 d009004:	103fe41e 	bne	r2,zero,d008f98 <_Balloc+0x30>
 d009008:	003ff206 	br	d008fd4 <_Balloc+0x6c>
 d00900c:	d00a5a80 	call	d00a5a8 <_calloc_r>
 d009010:	103ff026 	beq	r2,zero,d008fd4 <_Balloc+0x6c>
 d009014:	1021883a 	mov	r16,r2
 d009018:	14800115 	stw	r18,4(r2)
 d00901c:	14400215 	stw	r17,8(r2)
 d009020:	003fea06 	br	d008fcc <_Balloc+0x64>

0d009024 <__d2b>:
 d009024:	defff504 	addi	sp,sp,-44
 d009028:	dcc00515 	stw	r19,20(sp)
 d00902c:	04c00044 	movi	r19,1
 d009030:	dc000215 	stw	r16,8(sp)
 d009034:	2821883a 	mov	r16,r5
 d009038:	980b883a 	mov	r5,r19
 d00903c:	ddc00915 	stw	r23,36(sp)
 d009040:	dd800815 	stw	r22,32(sp)
 d009044:	dd400715 	stw	r21,28(sp)
 d009048:	dd000615 	stw	r20,24(sp)
 d00904c:	dc800415 	stw	r18,16(sp)
 d009050:	dc400315 	stw	r17,12(sp)
 d009054:	dfc00a15 	stw	ra,40(sp)
 d009058:	3023883a 	mov	r17,r6
 d00905c:	382d883a 	mov	r22,r7
 d009060:	ddc00b17 	ldw	r23,44(sp)
 d009064:	d008f680 	call	d008f68 <_Balloc>
 d009068:	1025883a 	mov	r18,r2
 d00906c:	00a00034 	movhi	r2,32768
 d009070:	10bfffc4 	addi	r2,r2,-1
 d009074:	8888703a 	and	r4,r17,r2
 d009078:	202ad53a 	srli	r21,r4,20
 d00907c:	00800434 	movhi	r2,16
 d009080:	10bfffc4 	addi	r2,r2,-1
 d009084:	8886703a 	and	r3,r17,r2
 d009088:	a829003a 	cmpeq	r20,r21,zero
 d00908c:	800b883a 	mov	r5,r16
 d009090:	d8c00115 	stw	r3,4(sp)
 d009094:	94000504 	addi	r16,r18,20
 d009098:	a000021e 	bne	r20,zero,d0090a4 <__d2b+0x80>
 d00909c:	18c00434 	orhi	r3,r3,16
 d0090a0:	d8c00115 	stw	r3,4(sp)
 d0090a4:	28002726 	beq	r5,zero,d009144 <__d2b+0x120>
 d0090a8:	d809883a 	mov	r4,sp
 d0090ac:	d9400015 	stw	r5,0(sp)
 d0090b0:	d008a800 	call	d008a80 <__lo0bits>
 d0090b4:	100d883a 	mov	r6,r2
 d0090b8:	10003526 	beq	r2,zero,d009190 <__d2b+0x16c>
 d0090bc:	d8c00117 	ldw	r3,4(sp)
 d0090c0:	00800804 	movi	r2,32
 d0090c4:	1185c83a 	sub	r2,r2,r6
 d0090c8:	d9000017 	ldw	r4,0(sp)
 d0090cc:	1886983a 	sll	r3,r3,r2
 d0090d0:	1906b03a 	or	r3,r3,r4
 d0090d4:	90c00515 	stw	r3,20(r18)
 d0090d8:	d8c00117 	ldw	r3,4(sp)
 d0090dc:	1986d83a 	srl	r3,r3,r6
 d0090e0:	d8c00115 	stw	r3,4(sp)
 d0090e4:	180b003a 	cmpeq	r5,r3,zero
 d0090e8:	00800084 	movi	r2,2
 d0090ec:	114bc83a 	sub	r5,r2,r5
 d0090f0:	80c00115 	stw	r3,4(r16)
 d0090f4:	91400415 	stw	r5,16(r18)
 d0090f8:	a0001a1e 	bne	r20,zero,d009164 <__d2b+0x140>
 d0090fc:	3545883a 	add	r2,r6,r21
 d009100:	10bef344 	addi	r2,r2,-1075
 d009104:	00c00d44 	movi	r3,53
 d009108:	b0800015 	stw	r2,0(r22)
 d00910c:	1987c83a 	sub	r3,r3,r6
 d009110:	b8c00015 	stw	r3,0(r23)
 d009114:	9005883a 	mov	r2,r18
 d009118:	dfc00a17 	ldw	ra,40(sp)
 d00911c:	ddc00917 	ldw	r23,36(sp)
 d009120:	dd800817 	ldw	r22,32(sp)
 d009124:	dd400717 	ldw	r21,28(sp)
 d009128:	dd000617 	ldw	r20,24(sp)
 d00912c:	dcc00517 	ldw	r19,20(sp)
 d009130:	dc800417 	ldw	r18,16(sp)
 d009134:	dc400317 	ldw	r17,12(sp)
 d009138:	dc000217 	ldw	r16,8(sp)
 d00913c:	dec00b04 	addi	sp,sp,44
 d009140:	f800283a 	ret
 d009144:	d9000104 	addi	r4,sp,4
 d009148:	d008a800 	call	d008a80 <__lo0bits>
 d00914c:	11800804 	addi	r6,r2,32
 d009150:	d8800117 	ldw	r2,4(sp)
 d009154:	94c00415 	stw	r19,16(r18)
 d009158:	980b883a 	mov	r5,r19
 d00915c:	90800515 	stw	r2,20(r18)
 d009160:	a03fe626 	beq	r20,zero,d0090fc <__d2b+0xd8>
 d009164:	2945883a 	add	r2,r5,r5
 d009168:	1085883a 	add	r2,r2,r2
 d00916c:	1405883a 	add	r2,r2,r16
 d009170:	113fff17 	ldw	r4,-4(r2)
 d009174:	30fef384 	addi	r3,r6,-1074
 d009178:	2820917a 	slli	r16,r5,5
 d00917c:	b0c00015 	stw	r3,0(r22)
 d009180:	d008a100 	call	d008a10 <__hi0bits>
 d009184:	80a1c83a 	sub	r16,r16,r2
 d009188:	bc000015 	stw	r16,0(r23)
 d00918c:	003fe106 	br	d009114 <__d2b+0xf0>
 d009190:	d8800017 	ldw	r2,0(sp)
 d009194:	90800515 	stw	r2,20(r18)
 d009198:	d8c00117 	ldw	r3,4(sp)
 d00919c:	003fd106 	br	d0090e4 <__d2b+0xc0>

0d0091a0 <__mdiff>:
 d0091a0:	defffb04 	addi	sp,sp,-20
 d0091a4:	dc000015 	stw	r16,0(sp)
 d0091a8:	2821883a 	mov	r16,r5
 d0091ac:	dc800215 	stw	r18,8(sp)
 d0091b0:	300b883a 	mov	r5,r6
 d0091b4:	2025883a 	mov	r18,r4
 d0091b8:	8009883a 	mov	r4,r16
 d0091bc:	dc400115 	stw	r17,4(sp)
 d0091c0:	dfc00415 	stw	ra,16(sp)
 d0091c4:	dcc00315 	stw	r19,12(sp)
 d0091c8:	3023883a 	mov	r17,r6
 d0091cc:	d008b440 	call	d008b44 <__mcmp>
 d0091d0:	10004226 	beq	r2,zero,d0092dc <__mdiff+0x13c>
 d0091d4:	10005016 	blt	r2,zero,d009318 <__mdiff+0x178>
 d0091d8:	0027883a 	mov	r19,zero
 d0091dc:	81400117 	ldw	r5,4(r16)
 d0091e0:	9009883a 	mov	r4,r18
 d0091e4:	d008f680 	call	d008f68 <_Balloc>
 d0091e8:	1019883a 	mov	r12,r2
 d0091ec:	82800417 	ldw	r10,16(r16)
 d0091f0:	88800417 	ldw	r2,16(r17)
 d0091f4:	81800504 	addi	r6,r16,20
 d0091f8:	5287883a 	add	r3,r10,r10
 d0091fc:	1085883a 	add	r2,r2,r2
 d009200:	18c7883a 	add	r3,r3,r3
 d009204:	1085883a 	add	r2,r2,r2
 d009208:	8a000504 	addi	r8,r17,20
 d00920c:	64c00315 	stw	r19,12(r12)
 d009210:	30db883a 	add	r13,r6,r3
 d009214:	4097883a 	add	r11,r8,r2
 d009218:	61c00504 	addi	r7,r12,20
 d00921c:	0013883a 	mov	r9,zero
 d009220:	31000017 	ldw	r4,0(r6)
 d009224:	41400017 	ldw	r5,0(r8)
 d009228:	42000104 	addi	r8,r8,4
 d00922c:	20bfffcc 	andi	r2,r4,65535
 d009230:	28ffffcc 	andi	r3,r5,65535
 d009234:	10c5c83a 	sub	r2,r2,r3
 d009238:	1245883a 	add	r2,r2,r9
 d00923c:	2008d43a 	srli	r4,r4,16
 d009240:	280ad43a 	srli	r5,r5,16
 d009244:	1007d43a 	srai	r3,r2,16
 d009248:	3880000d 	sth	r2,0(r7)
 d00924c:	2149c83a 	sub	r4,r4,r5
 d009250:	20c9883a 	add	r4,r4,r3
 d009254:	3900008d 	sth	r4,2(r7)
 d009258:	31800104 	addi	r6,r6,4
 d00925c:	39c00104 	addi	r7,r7,4
 d009260:	2013d43a 	srai	r9,r4,16
 d009264:	42ffee36 	bltu	r8,r11,d009220 <__mdiff+0x80>
 d009268:	33400c2e 	bgeu	r6,r13,d00929c <__mdiff+0xfc>
 d00926c:	30800017 	ldw	r2,0(r6)
 d009270:	31800104 	addi	r6,r6,4
 d009274:	10ffffcc 	andi	r3,r2,65535
 d009278:	1a47883a 	add	r3,r3,r9
 d00927c:	1004d43a 	srli	r2,r2,16
 d009280:	1809d43a 	srai	r4,r3,16
 d009284:	38c0000d 	sth	r3,0(r7)
 d009288:	1105883a 	add	r2,r2,r4
 d00928c:	3880008d 	sth	r2,2(r7)
 d009290:	1013d43a 	srai	r9,r2,16
 d009294:	39c00104 	addi	r7,r7,4
 d009298:	337ff436 	bltu	r6,r13,d00926c <__mdiff+0xcc>
 d00929c:	38bfff17 	ldw	r2,-4(r7)
 d0092a0:	38ffff04 	addi	r3,r7,-4
 d0092a4:	1000041e 	bne	r2,zero,d0092b8 <__mdiff+0x118>
 d0092a8:	18ffff04 	addi	r3,r3,-4
 d0092ac:	18800017 	ldw	r2,0(r3)
 d0092b0:	52bfffc4 	addi	r10,r10,-1
 d0092b4:	103ffc26 	beq	r2,zero,d0092a8 <__mdiff+0x108>
 d0092b8:	6005883a 	mov	r2,r12
 d0092bc:	62800415 	stw	r10,16(r12)
 d0092c0:	dfc00417 	ldw	ra,16(sp)
 d0092c4:	dcc00317 	ldw	r19,12(sp)
 d0092c8:	dc800217 	ldw	r18,8(sp)
 d0092cc:	dc400117 	ldw	r17,4(sp)
 d0092d0:	dc000017 	ldw	r16,0(sp)
 d0092d4:	dec00504 	addi	sp,sp,20
 d0092d8:	f800283a 	ret
 d0092dc:	9009883a 	mov	r4,r18
 d0092e0:	000b883a 	mov	r5,zero
 d0092e4:	d008f680 	call	d008f68 <_Balloc>
 d0092e8:	1019883a 	mov	r12,r2
 d0092ec:	00800044 	movi	r2,1
 d0092f0:	60800415 	stw	r2,16(r12)
 d0092f4:	6005883a 	mov	r2,r12
 d0092f8:	60000515 	stw	zero,20(r12)
 d0092fc:	dfc00417 	ldw	ra,16(sp)
 d009300:	dcc00317 	ldw	r19,12(sp)
 d009304:	dc800217 	ldw	r18,8(sp)
 d009308:	dc400117 	ldw	r17,4(sp)
 d00930c:	dc000017 	ldw	r16,0(sp)
 d009310:	dec00504 	addi	sp,sp,20
 d009314:	f800283a 	ret
 d009318:	880d883a 	mov	r6,r17
 d00931c:	04c00044 	movi	r19,1
 d009320:	8023883a 	mov	r17,r16
 d009324:	3021883a 	mov	r16,r6
 d009328:	003fac06 	br	d0091dc <__mdiff+0x3c>

0d00932c <__lshift>:
 d00932c:	defff904 	addi	sp,sp,-28
 d009330:	28800417 	ldw	r2,16(r5)
 d009334:	dc000015 	stw	r16,0(sp)
 d009338:	3021d17a 	srai	r16,r6,5
 d00933c:	28c00217 	ldw	r3,8(r5)
 d009340:	10800044 	addi	r2,r2,1
 d009344:	dc400115 	stw	r17,4(sp)
 d009348:	80a3883a 	add	r17,r16,r2
 d00934c:	dd400515 	stw	r21,20(sp)
 d009350:	dd000415 	stw	r20,16(sp)
 d009354:	dc800215 	stw	r18,8(sp)
 d009358:	dfc00615 	stw	ra,24(sp)
 d00935c:	2825883a 	mov	r18,r5
 d009360:	dcc00315 	stw	r19,12(sp)
 d009364:	3029883a 	mov	r20,r6
 d009368:	202b883a 	mov	r21,r4
 d00936c:	29400117 	ldw	r5,4(r5)
 d009370:	1c40030e 	bge	r3,r17,d009380 <__lshift+0x54>
 d009374:	18c7883a 	add	r3,r3,r3
 d009378:	29400044 	addi	r5,r5,1
 d00937c:	1c7ffd16 	blt	r3,r17,d009374 <__lshift+0x48>
 d009380:	a809883a 	mov	r4,r21
 d009384:	d008f680 	call	d008f68 <_Balloc>
 d009388:	1027883a 	mov	r19,r2
 d00938c:	11400504 	addi	r5,r2,20
 d009390:	0400090e 	bge	zero,r16,d0093b8 <__lshift+0x8c>
 d009394:	2805883a 	mov	r2,r5
 d009398:	0007883a 	mov	r3,zero
 d00939c:	18c00044 	addi	r3,r3,1
 d0093a0:	10000015 	stw	zero,0(r2)
 d0093a4:	10800104 	addi	r2,r2,4
 d0093a8:	80fffc1e 	bne	r16,r3,d00939c <__lshift+0x70>
 d0093ac:	8405883a 	add	r2,r16,r16
 d0093b0:	1085883a 	add	r2,r2,r2
 d0093b4:	288b883a 	add	r5,r5,r2
 d0093b8:	90800417 	ldw	r2,16(r18)
 d0093bc:	91000504 	addi	r4,r18,20
 d0093c0:	a18007cc 	andi	r6,r20,31
 d0093c4:	1085883a 	add	r2,r2,r2
 d0093c8:	1085883a 	add	r2,r2,r2
 d0093cc:	208f883a 	add	r7,r4,r2
 d0093d0:	30001e26 	beq	r6,zero,d00944c <__lshift+0x120>
 d0093d4:	00800804 	movi	r2,32
 d0093d8:	1191c83a 	sub	r8,r2,r6
 d0093dc:	0007883a 	mov	r3,zero
 d0093e0:	20800017 	ldw	r2,0(r4)
 d0093e4:	1184983a 	sll	r2,r2,r6
 d0093e8:	1884b03a 	or	r2,r3,r2
 d0093ec:	28800015 	stw	r2,0(r5)
 d0093f0:	20c00017 	ldw	r3,0(r4)
 d0093f4:	21000104 	addi	r4,r4,4
 d0093f8:	29400104 	addi	r5,r5,4
 d0093fc:	1a06d83a 	srl	r3,r3,r8
 d009400:	21fff736 	bltu	r4,r7,d0093e0 <__lshift+0xb4>
 d009404:	28c00015 	stw	r3,0(r5)
 d009408:	18000126 	beq	r3,zero,d009410 <__lshift+0xe4>
 d00940c:	8c400044 	addi	r17,r17,1
 d009410:	88bfffc4 	addi	r2,r17,-1
 d009414:	98800415 	stw	r2,16(r19)
 d009418:	a809883a 	mov	r4,r21
 d00941c:	900b883a 	mov	r5,r18
 d009420:	d0089e80 	call	d0089e8 <_Bfree>
 d009424:	9805883a 	mov	r2,r19
 d009428:	dfc00617 	ldw	ra,24(sp)
 d00942c:	dd400517 	ldw	r21,20(sp)
 d009430:	dd000417 	ldw	r20,16(sp)
 d009434:	dcc00317 	ldw	r19,12(sp)
 d009438:	dc800217 	ldw	r18,8(sp)
 d00943c:	dc400117 	ldw	r17,4(sp)
 d009440:	dc000017 	ldw	r16,0(sp)
 d009444:	dec00704 	addi	sp,sp,28
 d009448:	f800283a 	ret
 d00944c:	20800017 	ldw	r2,0(r4)
 d009450:	21000104 	addi	r4,r4,4
 d009454:	28800015 	stw	r2,0(r5)
 d009458:	29400104 	addi	r5,r5,4
 d00945c:	21ffec2e 	bgeu	r4,r7,d009410 <__lshift+0xe4>
 d009460:	20800017 	ldw	r2,0(r4)
 d009464:	21000104 	addi	r4,r4,4
 d009468:	28800015 	stw	r2,0(r5)
 d00946c:	29400104 	addi	r5,r5,4
 d009470:	21fff636 	bltu	r4,r7,d00944c <__lshift+0x120>
 d009474:	003fe606 	br	d009410 <__lshift+0xe4>

0d009478 <__multiply>:
 d009478:	defff004 	addi	sp,sp,-64
 d00947c:	dc800815 	stw	r18,32(sp)
 d009480:	dc400715 	stw	r17,28(sp)
 d009484:	2c800417 	ldw	r18,16(r5)
 d009488:	34400417 	ldw	r17,16(r6)
 d00948c:	dcc00915 	stw	r19,36(sp)
 d009490:	dc000615 	stw	r16,24(sp)
 d009494:	dfc00f15 	stw	ra,60(sp)
 d009498:	df000e15 	stw	fp,56(sp)
 d00949c:	ddc00d15 	stw	r23,52(sp)
 d0094a0:	dd800c15 	stw	r22,48(sp)
 d0094a4:	dd400b15 	stw	r21,44(sp)
 d0094a8:	dd000a15 	stw	r20,40(sp)
 d0094ac:	2821883a 	mov	r16,r5
 d0094b0:	3027883a 	mov	r19,r6
 d0094b4:	9440040e 	bge	r18,r17,d0094c8 <__multiply+0x50>
 d0094b8:	8825883a 	mov	r18,r17
 d0094bc:	2c400417 	ldw	r17,16(r5)
 d0094c0:	2827883a 	mov	r19,r5
 d0094c4:	3021883a 	mov	r16,r6
 d0094c8:	80800217 	ldw	r2,8(r16)
 d0094cc:	9447883a 	add	r3,r18,r17
 d0094d0:	d8c00415 	stw	r3,16(sp)
 d0094d4:	81400117 	ldw	r5,4(r16)
 d0094d8:	10c0010e 	bge	r2,r3,d0094e0 <__multiply+0x68>
 d0094dc:	29400044 	addi	r5,r5,1
 d0094e0:	d008f680 	call	d008f68 <_Balloc>
 d0094e4:	d8800515 	stw	r2,20(sp)
 d0094e8:	d9000417 	ldw	r4,16(sp)
 d0094ec:	d8c00517 	ldw	r3,20(sp)
 d0094f0:	2105883a 	add	r2,r4,r4
 d0094f4:	1085883a 	add	r2,r2,r2
 d0094f8:	19000504 	addi	r4,r3,20
 d0094fc:	2085883a 	add	r2,r4,r2
 d009500:	d8800315 	stw	r2,12(sp)
 d009504:	2080052e 	bgeu	r4,r2,d00951c <__multiply+0xa4>
 d009508:	2005883a 	mov	r2,r4
 d00950c:	d8c00317 	ldw	r3,12(sp)
 d009510:	10000015 	stw	zero,0(r2)
 d009514:	10800104 	addi	r2,r2,4
 d009518:	10fffc36 	bltu	r2,r3,d00950c <__multiply+0x94>
 d00951c:	8c45883a 	add	r2,r17,r17
 d009520:	9487883a 	add	r3,r18,r18
 d009524:	9dc00504 	addi	r23,r19,20
 d009528:	1085883a 	add	r2,r2,r2
 d00952c:	84000504 	addi	r16,r16,20
 d009530:	18c7883a 	add	r3,r3,r3
 d009534:	b885883a 	add	r2,r23,r2
 d009538:	dc000015 	stw	r16,0(sp)
 d00953c:	d8800215 	stw	r2,8(sp)
 d009540:	80f9883a 	add	fp,r16,r3
 d009544:	b880432e 	bgeu	r23,r2,d009654 <__multiply+0x1dc>
 d009548:	d9000115 	stw	r4,4(sp)
 d00954c:	b9000017 	ldw	r4,0(r23)
 d009550:	253fffcc 	andi	r20,r4,65535
 d009554:	a0001a26 	beq	r20,zero,d0095c0 <__multiply+0x148>
 d009558:	dcc00017 	ldw	r19,0(sp)
 d00955c:	dc800117 	ldw	r18,4(sp)
 d009560:	002b883a 	mov	r21,zero
 d009564:	9c400017 	ldw	r17,0(r19)
 d009568:	94000017 	ldw	r16,0(r18)
 d00956c:	a009883a 	mov	r4,r20
 d009570:	897fffcc 	andi	r5,r17,65535
 d009574:	d00235c0 	call	d00235c <__mulsi3>
 d009578:	880ad43a 	srli	r5,r17,16
 d00957c:	80ffffcc 	andi	r3,r16,65535
 d009580:	a8c7883a 	add	r3,r21,r3
 d009584:	a009883a 	mov	r4,r20
 d009588:	10e3883a 	add	r17,r2,r3
 d00958c:	8020d43a 	srli	r16,r16,16
 d009590:	d00235c0 	call	d00235c <__mulsi3>
 d009594:	8806d43a 	srli	r3,r17,16
 d009598:	1405883a 	add	r2,r2,r16
 d00959c:	9cc00104 	addi	r19,r19,4
 d0095a0:	1887883a 	add	r3,r3,r2
 d0095a4:	90c0008d 	sth	r3,2(r18)
 d0095a8:	9440000d 	sth	r17,0(r18)
 d0095ac:	182ad43a 	srli	r21,r3,16
 d0095b0:	94800104 	addi	r18,r18,4
 d0095b4:	9f3feb36 	bltu	r19,fp,d009564 <__multiply+0xec>
 d0095b8:	95400015 	stw	r21,0(r18)
 d0095bc:	b9000017 	ldw	r4,0(r23)
 d0095c0:	202ad43a 	srli	r21,r4,16
 d0095c4:	a8001c26 	beq	r21,zero,d009638 <__multiply+0x1c0>
 d0095c8:	d9000117 	ldw	r4,4(sp)
 d0095cc:	dd000017 	ldw	r20,0(sp)
 d0095d0:	002d883a 	mov	r22,zero
 d0095d4:	24c00017 	ldw	r19,0(r4)
 d0095d8:	2025883a 	mov	r18,r4
 d0095dc:	9823883a 	mov	r17,r19
 d0095e0:	a4000017 	ldw	r16,0(r20)
 d0095e4:	a809883a 	mov	r4,r21
 d0095e8:	a5000104 	addi	r20,r20,4
 d0095ec:	817fffcc 	andi	r5,r16,65535
 d0095f0:	d00235c0 	call	d00235c <__mulsi3>
 d0095f4:	8806d43a 	srli	r3,r17,16
 d0095f8:	800ad43a 	srli	r5,r16,16
 d0095fc:	94c0000d 	sth	r19,0(r18)
 d009600:	b0c7883a 	add	r3,r22,r3
 d009604:	10e1883a 	add	r16,r2,r3
 d009608:	9400008d 	sth	r16,2(r18)
 d00960c:	a809883a 	mov	r4,r21
 d009610:	94800104 	addi	r18,r18,4
 d009614:	d00235c0 	call	d00235c <__mulsi3>
 d009618:	94400017 	ldw	r17,0(r18)
 d00961c:	8020d43a 	srli	r16,r16,16
 d009620:	88ffffcc 	andi	r3,r17,65535
 d009624:	10c5883a 	add	r2,r2,r3
 d009628:	80a7883a 	add	r19,r16,r2
 d00962c:	982cd43a 	srli	r22,r19,16
 d009630:	a73feb36 	bltu	r20,fp,d0095e0 <__multiply+0x168>
 d009634:	94c00015 	stw	r19,0(r18)
 d009638:	d8800217 	ldw	r2,8(sp)
 d00963c:	bdc00104 	addi	r23,r23,4
 d009640:	b880042e 	bgeu	r23,r2,d009654 <__multiply+0x1dc>
 d009644:	d8c00117 	ldw	r3,4(sp)
 d009648:	18c00104 	addi	r3,r3,4
 d00964c:	d8c00115 	stw	r3,4(sp)
 d009650:	003fbe06 	br	d00954c <__multiply+0xd4>
 d009654:	d9000417 	ldw	r4,16(sp)
 d009658:	01000c0e 	bge	zero,r4,d00968c <__multiply+0x214>
 d00965c:	d8c00317 	ldw	r3,12(sp)
 d009660:	18bfff17 	ldw	r2,-4(r3)
 d009664:	18ffff04 	addi	r3,r3,-4
 d009668:	10000326 	beq	r2,zero,d009678 <__multiply+0x200>
 d00966c:	00000706 	br	d00968c <__multiply+0x214>
 d009670:	18800017 	ldw	r2,0(r3)
 d009674:	1000051e 	bne	r2,zero,d00968c <__multiply+0x214>
 d009678:	d9000417 	ldw	r4,16(sp)
 d00967c:	18ffff04 	addi	r3,r3,-4
 d009680:	213fffc4 	addi	r4,r4,-1
 d009684:	d9000415 	stw	r4,16(sp)
 d009688:	203ff91e 	bne	r4,zero,d009670 <__multiply+0x1f8>
 d00968c:	d8800417 	ldw	r2,16(sp)
 d009690:	d8c00517 	ldw	r3,20(sp)
 d009694:	18800415 	stw	r2,16(r3)
 d009698:	1805883a 	mov	r2,r3
 d00969c:	dfc00f17 	ldw	ra,60(sp)
 d0096a0:	df000e17 	ldw	fp,56(sp)
 d0096a4:	ddc00d17 	ldw	r23,52(sp)
 d0096a8:	dd800c17 	ldw	r22,48(sp)
 d0096ac:	dd400b17 	ldw	r21,44(sp)
 d0096b0:	dd000a17 	ldw	r20,40(sp)
 d0096b4:	dcc00917 	ldw	r19,36(sp)
 d0096b8:	dc800817 	ldw	r18,32(sp)
 d0096bc:	dc400717 	ldw	r17,28(sp)
 d0096c0:	dc000617 	ldw	r16,24(sp)
 d0096c4:	dec01004 	addi	sp,sp,64
 d0096c8:	f800283a 	ret

0d0096cc <__i2b>:
 d0096cc:	defffd04 	addi	sp,sp,-12
 d0096d0:	dc000015 	stw	r16,0(sp)
 d0096d4:	04000044 	movi	r16,1
 d0096d8:	dc800115 	stw	r18,4(sp)
 d0096dc:	2825883a 	mov	r18,r5
 d0096e0:	800b883a 	mov	r5,r16
 d0096e4:	dfc00215 	stw	ra,8(sp)
 d0096e8:	d008f680 	call	d008f68 <_Balloc>
 d0096ec:	14000415 	stw	r16,16(r2)
 d0096f0:	14800515 	stw	r18,20(r2)
 d0096f4:	dfc00217 	ldw	ra,8(sp)
 d0096f8:	dc800117 	ldw	r18,4(sp)
 d0096fc:	dc000017 	ldw	r16,0(sp)
 d009700:	dec00304 	addi	sp,sp,12
 d009704:	f800283a 	ret

0d009708 <__multadd>:
 d009708:	defff604 	addi	sp,sp,-40
 d00970c:	dd800615 	stw	r22,24(sp)
 d009710:	2d800417 	ldw	r22,16(r5)
 d009714:	df000815 	stw	fp,32(sp)
 d009718:	ddc00715 	stw	r23,28(sp)
 d00971c:	dd400515 	stw	r21,20(sp)
 d009720:	dd000415 	stw	r20,16(sp)
 d009724:	dcc00315 	stw	r19,12(sp)
 d009728:	dc800215 	stw	r18,8(sp)
 d00972c:	dfc00915 	stw	ra,36(sp)
 d009730:	dc400115 	stw	r17,4(sp)
 d009734:	dc000015 	stw	r16,0(sp)
 d009738:	282f883a 	mov	r23,r5
 d00973c:	2039883a 	mov	fp,r4
 d009740:	302b883a 	mov	r21,r6
 d009744:	3829883a 	mov	r20,r7
 d009748:	2c800504 	addi	r18,r5,20
 d00974c:	0027883a 	mov	r19,zero
 d009750:	94400017 	ldw	r17,0(r18)
 d009754:	a80b883a 	mov	r5,r21
 d009758:	9cc00044 	addi	r19,r19,1
 d00975c:	893fffcc 	andi	r4,r17,65535
 d009760:	d00235c0 	call	d00235c <__mulsi3>
 d009764:	8808d43a 	srli	r4,r17,16
 d009768:	1521883a 	add	r16,r2,r20
 d00976c:	a80b883a 	mov	r5,r21
 d009770:	d00235c0 	call	d00235c <__mulsi3>
 d009774:	8008d43a 	srli	r4,r16,16
 d009778:	843fffcc 	andi	r16,r16,65535
 d00977c:	1105883a 	add	r2,r2,r4
 d009780:	1006943a 	slli	r3,r2,16
 d009784:	1028d43a 	srli	r20,r2,16
 d009788:	1c07883a 	add	r3,r3,r16
 d00978c:	90c00015 	stw	r3,0(r18)
 d009790:	94800104 	addi	r18,r18,4
 d009794:	9dbfee16 	blt	r19,r22,d009750 <__multadd+0x48>
 d009798:	a0000826 	beq	r20,zero,d0097bc <__multadd+0xb4>
 d00979c:	b8800217 	ldw	r2,8(r23)
 d0097a0:	b080130e 	bge	r22,r2,d0097f0 <__multadd+0xe8>
 d0097a4:	b585883a 	add	r2,r22,r22
 d0097a8:	1085883a 	add	r2,r2,r2
 d0097ac:	15c5883a 	add	r2,r2,r23
 d0097b0:	b0c00044 	addi	r3,r22,1
 d0097b4:	15000515 	stw	r20,20(r2)
 d0097b8:	b8c00415 	stw	r3,16(r23)
 d0097bc:	b805883a 	mov	r2,r23
 d0097c0:	dfc00917 	ldw	ra,36(sp)
 d0097c4:	df000817 	ldw	fp,32(sp)
 d0097c8:	ddc00717 	ldw	r23,28(sp)
 d0097cc:	dd800617 	ldw	r22,24(sp)
 d0097d0:	dd400517 	ldw	r21,20(sp)
 d0097d4:	dd000417 	ldw	r20,16(sp)
 d0097d8:	dcc00317 	ldw	r19,12(sp)
 d0097dc:	dc800217 	ldw	r18,8(sp)
 d0097e0:	dc400117 	ldw	r17,4(sp)
 d0097e4:	dc000017 	ldw	r16,0(sp)
 d0097e8:	dec00a04 	addi	sp,sp,40
 d0097ec:	f800283a 	ret
 d0097f0:	b9400117 	ldw	r5,4(r23)
 d0097f4:	e009883a 	mov	r4,fp
 d0097f8:	29400044 	addi	r5,r5,1
 d0097fc:	d008f680 	call	d008f68 <_Balloc>
 d009800:	b9800417 	ldw	r6,16(r23)
 d009804:	b9400304 	addi	r5,r23,12
 d009808:	11000304 	addi	r4,r2,12
 d00980c:	318d883a 	add	r6,r6,r6
 d009810:	318d883a 	add	r6,r6,r6
 d009814:	31800204 	addi	r6,r6,8
 d009818:	1023883a 	mov	r17,r2
 d00981c:	d0026080 	call	d002608 <memcpy>
 d009820:	b80b883a 	mov	r5,r23
 d009824:	e009883a 	mov	r4,fp
 d009828:	d0089e80 	call	d0089e8 <_Bfree>
 d00982c:	882f883a 	mov	r23,r17
 d009830:	003fdc06 	br	d0097a4 <__multadd+0x9c>

0d009834 <__pow5mult>:
 d009834:	defffa04 	addi	sp,sp,-24
 d009838:	308000cc 	andi	r2,r6,3
 d00983c:	dd000415 	stw	r20,16(sp)
 d009840:	dcc00315 	stw	r19,12(sp)
 d009844:	dc000015 	stw	r16,0(sp)
 d009848:	dfc00515 	stw	ra,20(sp)
 d00984c:	dc800215 	stw	r18,8(sp)
 d009850:	dc400115 	stw	r17,4(sp)
 d009854:	3021883a 	mov	r16,r6
 d009858:	2027883a 	mov	r19,r4
 d00985c:	2829883a 	mov	r20,r5
 d009860:	10002b1e 	bne	r2,zero,d009910 <__pow5mult+0xdc>
 d009864:	8025d0ba 	srai	r18,r16,2
 d009868:	90001b26 	beq	r18,zero,d0098d8 <__pow5mult+0xa4>
 d00986c:	9c001217 	ldw	r16,72(r19)
 d009870:	8000081e 	bne	r16,zero,d009894 <__pow5mult+0x60>
 d009874:	00003006 	br	d009938 <__pow5mult+0x104>
 d009878:	800b883a 	mov	r5,r16
 d00987c:	800d883a 	mov	r6,r16
 d009880:	9809883a 	mov	r4,r19
 d009884:	90001426 	beq	r18,zero,d0098d8 <__pow5mult+0xa4>
 d009888:	80800017 	ldw	r2,0(r16)
 d00988c:	10001b26 	beq	r2,zero,d0098fc <__pow5mult+0xc8>
 d009890:	1021883a 	mov	r16,r2
 d009894:	9080004c 	andi	r2,r18,1
 d009898:	1005003a 	cmpeq	r2,r2,zero
 d00989c:	9025d07a 	srai	r18,r18,1
 d0098a0:	800d883a 	mov	r6,r16
 d0098a4:	9809883a 	mov	r4,r19
 d0098a8:	a00b883a 	mov	r5,r20
 d0098ac:	103ff21e 	bne	r2,zero,d009878 <__pow5mult+0x44>
 d0098b0:	d0094780 	call	d009478 <__multiply>
 d0098b4:	a00b883a 	mov	r5,r20
 d0098b8:	9809883a 	mov	r4,r19
 d0098bc:	1023883a 	mov	r17,r2
 d0098c0:	d0089e80 	call	d0089e8 <_Bfree>
 d0098c4:	8829883a 	mov	r20,r17
 d0098c8:	800b883a 	mov	r5,r16
 d0098cc:	800d883a 	mov	r6,r16
 d0098d0:	9809883a 	mov	r4,r19
 d0098d4:	903fec1e 	bne	r18,zero,d009888 <__pow5mult+0x54>
 d0098d8:	a005883a 	mov	r2,r20
 d0098dc:	dfc00517 	ldw	ra,20(sp)
 d0098e0:	dd000417 	ldw	r20,16(sp)
 d0098e4:	dcc00317 	ldw	r19,12(sp)
 d0098e8:	dc800217 	ldw	r18,8(sp)
 d0098ec:	dc400117 	ldw	r17,4(sp)
 d0098f0:	dc000017 	ldw	r16,0(sp)
 d0098f4:	dec00604 	addi	sp,sp,24
 d0098f8:	f800283a 	ret
 d0098fc:	d0094780 	call	d009478 <__multiply>
 d009900:	80800015 	stw	r2,0(r16)
 d009904:	1021883a 	mov	r16,r2
 d009908:	10000015 	stw	zero,0(r2)
 d00990c:	003fe106 	br	d009894 <__pow5mult+0x60>
 d009910:	1085883a 	add	r2,r2,r2
 d009914:	00c34174 	movhi	r3,3333
 d009918:	18f92a04 	addi	r3,r3,-7000
 d00991c:	1085883a 	add	r2,r2,r2
 d009920:	10c5883a 	add	r2,r2,r3
 d009924:	11bfff17 	ldw	r6,-4(r2)
 d009928:	000f883a 	mov	r7,zero
 d00992c:	d0097080 	call	d009708 <__multadd>
 d009930:	1029883a 	mov	r20,r2
 d009934:	003fcb06 	br	d009864 <__pow5mult+0x30>
 d009938:	9809883a 	mov	r4,r19
 d00993c:	01409c44 	movi	r5,625
 d009940:	d0096cc0 	call	d0096cc <__i2b>
 d009944:	98801215 	stw	r2,72(r19)
 d009948:	1021883a 	mov	r16,r2
 d00994c:	10000015 	stw	zero,0(r2)
 d009950:	003fd006 	br	d009894 <__pow5mult+0x60>

0d009954 <__s2b>:
 d009954:	defff904 	addi	sp,sp,-28
 d009958:	dcc00315 	stw	r19,12(sp)
 d00995c:	dc800215 	stw	r18,8(sp)
 d009960:	2827883a 	mov	r19,r5
 d009964:	2025883a 	mov	r18,r4
 d009968:	01400244 	movi	r5,9
 d00996c:	39000204 	addi	r4,r7,8
 d009970:	dd000415 	stw	r20,16(sp)
 d009974:	dc400115 	stw	r17,4(sp)
 d009978:	dfc00615 	stw	ra,24(sp)
 d00997c:	dd400515 	stw	r21,20(sp)
 d009980:	dc000015 	stw	r16,0(sp)
 d009984:	3829883a 	mov	r20,r7
 d009988:	3023883a 	mov	r17,r6
 d00998c:	d00c84c0 	call	d00c84c <__divsi3>
 d009990:	00c00044 	movi	r3,1
 d009994:	1880350e 	bge	r3,r2,d009a6c <__s2b+0x118>
 d009998:	000b883a 	mov	r5,zero
 d00999c:	18c7883a 	add	r3,r3,r3
 d0099a0:	29400044 	addi	r5,r5,1
 d0099a4:	18bffd16 	blt	r3,r2,d00999c <__s2b+0x48>
 d0099a8:	9009883a 	mov	r4,r18
 d0099ac:	d008f680 	call	d008f68 <_Balloc>
 d0099b0:	1011883a 	mov	r8,r2
 d0099b4:	d8800717 	ldw	r2,28(sp)
 d0099b8:	00c00044 	movi	r3,1
 d0099bc:	01800244 	movi	r6,9
 d0099c0:	40800515 	stw	r2,20(r8)
 d0099c4:	40c00415 	stw	r3,16(r8)
 d0099c8:	3440260e 	bge	r6,r17,d009a64 <__s2b+0x110>
 d0099cc:	3021883a 	mov	r16,r6
 d0099d0:	99ab883a 	add	r21,r19,r6
 d0099d4:	9c05883a 	add	r2,r19,r16
 d0099d8:	11c00007 	ldb	r7,0(r2)
 d0099dc:	400b883a 	mov	r5,r8
 d0099e0:	9009883a 	mov	r4,r18
 d0099e4:	39fff404 	addi	r7,r7,-48
 d0099e8:	01800284 	movi	r6,10
 d0099ec:	d0097080 	call	d009708 <__multadd>
 d0099f0:	84000044 	addi	r16,r16,1
 d0099f4:	1011883a 	mov	r8,r2
 d0099f8:	8c3ff61e 	bne	r17,r16,d0099d4 <__s2b+0x80>
 d0099fc:	ac45883a 	add	r2,r21,r17
 d009a00:	117ffe04 	addi	r5,r2,-8
 d009a04:	880d883a 	mov	r6,r17
 d009a08:	35000c0e 	bge	r6,r20,d009a3c <__s2b+0xe8>
 d009a0c:	a185c83a 	sub	r2,r20,r6
 d009a10:	2821883a 	mov	r16,r5
 d009a14:	28a3883a 	add	r17,r5,r2
 d009a18:	81c00007 	ldb	r7,0(r16)
 d009a1c:	400b883a 	mov	r5,r8
 d009a20:	9009883a 	mov	r4,r18
 d009a24:	39fff404 	addi	r7,r7,-48
 d009a28:	01800284 	movi	r6,10
 d009a2c:	d0097080 	call	d009708 <__multadd>
 d009a30:	84000044 	addi	r16,r16,1
 d009a34:	1011883a 	mov	r8,r2
 d009a38:	847ff71e 	bne	r16,r17,d009a18 <__s2b+0xc4>
 d009a3c:	4005883a 	mov	r2,r8
 d009a40:	dfc00617 	ldw	ra,24(sp)
 d009a44:	dd400517 	ldw	r21,20(sp)
 d009a48:	dd000417 	ldw	r20,16(sp)
 d009a4c:	dcc00317 	ldw	r19,12(sp)
 d009a50:	dc800217 	ldw	r18,8(sp)
 d009a54:	dc400117 	ldw	r17,4(sp)
 d009a58:	dc000017 	ldw	r16,0(sp)
 d009a5c:	dec00704 	addi	sp,sp,28
 d009a60:	f800283a 	ret
 d009a64:	99400284 	addi	r5,r19,10
 d009a68:	003fe706 	br	d009a08 <__s2b+0xb4>
 d009a6c:	000b883a 	mov	r5,zero
 d009a70:	003fcd06 	br	d0099a8 <__s2b+0x54>

0d009a74 <_realloc_r>:
 d009a74:	defff404 	addi	sp,sp,-48
 d009a78:	dd800815 	stw	r22,32(sp)
 d009a7c:	dc800415 	stw	r18,16(sp)
 d009a80:	dc400315 	stw	r17,12(sp)
 d009a84:	dfc00b15 	stw	ra,44(sp)
 d009a88:	df000a15 	stw	fp,40(sp)
 d009a8c:	ddc00915 	stw	r23,36(sp)
 d009a90:	dd400715 	stw	r21,28(sp)
 d009a94:	dd000615 	stw	r20,24(sp)
 d009a98:	dcc00515 	stw	r19,20(sp)
 d009a9c:	dc000215 	stw	r16,8(sp)
 d009aa0:	2825883a 	mov	r18,r5
 d009aa4:	3023883a 	mov	r17,r6
 d009aa8:	202d883a 	mov	r22,r4
 d009aac:	2800c926 	beq	r5,zero,d009dd4 <_realloc_r+0x360>
 d009ab0:	d00d7cc0 	call	d00d7cc <__malloc_lock>
 d009ab4:	943ffe04 	addi	r16,r18,-8
 d009ab8:	88c002c4 	addi	r3,r17,11
 d009abc:	00800584 	movi	r2,22
 d009ac0:	82000117 	ldw	r8,4(r16)
 d009ac4:	10c01b2e 	bgeu	r2,r3,d009b34 <_realloc_r+0xc0>
 d009ac8:	00bffe04 	movi	r2,-8
 d009acc:	188e703a 	and	r7,r3,r2
 d009ad0:	3839883a 	mov	fp,r7
 d009ad4:	38001a16 	blt	r7,zero,d009b40 <_realloc_r+0xcc>
 d009ad8:	e4401936 	bltu	fp,r17,d009b40 <_realloc_r+0xcc>
 d009adc:	013fff04 	movi	r4,-4
 d009ae0:	4126703a 	and	r19,r8,r4
 d009ae4:	99c02616 	blt	r19,r7,d009b80 <_realloc_r+0x10c>
 d009ae8:	802b883a 	mov	r21,r16
 d009aec:	9829883a 	mov	r20,r19
 d009af0:	84000204 	addi	r16,r16,8
 d009af4:	a80f883a 	mov	r7,r21
 d009af8:	a70dc83a 	sub	r6,r20,fp
 d009afc:	008003c4 	movi	r2,15
 d009b00:	1180c136 	bltu	r2,r6,d009e08 <_realloc_r+0x394>
 d009b04:	38800117 	ldw	r2,4(r7)
 d009b08:	a549883a 	add	r4,r20,r21
 d009b0c:	1080004c 	andi	r2,r2,1
 d009b10:	a084b03a 	or	r2,r20,r2
 d009b14:	38800115 	stw	r2,4(r7)
 d009b18:	20c00117 	ldw	r3,4(r4)
 d009b1c:	18c00054 	ori	r3,r3,1
 d009b20:	20c00115 	stw	r3,4(r4)
 d009b24:	b009883a 	mov	r4,r22
 d009b28:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d009b2c:	8023883a 	mov	r17,r16
 d009b30:	00000606 	br	d009b4c <_realloc_r+0xd8>
 d009b34:	01c00404 	movi	r7,16
 d009b38:	3839883a 	mov	fp,r7
 d009b3c:	e47fe72e 	bgeu	fp,r17,d009adc <_realloc_r+0x68>
 d009b40:	00800304 	movi	r2,12
 d009b44:	0023883a 	mov	r17,zero
 d009b48:	b0800015 	stw	r2,0(r22)
 d009b4c:	8805883a 	mov	r2,r17
 d009b50:	dfc00b17 	ldw	ra,44(sp)
 d009b54:	df000a17 	ldw	fp,40(sp)
 d009b58:	ddc00917 	ldw	r23,36(sp)
 d009b5c:	dd800817 	ldw	r22,32(sp)
 d009b60:	dd400717 	ldw	r21,28(sp)
 d009b64:	dd000617 	ldw	r20,24(sp)
 d009b68:	dcc00517 	ldw	r19,20(sp)
 d009b6c:	dc800417 	ldw	r18,16(sp)
 d009b70:	dc400317 	ldw	r17,12(sp)
 d009b74:	dc000217 	ldw	r16,8(sp)
 d009b78:	dec00c04 	addi	sp,sp,48
 d009b7c:	f800283a 	ret
 d009b80:	00834174 	movhi	r2,3333
 d009b84:	108b4704 	addi	r2,r2,11548
 d009b88:	12400217 	ldw	r9,8(r2)
 d009b8c:	84cd883a 	add	r6,r16,r19
 d009b90:	802b883a 	mov	r21,r16
 d009b94:	3240b926 	beq	r6,r9,d009e7c <_realloc_r+0x408>
 d009b98:	31400117 	ldw	r5,4(r6)
 d009b9c:	00bfff84 	movi	r2,-2
 d009ba0:	2884703a 	and	r2,r5,r2
 d009ba4:	1185883a 	add	r2,r2,r6
 d009ba8:	10c00117 	ldw	r3,4(r2)
 d009bac:	18c0004c 	andi	r3,r3,1
 d009bb0:	1807003a 	cmpeq	r3,r3,zero
 d009bb4:	1800a326 	beq	r3,zero,d009e44 <_realloc_r+0x3d0>
 d009bb8:	2908703a 	and	r4,r5,r4
 d009bbc:	9929883a 	add	r20,r19,r4
 d009bc0:	a1c0a30e 	bge	r20,r7,d009e50 <_realloc_r+0x3dc>
 d009bc4:	4080004c 	andi	r2,r8,1
 d009bc8:	1000551e 	bne	r2,zero,d009d20 <_realloc_r+0x2ac>
 d009bcc:	80800017 	ldw	r2,0(r16)
 d009bd0:	80afc83a 	sub	r23,r16,r2
 d009bd4:	b8c00117 	ldw	r3,4(r23)
 d009bd8:	00bfff04 	movi	r2,-4
 d009bdc:	1884703a 	and	r2,r3,r2
 d009be0:	30002e26 	beq	r6,zero,d009c9c <_realloc_r+0x228>
 d009be4:	3240b926 	beq	r6,r9,d009ecc <_realloc_r+0x458>
 d009be8:	98a9883a 	add	r20,r19,r2
 d009bec:	2509883a 	add	r4,r4,r20
 d009bf0:	d9000015 	stw	r4,0(sp)
 d009bf4:	21c02a16 	blt	r4,r7,d009ca0 <_realloc_r+0x22c>
 d009bf8:	30800317 	ldw	r2,12(r6)
 d009bfc:	30c00217 	ldw	r3,8(r6)
 d009c00:	01400904 	movi	r5,36
 d009c04:	99bfff04 	addi	r6,r19,-4
 d009c08:	18800315 	stw	r2,12(r3)
 d009c0c:	10c00215 	stw	r3,8(r2)
 d009c10:	b9000317 	ldw	r4,12(r23)
 d009c14:	b8800217 	ldw	r2,8(r23)
 d009c18:	b82b883a 	mov	r21,r23
 d009c1c:	bc000204 	addi	r16,r23,8
 d009c20:	20800215 	stw	r2,8(r4)
 d009c24:	11000315 	stw	r4,12(r2)
 d009c28:	2980e436 	bltu	r5,r6,d009fbc <_realloc_r+0x548>
 d009c2c:	008004c4 	movi	r2,19
 d009c30:	9009883a 	mov	r4,r18
 d009c34:	8011883a 	mov	r8,r16
 d009c38:	11800f2e 	bgeu	r2,r6,d009c78 <_realloc_r+0x204>
 d009c3c:	90800017 	ldw	r2,0(r18)
 d009c40:	ba000404 	addi	r8,r23,16
 d009c44:	91000204 	addi	r4,r18,8
 d009c48:	b8800215 	stw	r2,8(r23)
 d009c4c:	90c00117 	ldw	r3,4(r18)
 d009c50:	008006c4 	movi	r2,27
 d009c54:	b8c00315 	stw	r3,12(r23)
 d009c58:	1180072e 	bgeu	r2,r6,d009c78 <_realloc_r+0x204>
 d009c5c:	90c00217 	ldw	r3,8(r18)
 d009c60:	ba000604 	addi	r8,r23,24
 d009c64:	91000404 	addi	r4,r18,16
 d009c68:	b8c00415 	stw	r3,16(r23)
 d009c6c:	90800317 	ldw	r2,12(r18)
 d009c70:	b8800515 	stw	r2,20(r23)
 d009c74:	3140e726 	beq	r6,r5,d00a014 <_realloc_r+0x5a0>
 d009c78:	20800017 	ldw	r2,0(r4)
 d009c7c:	dd000017 	ldw	r20,0(sp)
 d009c80:	b80f883a 	mov	r7,r23
 d009c84:	40800015 	stw	r2,0(r8)
 d009c88:	20c00117 	ldw	r3,4(r4)
 d009c8c:	40c00115 	stw	r3,4(r8)
 d009c90:	20800217 	ldw	r2,8(r4)
 d009c94:	40800215 	stw	r2,8(r8)
 d009c98:	003f9706 	br	d009af8 <_realloc_r+0x84>
 d009c9c:	98a9883a 	add	r20,r19,r2
 d009ca0:	a1c01f16 	blt	r20,r7,d009d20 <_realloc_r+0x2ac>
 d009ca4:	b8c00317 	ldw	r3,12(r23)
 d009ca8:	b8800217 	ldw	r2,8(r23)
 d009cac:	99bfff04 	addi	r6,r19,-4
 d009cb0:	01400904 	movi	r5,36
 d009cb4:	b82b883a 	mov	r21,r23
 d009cb8:	18800215 	stw	r2,8(r3)
 d009cbc:	10c00315 	stw	r3,12(r2)
 d009cc0:	bc000204 	addi	r16,r23,8
 d009cc4:	2980c336 	bltu	r5,r6,d009fd4 <_realloc_r+0x560>
 d009cc8:	008004c4 	movi	r2,19
 d009ccc:	9009883a 	mov	r4,r18
 d009cd0:	8011883a 	mov	r8,r16
 d009cd4:	11800f2e 	bgeu	r2,r6,d009d14 <_realloc_r+0x2a0>
 d009cd8:	90800017 	ldw	r2,0(r18)
 d009cdc:	ba000404 	addi	r8,r23,16
 d009ce0:	91000204 	addi	r4,r18,8
 d009ce4:	b8800215 	stw	r2,8(r23)
 d009ce8:	90c00117 	ldw	r3,4(r18)
 d009cec:	008006c4 	movi	r2,27
 d009cf0:	b8c00315 	stw	r3,12(r23)
 d009cf4:	1180072e 	bgeu	r2,r6,d009d14 <_realloc_r+0x2a0>
 d009cf8:	90c00217 	ldw	r3,8(r18)
 d009cfc:	ba000604 	addi	r8,r23,24
 d009d00:	91000404 	addi	r4,r18,16
 d009d04:	b8c00415 	stw	r3,16(r23)
 d009d08:	90800317 	ldw	r2,12(r18)
 d009d0c:	b8800515 	stw	r2,20(r23)
 d009d10:	3140c726 	beq	r6,r5,d00a030 <_realloc_r+0x5bc>
 d009d14:	20800017 	ldw	r2,0(r4)
 d009d18:	b80f883a 	mov	r7,r23
 d009d1c:	003fd906 	br	d009c84 <_realloc_r+0x210>
 d009d20:	880b883a 	mov	r5,r17
 d009d24:	b009883a 	mov	r4,r22
 d009d28:	d0081c40 	call	d0081c4 <_malloc_r>
 d009d2c:	1023883a 	mov	r17,r2
 d009d30:	10002526 	beq	r2,zero,d009dc8 <_realloc_r+0x354>
 d009d34:	80800117 	ldw	r2,4(r16)
 d009d38:	00ffff84 	movi	r3,-2
 d009d3c:	893ffe04 	addi	r4,r17,-8
 d009d40:	10c4703a 	and	r2,r2,r3
 d009d44:	8085883a 	add	r2,r16,r2
 d009d48:	20809526 	beq	r4,r2,d009fa0 <_realloc_r+0x52c>
 d009d4c:	99bfff04 	addi	r6,r19,-4
 d009d50:	01c00904 	movi	r7,36
 d009d54:	39804536 	bltu	r7,r6,d009e6c <_realloc_r+0x3f8>
 d009d58:	008004c4 	movi	r2,19
 d009d5c:	9009883a 	mov	r4,r18
 d009d60:	880b883a 	mov	r5,r17
 d009d64:	11800f2e 	bgeu	r2,r6,d009da4 <_realloc_r+0x330>
 d009d68:	90800017 	ldw	r2,0(r18)
 d009d6c:	89400204 	addi	r5,r17,8
 d009d70:	91000204 	addi	r4,r18,8
 d009d74:	88800015 	stw	r2,0(r17)
 d009d78:	90c00117 	ldw	r3,4(r18)
 d009d7c:	008006c4 	movi	r2,27
 d009d80:	88c00115 	stw	r3,4(r17)
 d009d84:	1180072e 	bgeu	r2,r6,d009da4 <_realloc_r+0x330>
 d009d88:	90c00217 	ldw	r3,8(r18)
 d009d8c:	89400404 	addi	r5,r17,16
 d009d90:	91000404 	addi	r4,r18,16
 d009d94:	88c00215 	stw	r3,8(r17)
 d009d98:	90800317 	ldw	r2,12(r18)
 d009d9c:	88800315 	stw	r2,12(r17)
 d009da0:	31c09126 	beq	r6,r7,d009fe8 <_realloc_r+0x574>
 d009da4:	20800017 	ldw	r2,0(r4)
 d009da8:	28800015 	stw	r2,0(r5)
 d009dac:	20c00117 	ldw	r3,4(r4)
 d009db0:	28c00115 	stw	r3,4(r5)
 d009db4:	20800217 	ldw	r2,8(r4)
 d009db8:	28800215 	stw	r2,8(r5)
 d009dbc:	900b883a 	mov	r5,r18
 d009dc0:	b009883a 	mov	r4,r22
 d009dc4:	d00763c0 	call	d00763c <_free_r>
 d009dc8:	b009883a 	mov	r4,r22
 d009dcc:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d009dd0:	003f5e06 	br	d009b4c <_realloc_r+0xd8>
 d009dd4:	300b883a 	mov	r5,r6
 d009dd8:	dfc00b17 	ldw	ra,44(sp)
 d009ddc:	df000a17 	ldw	fp,40(sp)
 d009de0:	ddc00917 	ldw	r23,36(sp)
 d009de4:	dd800817 	ldw	r22,32(sp)
 d009de8:	dd400717 	ldw	r21,28(sp)
 d009dec:	dd000617 	ldw	r20,24(sp)
 d009df0:	dcc00517 	ldw	r19,20(sp)
 d009df4:	dc800417 	ldw	r18,16(sp)
 d009df8:	dc400317 	ldw	r17,12(sp)
 d009dfc:	dc000217 	ldw	r16,8(sp)
 d009e00:	dec00c04 	addi	sp,sp,48
 d009e04:	d0081c41 	jmpi	d0081c4 <_malloc_r>
 d009e08:	38800117 	ldw	r2,4(r7)
 d009e0c:	e54b883a 	add	r5,fp,r21
 d009e10:	31000054 	ori	r4,r6,1
 d009e14:	1080004c 	andi	r2,r2,1
 d009e18:	1704b03a 	or	r2,r2,fp
 d009e1c:	38800115 	stw	r2,4(r7)
 d009e20:	29000115 	stw	r4,4(r5)
 d009e24:	2987883a 	add	r3,r5,r6
 d009e28:	18800117 	ldw	r2,4(r3)
 d009e2c:	29400204 	addi	r5,r5,8
 d009e30:	b009883a 	mov	r4,r22
 d009e34:	10800054 	ori	r2,r2,1
 d009e38:	18800115 	stw	r2,4(r3)
 d009e3c:	d00763c0 	call	d00763c <_free_r>
 d009e40:	003f3806 	br	d009b24 <_realloc_r+0xb0>
 d009e44:	000d883a 	mov	r6,zero
 d009e48:	0009883a 	mov	r4,zero
 d009e4c:	003f5d06 	br	d009bc4 <_realloc_r+0x150>
 d009e50:	30c00217 	ldw	r3,8(r6)
 d009e54:	30800317 	ldw	r2,12(r6)
 d009e58:	800f883a 	mov	r7,r16
 d009e5c:	84000204 	addi	r16,r16,8
 d009e60:	10c00215 	stw	r3,8(r2)
 d009e64:	18800315 	stw	r2,12(r3)
 d009e68:	003f2306 	br	d009af8 <_realloc_r+0x84>
 d009e6c:	8809883a 	mov	r4,r17
 d009e70:	900b883a 	mov	r5,r18
 d009e74:	d0026a80 	call	d0026a8 <memmove>
 d009e78:	003fd006 	br	d009dbc <_realloc_r+0x348>
 d009e7c:	30800117 	ldw	r2,4(r6)
 d009e80:	e0c00404 	addi	r3,fp,16
 d009e84:	1108703a 	and	r4,r2,r4
 d009e88:	9905883a 	add	r2,r19,r4
 d009e8c:	10ff4d16 	blt	r2,r3,d009bc4 <_realloc_r+0x150>
 d009e90:	1705c83a 	sub	r2,r2,fp
 d009e94:	870b883a 	add	r5,r16,fp
 d009e98:	10800054 	ori	r2,r2,1
 d009e9c:	28800115 	stw	r2,4(r5)
 d009ea0:	80c00117 	ldw	r3,4(r16)
 d009ea4:	00834174 	movhi	r2,3333
 d009ea8:	108b4704 	addi	r2,r2,11548
 d009eac:	b009883a 	mov	r4,r22
 d009eb0:	18c0004c 	andi	r3,r3,1
 d009eb4:	e0c6b03a 	or	r3,fp,r3
 d009eb8:	11400215 	stw	r5,8(r2)
 d009ebc:	80c00115 	stw	r3,4(r16)
 d009ec0:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d009ec4:	84400204 	addi	r17,r16,8
 d009ec8:	003f2006 	br	d009b4c <_realloc_r+0xd8>
 d009ecc:	98a9883a 	add	r20,r19,r2
 d009ed0:	2509883a 	add	r4,r4,r20
 d009ed4:	e0800404 	addi	r2,fp,16
 d009ed8:	d9000115 	stw	r4,4(sp)
 d009edc:	20bf7016 	blt	r4,r2,d009ca0 <_realloc_r+0x22c>
 d009ee0:	b8c00317 	ldw	r3,12(r23)
 d009ee4:	b8800217 	ldw	r2,8(r23)
 d009ee8:	99bfff04 	addi	r6,r19,-4
 d009eec:	01400904 	movi	r5,36
 d009ef0:	18800215 	stw	r2,8(r3)
 d009ef4:	10c00315 	stw	r3,12(r2)
 d009ef8:	bc400204 	addi	r17,r23,8
 d009efc:	29804136 	bltu	r5,r6,d00a004 <_realloc_r+0x590>
 d009f00:	008004c4 	movi	r2,19
 d009f04:	9009883a 	mov	r4,r18
 d009f08:	880f883a 	mov	r7,r17
 d009f0c:	11800f2e 	bgeu	r2,r6,d009f4c <_realloc_r+0x4d8>
 d009f10:	90800017 	ldw	r2,0(r18)
 d009f14:	b9c00404 	addi	r7,r23,16
 d009f18:	91000204 	addi	r4,r18,8
 d009f1c:	b8800215 	stw	r2,8(r23)
 d009f20:	90c00117 	ldw	r3,4(r18)
 d009f24:	008006c4 	movi	r2,27
 d009f28:	b8c00315 	stw	r3,12(r23)
 d009f2c:	1180072e 	bgeu	r2,r6,d009f4c <_realloc_r+0x4d8>
 d009f30:	90c00217 	ldw	r3,8(r18)
 d009f34:	b9c00604 	addi	r7,r23,24
 d009f38:	91000404 	addi	r4,r18,16
 d009f3c:	b8c00415 	stw	r3,16(r23)
 d009f40:	90800317 	ldw	r2,12(r18)
 d009f44:	b8800515 	stw	r2,20(r23)
 d009f48:	31404026 	beq	r6,r5,d00a04c <_realloc_r+0x5d8>
 d009f4c:	20800017 	ldw	r2,0(r4)
 d009f50:	38800015 	stw	r2,0(r7)
 d009f54:	20c00117 	ldw	r3,4(r4)
 d009f58:	38c00115 	stw	r3,4(r7)
 d009f5c:	20800217 	ldw	r2,8(r4)
 d009f60:	38800215 	stw	r2,8(r7)
 d009f64:	d8c00117 	ldw	r3,4(sp)
 d009f68:	bf0b883a 	add	r5,r23,fp
 d009f6c:	b009883a 	mov	r4,r22
 d009f70:	1f05c83a 	sub	r2,r3,fp
 d009f74:	10800054 	ori	r2,r2,1
 d009f78:	28800115 	stw	r2,4(r5)
 d009f7c:	b8c00117 	ldw	r3,4(r23)
 d009f80:	00834174 	movhi	r2,3333
 d009f84:	108b4704 	addi	r2,r2,11548
 d009f88:	11400215 	stw	r5,8(r2)
 d009f8c:	18c0004c 	andi	r3,r3,1
 d009f90:	e0c6b03a 	or	r3,fp,r3
 d009f94:	b8c00115 	stw	r3,4(r23)
 d009f98:	d00d8d40 	call	d00d8d4 <__malloc_unlock>
 d009f9c:	003eeb06 	br	d009b4c <_realloc_r+0xd8>
 d009fa0:	20800117 	ldw	r2,4(r4)
 d009fa4:	00ffff04 	movi	r3,-4
 d009fa8:	800f883a 	mov	r7,r16
 d009fac:	10c4703a 	and	r2,r2,r3
 d009fb0:	98a9883a 	add	r20,r19,r2
 d009fb4:	84000204 	addi	r16,r16,8
 d009fb8:	003ecf06 	br	d009af8 <_realloc_r+0x84>
 d009fbc:	900b883a 	mov	r5,r18
 d009fc0:	8009883a 	mov	r4,r16
 d009fc4:	d0026a80 	call	d0026a8 <memmove>
 d009fc8:	dd000017 	ldw	r20,0(sp)
 d009fcc:	b80f883a 	mov	r7,r23
 d009fd0:	003ec906 	br	d009af8 <_realloc_r+0x84>
 d009fd4:	900b883a 	mov	r5,r18
 d009fd8:	8009883a 	mov	r4,r16
 d009fdc:	d0026a80 	call	d0026a8 <memmove>
 d009fe0:	b80f883a 	mov	r7,r23
 d009fe4:	003ec406 	br	d009af8 <_realloc_r+0x84>
 d009fe8:	90c00417 	ldw	r3,16(r18)
 d009fec:	89400604 	addi	r5,r17,24
 d009ff0:	91000604 	addi	r4,r18,24
 d009ff4:	88c00415 	stw	r3,16(r17)
 d009ff8:	90800517 	ldw	r2,20(r18)
 d009ffc:	88800515 	stw	r2,20(r17)
 d00a000:	003f6806 	br	d009da4 <_realloc_r+0x330>
 d00a004:	900b883a 	mov	r5,r18
 d00a008:	8809883a 	mov	r4,r17
 d00a00c:	d0026a80 	call	d0026a8 <memmove>
 d00a010:	003fd406 	br	d009f64 <_realloc_r+0x4f0>
 d00a014:	90c00417 	ldw	r3,16(r18)
 d00a018:	91000604 	addi	r4,r18,24
 d00a01c:	ba000804 	addi	r8,r23,32
 d00a020:	b8c00615 	stw	r3,24(r23)
 d00a024:	90800517 	ldw	r2,20(r18)
 d00a028:	b8800715 	stw	r2,28(r23)
 d00a02c:	003f1206 	br	d009c78 <_realloc_r+0x204>
 d00a030:	90c00417 	ldw	r3,16(r18)
 d00a034:	91000604 	addi	r4,r18,24
 d00a038:	ba000804 	addi	r8,r23,32
 d00a03c:	b8c00615 	stw	r3,24(r23)
 d00a040:	90800517 	ldw	r2,20(r18)
 d00a044:	b8800715 	stw	r2,28(r23)
 d00a048:	003f3206 	br	d009d14 <_realloc_r+0x2a0>
 d00a04c:	90c00417 	ldw	r3,16(r18)
 d00a050:	91000604 	addi	r4,r18,24
 d00a054:	b9c00804 	addi	r7,r23,32
 d00a058:	b8c00615 	stw	r3,24(r23)
 d00a05c:	90800517 	ldw	r2,20(r18)
 d00a060:	b8800715 	stw	r2,28(r23)
 d00a064:	003fb906 	br	d009f4c <_realloc_r+0x4d8>

0d00a068 <__srefill_r>:
 d00a068:	defffd04 	addi	sp,sp,-12
 d00a06c:	dc400115 	stw	r17,4(sp)
 d00a070:	dc000015 	stw	r16,0(sp)
 d00a074:	dfc00215 	stw	ra,8(sp)
 d00a078:	2023883a 	mov	r17,r4
 d00a07c:	2821883a 	mov	r16,r5
 d00a080:	20000226 	beq	r4,zero,d00a08c <__srefill_r+0x24>
 d00a084:	20800e17 	ldw	r2,56(r4)
 d00a088:	10004126 	beq	r2,zero,d00a190 <__srefill_r+0x128>
 d00a08c:	80c0030b 	ldhu	r3,12(r16)
 d00a090:	80000115 	stw	zero,4(r16)
 d00a094:	1880080c 	andi	r2,r3,32
 d00a098:	1000361e 	bne	r2,zero,d00a174 <__srefill_r+0x10c>
 d00a09c:	1880010c 	andi	r2,r3,4
 d00a0a0:	1000211e 	bne	r2,zero,d00a128 <__srefill_r+0xc0>
 d00a0a4:	1880040c 	andi	r2,r3,16
 d00a0a8:	10005026 	beq	r2,zero,d00a1ec <__srefill_r+0x184>
 d00a0ac:	1880020c 	andi	r2,r3,8
 d00a0b0:	1000541e 	bne	r2,zero,d00a204 <__srefill_r+0x19c>
 d00a0b4:	8080030b 	ldhu	r2,12(r16)
 d00a0b8:	10800114 	ori	r2,r2,4
 d00a0bc:	8080030d 	sth	r2,12(r16)
 d00a0c0:	80800417 	ldw	r2,16(r16)
 d00a0c4:	10004526 	beq	r2,zero,d00a1dc <__srefill_r+0x174>
 d00a0c8:	8080030b 	ldhu	r2,12(r16)
 d00a0cc:	108000cc 	andi	r2,r2,3
 d00a0d0:	1000361e 	bne	r2,zero,d00a1ac <__srefill_r+0x144>
 d00a0d4:	81800417 	ldw	r6,16(r16)
 d00a0d8:	80c00817 	ldw	r3,32(r16)
 d00a0dc:	81400717 	ldw	r5,28(r16)
 d00a0e0:	81c00517 	ldw	r7,20(r16)
 d00a0e4:	8809883a 	mov	r4,r17
 d00a0e8:	81800015 	stw	r6,0(r16)
 d00a0ec:	183ee83a 	callr	r3
 d00a0f0:	80c0030b 	ldhu	r3,12(r16)
 d00a0f4:	1009883a 	mov	r4,r2
 d00a0f8:	80800115 	stw	r2,4(r16)
 d00a0fc:	00b7ffc4 	movi	r2,-8193
 d00a100:	1884703a 	and	r2,r3,r2
 d00a104:	8080030d 	sth	r2,12(r16)
 d00a108:	0100230e 	bge	zero,r4,d00a198 <__srefill_r+0x130>
 d00a10c:	0009883a 	mov	r4,zero
 d00a110:	2005883a 	mov	r2,r4
 d00a114:	dfc00217 	ldw	ra,8(sp)
 d00a118:	dc400117 	ldw	r17,4(sp)
 d00a11c:	dc000017 	ldw	r16,0(sp)
 d00a120:	dec00304 	addi	sp,sp,12
 d00a124:	f800283a 	ret
 d00a128:	81400c17 	ldw	r5,48(r16)
 d00a12c:	283fe426 	beq	r5,zero,d00a0c0 <__srefill_r+0x58>
 d00a130:	80801004 	addi	r2,r16,64
 d00a134:	28800226 	beq	r5,r2,d00a140 <__srefill_r+0xd8>
 d00a138:	8809883a 	mov	r4,r17
 d00a13c:	d00763c0 	call	d00763c <_free_r>
 d00a140:	80800f17 	ldw	r2,60(r16)
 d00a144:	80000c15 	stw	zero,48(r16)
 d00a148:	80800115 	stw	r2,4(r16)
 d00a14c:	103fdc26 	beq	r2,zero,d00a0c0 <__srefill_r+0x58>
 d00a150:	80800e17 	ldw	r2,56(r16)
 d00a154:	0009883a 	mov	r4,zero
 d00a158:	80800015 	stw	r2,0(r16)
 d00a15c:	2005883a 	mov	r2,r4
 d00a160:	dfc00217 	ldw	ra,8(sp)
 d00a164:	dc400117 	ldw	r17,4(sp)
 d00a168:	dc000017 	ldw	r16,0(sp)
 d00a16c:	dec00304 	addi	sp,sp,12
 d00a170:	f800283a 	ret
 d00a174:	013fffc4 	movi	r4,-1
 d00a178:	2005883a 	mov	r2,r4
 d00a17c:	dfc00217 	ldw	ra,8(sp)
 d00a180:	dc400117 	ldw	r17,4(sp)
 d00a184:	dc000017 	ldw	r16,0(sp)
 d00a188:	dec00304 	addi	sp,sp,12
 d00a18c:	f800283a 	ret
 d00a190:	d0071380 	call	d007138 <__sinit>
 d00a194:	003fbd06 	br	d00a08c <__srefill_r+0x24>
 d00a198:	20000b1e 	bne	r4,zero,d00a1c8 <__srefill_r+0x160>
 d00a19c:	10800814 	ori	r2,r2,32
 d00a1a0:	013fffc4 	movi	r4,-1
 d00a1a4:	8080030d 	sth	r2,12(r16)
 d00a1a8:	003fd906 	br	d00a110 <__srefill_r+0xa8>
 d00a1ac:	00834174 	movhi	r2,3333
 d00a1b0:	10922104 	addi	r2,r2,18564
 d00a1b4:	11000017 	ldw	r4,0(r2)
 d00a1b8:	01434074 	movhi	r5,3329
 d00a1bc:	29688b04 	addi	r5,r5,-24020
 d00a1c0:	d007eb40 	call	d007eb4 <_fwalk>
 d00a1c4:	003fc306 	br	d00a0d4 <__srefill_r+0x6c>
 d00a1c8:	10801014 	ori	r2,r2,64
 d00a1cc:	013fffc4 	movi	r4,-1
 d00a1d0:	8080030d 	sth	r2,12(r16)
 d00a1d4:	80000115 	stw	zero,4(r16)
 d00a1d8:	003fcd06 	br	d00a110 <__srefill_r+0xa8>
 d00a1dc:	8809883a 	mov	r4,r17
 d00a1e0:	800b883a 	mov	r5,r16
 d00a1e4:	d0080300 	call	d008030 <__smakebuf_r>
 d00a1e8:	003fb706 	br	d00a0c8 <__srefill_r+0x60>
 d00a1ec:	18c01014 	ori	r3,r3,64
 d00a1f0:	00800244 	movi	r2,9
 d00a1f4:	013fffc4 	movi	r4,-1
 d00a1f8:	88800015 	stw	r2,0(r17)
 d00a1fc:	80c0030d 	sth	r3,12(r16)
 d00a200:	003fc306 	br	d00a110 <__srefill_r+0xa8>
 d00a204:	8809883a 	mov	r4,r17
 d00a208:	800b883a 	mov	r5,r16
 d00a20c:	d006ea00 	call	d006ea0 <_fflush_r>
 d00a210:	103fd81e 	bne	r2,zero,d00a174 <__srefill_r+0x10c>
 d00a214:	8080030b 	ldhu	r2,12(r16)
 d00a218:	80000215 	stw	zero,8(r16)
 d00a21c:	80000615 	stw	zero,24(r16)
 d00a220:	10bffdcc 	andi	r2,r2,65527
 d00a224:	8080030d 	sth	r2,12(r16)
 d00a228:	003fa206 	br	d00a0b4 <__srefill_r+0x4c>

0d00a22c <lflush>:
 d00a22c:	20c0030b 	ldhu	r3,12(r4)
 d00a230:	01400244 	movi	r5,9
 d00a234:	0005883a 	mov	r2,zero
 d00a238:	18c0024c 	andi	r3,r3,9
 d00a23c:	19400126 	beq	r3,r5,d00a244 <lflush+0x18>
 d00a240:	f800283a 	ret
 d00a244:	d00709c1 	jmpi	d00709c <fflush>

0d00a248 <__isinfd>:
 d00a248:	200d883a 	mov	r6,r4
 d00a24c:	0109c83a 	sub	r4,zero,r4
 d00a250:	2188b03a 	or	r4,r4,r6
 d00a254:	2008d7fa 	srli	r4,r4,31
 d00a258:	00a00034 	movhi	r2,32768
 d00a25c:	10bfffc4 	addi	r2,r2,-1
 d00a260:	1144703a 	and	r2,r2,r5
 d00a264:	2088b03a 	or	r4,r4,r2
 d00a268:	009ffc34 	movhi	r2,32752
 d00a26c:	1105c83a 	sub	r2,r2,r4
 d00a270:	0087c83a 	sub	r3,zero,r2
 d00a274:	10c4b03a 	or	r2,r2,r3
 d00a278:	1004d7fa 	srli	r2,r2,31
 d00a27c:	00c00044 	movi	r3,1
 d00a280:	1885c83a 	sub	r2,r3,r2
 d00a284:	f800283a 	ret

0d00a288 <__isnand>:
 d00a288:	200d883a 	mov	r6,r4
 d00a28c:	0109c83a 	sub	r4,zero,r4
 d00a290:	2188b03a 	or	r4,r4,r6
 d00a294:	2008d7fa 	srli	r4,r4,31
 d00a298:	00a00034 	movhi	r2,32768
 d00a29c:	10bfffc4 	addi	r2,r2,-1
 d00a2a0:	1144703a 	and	r2,r2,r5
 d00a2a4:	2088b03a 	or	r4,r4,r2
 d00a2a8:	009ffc34 	movhi	r2,32752
 d00a2ac:	1105c83a 	sub	r2,r2,r4
 d00a2b0:	1004d7fa 	srli	r2,r2,31
 d00a2b4:	f800283a 	ret

0d00a2b8 <_sbrk_r>:
 d00a2b8:	defffd04 	addi	sp,sp,-12
 d00a2bc:	dc000015 	stw	r16,0(sp)
 d00a2c0:	04034174 	movhi	r16,3333
 d00a2c4:	841b0104 	addi	r16,r16,27652
 d00a2c8:	dc400115 	stw	r17,4(sp)
 d00a2cc:	80000015 	stw	zero,0(r16)
 d00a2d0:	2023883a 	mov	r17,r4
 d00a2d4:	2809883a 	mov	r4,r5
 d00a2d8:	dfc00215 	stw	ra,8(sp)
 d00a2dc:	d00d6080 	call	d00d608 <sbrk>
 d00a2e0:	1007883a 	mov	r3,r2
 d00a2e4:	00bfffc4 	movi	r2,-1
 d00a2e8:	18800626 	beq	r3,r2,d00a304 <_sbrk_r+0x4c>
 d00a2ec:	1805883a 	mov	r2,r3
 d00a2f0:	dfc00217 	ldw	ra,8(sp)
 d00a2f4:	dc400117 	ldw	r17,4(sp)
 d00a2f8:	dc000017 	ldw	r16,0(sp)
 d00a2fc:	dec00304 	addi	sp,sp,12
 d00a300:	f800283a 	ret
 d00a304:	80800017 	ldw	r2,0(r16)
 d00a308:	103ff826 	beq	r2,zero,d00a2ec <_sbrk_r+0x34>
 d00a30c:	88800015 	stw	r2,0(r17)
 d00a310:	1805883a 	mov	r2,r3
 d00a314:	dfc00217 	ldw	ra,8(sp)
 d00a318:	dc400117 	ldw	r17,4(sp)
 d00a31c:	dc000017 	ldw	r16,0(sp)
 d00a320:	dec00304 	addi	sp,sp,12
 d00a324:	f800283a 	ret

0d00a328 <__sclose>:
 d00a328:	2940038f 	ldh	r5,14(r5)
 d00a32c:	d00a6701 	jmpi	d00a670 <_close_r>

0d00a330 <__sseek>:
 d00a330:	defffe04 	addi	sp,sp,-8
 d00a334:	dc000015 	stw	r16,0(sp)
 d00a338:	2821883a 	mov	r16,r5
 d00a33c:	2940038f 	ldh	r5,14(r5)
 d00a340:	dfc00115 	stw	ra,4(sp)
 d00a344:	d00a8e80 	call	d00a8e8 <_lseek_r>
 d00a348:	1007883a 	mov	r3,r2
 d00a34c:	00bfffc4 	movi	r2,-1
 d00a350:	18800926 	beq	r3,r2,d00a378 <__sseek+0x48>
 d00a354:	8080030b 	ldhu	r2,12(r16)
 d00a358:	80c01415 	stw	r3,80(r16)
 d00a35c:	10840014 	ori	r2,r2,4096
 d00a360:	8080030d 	sth	r2,12(r16)
 d00a364:	1805883a 	mov	r2,r3
 d00a368:	dfc00117 	ldw	ra,4(sp)
 d00a36c:	dc000017 	ldw	r16,0(sp)
 d00a370:	dec00204 	addi	sp,sp,8
 d00a374:	f800283a 	ret
 d00a378:	8080030b 	ldhu	r2,12(r16)
 d00a37c:	10bbffcc 	andi	r2,r2,61439
 d00a380:	8080030d 	sth	r2,12(r16)
 d00a384:	1805883a 	mov	r2,r3
 d00a388:	dfc00117 	ldw	ra,4(sp)
 d00a38c:	dc000017 	ldw	r16,0(sp)
 d00a390:	dec00204 	addi	sp,sp,8
 d00a394:	f800283a 	ret

0d00a398 <__swrite>:
 d00a398:	2880030b 	ldhu	r2,12(r5)
 d00a39c:	defffb04 	addi	sp,sp,-20
 d00a3a0:	dcc00315 	stw	r19,12(sp)
 d00a3a4:	1080400c 	andi	r2,r2,256
 d00a3a8:	dc800215 	stw	r18,8(sp)
 d00a3ac:	dc400115 	stw	r17,4(sp)
 d00a3b0:	dc000015 	stw	r16,0(sp)
 d00a3b4:	3027883a 	mov	r19,r6
 d00a3b8:	3825883a 	mov	r18,r7
 d00a3bc:	dfc00415 	stw	ra,16(sp)
 d00a3c0:	2821883a 	mov	r16,r5
 d00a3c4:	000d883a 	mov	r6,zero
 d00a3c8:	01c00084 	movi	r7,2
 d00a3cc:	2023883a 	mov	r17,r4
 d00a3d0:	10000226 	beq	r2,zero,d00a3dc <__swrite+0x44>
 d00a3d4:	2940038f 	ldh	r5,14(r5)
 d00a3d8:	d00a8e80 	call	d00a8e8 <_lseek_r>
 d00a3dc:	8080030b 	ldhu	r2,12(r16)
 d00a3e0:	8140038f 	ldh	r5,14(r16)
 d00a3e4:	8809883a 	mov	r4,r17
 d00a3e8:	10bbffcc 	andi	r2,r2,61439
 d00a3ec:	980d883a 	mov	r6,r19
 d00a3f0:	900f883a 	mov	r7,r18
 d00a3f4:	8080030d 	sth	r2,12(r16)
 d00a3f8:	dfc00417 	ldw	ra,16(sp)
 d00a3fc:	dcc00317 	ldw	r19,12(sp)
 d00a400:	dc800217 	ldw	r18,8(sp)
 d00a404:	dc400117 	ldw	r17,4(sp)
 d00a408:	dc000017 	ldw	r16,0(sp)
 d00a40c:	dec00504 	addi	sp,sp,20
 d00a410:	d00a5301 	jmpi	d00a530 <_write_r>

0d00a414 <__sread>:
 d00a414:	defffe04 	addi	sp,sp,-8
 d00a418:	dc000015 	stw	r16,0(sp)
 d00a41c:	2821883a 	mov	r16,r5
 d00a420:	2940038f 	ldh	r5,14(r5)
 d00a424:	dfc00115 	stw	ra,4(sp)
 d00a428:	d00a9600 	call	d00a960 <_read_r>
 d00a42c:	1007883a 	mov	r3,r2
 d00a430:	10000816 	blt	r2,zero,d00a454 <__sread+0x40>
 d00a434:	80801417 	ldw	r2,80(r16)
 d00a438:	10c5883a 	add	r2,r2,r3
 d00a43c:	80801415 	stw	r2,80(r16)
 d00a440:	1805883a 	mov	r2,r3
 d00a444:	dfc00117 	ldw	ra,4(sp)
 d00a448:	dc000017 	ldw	r16,0(sp)
 d00a44c:	dec00204 	addi	sp,sp,8
 d00a450:	f800283a 	ret
 d00a454:	8080030b 	ldhu	r2,12(r16)
 d00a458:	10bbffcc 	andi	r2,r2,61439
 d00a45c:	8080030d 	sth	r2,12(r16)
 d00a460:	1805883a 	mov	r2,r3
 d00a464:	dfc00117 	ldw	ra,4(sp)
 d00a468:	dc000017 	ldw	r16,0(sp)
 d00a46c:	dec00204 	addi	sp,sp,8
 d00a470:	f800283a 	ret

0d00a474 <strcmp>:
 d00a474:	2144b03a 	or	r2,r4,r5
 d00a478:	108000cc 	andi	r2,r2,3
 d00a47c:	10001d1e 	bne	r2,zero,d00a4f4 <strcmp+0x80>
 d00a480:	200f883a 	mov	r7,r4
 d00a484:	28800017 	ldw	r2,0(r5)
 d00a488:	21000017 	ldw	r4,0(r4)
 d00a48c:	280d883a 	mov	r6,r5
 d00a490:	2080161e 	bne	r4,r2,d00a4ec <strcmp+0x78>
 d00a494:	023fbff4 	movhi	r8,65279
 d00a498:	423fbfc4 	addi	r8,r8,-257
 d00a49c:	2207883a 	add	r3,r4,r8
 d00a4a0:	01602074 	movhi	r5,32897
 d00a4a4:	29602004 	addi	r5,r5,-32640
 d00a4a8:	1946703a 	and	r3,r3,r5
 d00a4ac:	0104303a 	nor	r2,zero,r4
 d00a4b0:	10c4703a 	and	r2,r2,r3
 d00a4b4:	10001c1e 	bne	r2,zero,d00a528 <strcmp+0xb4>
 d00a4b8:	4013883a 	mov	r9,r8
 d00a4bc:	2811883a 	mov	r8,r5
 d00a4c0:	00000106 	br	d00a4c8 <strcmp+0x54>
 d00a4c4:	1800181e 	bne	r3,zero,d00a528 <strcmp+0xb4>
 d00a4c8:	39c00104 	addi	r7,r7,4
 d00a4cc:	39000017 	ldw	r4,0(r7)
 d00a4d0:	31800104 	addi	r6,r6,4
 d00a4d4:	31400017 	ldw	r5,0(r6)
 d00a4d8:	2245883a 	add	r2,r4,r9
 d00a4dc:	1204703a 	and	r2,r2,r8
 d00a4e0:	0106303a 	nor	r3,zero,r4
 d00a4e4:	1886703a 	and	r3,r3,r2
 d00a4e8:	217ff626 	beq	r4,r5,d00a4c4 <strcmp+0x50>
 d00a4ec:	3809883a 	mov	r4,r7
 d00a4f0:	300b883a 	mov	r5,r6
 d00a4f4:	20c00007 	ldb	r3,0(r4)
 d00a4f8:	1800051e 	bne	r3,zero,d00a510 <strcmp+0x9c>
 d00a4fc:	00000606 	br	d00a518 <strcmp+0xa4>
 d00a500:	21000044 	addi	r4,r4,1
 d00a504:	20c00007 	ldb	r3,0(r4)
 d00a508:	29400044 	addi	r5,r5,1
 d00a50c:	18000226 	beq	r3,zero,d00a518 <strcmp+0xa4>
 d00a510:	28800007 	ldb	r2,0(r5)
 d00a514:	18bffa26 	beq	r3,r2,d00a500 <strcmp+0x8c>
 d00a518:	20c00003 	ldbu	r3,0(r4)
 d00a51c:	28800003 	ldbu	r2,0(r5)
 d00a520:	1885c83a 	sub	r2,r3,r2
 d00a524:	f800283a 	ret
 d00a528:	0005883a 	mov	r2,zero
 d00a52c:	f800283a 	ret

0d00a530 <_write_r>:
 d00a530:	defffd04 	addi	sp,sp,-12
 d00a534:	dc000015 	stw	r16,0(sp)
 d00a538:	04034174 	movhi	r16,3333
 d00a53c:	841b0104 	addi	r16,r16,27652
 d00a540:	dc400115 	stw	r17,4(sp)
 d00a544:	80000015 	stw	zero,0(r16)
 d00a548:	2023883a 	mov	r17,r4
 d00a54c:	2809883a 	mov	r4,r5
 d00a550:	300b883a 	mov	r5,r6
 d00a554:	380d883a 	mov	r6,r7
 d00a558:	dfc00215 	stw	ra,8(sp)
 d00a55c:	d01d5140 	call	d01d514 <write>
 d00a560:	1007883a 	mov	r3,r2
 d00a564:	00bfffc4 	movi	r2,-1
 d00a568:	18800626 	beq	r3,r2,d00a584 <_write_r+0x54>
 d00a56c:	1805883a 	mov	r2,r3
 d00a570:	dfc00217 	ldw	ra,8(sp)
 d00a574:	dc400117 	ldw	r17,4(sp)
 d00a578:	dc000017 	ldw	r16,0(sp)
 d00a57c:	dec00304 	addi	sp,sp,12
 d00a580:	f800283a 	ret
 d00a584:	80800017 	ldw	r2,0(r16)
 d00a588:	103ff826 	beq	r2,zero,d00a56c <_write_r+0x3c>
 d00a58c:	88800015 	stw	r2,0(r17)
 d00a590:	1805883a 	mov	r2,r3
 d00a594:	dfc00217 	ldw	ra,8(sp)
 d00a598:	dc400117 	ldw	r17,4(sp)
 d00a59c:	dc000017 	ldw	r16,0(sp)
 d00a5a0:	dec00304 	addi	sp,sp,12
 d00a5a4:	f800283a 	ret

0d00a5a8 <_calloc_r>:
 d00a5a8:	defffe04 	addi	sp,sp,-8
 d00a5ac:	dc400015 	stw	r17,0(sp)
 d00a5b0:	2023883a 	mov	r17,r4
 d00a5b4:	2809883a 	mov	r4,r5
 d00a5b8:	300b883a 	mov	r5,r6
 d00a5bc:	dfc00115 	stw	ra,4(sp)
 d00a5c0:	d00235c0 	call	d00235c <__mulsi3>
 d00a5c4:	100b883a 	mov	r5,r2
 d00a5c8:	8809883a 	mov	r4,r17
 d00a5cc:	d0081c40 	call	d0081c4 <_malloc_r>
 d00a5d0:	1023883a 	mov	r17,r2
 d00a5d4:	01c00904 	movi	r7,36
 d00a5d8:	10000d26 	beq	r2,zero,d00a610 <_calloc_r+0x68>
 d00a5dc:	10ffff17 	ldw	r3,-4(r2)
 d00a5e0:	1009883a 	mov	r4,r2
 d00a5e4:	00bfff04 	movi	r2,-4
 d00a5e8:	1886703a 	and	r3,r3,r2
 d00a5ec:	1887883a 	add	r3,r3,r2
 d00a5f0:	180d883a 	mov	r6,r3
 d00a5f4:	000b883a 	mov	r5,zero
 d00a5f8:	38c01736 	bltu	r7,r3,d00a658 <_calloc_r+0xb0>
 d00a5fc:	008004c4 	movi	r2,19
 d00a600:	10c00836 	bltu	r2,r3,d00a624 <_calloc_r+0x7c>
 d00a604:	20000215 	stw	zero,8(r4)
 d00a608:	20000015 	stw	zero,0(r4)
 d00a60c:	20000115 	stw	zero,4(r4)
 d00a610:	8805883a 	mov	r2,r17
 d00a614:	dfc00117 	ldw	ra,4(sp)
 d00a618:	dc400017 	ldw	r17,0(sp)
 d00a61c:	dec00204 	addi	sp,sp,8
 d00a620:	f800283a 	ret
 d00a624:	008006c4 	movi	r2,27
 d00a628:	88000015 	stw	zero,0(r17)
 d00a62c:	88000115 	stw	zero,4(r17)
 d00a630:	89000204 	addi	r4,r17,8
 d00a634:	10fff32e 	bgeu	r2,r3,d00a604 <_calloc_r+0x5c>
 d00a638:	88000215 	stw	zero,8(r17)
 d00a63c:	88000315 	stw	zero,12(r17)
 d00a640:	89000404 	addi	r4,r17,16
 d00a644:	19ffef1e 	bne	r3,r7,d00a604 <_calloc_r+0x5c>
 d00a648:	89000604 	addi	r4,r17,24
 d00a64c:	88000415 	stw	zero,16(r17)
 d00a650:	88000515 	stw	zero,20(r17)
 d00a654:	003feb06 	br	d00a604 <_calloc_r+0x5c>
 d00a658:	d0027880 	call	d002788 <memset>
 d00a65c:	8805883a 	mov	r2,r17
 d00a660:	dfc00117 	ldw	ra,4(sp)
 d00a664:	dc400017 	ldw	r17,0(sp)
 d00a668:	dec00204 	addi	sp,sp,8
 d00a66c:	f800283a 	ret

0d00a670 <_close_r>:
 d00a670:	defffd04 	addi	sp,sp,-12
 d00a674:	dc000015 	stw	r16,0(sp)
 d00a678:	04034174 	movhi	r16,3333
 d00a67c:	841b0104 	addi	r16,r16,27652
 d00a680:	dc400115 	stw	r17,4(sp)
 d00a684:	80000015 	stw	zero,0(r16)
 d00a688:	2023883a 	mov	r17,r4
 d00a68c:	2809883a 	mov	r4,r5
 d00a690:	dfc00215 	stw	ra,8(sp)
 d00a694:	d01d3040 	call	d01d304 <close>
 d00a698:	1007883a 	mov	r3,r2
 d00a69c:	00bfffc4 	movi	r2,-1
 d00a6a0:	18800626 	beq	r3,r2,d00a6bc <_close_r+0x4c>
 d00a6a4:	1805883a 	mov	r2,r3
 d00a6a8:	dfc00217 	ldw	ra,8(sp)
 d00a6ac:	dc400117 	ldw	r17,4(sp)
 d00a6b0:	dc000017 	ldw	r16,0(sp)
 d00a6b4:	dec00304 	addi	sp,sp,12
 d00a6b8:	f800283a 	ret
 d00a6bc:	80800017 	ldw	r2,0(r16)
 d00a6c0:	103ff826 	beq	r2,zero,d00a6a4 <_close_r+0x34>
 d00a6c4:	88800015 	stw	r2,0(r17)
 d00a6c8:	1805883a 	mov	r2,r3
 d00a6cc:	dfc00217 	ldw	ra,8(sp)
 d00a6d0:	dc400117 	ldw	r17,4(sp)
 d00a6d4:	dc000017 	ldw	r16,0(sp)
 d00a6d8:	dec00304 	addi	sp,sp,12
 d00a6dc:	f800283a 	ret

0d00a6e0 <_fclose_r>:
 d00a6e0:	defffc04 	addi	sp,sp,-16
 d00a6e4:	dc400115 	stw	r17,4(sp)
 d00a6e8:	dc000015 	stw	r16,0(sp)
 d00a6ec:	dfc00315 	stw	ra,12(sp)
 d00a6f0:	dc800215 	stw	r18,8(sp)
 d00a6f4:	2821883a 	mov	r16,r5
 d00a6f8:	2023883a 	mov	r17,r4
 d00a6fc:	28002926 	beq	r5,zero,d00a7a4 <_fclose_r+0xc4>
 d00a700:	d0071280 	call	d007128 <__sfp_lock_acquire>
 d00a704:	88000226 	beq	r17,zero,d00a710 <_fclose_r+0x30>
 d00a708:	88800e17 	ldw	r2,56(r17)
 d00a70c:	10002d26 	beq	r2,zero,d00a7c4 <_fclose_r+0xe4>
 d00a710:	8080030f 	ldh	r2,12(r16)
 d00a714:	10002226 	beq	r2,zero,d00a7a0 <_fclose_r+0xc0>
 d00a718:	8809883a 	mov	r4,r17
 d00a71c:	800b883a 	mov	r5,r16
 d00a720:	d006ea00 	call	d006ea0 <_fflush_r>
 d00a724:	1025883a 	mov	r18,r2
 d00a728:	80800b17 	ldw	r2,44(r16)
 d00a72c:	10000426 	beq	r2,zero,d00a740 <_fclose_r+0x60>
 d00a730:	81400717 	ldw	r5,28(r16)
 d00a734:	8809883a 	mov	r4,r17
 d00a738:	103ee83a 	callr	r2
 d00a73c:	10002a16 	blt	r2,zero,d00a7e8 <_fclose_r+0x108>
 d00a740:	8080030b 	ldhu	r2,12(r16)
 d00a744:	1080200c 	andi	r2,r2,128
 d00a748:	1000231e 	bne	r2,zero,d00a7d8 <_fclose_r+0xf8>
 d00a74c:	81400c17 	ldw	r5,48(r16)
 d00a750:	28000526 	beq	r5,zero,d00a768 <_fclose_r+0x88>
 d00a754:	80801004 	addi	r2,r16,64
 d00a758:	28800226 	beq	r5,r2,d00a764 <_fclose_r+0x84>
 d00a75c:	8809883a 	mov	r4,r17
 d00a760:	d00763c0 	call	d00763c <_free_r>
 d00a764:	80000c15 	stw	zero,48(r16)
 d00a768:	81401117 	ldw	r5,68(r16)
 d00a76c:	28000326 	beq	r5,zero,d00a77c <_fclose_r+0x9c>
 d00a770:	8809883a 	mov	r4,r17
 d00a774:	d00763c0 	call	d00763c <_free_r>
 d00a778:	80001115 	stw	zero,68(r16)
 d00a77c:	8000030d 	sth	zero,12(r16)
 d00a780:	d00712c0 	call	d00712c <__sfp_lock_release>
 d00a784:	9005883a 	mov	r2,r18
 d00a788:	dfc00317 	ldw	ra,12(sp)
 d00a78c:	dc800217 	ldw	r18,8(sp)
 d00a790:	dc400117 	ldw	r17,4(sp)
 d00a794:	dc000017 	ldw	r16,0(sp)
 d00a798:	dec00404 	addi	sp,sp,16
 d00a79c:	f800283a 	ret
 d00a7a0:	d00712c0 	call	d00712c <__sfp_lock_release>
 d00a7a4:	0025883a 	mov	r18,zero
 d00a7a8:	9005883a 	mov	r2,r18
 d00a7ac:	dfc00317 	ldw	ra,12(sp)
 d00a7b0:	dc800217 	ldw	r18,8(sp)
 d00a7b4:	dc400117 	ldw	r17,4(sp)
 d00a7b8:	dc000017 	ldw	r16,0(sp)
 d00a7bc:	dec00404 	addi	sp,sp,16
 d00a7c0:	f800283a 	ret
 d00a7c4:	8809883a 	mov	r4,r17
 d00a7c8:	d0071380 	call	d007138 <__sinit>
 d00a7cc:	8080030f 	ldh	r2,12(r16)
 d00a7d0:	103fd11e 	bne	r2,zero,d00a718 <_fclose_r+0x38>
 d00a7d4:	003ff206 	br	d00a7a0 <_fclose_r+0xc0>
 d00a7d8:	81400417 	ldw	r5,16(r16)
 d00a7dc:	8809883a 	mov	r4,r17
 d00a7e0:	d00763c0 	call	d00763c <_free_r>
 d00a7e4:	003fd906 	br	d00a74c <_fclose_r+0x6c>
 d00a7e8:	04bfffc4 	movi	r18,-1
 d00a7ec:	003fd406 	br	d00a740 <_fclose_r+0x60>

0d00a7f0 <fclose>:
 d00a7f0:	00834174 	movhi	r2,3333
 d00a7f4:	10922004 	addi	r2,r2,18560
 d00a7f8:	200b883a 	mov	r5,r4
 d00a7fc:	11000017 	ldw	r4,0(r2)
 d00a800:	d00a6e01 	jmpi	d00a6e0 <_fclose_r>

0d00a804 <_fstat_r>:
 d00a804:	defffd04 	addi	sp,sp,-12
 d00a808:	dc000015 	stw	r16,0(sp)
 d00a80c:	04034174 	movhi	r16,3333
 d00a810:	841b0104 	addi	r16,r16,27652
 d00a814:	dc400115 	stw	r17,4(sp)
 d00a818:	80000015 	stw	zero,0(r16)
 d00a81c:	2023883a 	mov	r17,r4
 d00a820:	2809883a 	mov	r4,r5
 d00a824:	300b883a 	mov	r5,r6
 d00a828:	dfc00215 	stw	ra,8(sp)
 d00a82c:	d00d0a40 	call	d00d0a4 <fstat>
 d00a830:	1007883a 	mov	r3,r2
 d00a834:	00bfffc4 	movi	r2,-1
 d00a838:	18800626 	beq	r3,r2,d00a854 <_fstat_r+0x50>
 d00a83c:	1805883a 	mov	r2,r3
 d00a840:	dfc00217 	ldw	ra,8(sp)
 d00a844:	dc400117 	ldw	r17,4(sp)
 d00a848:	dc000017 	ldw	r16,0(sp)
 d00a84c:	dec00304 	addi	sp,sp,12
 d00a850:	f800283a 	ret
 d00a854:	80800017 	ldw	r2,0(r16)
 d00a858:	103ff826 	beq	r2,zero,d00a83c <_fstat_r+0x38>
 d00a85c:	88800015 	stw	r2,0(r17)
 d00a860:	1805883a 	mov	r2,r3
 d00a864:	dfc00217 	ldw	ra,8(sp)
 d00a868:	dc400117 	ldw	r17,4(sp)
 d00a86c:	dc000017 	ldw	r16,0(sp)
 d00a870:	dec00304 	addi	sp,sp,12
 d00a874:	f800283a 	ret

0d00a878 <_isatty_r>:
 d00a878:	defffd04 	addi	sp,sp,-12
 d00a87c:	dc000015 	stw	r16,0(sp)
 d00a880:	04034174 	movhi	r16,3333
 d00a884:	841b0104 	addi	r16,r16,27652
 d00a888:	dc400115 	stw	r17,4(sp)
 d00a88c:	80000015 	stw	zero,0(r16)
 d00a890:	2023883a 	mov	r17,r4
 d00a894:	2809883a 	mov	r4,r5
 d00a898:	dfc00215 	stw	ra,8(sp)
 d00a89c:	d00d1dc0 	call	d00d1dc <isatty>
 d00a8a0:	1007883a 	mov	r3,r2
 d00a8a4:	00bfffc4 	movi	r2,-1
 d00a8a8:	18800626 	beq	r3,r2,d00a8c4 <_isatty_r+0x4c>
 d00a8ac:	1805883a 	mov	r2,r3
 d00a8b0:	dfc00217 	ldw	ra,8(sp)
 d00a8b4:	dc400117 	ldw	r17,4(sp)
 d00a8b8:	dc000017 	ldw	r16,0(sp)
 d00a8bc:	dec00304 	addi	sp,sp,12
 d00a8c0:	f800283a 	ret
 d00a8c4:	80800017 	ldw	r2,0(r16)
 d00a8c8:	103ff826 	beq	r2,zero,d00a8ac <_isatty_r+0x34>
 d00a8cc:	88800015 	stw	r2,0(r17)
 d00a8d0:	1805883a 	mov	r2,r3
 d00a8d4:	dfc00217 	ldw	ra,8(sp)
 d00a8d8:	dc400117 	ldw	r17,4(sp)
 d00a8dc:	dc000017 	ldw	r16,0(sp)
 d00a8e0:	dec00304 	addi	sp,sp,12
 d00a8e4:	f800283a 	ret

0d00a8e8 <_lseek_r>:
 d00a8e8:	defffd04 	addi	sp,sp,-12
 d00a8ec:	dc000015 	stw	r16,0(sp)
 d00a8f0:	04034174 	movhi	r16,3333
 d00a8f4:	841b0104 	addi	r16,r16,27652
 d00a8f8:	dc400115 	stw	r17,4(sp)
 d00a8fc:	80000015 	stw	zero,0(r16)
 d00a900:	2023883a 	mov	r17,r4
 d00a904:	2809883a 	mov	r4,r5
 d00a908:	300b883a 	mov	r5,r6
 d00a90c:	380d883a 	mov	r6,r7
 d00a910:	dfc00215 	stw	ra,8(sp)
 d00a914:	d00d3ec0 	call	d00d3ec <lseek>
 d00a918:	1007883a 	mov	r3,r2
 d00a91c:	00bfffc4 	movi	r2,-1
 d00a920:	18800626 	beq	r3,r2,d00a93c <_lseek_r+0x54>
 d00a924:	1805883a 	mov	r2,r3
 d00a928:	dfc00217 	ldw	ra,8(sp)
 d00a92c:	dc400117 	ldw	r17,4(sp)
 d00a930:	dc000017 	ldw	r16,0(sp)
 d00a934:	dec00304 	addi	sp,sp,12
 d00a938:	f800283a 	ret
 d00a93c:	80800017 	ldw	r2,0(r16)
 d00a940:	103ff826 	beq	r2,zero,d00a924 <_lseek_r+0x3c>
 d00a944:	88800015 	stw	r2,0(r17)
 d00a948:	1805883a 	mov	r2,r3
 d00a94c:	dfc00217 	ldw	ra,8(sp)
 d00a950:	dc400117 	ldw	r17,4(sp)
 d00a954:	dc000017 	ldw	r16,0(sp)
 d00a958:	dec00304 	addi	sp,sp,12
 d00a95c:	f800283a 	ret

0d00a960 <_read_r>:
 d00a960:	defffd04 	addi	sp,sp,-12
 d00a964:	dc000015 	stw	r16,0(sp)
 d00a968:	04034174 	movhi	r16,3333
 d00a96c:	841b0104 	addi	r16,r16,27652
 d00a970:	dc400115 	stw	r17,4(sp)
 d00a974:	80000015 	stw	zero,0(r16)
 d00a978:	2023883a 	mov	r17,r4
 d00a97c:	2809883a 	mov	r4,r5
 d00a980:	300b883a 	mov	r5,r6
 d00a984:	380d883a 	mov	r6,r7
 d00a988:	dfc00215 	stw	ra,8(sp)
 d00a98c:	d01d49c0 	call	d01d49c <read>
 d00a990:	1007883a 	mov	r3,r2
 d00a994:	00bfffc4 	movi	r2,-1
 d00a998:	18800626 	beq	r3,r2,d00a9b4 <_read_r+0x54>
 d00a99c:	1805883a 	mov	r2,r3
 d00a9a0:	dfc00217 	ldw	ra,8(sp)
 d00a9a4:	dc400117 	ldw	r17,4(sp)
 d00a9a8:	dc000017 	ldw	r16,0(sp)
 d00a9ac:	dec00304 	addi	sp,sp,12
 d00a9b0:	f800283a 	ret
 d00a9b4:	80800017 	ldw	r2,0(r16)
 d00a9b8:	103ff826 	beq	r2,zero,d00a99c <_read_r+0x3c>
 d00a9bc:	88800015 	stw	r2,0(r17)
 d00a9c0:	1805883a 	mov	r2,r3
 d00a9c4:	dfc00217 	ldw	ra,8(sp)
 d00a9c8:	dc400117 	ldw	r17,4(sp)
 d00a9cc:	dc000017 	ldw	r16,0(sp)
 d00a9d0:	dec00304 	addi	sp,sp,12
 d00a9d4:	f800283a 	ret

0d00a9d8 <__udivdi3>:
 d00a9d8:	defff104 	addi	sp,sp,-60
 d00a9dc:	0015883a 	mov	r10,zero
 d00a9e0:	2005883a 	mov	r2,r4
 d00a9e4:	3011883a 	mov	r8,r6
 d00a9e8:	df000d15 	stw	fp,52(sp)
 d00a9ec:	dd400a15 	stw	r21,40(sp)
 d00a9f0:	dcc00815 	stw	r19,32(sp)
 d00a9f4:	dfc00e15 	stw	ra,56(sp)
 d00a9f8:	ddc00c15 	stw	r23,48(sp)
 d00a9fc:	dd800b15 	stw	r22,44(sp)
 d00aa00:	dd000915 	stw	r20,36(sp)
 d00aa04:	dc800715 	stw	r18,28(sp)
 d00aa08:	dc400615 	stw	r17,24(sp)
 d00aa0c:	dc000515 	stw	r16,20(sp)
 d00aa10:	da800315 	stw	r10,12(sp)
 d00aa14:	4027883a 	mov	r19,r8
 d00aa18:	1039883a 	mov	fp,r2
 d00aa1c:	282b883a 	mov	r21,r5
 d00aa20:	da800415 	stw	r10,16(sp)
 d00aa24:	3800401e 	bne	r7,zero,d00ab28 <__udivdi3+0x150>
 d00aa28:	2a006536 	bltu	r5,r8,d00abc0 <__udivdi3+0x1e8>
 d00aa2c:	4000b526 	beq	r8,zero,d00ad04 <__udivdi3+0x32c>
 d00aa30:	00bfffd4 	movui	r2,65535
 d00aa34:	14c0ad36 	bltu	r2,r19,d00acec <__udivdi3+0x314>
 d00aa38:	00803fc4 	movi	r2,255
 d00aa3c:	14c15e36 	bltu	r2,r19,d00afb8 <__udivdi3+0x5e0>
 d00aa40:	000b883a 	mov	r5,zero
 d00aa44:	0005883a 	mov	r2,zero
 d00aa48:	9884d83a 	srl	r2,r19,r2
 d00aa4c:	01034174 	movhi	r4,3333
 d00aa50:	21393204 	addi	r4,r4,-6968
 d00aa54:	01800804 	movi	r6,32
 d00aa58:	1105883a 	add	r2,r2,r4
 d00aa5c:	10c00003 	ldbu	r3,0(r2)
 d00aa60:	28c7883a 	add	r3,r5,r3
 d00aa64:	30e9c83a 	sub	r20,r6,r3
 d00aa68:	a0010a1e 	bne	r20,zero,d00ae94 <__udivdi3+0x4bc>
 d00aa6c:	982ed43a 	srli	r23,r19,16
 d00aa70:	acebc83a 	sub	r21,r21,r19
 d00aa74:	9dbfffcc 	andi	r22,r19,65535
 d00aa78:	05000044 	movi	r20,1
 d00aa7c:	a809883a 	mov	r4,r21
 d00aa80:	b80b883a 	mov	r5,r23
 d00aa84:	d00c90c0 	call	d00c90c <__udivsi3>
 d00aa88:	100b883a 	mov	r5,r2
 d00aa8c:	b009883a 	mov	r4,r22
 d00aa90:	1021883a 	mov	r16,r2
 d00aa94:	d00235c0 	call	d00235c <__mulsi3>
 d00aa98:	a809883a 	mov	r4,r21
 d00aa9c:	b80b883a 	mov	r5,r23
 d00aaa0:	1023883a 	mov	r17,r2
 d00aaa4:	d00c9140 	call	d00c914 <__umodsi3>
 d00aaa8:	1004943a 	slli	r2,r2,16
 d00aaac:	e006d43a 	srli	r3,fp,16
 d00aab0:	10c4b03a 	or	r2,r2,r3
 d00aab4:	1440042e 	bgeu	r2,r17,d00aac8 <__udivdi3+0xf0>
 d00aab8:	14c5883a 	add	r2,r2,r19
 d00aabc:	843fffc4 	addi	r16,r16,-1
 d00aac0:	14c00136 	bltu	r2,r19,d00aac8 <__udivdi3+0xf0>
 d00aac4:	14415c36 	bltu	r2,r17,d00b038 <__udivdi3+0x660>
 d00aac8:	1463c83a 	sub	r17,r2,r17
 d00aacc:	8809883a 	mov	r4,r17
 d00aad0:	b80b883a 	mov	r5,r23
 d00aad4:	d00c90c0 	call	d00c90c <__udivsi3>
 d00aad8:	100b883a 	mov	r5,r2
 d00aadc:	b009883a 	mov	r4,r22
 d00aae0:	102b883a 	mov	r21,r2
 d00aae4:	d00235c0 	call	d00235c <__mulsi3>
 d00aae8:	8809883a 	mov	r4,r17
 d00aaec:	b80b883a 	mov	r5,r23
 d00aaf0:	1025883a 	mov	r18,r2
 d00aaf4:	d00c9140 	call	d00c914 <__umodsi3>
 d00aaf8:	1004943a 	slli	r2,r2,16
 d00aafc:	e0ffffcc 	andi	r3,fp,65535
 d00ab00:	10c4b03a 	or	r2,r2,r3
 d00ab04:	1480042e 	bgeu	r2,r18,d00ab18 <__udivdi3+0x140>
 d00ab08:	9885883a 	add	r2,r19,r2
 d00ab0c:	ad7fffc4 	addi	r21,r21,-1
 d00ab10:	14c00136 	bltu	r2,r19,d00ab18 <__udivdi3+0x140>
 d00ab14:	14813c36 	bltu	r2,r18,d00b008 <__udivdi3+0x630>
 d00ab18:	8004943a 	slli	r2,r16,16
 d00ab1c:	a009883a 	mov	r4,r20
 d00ab20:	a884b03a 	or	r2,r21,r2
 d00ab24:	00001506 	br	d00ab7c <__udivdi3+0x1a4>
 d00ab28:	380d883a 	mov	r6,r7
 d00ab2c:	29c06c36 	bltu	r5,r7,d00ace0 <__udivdi3+0x308>
 d00ab30:	00bfffd4 	movui	r2,65535
 d00ab34:	11c06436 	bltu	r2,r7,d00acc8 <__udivdi3+0x2f0>
 d00ab38:	00803fc4 	movi	r2,255
 d00ab3c:	11c11836 	bltu	r2,r7,d00afa0 <__udivdi3+0x5c8>
 d00ab40:	000b883a 	mov	r5,zero
 d00ab44:	0005883a 	mov	r2,zero
 d00ab48:	3084d83a 	srl	r2,r6,r2
 d00ab4c:	01034174 	movhi	r4,3333
 d00ab50:	21393204 	addi	r4,r4,-6968
 d00ab54:	01c00804 	movi	r7,32
 d00ab58:	1105883a 	add	r2,r2,r4
 d00ab5c:	10c00003 	ldbu	r3,0(r2)
 d00ab60:	28c7883a 	add	r3,r5,r3
 d00ab64:	38edc83a 	sub	r22,r7,r3
 d00ab68:	b000731e 	bne	r22,zero,d00ad38 <__udivdi3+0x360>
 d00ab6c:	35400136 	bltu	r6,r21,d00ab74 <__udivdi3+0x19c>
 d00ab70:	e4c05b36 	bltu	fp,r19,d00ace0 <__udivdi3+0x308>
 d00ab74:	00800044 	movi	r2,1
 d00ab78:	0009883a 	mov	r4,zero
 d00ab7c:	d8800315 	stw	r2,12(sp)
 d00ab80:	d9400317 	ldw	r5,12(sp)
 d00ab84:	2007883a 	mov	r3,r4
 d00ab88:	d9000415 	stw	r4,16(sp)
 d00ab8c:	2805883a 	mov	r2,r5
 d00ab90:	dfc00e17 	ldw	ra,56(sp)
 d00ab94:	df000d17 	ldw	fp,52(sp)
 d00ab98:	ddc00c17 	ldw	r23,48(sp)
 d00ab9c:	dd800b17 	ldw	r22,44(sp)
 d00aba0:	dd400a17 	ldw	r21,40(sp)
 d00aba4:	dd000917 	ldw	r20,36(sp)
 d00aba8:	dcc00817 	ldw	r19,32(sp)
 d00abac:	dc800717 	ldw	r18,28(sp)
 d00abb0:	dc400617 	ldw	r17,24(sp)
 d00abb4:	dc000517 	ldw	r16,20(sp)
 d00abb8:	dec00f04 	addi	sp,sp,60
 d00abbc:	f800283a 	ret
 d00abc0:	00bfffd4 	movui	r2,65535
 d00abc4:	12005636 	bltu	r2,r8,d00ad20 <__udivdi3+0x348>
 d00abc8:	00803fc4 	movi	r2,255
 d00abcc:	12010036 	bltu	r2,r8,d00afd0 <__udivdi3+0x5f8>
 d00abd0:	000b883a 	mov	r5,zero
 d00abd4:	0005883a 	mov	r2,zero
 d00abd8:	9884d83a 	srl	r2,r19,r2
 d00abdc:	01034174 	movhi	r4,3333
 d00abe0:	21393204 	addi	r4,r4,-6968
 d00abe4:	01800804 	movi	r6,32
 d00abe8:	1105883a 	add	r2,r2,r4
 d00abec:	10c00003 	ldbu	r3,0(r2)
 d00abf0:	28c7883a 	add	r3,r5,r3
 d00abf4:	30cbc83a 	sub	r5,r6,r3
 d00abf8:	28000626 	beq	r5,zero,d00ac14 <__udivdi3+0x23c>
 d00abfc:	3145c83a 	sub	r2,r6,r5
 d00ac00:	e084d83a 	srl	r2,fp,r2
 d00ac04:	a946983a 	sll	r3,r21,r5
 d00ac08:	e178983a 	sll	fp,fp,r5
 d00ac0c:	9966983a 	sll	r19,r19,r5
 d00ac10:	18aab03a 	or	r21,r3,r2
 d00ac14:	982ed43a 	srli	r23,r19,16
 d00ac18:	a809883a 	mov	r4,r21
 d00ac1c:	9cbfffcc 	andi	r18,r19,65535
 d00ac20:	b80b883a 	mov	r5,r23
 d00ac24:	d00c90c0 	call	d00c90c <__udivsi3>
 d00ac28:	100b883a 	mov	r5,r2
 d00ac2c:	9009883a 	mov	r4,r18
 d00ac30:	1021883a 	mov	r16,r2
 d00ac34:	d00235c0 	call	d00235c <__mulsi3>
 d00ac38:	a809883a 	mov	r4,r21
 d00ac3c:	b80b883a 	mov	r5,r23
 d00ac40:	1023883a 	mov	r17,r2
 d00ac44:	d00c9140 	call	d00c914 <__umodsi3>
 d00ac48:	1004943a 	slli	r2,r2,16
 d00ac4c:	e006d43a 	srli	r3,fp,16
 d00ac50:	10c4b03a 	or	r2,r2,r3
 d00ac54:	1440042e 	bgeu	r2,r17,d00ac68 <__udivdi3+0x290>
 d00ac58:	14c5883a 	add	r2,r2,r19
 d00ac5c:	843fffc4 	addi	r16,r16,-1
 d00ac60:	14c00136 	bltu	r2,r19,d00ac68 <__udivdi3+0x290>
 d00ac64:	1440ea36 	bltu	r2,r17,d00b010 <__udivdi3+0x638>
 d00ac68:	1463c83a 	sub	r17,r2,r17
 d00ac6c:	8809883a 	mov	r4,r17
 d00ac70:	b80b883a 	mov	r5,r23
 d00ac74:	d00c90c0 	call	d00c90c <__udivsi3>
 d00ac78:	100b883a 	mov	r5,r2
 d00ac7c:	9009883a 	mov	r4,r18
 d00ac80:	102b883a 	mov	r21,r2
 d00ac84:	d00235c0 	call	d00235c <__mulsi3>
 d00ac88:	8809883a 	mov	r4,r17
 d00ac8c:	b80b883a 	mov	r5,r23
 d00ac90:	1025883a 	mov	r18,r2
 d00ac94:	d00c9140 	call	d00c914 <__umodsi3>
 d00ac98:	1004943a 	slli	r2,r2,16
 d00ac9c:	e0ffffcc 	andi	r3,fp,65535
 d00aca0:	10c4b03a 	or	r2,r2,r3
 d00aca4:	1480042e 	bgeu	r2,r18,d00acb8 <__udivdi3+0x2e0>
 d00aca8:	9885883a 	add	r2,r19,r2
 d00acac:	ad7fffc4 	addi	r21,r21,-1
 d00acb0:	14c00136 	bltu	r2,r19,d00acb8 <__udivdi3+0x2e0>
 d00acb4:	1480d936 	bltu	r2,r18,d00b01c <__udivdi3+0x644>
 d00acb8:	8004943a 	slli	r2,r16,16
 d00acbc:	0009883a 	mov	r4,zero
 d00acc0:	a884b03a 	or	r2,r21,r2
 d00acc4:	003fad06 	br	d00ab7c <__udivdi3+0x1a4>
 d00acc8:	00804034 	movhi	r2,256
 d00accc:	10bfffc4 	addi	r2,r2,-1
 d00acd0:	11c0b636 	bltu	r2,r7,d00afac <__udivdi3+0x5d4>
 d00acd4:	01400404 	movi	r5,16
 d00acd8:	2805883a 	mov	r2,r5
 d00acdc:	003f9a06 	br	d00ab48 <__udivdi3+0x170>
 d00ace0:	0005883a 	mov	r2,zero
 d00ace4:	0009883a 	mov	r4,zero
 d00ace8:	003fa406 	br	d00ab7c <__udivdi3+0x1a4>
 d00acec:	00804034 	movhi	r2,256
 d00acf0:	10bfffc4 	addi	r2,r2,-1
 d00acf4:	14c0b336 	bltu	r2,r19,d00afc4 <__udivdi3+0x5ec>
 d00acf8:	01400404 	movi	r5,16
 d00acfc:	2805883a 	mov	r2,r5
 d00ad00:	003f5106 	br	d00aa48 <__udivdi3+0x70>
 d00ad04:	01000044 	movi	r4,1
 d00ad08:	000b883a 	mov	r5,zero
 d00ad0c:	d00c90c0 	call	d00c90c <__udivsi3>
 d00ad10:	1027883a 	mov	r19,r2
 d00ad14:	00bfffd4 	movui	r2,65535
 d00ad18:	14fff436 	bltu	r2,r19,d00acec <__udivdi3+0x314>
 d00ad1c:	003f4606 	br	d00aa38 <__udivdi3+0x60>
 d00ad20:	00804034 	movhi	r2,256
 d00ad24:	10bfffc4 	addi	r2,r2,-1
 d00ad28:	1200ac36 	bltu	r2,r8,d00afdc <__udivdi3+0x604>
 d00ad2c:	01400404 	movi	r5,16
 d00ad30:	2805883a 	mov	r2,r5
 d00ad34:	003fa806 	br	d00abd8 <__udivdi3+0x200>
 d00ad38:	3d85c83a 	sub	r2,r7,r22
 d00ad3c:	3588983a 	sll	r4,r6,r22
 d00ad40:	9886d83a 	srl	r3,r19,r2
 d00ad44:	a8a2d83a 	srl	r17,r21,r2
 d00ad48:	e084d83a 	srl	r2,fp,r2
 d00ad4c:	20eeb03a 	or	r23,r4,r3
 d00ad50:	b824d43a 	srli	r18,r23,16
 d00ad54:	ad86983a 	sll	r3,r21,r22
 d00ad58:	8809883a 	mov	r4,r17
 d00ad5c:	900b883a 	mov	r5,r18
 d00ad60:	1886b03a 	or	r3,r3,r2
 d00ad64:	d8c00115 	stw	r3,4(sp)
 d00ad68:	bc3fffcc 	andi	r16,r23,65535
 d00ad6c:	d00c90c0 	call	d00c90c <__udivsi3>
 d00ad70:	100b883a 	mov	r5,r2
 d00ad74:	8009883a 	mov	r4,r16
 d00ad78:	1029883a 	mov	r20,r2
 d00ad7c:	d00235c0 	call	d00235c <__mulsi3>
 d00ad80:	900b883a 	mov	r5,r18
 d00ad84:	8809883a 	mov	r4,r17
 d00ad88:	102b883a 	mov	r21,r2
 d00ad8c:	d00c9140 	call	d00c914 <__umodsi3>
 d00ad90:	d9400117 	ldw	r5,4(sp)
 d00ad94:	1004943a 	slli	r2,r2,16
 d00ad98:	9da6983a 	sll	r19,r19,r22
 d00ad9c:	2806d43a 	srli	r3,r5,16
 d00ada0:	10c4b03a 	or	r2,r2,r3
 d00ada4:	1540032e 	bgeu	r2,r21,d00adb4 <__udivdi3+0x3dc>
 d00ada8:	15c5883a 	add	r2,r2,r23
 d00adac:	a53fffc4 	addi	r20,r20,-1
 d00adb0:	15c0912e 	bgeu	r2,r23,d00aff8 <__udivdi3+0x620>
 d00adb4:	1563c83a 	sub	r17,r2,r21
 d00adb8:	8809883a 	mov	r4,r17
 d00adbc:	900b883a 	mov	r5,r18
 d00adc0:	d00c90c0 	call	d00c90c <__udivsi3>
 d00adc4:	100b883a 	mov	r5,r2
 d00adc8:	8009883a 	mov	r4,r16
 d00adcc:	102b883a 	mov	r21,r2
 d00add0:	d00235c0 	call	d00235c <__mulsi3>
 d00add4:	8809883a 	mov	r4,r17
 d00add8:	900b883a 	mov	r5,r18
 d00addc:	1021883a 	mov	r16,r2
 d00ade0:	d00c9140 	call	d00c914 <__umodsi3>
 d00ade4:	da800117 	ldw	r10,4(sp)
 d00ade8:	1004943a 	slli	r2,r2,16
 d00adec:	50ffffcc 	andi	r3,r10,65535
 d00adf0:	10c6b03a 	or	r3,r2,r3
 d00adf4:	1c00032e 	bgeu	r3,r16,d00ae04 <__udivdi3+0x42c>
 d00adf8:	1dc7883a 	add	r3,r3,r23
 d00adfc:	ad7fffc4 	addi	r21,r21,-1
 d00ae00:	1dc0792e 	bgeu	r3,r23,d00afe8 <__udivdi3+0x610>
 d00ae04:	a004943a 	slli	r2,r20,16
 d00ae08:	982ed43a 	srli	r23,r19,16
 d00ae0c:	9cffffcc 	andi	r19,r19,65535
 d00ae10:	a8a4b03a 	or	r18,r21,r2
 d00ae14:	947fffcc 	andi	r17,r18,65535
 d00ae18:	902ad43a 	srli	r21,r18,16
 d00ae1c:	8809883a 	mov	r4,r17
 d00ae20:	980b883a 	mov	r5,r19
 d00ae24:	1c21c83a 	sub	r16,r3,r16
 d00ae28:	d00235c0 	call	d00235c <__mulsi3>
 d00ae2c:	8809883a 	mov	r4,r17
 d00ae30:	b80b883a 	mov	r5,r23
 d00ae34:	1029883a 	mov	r20,r2
 d00ae38:	d00235c0 	call	d00235c <__mulsi3>
 d00ae3c:	980b883a 	mov	r5,r19
 d00ae40:	a809883a 	mov	r4,r21
 d00ae44:	1023883a 	mov	r17,r2
 d00ae48:	d00235c0 	call	d00235c <__mulsi3>
 d00ae4c:	a809883a 	mov	r4,r21
 d00ae50:	b80b883a 	mov	r5,r23
 d00ae54:	1027883a 	mov	r19,r2
 d00ae58:	d00235c0 	call	d00235c <__mulsi3>
 d00ae5c:	1009883a 	mov	r4,r2
 d00ae60:	a004d43a 	srli	r2,r20,16
 d00ae64:	8ce3883a 	add	r17,r17,r19
 d00ae68:	1447883a 	add	r3,r2,r17
 d00ae6c:	1cc0022e 	bgeu	r3,r19,d00ae78 <__udivdi3+0x4a0>
 d00ae70:	00800074 	movhi	r2,1
 d00ae74:	2089883a 	add	r4,r4,r2
 d00ae78:	1804d43a 	srli	r2,r3,16
 d00ae7c:	2085883a 	add	r2,r4,r2
 d00ae80:	80804436 	bltu	r16,r2,d00af94 <__udivdi3+0x5bc>
 d00ae84:	80803e26 	beq	r16,r2,d00af80 <__udivdi3+0x5a8>
 d00ae88:	9005883a 	mov	r2,r18
 d00ae8c:	0009883a 	mov	r4,zero
 d00ae90:	003f3a06 	br	d00ab7c <__udivdi3+0x1a4>
 d00ae94:	9d26983a 	sll	r19,r19,r20
 d00ae98:	3505c83a 	sub	r2,r6,r20
 d00ae9c:	a8a2d83a 	srl	r17,r21,r2
 d00aea0:	982ed43a 	srli	r23,r19,16
 d00aea4:	e084d83a 	srl	r2,fp,r2
 d00aea8:	ad06983a 	sll	r3,r21,r20
 d00aeac:	8809883a 	mov	r4,r17
 d00aeb0:	b80b883a 	mov	r5,r23
 d00aeb4:	1886b03a 	or	r3,r3,r2
 d00aeb8:	d8c00015 	stw	r3,0(sp)
 d00aebc:	9dbfffcc 	andi	r22,r19,65535
 d00aec0:	d00c90c0 	call	d00c90c <__udivsi3>
 d00aec4:	100b883a 	mov	r5,r2
 d00aec8:	b009883a 	mov	r4,r22
 d00aecc:	d8800215 	stw	r2,8(sp)
 d00aed0:	d00235c0 	call	d00235c <__mulsi3>
 d00aed4:	8809883a 	mov	r4,r17
 d00aed8:	b80b883a 	mov	r5,r23
 d00aedc:	102b883a 	mov	r21,r2
 d00aee0:	d00c9140 	call	d00c914 <__umodsi3>
 d00aee4:	d9000017 	ldw	r4,0(sp)
 d00aee8:	1004943a 	slli	r2,r2,16
 d00aeec:	2006d43a 	srli	r3,r4,16
 d00aef0:	10c4b03a 	or	r2,r2,r3
 d00aef4:	1540052e 	bgeu	r2,r21,d00af0c <__udivdi3+0x534>
 d00aef8:	d9400217 	ldw	r5,8(sp)
 d00aefc:	14c5883a 	add	r2,r2,r19
 d00af00:	297fffc4 	addi	r5,r5,-1
 d00af04:	d9400215 	stw	r5,8(sp)
 d00af08:	14c0462e 	bgeu	r2,r19,d00b024 <__udivdi3+0x64c>
 d00af0c:	1563c83a 	sub	r17,r2,r21
 d00af10:	8809883a 	mov	r4,r17
 d00af14:	b80b883a 	mov	r5,r23
 d00af18:	d00c90c0 	call	d00c90c <__udivsi3>
 d00af1c:	100b883a 	mov	r5,r2
 d00af20:	b009883a 	mov	r4,r22
 d00af24:	1025883a 	mov	r18,r2
 d00af28:	d00235c0 	call	d00235c <__mulsi3>
 d00af2c:	8809883a 	mov	r4,r17
 d00af30:	b80b883a 	mov	r5,r23
 d00af34:	1021883a 	mov	r16,r2
 d00af38:	d00c9140 	call	d00c914 <__umodsi3>
 d00af3c:	da800017 	ldw	r10,0(sp)
 d00af40:	1004943a 	slli	r2,r2,16
 d00af44:	50ffffcc 	andi	r3,r10,65535
 d00af48:	10c6b03a 	or	r3,r2,r3
 d00af4c:	1c00062e 	bgeu	r3,r16,d00af68 <__udivdi3+0x590>
 d00af50:	1cc7883a 	add	r3,r3,r19
 d00af54:	94bfffc4 	addi	r18,r18,-1
 d00af58:	1cc00336 	bltu	r3,r19,d00af68 <__udivdi3+0x590>
 d00af5c:	1c00022e 	bgeu	r3,r16,d00af68 <__udivdi3+0x590>
 d00af60:	94bfffc4 	addi	r18,r18,-1
 d00af64:	1cc7883a 	add	r3,r3,r19
 d00af68:	d9000217 	ldw	r4,8(sp)
 d00af6c:	e538983a 	sll	fp,fp,r20
 d00af70:	1c2bc83a 	sub	r21,r3,r16
 d00af74:	2004943a 	slli	r2,r4,16
 d00af78:	90a8b03a 	or	r20,r18,r2
 d00af7c:	003ebf06 	br	d00aa7c <__udivdi3+0xa4>
 d00af80:	1804943a 	slli	r2,r3,16
 d00af84:	e588983a 	sll	r4,fp,r22
 d00af88:	a0ffffcc 	andi	r3,r20,65535
 d00af8c:	10c5883a 	add	r2,r2,r3
 d00af90:	20bfbd2e 	bgeu	r4,r2,d00ae88 <__udivdi3+0x4b0>
 d00af94:	90bfffc4 	addi	r2,r18,-1
 d00af98:	0009883a 	mov	r4,zero
 d00af9c:	003ef706 	br	d00ab7c <__udivdi3+0x1a4>
 d00afa0:	01400204 	movi	r5,8
 d00afa4:	2805883a 	mov	r2,r5
 d00afa8:	003ee706 	br	d00ab48 <__udivdi3+0x170>
 d00afac:	01400604 	movi	r5,24
 d00afb0:	2805883a 	mov	r2,r5
 d00afb4:	003ee406 	br	d00ab48 <__udivdi3+0x170>
 d00afb8:	01400204 	movi	r5,8
 d00afbc:	2805883a 	mov	r2,r5
 d00afc0:	003ea106 	br	d00aa48 <__udivdi3+0x70>
 d00afc4:	01400604 	movi	r5,24
 d00afc8:	2805883a 	mov	r2,r5
 d00afcc:	003e9e06 	br	d00aa48 <__udivdi3+0x70>
 d00afd0:	01400204 	movi	r5,8
 d00afd4:	2805883a 	mov	r2,r5
 d00afd8:	003eff06 	br	d00abd8 <__udivdi3+0x200>
 d00afdc:	01400604 	movi	r5,24
 d00afe0:	2805883a 	mov	r2,r5
 d00afe4:	003efc06 	br	d00abd8 <__udivdi3+0x200>
 d00afe8:	1c3f862e 	bgeu	r3,r16,d00ae04 <__udivdi3+0x42c>
 d00afec:	1dc7883a 	add	r3,r3,r23
 d00aff0:	ad7fffc4 	addi	r21,r21,-1
 d00aff4:	003f8306 	br	d00ae04 <__udivdi3+0x42c>
 d00aff8:	157f6e2e 	bgeu	r2,r21,d00adb4 <__udivdi3+0x3dc>
 d00affc:	a53fffc4 	addi	r20,r20,-1
 d00b000:	15c5883a 	add	r2,r2,r23
 d00b004:	003f6b06 	br	d00adb4 <__udivdi3+0x3dc>
 d00b008:	ad7fffc4 	addi	r21,r21,-1
 d00b00c:	003ec206 	br	d00ab18 <__udivdi3+0x140>
 d00b010:	843fffc4 	addi	r16,r16,-1
 d00b014:	14c5883a 	add	r2,r2,r19
 d00b018:	003f1306 	br	d00ac68 <__udivdi3+0x290>
 d00b01c:	ad7fffc4 	addi	r21,r21,-1
 d00b020:	003f2506 	br	d00acb8 <__udivdi3+0x2e0>
 d00b024:	157fb92e 	bgeu	r2,r21,d00af0c <__udivdi3+0x534>
 d00b028:	297fffc4 	addi	r5,r5,-1
 d00b02c:	14c5883a 	add	r2,r2,r19
 d00b030:	d9400215 	stw	r5,8(sp)
 d00b034:	003fb506 	br	d00af0c <__udivdi3+0x534>
 d00b038:	843fffc4 	addi	r16,r16,-1
 d00b03c:	14c5883a 	add	r2,r2,r19
 d00b040:	003ea106 	br	d00aac8 <__udivdi3+0xf0>

0d00b044 <__umoddi3>:
 d00b044:	defff004 	addi	sp,sp,-64
 d00b048:	3011883a 	mov	r8,r6
 d00b04c:	000d883a 	mov	r6,zero
 d00b050:	dd400b15 	stw	r21,44(sp)
 d00b054:	dcc00915 	stw	r19,36(sp)
 d00b058:	dc000615 	stw	r16,24(sp)
 d00b05c:	dfc00f15 	stw	ra,60(sp)
 d00b060:	df000e15 	stw	fp,56(sp)
 d00b064:	ddc00d15 	stw	r23,52(sp)
 d00b068:	dd800c15 	stw	r22,48(sp)
 d00b06c:	dd000a15 	stw	r20,40(sp)
 d00b070:	dc800815 	stw	r18,32(sp)
 d00b074:	dc400715 	stw	r17,28(sp)
 d00b078:	2817883a 	mov	r11,r5
 d00b07c:	d9800415 	stw	r6,16(sp)
 d00b080:	4027883a 	mov	r19,r8
 d00b084:	d9800515 	stw	r6,20(sp)
 d00b088:	2021883a 	mov	r16,r4
 d00b08c:	282b883a 	mov	r21,r5
 d00b090:	38002c1e 	bne	r7,zero,d00b144 <__umoddi3+0x100>
 d00b094:	2a005636 	bltu	r5,r8,d00b1f0 <__umoddi3+0x1ac>
 d00b098:	40009a26 	beq	r8,zero,d00b304 <__umoddi3+0x2c0>
 d00b09c:	00bfffd4 	movui	r2,65535
 d00b0a0:	14c09236 	bltu	r2,r19,d00b2ec <__umoddi3+0x2a8>
 d00b0a4:	00803fc4 	movi	r2,255
 d00b0a8:	14c15c36 	bltu	r2,r19,d00b61c <__umoddi3+0x5d8>
 d00b0ac:	000b883a 	mov	r5,zero
 d00b0b0:	0005883a 	mov	r2,zero
 d00b0b4:	9884d83a 	srl	r2,r19,r2
 d00b0b8:	01034174 	movhi	r4,3333
 d00b0bc:	21393204 	addi	r4,r4,-6968
 d00b0c0:	01800804 	movi	r6,32
 d00b0c4:	1105883a 	add	r2,r2,r4
 d00b0c8:	10c00003 	ldbu	r3,0(r2)
 d00b0cc:	28c7883a 	add	r3,r5,r3
 d00b0d0:	30e5c83a 	sub	r18,r6,r3
 d00b0d4:	9000a41e 	bne	r18,zero,d00b368 <__umoddi3+0x324>
 d00b0d8:	982ed43a 	srli	r23,r19,16
 d00b0dc:	acebc83a 	sub	r21,r21,r19
 d00b0e0:	9d3fffcc 	andi	r20,r19,65535
 d00b0e4:	002d883a 	mov	r22,zero
 d00b0e8:	a809883a 	mov	r4,r21
 d00b0ec:	b80b883a 	mov	r5,r23
 d00b0f0:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b0f4:	100b883a 	mov	r5,r2
 d00b0f8:	a009883a 	mov	r4,r20
 d00b0fc:	d00235c0 	call	d00235c <__mulsi3>
 d00b100:	a809883a 	mov	r4,r21
 d00b104:	b80b883a 	mov	r5,r23
 d00b108:	1023883a 	mov	r17,r2
 d00b10c:	d00c9140 	call	d00c914 <__umodsi3>
 d00b110:	1004943a 	slli	r2,r2,16
 d00b114:	8006d43a 	srli	r3,r16,16
 d00b118:	10c4b03a 	or	r2,r2,r3
 d00b11c:	1440032e 	bgeu	r2,r17,d00b12c <__umoddi3+0xe8>
 d00b120:	14c5883a 	add	r2,r2,r19
 d00b124:	14c00136 	bltu	r2,r19,d00b12c <__umoddi3+0xe8>
 d00b128:	14415836 	bltu	r2,r17,d00b68c <__umoddi3+0x648>
 d00b12c:	1463c83a 	sub	r17,r2,r17
 d00b130:	8809883a 	mov	r4,r17
 d00b134:	b80b883a 	mov	r5,r23
 d00b138:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b13c:	a009883a 	mov	r4,r20
 d00b140:	00005306 	br	d00b290 <__umoddi3+0x24c>
 d00b144:	380d883a 	mov	r6,r7
 d00b148:	29c0132e 	bgeu	r5,r7,d00b198 <__umoddi3+0x154>
 d00b14c:	d9000415 	stw	r4,16(sp)
 d00b150:	d9400515 	stw	r5,20(sp)
 d00b154:	d9400417 	ldw	r5,16(sp)
 d00b158:	5813883a 	mov	r9,r11
 d00b15c:	2811883a 	mov	r8,r5
 d00b160:	4005883a 	mov	r2,r8
 d00b164:	4807883a 	mov	r3,r9
 d00b168:	dfc00f17 	ldw	ra,60(sp)
 d00b16c:	df000e17 	ldw	fp,56(sp)
 d00b170:	ddc00d17 	ldw	r23,52(sp)
 d00b174:	dd800c17 	ldw	r22,48(sp)
 d00b178:	dd400b17 	ldw	r21,44(sp)
 d00b17c:	dd000a17 	ldw	r20,40(sp)
 d00b180:	dcc00917 	ldw	r19,36(sp)
 d00b184:	dc800817 	ldw	r18,32(sp)
 d00b188:	dc400717 	ldw	r17,28(sp)
 d00b18c:	dc000617 	ldw	r16,24(sp)
 d00b190:	dec01004 	addi	sp,sp,64
 d00b194:	f800283a 	ret
 d00b198:	00bfffd4 	movui	r2,65535
 d00b19c:	11c06636 	bltu	r2,r7,d00b338 <__umoddi3+0x2f4>
 d00b1a0:	00803fc4 	movi	r2,255
 d00b1a4:	11c12036 	bltu	r2,r7,d00b628 <__umoddi3+0x5e4>
 d00b1a8:	000b883a 	mov	r5,zero
 d00b1ac:	0005883a 	mov	r2,zero
 d00b1b0:	3084d83a 	srl	r2,r6,r2
 d00b1b4:	01034174 	movhi	r4,3333
 d00b1b8:	21393204 	addi	r4,r4,-6968
 d00b1bc:	01c00804 	movi	r7,32
 d00b1c0:	1105883a 	add	r2,r2,r4
 d00b1c4:	10c00003 	ldbu	r3,0(r2)
 d00b1c8:	28c7883a 	add	r3,r5,r3
 d00b1cc:	38e5c83a 	sub	r18,r7,r3
 d00b1d0:	9000941e 	bne	r18,zero,d00b424 <__umoddi3+0x3e0>
 d00b1d4:	35405e36 	bltu	r6,r21,d00b350 <__umoddi3+0x30c>
 d00b1d8:	84c05d2e 	bgeu	r16,r19,d00b350 <__umoddi3+0x30c>
 d00b1dc:	8011883a 	mov	r8,r16
 d00b1e0:	a813883a 	mov	r9,r21
 d00b1e4:	dc000415 	stw	r16,16(sp)
 d00b1e8:	dd400515 	stw	r21,20(sp)
 d00b1ec:	003fdc06 	br	d00b160 <__umoddi3+0x11c>
 d00b1f0:	00bfffd4 	movui	r2,65535
 d00b1f4:	12004a36 	bltu	r2,r8,d00b320 <__umoddi3+0x2dc>
 d00b1f8:	00803fc4 	movi	r2,255
 d00b1fc:	12010d36 	bltu	r2,r8,d00b634 <__umoddi3+0x5f0>
 d00b200:	000b883a 	mov	r5,zero
 d00b204:	0005883a 	mov	r2,zero
 d00b208:	9884d83a 	srl	r2,r19,r2
 d00b20c:	01034174 	movhi	r4,3333
 d00b210:	21393204 	addi	r4,r4,-6968
 d00b214:	01800804 	movi	r6,32
 d00b218:	1105883a 	add	r2,r2,r4
 d00b21c:	10c00003 	ldbu	r3,0(r2)
 d00b220:	28c7883a 	add	r3,r5,r3
 d00b224:	30c7c83a 	sub	r3,r6,r3
 d00b228:	1800dc1e 	bne	r3,zero,d00b59c <__umoddi3+0x558>
 d00b22c:	002d883a 	mov	r22,zero
 d00b230:	982ed43a 	srli	r23,r19,16
 d00b234:	a809883a 	mov	r4,r21
 d00b238:	9cbfffcc 	andi	r18,r19,65535
 d00b23c:	b80b883a 	mov	r5,r23
 d00b240:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b244:	100b883a 	mov	r5,r2
 d00b248:	9009883a 	mov	r4,r18
 d00b24c:	d00235c0 	call	d00235c <__mulsi3>
 d00b250:	a809883a 	mov	r4,r21
 d00b254:	b80b883a 	mov	r5,r23
 d00b258:	1023883a 	mov	r17,r2
 d00b25c:	d00c9140 	call	d00c914 <__umodsi3>
 d00b260:	1004943a 	slli	r2,r2,16
 d00b264:	8006d43a 	srli	r3,r16,16
 d00b268:	10c4b03a 	or	r2,r2,r3
 d00b26c:	1440032e 	bgeu	r2,r17,d00b27c <__umoddi3+0x238>
 d00b270:	14c5883a 	add	r2,r2,r19
 d00b274:	14c00136 	bltu	r2,r19,d00b27c <__umoddi3+0x238>
 d00b278:	14410236 	bltu	r2,r17,d00b684 <__umoddi3+0x640>
 d00b27c:	1463c83a 	sub	r17,r2,r17
 d00b280:	8809883a 	mov	r4,r17
 d00b284:	b80b883a 	mov	r5,r23
 d00b288:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b28c:	9009883a 	mov	r4,r18
 d00b290:	100b883a 	mov	r5,r2
 d00b294:	d00235c0 	call	d00235c <__mulsi3>
 d00b298:	8809883a 	mov	r4,r17
 d00b29c:	b80b883a 	mov	r5,r23
 d00b2a0:	102b883a 	mov	r21,r2
 d00b2a4:	d00c9140 	call	d00c914 <__umodsi3>
 d00b2a8:	1004943a 	slli	r2,r2,16
 d00b2ac:	80ffffcc 	andi	r3,r16,65535
 d00b2b0:	10c4b03a 	or	r2,r2,r3
 d00b2b4:	1540042e 	bgeu	r2,r21,d00b2c8 <__umoddi3+0x284>
 d00b2b8:	14c5883a 	add	r2,r2,r19
 d00b2bc:	14c00236 	bltu	r2,r19,d00b2c8 <__umoddi3+0x284>
 d00b2c0:	1540012e 	bgeu	r2,r21,d00b2c8 <__umoddi3+0x284>
 d00b2c4:	14c5883a 	add	r2,r2,r19
 d00b2c8:	1545c83a 	sub	r2,r2,r21
 d00b2cc:	1584d83a 	srl	r2,r2,r22
 d00b2d0:	0013883a 	mov	r9,zero
 d00b2d4:	d8800415 	stw	r2,16(sp)
 d00b2d8:	d8c00417 	ldw	r3,16(sp)
 d00b2dc:	0005883a 	mov	r2,zero
 d00b2e0:	d8800515 	stw	r2,20(sp)
 d00b2e4:	1811883a 	mov	r8,r3
 d00b2e8:	003f9d06 	br	d00b160 <__umoddi3+0x11c>
 d00b2ec:	00804034 	movhi	r2,256
 d00b2f0:	10bfffc4 	addi	r2,r2,-1
 d00b2f4:	14c0c636 	bltu	r2,r19,d00b610 <__umoddi3+0x5cc>
 d00b2f8:	01400404 	movi	r5,16
 d00b2fc:	2805883a 	mov	r2,r5
 d00b300:	003f6c06 	br	d00b0b4 <__umoddi3+0x70>
 d00b304:	01000044 	movi	r4,1
 d00b308:	000b883a 	mov	r5,zero
 d00b30c:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b310:	1027883a 	mov	r19,r2
 d00b314:	00bfffd4 	movui	r2,65535
 d00b318:	14fff436 	bltu	r2,r19,d00b2ec <__umoddi3+0x2a8>
 d00b31c:	003f6106 	br	d00b0a4 <__umoddi3+0x60>
 d00b320:	00804034 	movhi	r2,256
 d00b324:	10bfffc4 	addi	r2,r2,-1
 d00b328:	1200c536 	bltu	r2,r8,d00b640 <__umoddi3+0x5fc>
 d00b32c:	01400404 	movi	r5,16
 d00b330:	2805883a 	mov	r2,r5
 d00b334:	003fb406 	br	d00b208 <__umoddi3+0x1c4>
 d00b338:	00804034 	movhi	r2,256
 d00b33c:	10bfffc4 	addi	r2,r2,-1
 d00b340:	11c0c236 	bltu	r2,r7,d00b64c <__umoddi3+0x608>
 d00b344:	01400404 	movi	r5,16
 d00b348:	2805883a 	mov	r2,r5
 d00b34c:	003f9806 	br	d00b1b0 <__umoddi3+0x16c>
 d00b350:	84c9c83a 	sub	r4,r16,r19
 d00b354:	8105803a 	cmpltu	r2,r16,r4
 d00b358:	a987c83a 	sub	r3,r21,r6
 d00b35c:	18abc83a 	sub	r21,r3,r2
 d00b360:	2021883a 	mov	r16,r4
 d00b364:	003f9d06 	br	d00b1dc <__umoddi3+0x198>
 d00b368:	9ca6983a 	sll	r19,r19,r18
 d00b36c:	3485c83a 	sub	r2,r6,r18
 d00b370:	a8a2d83a 	srl	r17,r21,r2
 d00b374:	982ed43a 	srli	r23,r19,16
 d00b378:	ac86983a 	sll	r3,r21,r18
 d00b37c:	8084d83a 	srl	r2,r16,r2
 d00b380:	8809883a 	mov	r4,r17
 d00b384:	b80b883a 	mov	r5,r23
 d00b388:	18b8b03a 	or	fp,r3,r2
 d00b38c:	9d3fffcc 	andi	r20,r19,65535
 d00b390:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b394:	100b883a 	mov	r5,r2
 d00b398:	a009883a 	mov	r4,r20
 d00b39c:	d00235c0 	call	d00235c <__mulsi3>
 d00b3a0:	8809883a 	mov	r4,r17
 d00b3a4:	b80b883a 	mov	r5,r23
 d00b3a8:	102b883a 	mov	r21,r2
 d00b3ac:	d00c9140 	call	d00c914 <__umodsi3>
 d00b3b0:	1004943a 	slli	r2,r2,16
 d00b3b4:	e006d43a 	srli	r3,fp,16
 d00b3b8:	902d883a 	mov	r22,r18
 d00b3bc:	10c4b03a 	or	r2,r2,r3
 d00b3c0:	1540022e 	bgeu	r2,r21,d00b3cc <__umoddi3+0x388>
 d00b3c4:	14c5883a 	add	r2,r2,r19
 d00b3c8:	14c0ab2e 	bgeu	r2,r19,d00b678 <__umoddi3+0x634>
 d00b3cc:	1563c83a 	sub	r17,r2,r21
 d00b3d0:	8809883a 	mov	r4,r17
 d00b3d4:	b80b883a 	mov	r5,r23
 d00b3d8:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b3dc:	100b883a 	mov	r5,r2
 d00b3e0:	a009883a 	mov	r4,r20
 d00b3e4:	d00235c0 	call	d00235c <__mulsi3>
 d00b3e8:	8809883a 	mov	r4,r17
 d00b3ec:	b80b883a 	mov	r5,r23
 d00b3f0:	102b883a 	mov	r21,r2
 d00b3f4:	d00c9140 	call	d00c914 <__umodsi3>
 d00b3f8:	1004943a 	slli	r2,r2,16
 d00b3fc:	e0ffffcc 	andi	r3,fp,65535
 d00b400:	10c4b03a 	or	r2,r2,r3
 d00b404:	1540042e 	bgeu	r2,r21,d00b418 <__umoddi3+0x3d4>
 d00b408:	14c5883a 	add	r2,r2,r19
 d00b40c:	14c00236 	bltu	r2,r19,d00b418 <__umoddi3+0x3d4>
 d00b410:	1540012e 	bgeu	r2,r21,d00b418 <__umoddi3+0x3d4>
 d00b414:	14c5883a 	add	r2,r2,r19
 d00b418:	84a0983a 	sll	r16,r16,r18
 d00b41c:	156bc83a 	sub	r21,r2,r21
 d00b420:	003f3106 	br	d00b0e8 <__umoddi3+0xa4>
 d00b424:	3c8fc83a 	sub	r7,r7,r18
 d00b428:	3486983a 	sll	r3,r6,r18
 d00b42c:	99c4d83a 	srl	r2,r19,r7
 d00b430:	a9e2d83a 	srl	r17,r21,r7
 d00b434:	ac8c983a 	sll	r6,r21,r18
 d00b438:	18acb03a 	or	r22,r3,r2
 d00b43c:	b02ed43a 	srli	r23,r22,16
 d00b440:	81c4d83a 	srl	r2,r16,r7
 d00b444:	8809883a 	mov	r4,r17
 d00b448:	b80b883a 	mov	r5,r23
 d00b44c:	308cb03a 	or	r6,r6,r2
 d00b450:	d9c00315 	stw	r7,12(sp)
 d00b454:	d9800215 	stw	r6,8(sp)
 d00b458:	b53fffcc 	andi	r20,r22,65535
 d00b45c:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b460:	100b883a 	mov	r5,r2
 d00b464:	a009883a 	mov	r4,r20
 d00b468:	1039883a 	mov	fp,r2
 d00b46c:	d00235c0 	call	d00235c <__mulsi3>
 d00b470:	8809883a 	mov	r4,r17
 d00b474:	b80b883a 	mov	r5,r23
 d00b478:	102b883a 	mov	r21,r2
 d00b47c:	d00c9140 	call	d00c914 <__umodsi3>
 d00b480:	d9000217 	ldw	r4,8(sp)
 d00b484:	1004943a 	slli	r2,r2,16
 d00b488:	9ca6983a 	sll	r19,r19,r18
 d00b48c:	2006d43a 	srli	r3,r4,16
 d00b490:	84a0983a 	sll	r16,r16,r18
 d00b494:	dcc00015 	stw	r19,0(sp)
 d00b498:	10c4b03a 	or	r2,r2,r3
 d00b49c:	dc000115 	stw	r16,4(sp)
 d00b4a0:	1540032e 	bgeu	r2,r21,d00b4b0 <__umoddi3+0x46c>
 d00b4a4:	1585883a 	add	r2,r2,r22
 d00b4a8:	e73fffc4 	addi	fp,fp,-1
 d00b4ac:	15806e2e 	bgeu	r2,r22,d00b668 <__umoddi3+0x624>
 d00b4b0:	1563c83a 	sub	r17,r2,r21
 d00b4b4:	8809883a 	mov	r4,r17
 d00b4b8:	b80b883a 	mov	r5,r23
 d00b4bc:	d00c90c0 	call	d00c90c <__udivsi3>
 d00b4c0:	100b883a 	mov	r5,r2
 d00b4c4:	a009883a 	mov	r4,r20
 d00b4c8:	1021883a 	mov	r16,r2
 d00b4cc:	d00235c0 	call	d00235c <__mulsi3>
 d00b4d0:	b80b883a 	mov	r5,r23
 d00b4d4:	8809883a 	mov	r4,r17
 d00b4d8:	1029883a 	mov	r20,r2
 d00b4dc:	d00c9140 	call	d00c914 <__umodsi3>
 d00b4e0:	d9400217 	ldw	r5,8(sp)
 d00b4e4:	1004943a 	slli	r2,r2,16
 d00b4e8:	28ffffcc 	andi	r3,r5,65535
 d00b4ec:	10c4b03a 	or	r2,r2,r3
 d00b4f0:	1500032e 	bgeu	r2,r20,d00b500 <__umoddi3+0x4bc>
 d00b4f4:	1585883a 	add	r2,r2,r22
 d00b4f8:	843fffc4 	addi	r16,r16,-1
 d00b4fc:	1580562e 	bgeu	r2,r22,d00b658 <__umoddi3+0x614>
 d00b500:	d9800017 	ldw	r6,0(sp)
 d00b504:	e022943a 	slli	r17,fp,16
 d00b508:	302ed43a 	srli	r23,r6,16
 d00b50c:	8462b03a 	or	r17,r16,r17
 d00b510:	34ffffcc 	andi	r19,r6,65535
 d00b514:	882ad43a 	srli	r21,r17,16
 d00b518:	8c7fffcc 	andi	r17,r17,65535
 d00b51c:	8809883a 	mov	r4,r17
 d00b520:	980b883a 	mov	r5,r19
 d00b524:	1521c83a 	sub	r16,r2,r20
 d00b528:	d00235c0 	call	d00235c <__mulsi3>
 d00b52c:	8809883a 	mov	r4,r17
 d00b530:	b80b883a 	mov	r5,r23
 d00b534:	1029883a 	mov	r20,r2
 d00b538:	d00235c0 	call	d00235c <__mulsi3>
 d00b53c:	980b883a 	mov	r5,r19
 d00b540:	a809883a 	mov	r4,r21
 d00b544:	1023883a 	mov	r17,r2
 d00b548:	d00235c0 	call	d00235c <__mulsi3>
 d00b54c:	a809883a 	mov	r4,r21
 d00b550:	b80b883a 	mov	r5,r23
 d00b554:	1027883a 	mov	r19,r2
 d00b558:	d00235c0 	call	d00235c <__mulsi3>
 d00b55c:	100b883a 	mov	r5,r2
 d00b560:	a004d43a 	srli	r2,r20,16
 d00b564:	8ce3883a 	add	r17,r17,r19
 d00b568:	1449883a 	add	r4,r2,r17
 d00b56c:	24c0022e 	bgeu	r4,r19,d00b578 <__umoddi3+0x534>
 d00b570:	00800074 	movhi	r2,1
 d00b574:	288b883a 	add	r5,r5,r2
 d00b578:	2004d43a 	srli	r2,r4,16
 d00b57c:	2008943a 	slli	r4,r4,16
 d00b580:	a0ffffcc 	andi	r3,r20,65535
 d00b584:	288d883a 	add	r6,r5,r2
 d00b588:	20c9883a 	add	r4,r4,r3
 d00b58c:	81800b36 	bltu	r16,r6,d00b5bc <__umoddi3+0x578>
 d00b590:	81804026 	beq	r16,r6,d00b694 <__umoddi3+0x650>
 d00b594:	818dc83a 	sub	r6,r16,r6
 d00b598:	00000f06 	br	d00b5d8 <__umoddi3+0x594>
 d00b59c:	30c5c83a 	sub	r2,r6,r3
 d00b5a0:	182d883a 	mov	r22,r3
 d00b5a4:	8084d83a 	srl	r2,r16,r2
 d00b5a8:	a8c6983a 	sll	r3,r21,r3
 d00b5ac:	9da6983a 	sll	r19,r19,r22
 d00b5b0:	85a0983a 	sll	r16,r16,r22
 d00b5b4:	18aab03a 	or	r21,r3,r2
 d00b5b8:	003f1d06 	br	d00b230 <__umoddi3+0x1ec>
 d00b5bc:	d8c00017 	ldw	r3,0(sp)
 d00b5c0:	20c5c83a 	sub	r2,r4,r3
 d00b5c4:	2089803a 	cmpltu	r4,r4,r2
 d00b5c8:	3587c83a 	sub	r3,r6,r22
 d00b5cc:	1907c83a 	sub	r3,r3,r4
 d00b5d0:	80cdc83a 	sub	r6,r16,r3
 d00b5d4:	1009883a 	mov	r4,r2
 d00b5d8:	d9400117 	ldw	r5,4(sp)
 d00b5dc:	2905c83a 	sub	r2,r5,r4
 d00b5e0:	2887803a 	cmpltu	r3,r5,r2
 d00b5e4:	30c7c83a 	sub	r3,r6,r3
 d00b5e8:	d9800317 	ldw	r6,12(sp)
 d00b5ec:	1484d83a 	srl	r2,r2,r18
 d00b5f0:	1988983a 	sll	r4,r3,r6
 d00b5f4:	1c86d83a 	srl	r3,r3,r18
 d00b5f8:	2088b03a 	or	r4,r4,r2
 d00b5fc:	2011883a 	mov	r8,r4
 d00b600:	1813883a 	mov	r9,r3
 d00b604:	d9000415 	stw	r4,16(sp)
 d00b608:	d8c00515 	stw	r3,20(sp)
 d00b60c:	003ed406 	br	d00b160 <__umoddi3+0x11c>
 d00b610:	01400604 	movi	r5,24
 d00b614:	2805883a 	mov	r2,r5
 d00b618:	003ea606 	br	d00b0b4 <__umoddi3+0x70>
 d00b61c:	01400204 	movi	r5,8
 d00b620:	2805883a 	mov	r2,r5
 d00b624:	003ea306 	br	d00b0b4 <__umoddi3+0x70>
 d00b628:	01400204 	movi	r5,8
 d00b62c:	2805883a 	mov	r2,r5
 d00b630:	003edf06 	br	d00b1b0 <__umoddi3+0x16c>
 d00b634:	01400204 	movi	r5,8
 d00b638:	2805883a 	mov	r2,r5
 d00b63c:	003ef206 	br	d00b208 <__umoddi3+0x1c4>
 d00b640:	01400604 	movi	r5,24
 d00b644:	2805883a 	mov	r2,r5
 d00b648:	003eef06 	br	d00b208 <__umoddi3+0x1c4>
 d00b64c:	01400604 	movi	r5,24
 d00b650:	2805883a 	mov	r2,r5
 d00b654:	003ed606 	br	d00b1b0 <__umoddi3+0x16c>
 d00b658:	153fa92e 	bgeu	r2,r20,d00b500 <__umoddi3+0x4bc>
 d00b65c:	843fffc4 	addi	r16,r16,-1
 d00b660:	1585883a 	add	r2,r2,r22
 d00b664:	003fa606 	br	d00b500 <__umoddi3+0x4bc>
 d00b668:	157f912e 	bgeu	r2,r21,d00b4b0 <__umoddi3+0x46c>
 d00b66c:	e73fffc4 	addi	fp,fp,-1
 d00b670:	1585883a 	add	r2,r2,r22
 d00b674:	003f8e06 	br	d00b4b0 <__umoddi3+0x46c>
 d00b678:	157f542e 	bgeu	r2,r21,d00b3cc <__umoddi3+0x388>
 d00b67c:	14c5883a 	add	r2,r2,r19
 d00b680:	003f5206 	br	d00b3cc <__umoddi3+0x388>
 d00b684:	14c5883a 	add	r2,r2,r19
 d00b688:	003efc06 	br	d00b27c <__umoddi3+0x238>
 d00b68c:	14c5883a 	add	r2,r2,r19
 d00b690:	003ea606 	br	d00b12c <__umoddi3+0xe8>
 d00b694:	d8800117 	ldw	r2,4(sp)
 d00b698:	113fc836 	bltu	r2,r4,d00b5bc <__umoddi3+0x578>
 d00b69c:	000d883a 	mov	r6,zero
 d00b6a0:	003fcd06 	br	d00b5d8 <__umoddi3+0x594>

0d00b6a4 <_fpadd_parts>:
 d00b6a4:	defff804 	addi	sp,sp,-32
 d00b6a8:	dcc00315 	stw	r19,12(sp)
 d00b6ac:	2027883a 	mov	r19,r4
 d00b6b0:	21000017 	ldw	r4,0(r4)
 d00b6b4:	00c00044 	movi	r3,1
 d00b6b8:	dd400515 	stw	r21,20(sp)
 d00b6bc:	dd000415 	stw	r20,16(sp)
 d00b6c0:	ddc00715 	stw	r23,28(sp)
 d00b6c4:	dd800615 	stw	r22,24(sp)
 d00b6c8:	dc800215 	stw	r18,8(sp)
 d00b6cc:	dc400115 	stw	r17,4(sp)
 d00b6d0:	dc000015 	stw	r16,0(sp)
 d00b6d4:	282b883a 	mov	r21,r5
 d00b6d8:	3029883a 	mov	r20,r6
 d00b6dc:	1900632e 	bgeu	r3,r4,d00b86c <_fpadd_parts+0x1c8>
 d00b6e0:	28800017 	ldw	r2,0(r5)
 d00b6e4:	1880812e 	bgeu	r3,r2,d00b8ec <_fpadd_parts+0x248>
 d00b6e8:	00c00104 	movi	r3,4
 d00b6ec:	20c0dc26 	beq	r4,r3,d00ba60 <_fpadd_parts+0x3bc>
 d00b6f0:	10c07e26 	beq	r2,r3,d00b8ec <_fpadd_parts+0x248>
 d00b6f4:	00c00084 	movi	r3,2
 d00b6f8:	10c06726 	beq	r2,r3,d00b898 <_fpadd_parts+0x1f4>
 d00b6fc:	20c07b26 	beq	r4,r3,d00b8ec <_fpadd_parts+0x248>
 d00b700:	9dc00217 	ldw	r23,8(r19)
 d00b704:	28c00217 	ldw	r3,8(r5)
 d00b708:	9c400317 	ldw	r17,12(r19)
 d00b70c:	2bc00317 	ldw	r15,12(r5)
 d00b710:	b8cdc83a 	sub	r6,r23,r3
 d00b714:	9c800417 	ldw	r18,16(r19)
 d00b718:	2c000417 	ldw	r16,16(r5)
 d00b71c:	3009883a 	mov	r4,r6
 d00b720:	30009716 	blt	r6,zero,d00b980 <_fpadd_parts+0x2dc>
 d00b724:	00800fc4 	movi	r2,63
 d00b728:	11806b16 	blt	r2,r6,d00b8d8 <_fpadd_parts+0x234>
 d00b72c:	0100a40e 	bge	zero,r4,d00b9c0 <_fpadd_parts+0x31c>
 d00b730:	35bff804 	addi	r22,r6,-32
 d00b734:	b000bc16 	blt	r22,zero,d00ba28 <_fpadd_parts+0x384>
 d00b738:	8596d83a 	srl	r11,r16,r22
 d00b73c:	0019883a 	mov	r12,zero
 d00b740:	0013883a 	mov	r9,zero
 d00b744:	01000044 	movi	r4,1
 d00b748:	0015883a 	mov	r10,zero
 d00b74c:	b000be16 	blt	r22,zero,d00ba48 <_fpadd_parts+0x3a4>
 d00b750:	2590983a 	sll	r8,r4,r22
 d00b754:	000f883a 	mov	r7,zero
 d00b758:	00bfffc4 	movi	r2,-1
 d00b75c:	3889883a 	add	r4,r7,r2
 d00b760:	408b883a 	add	r5,r8,r2
 d00b764:	21cd803a 	cmpltu	r6,r4,r7
 d00b768:	314b883a 	add	r5,r6,r5
 d00b76c:	7904703a 	and	r2,r15,r4
 d00b770:	8146703a 	and	r3,r16,r5
 d00b774:	10c4b03a 	or	r2,r2,r3
 d00b778:	10000226 	beq	r2,zero,d00b784 <_fpadd_parts+0xe0>
 d00b77c:	02400044 	movi	r9,1
 d00b780:	0015883a 	mov	r10,zero
 d00b784:	5a5eb03a 	or	r15,r11,r9
 d00b788:	62a0b03a 	or	r16,r12,r10
 d00b78c:	99400117 	ldw	r5,4(r19)
 d00b790:	a8800117 	ldw	r2,4(r21)
 d00b794:	28806e26 	beq	r5,r2,d00b950 <_fpadd_parts+0x2ac>
 d00b798:	28006626 	beq	r5,zero,d00b934 <_fpadd_parts+0x290>
 d00b79c:	7c45c83a 	sub	r2,r15,r17
 d00b7a0:	7889803a 	cmpltu	r4,r15,r2
 d00b7a4:	8487c83a 	sub	r3,r16,r18
 d00b7a8:	1909c83a 	sub	r4,r3,r4
 d00b7ac:	100d883a 	mov	r6,r2
 d00b7b0:	200f883a 	mov	r7,r4
 d00b7b4:	38007716 	blt	r7,zero,d00b994 <_fpadd_parts+0x2f0>
 d00b7b8:	a5c00215 	stw	r23,8(r20)
 d00b7bc:	a1c00415 	stw	r7,16(r20)
 d00b7c0:	a0000115 	stw	zero,4(r20)
 d00b7c4:	a1800315 	stw	r6,12(r20)
 d00b7c8:	a2000317 	ldw	r8,12(r20)
 d00b7cc:	a2400417 	ldw	r9,16(r20)
 d00b7d0:	00bfffc4 	movi	r2,-1
 d00b7d4:	408b883a 	add	r5,r8,r2
 d00b7d8:	2a09803a 	cmpltu	r4,r5,r8
 d00b7dc:	488d883a 	add	r6,r9,r2
 d00b7e0:	01c40034 	movhi	r7,4096
 d00b7e4:	39ffffc4 	addi	r7,r7,-1
 d00b7e8:	218d883a 	add	r6,r4,r6
 d00b7ec:	39801736 	bltu	r7,r6,d00b84c <_fpadd_parts+0x1a8>
 d00b7f0:	31c06526 	beq	r6,r7,d00b988 <_fpadd_parts+0x2e4>
 d00b7f4:	a3000217 	ldw	r12,8(r20)
 d00b7f8:	4209883a 	add	r4,r8,r8
 d00b7fc:	00bfffc4 	movi	r2,-1
 d00b800:	220f803a 	cmpltu	r7,r4,r8
 d00b804:	4a4b883a 	add	r5,r9,r9
 d00b808:	394f883a 	add	r7,r7,r5
 d00b80c:	2095883a 	add	r10,r4,r2
 d00b810:	3897883a 	add	r11,r7,r2
 d00b814:	510d803a 	cmpltu	r6,r10,r4
 d00b818:	6099883a 	add	r12,r12,r2
 d00b81c:	32d7883a 	add	r11,r6,r11
 d00b820:	00840034 	movhi	r2,4096
 d00b824:	10bfffc4 	addi	r2,r2,-1
 d00b828:	2011883a 	mov	r8,r4
 d00b82c:	3813883a 	mov	r9,r7
 d00b830:	a1000315 	stw	r4,12(r20)
 d00b834:	a1c00415 	stw	r7,16(r20)
 d00b838:	a3000215 	stw	r12,8(r20)
 d00b83c:	12c00336 	bltu	r2,r11,d00b84c <_fpadd_parts+0x1a8>
 d00b840:	58bfed1e 	bne	r11,r2,d00b7f8 <_fpadd_parts+0x154>
 d00b844:	00bfff84 	movi	r2,-2
 d00b848:	12bfeb2e 	bgeu	r2,r10,d00b7f8 <_fpadd_parts+0x154>
 d00b84c:	a2800417 	ldw	r10,16(r20)
 d00b850:	008000c4 	movi	r2,3
 d00b854:	00c80034 	movhi	r3,8192
 d00b858:	18ffffc4 	addi	r3,r3,-1
 d00b85c:	a2400317 	ldw	r9,12(r20)
 d00b860:	a0800015 	stw	r2,0(r20)
 d00b864:	1a802336 	bltu	r3,r10,d00b8f4 <_fpadd_parts+0x250>
 d00b868:	a027883a 	mov	r19,r20
 d00b86c:	9805883a 	mov	r2,r19
 d00b870:	ddc00717 	ldw	r23,28(sp)
 d00b874:	dd800617 	ldw	r22,24(sp)
 d00b878:	dd400517 	ldw	r21,20(sp)
 d00b87c:	dd000417 	ldw	r20,16(sp)
 d00b880:	dcc00317 	ldw	r19,12(sp)
 d00b884:	dc800217 	ldw	r18,8(sp)
 d00b888:	dc400117 	ldw	r17,4(sp)
 d00b88c:	dc000017 	ldw	r16,0(sp)
 d00b890:	dec00804 	addi	sp,sp,32
 d00b894:	f800283a 	ret
 d00b898:	20fff41e 	bne	r4,r3,d00b86c <_fpadd_parts+0x1c8>
 d00b89c:	31000015 	stw	r4,0(r6)
 d00b8a0:	98800117 	ldw	r2,4(r19)
 d00b8a4:	30800115 	stw	r2,4(r6)
 d00b8a8:	98c00217 	ldw	r3,8(r19)
 d00b8ac:	30c00215 	stw	r3,8(r6)
 d00b8b0:	98800317 	ldw	r2,12(r19)
 d00b8b4:	30800315 	stw	r2,12(r6)
 d00b8b8:	98c00417 	ldw	r3,16(r19)
 d00b8bc:	30c00415 	stw	r3,16(r6)
 d00b8c0:	98800117 	ldw	r2,4(r19)
 d00b8c4:	28c00117 	ldw	r3,4(r5)
 d00b8c8:	3027883a 	mov	r19,r6
 d00b8cc:	10c4703a 	and	r2,r2,r3
 d00b8d0:	30800115 	stw	r2,4(r6)
 d00b8d4:	003fe506 	br	d00b86c <_fpadd_parts+0x1c8>
 d00b8d8:	1dc02616 	blt	r3,r23,d00b974 <_fpadd_parts+0x2d0>
 d00b8dc:	0023883a 	mov	r17,zero
 d00b8e0:	182f883a 	mov	r23,r3
 d00b8e4:	0025883a 	mov	r18,zero
 d00b8e8:	003fa806 	br	d00b78c <_fpadd_parts+0xe8>
 d00b8ec:	a827883a 	mov	r19,r21
 d00b8f0:	003fde06 	br	d00b86c <_fpadd_parts+0x1c8>
 d00b8f4:	01800044 	movi	r6,1
 d00b8f8:	500497fa 	slli	r2,r10,31
 d00b8fc:	4808d07a 	srli	r4,r9,1
 d00b900:	518ad83a 	srl	r5,r10,r6
 d00b904:	a2000217 	ldw	r8,8(r20)
 d00b908:	1108b03a 	or	r4,r2,r4
 d00b90c:	0007883a 	mov	r3,zero
 d00b910:	4984703a 	and	r2,r9,r6
 d00b914:	208cb03a 	or	r6,r4,r2
 d00b918:	28ceb03a 	or	r7,r5,r3
 d00b91c:	42000044 	addi	r8,r8,1
 d00b920:	a027883a 	mov	r19,r20
 d00b924:	a1c00415 	stw	r7,16(r20)
 d00b928:	a2000215 	stw	r8,8(r20)
 d00b92c:	a1800315 	stw	r6,12(r20)
 d00b930:	003fce06 	br	d00b86c <_fpadd_parts+0x1c8>
 d00b934:	8bc5c83a 	sub	r2,r17,r15
 d00b938:	8889803a 	cmpltu	r4,r17,r2
 d00b93c:	9407c83a 	sub	r3,r18,r16
 d00b940:	1909c83a 	sub	r4,r3,r4
 d00b944:	100d883a 	mov	r6,r2
 d00b948:	200f883a 	mov	r7,r4
 d00b94c:	003f9906 	br	d00b7b4 <_fpadd_parts+0x110>
 d00b950:	7c45883a 	add	r2,r15,r17
 d00b954:	13c9803a 	cmpltu	r4,r2,r15
 d00b958:	8487883a 	add	r3,r16,r18
 d00b95c:	20c9883a 	add	r4,r4,r3
 d00b960:	a1400115 	stw	r5,4(r20)
 d00b964:	a5c00215 	stw	r23,8(r20)
 d00b968:	a0800315 	stw	r2,12(r20)
 d00b96c:	a1000415 	stw	r4,16(r20)
 d00b970:	003fb606 	br	d00b84c <_fpadd_parts+0x1a8>
 d00b974:	001f883a 	mov	r15,zero
 d00b978:	0021883a 	mov	r16,zero
 d00b97c:	003f8306 	br	d00b78c <_fpadd_parts+0xe8>
 d00b980:	018dc83a 	sub	r6,zero,r6
 d00b984:	003f6706 	br	d00b724 <_fpadd_parts+0x80>
 d00b988:	00bfff84 	movi	r2,-2
 d00b98c:	117faf36 	bltu	r2,r5,d00b84c <_fpadd_parts+0x1a8>
 d00b990:	003f9806 	br	d00b7f4 <_fpadd_parts+0x150>
 d00b994:	0005883a 	mov	r2,zero
 d00b998:	1189c83a 	sub	r4,r2,r6
 d00b99c:	1105803a 	cmpltu	r2,r2,r4
 d00b9a0:	01cbc83a 	sub	r5,zero,r7
 d00b9a4:	2885c83a 	sub	r2,r5,r2
 d00b9a8:	01800044 	movi	r6,1
 d00b9ac:	a1800115 	stw	r6,4(r20)
 d00b9b0:	a5c00215 	stw	r23,8(r20)
 d00b9b4:	a1000315 	stw	r4,12(r20)
 d00b9b8:	a0800415 	stw	r2,16(r20)
 d00b9bc:	003f8206 	br	d00b7c8 <_fpadd_parts+0x124>
 d00b9c0:	203f7226 	beq	r4,zero,d00b78c <_fpadd_parts+0xe8>
 d00b9c4:	35bff804 	addi	r22,r6,-32
 d00b9c8:	b9af883a 	add	r23,r23,r6
 d00b9cc:	b0003116 	blt	r22,zero,d00ba94 <_fpadd_parts+0x3f0>
 d00b9d0:	959ad83a 	srl	r13,r18,r22
 d00b9d4:	001d883a 	mov	r14,zero
 d00b9d8:	000f883a 	mov	r7,zero
 d00b9dc:	01000044 	movi	r4,1
 d00b9e0:	0011883a 	mov	r8,zero
 d00b9e4:	b0002516 	blt	r22,zero,d00ba7c <_fpadd_parts+0x3d8>
 d00b9e8:	2594983a 	sll	r10,r4,r22
 d00b9ec:	0013883a 	mov	r9,zero
 d00b9f0:	00bfffc4 	movi	r2,-1
 d00b9f4:	4889883a 	add	r4,r9,r2
 d00b9f8:	508b883a 	add	r5,r10,r2
 d00b9fc:	224d803a 	cmpltu	r6,r4,r9
 d00ba00:	314b883a 	add	r5,r6,r5
 d00ba04:	8904703a 	and	r2,r17,r4
 d00ba08:	9146703a 	and	r3,r18,r5
 d00ba0c:	10c4b03a 	or	r2,r2,r3
 d00ba10:	10000226 	beq	r2,zero,d00ba1c <_fpadd_parts+0x378>
 d00ba14:	01c00044 	movi	r7,1
 d00ba18:	0011883a 	mov	r8,zero
 d00ba1c:	69e2b03a 	or	r17,r13,r7
 d00ba20:	7224b03a 	or	r18,r14,r8
 d00ba24:	003f5906 	br	d00b78c <_fpadd_parts+0xe8>
 d00ba28:	8407883a 	add	r3,r16,r16
 d00ba2c:	008007c4 	movi	r2,31
 d00ba30:	1185c83a 	sub	r2,r2,r6
 d00ba34:	1886983a 	sll	r3,r3,r2
 d00ba38:	7996d83a 	srl	r11,r15,r6
 d00ba3c:	8198d83a 	srl	r12,r16,r6
 d00ba40:	1ad6b03a 	or	r11,r3,r11
 d00ba44:	003f3e06 	br	d00b740 <_fpadd_parts+0x9c>
 d00ba48:	2006d07a 	srli	r3,r4,1
 d00ba4c:	008007c4 	movi	r2,31
 d00ba50:	1185c83a 	sub	r2,r2,r6
 d00ba54:	1890d83a 	srl	r8,r3,r2
 d00ba58:	218e983a 	sll	r7,r4,r6
 d00ba5c:	003f3e06 	br	d00b758 <_fpadd_parts+0xb4>
 d00ba60:	113f821e 	bne	r2,r4,d00b86c <_fpadd_parts+0x1c8>
 d00ba64:	28c00117 	ldw	r3,4(r5)
 d00ba68:	98800117 	ldw	r2,4(r19)
 d00ba6c:	10ff7f26 	beq	r2,r3,d00b86c <_fpadd_parts+0x1c8>
 d00ba70:	04c34174 	movhi	r19,3333
 d00ba74:	9cf92d04 	addi	r19,r19,-6988
 d00ba78:	003f7c06 	br	d00b86c <_fpadd_parts+0x1c8>
 d00ba7c:	2006d07a 	srli	r3,r4,1
 d00ba80:	008007c4 	movi	r2,31
 d00ba84:	1185c83a 	sub	r2,r2,r6
 d00ba88:	1894d83a 	srl	r10,r3,r2
 d00ba8c:	2192983a 	sll	r9,r4,r6
 d00ba90:	003fd706 	br	d00b9f0 <_fpadd_parts+0x34c>
 d00ba94:	9487883a 	add	r3,r18,r18
 d00ba98:	008007c4 	movi	r2,31
 d00ba9c:	1185c83a 	sub	r2,r2,r6
 d00baa0:	1886983a 	sll	r3,r3,r2
 d00baa4:	899ad83a 	srl	r13,r17,r6
 d00baa8:	919cd83a 	srl	r14,r18,r6
 d00baac:	1b5ab03a 	or	r13,r3,r13
 d00bab0:	003fc906 	br	d00b9d8 <_fpadd_parts+0x334>

0d00bab4 <__subdf3>:
 d00bab4:	deffea04 	addi	sp,sp,-88
 d00bab8:	dcc01415 	stw	r19,80(sp)
 d00babc:	dcc00404 	addi	r19,sp,16
 d00bac0:	2011883a 	mov	r8,r4
 d00bac4:	2813883a 	mov	r9,r5
 d00bac8:	dc401315 	stw	r17,76(sp)
 d00bacc:	d809883a 	mov	r4,sp
 d00bad0:	980b883a 	mov	r5,r19
 d00bad4:	dc400904 	addi	r17,sp,36
 d00bad8:	dfc01515 	stw	ra,84(sp)
 d00badc:	da400115 	stw	r9,4(sp)
 d00bae0:	d9c00315 	stw	r7,12(sp)
 d00bae4:	da000015 	stw	r8,0(sp)
 d00bae8:	d9800215 	stw	r6,8(sp)
 d00baec:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00baf0:	d9000204 	addi	r4,sp,8
 d00baf4:	880b883a 	mov	r5,r17
 d00baf8:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00bafc:	d8800a17 	ldw	r2,40(sp)
 d00bb00:	880b883a 	mov	r5,r17
 d00bb04:	9809883a 	mov	r4,r19
 d00bb08:	d9800e04 	addi	r6,sp,56
 d00bb0c:	1080005c 	xori	r2,r2,1
 d00bb10:	d8800a15 	stw	r2,40(sp)
 d00bb14:	d00b6a40 	call	d00b6a4 <_fpadd_parts>
 d00bb18:	1009883a 	mov	r4,r2
 d00bb1c:	d00cac00 	call	d00cac0 <__pack_d>
 d00bb20:	dfc01517 	ldw	ra,84(sp)
 d00bb24:	dcc01417 	ldw	r19,80(sp)
 d00bb28:	dc401317 	ldw	r17,76(sp)
 d00bb2c:	dec01604 	addi	sp,sp,88
 d00bb30:	f800283a 	ret

0d00bb34 <__adddf3>:
 d00bb34:	deffea04 	addi	sp,sp,-88
 d00bb38:	dcc01415 	stw	r19,80(sp)
 d00bb3c:	dcc00404 	addi	r19,sp,16
 d00bb40:	2011883a 	mov	r8,r4
 d00bb44:	2813883a 	mov	r9,r5
 d00bb48:	dc401315 	stw	r17,76(sp)
 d00bb4c:	d809883a 	mov	r4,sp
 d00bb50:	980b883a 	mov	r5,r19
 d00bb54:	dc400904 	addi	r17,sp,36
 d00bb58:	dfc01515 	stw	ra,84(sp)
 d00bb5c:	da400115 	stw	r9,4(sp)
 d00bb60:	d9c00315 	stw	r7,12(sp)
 d00bb64:	da000015 	stw	r8,0(sp)
 d00bb68:	d9800215 	stw	r6,8(sp)
 d00bb6c:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00bb70:	d9000204 	addi	r4,sp,8
 d00bb74:	880b883a 	mov	r5,r17
 d00bb78:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00bb7c:	d9800e04 	addi	r6,sp,56
 d00bb80:	9809883a 	mov	r4,r19
 d00bb84:	880b883a 	mov	r5,r17
 d00bb88:	d00b6a40 	call	d00b6a4 <_fpadd_parts>
 d00bb8c:	1009883a 	mov	r4,r2
 d00bb90:	d00cac00 	call	d00cac0 <__pack_d>
 d00bb94:	dfc01517 	ldw	ra,84(sp)
 d00bb98:	dcc01417 	ldw	r19,80(sp)
 d00bb9c:	dc401317 	ldw	r17,76(sp)
 d00bba0:	dec01604 	addi	sp,sp,88
 d00bba4:	f800283a 	ret

0d00bba8 <__muldf3>:
 d00bba8:	deffe004 	addi	sp,sp,-128
 d00bbac:	dc401815 	stw	r17,96(sp)
 d00bbb0:	dc400404 	addi	r17,sp,16
 d00bbb4:	2011883a 	mov	r8,r4
 d00bbb8:	2813883a 	mov	r9,r5
 d00bbbc:	dc001715 	stw	r16,92(sp)
 d00bbc0:	d809883a 	mov	r4,sp
 d00bbc4:	880b883a 	mov	r5,r17
 d00bbc8:	dc000904 	addi	r16,sp,36
 d00bbcc:	dfc01f15 	stw	ra,124(sp)
 d00bbd0:	da400115 	stw	r9,4(sp)
 d00bbd4:	d9c00315 	stw	r7,12(sp)
 d00bbd8:	da000015 	stw	r8,0(sp)
 d00bbdc:	d9800215 	stw	r6,8(sp)
 d00bbe0:	ddc01e15 	stw	r23,120(sp)
 d00bbe4:	dd801d15 	stw	r22,116(sp)
 d00bbe8:	dd401c15 	stw	r21,112(sp)
 d00bbec:	dd001b15 	stw	r20,108(sp)
 d00bbf0:	dcc01a15 	stw	r19,104(sp)
 d00bbf4:	dc801915 	stw	r18,100(sp)
 d00bbf8:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00bbfc:	d9000204 	addi	r4,sp,8
 d00bc00:	800b883a 	mov	r5,r16
 d00bc04:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00bc08:	d9000417 	ldw	r4,16(sp)
 d00bc0c:	00800044 	movi	r2,1
 d00bc10:	1100102e 	bgeu	r2,r4,d00bc54 <__muldf3+0xac>
 d00bc14:	d8c00917 	ldw	r3,36(sp)
 d00bc18:	10c0062e 	bgeu	r2,r3,d00bc34 <__muldf3+0x8c>
 d00bc1c:	00800104 	movi	r2,4
 d00bc20:	20800a26 	beq	r4,r2,d00bc4c <__muldf3+0xa4>
 d00bc24:	1880cc26 	beq	r3,r2,d00bf58 <__muldf3+0x3b0>
 d00bc28:	00800084 	movi	r2,2
 d00bc2c:	20800926 	beq	r4,r2,d00bc54 <__muldf3+0xac>
 d00bc30:	1880191e 	bne	r3,r2,d00bc98 <__muldf3+0xf0>
 d00bc34:	d8c00a17 	ldw	r3,40(sp)
 d00bc38:	d8800517 	ldw	r2,20(sp)
 d00bc3c:	8009883a 	mov	r4,r16
 d00bc40:	10c4c03a 	cmpne	r2,r2,r3
 d00bc44:	d8800a15 	stw	r2,40(sp)
 d00bc48:	00000706 	br	d00bc68 <__muldf3+0xc0>
 d00bc4c:	00800084 	movi	r2,2
 d00bc50:	1880c326 	beq	r3,r2,d00bf60 <__muldf3+0x3b8>
 d00bc54:	d8800517 	ldw	r2,20(sp)
 d00bc58:	d8c00a17 	ldw	r3,40(sp)
 d00bc5c:	8809883a 	mov	r4,r17
 d00bc60:	10c4c03a 	cmpne	r2,r2,r3
 d00bc64:	d8800515 	stw	r2,20(sp)
 d00bc68:	d00cac00 	call	d00cac0 <__pack_d>
 d00bc6c:	dfc01f17 	ldw	ra,124(sp)
 d00bc70:	ddc01e17 	ldw	r23,120(sp)
 d00bc74:	dd801d17 	ldw	r22,116(sp)
 d00bc78:	dd401c17 	ldw	r21,112(sp)
 d00bc7c:	dd001b17 	ldw	r20,108(sp)
 d00bc80:	dcc01a17 	ldw	r19,104(sp)
 d00bc84:	dc801917 	ldw	r18,100(sp)
 d00bc88:	dc401817 	ldw	r17,96(sp)
 d00bc8c:	dc001717 	ldw	r16,92(sp)
 d00bc90:	dec02004 	addi	sp,sp,128
 d00bc94:	f800283a 	ret
 d00bc98:	dd800717 	ldw	r22,28(sp)
 d00bc9c:	dc800c17 	ldw	r18,48(sp)
 d00bca0:	002b883a 	mov	r21,zero
 d00bca4:	0023883a 	mov	r17,zero
 d00bca8:	a80b883a 	mov	r5,r21
 d00bcac:	b00d883a 	mov	r6,r22
 d00bcb0:	880f883a 	mov	r7,r17
 d00bcb4:	ddc00817 	ldw	r23,32(sp)
 d00bcb8:	dcc00d17 	ldw	r19,52(sp)
 d00bcbc:	9009883a 	mov	r4,r18
 d00bcc0:	d00c91c0 	call	d00c91c <__muldi3>
 d00bcc4:	001b883a 	mov	r13,zero
 d00bcc8:	680f883a 	mov	r7,r13
 d00bccc:	b009883a 	mov	r4,r22
 d00bcd0:	000b883a 	mov	r5,zero
 d00bcd4:	980d883a 	mov	r6,r19
 d00bcd8:	b82d883a 	mov	r22,r23
 d00bcdc:	002f883a 	mov	r23,zero
 d00bce0:	db401615 	stw	r13,88(sp)
 d00bce4:	d8801315 	stw	r2,76(sp)
 d00bce8:	d8c01415 	stw	r3,80(sp)
 d00bcec:	dcc01515 	stw	r19,84(sp)
 d00bcf0:	d00c91c0 	call	d00c91c <__muldi3>
 d00bcf4:	b00d883a 	mov	r6,r22
 d00bcf8:	000b883a 	mov	r5,zero
 d00bcfc:	9009883a 	mov	r4,r18
 d00bd00:	b80f883a 	mov	r7,r23
 d00bd04:	1021883a 	mov	r16,r2
 d00bd08:	1823883a 	mov	r17,r3
 d00bd0c:	d00c91c0 	call	d00c91c <__muldi3>
 d00bd10:	8085883a 	add	r2,r16,r2
 d00bd14:	140d803a 	cmpltu	r6,r2,r16
 d00bd18:	88c7883a 	add	r3,r17,r3
 d00bd1c:	30cd883a 	add	r6,r6,r3
 d00bd20:	1029883a 	mov	r20,r2
 d00bd24:	302b883a 	mov	r21,r6
 d00bd28:	da801317 	ldw	r10,76(sp)
 d00bd2c:	dac01417 	ldw	r11,80(sp)
 d00bd30:	db001517 	ldw	r12,84(sp)
 d00bd34:	db401617 	ldw	r13,88(sp)
 d00bd38:	3440612e 	bgeu	r6,r17,d00bec0 <__muldf3+0x318>
 d00bd3c:	0009883a 	mov	r4,zero
 d00bd40:	5105883a 	add	r2,r10,r4
 d00bd44:	128d803a 	cmpltu	r6,r2,r10
 d00bd48:	5d07883a 	add	r3,r11,r20
 d00bd4c:	30cd883a 	add	r6,r6,r3
 d00bd50:	0021883a 	mov	r16,zero
 d00bd54:	04400044 	movi	r17,1
 d00bd58:	1025883a 	mov	r18,r2
 d00bd5c:	3027883a 	mov	r19,r6
 d00bd60:	32c06236 	bltu	r6,r11,d00beec <__muldf3+0x344>
 d00bd64:	59807a26 	beq	r11,r6,d00bf50 <__muldf3+0x3a8>
 d00bd68:	680b883a 	mov	r5,r13
 d00bd6c:	b80f883a 	mov	r7,r23
 d00bd70:	6009883a 	mov	r4,r12
 d00bd74:	b00d883a 	mov	r6,r22
 d00bd78:	d00c91c0 	call	d00c91c <__muldi3>
 d00bd7c:	1009883a 	mov	r4,r2
 d00bd80:	000f883a 	mov	r7,zero
 d00bd84:	1545883a 	add	r2,r2,r21
 d00bd88:	1111803a 	cmpltu	r8,r2,r4
 d00bd8c:	19c7883a 	add	r3,r3,r7
 d00bd90:	40c7883a 	add	r3,r8,r3
 d00bd94:	88cb883a 	add	r5,r17,r3
 d00bd98:	d8c00617 	ldw	r3,24(sp)
 d00bd9c:	8089883a 	add	r4,r16,r2
 d00bda0:	d8800b17 	ldw	r2,44(sp)
 d00bda4:	18c00104 	addi	r3,r3,4
 d00bda8:	240d803a 	cmpltu	r6,r4,r16
 d00bdac:	10c7883a 	add	r3,r2,r3
 d00bdb0:	2013883a 	mov	r9,r4
 d00bdb4:	d8800a17 	ldw	r2,40(sp)
 d00bdb8:	d9000517 	ldw	r4,20(sp)
 d00bdbc:	314d883a 	add	r6,r6,r5
 d00bdc0:	3015883a 	mov	r10,r6
 d00bdc4:	2088c03a 	cmpne	r4,r4,r2
 d00bdc8:	00880034 	movhi	r2,8192
 d00bdcc:	10bfffc4 	addi	r2,r2,-1
 d00bdd0:	d9000f15 	stw	r4,60(sp)
 d00bdd4:	d8c01015 	stw	r3,64(sp)
 d00bdd8:	1180162e 	bgeu	r2,r6,d00be34 <__muldf3+0x28c>
 d00bddc:	1811883a 	mov	r8,r3
 d00bde0:	101f883a 	mov	r15,r2
 d00bde4:	980497fa 	slli	r2,r19,31
 d00bde8:	9016d07a 	srli	r11,r18,1
 d00bdec:	500697fa 	slli	r3,r10,31
 d00bdf0:	480cd07a 	srli	r6,r9,1
 d00bdf4:	500ed07a 	srli	r7,r10,1
 d00bdf8:	12d6b03a 	or	r11,r2,r11
 d00bdfc:	00800044 	movi	r2,1
 d00be00:	198cb03a 	or	r6,r3,r6
 d00be04:	4888703a 	and	r4,r9,r2
 d00be08:	9818d07a 	srli	r12,r19,1
 d00be0c:	001b883a 	mov	r13,zero
 d00be10:	03a00034 	movhi	r14,32768
 d00be14:	3013883a 	mov	r9,r6
 d00be18:	3815883a 	mov	r10,r7
 d00be1c:	4091883a 	add	r8,r8,r2
 d00be20:	20000226 	beq	r4,zero,d00be2c <__muldf3+0x284>
 d00be24:	5b64b03a 	or	r18,r11,r13
 d00be28:	63a6b03a 	or	r19,r12,r14
 d00be2c:	7abfed36 	bltu	r15,r10,d00bde4 <__muldf3+0x23c>
 d00be30:	da001015 	stw	r8,64(sp)
 d00be34:	00840034 	movhi	r2,4096
 d00be38:	10bfffc4 	addi	r2,r2,-1
 d00be3c:	12801436 	bltu	r2,r10,d00be90 <__muldf3+0x2e8>
 d00be40:	da001017 	ldw	r8,64(sp)
 d00be44:	101f883a 	mov	r15,r2
 d00be48:	4a45883a 	add	r2,r9,r9
 d00be4c:	124d803a 	cmpltu	r6,r2,r9
 d00be50:	5287883a 	add	r3,r10,r10
 d00be54:	9497883a 	add	r11,r18,r18
 d00be58:	5c8f803a 	cmpltu	r7,r11,r18
 d00be5c:	9cd9883a 	add	r12,r19,r19
 d00be60:	01000044 	movi	r4,1
 d00be64:	30cd883a 	add	r6,r6,r3
 d00be68:	3b0f883a 	add	r7,r7,r12
 d00be6c:	423fffc4 	addi	r8,r8,-1
 d00be70:	1013883a 	mov	r9,r2
 d00be74:	3015883a 	mov	r10,r6
 d00be78:	111ab03a 	or	r13,r2,r4
 d00be7c:	98003016 	blt	r19,zero,d00bf40 <__muldf3+0x398>
 d00be80:	5825883a 	mov	r18,r11
 d00be84:	3827883a 	mov	r19,r7
 d00be88:	7abfef2e 	bgeu	r15,r10,d00be48 <__muldf3+0x2a0>
 d00be8c:	da001015 	stw	r8,64(sp)
 d00be90:	00803fc4 	movi	r2,255
 d00be94:	488e703a 	and	r7,r9,r2
 d00be98:	00802004 	movi	r2,128
 d00be9c:	0007883a 	mov	r3,zero
 d00bea0:	0011883a 	mov	r8,zero
 d00bea4:	38801826 	beq	r7,r2,d00bf08 <__muldf3+0x360>
 d00bea8:	008000c4 	movi	r2,3
 d00beac:	d9000e04 	addi	r4,sp,56
 d00beb0:	da801215 	stw	r10,72(sp)
 d00beb4:	d8800e15 	stw	r2,56(sp)
 d00beb8:	da401115 	stw	r9,68(sp)
 d00bebc:	003f6a06 	br	d00bc68 <__muldf3+0xc0>
 d00bec0:	89802126 	beq	r17,r6,d00bf48 <__muldf3+0x3a0>
 d00bec4:	0009883a 	mov	r4,zero
 d00bec8:	5105883a 	add	r2,r10,r4
 d00becc:	128d803a 	cmpltu	r6,r2,r10
 d00bed0:	5d07883a 	add	r3,r11,r20
 d00bed4:	30cd883a 	add	r6,r6,r3
 d00bed8:	0021883a 	mov	r16,zero
 d00bedc:	0023883a 	mov	r17,zero
 d00bee0:	1025883a 	mov	r18,r2
 d00bee4:	3027883a 	mov	r19,r6
 d00bee8:	32ff9e2e 	bgeu	r6,r11,d00bd64 <__muldf3+0x1bc>
 d00beec:	00800044 	movi	r2,1
 d00bef0:	8089883a 	add	r4,r16,r2
 d00bef4:	240d803a 	cmpltu	r6,r4,r16
 d00bef8:	344d883a 	add	r6,r6,r17
 d00befc:	2021883a 	mov	r16,r4
 d00bf00:	3023883a 	mov	r17,r6
 d00bf04:	003f9806 	br	d00bd68 <__muldf3+0x1c0>
 d00bf08:	403fe71e 	bne	r8,zero,d00bea8 <__muldf3+0x300>
 d00bf0c:	01004004 	movi	r4,256
 d00bf10:	4904703a 	and	r2,r9,r4
 d00bf14:	10c4b03a 	or	r2,r2,r3
 d00bf18:	103fe31e 	bne	r2,zero,d00bea8 <__muldf3+0x300>
 d00bf1c:	94c4b03a 	or	r2,r18,r19
 d00bf20:	103fe126 	beq	r2,zero,d00bea8 <__muldf3+0x300>
 d00bf24:	49c5883a 	add	r2,r9,r7
 d00bf28:	1251803a 	cmpltu	r8,r2,r9
 d00bf2c:	4291883a 	add	r8,r8,r10
 d00bf30:	013fc004 	movi	r4,-256
 d00bf34:	1112703a 	and	r9,r2,r4
 d00bf38:	4015883a 	mov	r10,r8
 d00bf3c:	003fda06 	br	d00bea8 <__muldf3+0x300>
 d00bf40:	6813883a 	mov	r9,r13
 d00bf44:	003fce06 	br	d00be80 <__muldf3+0x2d8>
 d00bf48:	143f7c36 	bltu	r2,r16,d00bd3c <__muldf3+0x194>
 d00bf4c:	003fdd06 	br	d00bec4 <__muldf3+0x31c>
 d00bf50:	12bf852e 	bgeu	r2,r10,d00bd68 <__muldf3+0x1c0>
 d00bf54:	003fe506 	br	d00beec <__muldf3+0x344>
 d00bf58:	00800084 	movi	r2,2
 d00bf5c:	20bf351e 	bne	r4,r2,d00bc34 <__muldf3+0x8c>
 d00bf60:	01034174 	movhi	r4,3333
 d00bf64:	21392d04 	addi	r4,r4,-6988
 d00bf68:	003f3f06 	br	d00bc68 <__muldf3+0xc0>

0d00bf6c <__divdf3>:
 d00bf6c:	deffed04 	addi	sp,sp,-76
 d00bf70:	dcc01115 	stw	r19,68(sp)
 d00bf74:	dcc00404 	addi	r19,sp,16
 d00bf78:	2011883a 	mov	r8,r4
 d00bf7c:	2813883a 	mov	r9,r5
 d00bf80:	dc000e15 	stw	r16,56(sp)
 d00bf84:	d809883a 	mov	r4,sp
 d00bf88:	980b883a 	mov	r5,r19
 d00bf8c:	dc000904 	addi	r16,sp,36
 d00bf90:	dfc01215 	stw	ra,72(sp)
 d00bf94:	da400115 	stw	r9,4(sp)
 d00bf98:	d9c00315 	stw	r7,12(sp)
 d00bf9c:	da000015 	stw	r8,0(sp)
 d00bfa0:	d9800215 	stw	r6,8(sp)
 d00bfa4:	dc801015 	stw	r18,64(sp)
 d00bfa8:	dc400f15 	stw	r17,60(sp)
 d00bfac:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00bfb0:	d9000204 	addi	r4,sp,8
 d00bfb4:	800b883a 	mov	r5,r16
 d00bfb8:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00bfbc:	d9000417 	ldw	r4,16(sp)
 d00bfc0:	00800044 	movi	r2,1
 d00bfc4:	11000b2e 	bgeu	r2,r4,d00bff4 <__divdf3+0x88>
 d00bfc8:	d9400917 	ldw	r5,36(sp)
 d00bfcc:	1140762e 	bgeu	r2,r5,d00c1a8 <__divdf3+0x23c>
 d00bfd0:	d8800517 	ldw	r2,20(sp)
 d00bfd4:	d8c00a17 	ldw	r3,40(sp)
 d00bfd8:	01800104 	movi	r6,4
 d00bfdc:	10c4f03a 	xor	r2,r2,r3
 d00bfe0:	d8800515 	stw	r2,20(sp)
 d00bfe4:	21800226 	beq	r4,r6,d00bff0 <__divdf3+0x84>
 d00bfe8:	00800084 	movi	r2,2
 d00bfec:	2080141e 	bne	r4,r2,d00c040 <__divdf3+0xd4>
 d00bff0:	29000926 	beq	r5,r4,d00c018 <__divdf3+0xac>
 d00bff4:	9809883a 	mov	r4,r19
 d00bff8:	d00cac00 	call	d00cac0 <__pack_d>
 d00bffc:	dfc01217 	ldw	ra,72(sp)
 d00c000:	dcc01117 	ldw	r19,68(sp)
 d00c004:	dc801017 	ldw	r18,64(sp)
 d00c008:	dc400f17 	ldw	r17,60(sp)
 d00c00c:	dc000e17 	ldw	r16,56(sp)
 d00c010:	dec01304 	addi	sp,sp,76
 d00c014:	f800283a 	ret
 d00c018:	01034174 	movhi	r4,3333
 d00c01c:	21392d04 	addi	r4,r4,-6988
 d00c020:	d00cac00 	call	d00cac0 <__pack_d>
 d00c024:	dfc01217 	ldw	ra,72(sp)
 d00c028:	dcc01117 	ldw	r19,68(sp)
 d00c02c:	dc801017 	ldw	r18,64(sp)
 d00c030:	dc400f17 	ldw	r17,60(sp)
 d00c034:	dc000e17 	ldw	r16,56(sp)
 d00c038:	dec01304 	addi	sp,sp,76
 d00c03c:	f800283a 	ret
 d00c040:	29805b26 	beq	r5,r6,d00c1b0 <__divdf3+0x244>
 d00c044:	28802d26 	beq	r5,r2,d00c0fc <__divdf3+0x190>
 d00c048:	d8c00617 	ldw	r3,24(sp)
 d00c04c:	d8800b17 	ldw	r2,44(sp)
 d00c050:	d9c00817 	ldw	r7,32(sp)
 d00c054:	dc400d17 	ldw	r17,52(sp)
 d00c058:	188bc83a 	sub	r5,r3,r2
 d00c05c:	d9800717 	ldw	r6,28(sp)
 d00c060:	dc000c17 	ldw	r16,48(sp)
 d00c064:	d9400615 	stw	r5,24(sp)
 d00c068:	3c403836 	bltu	r7,r17,d00c14c <__divdf3+0x1e0>
 d00c06c:	89c03626 	beq	r17,r7,d00c148 <__divdf3+0x1dc>
 d00c070:	0015883a 	mov	r10,zero
 d00c074:	001d883a 	mov	r14,zero
 d00c078:	02c40034 	movhi	r11,4096
 d00c07c:	001f883a 	mov	r15,zero
 d00c080:	003f883a 	mov	ra,zero
 d00c084:	04800f44 	movi	r18,61
 d00c088:	00000f06 	br	d00c0c8 <__divdf3+0x15c>
 d00c08c:	601d883a 	mov	r14,r12
 d00c090:	681f883a 	mov	r15,r13
 d00c094:	400d883a 	mov	r6,r8
 d00c098:	100f883a 	mov	r7,r2
 d00c09c:	3191883a 	add	r8,r6,r6
 d00c0a0:	5808d07a 	srli	r4,r11,1
 d00c0a4:	4185803a 	cmpltu	r2,r8,r6
 d00c0a8:	39d3883a 	add	r9,r7,r7
 d00c0ac:	28c6b03a 	or	r3,r5,r3
 d00c0b0:	1245883a 	add	r2,r2,r9
 d00c0b4:	1815883a 	mov	r10,r3
 d00c0b8:	2017883a 	mov	r11,r4
 d00c0bc:	400d883a 	mov	r6,r8
 d00c0c0:	100f883a 	mov	r7,r2
 d00c0c4:	fc801726 	beq	ra,r18,d00c124 <__divdf3+0x1b8>
 d00c0c8:	580a97fa 	slli	r5,r11,31
 d00c0cc:	5006d07a 	srli	r3,r10,1
 d00c0d0:	ffc00044 	addi	ra,ra,1
 d00c0d4:	3c7ff136 	bltu	r7,r17,d00c09c <__divdf3+0x130>
 d00c0d8:	3411c83a 	sub	r8,r6,r16
 d00c0dc:	3205803a 	cmpltu	r2,r6,r8
 d00c0e0:	3c53c83a 	sub	r9,r7,r17
 d00c0e4:	7298b03a 	or	r12,r14,r10
 d00c0e8:	7adab03a 	or	r13,r15,r11
 d00c0ec:	4885c83a 	sub	r2,r9,r2
 d00c0f0:	89ffe61e 	bne	r17,r7,d00c08c <__divdf3+0x120>
 d00c0f4:	343fe936 	bltu	r6,r16,d00c09c <__divdf3+0x130>
 d00c0f8:	003fe406 	br	d00c08c <__divdf3+0x120>
 d00c0fc:	9809883a 	mov	r4,r19
 d00c100:	d9800415 	stw	r6,16(sp)
 d00c104:	d00cac00 	call	d00cac0 <__pack_d>
 d00c108:	dfc01217 	ldw	ra,72(sp)
 d00c10c:	dcc01117 	ldw	r19,68(sp)
 d00c110:	dc801017 	ldw	r18,64(sp)
 d00c114:	dc400f17 	ldw	r17,60(sp)
 d00c118:	dc000e17 	ldw	r16,56(sp)
 d00c11c:	dec01304 	addi	sp,sp,76
 d00c120:	f800283a 	ret
 d00c124:	00803fc4 	movi	r2,255
 d00c128:	7090703a 	and	r8,r14,r2
 d00c12c:	00802004 	movi	r2,128
 d00c130:	0007883a 	mov	r3,zero
 d00c134:	0013883a 	mov	r9,zero
 d00c138:	40800d26 	beq	r8,r2,d00c170 <__divdf3+0x204>
 d00c13c:	dbc00815 	stw	r15,32(sp)
 d00c140:	db800715 	stw	r14,28(sp)
 d00c144:	003fab06 	br	d00bff4 <__divdf3+0x88>
 d00c148:	343fc92e 	bgeu	r6,r16,d00c070 <__divdf3+0x104>
 d00c14c:	3185883a 	add	r2,r6,r6
 d00c150:	1189803a 	cmpltu	r4,r2,r6
 d00c154:	39c7883a 	add	r3,r7,r7
 d00c158:	20c9883a 	add	r4,r4,r3
 d00c15c:	297fffc4 	addi	r5,r5,-1
 d00c160:	100d883a 	mov	r6,r2
 d00c164:	200f883a 	mov	r7,r4
 d00c168:	d9400615 	stw	r5,24(sp)
 d00c16c:	003fc006 	br	d00c070 <__divdf3+0x104>
 d00c170:	483ff21e 	bne	r9,zero,d00c13c <__divdf3+0x1d0>
 d00c174:	01004004 	movi	r4,256
 d00c178:	7104703a 	and	r2,r14,r4
 d00c17c:	10c4b03a 	or	r2,r2,r3
 d00c180:	103fee1e 	bne	r2,zero,d00c13c <__divdf3+0x1d0>
 d00c184:	31c4b03a 	or	r2,r6,r7
 d00c188:	103fec26 	beq	r2,zero,d00c13c <__divdf3+0x1d0>
 d00c18c:	7205883a 	add	r2,r14,r8
 d00c190:	1391803a 	cmpltu	r8,r2,r14
 d00c194:	43d1883a 	add	r8,r8,r15
 d00c198:	013fc004 	movi	r4,-256
 d00c19c:	111c703a 	and	r14,r2,r4
 d00c1a0:	401f883a 	mov	r15,r8
 d00c1a4:	003fe506 	br	d00c13c <__divdf3+0x1d0>
 d00c1a8:	8009883a 	mov	r4,r16
 d00c1ac:	003f9206 	br	d00bff8 <__divdf3+0x8c>
 d00c1b0:	9809883a 	mov	r4,r19
 d00c1b4:	d8000715 	stw	zero,28(sp)
 d00c1b8:	d8000815 	stw	zero,32(sp)
 d00c1bc:	d8000615 	stw	zero,24(sp)
 d00c1c0:	003f8d06 	br	d00bff8 <__divdf3+0x8c>

0d00c1c4 <__eqdf2>:
 d00c1c4:	deffef04 	addi	sp,sp,-68
 d00c1c8:	dc400f15 	stw	r17,60(sp)
 d00c1cc:	dc400404 	addi	r17,sp,16
 d00c1d0:	2005883a 	mov	r2,r4
 d00c1d4:	2807883a 	mov	r3,r5
 d00c1d8:	dc000e15 	stw	r16,56(sp)
 d00c1dc:	d809883a 	mov	r4,sp
 d00c1e0:	880b883a 	mov	r5,r17
 d00c1e4:	dc000904 	addi	r16,sp,36
 d00c1e8:	d8c00115 	stw	r3,4(sp)
 d00c1ec:	d8800015 	stw	r2,0(sp)
 d00c1f0:	d9800215 	stw	r6,8(sp)
 d00c1f4:	dfc01015 	stw	ra,64(sp)
 d00c1f8:	d9c00315 	stw	r7,12(sp)
 d00c1fc:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c200:	d9000204 	addi	r4,sp,8
 d00c204:	800b883a 	mov	r5,r16
 d00c208:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c20c:	d8800417 	ldw	r2,16(sp)
 d00c210:	00c00044 	movi	r3,1
 d00c214:	180d883a 	mov	r6,r3
 d00c218:	1880062e 	bgeu	r3,r2,d00c234 <__eqdf2+0x70>
 d00c21c:	d8800917 	ldw	r2,36(sp)
 d00c220:	8809883a 	mov	r4,r17
 d00c224:	800b883a 	mov	r5,r16
 d00c228:	1880022e 	bgeu	r3,r2,d00c234 <__eqdf2+0x70>
 d00c22c:	d00cf0c0 	call	d00cf0c <__fpcmp_parts_d>
 d00c230:	100d883a 	mov	r6,r2
 d00c234:	3005883a 	mov	r2,r6
 d00c238:	dfc01017 	ldw	ra,64(sp)
 d00c23c:	dc400f17 	ldw	r17,60(sp)
 d00c240:	dc000e17 	ldw	r16,56(sp)
 d00c244:	dec01104 	addi	sp,sp,68
 d00c248:	f800283a 	ret

0d00c24c <__nedf2>:
 d00c24c:	deffef04 	addi	sp,sp,-68
 d00c250:	dc400f15 	stw	r17,60(sp)
 d00c254:	dc400404 	addi	r17,sp,16
 d00c258:	2005883a 	mov	r2,r4
 d00c25c:	2807883a 	mov	r3,r5
 d00c260:	dc000e15 	stw	r16,56(sp)
 d00c264:	d809883a 	mov	r4,sp
 d00c268:	880b883a 	mov	r5,r17
 d00c26c:	dc000904 	addi	r16,sp,36
 d00c270:	d8c00115 	stw	r3,4(sp)
 d00c274:	d8800015 	stw	r2,0(sp)
 d00c278:	d9800215 	stw	r6,8(sp)
 d00c27c:	dfc01015 	stw	ra,64(sp)
 d00c280:	d9c00315 	stw	r7,12(sp)
 d00c284:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c288:	d9000204 	addi	r4,sp,8
 d00c28c:	800b883a 	mov	r5,r16
 d00c290:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c294:	d8800417 	ldw	r2,16(sp)
 d00c298:	00c00044 	movi	r3,1
 d00c29c:	180d883a 	mov	r6,r3
 d00c2a0:	1880062e 	bgeu	r3,r2,d00c2bc <__nedf2+0x70>
 d00c2a4:	d8800917 	ldw	r2,36(sp)
 d00c2a8:	8809883a 	mov	r4,r17
 d00c2ac:	800b883a 	mov	r5,r16
 d00c2b0:	1880022e 	bgeu	r3,r2,d00c2bc <__nedf2+0x70>
 d00c2b4:	d00cf0c0 	call	d00cf0c <__fpcmp_parts_d>
 d00c2b8:	100d883a 	mov	r6,r2
 d00c2bc:	3005883a 	mov	r2,r6
 d00c2c0:	dfc01017 	ldw	ra,64(sp)
 d00c2c4:	dc400f17 	ldw	r17,60(sp)
 d00c2c8:	dc000e17 	ldw	r16,56(sp)
 d00c2cc:	dec01104 	addi	sp,sp,68
 d00c2d0:	f800283a 	ret

0d00c2d4 <__gtdf2>:
 d00c2d4:	deffef04 	addi	sp,sp,-68
 d00c2d8:	dc400f15 	stw	r17,60(sp)
 d00c2dc:	dc400404 	addi	r17,sp,16
 d00c2e0:	2005883a 	mov	r2,r4
 d00c2e4:	2807883a 	mov	r3,r5
 d00c2e8:	dc000e15 	stw	r16,56(sp)
 d00c2ec:	d809883a 	mov	r4,sp
 d00c2f0:	880b883a 	mov	r5,r17
 d00c2f4:	dc000904 	addi	r16,sp,36
 d00c2f8:	d8c00115 	stw	r3,4(sp)
 d00c2fc:	d8800015 	stw	r2,0(sp)
 d00c300:	d9800215 	stw	r6,8(sp)
 d00c304:	dfc01015 	stw	ra,64(sp)
 d00c308:	d9c00315 	stw	r7,12(sp)
 d00c30c:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c310:	d9000204 	addi	r4,sp,8
 d00c314:	800b883a 	mov	r5,r16
 d00c318:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c31c:	d8800417 	ldw	r2,16(sp)
 d00c320:	00c00044 	movi	r3,1
 d00c324:	01bfffc4 	movi	r6,-1
 d00c328:	1880062e 	bgeu	r3,r2,d00c344 <__gtdf2+0x70>
 d00c32c:	d8800917 	ldw	r2,36(sp)
 d00c330:	8809883a 	mov	r4,r17
 d00c334:	800b883a 	mov	r5,r16
 d00c338:	1880022e 	bgeu	r3,r2,d00c344 <__gtdf2+0x70>
 d00c33c:	d00cf0c0 	call	d00cf0c <__fpcmp_parts_d>
 d00c340:	100d883a 	mov	r6,r2
 d00c344:	3005883a 	mov	r2,r6
 d00c348:	dfc01017 	ldw	ra,64(sp)
 d00c34c:	dc400f17 	ldw	r17,60(sp)
 d00c350:	dc000e17 	ldw	r16,56(sp)
 d00c354:	dec01104 	addi	sp,sp,68
 d00c358:	f800283a 	ret

0d00c35c <__gedf2>:
 d00c35c:	deffef04 	addi	sp,sp,-68
 d00c360:	dc400f15 	stw	r17,60(sp)
 d00c364:	dc400404 	addi	r17,sp,16
 d00c368:	2005883a 	mov	r2,r4
 d00c36c:	2807883a 	mov	r3,r5
 d00c370:	dc000e15 	stw	r16,56(sp)
 d00c374:	d809883a 	mov	r4,sp
 d00c378:	880b883a 	mov	r5,r17
 d00c37c:	dc000904 	addi	r16,sp,36
 d00c380:	d8c00115 	stw	r3,4(sp)
 d00c384:	d8800015 	stw	r2,0(sp)
 d00c388:	d9800215 	stw	r6,8(sp)
 d00c38c:	dfc01015 	stw	ra,64(sp)
 d00c390:	d9c00315 	stw	r7,12(sp)
 d00c394:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c398:	d9000204 	addi	r4,sp,8
 d00c39c:	800b883a 	mov	r5,r16
 d00c3a0:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c3a4:	d8800417 	ldw	r2,16(sp)
 d00c3a8:	00c00044 	movi	r3,1
 d00c3ac:	01bfffc4 	movi	r6,-1
 d00c3b0:	1880062e 	bgeu	r3,r2,d00c3cc <__gedf2+0x70>
 d00c3b4:	d8800917 	ldw	r2,36(sp)
 d00c3b8:	8809883a 	mov	r4,r17
 d00c3bc:	800b883a 	mov	r5,r16
 d00c3c0:	1880022e 	bgeu	r3,r2,d00c3cc <__gedf2+0x70>
 d00c3c4:	d00cf0c0 	call	d00cf0c <__fpcmp_parts_d>
 d00c3c8:	100d883a 	mov	r6,r2
 d00c3cc:	3005883a 	mov	r2,r6
 d00c3d0:	dfc01017 	ldw	ra,64(sp)
 d00c3d4:	dc400f17 	ldw	r17,60(sp)
 d00c3d8:	dc000e17 	ldw	r16,56(sp)
 d00c3dc:	dec01104 	addi	sp,sp,68
 d00c3e0:	f800283a 	ret

0d00c3e4 <__ltdf2>:
 d00c3e4:	deffef04 	addi	sp,sp,-68
 d00c3e8:	dc400f15 	stw	r17,60(sp)
 d00c3ec:	dc400404 	addi	r17,sp,16
 d00c3f0:	2005883a 	mov	r2,r4
 d00c3f4:	2807883a 	mov	r3,r5
 d00c3f8:	dc000e15 	stw	r16,56(sp)
 d00c3fc:	d809883a 	mov	r4,sp
 d00c400:	880b883a 	mov	r5,r17
 d00c404:	dc000904 	addi	r16,sp,36
 d00c408:	d8c00115 	stw	r3,4(sp)
 d00c40c:	d8800015 	stw	r2,0(sp)
 d00c410:	d9800215 	stw	r6,8(sp)
 d00c414:	dfc01015 	stw	ra,64(sp)
 d00c418:	d9c00315 	stw	r7,12(sp)
 d00c41c:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c420:	d9000204 	addi	r4,sp,8
 d00c424:	800b883a 	mov	r5,r16
 d00c428:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c42c:	d8800417 	ldw	r2,16(sp)
 d00c430:	00c00044 	movi	r3,1
 d00c434:	180d883a 	mov	r6,r3
 d00c438:	1880062e 	bgeu	r3,r2,d00c454 <__ltdf2+0x70>
 d00c43c:	d8800917 	ldw	r2,36(sp)
 d00c440:	8809883a 	mov	r4,r17
 d00c444:	800b883a 	mov	r5,r16
 d00c448:	1880022e 	bgeu	r3,r2,d00c454 <__ltdf2+0x70>
 d00c44c:	d00cf0c0 	call	d00cf0c <__fpcmp_parts_d>
 d00c450:	100d883a 	mov	r6,r2
 d00c454:	3005883a 	mov	r2,r6
 d00c458:	dfc01017 	ldw	ra,64(sp)
 d00c45c:	dc400f17 	ldw	r17,60(sp)
 d00c460:	dc000e17 	ldw	r16,56(sp)
 d00c464:	dec01104 	addi	sp,sp,68
 d00c468:	f800283a 	ret

0d00c46c <__floatsidf>:
 d00c46c:	2006d7fa 	srli	r3,r4,31
 d00c470:	defff604 	addi	sp,sp,-40
 d00c474:	008000c4 	movi	r2,3
 d00c478:	dfc00915 	stw	ra,36(sp)
 d00c47c:	dcc00815 	stw	r19,32(sp)
 d00c480:	dc800715 	stw	r18,28(sp)
 d00c484:	dc400615 	stw	r17,24(sp)
 d00c488:	dc000515 	stw	r16,20(sp)
 d00c48c:	d8800015 	stw	r2,0(sp)
 d00c490:	d8c00115 	stw	r3,4(sp)
 d00c494:	20000f1e 	bne	r4,zero,d00c4d4 <__floatsidf+0x68>
 d00c498:	00800084 	movi	r2,2
 d00c49c:	d8800015 	stw	r2,0(sp)
 d00c4a0:	d809883a 	mov	r4,sp
 d00c4a4:	d00cac00 	call	d00cac0 <__pack_d>
 d00c4a8:	1009883a 	mov	r4,r2
 d00c4ac:	180b883a 	mov	r5,r3
 d00c4b0:	2005883a 	mov	r2,r4
 d00c4b4:	2807883a 	mov	r3,r5
 d00c4b8:	dfc00917 	ldw	ra,36(sp)
 d00c4bc:	dcc00817 	ldw	r19,32(sp)
 d00c4c0:	dc800717 	ldw	r18,28(sp)
 d00c4c4:	dc400617 	ldw	r17,24(sp)
 d00c4c8:	dc000517 	ldw	r16,20(sp)
 d00c4cc:	dec00a04 	addi	sp,sp,40
 d00c4d0:	f800283a 	ret
 d00c4d4:	00800f04 	movi	r2,60
 d00c4d8:	1807003a 	cmpeq	r3,r3,zero
 d00c4dc:	d8800215 	stw	r2,8(sp)
 d00c4e0:	18001126 	beq	r3,zero,d00c528 <__floatsidf+0xbc>
 d00c4e4:	0027883a 	mov	r19,zero
 d00c4e8:	2025883a 	mov	r18,r4
 d00c4ec:	d9000315 	stw	r4,12(sp)
 d00c4f0:	dcc00415 	stw	r19,16(sp)
 d00c4f4:	d00ca400 	call	d00ca40 <__clzsi2>
 d00c4f8:	11000744 	addi	r4,r2,29
 d00c4fc:	013fe80e 	bge	zero,r4,d00c4a0 <__floatsidf+0x34>
 d00c500:	10bfff44 	addi	r2,r2,-3
 d00c504:	10000c16 	blt	r2,zero,d00c538 <__floatsidf+0xcc>
 d00c508:	90a2983a 	sll	r17,r18,r2
 d00c50c:	0021883a 	mov	r16,zero
 d00c510:	d8800217 	ldw	r2,8(sp)
 d00c514:	dc400415 	stw	r17,16(sp)
 d00c518:	dc000315 	stw	r16,12(sp)
 d00c51c:	1105c83a 	sub	r2,r2,r4
 d00c520:	d8800215 	stw	r2,8(sp)
 d00c524:	003fde06 	br	d00c4a0 <__floatsidf+0x34>
 d00c528:	00a00034 	movhi	r2,32768
 d00c52c:	20800a26 	beq	r4,r2,d00c558 <__floatsidf+0xec>
 d00c530:	0109c83a 	sub	r4,zero,r4
 d00c534:	003feb06 	br	d00c4e4 <__floatsidf+0x78>
 d00c538:	9006d07a 	srli	r3,r18,1
 d00c53c:	008007c4 	movi	r2,31
 d00c540:	1105c83a 	sub	r2,r2,r4
 d00c544:	1886d83a 	srl	r3,r3,r2
 d00c548:	9922983a 	sll	r17,r19,r4
 d00c54c:	9120983a 	sll	r16,r18,r4
 d00c550:	1c62b03a 	or	r17,r3,r17
 d00c554:	003fee06 	br	d00c510 <__floatsidf+0xa4>
 d00c558:	0009883a 	mov	r4,zero
 d00c55c:	01707834 	movhi	r5,49632
 d00c560:	003fd306 	br	d00c4b0 <__floatsidf+0x44>

0d00c564 <__fixdfsi>:
 d00c564:	defff804 	addi	sp,sp,-32
 d00c568:	2005883a 	mov	r2,r4
 d00c56c:	2807883a 	mov	r3,r5
 d00c570:	d809883a 	mov	r4,sp
 d00c574:	d9400204 	addi	r5,sp,8
 d00c578:	d8c00115 	stw	r3,4(sp)
 d00c57c:	d8800015 	stw	r2,0(sp)
 d00c580:	dfc00715 	stw	ra,28(sp)
 d00c584:	d00cdd40 	call	d00cdd4 <__unpack_d>
 d00c588:	d8c00217 	ldw	r3,8(sp)
 d00c58c:	00800084 	movi	r2,2
 d00c590:	1880051e 	bne	r3,r2,d00c5a8 <__fixdfsi+0x44>
 d00c594:	0007883a 	mov	r3,zero
 d00c598:	1805883a 	mov	r2,r3
 d00c59c:	dfc00717 	ldw	ra,28(sp)
 d00c5a0:	dec00804 	addi	sp,sp,32
 d00c5a4:	f800283a 	ret
 d00c5a8:	00800044 	movi	r2,1
 d00c5ac:	10fff92e 	bgeu	r2,r3,d00c594 <__fixdfsi+0x30>
 d00c5b0:	00800104 	movi	r2,4
 d00c5b4:	18800426 	beq	r3,r2,d00c5c8 <__fixdfsi+0x64>
 d00c5b8:	d8c00417 	ldw	r3,16(sp)
 d00c5bc:	183ff516 	blt	r3,zero,d00c594 <__fixdfsi+0x30>
 d00c5c0:	00800784 	movi	r2,30
 d00c5c4:	10c0080e 	bge	r2,r3,d00c5e8 <__fixdfsi+0x84>
 d00c5c8:	d8800317 	ldw	r2,12(sp)
 d00c5cc:	1000121e 	bne	r2,zero,d00c618 <__fixdfsi+0xb4>
 d00c5d0:	00e00034 	movhi	r3,32768
 d00c5d4:	18ffffc4 	addi	r3,r3,-1
 d00c5d8:	1805883a 	mov	r2,r3
 d00c5dc:	dfc00717 	ldw	ra,28(sp)
 d00c5e0:	dec00804 	addi	sp,sp,32
 d00c5e4:	f800283a 	ret
 d00c5e8:	00800f04 	movi	r2,60
 d00c5ec:	10d1c83a 	sub	r8,r2,r3
 d00c5f0:	40bff804 	addi	r2,r8,-32
 d00c5f4:	d9800517 	ldw	r6,20(sp)
 d00c5f8:	d9c00617 	ldw	r7,24(sp)
 d00c5fc:	10000816 	blt	r2,zero,d00c620 <__fixdfsi+0xbc>
 d00c600:	3888d83a 	srl	r4,r7,r2
 d00c604:	d8800317 	ldw	r2,12(sp)
 d00c608:	2007883a 	mov	r3,r4
 d00c60c:	103fe226 	beq	r2,zero,d00c598 <__fixdfsi+0x34>
 d00c610:	0107c83a 	sub	r3,zero,r4
 d00c614:	003fe006 	br	d00c598 <__fixdfsi+0x34>
 d00c618:	00e00034 	movhi	r3,32768
 d00c61c:	003fde06 	br	d00c598 <__fixdfsi+0x34>
 d00c620:	39c7883a 	add	r3,r7,r7
 d00c624:	008007c4 	movi	r2,31
 d00c628:	1205c83a 	sub	r2,r2,r8
 d00c62c:	1886983a 	sll	r3,r3,r2
 d00c630:	3208d83a 	srl	r4,r6,r8
 d00c634:	1908b03a 	or	r4,r3,r4
 d00c638:	003ff206 	br	d00c604 <__fixdfsi+0xa0>

0d00c63c <__floatunsidf>:
 d00c63c:	defff204 	addi	sp,sp,-56
 d00c640:	dfc00d15 	stw	ra,52(sp)
 d00c644:	ddc00c15 	stw	r23,48(sp)
 d00c648:	dd800b15 	stw	r22,44(sp)
 d00c64c:	dd400a15 	stw	r21,40(sp)
 d00c650:	dd000915 	stw	r20,36(sp)
 d00c654:	dcc00815 	stw	r19,32(sp)
 d00c658:	dc800715 	stw	r18,28(sp)
 d00c65c:	dc400615 	stw	r17,24(sp)
 d00c660:	dc000515 	stw	r16,20(sp)
 d00c664:	d8000115 	stw	zero,4(sp)
 d00c668:	20000f1e 	bne	r4,zero,d00c6a8 <__floatunsidf+0x6c>
 d00c66c:	00800084 	movi	r2,2
 d00c670:	d8800015 	stw	r2,0(sp)
 d00c674:	d809883a 	mov	r4,sp
 d00c678:	d00cac00 	call	d00cac0 <__pack_d>
 d00c67c:	dfc00d17 	ldw	ra,52(sp)
 d00c680:	ddc00c17 	ldw	r23,48(sp)
 d00c684:	dd800b17 	ldw	r22,44(sp)
 d00c688:	dd400a17 	ldw	r21,40(sp)
 d00c68c:	dd000917 	ldw	r20,36(sp)
 d00c690:	dcc00817 	ldw	r19,32(sp)
 d00c694:	dc800717 	ldw	r18,28(sp)
 d00c698:	dc400617 	ldw	r17,24(sp)
 d00c69c:	dc000517 	ldw	r16,20(sp)
 d00c6a0:	dec00e04 	addi	sp,sp,56
 d00c6a4:	f800283a 	ret
 d00c6a8:	008000c4 	movi	r2,3
 d00c6ac:	00c00f04 	movi	r3,60
 d00c6b0:	002f883a 	mov	r23,zero
 d00c6b4:	202d883a 	mov	r22,r4
 d00c6b8:	d8800015 	stw	r2,0(sp)
 d00c6bc:	d8c00215 	stw	r3,8(sp)
 d00c6c0:	d9000315 	stw	r4,12(sp)
 d00c6c4:	ddc00415 	stw	r23,16(sp)
 d00c6c8:	d00ca400 	call	d00ca40 <__clzsi2>
 d00c6cc:	12400744 	addi	r9,r2,29
 d00c6d0:	48000b16 	blt	r9,zero,d00c700 <__floatunsidf+0xc4>
 d00c6d4:	483fe726 	beq	r9,zero,d00c674 <__floatunsidf+0x38>
 d00c6d8:	10bfff44 	addi	r2,r2,-3
 d00c6dc:	10002e16 	blt	r2,zero,d00c798 <__floatunsidf+0x15c>
 d00c6e0:	b0a2983a 	sll	r17,r22,r2
 d00c6e4:	0021883a 	mov	r16,zero
 d00c6e8:	d8800217 	ldw	r2,8(sp)
 d00c6ec:	dc400415 	stw	r17,16(sp)
 d00c6f0:	dc000315 	stw	r16,12(sp)
 d00c6f4:	1245c83a 	sub	r2,r2,r9
 d00c6f8:	d8800215 	stw	r2,8(sp)
 d00c6fc:	003fdd06 	br	d00c674 <__floatunsidf+0x38>
 d00c700:	0255c83a 	sub	r10,zero,r9
 d00c704:	51bff804 	addi	r6,r10,-32
 d00c708:	30001b16 	blt	r6,zero,d00c778 <__floatunsidf+0x13c>
 d00c70c:	b9a8d83a 	srl	r20,r23,r6
 d00c710:	002b883a 	mov	r21,zero
 d00c714:	000f883a 	mov	r7,zero
 d00c718:	01000044 	movi	r4,1
 d00c71c:	0011883a 	mov	r8,zero
 d00c720:	30002516 	blt	r6,zero,d00c7b8 <__floatunsidf+0x17c>
 d00c724:	21a6983a 	sll	r19,r4,r6
 d00c728:	0025883a 	mov	r18,zero
 d00c72c:	00bfffc4 	movi	r2,-1
 d00c730:	9089883a 	add	r4,r18,r2
 d00c734:	988b883a 	add	r5,r19,r2
 d00c738:	248d803a 	cmpltu	r6,r4,r18
 d00c73c:	314b883a 	add	r5,r6,r5
 d00c740:	b104703a 	and	r2,r22,r4
 d00c744:	b946703a 	and	r3,r23,r5
 d00c748:	10c4b03a 	or	r2,r2,r3
 d00c74c:	10000226 	beq	r2,zero,d00c758 <__floatunsidf+0x11c>
 d00c750:	01c00044 	movi	r7,1
 d00c754:	0011883a 	mov	r8,zero
 d00c758:	d9000217 	ldw	r4,8(sp)
 d00c75c:	a1c4b03a 	or	r2,r20,r7
 d00c760:	aa06b03a 	or	r3,r21,r8
 d00c764:	2249c83a 	sub	r4,r4,r9
 d00c768:	d8c00415 	stw	r3,16(sp)
 d00c76c:	d9000215 	stw	r4,8(sp)
 d00c770:	d8800315 	stw	r2,12(sp)
 d00c774:	003fbf06 	br	d00c674 <__floatunsidf+0x38>
 d00c778:	bdc7883a 	add	r3,r23,r23
 d00c77c:	008007c4 	movi	r2,31
 d00c780:	1285c83a 	sub	r2,r2,r10
 d00c784:	1886983a 	sll	r3,r3,r2
 d00c788:	b2a8d83a 	srl	r20,r22,r10
 d00c78c:	baaad83a 	srl	r21,r23,r10
 d00c790:	1d28b03a 	or	r20,r3,r20
 d00c794:	003fdf06 	br	d00c714 <__floatunsidf+0xd8>
 d00c798:	b006d07a 	srli	r3,r22,1
 d00c79c:	008007c4 	movi	r2,31
 d00c7a0:	1245c83a 	sub	r2,r2,r9
 d00c7a4:	1886d83a 	srl	r3,r3,r2
 d00c7a8:	ba62983a 	sll	r17,r23,r9
 d00c7ac:	b260983a 	sll	r16,r22,r9
 d00c7b0:	1c62b03a 	or	r17,r3,r17
 d00c7b4:	003fcc06 	br	d00c6e8 <__floatunsidf+0xac>
 d00c7b8:	2006d07a 	srli	r3,r4,1
 d00c7bc:	008007c4 	movi	r2,31
 d00c7c0:	1285c83a 	sub	r2,r2,r10
 d00c7c4:	18a6d83a 	srl	r19,r3,r2
 d00c7c8:	22a4983a 	sll	r18,r4,r10
 d00c7cc:	003fd706 	br	d00c72c <__floatunsidf+0xf0>

0d00c7d0 <udivmodsi4>:
 d00c7d0:	29001b2e 	bgeu	r5,r4,d00c840 <udivmodsi4+0x70>
 d00c7d4:	28001a16 	blt	r5,zero,d00c840 <udivmodsi4+0x70>
 d00c7d8:	00800044 	movi	r2,1
 d00c7dc:	0007883a 	mov	r3,zero
 d00c7e0:	01c007c4 	movi	r7,31
 d00c7e4:	00000306 	br	d00c7f4 <udivmodsi4+0x24>
 d00c7e8:	19c01326 	beq	r3,r7,d00c838 <udivmodsi4+0x68>
 d00c7ec:	18c00044 	addi	r3,r3,1
 d00c7f0:	28000416 	blt	r5,zero,d00c804 <udivmodsi4+0x34>
 d00c7f4:	294b883a 	add	r5,r5,r5
 d00c7f8:	1085883a 	add	r2,r2,r2
 d00c7fc:	293ffa36 	bltu	r5,r4,d00c7e8 <udivmodsi4+0x18>
 d00c800:	10000d26 	beq	r2,zero,d00c838 <udivmodsi4+0x68>
 d00c804:	0007883a 	mov	r3,zero
 d00c808:	21400236 	bltu	r4,r5,d00c814 <udivmodsi4+0x44>
 d00c80c:	2149c83a 	sub	r4,r4,r5
 d00c810:	1886b03a 	or	r3,r3,r2
 d00c814:	1004d07a 	srli	r2,r2,1
 d00c818:	280ad07a 	srli	r5,r5,1
 d00c81c:	103ffa1e 	bne	r2,zero,d00c808 <udivmodsi4+0x38>
 d00c820:	30000226 	beq	r6,zero,d00c82c <udivmodsi4+0x5c>
 d00c824:	2005883a 	mov	r2,r4
 d00c828:	f800283a 	ret
 d00c82c:	1809883a 	mov	r4,r3
 d00c830:	2005883a 	mov	r2,r4
 d00c834:	f800283a 	ret
 d00c838:	0007883a 	mov	r3,zero
 d00c83c:	003ff806 	br	d00c820 <udivmodsi4+0x50>
 d00c840:	00800044 	movi	r2,1
 d00c844:	0007883a 	mov	r3,zero
 d00c848:	003fef06 	br	d00c808 <udivmodsi4+0x38>

0d00c84c <__divsi3>:
 d00c84c:	defffe04 	addi	sp,sp,-8
 d00c850:	dc000015 	stw	r16,0(sp)
 d00c854:	dfc00115 	stw	ra,4(sp)
 d00c858:	0021883a 	mov	r16,zero
 d00c85c:	20000c16 	blt	r4,zero,d00c890 <__divsi3+0x44>
 d00c860:	000d883a 	mov	r6,zero
 d00c864:	28000e16 	blt	r5,zero,d00c8a0 <__divsi3+0x54>
 d00c868:	d00c7d00 	call	d00c7d0 <udivmodsi4>
 d00c86c:	1007883a 	mov	r3,r2
 d00c870:	8005003a 	cmpeq	r2,r16,zero
 d00c874:	1000011e 	bne	r2,zero,d00c87c <__divsi3+0x30>
 d00c878:	00c7c83a 	sub	r3,zero,r3
 d00c87c:	1805883a 	mov	r2,r3
 d00c880:	dfc00117 	ldw	ra,4(sp)
 d00c884:	dc000017 	ldw	r16,0(sp)
 d00c888:	dec00204 	addi	sp,sp,8
 d00c88c:	f800283a 	ret
 d00c890:	0109c83a 	sub	r4,zero,r4
 d00c894:	04000044 	movi	r16,1
 d00c898:	000d883a 	mov	r6,zero
 d00c89c:	283ff20e 	bge	r5,zero,d00c868 <__divsi3+0x1c>
 d00c8a0:	014bc83a 	sub	r5,zero,r5
 d00c8a4:	8021003a 	cmpeq	r16,r16,zero
 d00c8a8:	003fef06 	br	d00c868 <__divsi3+0x1c>

0d00c8ac <__modsi3>:
 d00c8ac:	deffff04 	addi	sp,sp,-4
 d00c8b0:	dfc00015 	stw	ra,0(sp)
 d00c8b4:	01800044 	movi	r6,1
 d00c8b8:	2807883a 	mov	r3,r5
 d00c8bc:	20000416 	blt	r4,zero,d00c8d0 <__modsi3+0x24>
 d00c8c0:	28000c16 	blt	r5,zero,d00c8f4 <__modsi3+0x48>
 d00c8c4:	dfc00017 	ldw	ra,0(sp)
 d00c8c8:	dec00104 	addi	sp,sp,4
 d00c8cc:	d00c7d01 	jmpi	d00c7d0 <udivmodsi4>
 d00c8d0:	0109c83a 	sub	r4,zero,r4
 d00c8d4:	28000b16 	blt	r5,zero,d00c904 <__modsi3+0x58>
 d00c8d8:	180b883a 	mov	r5,r3
 d00c8dc:	01800044 	movi	r6,1
 d00c8e0:	d00c7d00 	call	d00c7d0 <udivmodsi4>
 d00c8e4:	0085c83a 	sub	r2,zero,r2
 d00c8e8:	dfc00017 	ldw	ra,0(sp)
 d00c8ec:	dec00104 	addi	sp,sp,4
 d00c8f0:	f800283a 	ret
 d00c8f4:	014bc83a 	sub	r5,zero,r5
 d00c8f8:	dfc00017 	ldw	ra,0(sp)
 d00c8fc:	dec00104 	addi	sp,sp,4
 d00c900:	d00c7d01 	jmpi	d00c7d0 <udivmodsi4>
 d00c904:	0147c83a 	sub	r3,zero,r5
 d00c908:	003ff306 	br	d00c8d8 <__modsi3+0x2c>

0d00c90c <__udivsi3>:
 d00c90c:	000d883a 	mov	r6,zero
 d00c910:	d00c7d01 	jmpi	d00c7d0 <udivmodsi4>

0d00c914 <__umodsi3>:
 d00c914:	01800044 	movi	r6,1
 d00c918:	d00c7d01 	jmpi	d00c7d0 <udivmodsi4>

0d00c91c <__muldi3>:
 d00c91c:	defff204 	addi	sp,sp,-56
 d00c920:	df000c15 	stw	fp,48(sp)
 d00c924:	3038d43a 	srli	fp,r6,16
 d00c928:	dd000815 	stw	r20,32(sp)
 d00c92c:	dc400515 	stw	r17,20(sp)
 d00c930:	2028d43a 	srli	r20,r4,16
 d00c934:	247fffcc 	andi	r17,r4,65535
 d00c938:	dc000415 	stw	r16,16(sp)
 d00c93c:	343fffcc 	andi	r16,r6,65535
 d00c940:	dcc00715 	stw	r19,28(sp)
 d00c944:	d9000015 	stw	r4,0(sp)
 d00c948:	2827883a 	mov	r19,r5
 d00c94c:	8809883a 	mov	r4,r17
 d00c950:	d9400115 	stw	r5,4(sp)
 d00c954:	800b883a 	mov	r5,r16
 d00c958:	d9800215 	stw	r6,8(sp)
 d00c95c:	dfc00d15 	stw	ra,52(sp)
 d00c960:	d9c00315 	stw	r7,12(sp)
 d00c964:	dd800a15 	stw	r22,40(sp)
 d00c968:	dd400915 	stw	r21,36(sp)
 d00c96c:	302d883a 	mov	r22,r6
 d00c970:	ddc00b15 	stw	r23,44(sp)
 d00c974:	dc800615 	stw	r18,24(sp)
 d00c978:	d00235c0 	call	d00235c <__mulsi3>
 d00c97c:	8809883a 	mov	r4,r17
 d00c980:	e00b883a 	mov	r5,fp
 d00c984:	102b883a 	mov	r21,r2
 d00c988:	d00235c0 	call	d00235c <__mulsi3>
 d00c98c:	800b883a 	mov	r5,r16
 d00c990:	a009883a 	mov	r4,r20
 d00c994:	1023883a 	mov	r17,r2
 d00c998:	d00235c0 	call	d00235c <__mulsi3>
 d00c99c:	a009883a 	mov	r4,r20
 d00c9a0:	e00b883a 	mov	r5,fp
 d00c9a4:	1021883a 	mov	r16,r2
 d00c9a8:	d00235c0 	call	d00235c <__mulsi3>
 d00c9ac:	a8ffffcc 	andi	r3,r21,65535
 d00c9b0:	a82ad43a 	srli	r21,r21,16
 d00c9b4:	8c23883a 	add	r17,r17,r16
 d00c9b8:	1011883a 	mov	r8,r2
 d00c9bc:	ac6b883a 	add	r21,r21,r17
 d00c9c0:	a804943a 	slli	r2,r21,16
 d00c9c4:	b009883a 	mov	r4,r22
 d00c9c8:	980b883a 	mov	r5,r19
 d00c9cc:	10c7883a 	add	r3,r2,r3
 d00c9d0:	a812d43a 	srli	r9,r21,16
 d00c9d4:	180d883a 	mov	r6,r3
 d00c9d8:	ac00022e 	bgeu	r21,r16,d00c9e4 <__muldi3+0xc8>
 d00c9dc:	00800074 	movhi	r2,1
 d00c9e0:	4091883a 	add	r8,r8,r2
 d00c9e4:	4267883a 	add	r19,r8,r9
 d00c9e8:	302d883a 	mov	r22,r6
 d00c9ec:	d00235c0 	call	d00235c <__mulsi3>
 d00c9f0:	d9400317 	ldw	r5,12(sp)
 d00c9f4:	d9000017 	ldw	r4,0(sp)
 d00c9f8:	1023883a 	mov	r17,r2
 d00c9fc:	d00235c0 	call	d00235c <__mulsi3>
 d00ca00:	14cb883a 	add	r5,r2,r19
 d00ca04:	894b883a 	add	r5,r17,r5
 d00ca08:	b005883a 	mov	r2,r22
 d00ca0c:	2807883a 	mov	r3,r5
 d00ca10:	dfc00d17 	ldw	ra,52(sp)
 d00ca14:	df000c17 	ldw	fp,48(sp)
 d00ca18:	ddc00b17 	ldw	r23,44(sp)
 d00ca1c:	dd800a17 	ldw	r22,40(sp)
 d00ca20:	dd400917 	ldw	r21,36(sp)
 d00ca24:	dd000817 	ldw	r20,32(sp)
 d00ca28:	dcc00717 	ldw	r19,28(sp)
 d00ca2c:	dc800617 	ldw	r18,24(sp)
 d00ca30:	dc400517 	ldw	r17,20(sp)
 d00ca34:	dc000417 	ldw	r16,16(sp)
 d00ca38:	dec00e04 	addi	sp,sp,56
 d00ca3c:	f800283a 	ret

0d00ca40 <__clzsi2>:
 d00ca40:	00bfffd4 	movui	r2,65535
 d00ca44:	11000e36 	bltu	r2,r4,d00ca80 <__clzsi2+0x40>
 d00ca48:	00803fc4 	movi	r2,255
 d00ca4c:	01400204 	movi	r5,8
 d00ca50:	0007883a 	mov	r3,zero
 d00ca54:	11001036 	bltu	r2,r4,d00ca98 <__clzsi2+0x58>
 d00ca58:	000b883a 	mov	r5,zero
 d00ca5c:	20c6d83a 	srl	r3,r4,r3
 d00ca60:	00834174 	movhi	r2,3333
 d00ca64:	10b93204 	addi	r2,r2,-6968
 d00ca68:	1887883a 	add	r3,r3,r2
 d00ca6c:	18800003 	ldbu	r2,0(r3)
 d00ca70:	00c00804 	movi	r3,32
 d00ca74:	2885883a 	add	r2,r5,r2
 d00ca78:	1885c83a 	sub	r2,r3,r2
 d00ca7c:	f800283a 	ret
 d00ca80:	01400404 	movi	r5,16
 d00ca84:	00804034 	movhi	r2,256
 d00ca88:	10bfffc4 	addi	r2,r2,-1
 d00ca8c:	2807883a 	mov	r3,r5
 d00ca90:	113ff22e 	bgeu	r2,r4,d00ca5c <__clzsi2+0x1c>
 d00ca94:	01400604 	movi	r5,24
 d00ca98:	2807883a 	mov	r3,r5
 d00ca9c:	20c6d83a 	srl	r3,r4,r3
 d00caa0:	00834174 	movhi	r2,3333
 d00caa4:	10b93204 	addi	r2,r2,-6968
 d00caa8:	1887883a 	add	r3,r3,r2
 d00caac:	18800003 	ldbu	r2,0(r3)
 d00cab0:	00c00804 	movi	r3,32
 d00cab4:	2885883a 	add	r2,r5,r2
 d00cab8:	1885c83a 	sub	r2,r3,r2
 d00cabc:	f800283a 	ret

0d00cac0 <__pack_d>:
 d00cac0:	20c00017 	ldw	r3,0(r4)
 d00cac4:	defffd04 	addi	sp,sp,-12
 d00cac8:	dc000015 	stw	r16,0(sp)
 d00cacc:	dc800215 	stw	r18,8(sp)
 d00cad0:	dc400115 	stw	r17,4(sp)
 d00cad4:	00800044 	movi	r2,1
 d00cad8:	22000317 	ldw	r8,12(r4)
 d00cadc:	001f883a 	mov	r15,zero
 d00cae0:	22400417 	ldw	r9,16(r4)
 d00cae4:	24000117 	ldw	r16,4(r4)
 d00cae8:	10c0552e 	bgeu	r2,r3,d00cc40 <__pack_d+0x180>
 d00caec:	00800104 	movi	r2,4
 d00caf0:	18804f26 	beq	r3,r2,d00cc30 <__pack_d+0x170>
 d00caf4:	00800084 	movi	r2,2
 d00caf8:	18800226 	beq	r3,r2,d00cb04 <__pack_d+0x44>
 d00cafc:	4244b03a 	or	r2,r8,r9
 d00cb00:	10001a1e 	bne	r2,zero,d00cb6c <__pack_d+0xac>
 d00cb04:	000d883a 	mov	r6,zero
 d00cb08:	000f883a 	mov	r7,zero
 d00cb0c:	0011883a 	mov	r8,zero
 d00cb10:	00800434 	movhi	r2,16
 d00cb14:	10bfffc4 	addi	r2,r2,-1
 d00cb18:	301d883a 	mov	r14,r6
 d00cb1c:	3884703a 	and	r2,r7,r2
 d00cb20:	400a953a 	slli	r5,r8,20
 d00cb24:	79bffc2c 	andhi	r6,r15,65520
 d00cb28:	308cb03a 	or	r6,r6,r2
 d00cb2c:	00e00434 	movhi	r3,32784
 d00cb30:	18ffffc4 	addi	r3,r3,-1
 d00cb34:	800497fa 	slli	r2,r16,31
 d00cb38:	30c6703a 	and	r3,r6,r3
 d00cb3c:	1946b03a 	or	r3,r3,r5
 d00cb40:	01600034 	movhi	r5,32768
 d00cb44:	297fffc4 	addi	r5,r5,-1
 d00cb48:	194a703a 	and	r5,r3,r5
 d00cb4c:	288ab03a 	or	r5,r5,r2
 d00cb50:	2807883a 	mov	r3,r5
 d00cb54:	7005883a 	mov	r2,r14
 d00cb58:	dc800217 	ldw	r18,8(sp)
 d00cb5c:	dc400117 	ldw	r17,4(sp)
 d00cb60:	dc000017 	ldw	r16,0(sp)
 d00cb64:	dec00304 	addi	sp,sp,12
 d00cb68:	f800283a 	ret
 d00cb6c:	21000217 	ldw	r4,8(r4)
 d00cb70:	00bf0084 	movi	r2,-1022
 d00cb74:	20803f16 	blt	r4,r2,d00cc74 <__pack_d+0x1b4>
 d00cb78:	0080ffc4 	movi	r2,1023
 d00cb7c:	11002c16 	blt	r2,r4,d00cc30 <__pack_d+0x170>
 d00cb80:	00803fc4 	movi	r2,255
 d00cb84:	408c703a 	and	r6,r8,r2
 d00cb88:	00802004 	movi	r2,128
 d00cb8c:	0007883a 	mov	r3,zero
 d00cb90:	000f883a 	mov	r7,zero
 d00cb94:	2280ffc4 	addi	r10,r4,1023
 d00cb98:	30801e26 	beq	r6,r2,d00cc14 <__pack_d+0x154>
 d00cb9c:	00801fc4 	movi	r2,127
 d00cba0:	4089883a 	add	r4,r8,r2
 d00cba4:	220d803a 	cmpltu	r6,r4,r8
 d00cba8:	324d883a 	add	r6,r6,r9
 d00cbac:	2011883a 	mov	r8,r4
 d00cbb0:	3013883a 	mov	r9,r6
 d00cbb4:	00880034 	movhi	r2,8192
 d00cbb8:	10bfffc4 	addi	r2,r2,-1
 d00cbbc:	12400d36 	bltu	r2,r9,d00cbf4 <__pack_d+0x134>
 d00cbc0:	4804963a 	slli	r2,r9,24
 d00cbc4:	400cd23a 	srli	r6,r8,8
 d00cbc8:	480ed23a 	srli	r7,r9,8
 d00cbcc:	013fffc4 	movi	r4,-1
 d00cbd0:	118cb03a 	or	r6,r2,r6
 d00cbd4:	01400434 	movhi	r5,16
 d00cbd8:	297fffc4 	addi	r5,r5,-1
 d00cbdc:	3104703a 	and	r2,r6,r4
 d00cbe0:	3946703a 	and	r3,r7,r5
 d00cbe4:	5201ffcc 	andi	r8,r10,2047
 d00cbe8:	100d883a 	mov	r6,r2
 d00cbec:	180f883a 	mov	r7,r3
 d00cbf0:	003fc706 	br	d00cb10 <__pack_d+0x50>
 d00cbf4:	480897fa 	slli	r4,r9,31
 d00cbf8:	4004d07a 	srli	r2,r8,1
 d00cbfc:	4806d07a 	srli	r3,r9,1
 d00cc00:	52800044 	addi	r10,r10,1
 d00cc04:	2084b03a 	or	r2,r4,r2
 d00cc08:	1011883a 	mov	r8,r2
 d00cc0c:	1813883a 	mov	r9,r3
 d00cc10:	003feb06 	br	d00cbc0 <__pack_d+0x100>
 d00cc14:	383fe11e 	bne	r7,zero,d00cb9c <__pack_d+0xdc>
 d00cc18:	01004004 	movi	r4,256
 d00cc1c:	4104703a 	and	r2,r8,r4
 d00cc20:	10c4b03a 	or	r2,r2,r3
 d00cc24:	103fe326 	beq	r2,zero,d00cbb4 <__pack_d+0xf4>
 d00cc28:	3005883a 	mov	r2,r6
 d00cc2c:	003fdc06 	br	d00cba0 <__pack_d+0xe0>
 d00cc30:	000d883a 	mov	r6,zero
 d00cc34:	000f883a 	mov	r7,zero
 d00cc38:	0201ffc4 	movi	r8,2047
 d00cc3c:	003fb406 	br	d00cb10 <__pack_d+0x50>
 d00cc40:	0005883a 	mov	r2,zero
 d00cc44:	00c00234 	movhi	r3,8
 d00cc48:	408cb03a 	or	r6,r8,r2
 d00cc4c:	48ceb03a 	or	r7,r9,r3
 d00cc50:	013fffc4 	movi	r4,-1
 d00cc54:	01400434 	movhi	r5,16
 d00cc58:	297fffc4 	addi	r5,r5,-1
 d00cc5c:	3104703a 	and	r2,r6,r4
 d00cc60:	3946703a 	and	r3,r7,r5
 d00cc64:	100d883a 	mov	r6,r2
 d00cc68:	180f883a 	mov	r7,r3
 d00cc6c:	0201ffc4 	movi	r8,2047
 d00cc70:	003fa706 	br	d00cb10 <__pack_d+0x50>
 d00cc74:	1109c83a 	sub	r4,r2,r4
 d00cc78:	00800e04 	movi	r2,56
 d00cc7c:	11004316 	blt	r2,r4,d00cd8c <__pack_d+0x2cc>
 d00cc80:	21fff804 	addi	r7,r4,-32
 d00cc84:	38004516 	blt	r7,zero,d00cd9c <__pack_d+0x2dc>
 d00cc88:	49d8d83a 	srl	r12,r9,r7
 d00cc8c:	001b883a 	mov	r13,zero
 d00cc90:	0023883a 	mov	r17,zero
 d00cc94:	01400044 	movi	r5,1
 d00cc98:	0025883a 	mov	r18,zero
 d00cc9c:	38004716 	blt	r7,zero,d00cdbc <__pack_d+0x2fc>
 d00cca0:	29d6983a 	sll	r11,r5,r7
 d00cca4:	0015883a 	mov	r10,zero
 d00cca8:	00bfffc4 	movi	r2,-1
 d00ccac:	5089883a 	add	r4,r10,r2
 d00ccb0:	588b883a 	add	r5,r11,r2
 d00ccb4:	228d803a 	cmpltu	r6,r4,r10
 d00ccb8:	314b883a 	add	r5,r6,r5
 d00ccbc:	4104703a 	and	r2,r8,r4
 d00ccc0:	4946703a 	and	r3,r9,r5
 d00ccc4:	10c4b03a 	or	r2,r2,r3
 d00ccc8:	10000226 	beq	r2,zero,d00ccd4 <__pack_d+0x214>
 d00cccc:	04400044 	movi	r17,1
 d00ccd0:	0025883a 	mov	r18,zero
 d00ccd4:	00803fc4 	movi	r2,255
 d00ccd8:	644eb03a 	or	r7,r12,r17
 d00ccdc:	3892703a 	and	r9,r7,r2
 d00cce0:	00802004 	movi	r2,128
 d00cce4:	6c90b03a 	or	r8,r13,r18
 d00cce8:	0015883a 	mov	r10,zero
 d00ccec:	48801626 	beq	r9,r2,d00cd48 <__pack_d+0x288>
 d00ccf0:	01001fc4 	movi	r4,127
 d00ccf4:	3905883a 	add	r2,r7,r4
 d00ccf8:	11cd803a 	cmpltu	r6,r2,r7
 d00ccfc:	320d883a 	add	r6,r6,r8
 d00cd00:	100f883a 	mov	r7,r2
 d00cd04:	00840034 	movhi	r2,4096
 d00cd08:	10bfffc4 	addi	r2,r2,-1
 d00cd0c:	3011883a 	mov	r8,r6
 d00cd10:	0007883a 	mov	r3,zero
 d00cd14:	11801b36 	bltu	r2,r6,d00cd84 <__pack_d+0x2c4>
 d00cd18:	4004963a 	slli	r2,r8,24
 d00cd1c:	3808d23a 	srli	r4,r7,8
 d00cd20:	400ad23a 	srli	r5,r8,8
 d00cd24:	1813883a 	mov	r9,r3
 d00cd28:	1108b03a 	or	r4,r2,r4
 d00cd2c:	00bfffc4 	movi	r2,-1
 d00cd30:	00c00434 	movhi	r3,16
 d00cd34:	18ffffc4 	addi	r3,r3,-1
 d00cd38:	208c703a 	and	r6,r4,r2
 d00cd3c:	28ce703a 	and	r7,r5,r3
 d00cd40:	4a01ffcc 	andi	r8,r9,2047
 d00cd44:	003f7206 	br	d00cb10 <__pack_d+0x50>
 d00cd48:	503fe91e 	bne	r10,zero,d00ccf0 <__pack_d+0x230>
 d00cd4c:	01004004 	movi	r4,256
 d00cd50:	3904703a 	and	r2,r7,r4
 d00cd54:	0007883a 	mov	r3,zero
 d00cd58:	10c4b03a 	or	r2,r2,r3
 d00cd5c:	10000626 	beq	r2,zero,d00cd78 <__pack_d+0x2b8>
 d00cd60:	3a45883a 	add	r2,r7,r9
 d00cd64:	11cd803a 	cmpltu	r6,r2,r7
 d00cd68:	320d883a 	add	r6,r6,r8
 d00cd6c:	100f883a 	mov	r7,r2
 d00cd70:	3011883a 	mov	r8,r6
 d00cd74:	0007883a 	mov	r3,zero
 d00cd78:	00840034 	movhi	r2,4096
 d00cd7c:	10bfffc4 	addi	r2,r2,-1
 d00cd80:	123fe52e 	bgeu	r2,r8,d00cd18 <__pack_d+0x258>
 d00cd84:	00c00044 	movi	r3,1
 d00cd88:	003fe306 	br	d00cd18 <__pack_d+0x258>
 d00cd8c:	0009883a 	mov	r4,zero
 d00cd90:	0013883a 	mov	r9,zero
 d00cd94:	000b883a 	mov	r5,zero
 d00cd98:	003fe406 	br	d00cd2c <__pack_d+0x26c>
 d00cd9c:	4a47883a 	add	r3,r9,r9
 d00cda0:	008007c4 	movi	r2,31
 d00cda4:	1105c83a 	sub	r2,r2,r4
 d00cda8:	1886983a 	sll	r3,r3,r2
 d00cdac:	4118d83a 	srl	r12,r8,r4
 d00cdb0:	491ad83a 	srl	r13,r9,r4
 d00cdb4:	1b18b03a 	or	r12,r3,r12
 d00cdb8:	003fb506 	br	d00cc90 <__pack_d+0x1d0>
 d00cdbc:	2806d07a 	srli	r3,r5,1
 d00cdc0:	008007c4 	movi	r2,31
 d00cdc4:	1105c83a 	sub	r2,r2,r4
 d00cdc8:	1896d83a 	srl	r11,r3,r2
 d00cdcc:	2914983a 	sll	r10,r5,r4
 d00cdd0:	003fb506 	br	d00cca8 <__pack_d+0x1e8>

0d00cdd4 <__unpack_d>:
 d00cdd4:	20c00117 	ldw	r3,4(r4)
 d00cdd8:	22400017 	ldw	r9,0(r4)
 d00cddc:	00800434 	movhi	r2,16
 d00cde0:	10bfffc4 	addi	r2,r2,-1
 d00cde4:	1808d53a 	srli	r4,r3,20
 d00cde8:	180cd7fa 	srli	r6,r3,31
 d00cdec:	1894703a 	and	r10,r3,r2
 d00cdf0:	2201ffcc 	andi	r8,r4,2047
 d00cdf4:	281b883a 	mov	r13,r5
 d00cdf8:	4817883a 	mov	r11,r9
 d00cdfc:	29800115 	stw	r6,4(r5)
 d00ce00:	5019883a 	mov	r12,r10
 d00ce04:	40001e1e 	bne	r8,zero,d00ce80 <__unpack_d+0xac>
 d00ce08:	4a84b03a 	or	r2,r9,r10
 d00ce0c:	10001926 	beq	r2,zero,d00ce74 <__unpack_d+0xa0>
 d00ce10:	4804d63a 	srli	r2,r9,24
 d00ce14:	500c923a 	slli	r6,r10,8
 d00ce18:	013f0084 	movi	r4,-1022
 d00ce1c:	00c40034 	movhi	r3,4096
 d00ce20:	18ffffc4 	addi	r3,r3,-1
 d00ce24:	118cb03a 	or	r6,r2,r6
 d00ce28:	008000c4 	movi	r2,3
 d00ce2c:	480a923a 	slli	r5,r9,8
 d00ce30:	68800015 	stw	r2,0(r13)
 d00ce34:	69000215 	stw	r4,8(r13)
 d00ce38:	19800b36 	bltu	r3,r6,d00ce68 <__unpack_d+0x94>
 d00ce3c:	200f883a 	mov	r7,r4
 d00ce40:	1811883a 	mov	r8,r3
 d00ce44:	2945883a 	add	r2,r5,r5
 d00ce48:	1149803a 	cmpltu	r4,r2,r5
 d00ce4c:	3187883a 	add	r3,r6,r6
 d00ce50:	20c9883a 	add	r4,r4,r3
 d00ce54:	100b883a 	mov	r5,r2
 d00ce58:	200d883a 	mov	r6,r4
 d00ce5c:	39ffffc4 	addi	r7,r7,-1
 d00ce60:	413ff82e 	bgeu	r8,r4,d00ce44 <__unpack_d+0x70>
 d00ce64:	69c00215 	stw	r7,8(r13)
 d00ce68:	69800415 	stw	r6,16(r13)
 d00ce6c:	69400315 	stw	r5,12(r13)
 d00ce70:	f800283a 	ret
 d00ce74:	00800084 	movi	r2,2
 d00ce78:	28800015 	stw	r2,0(r5)
 d00ce7c:	f800283a 	ret
 d00ce80:	0081ffc4 	movi	r2,2047
 d00ce84:	40800f26 	beq	r8,r2,d00cec4 <__unpack_d+0xf0>
 d00ce88:	480cd63a 	srli	r6,r9,24
 d00ce8c:	5006923a 	slli	r3,r10,8
 d00ce90:	4804923a 	slli	r2,r9,8
 d00ce94:	0009883a 	mov	r4,zero
 d00ce98:	30c6b03a 	or	r3,r6,r3
 d00ce9c:	01440034 	movhi	r5,4096
 d00cea0:	110cb03a 	or	r6,r2,r4
 d00cea4:	423f0044 	addi	r8,r8,-1023
 d00cea8:	194eb03a 	or	r7,r3,r5
 d00ceac:	008000c4 	movi	r2,3
 d00ceb0:	69c00415 	stw	r7,16(r13)
 d00ceb4:	6a000215 	stw	r8,8(r13)
 d00ceb8:	68800015 	stw	r2,0(r13)
 d00cebc:	69800315 	stw	r6,12(r13)
 d00cec0:	f800283a 	ret
 d00cec4:	4a84b03a 	or	r2,r9,r10
 d00cec8:	1000031e 	bne	r2,zero,d00ced8 <__unpack_d+0x104>
 d00cecc:	00800104 	movi	r2,4
 d00ced0:	28800015 	stw	r2,0(r5)
 d00ced4:	f800283a 	ret
 d00ced8:	0009883a 	mov	r4,zero
 d00cedc:	01400234 	movhi	r5,8
 d00cee0:	4904703a 	and	r2,r9,r4
 d00cee4:	5146703a 	and	r3,r10,r5
 d00cee8:	10c4b03a 	or	r2,r2,r3
 d00ceec:	10000526 	beq	r2,zero,d00cf04 <__unpack_d+0x130>
 d00cef0:	00800044 	movi	r2,1
 d00cef4:	68800015 	stw	r2,0(r13)
 d00cef8:	6b000415 	stw	r12,16(r13)
 d00cefc:	6ac00315 	stw	r11,12(r13)
 d00cf00:	f800283a 	ret
 d00cf04:	68000015 	stw	zero,0(r13)
 d00cf08:	003ffb06 	br	d00cef8 <__unpack_d+0x124>

0d00cf0c <__fpcmp_parts_d>:
 d00cf0c:	21800017 	ldw	r6,0(r4)
 d00cf10:	00c00044 	movi	r3,1
 d00cf14:	19800a2e 	bgeu	r3,r6,d00cf40 <__fpcmp_parts_d+0x34>
 d00cf18:	28800017 	ldw	r2,0(r5)
 d00cf1c:	1880082e 	bgeu	r3,r2,d00cf40 <__fpcmp_parts_d+0x34>
 d00cf20:	00c00104 	movi	r3,4
 d00cf24:	30c02626 	beq	r6,r3,d00cfc0 <__fpcmp_parts_d+0xb4>
 d00cf28:	10c02226 	beq	r2,r3,d00cfb4 <__fpcmp_parts_d+0xa8>
 d00cf2c:	00c00084 	movi	r3,2
 d00cf30:	30c00526 	beq	r6,r3,d00cf48 <__fpcmp_parts_d+0x3c>
 d00cf34:	10c0071e 	bne	r2,r3,d00cf54 <__fpcmp_parts_d+0x48>
 d00cf38:	20800117 	ldw	r2,4(r4)
 d00cf3c:	1000091e 	bne	r2,zero,d00cf64 <__fpcmp_parts_d+0x58>
 d00cf40:	00800044 	movi	r2,1
 d00cf44:	f800283a 	ret
 d00cf48:	10c01a1e 	bne	r2,r3,d00cfb4 <__fpcmp_parts_d+0xa8>
 d00cf4c:	0005883a 	mov	r2,zero
 d00cf50:	f800283a 	ret
 d00cf54:	22000117 	ldw	r8,4(r4)
 d00cf58:	28800117 	ldw	r2,4(r5)
 d00cf5c:	40800326 	beq	r8,r2,d00cf6c <__fpcmp_parts_d+0x60>
 d00cf60:	403ff726 	beq	r8,zero,d00cf40 <__fpcmp_parts_d+0x34>
 d00cf64:	00bfffc4 	movi	r2,-1
 d00cf68:	f800283a 	ret
 d00cf6c:	20c00217 	ldw	r3,8(r4)
 d00cf70:	28800217 	ldw	r2,8(r5)
 d00cf74:	10fffa16 	blt	r2,r3,d00cf60 <__fpcmp_parts_d+0x54>
 d00cf78:	18800916 	blt	r3,r2,d00cfa0 <__fpcmp_parts_d+0x94>
 d00cf7c:	21c00417 	ldw	r7,16(r4)
 d00cf80:	28c00417 	ldw	r3,16(r5)
 d00cf84:	21800317 	ldw	r6,12(r4)
 d00cf88:	28800317 	ldw	r2,12(r5)
 d00cf8c:	19fff436 	bltu	r3,r7,d00cf60 <__fpcmp_parts_d+0x54>
 d00cf90:	38c00526 	beq	r7,r3,d00cfa8 <__fpcmp_parts_d+0x9c>
 d00cf94:	38c00236 	bltu	r7,r3,d00cfa0 <__fpcmp_parts_d+0x94>
 d00cf98:	19ffec1e 	bne	r3,r7,d00cf4c <__fpcmp_parts_d+0x40>
 d00cf9c:	30bfeb2e 	bgeu	r6,r2,d00cf4c <__fpcmp_parts_d+0x40>
 d00cfa0:	403fe71e 	bne	r8,zero,d00cf40 <__fpcmp_parts_d+0x34>
 d00cfa4:	003fef06 	br	d00cf64 <__fpcmp_parts_d+0x58>
 d00cfa8:	11bffa2e 	bgeu	r2,r6,d00cf94 <__fpcmp_parts_d+0x88>
 d00cfac:	403fe426 	beq	r8,zero,d00cf40 <__fpcmp_parts_d+0x34>
 d00cfb0:	003fec06 	br	d00cf64 <__fpcmp_parts_d+0x58>
 d00cfb4:	28800117 	ldw	r2,4(r5)
 d00cfb8:	103fe11e 	bne	r2,zero,d00cf40 <__fpcmp_parts_d+0x34>
 d00cfbc:	003fe906 	br	d00cf64 <__fpcmp_parts_d+0x58>
 d00cfc0:	11bfdd1e 	bne	r2,r6,d00cf38 <__fpcmp_parts_d+0x2c>
 d00cfc4:	28c00117 	ldw	r3,4(r5)
 d00cfc8:	20800117 	ldw	r2,4(r4)
 d00cfcc:	1885c83a 	sub	r2,r3,r2
 d00cfd0:	f800283a 	ret

0d00cfd4 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 d00cfd4:	defffb04 	addi	sp,sp,-20
 d00cfd8:	dfc00415 	stw	ra,16(sp)
 d00cfdc:	df000315 	stw	fp,12(sp)
 d00cfe0:	df000304 	addi	fp,sp,12
 d00cfe4:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 d00cfe8:	e13ffe17 	ldw	r4,-8(fp)
 d00cfec:	d1600704 	addi	r5,gp,-32740
 d00cff0:	d03538c0 	call	d03538c <alt_find_dev>
 d00cff4:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 d00cff8:	e0bffd17 	ldw	r2,-12(fp)
 d00cffc:	1005003a 	cmpeq	r2,r2,zero
 d00d000:	10000b1e 	bne	r2,zero,d00d030 <alt_flash_open_dev+0x5c>
 d00d004:	e0bffd17 	ldw	r2,-12(fp)
 d00d008:	10800317 	ldw	r2,12(r2)
 d00d00c:	1005003a 	cmpeq	r2,r2,zero
 d00d010:	1000071e 	bne	r2,zero,d00d030 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 d00d014:	e0bffd17 	ldw	r2,-12(fp)
 d00d018:	10800317 	ldw	r2,12(r2)
 d00d01c:	e13ffd17 	ldw	r4,-12(fp)
 d00d020:	e17ffe17 	ldw	r5,-8(fp)
 d00d024:	103ee83a 	callr	r2
 d00d028:	e0bfff15 	stw	r2,-4(fp)
 d00d02c:	00000206 	br	d00d038 <alt_flash_open_dev+0x64>
  }

  return dev;
 d00d030:	e0bffd17 	ldw	r2,-12(fp)
 d00d034:	e0bfff15 	stw	r2,-4(fp)
 d00d038:	e0bfff17 	ldw	r2,-4(fp)
}
 d00d03c:	e037883a 	mov	sp,fp
 d00d040:	dfc00117 	ldw	ra,4(sp)
 d00d044:	df000017 	ldw	fp,0(sp)
 d00d048:	dec00204 	addi	sp,sp,8
 d00d04c:	f800283a 	ret

0d00d050 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 d00d050:	defffd04 	addi	sp,sp,-12
 d00d054:	dfc00215 	stw	ra,8(sp)
 d00d058:	df000115 	stw	fp,4(sp)
 d00d05c:	df000104 	addi	fp,sp,4
 d00d060:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 d00d064:	e0bfff17 	ldw	r2,-4(fp)
 d00d068:	1005003a 	cmpeq	r2,r2,zero
 d00d06c:	1000081e 	bne	r2,zero,d00d090 <alt_flash_close_dev+0x40>
 d00d070:	e0bfff17 	ldw	r2,-4(fp)
 d00d074:	10800417 	ldw	r2,16(r2)
 d00d078:	1005003a 	cmpeq	r2,r2,zero
 d00d07c:	1000041e 	bne	r2,zero,d00d090 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 d00d080:	e0bfff17 	ldw	r2,-4(fp)
 d00d084:	10800417 	ldw	r2,16(r2)
 d00d088:	e13fff17 	ldw	r4,-4(fp)
 d00d08c:	103ee83a 	callr	r2
  }
  return;
}
 d00d090:	e037883a 	mov	sp,fp
 d00d094:	dfc00117 	ldw	ra,4(sp)
 d00d098:	df000017 	ldw	fp,0(sp)
 d00d09c:	dec00204 	addi	sp,sp,8
 d00d0a0:	f800283a 	ret

0d00d0a4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 d00d0a4:	defff904 	addi	sp,sp,-28
 d00d0a8:	dfc00615 	stw	ra,24(sp)
 d00d0ac:	df000515 	stw	fp,20(sp)
 d00d0b0:	df000504 	addi	fp,sp,20
 d00d0b4:	e13ffc15 	stw	r4,-16(fp)
 d00d0b8:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d00d0bc:	e0bffc17 	ldw	r2,-16(fp)
 d00d0c0:	1004803a 	cmplt	r2,r2,zero
 d00d0c4:	1000091e 	bne	r2,zero,d00d0ec <fstat+0x48>
 d00d0c8:	e13ffc17 	ldw	r4,-16(fp)
 d00d0cc:	01400304 	movi	r5,12
 d00d0d0:	d00235c0 	call	d00235c <__mulsi3>
 d00d0d4:	1007883a 	mov	r3,r2
 d00d0d8:	00834174 	movhi	r2,3333
 d00d0dc:	10915b04 	addi	r2,r2,17772
 d00d0e0:	1887883a 	add	r3,r3,r2
 d00d0e4:	e0ffff15 	stw	r3,-4(fp)
 d00d0e8:	00000106 	br	d00d0f0 <fstat+0x4c>
 d00d0ec:	e03fff15 	stw	zero,-4(fp)
 d00d0f0:	e0bfff17 	ldw	r2,-4(fp)
 d00d0f4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 d00d0f8:	e0bffb17 	ldw	r2,-20(fp)
 d00d0fc:	1005003a 	cmpeq	r2,r2,zero
 d00d100:	1000121e 	bne	r2,zero,d00d14c <fstat+0xa8>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 d00d104:	e0bffb17 	ldw	r2,-20(fp)
 d00d108:	10800017 	ldw	r2,0(r2)
 d00d10c:	10800817 	ldw	r2,32(r2)
 d00d110:	1005003a 	cmpeq	r2,r2,zero
 d00d114:	1000081e 	bne	r2,zero,d00d138 <fstat+0x94>
    {
      return fd->dev->fstat(fd, st);
 d00d118:	e0bffb17 	ldw	r2,-20(fp)
 d00d11c:	10800017 	ldw	r2,0(r2)
 d00d120:	10800817 	ldw	r2,32(r2)
 d00d124:	e13ffb17 	ldw	r4,-20(fp)
 d00d128:	e17ffd17 	ldw	r5,-12(fp)
 d00d12c:	103ee83a 	callr	r2
 d00d130:	e0bffe15 	stw	r2,-8(fp)
 d00d134:	00000b06 	br	d00d164 <fstat+0xc0>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 d00d138:	e0fffd17 	ldw	r3,-12(fp)
 d00d13c:	00880004 	movi	r2,8192
 d00d140:	18800115 	stw	r2,4(r3)
      return 0;
 d00d144:	e03ffe15 	stw	zero,-8(fp)
 d00d148:	00000606 	br	d00d164 <fstat+0xc0>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 d00d14c:	d00d17c0 	call	d00d17c <alt_get_errno>
 d00d150:	1007883a 	mov	r3,r2
 d00d154:	00801444 	movi	r2,81
 d00d158:	18800015 	stw	r2,0(r3)
    return -1;
 d00d15c:	00bfffc4 	movi	r2,-1
 d00d160:	e0bffe15 	stw	r2,-8(fp)
 d00d164:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 d00d168:	e037883a 	mov	sp,fp
 d00d16c:	dfc00117 	ldw	ra,4(sp)
 d00d170:	df000017 	ldw	fp,0(sp)
 d00d174:	dec00204 	addi	sp,sp,8
 d00d178:	f800283a 	ret

0d00d17c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d00d17c:	defffd04 	addi	sp,sp,-12
 d00d180:	dfc00215 	stw	ra,8(sp)
 d00d184:	df000115 	stw	fp,4(sp)
 d00d188:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d00d18c:	00834174 	movhi	r2,3333
 d00d190:	10926504 	addi	r2,r2,18836
 d00d194:	10800017 	ldw	r2,0(r2)
 d00d198:	1005003a 	cmpeq	r2,r2,zero
 d00d19c:	1000061e 	bne	r2,zero,d00d1b8 <alt_get_errno+0x3c>
 d00d1a0:	00834174 	movhi	r2,3333
 d00d1a4:	10926504 	addi	r2,r2,18836
 d00d1a8:	10800017 	ldw	r2,0(r2)
 d00d1ac:	103ee83a 	callr	r2
 d00d1b0:	e0bfff15 	stw	r2,-4(fp)
 d00d1b4:	00000306 	br	d00d1c4 <alt_get_errno+0x48>
 d00d1b8:	00834174 	movhi	r2,3333
 d00d1bc:	109b0104 	addi	r2,r2,27652
 d00d1c0:	e0bfff15 	stw	r2,-4(fp)
 d00d1c4:	e0bfff17 	ldw	r2,-4(fp)
}
 d00d1c8:	e037883a 	mov	sp,fp
 d00d1cc:	dfc00117 	ldw	ra,4(sp)
 d00d1d0:	df000017 	ldw	fp,0(sp)
 d00d1d4:	dec00204 	addi	sp,sp,8
 d00d1d8:	f800283a 	ret

0d00d1dc <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 d00d1dc:	deffeb04 	addi	sp,sp,-84
 d00d1e0:	dfc01415 	stw	ra,80(sp)
 d00d1e4:	df001315 	stw	fp,76(sp)
 d00d1e8:	df001304 	addi	fp,sp,76
 d00d1ec:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d00d1f0:	e0bffd17 	ldw	r2,-12(fp)
 d00d1f4:	1004803a 	cmplt	r2,r2,zero
 d00d1f8:	1000091e 	bne	r2,zero,d00d220 <isatty+0x44>
 d00d1fc:	e13ffd17 	ldw	r4,-12(fp)
 d00d200:	01400304 	movi	r5,12
 d00d204:	d00235c0 	call	d00235c <__mulsi3>
 d00d208:	1007883a 	mov	r3,r2
 d00d20c:	00834174 	movhi	r2,3333
 d00d210:	10915b04 	addi	r2,r2,17772
 d00d214:	1887883a 	add	r3,r3,r2
 d00d218:	e0ffff15 	stw	r3,-4(fp)
 d00d21c:	00000106 	br	d00d224 <isatty+0x48>
 d00d220:	e03fff15 	stw	zero,-4(fp)
 d00d224:	e0bfff17 	ldw	r2,-4(fp)
 d00d228:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 d00d22c:	e0bfed17 	ldw	r2,-76(fp)
 d00d230:	1005003a 	cmpeq	r2,r2,zero
 d00d234:	10000f1e 	bne	r2,zero,d00d274 <isatty+0x98>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 d00d238:	e0bfed17 	ldw	r2,-76(fp)
 d00d23c:	10800017 	ldw	r2,0(r2)
 d00d240:	10800817 	ldw	r2,32(r2)
 d00d244:	1004c03a 	cmpne	r2,r2,zero
 d00d248:	1000031e 	bne	r2,zero,d00d258 <isatty+0x7c>
    {
      return 1;
 d00d24c:	00800044 	movi	r2,1
 d00d250:	e0bffe15 	stw	r2,-8(fp)
 d00d254:	00000c06 	br	d00d288 <isatty+0xac>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 d00d258:	e17fee04 	addi	r5,fp,-72
 d00d25c:	e13ffd17 	ldw	r4,-12(fp)
 d00d260:	d00d0a40 	call	d00d0a4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 d00d264:	e0bfef17 	ldw	r2,-68(fp)
 d00d268:	10880020 	cmpeqi	r2,r2,8192
 d00d26c:	e0bffe15 	stw	r2,-8(fp)
 d00d270:	00000506 	br	d00d288 <isatty+0xac>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 d00d274:	d00d2a00 	call	d00d2a0 <alt_get_errno>
 d00d278:	1007883a 	mov	r3,r2
 d00d27c:	00801444 	movi	r2,81
 d00d280:	18800015 	stw	r2,0(r3)
    return 0;
 d00d284:	e03ffe15 	stw	zero,-8(fp)
 d00d288:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 d00d28c:	e037883a 	mov	sp,fp
 d00d290:	dfc00117 	ldw	ra,4(sp)
 d00d294:	df000017 	ldw	fp,0(sp)
 d00d298:	dec00204 	addi	sp,sp,8
 d00d29c:	f800283a 	ret

0d00d2a0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d00d2a0:	defffd04 	addi	sp,sp,-12
 d00d2a4:	dfc00215 	stw	ra,8(sp)
 d00d2a8:	df000115 	stw	fp,4(sp)
 d00d2ac:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d00d2b0:	00834174 	movhi	r2,3333
 d00d2b4:	10926504 	addi	r2,r2,18836
 d00d2b8:	10800017 	ldw	r2,0(r2)
 d00d2bc:	1005003a 	cmpeq	r2,r2,zero
 d00d2c0:	1000061e 	bne	r2,zero,d00d2dc <alt_get_errno+0x3c>
 d00d2c4:	00834174 	movhi	r2,3333
 d00d2c8:	10926504 	addi	r2,r2,18836
 d00d2cc:	10800017 	ldw	r2,0(r2)
 d00d2d0:	103ee83a 	callr	r2
 d00d2d4:	e0bfff15 	stw	r2,-4(fp)
 d00d2d8:	00000306 	br	d00d2e8 <alt_get_errno+0x48>
 d00d2dc:	00834174 	movhi	r2,3333
 d00d2e0:	109b0104 	addi	r2,r2,27652
 d00d2e4:	e0bfff15 	stw	r2,-4(fp)
 d00d2e8:	e0bfff17 	ldw	r2,-4(fp)
}
 d00d2ec:	e037883a 	mov	sp,fp
 d00d2f0:	dfc00117 	ldw	ra,4(sp)
 d00d2f4:	df000017 	ldw	fp,0(sp)
 d00d2f8:	dec00204 	addi	sp,sp,8
 d00d2fc:	f800283a 	ret

0d00d300 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 d00d300:	defffe04 	addi	sp,sp,-8
 d00d304:	dfc00115 	stw	ra,4(sp)
 d00d308:	df000015 	stw	fp,0(sp)
 d00d30c:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 d00d310:	01034174 	movhi	r4,3333
 d00d314:	21127504 	addi	r4,r4,18900
 d00d318:	01434174 	movhi	r5,3333
 d00d31c:	2949f604 	addi	r5,r5,10200
 d00d320:	01834174 	movhi	r6,3333
 d00d324:	31927504 	addi	r6,r6,18900
 d00d328:	d00d3800 	call	d00d380 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 d00d32c:	01034034 	movhi	r4,3328
 d00d330:	21000004 	addi	r4,r4,0
 d00d334:	01400234 	movhi	r5,8
 d00d338:	29401804 	addi	r5,r5,96
 d00d33c:	01800234 	movhi	r6,8
 d00d340:	31807f04 	addi	r6,r6,508
 d00d344:	d00d3800 	call	d00d380 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 d00d348:	01034174 	movhi	r4,3333
 d00d34c:	2131d904 	addi	r4,r4,-14492
 d00d350:	01434174 	movhi	r5,3333
 d00d354:	2971d904 	addi	r5,r5,-14492
 d00d358:	01834174 	movhi	r6,3333
 d00d35c:	3189f604 	addi	r6,r6,10200
 d00d360:	d00d3800 	call	d00d380 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 d00d364:	d0351680 	call	d035168 <alt_dcache_flush_all>
  alt_icache_flush_all();
 d00d368:	d0354200 	call	d035420 <alt_icache_flush_all>
}
 d00d36c:	e037883a 	mov	sp,fp
 d00d370:	dfc00117 	ldw	ra,4(sp)
 d00d374:	df000017 	ldw	fp,0(sp)
 d00d378:	dec00204 	addi	sp,sp,8
 d00d37c:	f800283a 	ret

0d00d380 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 d00d380:	defffc04 	addi	sp,sp,-16
 d00d384:	df000315 	stw	fp,12(sp)
 d00d388:	df000304 	addi	fp,sp,12
 d00d38c:	e13ffd15 	stw	r4,-12(fp)
 d00d390:	e17ffe15 	stw	r5,-8(fp)
 d00d394:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 d00d398:	e0fffe17 	ldw	r3,-8(fp)
 d00d39c:	e0bffd17 	ldw	r2,-12(fp)
 d00d3a0:	18800e26 	beq	r3,r2,d00d3dc <alt_load_section+0x5c>
  {
    while( to != end )
 d00d3a4:	00000a06 	br	d00d3d0 <alt_load_section+0x50>
    {
      *to++ = *from++;
 d00d3a8:	e0bffd17 	ldw	r2,-12(fp)
 d00d3ac:	10c00017 	ldw	r3,0(r2)
 d00d3b0:	e0bffe17 	ldw	r2,-8(fp)
 d00d3b4:	10c00015 	stw	r3,0(r2)
 d00d3b8:	e0bffe17 	ldw	r2,-8(fp)
 d00d3bc:	10800104 	addi	r2,r2,4
 d00d3c0:	e0bffe15 	stw	r2,-8(fp)
 d00d3c4:	e0bffd17 	ldw	r2,-12(fp)
 d00d3c8:	10800104 	addi	r2,r2,4
 d00d3cc:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 d00d3d0:	e0fffe17 	ldw	r3,-8(fp)
 d00d3d4:	e0bfff17 	ldw	r2,-4(fp)
 d00d3d8:	18bff31e 	bne	r3,r2,d00d3a8 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 d00d3dc:	e037883a 	mov	sp,fp
 d00d3e0:	df000017 	ldw	fp,0(sp)
 d00d3e4:	dec00104 	addi	sp,sp,4
 d00d3e8:	f800283a 	ret

0d00d3ec <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 d00d3ec:	defff804 	addi	sp,sp,-32
 d00d3f0:	dfc00715 	stw	ra,28(sp)
 d00d3f4:	df000615 	stw	fp,24(sp)
 d00d3f8:	df000604 	addi	fp,sp,24
 d00d3fc:	e13ffc15 	stw	r4,-16(fp)
 d00d400:	e17ffd15 	stw	r5,-12(fp)
 d00d404:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 d00d408:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d00d40c:	e0bffc17 	ldw	r2,-16(fp)
 d00d410:	1004803a 	cmplt	r2,r2,zero
 d00d414:	1000091e 	bne	r2,zero,d00d43c <lseek+0x50>
 d00d418:	e13ffc17 	ldw	r4,-16(fp)
 d00d41c:	01400304 	movi	r5,12
 d00d420:	d00235c0 	call	d00235c <__mulsi3>
 d00d424:	1007883a 	mov	r3,r2
 d00d428:	00834174 	movhi	r2,3333
 d00d42c:	10915b04 	addi	r2,r2,17772
 d00d430:	1887883a 	add	r3,r3,r2
 d00d434:	e0ffff15 	stw	r3,-4(fp)
 d00d438:	00000106 	br	d00d440 <lseek+0x54>
 d00d43c:	e03fff15 	stw	zero,-4(fp)
 d00d440:	e0bfff17 	ldw	r2,-4(fp)
 d00d444:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 d00d448:	e0bffb17 	ldw	r2,-20(fp)
 d00d44c:	1005003a 	cmpeq	r2,r2,zero
 d00d450:	1000111e 	bne	r2,zero,d00d498 <lseek+0xac>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 d00d454:	e0bffb17 	ldw	r2,-20(fp)
 d00d458:	10800017 	ldw	r2,0(r2)
 d00d45c:	10800717 	ldw	r2,28(r2)
 d00d460:	1005003a 	cmpeq	r2,r2,zero
 d00d464:	1000091e 	bne	r2,zero,d00d48c <lseek+0xa0>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 d00d468:	e0bffb17 	ldw	r2,-20(fp)
 d00d46c:	10800017 	ldw	r2,0(r2)
 d00d470:	10800717 	ldw	r2,28(r2)
 d00d474:	e13ffb17 	ldw	r4,-20(fp)
 d00d478:	e17ffd17 	ldw	r5,-12(fp)
 d00d47c:	e1bffe17 	ldw	r6,-8(fp)
 d00d480:	103ee83a 	callr	r2
 d00d484:	e0bffa15 	stw	r2,-24(fp)
 d00d488:	00000506 	br	d00d4a0 <lseek+0xb4>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 d00d48c:	00bfde84 	movi	r2,-134
 d00d490:	e0bffa15 	stw	r2,-24(fp)
 d00d494:	00000206 	br	d00d4a0 <lseek+0xb4>
    }
  }
  else  
  {
    rc = -EBADFD;
 d00d498:	00bfebc4 	movi	r2,-81
 d00d49c:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 d00d4a0:	e0bffa17 	ldw	r2,-24(fp)
 d00d4a4:	1004403a 	cmpge	r2,r2,zero
 d00d4a8:	1000071e 	bne	r2,zero,d00d4c8 <lseek+0xdc>
  {
    ALT_ERRNO = -rc;
 d00d4ac:	d00d4e00 	call	d00d4e0 <alt_get_errno>
 d00d4b0:	1007883a 	mov	r3,r2
 d00d4b4:	e0bffa17 	ldw	r2,-24(fp)
 d00d4b8:	0085c83a 	sub	r2,zero,r2
 d00d4bc:	18800015 	stw	r2,0(r3)
    rc = -1;
 d00d4c0:	00bfffc4 	movi	r2,-1
 d00d4c4:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 d00d4c8:	e0bffa17 	ldw	r2,-24(fp)
}
 d00d4cc:	e037883a 	mov	sp,fp
 d00d4d0:	dfc00117 	ldw	ra,4(sp)
 d00d4d4:	df000017 	ldw	fp,0(sp)
 d00d4d8:	dec00204 	addi	sp,sp,8
 d00d4dc:	f800283a 	ret

0d00d4e0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d00d4e0:	defffd04 	addi	sp,sp,-12
 d00d4e4:	dfc00215 	stw	ra,8(sp)
 d00d4e8:	df000115 	stw	fp,4(sp)
 d00d4ec:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d00d4f0:	00834174 	movhi	r2,3333
 d00d4f4:	10926504 	addi	r2,r2,18836
 d00d4f8:	10800017 	ldw	r2,0(r2)
 d00d4fc:	1005003a 	cmpeq	r2,r2,zero
 d00d500:	1000061e 	bne	r2,zero,d00d51c <alt_get_errno+0x3c>
 d00d504:	00834174 	movhi	r2,3333
 d00d508:	10926504 	addi	r2,r2,18836
 d00d50c:	10800017 	ldw	r2,0(r2)
 d00d510:	103ee83a 	callr	r2
 d00d514:	e0bfff15 	stw	r2,-4(fp)
 d00d518:	00000306 	br	d00d528 <alt_get_errno+0x48>
 d00d51c:	00834174 	movhi	r2,3333
 d00d520:	109b0104 	addi	r2,r2,27652
 d00d524:	e0bfff15 	stw	r2,-4(fp)
 d00d528:	e0bfff17 	ldw	r2,-4(fp)
}
 d00d52c:	e037883a 	mov	sp,fp
 d00d530:	dfc00117 	ldw	ra,4(sp)
 d00d534:	df000017 	ldw	fp,0(sp)
 d00d538:	dec00204 	addi	sp,sp,8
 d00d53c:	f800283a 	ret

0d00d540 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 d00d540:	defffb04 	addi	sp,sp,-20
 d00d544:	dfc00415 	stw	ra,16(sp)
 d00d548:	df000315 	stw	fp,12(sp)
 d00d54c:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 d00d550:	0009883a 	mov	r4,zero
 d00d554:	d015c900 	call	d015c90 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 d00d558:	d00e2cc0 	call	d00e2cc <OSInit>
 d00d55c:	01000044 	movi	r4,1
 d00d560:	d0131940 	call	d013194 <OSSemCreate>
 d00d564:	1007883a 	mov	r3,r2
 d00d568:	00834174 	movhi	r2,3333
 d00d56c:	109b0604 	addi	r2,r2,27672
 d00d570:	10c00015 	stw	r3,0(r2)
 d00d574:	01000044 	movi	r4,1
 d00d578:	d0131940 	call	d013194 <OSSemCreate>
 d00d57c:	1007883a 	mov	r3,r2
 d00d580:	00834174 	movhi	r2,3333
 d00d584:	109b0804 	addi	r2,r2,27680
 d00d588:	10c00015 	stw	r3,0(r2)
 d00d58c:	00834174 	movhi	r2,3333
 d00d590:	109b5304 	addi	r2,r2,27980
 d00d594:	e0bffd15 	stw	r2,-12(fp)
 d00d598:	00800044 	movi	r2,1
 d00d59c:	e0bffe0d 	sth	r2,-8(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 d00d5a0:	e13ffe0b 	ldhu	r4,-8(fp)
 d00d5a4:	d0131940 	call	d013194 <OSSemCreate>
 d00d5a8:	1007883a 	mov	r3,r2
 d00d5ac:	e0bffd17 	ldw	r2,-12(fp)
 d00d5b0:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 d00d5b4:	d015cc40 	call	d015cc4 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 d00d5b8:	01034174 	movhi	r4,3333
 d00d5bc:	21397204 	addi	r4,r4,-6712
 d00d5c0:	01434174 	movhi	r5,3333
 d00d5c4:	29797204 	addi	r5,r5,-6712
 d00d5c8:	01834174 	movhi	r6,3333
 d00d5cc:	31b97204 	addi	r6,r6,-6712
 d00d5d0:	d0357f40 	call	d0357f4 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 d00d5d4:	d0352c40 	call	d0352c4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 d00d5d8:	010340f4 	movhi	r4,3331
 d00d5dc:	2114ca04 	addi	r4,r4,21288
 d00d5e0:	d04bd9c0 	call	d04bd9c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 d00d5e4:	d128e317 	ldw	r4,-23668(gp)
 d00d5e8:	d168e417 	ldw	r5,-23664(gp)
 d00d5ec:	d1a8e517 	ldw	r6,-23660(gp)
 d00d5f0:	d000df80 	call	d000df8 <main>
 d00d5f4:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 d00d5f8:	01000044 	movi	r4,1
 d00d5fc:	d01d3040 	call	d01d304 <close>
  exit (result);
 d00d600:	e13fff17 	ldw	r4,-4(fp)
 d00d604:	d04bde40 	call	d04bde4 <exit>

0d00d608 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 d00d608:	defff804 	addi	sp,sp,-32
 d00d60c:	df000715 	stw	fp,28(sp)
 d00d610:	df000704 	addi	fp,sp,28
 d00d614:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d618:	0005303a 	rdctl	r2,status
 d00d61c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d620:	e0fffb17 	ldw	r3,-20(fp)
 d00d624:	00bfff84 	movi	r2,-2
 d00d628:	1884703a 	and	r2,r3,r2
 d00d62c:	1001703a 	wrctl	status,r2
  
  return context;
 d00d630:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 d00d634:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 d00d638:	d0a00917 	ldw	r2,-32732(gp)
 d00d63c:	10c000c4 	addi	r3,r2,3
 d00d640:	00bfff04 	movi	r2,-4
 d00d644:	1884703a 	and	r2,r3,r2
 d00d648:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 d00d64c:	d0e00917 	ldw	r3,-32732(gp)
 d00d650:	e0bffe17 	ldw	r2,-8(fp)
 d00d654:	1887883a 	add	r3,r3,r2
 d00d658:	00834834 	movhi	r2,3360
 d00d65c:	10800004 	addi	r2,r2,0
 d00d660:	10c0072e 	bgeu	r2,r3,d00d680 <sbrk+0x78>
 d00d664:	e0bffd17 	ldw	r2,-12(fp)
 d00d668:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d66c:	e0bffa17 	ldw	r2,-24(fp)
 d00d670:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 d00d674:	00bfffc4 	movi	r2,-1
 d00d678:	e0bfff15 	stw	r2,-4(fp)
 d00d67c:	00000c06 	br	d00d6b0 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 d00d680:	d0a00917 	ldw	r2,-32732(gp)
 d00d684:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 d00d688:	d0e00917 	ldw	r3,-32732(gp)
 d00d68c:	e0bffe17 	ldw	r2,-8(fp)
 d00d690:	1885883a 	add	r2,r3,r2
 d00d694:	d0a00915 	stw	r2,-32732(gp)
 d00d698:	e0bffd17 	ldw	r2,-12(fp)
 d00d69c:	e0bff915 	stw	r2,-28(fp)
 d00d6a0:	e0bff917 	ldw	r2,-28(fp)
 d00d6a4:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 d00d6a8:	e0bffc17 	ldw	r2,-16(fp)
 d00d6ac:	e0bfff15 	stw	r2,-4(fp)
 d00d6b0:	e0bfff17 	ldw	r2,-4(fp)
} 
 d00d6b4:	e037883a 	mov	sp,fp
 d00d6b8:	df000017 	ldw	fp,0(sp)
 d00d6bc:	dec00104 	addi	sp,sp,4
 d00d6c0:	f800283a 	ret

0d00d6c4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 d00d6c4:	deffdf04 	addi	sp,sp,-132
 d00d6c8:	dfc02015 	stw	ra,128(sp)
 d00d6cc:	df001f15 	stw	fp,124(sp)
 d00d6d0:	df001f04 	addi	fp,sp,124
 d00d6d4:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 d00d6d8:	e17fe204 	addi	r5,fp,-120
 d00d6dc:	01003fc4 	movi	r4,255
 d00d6e0:	d01551c0 	call	d01551c <OSTaskQuery>
 d00d6e4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 d00d6e8:	e0bffe83 	ldbu	r2,-6(fp)
 d00d6ec:	10803fcc 	andi	r2,r2,255
 d00d6f0:	1004c03a 	cmpne	r2,r2,zero
 d00d6f4:	1000191e 	bne	r2,zero,d00d75c <__env_lock+0x98>
    return;

  id = tcb.OSTCBPrio;
 d00d6f8:	e0bfee83 	ldbu	r2,-70(fp)
 d00d6fc:	10803fcc 	andi	r2,r2,255
 d00d700:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 d00d704:	d128e717 	ldw	r4,-23652(gp)
 d00d708:	e17ffd04 	addi	r5,fp,-12
 d00d70c:	d013a680 	call	d013a68 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 d00d710:	e0bffe43 	ldbu	r2,-7(fp)
 d00d714:	10803fcc 	andi	r2,r2,255
 d00d718:	1005003a 	cmpeq	r2,r2,zero
 d00d71c:	1000071e 	bne	r2,zero,d00d73c <__env_lock+0x78>
 d00d720:	d0e00a17 	ldw	r3,-32728(gp)
 d00d724:	e0bfe117 	ldw	r2,-124(fp)
 d00d728:	10c0041e 	bne	r2,r3,d00d73c <__env_lock+0x78>
  {
    /* we do; just count the recursion */

    locks++;
 d00d72c:	d0a8e617 	ldw	r2,-23656(gp)
 d00d730:	10800044 	addi	r2,r2,1
 d00d734:	d0a8e615 	stw	r2,-23656(gp)
  id = tcb.OSTCBPrio;
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
  if( semdata.OSEventGrp && id == lockid ) 
 d00d738:	00000806 	br	d00d75c <__env_lock+0x98>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 d00d73c:	d128e717 	ldw	r4,-23652(gp)
 d00d740:	e1bffe84 	addi	r6,fp,-6
 d00d744:	000b883a 	mov	r5,zero
 d00d748:	d0135480 	call	d013548 <OSSemPend>
    locks  = 1;
 d00d74c:	00800044 	movi	r2,1
 d00d750:	d0a8e615 	stw	r2,-23656(gp)
    lockid = id;
 d00d754:	e0bfe117 	ldw	r2,-124(fp)
 d00d758:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 d00d75c:	e037883a 	mov	sp,fp
 d00d760:	dfc00117 	ldw	ra,4(sp)
 d00d764:	df000017 	ldw	fp,0(sp)
 d00d768:	dec00204 	addi	sp,sp,8
 d00d76c:	f800283a 	ret

0d00d770 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 d00d770:	defffd04 	addi	sp,sp,-12
 d00d774:	dfc00215 	stw	ra,8(sp)
 d00d778:	df000115 	stw	fp,4(sp)
 d00d77c:	df000104 	addi	fp,sp,4
 d00d780:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 d00d784:	d0a8e617 	ldw	r2,-23656(gp)
 d00d788:	1005003a 	cmpeq	r2,r2,zero
 d00d78c:	10000a1e 	bne	r2,zero,d00d7b8 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 d00d790:	d0a8e617 	ldw	r2,-23656(gp)
 d00d794:	10bfffc4 	addi	r2,r2,-1
 d00d798:	d0a8e615 	stw	r2,-23656(gp)
 d00d79c:	d0a8e617 	ldw	r2,-23656(gp)
 d00d7a0:	1004c03a 	cmpne	r2,r2,zero
 d00d7a4:	1000041e 	bne	r2,zero,d00d7b8 <__env_unlock+0x48>
  {
    lockid = -1;
 d00d7a8:	00bfffc4 	movi	r2,-1
 d00d7ac:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 d00d7b0:	d128e717 	ldw	r4,-23652(gp)
 d00d7b4:	d0139400 	call	d013940 <OSSemPost>
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 d00d7b8:	e037883a 	mov	sp,fp
 d00d7bc:	dfc00117 	ldw	ra,4(sp)
 d00d7c0:	df000017 	ldw	fp,0(sp)
 d00d7c4:	dec00204 	addi	sp,sp,8
 d00d7c8:	f800283a 	ret

0d00d7cc <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 d00d7cc:	deffdb04 	addi	sp,sp,-148
 d00d7d0:	dfc02415 	stw	ra,144(sp)
 d00d7d4:	df002315 	stw	fp,140(sp)
 d00d7d8:	df002304 	addi	fp,sp,140
 d00d7dc:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00d7e0:	e03fe015 	stw	zero,-128(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 d00d7e4:	00834174 	movhi	r2,3333
 d00d7e8:	109b0944 	addi	r2,r2,27685
 d00d7ec:	10800003 	ldbu	r2,0(r2)
 d00d7f0:	10803fcc 	andi	r2,r2,255
 d00d7f4:	10800058 	cmpnei	r2,r2,1
 d00d7f8:	1000311e 	bne	r2,zero,d00d8c0 <__malloc_lock+0xf4>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 d00d7fc:	e17fe204 	addi	r5,fp,-120
 d00d800:	01003fc4 	movi	r4,255
 d00d804:	d01551c0 	call	d01551c <OSTaskQuery>
 d00d808:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 d00d80c:	e0bffe83 	ldbu	r2,-6(fp)
 d00d810:	10803fcc 	andi	r2,r2,255
 d00d814:	1004c03a 	cmpne	r2,r2,zero
 d00d818:	1000291e 	bne	r2,zero,d00d8c0 <__malloc_lock+0xf4>
    return;

  id = tcb.OSTCBPrio;
 d00d81c:	e0bfee83 	ldbu	r2,-70(fp)
 d00d820:	10803fcc 	andi	r2,r2,255
 d00d824:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 d00d828:	d128e917 	ldw	r4,-23644(gp)
 d00d82c:	e17ffd04 	addi	r5,fp,-12
 d00d830:	d013a680 	call	d013a68 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d834:	0005303a 	rdctl	r2,status
 d00d838:	e0bfdf15 	stw	r2,-132(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d83c:	e0ffdf17 	ldw	r3,-132(fp)
 d00d840:	00bfff84 	movi	r2,-2
 d00d844:	1884703a 	and	r2,r3,r2
 d00d848:	1001703a 	wrctl	status,r2
  
  return context;
 d00d84c:	e0bfdf17 	ldw	r2,-132(fp)
  
  OS_ENTER_CRITICAL();
 d00d850:	e0bfe015 	stw	r2,-128(fp)

  if( !semdata.OSCnt && id == lockid ) 
 d00d854:	e0bffd0b 	ldhu	r2,-12(fp)
 d00d858:	10bfffcc 	andi	r2,r2,65535
 d00d85c:	1004c03a 	cmpne	r2,r2,zero
 d00d860:	10000b1e 	bne	r2,zero,d00d890 <__malloc_lock+0xc4>
 d00d864:	d0e00b17 	ldw	r3,-32724(gp)
 d00d868:	e0bfe117 	ldw	r2,-124(fp)
 d00d86c:	10c0081e 	bne	r2,r3,d00d890 <__malloc_lock+0xc4>
  {
    /* we do; just count the recursion */
    locks++;
 d00d870:	d0a8e817 	ldw	r2,-23648(gp)
 d00d874:	10800044 	addi	r2,r2,1
 d00d878:	d0a8e815 	stw	r2,-23648(gp)
 d00d87c:	e0bfe017 	ldw	r2,-128(fp)
 d00d880:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d884:	e0bfde17 	ldw	r2,-136(fp)
 d00d888:	1001703a 	wrctl	status,r2

  OSSemQuery( alt_heapsem, &semdata );
  
  OS_ENTER_CRITICAL();

  if( !semdata.OSCnt && id == lockid ) 
 d00d88c:	00000c06 	br	d00d8c0 <__malloc_lock+0xf4>
 d00d890:	e0bfe017 	ldw	r2,-128(fp)
 d00d894:	e0bfdd15 	stw	r2,-140(fp)
 d00d898:	e0bfdd17 	ldw	r2,-140(fp)
 d00d89c:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 d00d8a0:	d128e917 	ldw	r4,-23644(gp)
 d00d8a4:	e1bffe84 	addi	r6,fp,-6
 d00d8a8:	000b883a 	mov	r5,zero
 d00d8ac:	d0135480 	call	d013548 <OSSemPend>
    locks  = 1;
 d00d8b0:	00800044 	movi	r2,1
 d00d8b4:	d0a8e815 	stw	r2,-23648(gp)
    lockid = id;
 d00d8b8:	e0bfe117 	ldw	r2,-124(fp)
 d00d8bc:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 d00d8c0:	e037883a 	mov	sp,fp
 d00d8c4:	dfc00117 	ldw	ra,4(sp)
 d00d8c8:	df000017 	ldw	fp,0(sp)
 d00d8cc:	dec00204 	addi	sp,sp,8
 d00d8d0:	f800283a 	ret

0d00d8d4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 d00d8d4:	defff804 	addi	sp,sp,-32
 d00d8d8:	dfc00715 	stw	ra,28(sp)
 d00d8dc:	df000615 	stw	fp,24(sp)
 d00d8e0:	df000604 	addi	fp,sp,24
 d00d8e4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00d8e8:	e03ffe15 	stw	zero,-8(fp)
#endif 

  if (OSRunning != OS_TRUE)
 d00d8ec:	00834174 	movhi	r2,3333
 d00d8f0:	109b0944 	addi	r2,r2,27685
 d00d8f4:	10800003 	ldbu	r2,0(r2)
 d00d8f8:	10803fcc 	andi	r2,r2,255
 d00d8fc:	10800058 	cmpnei	r2,r2,1
 d00d900:	1000231e 	bne	r2,zero,d00d990 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d904:	0005303a 	rdctl	r2,status
 d00d908:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d90c:	e0fffd17 	ldw	r3,-12(fp)
 d00d910:	00bfff84 	movi	r2,-2
 d00d914:	1884703a 	and	r2,r3,r2
 d00d918:	1001703a 	wrctl	status,r2
  
  return context;
 d00d91c:	e0bffd17 	ldw	r2,-12(fp)
      return;

  OS_ENTER_CRITICAL();
 d00d920:	e0bffe15 	stw	r2,-8(fp)
  if (locks == 0)
 d00d924:	d0a8e817 	ldw	r2,-23648(gp)
 d00d928:	1004c03a 	cmpne	r2,r2,zero
 d00d92c:	1000051e 	bne	r2,zero,d00d944 <__malloc_unlock+0x70>
 d00d930:	e0bffe17 	ldw	r2,-8(fp)
 d00d934:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d938:	e0bffc17 	ldw	r2,-16(fp)
 d00d93c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 d00d940:	00001306 	br	d00d990 <__malloc_unlock+0xbc>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 d00d944:	d0a8e817 	ldw	r2,-23648(gp)
 d00d948:	10bfffc4 	addi	r2,r2,-1
 d00d94c:	d0a8e815 	stw	r2,-23648(gp)
 d00d950:	d0a8e817 	ldw	r2,-23648(gp)
 d00d954:	1004c03a 	cmpne	r2,r2,zero
 d00d958:	1000091e 	bne	r2,zero,d00d980 <__malloc_unlock+0xac>
  {
    lockid = -1;
 d00d95c:	00bfffc4 	movi	r2,-1
 d00d960:	d0a00b15 	stw	r2,-32724(gp)
 d00d964:	e0bffe17 	ldw	r2,-8(fp)
 d00d968:	e0bffb15 	stw	r2,-20(fp)
 d00d96c:	e0bffb17 	ldw	r2,-20(fp)
 d00d970:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 d00d974:	d128e917 	ldw	r4,-23644(gp)
 d00d978:	d0139400 	call	d013940 <OSSemPost>
 d00d97c:	00000406 	br	d00d990 <__malloc_unlock+0xbc>
 d00d980:	e0bffe17 	ldw	r2,-8(fp)
 d00d984:	e0bffa15 	stw	r2,-24(fp)
 d00d988:	e0bffa17 	ldw	r2,-24(fp)
 d00d98c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 d00d990:	e037883a 	mov	sp,fp
 d00d994:	dfc00117 	ldw	ra,4(sp)
 d00d998:	df000017 	ldw	fp,0(sp)
 d00d99c:	dec00204 	addi	sp,sp,8
 d00d9a0:	f800283a 	ret

0d00d9a4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 d00d9a4:	defff604 	addi	sp,sp,-40
 d00d9a8:	dfc00915 	stw	ra,36(sp)
 d00d9ac:	df000815 	stw	fp,32(sp)
 d00d9b0:	df000804 	addi	fp,sp,32
 d00d9b4:	e13ffc15 	stw	r4,-16(fp)
 d00d9b8:	e17ffd15 	stw	r5,-12(fp)
 d00d9bc:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00d9c0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d00d9c4:	e0bffe17 	ldw	r2,-8(fp)
 d00d9c8:	1004c03a 	cmpne	r2,r2,zero
 d00d9cc:	1000021e 	bne	r2,zero,d00d9d8 <OSEventNameGet+0x34>
        return (0);
 d00d9d0:	e03fff15 	stw	zero,-4(fp)
 d00d9d4:	00003906 	br	d00dabc <OSEventNameGet+0x118>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 d00d9d8:	e0bffc17 	ldw	r2,-16(fp)
 d00d9dc:	1004c03a 	cmpne	r2,r2,zero
 d00d9e0:	1000051e 	bne	r2,zero,d00d9f8 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d00d9e4:	e0fffe17 	ldw	r3,-8(fp)
 d00d9e8:	00800104 	movi	r2,4
 d00d9ec:	18800005 	stb	r2,0(r3)
        return (0);
 d00d9f0:	e03fff15 	stw	zero,-4(fp)
 d00d9f4:	00003106 	br	d00dabc <OSEventNameGet+0x118>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d00d9f8:	e0bffd17 	ldw	r2,-12(fp)
 d00d9fc:	1004c03a 	cmpne	r2,r2,zero
 d00da00:	1000051e 	bne	r2,zero,d00da18 <OSEventNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 d00da04:	e0fffe17 	ldw	r3,-8(fp)
 d00da08:	00800304 	movi	r2,12
 d00da0c:	18800005 	stb	r2,0(r3)
        return (0);
 d00da10:	e03fff15 	stw	zero,-4(fp)
 d00da14:	00002906 	br	d00dabc <OSEventNameGet+0x118>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d00da18:	d0a8f803 	ldbu	r2,-23584(gp)
 d00da1c:	10803fcc 	andi	r2,r2,255
 d00da20:	1005003a 	cmpeq	r2,r2,zero
 d00da24:	1000051e 	bne	r2,zero,d00da3c <OSEventNameGet+0x98>
        *perr  = OS_ERR_NAME_GET_ISR;
 d00da28:	e0fffe17 	ldw	r3,-8(fp)
 d00da2c:	00800444 	movi	r2,17
 d00da30:	18800005 	stb	r2,0(r3)
        return (0);
 d00da34:	e03fff15 	stw	zero,-4(fp)
 d00da38:	00002006 	br	d00dabc <OSEventNameGet+0x118>
    }
    switch (pevent->OSEventType) {
 d00da3c:	e0bffc17 	ldw	r2,-16(fp)
 d00da40:	10800003 	ldbu	r2,0(r2)
 d00da44:	10803fcc 	andi	r2,r2,255
 d00da48:	10bfffc4 	addi	r2,r2,-1
 d00da4c:	10800128 	cmpgeui	r2,r2,4
 d00da50:	1000161e 	bne	r2,zero,d00daac <OSEventNameGet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00da54:	0005303a 	rdctl	r2,status
 d00da58:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00da5c:	e0fff917 	ldw	r3,-28(fp)
 d00da60:	00bfff84 	movi	r2,-2
 d00da64:	1884703a 	and	r2,r3,r2
 d00da68:	1001703a 	wrctl	status,r2
  
  return context;
 d00da6c:	e0bff917 	ldw	r2,-28(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 d00da70:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 d00da74:	e0bffc17 	ldw	r2,-16(fp)
 d00da78:	11400384 	addi	r5,r2,14
 d00da7c:	e13ffd17 	ldw	r4,-12(fp)
 d00da80:	d00f5280 	call	d00f528 <OS_StrCopy>
 d00da84:	e0bffb05 	stb	r2,-20(fp)
 d00da88:	e0bffa17 	ldw	r2,-24(fp)
 d00da8c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00da90:	e0bff817 	ldw	r2,-32(fp)
 d00da94:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d00da98:	e0bffe17 	ldw	r2,-8(fp)
 d00da9c:	10000005 	stb	zero,0(r2)
    return (len);
 d00daa0:	e0bffb03 	ldbu	r2,-20(fp)
 d00daa4:	e0bfff15 	stw	r2,-4(fp)
 d00daa8:	00000406 	br	d00dabc <OSEventNameGet+0x118>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 d00daac:	e0fffe17 	ldw	r3,-8(fp)
 d00dab0:	00800044 	movi	r2,1
 d00dab4:	18800005 	stb	r2,0(r3)
             return (0);
 d00dab8:	e03fff15 	stw	zero,-4(fp)
 d00dabc:	e0bfff17 	ldw	r2,-4(fp)
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
 d00dac0:	e037883a 	mov	sp,fp
 d00dac4:	dfc00117 	ldw	ra,4(sp)
 d00dac8:	df000017 	ldw	fp,0(sp)
 d00dacc:	dec00204 	addi	sp,sp,8
 d00dad0:	f800283a 	ret

0d00dad4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 d00dad4:	defff604 	addi	sp,sp,-40
 d00dad8:	dfc00915 	stw	ra,36(sp)
 d00dadc:	df000815 	stw	fp,32(sp)
 d00dae0:	df000804 	addi	fp,sp,32
 d00dae4:	e13ffd15 	stw	r4,-12(fp)
 d00dae8:	e17ffe15 	stw	r5,-8(fp)
 d00daec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00daf0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d00daf4:	e0bfff17 	ldw	r2,-4(fp)
 d00daf8:	1005003a 	cmpeq	r2,r2,zero
 d00dafc:	1000411e 	bne	r2,zero,d00dc04 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 d00db00:	e0bffd17 	ldw	r2,-12(fp)
 d00db04:	1004c03a 	cmpne	r2,r2,zero
 d00db08:	1000041e 	bne	r2,zero,d00db1c <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 d00db0c:	e0ffff17 	ldw	r3,-4(fp)
 d00db10:	00800104 	movi	r2,4
 d00db14:	18800005 	stb	r2,0(r3)
        return;
 d00db18:	00003a06 	br	d00dc04 <OSEventNameSet+0x130>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d00db1c:	e0bffe17 	ldw	r2,-8(fp)
 d00db20:	1004c03a 	cmpne	r2,r2,zero
 d00db24:	1000041e 	bne	r2,zero,d00db38 <OSEventNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 d00db28:	e0ffff17 	ldw	r3,-4(fp)
 d00db2c:	00800304 	movi	r2,12
 d00db30:	18800005 	stb	r2,0(r3)
        return;
 d00db34:	00003306 	br	d00dc04 <OSEventNameSet+0x130>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d00db38:	d0a8f803 	ldbu	r2,-23584(gp)
 d00db3c:	10803fcc 	andi	r2,r2,255
 d00db40:	1005003a 	cmpeq	r2,r2,zero
 d00db44:	1000041e 	bne	r2,zero,d00db58 <OSEventNameSet+0x84>
        *perr = OS_ERR_NAME_SET_ISR;
 d00db48:	e0ffff17 	ldw	r3,-4(fp)
 d00db4c:	00800484 	movi	r2,18
 d00db50:	18800005 	stb	r2,0(r3)
        return;
 d00db54:	00002b06 	br	d00dc04 <OSEventNameSet+0x130>
    }
    switch (pevent->OSEventType) {
 d00db58:	e0bffd17 	ldw	r2,-12(fp)
 d00db5c:	10800003 	ldbu	r2,0(r2)
 d00db60:	10803fcc 	andi	r2,r2,255
 d00db64:	10bfffc4 	addi	r2,r2,-1
 d00db68:	10800128 	cmpgeui	r2,r2,4
 d00db6c:	10000f1e 	bne	r2,zero,d00dbac <OSEventNameSet+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00db70:	0005303a 	rdctl	r2,status
 d00db74:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00db78:	e0fffa17 	ldw	r3,-24(fp)
 d00db7c:	00bfff84 	movi	r2,-2
 d00db80:	1884703a 	and	r2,r3,r2
 d00db84:	1001703a 	wrctl	status,r2
  
  return context;
 d00db88:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 d00db8c:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 d00db90:	e13ffe17 	ldw	r4,-8(fp)
 d00db94:	d00f5a80 	call	d00f5a8 <OS_StrLen>
 d00db98:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 d00db9c:	e0bffc03 	ldbu	r2,-16(fp)
 d00dba0:	10800828 	cmpgeui	r2,r2,32
 d00dba4:	1000051e 	bne	r2,zero,d00dbbc <OSEventNameSet+0xe8>
 d00dba8:	00000c06 	br	d00dbdc <OSEventNameSet+0x108>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 d00dbac:	e0ffff17 	ldw	r3,-4(fp)
 d00dbb0:	00800044 	movi	r2,1
 d00dbb4:	18800005 	stb	r2,0(r3)
             return;
 d00dbb8:	00001206 	br	d00dc04 <OSEventNameSet+0x130>
 d00dbbc:	e0bffb17 	ldw	r2,-20(fp)
 d00dbc0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00dbc4:	e0bff917 	ldw	r2,-28(fp)
 d00dbc8:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 d00dbcc:	e0ffff17 	ldw	r3,-4(fp)
 d00dbd0:	008002c4 	movi	r2,11
 d00dbd4:	18800005 	stb	r2,0(r3)
        return;
 d00dbd8:	00000a06 	br	d00dc04 <OSEventNameSet+0x130>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 d00dbdc:	e0bffd17 	ldw	r2,-12(fp)
 d00dbe0:	11000384 	addi	r4,r2,14
 d00dbe4:	e17ffe17 	ldw	r5,-8(fp)
 d00dbe8:	d00f5280 	call	d00f528 <OS_StrCopy>
 d00dbec:	e0bffb17 	ldw	r2,-20(fp)
 d00dbf0:	e0bff815 	stw	r2,-32(fp)
 d00dbf4:	e0bff817 	ldw	r2,-32(fp)
 d00dbf8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d00dbfc:	e0bfff17 	ldw	r2,-4(fp)
 d00dc00:	10000005 	stb	zero,0(r2)
}
 d00dc04:	e037883a 	mov	sp,fp
 d00dc08:	dfc00117 	ldw	ra,4(sp)
 d00dc0c:	df000017 	ldw	fp,0(sp)
 d00dc10:	dec00204 	addi	sp,sp,8
 d00dc14:	f800283a 	ret

0d00dc18 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 d00dc18:	deffe704 	addi	sp,sp,-100
 d00dc1c:	dfc01815 	stw	ra,96(sp)
 d00dc20:	df001715 	stw	fp,92(sp)
 d00dc24:	df001704 	addi	fp,sp,92
 d00dc28:	e13ff615 	stw	r4,-40(fp)
 d00dc2c:	e17ff715 	stw	r5,-36(fp)
 d00dc30:	e1bff815 	stw	r6,-32(fp)
 d00dc34:	e1fff90d 	sth	r7,-28(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 d00dc38:	e03ff015 	stw	zero,-64(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 d00dc3c:	e0800217 	ldw	r2,8(fp)
 d00dc40:	1004c03a 	cmpne	r2,r2,zero
 d00dc44:	1000021e 	bne	r2,zero,d00dc50 <OSEventPendMulti+0x38>
        return (0);
 d00dc48:	e03fff15 	stw	zero,-4(fp)
 d00dc4c:	00019906 	br	d00e2b4 <OSEventPendMulti+0x69c>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 d00dc50:	e0bff617 	ldw	r2,-40(fp)
 d00dc54:	1004c03a 	cmpne	r2,r2,zero
 d00dc58:	1000051e 	bne	r2,zero,d00dc70 <OSEventPendMulti+0x58>
       *perr =  OS_ERR_PEVENT_NULL;
 d00dc5c:	e0c00217 	ldw	r3,8(fp)
 d00dc60:	00800104 	movi	r2,4
 d00dc64:	18800005 	stb	r2,0(r3)
        return (0);
 d00dc68:	e03fff15 	stw	zero,-4(fp)
 d00dc6c:	00019106 	br	d00e2b4 <OSEventPendMulti+0x69c>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 d00dc70:	e0bff717 	ldw	r2,-36(fp)
 d00dc74:	1004c03a 	cmpne	r2,r2,zero
 d00dc78:	1000051e 	bne	r2,zero,d00dc90 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
 d00dc7c:	e0c00217 	ldw	r3,8(fp)
 d00dc80:	00800104 	movi	r2,4
 d00dc84:	18800005 	stb	r2,0(r3)
        return (0);
 d00dc88:	e03fff15 	stw	zero,-4(fp)
 d00dc8c:	00018906 	br	d00e2b4 <OSEventPendMulti+0x69c>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 d00dc90:	e0bff817 	ldw	r2,-32(fp)
 d00dc94:	1004c03a 	cmpne	r2,r2,zero
 d00dc98:	1000051e 	bne	r2,zero,d00dcb0 <OSEventPendMulti+0x98>
       *perr =  OS_ERR_PEVENT_NULL;
 d00dc9c:	e0c00217 	ldw	r3,8(fp)
 d00dca0:	00800104 	movi	r2,4
 d00dca4:	18800005 	stb	r2,0(r3)
        return (0);
 d00dca8:	e03fff15 	stw	zero,-4(fp)
 d00dcac:	00018106 	br	d00e2b4 <OSEventPendMulti+0x69c>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 d00dcb0:	e0bff717 	ldw	r2,-36(fp)
 d00dcb4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 d00dcb8:	e0bff617 	ldw	r2,-40(fp)
 d00dcbc:	e0bff515 	stw	r2,-44(fp)
    pevent      = *pevents;
 d00dcc0:	e0bff517 	ldw	r2,-44(fp)
 d00dcc4:	10800017 	ldw	r2,0(r2)
 d00dcc8:	e0bff415 	stw	r2,-48(fp)
    while  (pevent != (OS_EVENT *)0) {
 d00dccc:	00001806 	br	d00dd30 <OSEventPendMulti+0x118>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 d00dcd0:	e0bff417 	ldw	r2,-48(fp)
 d00dcd4:	10800003 	ldbu	r2,0(r2)
 d00dcd8:	10803fcc 	andi	r2,r2,255
 d00dcdc:	e0bffe15 	stw	r2,-8(fp)
 d00dce0:	e0fffe17 	ldw	r3,-8(fp)
 d00dce4:	188000a0 	cmpeqi	r2,r3,2
 d00dce8:	10000b1e 	bne	r2,zero,d00dd18 <OSEventPendMulti+0x100>
 d00dcec:	e0fffe17 	ldw	r3,-8(fp)
 d00dcf0:	188000e0 	cmpeqi	r2,r3,3
 d00dcf4:	1000081e 	bne	r2,zero,d00dd18 <OSEventPendMulti+0x100>
 d00dcf8:	e0fffe17 	ldw	r3,-8(fp)
 d00dcfc:	18800060 	cmpeqi	r2,r3,1
 d00dd00:	1000051e 	bne	r2,zero,d00dd18 <OSEventPendMulti+0x100>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 d00dd04:	e0c00217 	ldw	r3,8(fp)
 d00dd08:	00800044 	movi	r2,1
 d00dd0c:	18800005 	stb	r2,0(r3)
                 return (0);
 d00dd10:	e03fff15 	stw	zero,-4(fp)
 d00dd14:	00016706 	br	d00e2b4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 d00dd18:	e0bff517 	ldw	r2,-44(fp)
 d00dd1c:	10800104 	addi	r2,r2,4
 d00dd20:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 d00dd24:	e0bff517 	ldw	r2,-44(fp)
 d00dd28:	10800017 	ldw	r2,0(r2)
 d00dd2c:	e0bff415 	stw	r2,-48(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 d00dd30:	e0bff417 	ldw	r2,-48(fp)
 d00dd34:	1004c03a 	cmpne	r2,r2,zero
 d00dd38:	103fe51e 	bne	r2,zero,d00dcd0 <OSEventPendMulti+0xb8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 d00dd3c:	d0a8f803 	ldbu	r2,-23584(gp)
 d00dd40:	10803fcc 	andi	r2,r2,255
 d00dd44:	1005003a 	cmpeq	r2,r2,zero
 d00dd48:	1000051e 	bne	r2,zero,d00dd60 <OSEventPendMulti+0x148>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 d00dd4c:	e0c00217 	ldw	r3,8(fp)
 d00dd50:	00800084 	movi	r2,2
 d00dd54:	18800005 	stb	r2,0(r3)
        return (0);
 d00dd58:	e03fff15 	stw	zero,-4(fp)
 d00dd5c:	00015506 	br	d00e2b4 <OSEventPendMulti+0x69c>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 d00dd60:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00dd64:	10803fcc 	andi	r2,r2,255
 d00dd68:	1005003a 	cmpeq	r2,r2,zero
 d00dd6c:	1000051e 	bne	r2,zero,d00dd84 <OSEventPendMulti+0x16c>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 d00dd70:	e0c00217 	ldw	r3,8(fp)
 d00dd74:	00800344 	movi	r2,13
 d00dd78:	18800005 	stb	r2,0(r3)
        return (0);
 d00dd7c:	e03fff15 	stw	zero,-4(fp)
 d00dd80:	00014c06 	br	d00e2b4 <OSEventPendMulti+0x69c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00dd84:	0005303a 	rdctl	r2,status
 d00dd88:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00dd8c:	e0ffef17 	ldw	r3,-68(fp)
 d00dd90:	00bfff84 	movi	r2,-2
 d00dd94:	1884703a 	and	r2,r3,r2
 d00dd98:	1001703a 	wrctl	status,r2
  
  return context;
 d00dd9c:	e0bfef17 	ldw	r2,-68(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 d00dda0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
 d00dda4:	e03ff205 	stb	zero,-56(fp)
    events_rdy_nbr =  0;
 d00dda8:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 d00ddac:	e03ff105 	stb	zero,-60(fp)
    pevents        =  pevents_pend;
 d00ddb0:	e0bff617 	ldw	r2,-40(fp)
 d00ddb4:	e0bff515 	stw	r2,-44(fp)
    pevent         = *pevents;
 d00ddb8:	e0bff517 	ldw	r2,-44(fp)
 d00ddbc:	10800017 	ldw	r2,0(r2)
 d00ddc0:	e0bff415 	stw	r2,-48(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 d00ddc4:	00008f06 	br	d00e004 <OSEventPendMulti+0x3ec>
        switch (pevent->OSEventType) {
 d00ddc8:	e0bff417 	ldw	r2,-48(fp)
 d00ddcc:	10800003 	ldbu	r2,0(r2)
 d00ddd0:	10803fcc 	andi	r2,r2,255
 d00ddd4:	e0bffd15 	stw	r2,-12(fp)
 d00ddd8:	e0fffd17 	ldw	r3,-12(fp)
 d00dddc:	188000a0 	cmpeqi	r2,r3,2
 d00dde0:	1000441e 	bne	r2,zero,d00def4 <OSEventPendMulti+0x2dc>
 d00dde4:	e0fffd17 	ldw	r3,-12(fp)
 d00dde8:	188000e0 	cmpeqi	r2,r3,3
 d00ddec:	1000041e 	bne	r2,zero,d00de00 <OSEventPendMulti+0x1e8>
 d00ddf0:	e0fffd17 	ldw	r3,-12(fp)
 d00ddf4:	18800060 	cmpeqi	r2,r3,1
 d00ddf8:	1000211e 	bne	r2,zero,d00de80 <OSEventPendMulti+0x268>
 d00ddfc:	00006f06 	br	d00dfbc <OSEventPendMulti+0x3a4>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 d00de00:	e0bff417 	ldw	r2,-48(fp)
 d00de04:	1080020b 	ldhu	r2,8(r2)
 d00de08:	10bfffcc 	andi	r2,r2,65535
 d00de0c:	1005003a 	cmpeq	r2,r2,zero
 d00de10:	1000171e 	bne	r2,zero,d00de70 <OSEventPendMulti+0x258>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 d00de14:	e0bff417 	ldw	r2,-48(fp)
 d00de18:	1080020b 	ldhu	r2,8(r2)
 d00de1c:	10bfffc4 	addi	r2,r2,-1
 d00de20:	1007883a 	mov	r3,r2
 d00de24:	e0bff417 	ldw	r2,-48(fp)
 d00de28:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 d00de2c:	e0fff717 	ldw	r3,-36(fp)
 d00de30:	e0bff417 	ldw	r2,-48(fp)
 d00de34:	18800015 	stw	r2,0(r3)
 d00de38:	e0bff717 	ldw	r2,-36(fp)
 d00de3c:	10800104 	addi	r2,r2,4
 d00de40:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   =  OS_TRUE;
 d00de44:	00800044 	movi	r2,1
 d00de48:	e0bff205 	stb	r2,-56(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 d00de4c:	e0bff817 	ldw	r2,-32(fp)
 d00de50:	10000015 	stw	zero,0(r2)
 d00de54:	e0bff817 	ldw	r2,-32(fp)
 d00de58:	10800104 	addi	r2,r2,4
 d00de5c:	e0bff815 	stw	r2,-32(fp)
                      events_rdy_nbr++;
 d00de60:	e0bff18b 	ldhu	r2,-58(fp)
 d00de64:	10800044 	addi	r2,r2,1
 d00de68:	e0bff18d 	sth	r2,-58(fp)
 d00de6c:	00005f06 	br	d00dfec <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 d00de70:	e0bff103 	ldbu	r2,-60(fp)
 d00de74:	10800054 	ori	r2,r2,1
 d00de78:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 d00de7c:	00005b06 	br	d00dfec <OSEventPendMulti+0x3d4>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 d00de80:	e0bff417 	ldw	r2,-48(fp)
 d00de84:	10800117 	ldw	r2,4(r2)
 d00de88:	1005003a 	cmpeq	r2,r2,zero
 d00de8c:	1000151e 	bne	r2,zero,d00dee4 <OSEventPendMulti+0x2cc>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 d00de90:	e0bff417 	ldw	r2,-48(fp)
 d00de94:	10c00117 	ldw	r3,4(r2)
 d00de98:	e0bff817 	ldw	r2,-32(fp)
 d00de9c:	10c00015 	stw	r3,0(r2)
 d00dea0:	e0bff817 	ldw	r2,-32(fp)
 d00dea4:	10800104 	addi	r2,r2,4
 d00dea8:	e0bff815 	stw	r2,-32(fp)
                     pevent->OSEventPtr  = (void *)0;
 d00deac:	e0bff417 	ldw	r2,-48(fp)
 d00deb0:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 d00deb4:	e0fff717 	ldw	r3,-36(fp)
 d00deb8:	e0bff417 	ldw	r2,-48(fp)
 d00debc:	18800015 	stw	r2,0(r3)
 d00dec0:	e0bff717 	ldw	r2,-36(fp)
 d00dec4:	10800104 	addi	r2,r2,4
 d00dec8:	e0bff715 	stw	r2,-36(fp)
                      events_rdy         =  OS_TRUE;
 d00decc:	00800044 	movi	r2,1
 d00ded0:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 d00ded4:	e0bff18b 	ldhu	r2,-58(fp)
 d00ded8:	10800044 	addi	r2,r2,1
 d00dedc:	e0bff18d 	sth	r2,-58(fp)
 d00dee0:	00004206 	br	d00dfec <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 d00dee4:	e0bff103 	ldbu	r2,-60(fp)
 d00dee8:	10800094 	ori	r2,r2,2
 d00deec:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 d00def0:	00003e06 	br	d00dfec <OSEventPendMulti+0x3d4>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 d00def4:	e0bff417 	ldw	r2,-48(fp)
 d00def8:	10800117 	ldw	r2,4(r2)
 d00defc:	e0bff315 	stw	r2,-52(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 d00df00:	e0bff317 	ldw	r2,-52(fp)
 d00df04:	1080058b 	ldhu	r2,22(r2)
 d00df08:	10bfffcc 	andi	r2,r2,65535
 d00df0c:	1005003a 	cmpeq	r2,r2,zero
 d00df10:	1000261e 	bne	r2,zero,d00dfac <OSEventPendMulti+0x394>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 d00df14:	e0bff317 	ldw	r2,-52(fp)
 d00df18:	11000417 	ldw	r4,16(r2)
 d00df1c:	20c00017 	ldw	r3,0(r4)
 d00df20:	e0bff817 	ldw	r2,-32(fp)
 d00df24:	10c00015 	stw	r3,0(r2)
 d00df28:	e0bff817 	ldw	r2,-32(fp)
 d00df2c:	10800104 	addi	r2,r2,4
 d00df30:	e0bff815 	stw	r2,-32(fp)
 d00df34:	20c00104 	addi	r3,r4,4
 d00df38:	e0bff317 	ldw	r2,-52(fp)
 d00df3c:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 d00df40:	e0bff317 	ldw	r2,-52(fp)
 d00df44:	10c00417 	ldw	r3,16(r2)
 d00df48:	e0bff317 	ldw	r2,-52(fp)
 d00df4c:	10800217 	ldw	r2,8(r2)
 d00df50:	1880041e 	bne	r3,r2,d00df64 <OSEventPendMulti+0x34c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 d00df54:	e0bff317 	ldw	r2,-52(fp)
 d00df58:	10c00117 	ldw	r3,4(r2)
 d00df5c:	e0bff317 	ldw	r2,-52(fp)
 d00df60:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 d00df64:	e0bff317 	ldw	r2,-52(fp)
 d00df68:	1080058b 	ldhu	r2,22(r2)
 d00df6c:	10bfffc4 	addi	r2,r2,-1
 d00df70:	1007883a 	mov	r3,r2
 d00df74:	e0bff317 	ldw	r2,-52(fp)
 d00df78:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 d00df7c:	e0fff717 	ldw	r3,-36(fp)
 d00df80:	e0bff417 	ldw	r2,-48(fp)
 d00df84:	18800015 	stw	r2,0(r3)
 d00df88:	e0bff717 	ldw	r2,-36(fp)
 d00df8c:	10800104 	addi	r2,r2,4
 d00df90:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   = OS_TRUE;
 d00df94:	00800044 	movi	r2,1
 d00df98:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 d00df9c:	e0bff18b 	ldhu	r2,-58(fp)
 d00dfa0:	10800044 	addi	r2,r2,1
 d00dfa4:	e0bff18d 	sth	r2,-58(fp)
 d00dfa8:	00001006 	br	d00dfec <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 d00dfac:	e0bff103 	ldbu	r2,-60(fp)
 d00dfb0:	10800114 	ori	r2,r2,4
 d00dfb4:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 d00dfb8:	00000c06 	br	d00dfec <OSEventPendMulti+0x3d4>
 d00dfbc:	e0bff017 	ldw	r2,-64(fp)
 d00dfc0:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00dfc4:	e0bfee17 	ldw	r2,-72(fp)
 d00dfc8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 d00dfcc:	e0bff717 	ldw	r2,-36(fp)
 d00dfd0:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 d00dfd4:	e0c00217 	ldw	r3,8(fp)
 d00dfd8:	00800044 	movi	r2,1
 d00dfdc:	18800005 	stb	r2,0(r3)
                 return (events_rdy_nbr);
 d00dfe0:	e0bff18b 	ldhu	r2,-58(fp)
 d00dfe4:	e0bfff15 	stw	r2,-4(fp)
 d00dfe8:	0000b206 	br	d00e2b4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 d00dfec:	e0bff517 	ldw	r2,-44(fp)
 d00dff0:	10800104 	addi	r2,r2,4
 d00dff4:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 d00dff8:	e0bff517 	ldw	r2,-44(fp)
 d00dffc:	10800017 	ldw	r2,0(r2)
 d00e000:	e0bff415 	stw	r2,-48(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 d00e004:	e0bff417 	ldw	r2,-48(fp)
 d00e008:	1004c03a 	cmpne	r2,r2,zero
 d00e00c:	103f6e1e 	bne	r2,zero,d00ddc8 <OSEventPendMulti+0x1b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 d00e010:	e0bff203 	ldbu	r2,-56(fp)
 d00e014:	10800058 	cmpnei	r2,r2,1
 d00e018:	10000b1e 	bne	r2,zero,d00e048 <OSEventPendMulti+0x430>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 d00e01c:	e0bff717 	ldw	r2,-36(fp)
 d00e020:	10000015 	stw	zero,0(r2)
 d00e024:	e0bff017 	ldw	r2,-64(fp)
 d00e028:	e0bfed15 	stw	r2,-76(fp)
 d00e02c:	e0bfed17 	ldw	r2,-76(fp)
 d00e030:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 d00e034:	e0800217 	ldw	r2,8(fp)
 d00e038:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 d00e03c:	e0fff18b 	ldhu	r3,-58(fp)
 d00e040:	e0ffff15 	stw	r3,-4(fp)
 d00e044:	00009b06 	br	d00e2b4 <OSEventPendMulti+0x69c>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 d00e048:	d128f917 	ldw	r4,-23580(gp)
 d00e04c:	d0a8f917 	ldw	r2,-23580(gp)
 d00e050:	10c00c03 	ldbu	r3,48(r2)
 d00e054:	e0bff103 	ldbu	r2,-60(fp)
 d00e058:	1884b03a 	or	r2,r3,r2
 d00e05c:	1007883a 	mov	r3,r2
 d00e060:	00bfe004 	movi	r2,-128
 d00e064:	1884b03a 	or	r2,r3,r2
 d00e068:	20800c05 	stb	r2,48(r4)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d00e06c:	d0a8f917 	ldw	r2,-23580(gp)
 d00e070:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 d00e074:	d0e8f917 	ldw	r3,-23580(gp)
 d00e078:	e0bff90b 	ldhu	r2,-28(fp)
 d00e07c:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 d00e080:	e13ff617 	ldw	r4,-40(fp)
 d00e084:	d00ec480 	call	d00ec48 <OS_EventTaskWaitMulti>
 d00e088:	e0bff017 	ldw	r2,-64(fp)
 d00e08c:	e0bfec15 	stw	r2,-80(fp)
 d00e090:	e0bfec17 	ldw	r2,-80(fp)
 d00e094:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 d00e098:	d00f3e40 	call	d00f3e4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e09c:	0005303a 	rdctl	r2,status
 d00e0a0:	e0bfeb15 	stw	r2,-84(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e0a4:	e0ffeb17 	ldw	r3,-84(fp)
 d00e0a8:	00bfff84 	movi	r2,-2
 d00e0ac:	1884703a 	and	r2,r3,r2
 d00e0b0:	1001703a 	wrctl	status,r2
  
  return context;
 d00e0b4:	e0bfeb17 	ldw	r2,-84(fp)
    OS_ENTER_CRITICAL();
 d00e0b8:	e0bff015 	stw	r2,-64(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 d00e0bc:	d0a8f917 	ldw	r2,-23580(gp)
 d00e0c0:	10800c43 	ldbu	r2,49(r2)
 d00e0c4:	10803fcc 	andi	r2,r2,255
 d00e0c8:	e0bffc15 	stw	r2,-16(fp)
 d00e0cc:	e0fffc17 	ldw	r3,-16(fp)
 d00e0d0:	1805003a 	cmpeq	r2,r3,zero
 d00e0d4:	1000041e 	bne	r2,zero,d00e0e8 <OSEventPendMulti+0x4d0>
 d00e0d8:	e0fffc17 	ldw	r3,-16(fp)
 d00e0dc:	188000a0 	cmpeqi	r2,r3,2
 d00e0e0:	1000011e 	bne	r2,zero,d00e0e8 <OSEventPendMulti+0x4d0>
 d00e0e4:	00001906 	br	d00e14c <OSEventPendMulti+0x534>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 d00e0e8:	d0a8f917 	ldw	r2,-23580(gp)
 d00e0ec:	10800717 	ldw	r2,28(r2)
 d00e0f0:	e0bff415 	stw	r2,-48(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 d00e0f4:	e0bff417 	ldw	r2,-48(fp)
 d00e0f8:	1005003a 	cmpeq	r2,r2,zero
 d00e0fc:	10000c1e 	bne	r2,zero,d00e130 <OSEventPendMulti+0x518>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 d00e100:	e0fff717 	ldw	r3,-36(fp)
 d00e104:	e0bff417 	ldw	r2,-48(fp)
 d00e108:	18800015 	stw	r2,0(r3)
 d00e10c:	e0bff717 	ldw	r2,-36(fp)
 d00e110:	10800104 	addi	r2,r2,4
 d00e114:	e0bff715 	stw	r2,-36(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 d00e118:	e0bff717 	ldw	r2,-36(fp)
 d00e11c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 d00e120:	e0bff18b 	ldhu	r2,-58(fp)
 d00e124:	10800044 	addi	r2,r2,1
 d00e128:	e0bff18d 	sth	r2,-58(fp)
 d00e12c:	00000a06 	br	d00e158 <OSEventPendMulti+0x540>

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 d00e130:	d0a8f917 	ldw	r2,-23580(gp)
 d00e134:	00c00044 	movi	r3,1
 d00e138:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 d00e13c:	d128f917 	ldw	r4,-23580(gp)
 d00e140:	e17ff617 	ldw	r5,-40(fp)
 d00e144:	d00ee540 	call	d00ee54 <OS_EventTaskRemoveMulti>
             }
			 break;
 d00e148:	00000306 	br	d00e158 <OSEventPendMulti+0x540>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 d00e14c:	d128f917 	ldw	r4,-23580(gp)
 d00e150:	e17ff617 	ldw	r5,-40(fp)
 d00e154:	d00ee540 	call	d00ee54 <OS_EventTaskRemoveMulti>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
 d00e158:	d0a8f917 	ldw	r2,-23580(gp)
 d00e15c:	10800c43 	ldbu	r2,49(r2)
 d00e160:	10803fcc 	andi	r2,r2,255
 d00e164:	e0bffb15 	stw	r2,-20(fp)
 d00e168:	e0fffb17 	ldw	r3,-20(fp)
 d00e16c:	1805003a 	cmpeq	r2,r3,zero
 d00e170:	1000041e 	bne	r2,zero,d00e184 <OSEventPendMulti+0x56c>
 d00e174:	e0fffb17 	ldw	r3,-20(fp)
 d00e178:	188000a0 	cmpeqi	r2,r3,2
 d00e17c:	10002c1e 	bne	r2,zero,d00e230 <OSEventPendMulti+0x618>
 d00e180:	00003406 	br	d00e254 <OSEventPendMulti+0x63c>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 d00e184:	e0bff417 	ldw	r2,-48(fp)
 d00e188:	10800003 	ldbu	r2,0(r2)
 d00e18c:	10803fcc 	andi	r2,r2,255
 d00e190:	e0bffa15 	stw	r2,-24(fp)
 d00e194:	e0fffa17 	ldw	r3,-24(fp)
 d00e198:	18800050 	cmplti	r2,r3,1
 d00e19c:	1000151e 	bne	r2,zero,d00e1f4 <OSEventPendMulti+0x5dc>
 d00e1a0:	e0fffa17 	ldw	r3,-24(fp)
 d00e1a4:	188000d0 	cmplti	r2,r3,3
 d00e1a8:	10000a1e 	bne	r2,zero,d00e1d4 <OSEventPendMulti+0x5bc>
 d00e1ac:	e0fffa17 	ldw	r3,-24(fp)
 d00e1b0:	188000e0 	cmpeqi	r2,r3,3
 d00e1b4:	1000011e 	bne	r2,zero,d00e1bc <OSEventPendMulti+0x5a4>
 d00e1b8:	00000e06 	br	d00e1f4 <OSEventPendMulti+0x5dc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 d00e1bc:	e0bff817 	ldw	r2,-32(fp)
 d00e1c0:	10000015 	stw	zero,0(r2)
 d00e1c4:	e0bff817 	ldw	r2,-32(fp)
 d00e1c8:	10800104 	addi	r2,r2,4
 d00e1cc:	e0bff815 	stw	r2,-32(fp)
                      break;
 d00e1d0:	00001406 	br	d00e224 <OSEventPendMulti+0x60c>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 d00e1d4:	d0a8f917 	ldw	r2,-23580(gp)
 d00e1d8:	10c00917 	ldw	r3,36(r2)
 d00e1dc:	e0bff817 	ldw	r2,-32(fp)
 d00e1e0:	10c00015 	stw	r3,0(r2)
 d00e1e4:	e0bff817 	ldw	r2,-32(fp)
 d00e1e8:	10800104 	addi	r2,r2,4
 d00e1ec:	e0bff815 	stw	r2,-32(fp)
                      break;
 d00e1f0:	00000c06 	br	d00e224 <OSEventPendMulti+0x60c>
 d00e1f4:	e0bff017 	ldw	r2,-64(fp)
 d00e1f8:	e0bfea15 	stw	r2,-88(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e1fc:	e0bfea17 	ldw	r2,-88(fp)
 d00e200:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 d00e204:	e0bff717 	ldw	r2,-36(fp)
 d00e208:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 d00e20c:	e0c00217 	ldw	r3,8(fp)
 d00e210:	00800044 	movi	r2,1
 d00e214:	18800005 	stb	r2,0(r3)
                      return (events_rdy_nbr);
 d00e218:	e0bff18b 	ldhu	r2,-58(fp)
 d00e21c:	e0bfff15 	stw	r2,-4(fp)
 d00e220:	00002406 	br	d00e2b4 <OSEventPendMulti+0x69c>
             }
            *perr = OS_ERR_NONE;
 d00e224:	e0800217 	ldw	r2,8(fp)
 d00e228:	10000005 	stb	zero,0(r2)
             break;
 d00e22c:	00001106 	br	d00e274 <OSEventPendMulti+0x65c>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 d00e230:	e0bff817 	ldw	r2,-32(fp)
 d00e234:	10000015 	stw	zero,0(r2)
 d00e238:	e0bff817 	ldw	r2,-32(fp)
 d00e23c:	10800104 	addi	r2,r2,4
 d00e240:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 d00e244:	e0c00217 	ldw	r3,8(fp)
 d00e248:	00800384 	movi	r2,14
 d00e24c:	18800005 	stb	r2,0(r3)
             break;
 d00e250:	00000806 	br	d00e274 <OSEventPendMulti+0x65c>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 d00e254:	e0bff817 	ldw	r2,-32(fp)
 d00e258:	10000015 	stw	zero,0(r2)
 d00e25c:	e0bff817 	ldw	r2,-32(fp)
 d00e260:	10800104 	addi	r2,r2,4
 d00e264:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 d00e268:	e0c00217 	ldw	r3,8(fp)
 d00e26c:	00800284 	movi	r2,10
 d00e270:	18800005 	stb	r2,0(r3)
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 d00e274:	d0a8f917 	ldw	r2,-23580(gp)
 d00e278:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 d00e27c:	d0a8f917 	ldw	r2,-23580(gp)
 d00e280:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 d00e284:	d0a8f917 	ldw	r2,-23580(gp)
 d00e288:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 d00e28c:	d0a8f917 	ldw	r2,-23580(gp)
 d00e290:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 d00e294:	d0a8f917 	ldw	r2,-23580(gp)
 d00e298:	10000915 	stw	zero,36(r2)
 d00e29c:	e0bff017 	ldw	r2,-64(fp)
 d00e2a0:	e0bfe915 	stw	r2,-92(fp)
 d00e2a4:	e0bfe917 	ldw	r2,-92(fp)
 d00e2a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 d00e2ac:	e0fff18b 	ldhu	r3,-58(fp)
 d00e2b0:	e0ffff15 	stw	r3,-4(fp)
 d00e2b4:	e0bfff17 	ldw	r2,-4(fp)
}
 d00e2b8:	e037883a 	mov	sp,fp
 d00e2bc:	dfc00117 	ldw	ra,4(sp)
 d00e2c0:	df000017 	ldw	fp,0(sp)
 d00e2c4:	dec00204 	addi	sp,sp,8
 d00e2c8:	f800283a 	ret

0d00e2cc <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 d00e2cc:	defffe04 	addi	sp,sp,-8
 d00e2d0:	dfc00115 	stw	ra,4(sp)
 d00e2d4:	df000015 	stw	fp,0(sp)
 d00e2d8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 d00e2dc:	d0367140 	call	d036714 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 d00e2e0:	d00f09c0 	call	d00f09c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 d00e2e4:	d00f0e00 	call	d00f0e0 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 d00e2e8:	d00f2440 	call	d00f244 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 d00e2ec:	d00efc00 	call	d00efc0 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 d00e2f0:	d0112f40 	call	d0112f4 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 d00e2f4:	d011ccc0 	call	d011ccc <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 d00e2f8:	d0130280 	call	d013028 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 d00e2fc:	d00f14c0 	call	d00f14c <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 d00e300:	d00f1c80 	call	d00f1c8 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 d00e304:	d0367300 	call	d036730 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 d00e308:	d00facc0 	call	d00facc <OSDebugInit>
#endif
}
 d00e30c:	e037883a 	mov	sp,fp
 d00e310:	dfc00117 	ldw	ra,4(sp)
 d00e314:	df000017 	ldw	fp,0(sp)
 d00e318:	dec00204 	addi	sp,sp,8
 d00e31c:	f800283a 	ret

0d00e320 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 d00e320:	defffc04 	addi	sp,sp,-16
 d00e324:	df000315 	stw	fp,12(sp)
 d00e328:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00e32c:	e03fff15 	stw	zero,-4(fp)
#endif

    if (OSRunning == OS_TRUE) {
 d00e330:	d0a8ea43 	ldbu	r2,-23639(gp)
 d00e334:	10803fcc 	andi	r2,r2,255
 d00e338:	10800058 	cmpnei	r2,r2,1
 d00e33c:	1000131e 	bne	r2,zero,d00e38c <OSIntEnter+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e340:	0005303a 	rdctl	r2,status
 d00e344:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e348:	e0fffe17 	ldw	r3,-8(fp)
 d00e34c:	00bfff84 	movi	r2,-2
 d00e350:	1884703a 	and	r2,r3,r2
 d00e354:	1001703a 	wrctl	status,r2
  
  return context;
 d00e358:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e35c:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting < 255u) {
 d00e360:	d0a8f803 	ldbu	r2,-23584(gp)
 d00e364:	10803fcc 	andi	r2,r2,255
 d00e368:	10803fe0 	cmpeqi	r2,r2,255
 d00e36c:	1000031e 	bne	r2,zero,d00e37c <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 d00e370:	d0a8f803 	ldbu	r2,-23584(gp)
 d00e374:	10800044 	addi	r2,r2,1
 d00e378:	d0a8f805 	stb	r2,-23584(gp)
 d00e37c:	e0bfff17 	ldw	r2,-4(fp)
 d00e380:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e384:	e0bffd17 	ldw	r2,-12(fp)
 d00e388:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
 d00e38c:	e037883a 	mov	sp,fp
 d00e390:	df000017 	ldw	fp,0(sp)
 d00e394:	dec00104 	addi	sp,sp,4
 d00e398:	f800283a 	ret

0d00e39c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 d00e39c:	defffb04 	addi	sp,sp,-20
 d00e3a0:	dfc00415 	stw	ra,16(sp)
 d00e3a4:	df000315 	stw	fp,12(sp)
 d00e3a8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00e3ac:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {
 d00e3b0:	d0a8ea43 	ldbu	r2,-23639(gp)
 d00e3b4:	10803fcc 	andi	r2,r2,255
 d00e3b8:	10800058 	cmpnei	r2,r2,1
 d00e3bc:	1000321e 	bne	r2,zero,d00e488 <OSIntExit+0xec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e3c0:	0005303a 	rdctl	r2,status
 d00e3c4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e3c8:	e0fffe17 	ldw	r3,-8(fp)
 d00e3cc:	00bfff84 	movi	r2,-2
 d00e3d0:	1884703a 	and	r2,r3,r2
 d00e3d4:	1001703a 	wrctl	status,r2
  
  return context;
 d00e3d8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e3dc:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 d00e3e0:	d0a8f803 	ldbu	r2,-23584(gp)
 d00e3e4:	10803fcc 	andi	r2,r2,255
 d00e3e8:	1005003a 	cmpeq	r2,r2,zero
 d00e3ec:	1000031e 	bne	r2,zero,d00e3fc <OSIntExit+0x60>
            OSIntNesting--;
 d00e3f0:	d0a8f803 	ldbu	r2,-23584(gp)
 d00e3f4:	10bfffc4 	addi	r2,r2,-1
 d00e3f8:	d0a8f805 	stb	r2,-23584(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 d00e3fc:	d0a8f803 	ldbu	r2,-23584(gp)
 d00e400:	10803fcc 	andi	r2,r2,255
 d00e404:	1004c03a 	cmpne	r2,r2,zero
 d00e408:	10001b1e 	bne	r2,zero,d00e478 <OSIntExit+0xdc>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 d00e40c:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00e410:	10803fcc 	andi	r2,r2,255
 d00e414:	1004c03a 	cmpne	r2,r2,zero
 d00e418:	1000171e 	bne	r2,zero,d00e478 <OSIntExit+0xdc>
                OS_SchedNew();
 d00e41c:	d00f4b80 	call	d00f4b8 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 d00e420:	d0a8ec03 	ldbu	r2,-23632(gp)
 d00e424:	d0e8ec43 	ldbu	r3,-23631(gp)
 d00e428:	11003fcc 	andi	r4,r2,255
 d00e42c:	18803fcc 	andi	r2,r3,255
 d00e430:	20801126 	beq	r4,r2,d00e478 <OSIntExit+0xdc>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 d00e434:	d0a8ec03 	ldbu	r2,-23632(gp)
 d00e438:	10803fcc 	andi	r2,r2,255
 d00e43c:	00c341b4 	movhi	r3,3334
 d00e440:	18c1b004 	addi	r3,r3,1728
 d00e444:	1085883a 	add	r2,r2,r2
 d00e448:	1085883a 	add	r2,r2,r2
 d00e44c:	10c5883a 	add	r2,r2,r3
 d00e450:	10800017 	ldw	r2,0(r2)
 d00e454:	d0a8f415 	stw	r2,-23600(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 d00e458:	d0e8f417 	ldw	r3,-23600(gp)
 d00e45c:	18800e17 	ldw	r2,56(r3)
 d00e460:	10800044 	addi	r2,r2,1
 d00e464:	18800e15 	stw	r2,56(r3)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 d00e468:	d0a8ef17 	ldw	r2,-23620(gp)
 d00e46c:	10800044 	addi	r2,r2,1
 d00e470:	d0a8ef15 	stw	r2,-23620(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 d00e474:	d0362940 	call	d036294 <OSCtxSw>
 d00e478:	e0bfff17 	ldw	r2,-4(fp)
 d00e47c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e480:	e0bffd17 	ldw	r2,-12(fp)
 d00e484:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 d00e488:	e037883a 	mov	sp,fp
 d00e48c:	dfc00117 	ldw	ra,4(sp)
 d00e490:	df000017 	ldw	fp,0(sp)
 d00e494:	dec00204 	addi	sp,sp,8
 d00e498:	f800283a 	ret

0d00e49c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 d00e49c:	defffc04 	addi	sp,sp,-16
 d00e4a0:	df000315 	stw	fp,12(sp)
 d00e4a4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00e4a8:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 d00e4ac:	d0a8ea43 	ldbu	r2,-23639(gp)
 d00e4b0:	10803fcc 	andi	r2,r2,255
 d00e4b4:	10800058 	cmpnei	r2,r2,1
 d00e4b8:	1000171e 	bne	r2,zero,d00e518 <OSSchedLock+0x7c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e4bc:	0005303a 	rdctl	r2,status
 d00e4c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e4c4:	e0fffe17 	ldw	r3,-8(fp)
 d00e4c8:	00bfff84 	movi	r2,-2
 d00e4cc:	1884703a 	and	r2,r3,r2
 d00e4d0:	1001703a 	wrctl	status,r2
  
  return context;
 d00e4d4:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e4d8:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 d00e4dc:	d0a8f803 	ldbu	r2,-23584(gp)
 d00e4e0:	10803fcc 	andi	r2,r2,255
 d00e4e4:	1004c03a 	cmpne	r2,r2,zero
 d00e4e8:	1000071e 	bne	r2,zero,d00e508 <OSSchedLock+0x6c>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 d00e4ec:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00e4f0:	10803fcc 	andi	r2,r2,255
 d00e4f4:	10803fe0 	cmpeqi	r2,r2,255
 d00e4f8:	1000031e 	bne	r2,zero,d00e508 <OSSchedLock+0x6c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 d00e4fc:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00e500:	10800044 	addi	r2,r2,1
 d00e504:	d0a8ea05 	stb	r2,-23640(gp)
 d00e508:	e0bfff17 	ldw	r2,-4(fp)
 d00e50c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e510:	e0bffd17 	ldw	r2,-12(fp)
 d00e514:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 d00e518:	e037883a 	mov	sp,fp
 d00e51c:	df000017 	ldw	fp,0(sp)
 d00e520:	dec00104 	addi	sp,sp,4
 d00e524:	f800283a 	ret

0d00e528 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 d00e528:	defff804 	addi	sp,sp,-32
 d00e52c:	dfc00715 	stw	ra,28(sp)
 d00e530:	df000615 	stw	fp,24(sp)
 d00e534:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00e538:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 d00e53c:	d0a8ea43 	ldbu	r2,-23639(gp)
 d00e540:	10803fcc 	andi	r2,r2,255
 d00e544:	10800058 	cmpnei	r2,r2,1
 d00e548:	10002b1e 	bne	r2,zero,d00e5f8 <OSSchedUnlock+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e54c:	0005303a 	rdctl	r2,status
 d00e550:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e554:	e0fffe17 	ldw	r3,-8(fp)
 d00e558:	00bfff84 	movi	r2,-2
 d00e55c:	1884703a 	and	r2,r3,r2
 d00e560:	1001703a 	wrctl	status,r2
  
  return context;
 d00e564:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e568:	e0bfff15 	stw	r2,-4(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 d00e56c:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00e570:	10803fcc 	andi	r2,r2,255
 d00e574:	1005003a 	cmpeq	r2,r2,zero
 d00e578:	10001b1e 	bne	r2,zero,d00e5e8 <OSSchedUnlock+0xc0>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 d00e57c:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00e580:	10bfffc4 	addi	r2,r2,-1
 d00e584:	d0a8ea05 	stb	r2,-23640(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 d00e588:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00e58c:	10803fcc 	andi	r2,r2,255
 d00e590:	1004c03a 	cmpne	r2,r2,zero
 d00e594:	10000f1e 	bne	r2,zero,d00e5d4 <OSSchedUnlock+0xac>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 d00e598:	d0a8f803 	ldbu	r2,-23584(gp)
 d00e59c:	10803fcc 	andi	r2,r2,255
 d00e5a0:	1004c03a 	cmpne	r2,r2,zero
 d00e5a4:	1000061e 	bne	r2,zero,d00e5c0 <OSSchedUnlock+0x98>
 d00e5a8:	e0bfff17 	ldw	r2,-4(fp)
 d00e5ac:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e5b0:	e0bffd17 	ldw	r2,-12(fp)
 d00e5b4:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 d00e5b8:	d00f3e40 	call	d00f3e4 <OS_Sched>
 d00e5bc:	00000e06 	br	d00e5f8 <OSSchedUnlock+0xd0>
 d00e5c0:	e0bfff17 	ldw	r2,-4(fp)
 d00e5c4:	e0bffc15 	stw	r2,-16(fp)
 d00e5c8:	e0bffc17 	ldw	r2,-16(fp)
 d00e5cc:	1001703a 	wrctl	status,r2
 d00e5d0:	00000906 	br	d00e5f8 <OSSchedUnlock+0xd0>
 d00e5d4:	e0bfff17 	ldw	r2,-4(fp)
 d00e5d8:	e0bffb15 	stw	r2,-20(fp)
 d00e5dc:	e0bffb17 	ldw	r2,-20(fp)
 d00e5e0:	1001703a 	wrctl	status,r2
 d00e5e4:	00000406 	br	d00e5f8 <OSSchedUnlock+0xd0>
 d00e5e8:	e0bfff17 	ldw	r2,-4(fp)
 d00e5ec:	e0bffa15 	stw	r2,-24(fp)
 d00e5f0:	e0bffa17 	ldw	r2,-24(fp)
 d00e5f4:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 d00e5f8:	e037883a 	mov	sp,fp
 d00e5fc:	dfc00117 	ldw	ra,4(sp)
 d00e600:	df000017 	ldw	fp,0(sp)
 d00e604:	dec00204 	addi	sp,sp,8
 d00e608:	f800283a 	ret

0d00e60c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 d00e60c:	defffe04 	addi	sp,sp,-8
 d00e610:	dfc00115 	stw	ra,4(sp)
 d00e614:	df000015 	stw	fp,0(sp)
 d00e618:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 d00e61c:	d0a8ea43 	ldbu	r2,-23639(gp)
 d00e620:	10803fcc 	andi	r2,r2,255
 d00e624:	1004c03a 	cmpne	r2,r2,zero
 d00e628:	10000f1e 	bne	r2,zero,d00e668 <OSStart+0x5c>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 d00e62c:	d00f4b80 	call	d00f4b8 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 d00e630:	d0a8ec03 	ldbu	r2,-23632(gp)
 d00e634:	d0a8ec45 	stb	r2,-23631(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 d00e638:	d0a8ec03 	ldbu	r2,-23632(gp)
 d00e63c:	10803fcc 	andi	r2,r2,255
 d00e640:	00c341b4 	movhi	r3,3334
 d00e644:	18c1b004 	addi	r3,r3,1728
 d00e648:	1085883a 	add	r2,r2,r2
 d00e64c:	1085883a 	add	r2,r2,r2
 d00e650:	10c5883a 	add	r2,r2,r3
 d00e654:	10800017 	ldw	r2,0(r2)
 d00e658:	d0a8f415 	stw	r2,-23600(gp)
        OSTCBCur      = OSTCBHighRdy;
 d00e65c:	d0a8f417 	ldw	r2,-23600(gp)
 d00e660:	d0a8f915 	stw	r2,-23580(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 d00e664:	d0363200 	call	d036320 <OSStartHighRdy>
    }
}
 d00e668:	e037883a 	mov	sp,fp
 d00e66c:	dfc00117 	ldw	ra,4(sp)
 d00e670:	df000017 	ldw	fp,0(sp)
 d00e674:	dec00204 	addi	sp,sp,8
 d00e678:	f800283a 	ret

0d00e67c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 d00e67c:	defff904 	addi	sp,sp,-28
 d00e680:	dfc00615 	stw	ra,24(sp)
 d00e684:	df000515 	stw	fp,20(sp)
 d00e688:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00e68c:	e03fff15 	stw	zero,-4(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 d00e690:	01000084 	movi	r4,2
 d00e694:	d0156dc0 	call	d0156dc <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e698:	0005303a 	rdctl	r2,status
 d00e69c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e6a0:	e0fffe17 	ldw	r3,-8(fp)
 d00e6a4:	00bfff84 	movi	r2,-2
 d00e6a8:	1884703a 	and	r2,r3,r2
 d00e6ac:	1001703a 	wrctl	status,r2
  
  return context;
 d00e6b0:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 d00e6b4:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 d00e6b8:	d028eb15 	stw	zero,-23636(gp)
 d00e6bc:	e0bfff17 	ldw	r2,-4(fp)
 d00e6c0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e6c4:	e0bffd17 	ldw	r2,-12(fp)
 d00e6c8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 d00e6cc:	01000284 	movi	r4,10
 d00e6d0:	d0156dc0 	call	d0156dc <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e6d4:	0005303a 	rdctl	r2,status
 d00e6d8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e6dc:	e0fffc17 	ldw	r3,-16(fp)
 d00e6e0:	00bfff84 	movi	r2,-2
 d00e6e4:	1884703a 	and	r2,r3,r2
 d00e6e8:	1001703a 	wrctl	status,r2
  
  return context;
 d00e6ec:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 d00e6f0:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 d00e6f4:	d0a8eb17 	ldw	r2,-23636(gp)
 d00e6f8:	d0a8f015 	stw	r2,-23616(gp)
    OSStatRdy    = OS_TRUE;
 d00e6fc:	00800044 	movi	r2,1
 d00e700:	d0a8fc05 	stb	r2,-23568(gp)
 d00e704:	e0bfff17 	ldw	r2,-4(fp)
 d00e708:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e70c:	e0bffb17 	ldw	r2,-20(fp)
 d00e710:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 d00e714:	e037883a 	mov	sp,fp
 d00e718:	dfc00117 	ldw	ra,4(sp)
 d00e71c:	df000017 	ldw	fp,0(sp)
 d00e720:	dec00204 	addi	sp,sp,8
 d00e724:	f800283a 	ret

0d00e728 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 d00e728:	defff604 	addi	sp,sp,-40
 d00e72c:	dfc00915 	stw	ra,36(sp)
 d00e730:	df000815 	stw	fp,32(sp)
 d00e734:	df000804 	addi	fp,sp,32
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d00e738:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 d00e73c:	d0366ec0 	call	d0366ec <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e740:	0005303a 	rdctl	r2,status
 d00e744:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e748:	e0fffb17 	ldw	r3,-20(fp)
 d00e74c:	00bfff84 	movi	r2,-2
 d00e750:	1884703a 	and	r2,r3,r2
 d00e754:	1001703a 	wrctl	status,r2
  
  return context;
 d00e758:	e0bffb17 	ldw	r2,-20(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 d00e75c:	e0bffc15 	stw	r2,-16(fp)
    OSTime++;
 d00e760:	d0a8fa17 	ldw	r2,-23576(gp)
 d00e764:	10800044 	addi	r2,r2,1
 d00e768:	d0a8fa15 	stw	r2,-23576(gp)
 d00e76c:	e0bffc17 	ldw	r2,-16(fp)
 d00e770:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e774:	e0bffa17 	ldw	r2,-24(fp)
 d00e778:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 d00e77c:	d0a8ea43 	ldbu	r2,-23639(gp)
 d00e780:	10803fcc 	andi	r2,r2,255
 d00e784:	10800058 	cmpnei	r2,r2,1
 d00e788:	1000721e 	bne	r2,zero,d00e954 <OSTimeTick+0x22c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 d00e78c:	d0a8ee03 	ldbu	r2,-23624(gp)
 d00e790:	10803fcc 	andi	r2,r2,255
 d00e794:	e0bfff15 	stw	r2,-4(fp)
 d00e798:	e0ffff17 	ldw	r3,-4(fp)
 d00e79c:	18800060 	cmpeqi	r2,r3,1
 d00e7a0:	10000a1e 	bne	r2,zero,d00e7cc <OSTimeTick+0xa4>
 d00e7a4:	e0ffff17 	ldw	r3,-4(fp)
 d00e7a8:	188000a0 	cmpeqi	r2,r3,2
 d00e7ac:	1000091e 	bne	r2,zero,d00e7d4 <OSTimeTick+0xac>
 d00e7b0:	e0ffff17 	ldw	r3,-4(fp)
 d00e7b4:	1805003a 	cmpeq	r2,r3,zero
 d00e7b8:	1000011e 	bne	r2,zero,d00e7c0 <OSTimeTick+0x98>
 d00e7bc:	00000a06 	br	d00e7e8 <OSTimeTick+0xc0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 d00e7c0:	00800044 	movi	r2,1
 d00e7c4:	e0bffd05 	stb	r2,-12(fp)
                 break;
 d00e7c8:	00000a06 	br	d00e7f4 <OSTimeTick+0xcc>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 d00e7cc:	e03ffd05 	stb	zero,-12(fp)
                 break;
 d00e7d0:	00000806 	br	d00e7f4 <OSTimeTick+0xcc>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 d00e7d4:	00800044 	movi	r2,1
 d00e7d8:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 d00e7dc:	00800044 	movi	r2,1
 d00e7e0:	d0a8ee05 	stb	r2,-23624(gp)
                 break;
 d00e7e4:	00000306 	br	d00e7f4 <OSTimeTick+0xcc>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 d00e7e8:	00800044 	movi	r2,1
 d00e7ec:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 d00e7f0:	d028ee05 	stb	zero,-23624(gp)
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 d00e7f4:	e0bffd03 	ldbu	r2,-12(fp)
 d00e7f8:	1005003a 	cmpeq	r2,r2,zero
 d00e7fc:	1000551e 	bne	r2,zero,d00e954 <OSTimeTick+0x22c>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 d00e800:	d0a8ed17 	ldw	r2,-23628(gp)
 d00e804:	e0bffe15 	stw	r2,-8(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 d00e808:	00004d06 	br	d00e940 <OSTimeTick+0x218>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e80c:	0005303a 	rdctl	r2,status
 d00e810:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e814:	e0fff917 	ldw	r3,-28(fp)
 d00e818:	00bfff84 	movi	r2,-2
 d00e81c:	1884703a 	and	r2,r3,r2
 d00e820:	1001703a 	wrctl	status,r2
  
  return context;
 d00e824:	e0bff917 	ldw	r2,-28(fp)
            OS_ENTER_CRITICAL();
 d00e828:	e0bffc15 	stw	r2,-16(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 d00e82c:	e0bffe17 	ldw	r2,-8(fp)
 d00e830:	10800b8b 	ldhu	r2,46(r2)
 d00e834:	10bfffcc 	andi	r2,r2,65535
 d00e838:	1005003a 	cmpeq	r2,r2,zero
 d00e83c:	1000391e 	bne	r2,zero,d00e924 <OSTimeTick+0x1fc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 d00e840:	e0bffe17 	ldw	r2,-8(fp)
 d00e844:	10800b8b 	ldhu	r2,46(r2)
 d00e848:	10bfffc4 	addi	r2,r2,-1
 d00e84c:	1007883a 	mov	r3,r2
 d00e850:	e0bffe17 	ldw	r2,-8(fp)
 d00e854:	10c00b8d 	sth	r3,46(r2)
 d00e858:	e0bffe17 	ldw	r2,-8(fp)
 d00e85c:	10800b8b 	ldhu	r2,46(r2)
 d00e860:	10bfffcc 	andi	r2,r2,65535
 d00e864:	1004c03a 	cmpne	r2,r2,zero
 d00e868:	10002e1e 	bne	r2,zero,d00e924 <OSTimeTick+0x1fc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 d00e86c:	e0bffe17 	ldw	r2,-8(fp)
 d00e870:	10800c03 	ldbu	r2,48(r2)
 d00e874:	10803fcc 	andi	r2,r2,255
 d00e878:	10800dcc 	andi	r2,r2,55
 d00e87c:	1005003a 	cmpeq	r2,r2,zero
 d00e880:	10000b1e 	bne	r2,zero,d00e8b0 <OSTimeTick+0x188>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 d00e884:	e0bffe17 	ldw	r2,-8(fp)
 d00e888:	10c00c03 	ldbu	r3,48(r2)
 d00e88c:	00bff204 	movi	r2,-56
 d00e890:	1884703a 	and	r2,r3,r2
 d00e894:	1007883a 	mov	r3,r2
 d00e898:	e0bffe17 	ldw	r2,-8(fp)
 d00e89c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 d00e8a0:	e0fffe17 	ldw	r3,-8(fp)
 d00e8a4:	00800044 	movi	r2,1
 d00e8a8:	18800c45 	stb	r2,49(r3)
 d00e8ac:	00000206 	br	d00e8b8 <OSTimeTick+0x190>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 d00e8b0:	e0bffe17 	ldw	r2,-8(fp)
 d00e8b4:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 d00e8b8:	e0bffe17 	ldw	r2,-8(fp)
 d00e8bc:	10800c03 	ldbu	r2,48(r2)
 d00e8c0:	10803fcc 	andi	r2,r2,255
 d00e8c4:	1080020c 	andi	r2,r2,8
 d00e8c8:	1004c03a 	cmpne	r2,r2,zero
 d00e8cc:	1000151e 	bne	r2,zero,d00e924 <OSTimeTick+0x1fc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 d00e8d0:	e0bffe17 	ldw	r2,-8(fp)
 d00e8d4:	10c00d83 	ldbu	r3,54(r2)
 d00e8d8:	d0a8f603 	ldbu	r2,-23592(gp)
 d00e8dc:	1884b03a 	or	r2,r3,r2
 d00e8e0:	d0a8f605 	stb	r2,-23592(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d00e8e4:	e0bffe17 	ldw	r2,-8(fp)
 d00e8e8:	10800d03 	ldbu	r2,52(r2)
 d00e8ec:	11003fcc 	andi	r4,r2,255
 d00e8f0:	e0bffe17 	ldw	r2,-8(fp)
 d00e8f4:	10800d03 	ldbu	r2,52(r2)
 d00e8f8:	10c03fcc 	andi	r3,r2,255
 d00e8fc:	d0a8f644 	addi	r2,gp,-23591
 d00e900:	1885883a 	add	r2,r3,r2
 d00e904:	10c00003 	ldbu	r3,0(r2)
 d00e908:	e0bffe17 	ldw	r2,-8(fp)
 d00e90c:	10800d43 	ldbu	r2,53(r2)
 d00e910:	1884b03a 	or	r2,r3,r2
 d00e914:	1007883a 	mov	r3,r2
 d00e918:	d0a8f644 	addi	r2,gp,-23591
 d00e91c:	2085883a 	add	r2,r4,r2
 d00e920:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 d00e924:	e0bffe17 	ldw	r2,-8(fp)
 d00e928:	10800517 	ldw	r2,20(r2)
 d00e92c:	e0bffe15 	stw	r2,-8(fp)
 d00e930:	e0bffc17 	ldw	r2,-16(fp)
 d00e934:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e938:	e0bff817 	ldw	r2,-32(fp)
 d00e93c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 d00e940:	e0bffe17 	ldw	r2,-8(fp)
 d00e944:	10800c83 	ldbu	r2,50(r2)
 d00e948:	10803fcc 	andi	r2,r2,255
 d00e94c:	10800518 	cmpnei	r2,r2,20
 d00e950:	103fae1e 	bne	r2,zero,d00e80c <OSTimeTick+0xe4>
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 d00e954:	e037883a 	mov	sp,fp
 d00e958:	dfc00117 	ldw	ra,4(sp)
 d00e95c:	df000017 	ldw	fp,0(sp)
 d00e960:	dec00204 	addi	sp,sp,8
 d00e964:	f800283a 	ret

0d00e968 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 d00e968:	deffff04 	addi	sp,sp,-4
 d00e96c:	df000015 	stw	fp,0(sp)
 d00e970:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 d00e974:	00804784 	movi	r2,286
}
 d00e978:	e037883a 	mov	sp,fp
 d00e97c:	df000017 	ldw	fp,0(sp)
 d00e980:	dec00104 	addi	sp,sp,4
 d00e984:	f800283a 	ret

0d00e988 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 d00e988:	deffff04 	addi	sp,sp,-4
 d00e98c:	df000015 	stw	fp,0(sp)
 d00e990:	d839883a 	mov	fp,sp
}
 d00e994:	e037883a 	mov	sp,fp
 d00e998:	df000017 	ldw	fp,0(sp)
 d00e99c:	dec00104 	addi	sp,sp,4
 d00e9a0:	f800283a 	ret

0d00e9a4 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 d00e9a4:	defff804 	addi	sp,sp,-32
 d00e9a8:	dfc00715 	stw	ra,28(sp)
 d00e9ac:	df000615 	stw	fp,24(sp)
 d00e9b0:	df000604 	addi	fp,sp,24
 d00e9b4:	e13ffc15 	stw	r4,-16(fp)
 d00e9b8:	e17ffd15 	stw	r5,-12(fp)
 d00e9bc:	e1bffe05 	stb	r6,-8(fp)
 d00e9c0:	e1ffff05 	stb	r7,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 d00e9c4:	e0bffc17 	ldw	r2,-16(fp)
 d00e9c8:	10800283 	ldbu	r2,10(r2)
 d00e9cc:	10c03fcc 	andi	r3,r2,255
 d00e9d0:	00834174 	movhi	r2,3333
 d00e9d4:	10b97604 	addi	r2,r2,-6696
 d00e9d8:	10c5883a 	add	r2,r2,r3
 d00e9dc:	10800003 	ldbu	r2,0(r2)
 d00e9e0:	e0bffa85 	stb	r2,-22(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 d00e9e4:	e0fffa83 	ldbu	r3,-22(fp)
 d00e9e8:	e0bffc17 	ldw	r2,-16(fp)
 d00e9ec:	1885883a 	add	r2,r3,r2
 d00e9f0:	10800204 	addi	r2,r2,8
 d00e9f4:	108000c3 	ldbu	r2,3(r2)
 d00e9f8:	10c03fcc 	andi	r3,r2,255
 d00e9fc:	00834174 	movhi	r2,3333
 d00ea00:	10b97604 	addi	r2,r2,-6696
 d00ea04:	10c5883a 	add	r2,r2,r3
 d00ea08:	10800003 	ldbu	r2,0(r2)
 d00ea0c:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 d00ea10:	e0bffa83 	ldbu	r2,-22(fp)
 d00ea14:	100490fa 	slli	r2,r2,3
 d00ea18:	1007883a 	mov	r3,r2
 d00ea1c:	e0bffa43 	ldbu	r2,-23(fp)
 d00ea20:	1885883a 	add	r2,r3,r2
 d00ea24:	e0bffa05 	stb	r2,-24(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 d00ea28:	e0bffa03 	ldbu	r2,-24(fp)
 d00ea2c:	00c341b4 	movhi	r3,3334
 d00ea30:	18c1b004 	addi	r3,r3,1728
 d00ea34:	1085883a 	add	r2,r2,r2
 d00ea38:	1085883a 	add	r2,r2,r2
 d00ea3c:	10c5883a 	add	r2,r2,r3
 d00ea40:	10800017 	ldw	r2,0(r2)
 d00ea44:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 d00ea48:	e0bffb17 	ldw	r2,-20(fp)
 d00ea4c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 d00ea50:	e0fffb17 	ldw	r3,-20(fp)
 d00ea54:	e0bffd17 	ldw	r2,-12(fp)
 d00ea58:	18800915 	stw	r2,36(r3)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 d00ea5c:	e0bffb17 	ldw	r2,-20(fp)
 d00ea60:	10800c03 	ldbu	r2,48(r2)
 d00ea64:	1007883a 	mov	r3,r2
 d00ea68:	e0bffe03 	ldbu	r2,-8(fp)
 d00ea6c:	0084303a 	nor	r2,zero,r2
 d00ea70:	1884703a 	and	r2,r3,r2
 d00ea74:	1007883a 	mov	r3,r2
 d00ea78:	e0bffb17 	ldw	r2,-20(fp)
 d00ea7c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 d00ea80:	e0fffb17 	ldw	r3,-20(fp)
 d00ea84:	e0bfff03 	ldbu	r2,-4(fp)
 d00ea88:	18800c45 	stb	r2,49(r3)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 d00ea8c:	e0bffb17 	ldw	r2,-20(fp)
 d00ea90:	10800c03 	ldbu	r2,48(r2)
 d00ea94:	10803fcc 	andi	r2,r2,255
 d00ea98:	1080020c 	andi	r2,r2,8
 d00ea9c:	1004c03a 	cmpne	r2,r2,zero
 d00eaa0:	1000111e 	bne	r2,zero,d00eae8 <OS_EventTaskRdy+0x144>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 d00eaa4:	e0bffb17 	ldw	r2,-20(fp)
 d00eaa8:	10c00d83 	ldbu	r3,54(r2)
 d00eaac:	d0a8f603 	ldbu	r2,-23592(gp)
 d00eab0:	1884b03a 	or	r2,r3,r2
 d00eab4:	d0a8f605 	stb	r2,-23592(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 d00eab8:	e13ffa83 	ldbu	r4,-22(fp)
 d00eabc:	e0fffa83 	ldbu	r3,-22(fp)
 d00eac0:	d0a8f644 	addi	r2,gp,-23591
 d00eac4:	1885883a 	add	r2,r3,r2
 d00eac8:	10c00003 	ldbu	r3,0(r2)
 d00eacc:	e0bffb17 	ldw	r2,-20(fp)
 d00ead0:	10800d43 	ldbu	r2,53(r2)
 d00ead4:	1884b03a 	or	r2,r3,r2
 d00ead8:	1007883a 	mov	r3,r2
 d00eadc:	d0a8f644 	addi	r2,gp,-23591
 d00eae0:	2085883a 	add	r2,r4,r2
 d00eae4:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 d00eae8:	e13ffb17 	ldw	r4,-20(fp)
 d00eaec:	e17ffc17 	ldw	r5,-16(fp)
 d00eaf0:	d00ed9c0 	call	d00ed9c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 d00eaf4:	e0bffb17 	ldw	r2,-20(fp)
 d00eaf8:	10800817 	ldw	r2,32(r2)
 d00eafc:	1005003a 	cmpeq	r2,r2,zero
 d00eb00:	1000071e 	bne	r2,zero,d00eb20 <OS_EventTaskRdy+0x17c>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 d00eb04:	e0bffb17 	ldw	r2,-20(fp)
 d00eb08:	11400817 	ldw	r5,32(r2)
 d00eb0c:	e13ffb17 	ldw	r4,-20(fp)
 d00eb10:	d00ee540 	call	d00ee54 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 d00eb14:	e0fffb17 	ldw	r3,-20(fp)
 d00eb18:	e0bffc17 	ldw	r2,-16(fp)
 d00eb1c:	18800715 	stw	r2,28(r3)
    }
#endif

    return (prio);
 d00eb20:	e0bffa03 	ldbu	r2,-24(fp)
}
 d00eb24:	e037883a 	mov	sp,fp
 d00eb28:	dfc00117 	ldw	ra,4(sp)
 d00eb2c:	df000017 	ldw	fp,0(sp)
 d00eb30:	dec00204 	addi	sp,sp,8
 d00eb34:	f800283a 	ret

0d00eb38 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 d00eb38:	defffd04 	addi	sp,sp,-12
 d00eb3c:	df000215 	stw	fp,8(sp)
 d00eb40:	df000204 	addi	fp,sp,8
 d00eb44:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 d00eb48:	d0e8f917 	ldw	r3,-23580(gp)
 d00eb4c:	e0bfff17 	ldw	r2,-4(fp)
 d00eb50:	18800715 	stw	r2,28(r3)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 d00eb54:	d0a8f917 	ldw	r2,-23580(gp)
 d00eb58:	10800d03 	ldbu	r2,52(r2)
 d00eb5c:	11003fcc 	andi	r4,r2,255
 d00eb60:	d0a8f917 	ldw	r2,-23580(gp)
 d00eb64:	10800d03 	ldbu	r2,52(r2)
 d00eb68:	10c03fcc 	andi	r3,r2,255
 d00eb6c:	e0bfff17 	ldw	r2,-4(fp)
 d00eb70:	1885883a 	add	r2,r3,r2
 d00eb74:	10800204 	addi	r2,r2,8
 d00eb78:	10c000c3 	ldbu	r3,3(r2)
 d00eb7c:	d0a8f917 	ldw	r2,-23580(gp)
 d00eb80:	10800d43 	ldbu	r2,53(r2)
 d00eb84:	1884b03a 	or	r2,r3,r2
 d00eb88:	1007883a 	mov	r3,r2
 d00eb8c:	e0bfff17 	ldw	r2,-4(fp)
 d00eb90:	2085883a 	add	r2,r4,r2
 d00eb94:	10800204 	addi	r2,r2,8
 d00eb98:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 d00eb9c:	e0bfff17 	ldw	r2,-4(fp)
 d00eba0:	10c00283 	ldbu	r3,10(r2)
 d00eba4:	d0a8f917 	ldw	r2,-23580(gp)
 d00eba8:	10800d83 	ldbu	r2,54(r2)
 d00ebac:	1884b03a 	or	r2,r3,r2
 d00ebb0:	1007883a 	mov	r3,r2
 d00ebb4:	e0bfff17 	ldw	r2,-4(fp)
 d00ebb8:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 d00ebbc:	d0a8f917 	ldw	r2,-23580(gp)
 d00ebc0:	10800d03 	ldbu	r2,52(r2)
 d00ebc4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 d00ebc8:	e13ffe03 	ldbu	r4,-8(fp)
 d00ebcc:	e0fffe03 	ldbu	r3,-8(fp)
 d00ebd0:	d0a8f644 	addi	r2,gp,-23591
 d00ebd4:	1885883a 	add	r2,r3,r2
 d00ebd8:	10800003 	ldbu	r2,0(r2)
 d00ebdc:	1007883a 	mov	r3,r2
 d00ebe0:	d0a8f917 	ldw	r2,-23580(gp)
 d00ebe4:	10800d43 	ldbu	r2,53(r2)
 d00ebe8:	0084303a 	nor	r2,zero,r2
 d00ebec:	1884703a 	and	r2,r3,r2
 d00ebf0:	1007883a 	mov	r3,r2
 d00ebf4:	d0a8f644 	addi	r2,gp,-23591
 d00ebf8:	2085883a 	add	r2,r4,r2
 d00ebfc:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 d00ec00:	e0fffe03 	ldbu	r3,-8(fp)
 d00ec04:	d0a8f644 	addi	r2,gp,-23591
 d00ec08:	1885883a 	add	r2,r3,r2
 d00ec0c:	10800003 	ldbu	r2,0(r2)
 d00ec10:	10803fcc 	andi	r2,r2,255
 d00ec14:	1004c03a 	cmpne	r2,r2,zero
 d00ec18:	1000071e 	bne	r2,zero,d00ec38 <OS_EventTaskWait+0x100>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 d00ec1c:	d0a8f917 	ldw	r2,-23580(gp)
 d00ec20:	10800d83 	ldbu	r2,54(r2)
 d00ec24:	0084303a 	nor	r2,zero,r2
 d00ec28:	1007883a 	mov	r3,r2
 d00ec2c:	d0a8f603 	ldbu	r2,-23592(gp)
 d00ec30:	1884703a 	and	r2,r3,r2
 d00ec34:	d0a8f605 	stb	r2,-23592(gp)
    }
}
 d00ec38:	e037883a 	mov	sp,fp
 d00ec3c:	df000017 	ldw	fp,0(sp)
 d00ec40:	dec00104 	addi	sp,sp,4
 d00ec44:	f800283a 	ret

0d00ec48 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 d00ec48:	defffb04 	addi	sp,sp,-20
 d00ec4c:	df000415 	stw	fp,16(sp)
 d00ec50:	df000404 	addi	fp,sp,16
 d00ec54:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 d00ec58:	d0a8f917 	ldw	r2,-23580(gp)
 d00ec5c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 d00ec60:	d0e8f917 	ldw	r3,-23580(gp)
 d00ec64:	e0bfff17 	ldw	r2,-4(fp)
 d00ec68:	18800815 	stw	r2,32(r3)

    pevents =  pevents_wait;
 d00ec6c:	e0bfff17 	ldw	r2,-4(fp)
 d00ec70:	e0bffe15 	stw	r2,-8(fp)
    pevent  = *pevents;
 d00ec74:	e0bffe17 	ldw	r2,-8(fp)
 d00ec78:	10800017 	ldw	r2,0(r2)
 d00ec7c:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 d00ec80:	00002006 	br	d00ed04 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 d00ec84:	d0a8f917 	ldw	r2,-23580(gp)
 d00ec88:	10800d03 	ldbu	r2,52(r2)
 d00ec8c:	11003fcc 	andi	r4,r2,255
 d00ec90:	d0a8f917 	ldw	r2,-23580(gp)
 d00ec94:	10800d03 	ldbu	r2,52(r2)
 d00ec98:	10c03fcc 	andi	r3,r2,255
 d00ec9c:	e0bffd17 	ldw	r2,-12(fp)
 d00eca0:	1885883a 	add	r2,r3,r2
 d00eca4:	10800204 	addi	r2,r2,8
 d00eca8:	10c000c3 	ldbu	r3,3(r2)
 d00ecac:	d0a8f917 	ldw	r2,-23580(gp)
 d00ecb0:	10800d43 	ldbu	r2,53(r2)
 d00ecb4:	1884b03a 	or	r2,r3,r2
 d00ecb8:	1007883a 	mov	r3,r2
 d00ecbc:	e0bffd17 	ldw	r2,-12(fp)
 d00ecc0:	2085883a 	add	r2,r4,r2
 d00ecc4:	10800204 	addi	r2,r2,8
 d00ecc8:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 d00eccc:	e0bffd17 	ldw	r2,-12(fp)
 d00ecd0:	10c00283 	ldbu	r3,10(r2)
 d00ecd4:	d0a8f917 	ldw	r2,-23580(gp)
 d00ecd8:	10800d83 	ldbu	r2,54(r2)
 d00ecdc:	1884b03a 	or	r2,r3,r2
 d00ece0:	1007883a 	mov	r3,r2
 d00ece4:	e0bffd17 	ldw	r2,-12(fp)
 d00ece8:	10c00285 	stb	r3,10(r2)
        pevents++;
 d00ecec:	e0bffe17 	ldw	r2,-8(fp)
 d00ecf0:	10800104 	addi	r2,r2,4
 d00ecf4:	e0bffe15 	stw	r2,-8(fp)
        pevent = *pevents;
 d00ecf8:	e0bffe17 	ldw	r2,-8(fp)
 d00ecfc:	10800017 	ldw	r2,0(r2)
 d00ed00:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 d00ed04:	e0bffd17 	ldw	r2,-12(fp)
 d00ed08:	1004c03a 	cmpne	r2,r2,zero
 d00ed0c:	103fdd1e 	bne	r2,zero,d00ec84 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 d00ed10:	d0a8f917 	ldw	r2,-23580(gp)
 d00ed14:	10800d03 	ldbu	r2,52(r2)
 d00ed18:	e0bffc05 	stb	r2,-16(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 d00ed1c:	e13ffc03 	ldbu	r4,-16(fp)
 d00ed20:	e0fffc03 	ldbu	r3,-16(fp)
 d00ed24:	d0a8f644 	addi	r2,gp,-23591
 d00ed28:	1885883a 	add	r2,r3,r2
 d00ed2c:	10800003 	ldbu	r2,0(r2)
 d00ed30:	1007883a 	mov	r3,r2
 d00ed34:	d0a8f917 	ldw	r2,-23580(gp)
 d00ed38:	10800d43 	ldbu	r2,53(r2)
 d00ed3c:	0084303a 	nor	r2,zero,r2
 d00ed40:	1884703a 	and	r2,r3,r2
 d00ed44:	1007883a 	mov	r3,r2
 d00ed48:	d0a8f644 	addi	r2,gp,-23591
 d00ed4c:	2085883a 	add	r2,r4,r2
 d00ed50:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 d00ed54:	e0fffc03 	ldbu	r3,-16(fp)
 d00ed58:	d0a8f644 	addi	r2,gp,-23591
 d00ed5c:	1885883a 	add	r2,r3,r2
 d00ed60:	10800003 	ldbu	r2,0(r2)
 d00ed64:	10803fcc 	andi	r2,r2,255
 d00ed68:	1004c03a 	cmpne	r2,r2,zero
 d00ed6c:	1000071e 	bne	r2,zero,d00ed8c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 d00ed70:	d0a8f917 	ldw	r2,-23580(gp)
 d00ed74:	10800d83 	ldbu	r2,54(r2)
 d00ed78:	0084303a 	nor	r2,zero,r2
 d00ed7c:	1007883a 	mov	r3,r2
 d00ed80:	d0a8f603 	ldbu	r2,-23592(gp)
 d00ed84:	1884703a 	and	r2,r3,r2
 d00ed88:	d0a8f605 	stb	r2,-23592(gp)
    }
}
 d00ed8c:	e037883a 	mov	sp,fp
 d00ed90:	df000017 	ldw	fp,0(sp)
 d00ed94:	dec00104 	addi	sp,sp,4
 d00ed98:	f800283a 	ret

0d00ed9c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 d00ed9c:	defffc04 	addi	sp,sp,-16
 d00eda0:	df000315 	stw	fp,12(sp)
 d00eda4:	df000304 	addi	fp,sp,12
 d00eda8:	e13ffe15 	stw	r4,-8(fp)
 d00edac:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 d00edb0:	e0bffe17 	ldw	r2,-8(fp)
 d00edb4:	10800d03 	ldbu	r2,52(r2)
 d00edb8:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 d00edbc:	e13ffd03 	ldbu	r4,-12(fp)
 d00edc0:	e0fffd03 	ldbu	r3,-12(fp)
 d00edc4:	e0bfff17 	ldw	r2,-4(fp)
 d00edc8:	1885883a 	add	r2,r3,r2
 d00edcc:	10800204 	addi	r2,r2,8
 d00edd0:	108000c3 	ldbu	r2,3(r2)
 d00edd4:	1007883a 	mov	r3,r2
 d00edd8:	e0bffe17 	ldw	r2,-8(fp)
 d00eddc:	10800d43 	ldbu	r2,53(r2)
 d00ede0:	0084303a 	nor	r2,zero,r2
 d00ede4:	1884703a 	and	r2,r3,r2
 d00ede8:	1007883a 	mov	r3,r2
 d00edec:	e0bfff17 	ldw	r2,-4(fp)
 d00edf0:	2085883a 	add	r2,r4,r2
 d00edf4:	10800204 	addi	r2,r2,8
 d00edf8:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
 d00edfc:	e0fffd03 	ldbu	r3,-12(fp)
 d00ee00:	e0bfff17 	ldw	r2,-4(fp)
 d00ee04:	1885883a 	add	r2,r3,r2
 d00ee08:	10800204 	addi	r2,r2,8
 d00ee0c:	108000c3 	ldbu	r2,3(r2)
 d00ee10:	10803fcc 	andi	r2,r2,255
 d00ee14:	1004c03a 	cmpne	r2,r2,zero
 d00ee18:	10000a1e 	bne	r2,zero,d00ee44 <OS_EventTaskRemove+0xa8>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 d00ee1c:	e0bfff17 	ldw	r2,-4(fp)
 d00ee20:	10800283 	ldbu	r2,10(r2)
 d00ee24:	1007883a 	mov	r3,r2
 d00ee28:	e0bffe17 	ldw	r2,-8(fp)
 d00ee2c:	10800d83 	ldbu	r2,54(r2)
 d00ee30:	0084303a 	nor	r2,zero,r2
 d00ee34:	1884703a 	and	r2,r3,r2
 d00ee38:	1007883a 	mov	r3,r2
 d00ee3c:	e0bfff17 	ldw	r2,-4(fp)
 d00ee40:	10c00285 	stb	r3,10(r2)
    }
}
 d00ee44:	e037883a 	mov	sp,fp
 d00ee48:	df000017 	ldw	fp,0(sp)
 d00ee4c:	dec00104 	addi	sp,sp,4
 d00ee50:	f800283a 	ret

0d00ee54 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 d00ee54:	defffa04 	addi	sp,sp,-24
 d00ee58:	df000515 	stw	fp,20(sp)
 d00ee5c:	df000504 	addi	fp,sp,20
 d00ee60:	e13ffe15 	stw	r4,-8(fp)
 d00ee64:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 d00ee68:	e0bffe17 	ldw	r2,-8(fp)
 d00ee6c:	10800d03 	ldbu	r2,52(r2)
 d00ee70:	e0bffb85 	stb	r2,-18(fp)
    bity    =  ptcb->OSTCBBitY;
 d00ee74:	e0bffe17 	ldw	r2,-8(fp)
 d00ee78:	10800d83 	ldbu	r2,54(r2)
 d00ee7c:	e0bffb45 	stb	r2,-19(fp)
    bitx    =  ptcb->OSTCBBitX;
 d00ee80:	e0bffe17 	ldw	r2,-8(fp)
 d00ee84:	10800d43 	ldbu	r2,53(r2)
 d00ee88:	e0bffb05 	stb	r2,-20(fp)
    pevents =  pevents_multi;
 d00ee8c:	e0bfff17 	ldw	r2,-4(fp)
 d00ee90:	e0bffd15 	stw	r2,-12(fp)
    pevent  = *pevents;
 d00ee94:	e0bffd17 	ldw	r2,-12(fp)
 d00ee98:	10800017 	ldw	r2,0(r2)
 d00ee9c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 d00eea0:	00002606 	br	d00ef3c <OS_EventTaskRemoveMulti+0xe8>
        pevent->OSEventTbl[y]  &= ~bitx;
 d00eea4:	e13ffb83 	ldbu	r4,-18(fp)
 d00eea8:	e0fffb83 	ldbu	r3,-18(fp)
 d00eeac:	e0bffc17 	ldw	r2,-16(fp)
 d00eeb0:	1885883a 	add	r2,r3,r2
 d00eeb4:	10800204 	addi	r2,r2,8
 d00eeb8:	108000c3 	ldbu	r2,3(r2)
 d00eebc:	1007883a 	mov	r3,r2
 d00eec0:	e0bffb03 	ldbu	r2,-20(fp)
 d00eec4:	0084303a 	nor	r2,zero,r2
 d00eec8:	1884703a 	and	r2,r3,r2
 d00eecc:	1007883a 	mov	r3,r2
 d00eed0:	e0bffc17 	ldw	r2,-16(fp)
 d00eed4:	2085883a 	add	r2,r4,r2
 d00eed8:	10800204 	addi	r2,r2,8
 d00eedc:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
 d00eee0:	e0fffb83 	ldbu	r3,-18(fp)
 d00eee4:	e0bffc17 	ldw	r2,-16(fp)
 d00eee8:	1885883a 	add	r2,r3,r2
 d00eeec:	10800204 	addi	r2,r2,8
 d00eef0:	108000c3 	ldbu	r2,3(r2)
 d00eef4:	10803fcc 	andi	r2,r2,255
 d00eef8:	1004c03a 	cmpne	r2,r2,zero
 d00eefc:	1000091e 	bne	r2,zero,d00ef24 <OS_EventTaskRemoveMulti+0xd0>
            pevent->OSEventGrp &= ~bity;
 d00ef00:	e0bffc17 	ldw	r2,-16(fp)
 d00ef04:	10800283 	ldbu	r2,10(r2)
 d00ef08:	1007883a 	mov	r3,r2
 d00ef0c:	e0bffb43 	ldbu	r2,-19(fp)
 d00ef10:	0084303a 	nor	r2,zero,r2
 d00ef14:	1884703a 	and	r2,r3,r2
 d00ef18:	1007883a 	mov	r3,r2
 d00ef1c:	e0bffc17 	ldw	r2,-16(fp)
 d00ef20:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 d00ef24:	e0bffd17 	ldw	r2,-12(fp)
 d00ef28:	10800104 	addi	r2,r2,4
 d00ef2c:	e0bffd15 	stw	r2,-12(fp)
        pevent = *pevents;
 d00ef30:	e0bffd17 	ldw	r2,-12(fp)
 d00ef34:	10800017 	ldw	r2,0(r2)
 d00ef38:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 d00ef3c:	e0bffc17 	ldw	r2,-16(fp)
 d00ef40:	1004c03a 	cmpne	r2,r2,zero
 d00ef44:	103fd71e 	bne	r2,zero,d00eea4 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 d00ef48:	e037883a 	mov	sp,fp
 d00ef4c:	df000017 	ldw	fp,0(sp)
 d00ef50:	dec00104 	addi	sp,sp,4
 d00ef54:	f800283a 	ret

0d00ef58 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 d00ef58:	defffc04 	addi	sp,sp,-16
 d00ef5c:	df000315 	stw	fp,12(sp)
 d00ef60:	df000304 	addi	fp,sp,12
 d00ef64:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 d00ef68:	e0bfff17 	ldw	r2,-4(fp)
 d00ef6c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 d00ef70:	e0bfff17 	ldw	r2,-4(fp)
 d00ef74:	108002c4 	addi	r2,r2,11
 d00ef78:	e0bffe15 	stw	r2,-8(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d00ef7c:	e03ffd05 	stb	zero,-12(fp)
 d00ef80:	00000806 	br	d00efa4 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
 d00ef84:	e0bffe17 	ldw	r2,-8(fp)
 d00ef88:	10000005 	stb	zero,0(r2)
 d00ef8c:	e0bffe17 	ldw	r2,-8(fp)
 d00ef90:	10800044 	addi	r2,r2,1
 d00ef94:	e0bffe15 	stw	r2,-8(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d00ef98:	e0bffd03 	ldbu	r2,-12(fp)
 d00ef9c:	10800044 	addi	r2,r2,1
 d00efa0:	e0bffd05 	stb	r2,-12(fp)
 d00efa4:	e0bffd03 	ldbu	r2,-12(fp)
 d00efa8:	108000f0 	cmpltui	r2,r2,3
 d00efac:	103ff51e 	bne	r2,zero,d00ef84 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 d00efb0:	e037883a 	mov	sp,fp
 d00efb4:	df000017 	ldw	fp,0(sp)
 d00efb8:	dec00104 	addi	sp,sp,4
 d00efbc:	f800283a 	ret

0d00efc0 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 d00efc0:	defffb04 	addi	sp,sp,-20
 d00efc4:	dfc00415 	stw	ra,16(sp)
 d00efc8:	df000315 	stw	fp,12(sp)
 d00efcc:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 d00efd0:	010341b4 	movhi	r4,3334
 d00efd4:	213d9c04 	addi	r4,r4,-2448
 d00efd8:	0142d004 	movi	r5,2880
 d00efdc:	d00f3240 	call	d00f324 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 d00efe0:	008341b4 	movhi	r2,3334
 d00efe4:	10bd9c04 	addi	r2,r2,-2448
 d00efe8:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 d00efec:	008341b4 	movhi	r2,3334
 d00eff0:	10bda804 	addi	r2,r2,-2400
 d00eff4:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 d00eff8:	e03fff0d 	sth	zero,-4(fp)
 d00effc:	00001306 	br	d00f04c <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d00f000:	e0bffe17 	ldw	r2,-8(fp)
 d00f004:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 d00f008:	e0fffe17 	ldw	r3,-8(fp)
 d00f00c:	e0bffd17 	ldw	r2,-12(fp)
 d00f010:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 d00f014:	e0fffe17 	ldw	r3,-8(fp)
 d00f018:	00800fc4 	movi	r2,63
 d00f01c:	18800385 	stb	r2,14(r3)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 d00f020:	e0bffe17 	ldw	r2,-8(fp)
 d00f024:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 d00f028:	e0bffe17 	ldw	r2,-8(fp)
 d00f02c:	10800c04 	addi	r2,r2,48
 d00f030:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 d00f034:	e0bffd17 	ldw	r2,-12(fp)
 d00f038:	10800c04 	addi	r2,r2,48
 d00f03c:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 d00f040:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f044:	10800044 	addi	r2,r2,1
 d00f048:	e0bfff0d 	sth	r2,-4(fp)
 d00f04c:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f050:	10800ef0 	cmpltui	r2,r2,59
 d00f054:	103fea1e 	bne	r2,zero,d00f000 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 d00f058:	e0bffe17 	ldw	r2,-8(fp)
 d00f05c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 d00f060:	e0bffe17 	ldw	r2,-8(fp)
 d00f064:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 d00f068:	e0fffe17 	ldw	r3,-8(fp)
 d00f06c:	00800fc4 	movi	r2,63
 d00f070:	18800385 	stb	r2,14(r3)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 d00f074:	e0bffe17 	ldw	r2,-8(fp)
 d00f078:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 d00f07c:	008341b4 	movhi	r2,3334
 d00f080:	10bd9c04 	addi	r2,r2,-2448
 d00f084:	d0a8f715 	stw	r2,-23588(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 d00f088:	e037883a 	mov	sp,fp
 d00f08c:	dfc00117 	ldw	ra,4(sp)
 d00f090:	df000017 	ldw	fp,0(sp)
 d00f094:	dec00204 	addi	sp,sp,8
 d00f098:	f800283a 	ret

0d00f09c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 d00f09c:	deffff04 	addi	sp,sp,-4
 d00f0a0:	df000015 	stw	fp,0(sp)
 d00f0a4:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 d00f0a8:	d028fa15 	stw	zero,-23576(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 d00f0ac:	d028f805 	stb	zero,-23584(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 d00f0b0:	d028ea05 	stb	zero,-23640(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 d00f0b4:	d028f245 	stb	zero,-23607(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 d00f0b8:	d028ea45 	stb	zero,-23639(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 d00f0bc:	d028ef15 	stw	zero,-23620(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 d00f0c0:	d028eb15 	stw	zero,-23636(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 d00f0c4:	d028fd15 	stw	zero,-23564(gp)
    OSIdleCtrMax  = 0L;
 d00f0c8:	d028f015 	stw	zero,-23616(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 d00f0cc:	d028fc05 	stb	zero,-23568(gp)
#endif
}
 d00f0d0:	e037883a 	mov	sp,fp
 d00f0d4:	df000017 	ldw	fp,0(sp)
 d00f0d8:	dec00104 	addi	sp,sp,4
 d00f0dc:	f800283a 	ret

0d00f0e0 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 d00f0e0:	defffd04 	addi	sp,sp,-12
 d00f0e4:	df000215 	stw	fp,8(sp)
 d00f0e8:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 d00f0ec:	d028f605 	stb	zero,-23592(gp)
    prdytbl       = &OSRdyTbl[0];
 d00f0f0:	d0a8f644 	addi	r2,gp,-23591
 d00f0f4:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 d00f0f8:	e03fff05 	stb	zero,-4(fp)
 d00f0fc:	00000806 	br	d00f120 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
 d00f100:	e0bffe17 	ldw	r2,-8(fp)
 d00f104:	10000005 	stb	zero,0(r2)
 d00f108:	e0bffe17 	ldw	r2,-8(fp)
 d00f10c:	10800044 	addi	r2,r2,1
 d00f110:	e0bffe15 	stw	r2,-8(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 d00f114:	e0bfff03 	ldbu	r2,-4(fp)
 d00f118:	10800044 	addi	r2,r2,1
 d00f11c:	e0bfff05 	stb	r2,-4(fp)
 d00f120:	e0bfff03 	ldbu	r2,-4(fp)
 d00f124:	108000f0 	cmpltui	r2,r2,3
 d00f128:	103ff51e 	bne	r2,zero,d00f100 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 d00f12c:	d028ec45 	stb	zero,-23631(gp)
    OSPrioHighRdy = 0;
 d00f130:	d028ec05 	stb	zero,-23632(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 d00f134:	d028f415 	stw	zero,-23600(gp)
    OSTCBCur      = (OS_TCB *)0;
 d00f138:	d028f915 	stw	zero,-23580(gp)
}
 d00f13c:	e037883a 	mov	sp,fp
 d00f140:	df000017 	ldw	fp,0(sp)
 d00f144:	dec00104 	addi	sp,sp,4
 d00f148:	f800283a 	ret

0d00f14c <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 d00f14c:	defff804 	addi	sp,sp,-32
 d00f150:	dfc00715 	stw	ra,28(sp)
 d00f154:	df000615 	stw	fp,24(sp)
 d00f158:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 d00f15c:	018341b4 	movhi	r6,3334
 d00f160:	31bd9b04 	addi	r6,r6,-2452
 d00f164:	00bfffd4 	movui	r2,65535
 d00f168:	d8800015 	stw	r2,0(sp)
 d00f16c:	008341b4 	movhi	r2,3334
 d00f170:	10bb9c04 	addi	r2,r2,-4496
 d00f174:	d8800115 	stw	r2,4(sp)
 d00f178:	00808004 	movi	r2,512
 d00f17c:	d8800215 	stw	r2,8(sp)
 d00f180:	d8000315 	stw	zero,12(sp)
 d00f184:	008000c4 	movi	r2,3
 d00f188:	d8800415 	stw	r2,16(sp)
 d00f18c:	01034074 	movhi	r4,3329
 d00f190:	213d8004 	addi	r4,r4,-2560
 d00f194:	000b883a 	mov	r5,zero
 d00f198:	01c00504 	movi	r7,20
 d00f19c:	d0143e40 	call	d0143e4 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 d00f1a0:	01434174 	movhi	r5,3333
 d00f1a4:	2979b604 	addi	r5,r5,-6440
 d00f1a8:	01000504 	movi	r4,20
 d00f1ac:	e1bfff04 	addi	r6,fp,-4
 d00f1b0:	d014d180 	call	d014d18 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 d00f1b4:	e037883a 	mov	sp,fp
 d00f1b8:	dfc00117 	ldw	ra,4(sp)
 d00f1bc:	df000017 	ldw	fp,0(sp)
 d00f1c0:	dec00204 	addi	sp,sp,8
 d00f1c4:	f800283a 	ret

0d00f1c8 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 d00f1c8:	defff804 	addi	sp,sp,-32
 d00f1cc:	dfc00715 	stw	ra,28(sp)
 d00f1d0:	df000615 	stw	fp,24(sp)
 d00f1d4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 d00f1d8:	018341b4 	movhi	r6,3334
 d00f1dc:	31bb2304 	addi	r6,r6,-4980
 d00f1e0:	00bfff94 	movui	r2,65534
 d00f1e4:	d8800015 	stw	r2,0(sp)
 d00f1e8:	008341b4 	movhi	r2,3334
 d00f1ec:	10b92404 	addi	r2,r2,-7024
 d00f1f0:	d8800115 	stw	r2,4(sp)
 d00f1f4:	00808004 	movi	r2,512
 d00f1f8:	d8800215 	stw	r2,8(sp)
 d00f1fc:	d8000315 	stw	zero,12(sp)
 d00f200:	008000c4 	movi	r2,3
 d00f204:	d8800415 	stw	r2,16(sp)
 d00f208:	01034074 	movhi	r4,3329
 d00f20c:	213d9704 	addi	r4,r4,-2468
 d00f210:	000b883a 	mov	r5,zero
 d00f214:	01c004c4 	movi	r7,19
 d00f218:	d0143e40 	call	d0143e4 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 d00f21c:	01434174 	movhi	r5,3333
 d00f220:	2979ba04 	addi	r5,r5,-6424
 d00f224:	010004c4 	movi	r4,19
 d00f228:	e1bfff04 	addi	r6,fp,-4
 d00f22c:	d014d180 	call	d014d18 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 d00f230:	e037883a 	mov	sp,fp
 d00f234:	dfc00117 	ldw	ra,4(sp)
 d00f238:	df000017 	ldw	fp,0(sp)
 d00f23c:	dec00204 	addi	sp,sp,8
 d00f240:	f800283a 	ret

0d00f244 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 d00f244:	defffb04 	addi	sp,sp,-20
 d00f248:	dfc00415 	stw	ra,16(sp)
 d00f24c:	df000315 	stw	fp,12(sp)
 d00f250:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 d00f254:	010341b4 	movhi	r4,3334
 d00f258:	21006c04 	addi	r4,r4,432
 d00f25c:	01414404 	movi	r5,1296
 d00f260:	d00f3240 	call	d00f324 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 d00f264:	010341b4 	movhi	r4,3334
 d00f268:	2101b004 	addi	r4,r4,1728
 d00f26c:	01401504 	movi	r5,84
 d00f270:	d00f3240 	call	d00f324 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 d00f274:	008341b4 	movhi	r2,3334
 d00f278:	10806c04 	addi	r2,r2,432
 d00f27c:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 d00f280:	008341b4 	movhi	r2,3334
 d00f284:	10808704 	addi	r2,r2,540
 d00f288:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 d00f28c:	e03fff05 	stb	zero,-4(fp)
 d00f290:	00001106 	br	d00f2d8 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 d00f294:	e0fffe17 	ldw	r3,-8(fp)
 d00f298:	e0bffd17 	ldw	r2,-12(fp)
 d00f29c:	18800515 	stw	r2,20(r3)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 d00f2a0:	e0fffe17 	ldw	r3,-8(fp)
 d00f2a4:	00800fc4 	movi	r2,63
 d00f2a8:	18801305 	stb	r2,76(r3)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 d00f2ac:	e0bffe17 	ldw	r2,-8(fp)
 d00f2b0:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 d00f2b4:	e0bffe17 	ldw	r2,-8(fp)
 d00f2b8:	10801b04 	addi	r2,r2,108
 d00f2bc:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 d00f2c0:	e0bffd17 	ldw	r2,-12(fp)
 d00f2c4:	10801b04 	addi	r2,r2,108
 d00f2c8:	e0bffd15 	stw	r2,-12(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 d00f2cc:	e0bfff03 	ldbu	r2,-4(fp)
 d00f2d0:	10800044 	addi	r2,r2,1
 d00f2d4:	e0bfff05 	stb	r2,-4(fp)
 d00f2d8:	e0bfff03 	ldbu	r2,-4(fp)
 d00f2dc:	108002f0 	cmpltui	r2,r2,11
 d00f2e0:	103fec1e 	bne	r2,zero,d00f294 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 d00f2e4:	e0bffe17 	ldw	r2,-8(fp)
 d00f2e8:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 d00f2ec:	e0fffe17 	ldw	r3,-8(fp)
 d00f2f0:	00800fc4 	movi	r2,63
 d00f2f4:	18801305 	stb	r2,76(r3)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 d00f2f8:	e0bffe17 	ldw	r2,-8(fp)
 d00f2fc:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 d00f300:	d028ed15 	stw	zero,-23628(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 d00f304:	008341b4 	movhi	r2,3334
 d00f308:	10806c04 	addi	r2,r2,432
 d00f30c:	d0a8f115 	stw	r2,-23612(gp)
}
 d00f310:	e037883a 	mov	sp,fp
 d00f314:	dfc00117 	ldw	ra,4(sp)
 d00f318:	df000017 	ldw	fp,0(sp)
 d00f31c:	dec00204 	addi	sp,sp,8
 d00f320:	f800283a 	ret

0d00f324 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 d00f324:	defffd04 	addi	sp,sp,-12
 d00f328:	df000215 	stw	fp,8(sp)
 d00f32c:	df000204 	addi	fp,sp,8
 d00f330:	e13ffe15 	stw	r4,-8(fp)
 d00f334:	e17fff0d 	sth	r5,-4(fp)
    while (size > 0) {
 d00f338:	00000806 	br	d00f35c <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 d00f33c:	e0bffe17 	ldw	r2,-8(fp)
 d00f340:	10000005 	stb	zero,0(r2)
 d00f344:	e0bffe17 	ldw	r2,-8(fp)
 d00f348:	10800044 	addi	r2,r2,1
 d00f34c:	e0bffe15 	stw	r2,-8(fp)
        size--;
 d00f350:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f354:	10bfffc4 	addi	r2,r2,-1
 d00f358:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 d00f35c:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f360:	1004c03a 	cmpne	r2,r2,zero
 d00f364:	103ff51e 	bne	r2,zero,d00f33c <OS_MemClr+0x18>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 d00f368:	e037883a 	mov	sp,fp
 d00f36c:	df000017 	ldw	fp,0(sp)
 d00f370:	dec00104 	addi	sp,sp,4
 d00f374:	f800283a 	ret

0d00f378 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 d00f378:	defffc04 	addi	sp,sp,-16
 d00f37c:	df000315 	stw	fp,12(sp)
 d00f380:	df000304 	addi	fp,sp,12
 d00f384:	e13ffd15 	stw	r4,-12(fp)
 d00f388:	e17ffe15 	stw	r5,-8(fp)
 d00f38c:	e1bfff0d 	sth	r6,-4(fp)
    while (size > 0) {
 d00f390:	00000d06 	br	d00f3c8 <OS_MemCopy+0x50>
        *pdest++ = *psrc++;
 d00f394:	e0bffe17 	ldw	r2,-8(fp)
 d00f398:	10c00003 	ldbu	r3,0(r2)
 d00f39c:	e0bffd17 	ldw	r2,-12(fp)
 d00f3a0:	10c00005 	stb	r3,0(r2)
 d00f3a4:	e0bffd17 	ldw	r2,-12(fp)
 d00f3a8:	10800044 	addi	r2,r2,1
 d00f3ac:	e0bffd15 	stw	r2,-12(fp)
 d00f3b0:	e0bffe17 	ldw	r2,-8(fp)
 d00f3b4:	10800044 	addi	r2,r2,1
 d00f3b8:	e0bffe15 	stw	r2,-8(fp)
        size--;
 d00f3bc:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f3c0:	10bfffc4 	addi	r2,r2,-1
 d00f3c4:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 d00f3c8:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f3cc:	1004c03a 	cmpne	r2,r2,zero
 d00f3d0:	103ff01e 	bne	r2,zero,d00f394 <OS_MemCopy+0x1c>
        *pdest++ = *psrc++;
        size--;
    }
}
 d00f3d4:	e037883a 	mov	sp,fp
 d00f3d8:	df000017 	ldw	fp,0(sp)
 d00f3dc:	dec00104 	addi	sp,sp,4
 d00f3e0:	f800283a 	ret

0d00f3e4 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 d00f3e4:	defffb04 	addi	sp,sp,-20
 d00f3e8:	dfc00415 	stw	ra,16(sp)
 d00f3ec:	df000315 	stw	fp,12(sp)
 d00f3f0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d00f3f4:	e03fff15 	stw	zero,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f3f8:	0005303a 	rdctl	r2,status
 d00f3fc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f400:	e0fffe17 	ldw	r3,-8(fp)
 d00f404:	00bfff84 	movi	r2,-2
 d00f408:	1884703a 	and	r2,r3,r2
 d00f40c:	1001703a 	wrctl	status,r2
  
  return context;
 d00f410:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 d00f414:	e0bfff15 	stw	r2,-4(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 d00f418:	d0a8f803 	ldbu	r2,-23584(gp)
 d00f41c:	10803fcc 	andi	r2,r2,255
 d00f420:	1004c03a 	cmpne	r2,r2,zero
 d00f424:	10001b1e 	bne	r2,zero,d00f494 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 d00f428:	d0a8ea03 	ldbu	r2,-23640(gp)
 d00f42c:	10803fcc 	andi	r2,r2,255
 d00f430:	1004c03a 	cmpne	r2,r2,zero
 d00f434:	1000171e 	bne	r2,zero,d00f494 <OS_Sched+0xb0>
            OS_SchedNew();
 d00f438:	d00f4b80 	call	d00f4b8 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 d00f43c:	d0a8ec03 	ldbu	r2,-23632(gp)
 d00f440:	d0e8ec43 	ldbu	r3,-23631(gp)
 d00f444:	11003fcc 	andi	r4,r2,255
 d00f448:	18803fcc 	andi	r2,r3,255
 d00f44c:	20801126 	beq	r4,r2,d00f494 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 d00f450:	d0a8ec03 	ldbu	r2,-23632(gp)
 d00f454:	10803fcc 	andi	r2,r2,255
 d00f458:	00c341b4 	movhi	r3,3334
 d00f45c:	18c1b004 	addi	r3,r3,1728
 d00f460:	1085883a 	add	r2,r2,r2
 d00f464:	1085883a 	add	r2,r2,r2
 d00f468:	10c5883a 	add	r2,r2,r3
 d00f46c:	10800017 	ldw	r2,0(r2)
 d00f470:	d0a8f415 	stw	r2,-23600(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 d00f474:	d0e8f417 	ldw	r3,-23600(gp)
 d00f478:	18800e17 	ldw	r2,56(r3)
 d00f47c:	10800044 	addi	r2,r2,1
 d00f480:	18800e15 	stw	r2,56(r3)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 d00f484:	d0a8ef17 	ldw	r2,-23620(gp)
 d00f488:	10800044 	addi	r2,r2,1
 d00f48c:	d0a8ef15 	stw	r2,-23620(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 d00f490:	d0362940 	call	d036294 <OSCtxSw>
 d00f494:	e0bfff17 	ldw	r2,-4(fp)
 d00f498:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f49c:	e0bffd17 	ldw	r2,-12(fp)
 d00f4a0:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 d00f4a4:	e037883a 	mov	sp,fp
 d00f4a8:	dfc00117 	ldw	ra,4(sp)
 d00f4ac:	df000017 	ldw	fp,0(sp)
 d00f4b0:	dec00204 	addi	sp,sp,8
 d00f4b4:	f800283a 	ret

0d00f4b8 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 d00f4b8:	defffe04 	addi	sp,sp,-8
 d00f4bc:	df000115 	stw	fp,4(sp)
 d00f4c0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 d00f4c4:	d0a8f603 	ldbu	r2,-23592(gp)
 d00f4c8:	10c03fcc 	andi	r3,r2,255
 d00f4cc:	00834174 	movhi	r2,3333
 d00f4d0:	10b97604 	addi	r2,r2,-6696
 d00f4d4:	10c5883a 	add	r2,r2,r3
 d00f4d8:	10800003 	ldbu	r2,0(r2)
 d00f4dc:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 d00f4e0:	e0bfff03 	ldbu	r2,-4(fp)
 d00f4e4:	100490fa 	slli	r2,r2,3
 d00f4e8:	1009883a 	mov	r4,r2
 d00f4ec:	e0ffff03 	ldbu	r3,-4(fp)
 d00f4f0:	d0a8f644 	addi	r2,gp,-23591
 d00f4f4:	1885883a 	add	r2,r3,r2
 d00f4f8:	10800003 	ldbu	r2,0(r2)
 d00f4fc:	10c03fcc 	andi	r3,r2,255
 d00f500:	00834174 	movhi	r2,3333
 d00f504:	10b97604 	addi	r2,r2,-6696
 d00f508:	10c5883a 	add	r2,r2,r3
 d00f50c:	10800003 	ldbu	r2,0(r2)
 d00f510:	2085883a 	add	r2,r4,r2
 d00f514:	d0a8ec05 	stb	r2,-23632(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 d00f518:	e037883a 	mov	sp,fp
 d00f51c:	df000017 	ldw	fp,0(sp)
 d00f520:	dec00104 	addi	sp,sp,4
 d00f524:	f800283a 	ret

0d00f528 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 d00f528:	defffc04 	addi	sp,sp,-16
 d00f52c:	df000315 	stw	fp,12(sp)
 d00f530:	df000304 	addi	fp,sp,12
 d00f534:	e13ffe15 	stw	r4,-8(fp)
 d00f538:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 d00f53c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 d00f540:	00000d06 	br	d00f578 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
 d00f544:	e0bfff17 	ldw	r2,-4(fp)
 d00f548:	10c00003 	ldbu	r3,0(r2)
 d00f54c:	e0bffe17 	ldw	r2,-8(fp)
 d00f550:	10c00005 	stb	r3,0(r2)
 d00f554:	e0bffe17 	ldw	r2,-8(fp)
 d00f558:	10800044 	addi	r2,r2,1
 d00f55c:	e0bffe15 	stw	r2,-8(fp)
 d00f560:	e0bfff17 	ldw	r2,-4(fp)
 d00f564:	10800044 	addi	r2,r2,1
 d00f568:	e0bfff15 	stw	r2,-4(fp)
        len++;
 d00f56c:	e0bffd03 	ldbu	r2,-12(fp)
 d00f570:	10800044 	addi	r2,r2,1
 d00f574:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 d00f578:	e0bfff17 	ldw	r2,-4(fp)
 d00f57c:	10800003 	ldbu	r2,0(r2)
 d00f580:	10803fcc 	andi	r2,r2,255
 d00f584:	1004c03a 	cmpne	r2,r2,zero
 d00f588:	103fee1e 	bne	r2,zero,d00f544 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 d00f58c:	e0bffe17 	ldw	r2,-8(fp)
 d00f590:	10000005 	stb	zero,0(r2)
    return (len);
 d00f594:	e0bffd03 	ldbu	r2,-12(fp)
}
 d00f598:	e037883a 	mov	sp,fp
 d00f59c:	df000017 	ldw	fp,0(sp)
 d00f5a0:	dec00104 	addi	sp,sp,4
 d00f5a4:	f800283a 	ret

0d00f5a8 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 d00f5a8:	defffd04 	addi	sp,sp,-12
 d00f5ac:	df000215 	stw	fp,8(sp)
 d00f5b0:	df000204 	addi	fp,sp,8
 d00f5b4:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 d00f5b8:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 d00f5bc:	00000606 	br	d00f5d8 <OS_StrLen+0x30>
        psrc++;
 d00f5c0:	e0bfff17 	ldw	r2,-4(fp)
 d00f5c4:	10800044 	addi	r2,r2,1
 d00f5c8:	e0bfff15 	stw	r2,-4(fp)
        len++;
 d00f5cc:	e0bffe03 	ldbu	r2,-8(fp)
 d00f5d0:	10800044 	addi	r2,r2,1
 d00f5d4:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 d00f5d8:	e0bfff17 	ldw	r2,-4(fp)
 d00f5dc:	10800003 	ldbu	r2,0(r2)
 d00f5e0:	10803fcc 	andi	r2,r2,255
 d00f5e4:	1004c03a 	cmpne	r2,r2,zero
 d00f5e8:	103ff51e 	bne	r2,zero,d00f5c0 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 d00f5ec:	e0bffe03 	ldbu	r2,-8(fp)
}
 d00f5f0:	e037883a 	mov	sp,fp
 d00f5f4:	df000017 	ldw	fp,0(sp)
 d00f5f8:	dec00104 	addi	sp,sp,4
 d00f5fc:	f800283a 	ret

0d00f600 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 d00f600:	defffa04 	addi	sp,sp,-24
 d00f604:	dfc00515 	stw	ra,20(sp)
 d00f608:	df000415 	stw	fp,16(sp)
 d00f60c:	df000404 	addi	fp,sp,16
 d00f610:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00f614:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f618:	0005303a 	rdctl	r2,status
 d00f61c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f620:	e0fffd17 	ldw	r3,-12(fp)
 d00f624:	00bfff84 	movi	r2,-2
 d00f628:	1884703a 	and	r2,r3,r2
 d00f62c:	1001703a 	wrctl	status,r2
  
  return context;
 d00f630:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 d00f634:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtr++;
 d00f638:	d0a8eb17 	ldw	r2,-23636(gp)
 d00f63c:	10800044 	addi	r2,r2,1
 d00f640:	d0a8eb15 	stw	r2,-23636(gp)
 d00f644:	e0bffe17 	ldw	r2,-8(fp)
 d00f648:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f64c:	e0bffc17 	ldw	r2,-16(fp)
 d00f650:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 d00f654:	d03674c0 	call	d03674c <OSTaskIdleHook>
    }
 d00f658:	003fef06 	br	d00f618 <OS_TaskIdle+0x18>

0d00f65c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 d00f65c:	defffa04 	addi	sp,sp,-24
 d00f660:	dfc00515 	stw	ra,20(sp)
 d00f664:	df000415 	stw	fp,16(sp)
 d00f668:	df000404 	addi	fp,sp,16
 d00f66c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00f670:	e03ffe15 	stw	zero,-8(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 d00f674:	00000206 	br	d00f680 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 d00f678:	01000504 	movi	r4,20
 d00f67c:	d0156dc0 	call	d0156dc <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 d00f680:	d0a8fc03 	ldbu	r2,-23568(gp)
 d00f684:	10803fcc 	andi	r2,r2,255
 d00f688:	1005003a 	cmpeq	r2,r2,zero
 d00f68c:	103ffa1e 	bne	r2,zero,d00f678 <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 d00f690:	d128f017 	ldw	r4,-23616(gp)
 d00f694:	01401904 	movi	r5,100
 d00f698:	d00c90c0 	call	d00c90c <__udivsi3>
 d00f69c:	d0a8f015 	stw	r2,-23616(gp)
    if (OSIdleCtrMax == 0L) {
 d00f6a0:	d0a8f017 	ldw	r2,-23616(gp)
 d00f6a4:	1004c03a 	cmpne	r2,r2,zero
 d00f6a8:	1000031e 	bne	r2,zero,d00f6b8 <OS_TaskStat+0x5c>
        OSCPUUsage = 0;
 d00f6ac:	d028f205 	stb	zero,-23608(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 d00f6b0:	01003fc4 	movi	r4,255
 d00f6b4:	d0152f00 	call	d0152f0 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f6b8:	0005303a 	rdctl	r2,status
 d00f6bc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f6c0:	e0fffd17 	ldw	r3,-12(fp)
 d00f6c4:	00bfff84 	movi	r2,-2
 d00f6c8:	1884703a 	and	r2,r3,r2
 d00f6cc:	1001703a 	wrctl	status,r2
  
  return context;
 d00f6d0:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 d00f6d4:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 d00f6d8:	d0a8eb17 	ldw	r2,-23636(gp)
 d00f6dc:	d0a8fd15 	stw	r2,-23564(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 d00f6e0:	d028eb15 	stw	zero,-23636(gp)
 d00f6e4:	e0bffe17 	ldw	r2,-8(fp)
 d00f6e8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f6ec:	e0bffc17 	ldw	r2,-16(fp)
 d00f6f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 d00f6f4:	d128fd17 	ldw	r4,-23564(gp)
 d00f6f8:	d168f017 	ldw	r5,-23616(gp)
 d00f6fc:	d00c90c0 	call	d00c90c <__udivsi3>
 d00f700:	1007883a 	mov	r3,r2
 d00f704:	00801904 	movi	r2,100
 d00f708:	10c5c83a 	sub	r2,r2,r3
 d00f70c:	d0a8f205 	stb	r2,-23608(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 d00f710:	d0366d00 	call	d0366d0 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 d00f714:	d00f7240 	call	d00f724 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 d00f718:	01000284 	movi	r4,10
 d00f71c:	d0156dc0 	call	d0156dc <OSTimeDly>
    }
 d00f720:	003fe506 	br	d00f6b8 <OS_TaskStat+0x5c>

0d00f724 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 d00f724:	defffa04 	addi	sp,sp,-24
 d00f728:	dfc00515 	stw	ra,20(sp)
 d00f72c:	df000415 	stw	fp,16(sp)
 d00f730:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 d00f734:	e03ffc05 	stb	zero,-16(fp)
 d00f738:	00002406 	br	d00f7cc <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 d00f73c:	e13ffc03 	ldbu	r4,-16(fp)
 d00f740:	e17ffe04 	addi	r5,fp,-8
 d00f744:	d0150f40 	call	d0150f4 <OSTaskStkChk>
 d00f748:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 d00f74c:	e0bffc43 	ldbu	r2,-15(fp)
 d00f750:	1004c03a 	cmpne	r2,r2,zero
 d00f754:	10001a1e 	bne	r2,zero,d00f7c0 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 d00f758:	e0bffc03 	ldbu	r2,-16(fp)
 d00f75c:	00c341b4 	movhi	r3,3334
 d00f760:	18c1b004 	addi	r3,r3,1728
 d00f764:	1085883a 	add	r2,r2,r2
 d00f768:	1085883a 	add	r2,r2,r2
 d00f76c:	10c5883a 	add	r2,r2,r3
 d00f770:	10800017 	ldw	r2,0(r2)
 d00f774:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 d00f778:	e0bffd17 	ldw	r2,-12(fp)
 d00f77c:	1005003a 	cmpeq	r2,r2,zero
 d00f780:	10000f1e 	bne	r2,zero,d00f7c0 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 d00f784:	e0bffd17 	ldw	r2,-12(fp)
 d00f788:	10800060 	cmpeqi	r2,r2,1
 d00f78c:	10000c1e 	bne	r2,zero,d00f7c0 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 d00f790:	e0bffd17 	ldw	r2,-12(fp)
 d00f794:	10c00217 	ldw	r3,8(r2)
 d00f798:	e0bffd17 	ldw	r2,-12(fp)
 d00f79c:	10800317 	ldw	r2,12(r2)
 d00f7a0:	1085883a 	add	r2,r2,r2
 d00f7a4:	1085883a 	add	r2,r2,r2
 d00f7a8:	1887883a 	add	r3,r3,r2
 d00f7ac:	e0bffd17 	ldw	r2,-12(fp)
 d00f7b0:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 d00f7b4:	e0ffff17 	ldw	r3,-4(fp)
 d00f7b8:	e0bffd17 	ldw	r2,-12(fp)
 d00f7bc:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 d00f7c0:	e0bffc03 	ldbu	r2,-16(fp)
 d00f7c4:	10800044 	addi	r2,r2,1
 d00f7c8:	e0bffc05 	stb	r2,-16(fp)
 d00f7cc:	e0bffc03 	ldbu	r2,-16(fp)
 d00f7d0:	10800570 	cmpltui	r2,r2,21
 d00f7d4:	103fd91e 	bne	r2,zero,d00f73c <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 d00f7d8:	e037883a 	mov	sp,fp
 d00f7dc:	dfc00117 	ldw	ra,4(sp)
 d00f7e0:	df000017 	ldw	fp,0(sp)
 d00f7e4:	dec00204 	addi	sp,sp,8
 d00f7e8:	f800283a 	ret

0d00f7ec <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 d00f7ec:	defff104 	addi	sp,sp,-60
 d00f7f0:	dfc00e15 	stw	ra,56(sp)
 d00f7f4:	df000d15 	stw	fp,52(sp)
 d00f7f8:	df000d04 	addi	fp,sp,52
 d00f7fc:	e17ffb15 	stw	r5,-20(fp)
 d00f800:	e1bffc15 	stw	r6,-16(fp)
 d00f804:	e0800417 	ldw	r2,16(fp)
 d00f808:	e13ffa05 	stb	r4,-24(fp)
 d00f80c:	e1fffd0d 	sth	r7,-12(fp)
 d00f810:	e0bffe0d 	sth	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00f814:	e03ff815 	stw	zero,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f818:	0005303a 	rdctl	r2,status
 d00f81c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f820:	e0fff717 	ldw	r3,-36(fp)
 d00f824:	00bfff84 	movi	r2,-2
 d00f828:	1884703a 	and	r2,r3,r2
 d00f82c:	1001703a 	wrctl	status,r2
  
  return context;
 d00f830:	e0bff717 	ldw	r2,-36(fp)
#endif



    OS_ENTER_CRITICAL();
 d00f834:	e0bff815 	stw	r2,-32(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 d00f838:	d0a8f117 	ldw	r2,-23612(gp)
 d00f83c:	e0bff915 	stw	r2,-28(fp)
    if (ptcb != (OS_TCB *)0) {
 d00f840:	e0bff917 	ldw	r2,-28(fp)
 d00f844:	1005003a 	cmpeq	r2,r2,zero
 d00f848:	1000941e 	bne	r2,zero,d00fa9c <OS_TCBInit+0x2b0>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 d00f84c:	e0bff917 	ldw	r2,-28(fp)
 d00f850:	10800517 	ldw	r2,20(r2)
 d00f854:	d0a8f115 	stw	r2,-23612(gp)
 d00f858:	e0bff817 	ldw	r2,-32(fp)
 d00f85c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f860:	e0bff617 	ldw	r2,-40(fp)
 d00f864:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 d00f868:	e0fff917 	ldw	r3,-28(fp)
 d00f86c:	e0bffb17 	ldw	r2,-20(fp)
 d00f870:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 d00f874:	e0fff917 	ldw	r3,-28(fp)
 d00f878:	e0bffa03 	ldbu	r2,-24(fp)
 d00f87c:	18800c85 	stb	r2,50(r3)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 d00f880:	e0bff917 	ldw	r2,-28(fp)
 d00f884:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 d00f888:	e0bff917 	ldw	r2,-28(fp)
 d00f88c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 d00f890:	e0bff917 	ldw	r2,-28(fp)
 d00f894:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 d00f898:	e0fff917 	ldw	r3,-28(fp)
 d00f89c:	e0800317 	ldw	r2,12(fp)
 d00f8a0:	18800115 	stw	r2,4(r3)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 d00f8a4:	e0fff917 	ldw	r3,-28(fp)
 d00f8a8:	e0800217 	ldw	r2,8(fp)
 d00f8ac:	18800315 	stw	r2,12(r3)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 d00f8b0:	e0fff917 	ldw	r3,-28(fp)
 d00f8b4:	e0bffc17 	ldw	r2,-16(fp)
 d00f8b8:	18800215 	stw	r2,8(r3)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 d00f8bc:	e0fff917 	ldw	r3,-28(fp)
 d00f8c0:	e0bffe0b 	ldhu	r2,-8(fp)
 d00f8c4:	1880040d 	sth	r2,16(r3)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 d00f8c8:	e0fff917 	ldw	r3,-28(fp)
 d00f8cc:	e0bffd0b 	ldhu	r2,-12(fp)
 d00f8d0:	1880048d 	sth	r2,18(r3)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 d00f8d4:	e0bff917 	ldw	r2,-28(fp)
 d00f8d8:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 d00f8dc:	e0bffa03 	ldbu	r2,-24(fp)
 d00f8e0:	1004d0fa 	srli	r2,r2,3
 d00f8e4:	1007883a 	mov	r3,r2
 d00f8e8:	e0bff917 	ldw	r2,-28(fp)
 d00f8ec:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 d00f8f0:	e0bffa03 	ldbu	r2,-24(fp)
 d00f8f4:	108001cc 	andi	r2,r2,7
 d00f8f8:	1007883a 	mov	r3,r2
 d00f8fc:	e0bff917 	ldw	r2,-28(fp)
 d00f900:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 d00f904:	e0bff917 	ldw	r2,-28(fp)
 d00f908:	10800d03 	ldbu	r2,52(r2)
 d00f90c:	10c03fcc 	andi	r3,r2,255
 d00f910:	00800044 	movi	r2,1
 d00f914:	10c4983a 	sll	r2,r2,r3
 d00f918:	1007883a 	mov	r3,r2
 d00f91c:	e0bff917 	ldw	r2,-28(fp)
 d00f920:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 d00f924:	e0bff917 	ldw	r2,-28(fp)
 d00f928:	10800cc3 	ldbu	r2,51(r2)
 d00f92c:	10c03fcc 	andi	r3,r2,255
 d00f930:	00800044 	movi	r2,1
 d00f934:	10c4983a 	sll	r2,r2,r3
 d00f938:	1007883a 	mov	r3,r2
 d00f93c:	e0bff917 	ldw	r2,-28(fp)
 d00f940:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 d00f944:	e0bff917 	ldw	r2,-28(fp)
 d00f948:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 d00f94c:	e0bff917 	ldw	r2,-28(fp)
 d00f950:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 d00f954:	e0bff917 	ldw	r2,-28(fp)
 d00f958:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 d00f95c:	e0bff917 	ldw	r2,-28(fp)
 d00f960:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 d00f964:	e0bff917 	ldw	r2,-28(fp)
 d00f968:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 d00f96c:	e0bff917 	ldw	r2,-28(fp)
 d00f970:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 d00f974:	e0bff917 	ldw	r2,-28(fp)
 d00f978:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 d00f97c:	e0bff917 	ldw	r2,-28(fp)
 d00f980:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 d00f984:	e0bff917 	ldw	r2,-28(fp)
 d00f988:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 d00f98c:	e0fff917 	ldw	r3,-28(fp)
 d00f990:	00800fc4 	movi	r2,63
 d00f994:	18801305 	stb	r2,76(r3)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 d00f998:	e0bff917 	ldw	r2,-28(fp)
 d00f99c:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 d00f9a0:	e13ff917 	ldw	r4,-28(fp)
 d00f9a4:	d0367680 	call	d036768 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 d00f9a8:	e13ff917 	ldw	r4,-28(fp)
 d00f9ac:	d0366740 	call	d036674 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f9b0:	0005303a 	rdctl	r2,status
 d00f9b4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f9b8:	e0fff517 	ldw	r3,-44(fp)
 d00f9bc:	00bfff84 	movi	r2,-2
 d00f9c0:	1884703a 	and	r2,r3,r2
 d00f9c4:	1001703a 	wrctl	status,r2
  
  return context;
 d00f9c8:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 d00f9cc:	e0bff815 	stw	r2,-32(fp)
        OSTCBPrioTbl[prio] = ptcb;
 d00f9d0:	e0bffa03 	ldbu	r2,-24(fp)
 d00f9d4:	00c341b4 	movhi	r3,3334
 d00f9d8:	18c1b004 	addi	r3,r3,1728
 d00f9dc:	1085883a 	add	r2,r2,r2
 d00f9e0:	1085883a 	add	r2,r2,r2
 d00f9e4:	10c7883a 	add	r3,r2,r3
 d00f9e8:	e0bff917 	ldw	r2,-28(fp)
 d00f9ec:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 d00f9f0:	d0e8ed17 	ldw	r3,-23628(gp)
 d00f9f4:	e0bff917 	ldw	r2,-28(fp)
 d00f9f8:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 d00f9fc:	e0bff917 	ldw	r2,-28(fp)
 d00fa00:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 d00fa04:	d0a8ed17 	ldw	r2,-23628(gp)
 d00fa08:	1005003a 	cmpeq	r2,r2,zero
 d00fa0c:	1000031e 	bne	r2,zero,d00fa1c <OS_TCBInit+0x230>
            OSTCBList->OSTCBPrev = ptcb;
 d00fa10:	d0e8ed17 	ldw	r3,-23628(gp)
 d00fa14:	e0bff917 	ldw	r2,-28(fp)
 d00fa18:	18800615 	stw	r2,24(r3)
        }
        OSTCBList               = ptcb;
 d00fa1c:	e0bff917 	ldw	r2,-28(fp)
 d00fa20:	d0a8ed15 	stw	r2,-23628(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 d00fa24:	e0bff917 	ldw	r2,-28(fp)
 d00fa28:	10c00d83 	ldbu	r3,54(r2)
 d00fa2c:	d0a8f603 	ldbu	r2,-23592(gp)
 d00fa30:	1884b03a 	or	r2,r3,r2
 d00fa34:	d0a8f605 	stb	r2,-23592(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d00fa38:	e0bff917 	ldw	r2,-28(fp)
 d00fa3c:	10800d03 	ldbu	r2,52(r2)
 d00fa40:	11003fcc 	andi	r4,r2,255
 d00fa44:	e0bff917 	ldw	r2,-28(fp)
 d00fa48:	10800d03 	ldbu	r2,52(r2)
 d00fa4c:	10c03fcc 	andi	r3,r2,255
 d00fa50:	d0a8f644 	addi	r2,gp,-23591
 d00fa54:	1885883a 	add	r2,r3,r2
 d00fa58:	10c00003 	ldbu	r3,0(r2)
 d00fa5c:	e0bff917 	ldw	r2,-28(fp)
 d00fa60:	10800d43 	ldbu	r2,53(r2)
 d00fa64:	1884b03a 	or	r2,r3,r2
 d00fa68:	1007883a 	mov	r3,r2
 d00fa6c:	d0a8f644 	addi	r2,gp,-23591
 d00fa70:	2085883a 	add	r2,r4,r2
 d00fa74:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 d00fa78:	d0a8f243 	ldbu	r2,-23607(gp)
 d00fa7c:	10800044 	addi	r2,r2,1
 d00fa80:	d0a8f245 	stb	r2,-23607(gp)
 d00fa84:	e0bff817 	ldw	r2,-32(fp)
 d00fa88:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00fa8c:	e0bff417 	ldw	r2,-48(fp)
 d00fa90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 d00fa94:	e03fff15 	stw	zero,-4(fp)
 d00fa98:	00000606 	br	d00fab4 <OS_TCBInit+0x2c8>
 d00fa9c:	e0bff817 	ldw	r2,-32(fp)
 d00faa0:	e0bff315 	stw	r2,-52(fp)
 d00faa4:	e0bff317 	ldw	r2,-52(fp)
 d00faa8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 d00faac:	00801084 	movi	r2,66
 d00fab0:	e0bfff15 	stw	r2,-4(fp)
 d00fab4:	e0bfff17 	ldw	r2,-4(fp)
}
 d00fab8:	e037883a 	mov	sp,fp
 d00fabc:	dfc00117 	ldw	ra,4(sp)
 d00fac0:	df000017 	ldw	fp,0(sp)
 d00fac4:	dec00204 	addi	sp,sp,8
 d00fac8:	f800283a 	ret

0d00facc <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 d00facc:	defffe04 	addi	sp,sp,-8
 d00fad0:	df000115 	stw	fp,4(sp)
 d00fad4:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 d00fad8:	d0a00c04 	addi	r2,gp,-32720
 d00fadc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 d00fae0:	d0a00d04 	addi	r2,gp,-32716
 d00fae4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 d00fae8:	d0a00e84 	addi	r2,gp,-32710
 d00faec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 d00faf0:	d0a00f04 	addi	r2,gp,-32708
 d00faf4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 d00faf8:	d0a00e04 	addi	r2,gp,-32712
 d00fafc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 d00fb00:	d0a00f84 	addi	r2,gp,-32706
 d00fb04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 d00fb08:	d0a01004 	addi	r2,gp,-32704
 d00fb0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 d00fb10:	d0a01084 	addi	r2,gp,-32702
 d00fb14:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 d00fb18:	d0a01104 	addi	r2,gp,-32700
 d00fb1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 d00fb20:	d0a01184 	addi	r2,gp,-32698
 d00fb24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 d00fb28:	d0a01204 	addi	r2,gp,-32696
 d00fb2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 d00fb30:	d0a01284 	addi	r2,gp,-32694
 d00fb34:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 d00fb38:	d0a01304 	addi	r2,gp,-32692
 d00fb3c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 d00fb40:	d0a01384 	addi	r2,gp,-32690
 d00fb44:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 d00fb48:	d0a01404 	addi	r2,gp,-32688
 d00fb4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 d00fb50:	d0a01484 	addi	r2,gp,-32686
 d00fb54:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 d00fb58:	d0a01504 	addi	r2,gp,-32684
 d00fb5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 d00fb60:	d0a01584 	addi	r2,gp,-32682
 d00fb64:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 d00fb68:	d0a01604 	addi	r2,gp,-32680
 d00fb6c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 d00fb70:	d0a01684 	addi	r2,gp,-32678
 d00fb74:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 d00fb78:	d0a01704 	addi	r2,gp,-32676
 d00fb7c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 d00fb80:	d0a01784 	addi	r2,gp,-32674
 d00fb84:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 d00fb88:	d0a01804 	addi	r2,gp,-32672
 d00fb8c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 d00fb90:	d0a01884 	addi	r2,gp,-32670
 d00fb94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 d00fb98:	d0a01904 	addi	r2,gp,-32668
 d00fb9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 d00fba0:	d0a01984 	addi	r2,gp,-32666
 d00fba4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 d00fba8:	d0a01a04 	addi	r2,gp,-32664
 d00fbac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 d00fbb0:	d0a01a84 	addi	r2,gp,-32662
 d00fbb4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 d00fbb8:	d0a01b04 	addi	r2,gp,-32660
 d00fbbc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 d00fbc0:	d0a01b84 	addi	r2,gp,-32658
 d00fbc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 d00fbc8:	d0a01c04 	addi	r2,gp,-32656
 d00fbcc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 d00fbd0:	d0a01c84 	addi	r2,gp,-32654
 d00fbd4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 d00fbd8:	d0a01d04 	addi	r2,gp,-32652
 d00fbdc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 d00fbe0:	d0a01d84 	addi	r2,gp,-32650
 d00fbe4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 d00fbe8:	d0a01e04 	addi	r2,gp,-32648
 d00fbec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 d00fbf0:	d0a01e84 	addi	r2,gp,-32646
 d00fbf4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 d00fbf8:	d0a01f04 	addi	r2,gp,-32644
 d00fbfc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 d00fc00:	d0a01f84 	addi	r2,gp,-32642
 d00fc04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 d00fc08:	d0a02004 	addi	r2,gp,-32640
 d00fc0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 d00fc10:	d0a02084 	addi	r2,gp,-32638
 d00fc14:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 d00fc18:	d0a02104 	addi	r2,gp,-32636
 d00fc1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 d00fc20:	d0a02184 	addi	r2,gp,-32634
 d00fc24:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 d00fc28:	d0a02204 	addi	r2,gp,-32632
 d00fc2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 d00fc30:	d0a02284 	addi	r2,gp,-32630
 d00fc34:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 d00fc38:	d0a02304 	addi	r2,gp,-32628
 d00fc3c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 d00fc40:	d0a02804 	addi	r2,gp,-32608
 d00fc44:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 d00fc48:	e037883a 	mov	sp,fp
 d00fc4c:	df000017 	ldw	fp,0(sp)
 d00fc50:	dec00104 	addi	sp,sp,4
 d00fc54:	f800283a 	ret

0d00fc58 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 d00fc58:	defff104 	addi	sp,sp,-60
 d00fc5c:	df000e15 	stw	fp,56(sp)
 d00fc60:	df000e04 	addi	fp,sp,56
 d00fc64:	e13ffa15 	stw	r4,-24(fp)
 d00fc68:	e1fffd15 	stw	r7,-12(fp)
 d00fc6c:	e17ffb0d 	sth	r5,-20(fp)
 d00fc70:	e1bffc05 	stb	r6,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d00fc74:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d00fc78:	e0bffd17 	ldw	r2,-12(fp)
 d00fc7c:	1004c03a 	cmpne	r2,r2,zero
 d00fc80:	1000021e 	bne	r2,zero,d00fc8c <OSFlagAccept+0x34>
        return ((OS_FLAGS)0);
 d00fc84:	e03fff15 	stw	zero,-4(fp)
 d00fc88:	0000bb06 	br	d00ff78 <OSFlagAccept+0x320>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 d00fc8c:	e0bffa17 	ldw	r2,-24(fp)
 d00fc90:	1004c03a 	cmpne	r2,r2,zero
 d00fc94:	1000051e 	bne	r2,zero,d00fcac <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d00fc98:	e0fffd17 	ldw	r3,-12(fp)
 d00fc9c:	00801b84 	movi	r2,110
 d00fca0:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d00fca4:	e03fff15 	stw	zero,-4(fp)
 d00fca8:	0000b306 	br	d00ff78 <OSFlagAccept+0x320>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 d00fcac:	e0bffa17 	ldw	r2,-24(fp)
 d00fcb0:	10800003 	ldbu	r2,0(r2)
 d00fcb4:	10803fcc 	andi	r2,r2,255
 d00fcb8:	10800160 	cmpeqi	r2,r2,5
 d00fcbc:	1000051e 	bne	r2,zero,d00fcd4 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d00fcc0:	e0fffd17 	ldw	r3,-12(fp)
 d00fcc4:	00800044 	movi	r2,1
 d00fcc8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d00fccc:	e03fff15 	stw	zero,-4(fp)
 d00fcd0:	0000a906 	br	d00ff78 <OSFlagAccept+0x320>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 d00fcd4:	e0fffc03 	ldbu	r3,-16(fp)
 d00fcd8:	00bfe004 	movi	r2,-128
 d00fcdc:	1884703a 	and	r2,r3,r2
 d00fce0:	e0bff945 	stb	r2,-27(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 d00fce4:	e0bff943 	ldbu	r2,-27(fp)
 d00fce8:	1005003a 	cmpeq	r2,r2,zero
 d00fcec:	1000061e 	bne	r2,zero,d00fd08 <OSFlagAccept+0xb0>
        wait_type &= ~OS_FLAG_CONSUME;
 d00fcf0:	e0bffc03 	ldbu	r2,-16(fp)
 d00fcf4:	10801fcc 	andi	r2,r2,127
 d00fcf8:	e0bffc05 	stb	r2,-16(fp)
        consume    = OS_TRUE;
 d00fcfc:	00800044 	movi	r2,1
 d00fd00:	e0bff905 	stb	r2,-28(fp)
 d00fd04:	00000106 	br	d00fd0c <OSFlagAccept+0xb4>
    } else {
        consume    = OS_FALSE;
 d00fd08:	e03ff905 	stb	zero,-28(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 d00fd0c:	e0bffd17 	ldw	r2,-12(fp)
 d00fd10:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00fd14:	0005303a 	rdctl	r2,status
 d00fd18:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00fd1c:	e0fff717 	ldw	r3,-36(fp)
 d00fd20:	00bfff84 	movi	r2,-2
 d00fd24:	1884703a 	and	r2,r3,r2
 d00fd28:	1001703a 	wrctl	status,r2
  
  return context;
 d00fd2c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 d00fd30:	e0bff815 	stw	r2,-32(fp)
    switch (wait_type) {
 d00fd34:	e0bffc03 	ldbu	r2,-16(fp)
 d00fd38:	e0bffe15 	stw	r2,-8(fp)
 d00fd3c:	e0fffe17 	ldw	r3,-8(fp)
 d00fd40:	18800060 	cmpeqi	r2,r3,1
 d00fd44:	1000651e 	bne	r2,zero,d00fedc <OSFlagAccept+0x284>
 d00fd48:	e0fffe17 	ldw	r3,-8(fp)
 d00fd4c:	18800088 	cmpgei	r2,r3,2
 d00fd50:	1000041e 	bne	r2,zero,d00fd64 <OSFlagAccept+0x10c>
 d00fd54:	e0fffe17 	ldw	r3,-8(fp)
 d00fd58:	1805003a 	cmpeq	r2,r3,zero
 d00fd5c:	1000421e 	bne	r2,zero,d00fe68 <OSFlagAccept+0x210>
 d00fd60:	00007b06 	br	d00ff50 <OSFlagAccept+0x2f8>
 d00fd64:	e0fffe17 	ldw	r3,-8(fp)
 d00fd68:	188000a0 	cmpeqi	r2,r3,2
 d00fd6c:	1000041e 	bne	r2,zero,d00fd80 <OSFlagAccept+0x128>
 d00fd70:	e0fffe17 	ldw	r3,-8(fp)
 d00fd74:	188000e0 	cmpeqi	r2,r3,3
 d00fd78:	10001e1e 	bne	r2,zero,d00fdf4 <OSFlagAccept+0x19c>
 d00fd7c:	00007406 	br	d00ff50 <OSFlagAccept+0x2f8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 d00fd80:	e0bffa17 	ldw	r2,-24(fp)
 d00fd84:	10c0020b 	ldhu	r3,8(r2)
 d00fd88:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fd8c:	1884703a 	and	r2,r3,r2
 d00fd90:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d00fd94:	e0fff98b 	ldhu	r3,-26(fp)
 d00fd98:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fd9c:	18800d1e 	bne	r3,r2,d00fdd4 <OSFlagAccept+0x17c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00fda0:	e0bff903 	ldbu	r2,-28(fp)
 d00fda4:	10800058 	cmpnei	r2,r2,1
 d00fda8:	10000d1e 	bne	r2,zero,d00fde0 <OSFlagAccept+0x188>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 d00fdac:	e0bffa17 	ldw	r2,-24(fp)
 d00fdb0:	1080020b 	ldhu	r2,8(r2)
 d00fdb4:	1007883a 	mov	r3,r2
 d00fdb8:	e0bff98b 	ldhu	r2,-26(fp)
 d00fdbc:	0084303a 	nor	r2,zero,r2
 d00fdc0:	1884703a 	and	r2,r3,r2
 d00fdc4:	1007883a 	mov	r3,r2
 d00fdc8:	e0bffa17 	ldw	r2,-24(fp)
 d00fdcc:	10c0020d 	sth	r3,8(r2)
 d00fdd0:	00000306 	br	d00fde0 <OSFlagAccept+0x188>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00fdd4:	e0fffd17 	ldw	r3,-12(fp)
 d00fdd8:	00801c04 	movi	r2,112
 d00fddc:	18800005 	stb	r2,0(r3)
 d00fde0:	e0bff817 	ldw	r2,-32(fp)
 d00fde4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00fde8:	e0bff617 	ldw	r2,-40(fp)
 d00fdec:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00fdf0:	00005f06 	br	d00ff70 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 d00fdf4:	e0bffa17 	ldw	r2,-24(fp)
 d00fdf8:	10c0020b 	ldhu	r3,8(r2)
 d00fdfc:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fe00:	1884703a 	and	r2,r3,r2
 d00fe04:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 d00fe08:	e0bff98b 	ldhu	r2,-26(fp)
 d00fe0c:	1005003a 	cmpeq	r2,r2,zero
 d00fe10:	10000d1e 	bne	r2,zero,d00fe48 <OSFlagAccept+0x1f0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00fe14:	e0bff903 	ldbu	r2,-28(fp)
 d00fe18:	10800058 	cmpnei	r2,r2,1
 d00fe1c:	10000d1e 	bne	r2,zero,d00fe54 <OSFlagAccept+0x1fc>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 d00fe20:	e0bffa17 	ldw	r2,-24(fp)
 d00fe24:	1080020b 	ldhu	r2,8(r2)
 d00fe28:	1007883a 	mov	r3,r2
 d00fe2c:	e0bff98b 	ldhu	r2,-26(fp)
 d00fe30:	0084303a 	nor	r2,zero,r2
 d00fe34:	1884703a 	and	r2,r3,r2
 d00fe38:	1007883a 	mov	r3,r2
 d00fe3c:	e0bffa17 	ldw	r2,-24(fp)
 d00fe40:	10c0020d 	sth	r3,8(r2)
 d00fe44:	00000306 	br	d00fe54 <OSFlagAccept+0x1fc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00fe48:	e0fffd17 	ldw	r3,-12(fp)
 d00fe4c:	00801c04 	movi	r2,112
 d00fe50:	18800005 	stb	r2,0(r3)
 d00fe54:	e0bff817 	ldw	r2,-32(fp)
 d00fe58:	e0bff515 	stw	r2,-44(fp)
 d00fe5c:	e0bff517 	ldw	r2,-44(fp)
 d00fe60:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00fe64:	00004206 	br	d00ff70 <OSFlagAccept+0x318>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 d00fe68:	e0bffa17 	ldw	r2,-24(fp)
 d00fe6c:	1080020b 	ldhu	r2,8(r2)
 d00fe70:	0084303a 	nor	r2,zero,r2
 d00fe74:	1007883a 	mov	r3,r2
 d00fe78:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fe7c:	1884703a 	and	r2,r3,r2
 d00fe80:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d00fe84:	e0fff98b 	ldhu	r3,-26(fp)
 d00fe88:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fe8c:	18800b1e 	bne	r3,r2,d00febc <OSFlagAccept+0x264>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00fe90:	e0bff903 	ldbu	r2,-28(fp)
 d00fe94:	10800058 	cmpnei	r2,r2,1
 d00fe98:	10000b1e 	bne	r2,zero,d00fec8 <OSFlagAccept+0x270>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 d00fe9c:	e0bffa17 	ldw	r2,-24(fp)
 d00fea0:	10c0020b 	ldhu	r3,8(r2)
 d00fea4:	e0bff98b 	ldhu	r2,-26(fp)
 d00fea8:	1884b03a 	or	r2,r3,r2
 d00feac:	1007883a 	mov	r3,r2
 d00feb0:	e0bffa17 	ldw	r2,-24(fp)
 d00feb4:	10c0020d 	sth	r3,8(r2)
 d00feb8:	00000306 	br	d00fec8 <OSFlagAccept+0x270>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00febc:	e0fffd17 	ldw	r3,-12(fp)
 d00fec0:	00801c04 	movi	r2,112
 d00fec4:	18800005 	stb	r2,0(r3)
 d00fec8:	e0bff817 	ldw	r2,-32(fp)
 d00fecc:	e0bff415 	stw	r2,-48(fp)
 d00fed0:	e0bff417 	ldw	r2,-48(fp)
 d00fed4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00fed8:	00002506 	br	d00ff70 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 d00fedc:	e0bffa17 	ldw	r2,-24(fp)
 d00fee0:	1080020b 	ldhu	r2,8(r2)
 d00fee4:	0084303a 	nor	r2,zero,r2
 d00fee8:	1007883a 	mov	r3,r2
 d00feec:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fef0:	1884703a 	and	r2,r3,r2
 d00fef4:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 d00fef8:	e0bff98b 	ldhu	r2,-26(fp)
 d00fefc:	1005003a 	cmpeq	r2,r2,zero
 d00ff00:	10000b1e 	bne	r2,zero,d00ff30 <OSFlagAccept+0x2d8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00ff04:	e0bff903 	ldbu	r2,-28(fp)
 d00ff08:	10800058 	cmpnei	r2,r2,1
 d00ff0c:	10000b1e 	bne	r2,zero,d00ff3c <OSFlagAccept+0x2e4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 d00ff10:	e0bffa17 	ldw	r2,-24(fp)
 d00ff14:	10c0020b 	ldhu	r3,8(r2)
 d00ff18:	e0bff98b 	ldhu	r2,-26(fp)
 d00ff1c:	1884b03a 	or	r2,r3,r2
 d00ff20:	1007883a 	mov	r3,r2
 d00ff24:	e0bffa17 	ldw	r2,-24(fp)
 d00ff28:	10c0020d 	sth	r3,8(r2)
 d00ff2c:	00000306 	br	d00ff3c <OSFlagAccept+0x2e4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00ff30:	e0fffd17 	ldw	r3,-12(fp)
 d00ff34:	00801c04 	movi	r2,112
 d00ff38:	18800005 	stb	r2,0(r3)
 d00ff3c:	e0bff817 	ldw	r2,-32(fp)
 d00ff40:	e0bff315 	stw	r2,-52(fp)
 d00ff44:	e0bff317 	ldw	r2,-52(fp)
 d00ff48:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00ff4c:	00000806 	br	d00ff70 <OSFlagAccept+0x318>
 d00ff50:	e0bff817 	ldw	r2,-32(fp)
 d00ff54:	e0bff215 	stw	r2,-56(fp)
 d00ff58:	e0bff217 	ldw	r2,-56(fp)
 d00ff5c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 d00ff60:	e03ff98d 	sth	zero,-26(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 d00ff64:	e0fffd17 	ldw	r3,-12(fp)
 d00ff68:	00801bc4 	movi	r2,111
 d00ff6c:	18800005 	stb	r2,0(r3)
             break;
    }
    return (flags_rdy);
 d00ff70:	e0bff98b 	ldhu	r2,-26(fp)
 d00ff74:	e0bfff15 	stw	r2,-4(fp)
 d00ff78:	e0bfff17 	ldw	r2,-4(fp)
}
 d00ff7c:	e037883a 	mov	sp,fp
 d00ff80:	df000017 	ldw	fp,0(sp)
 d00ff84:	dec00104 	addi	sp,sp,4
 d00ff88:	f800283a 	ret

0d00ff8c <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 d00ff8c:	defff704 	addi	sp,sp,-36
 d00ff90:	df000815 	stw	fp,32(sp)
 d00ff94:	df000804 	addi	fp,sp,32
 d00ff98:	e17ffe15 	stw	r5,-8(fp)
 d00ff9c:	e13ffd0d 	sth	r4,-12(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 d00ffa0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 d00ffa4:	e0bffe17 	ldw	r2,-8(fp)
 d00ffa8:	1004c03a 	cmpne	r2,r2,zero
 d00ffac:	1000021e 	bne	r2,zero,d00ffb8 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 d00ffb0:	e03fff15 	stw	zero,-4(fp)
 d00ffb4:	00003f06 	br	d0100b4 <OSFlagCreate+0x128>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 d00ffb8:	00834174 	movhi	r2,3333
 d00ffbc:	109b1704 	addi	r2,r2,27740
 d00ffc0:	10800003 	ldbu	r2,0(r2)
 d00ffc4:	10803fcc 	andi	r2,r2,255
 d00ffc8:	1005003a 	cmpeq	r2,r2,zero
 d00ffcc:	1000051e 	bne	r2,zero,d00ffe4 <OSFlagCreate+0x58>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 d00ffd0:	e0fffe17 	ldw	r3,-8(fp)
 d00ffd4:	00800404 	movi	r2,16
 d00ffd8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAG_GRP *)0);
 d00ffdc:	e03fff15 	stw	zero,-4(fp)
 d00ffe0:	00003406 	br	d0100b4 <OSFlagCreate+0x128>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00ffe4:	0005303a 	rdctl	r2,status
 d00ffe8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00ffec:	e0fffa17 	ldw	r3,-24(fp)
 d00fff0:	00bfff84 	movi	r2,-2
 d00fff4:	1884703a 	and	r2,r3,r2
 d00fff8:	1001703a 	wrctl	status,r2
  
  return context;
 d00fffc:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d010000:	e0bffb15 	stw	r2,-20(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 d010004:	00834174 	movhi	r2,3333
 d010008:	109b1a04 	addi	r2,r2,27752
 d01000c:	10800017 	ldw	r2,0(r2)
 d010010:	e0bffc15 	stw	r2,-16(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 d010014:	e0bffc17 	ldw	r2,-16(fp)
 d010018:	1005003a 	cmpeq	r2,r2,zero
 d01001c:	10001c1e 	bne	r2,zero,d010090 <OSFlagCreate+0x104>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 d010020:	00834174 	movhi	r2,3333
 d010024:	109b1a04 	addi	r2,r2,27752
 d010028:	10800017 	ldw	r2,0(r2)
 d01002c:	10800117 	ldw	r2,4(r2)
 d010030:	1007883a 	mov	r3,r2
 d010034:	00834174 	movhi	r2,3333
 d010038:	109b1a04 	addi	r2,r2,27752
 d01003c:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 d010040:	e0fffc17 	ldw	r3,-16(fp)
 d010044:	00800144 	movi	r2,5
 d010048:	18800005 	stb	r2,0(r3)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 d01004c:	e0fffc17 	ldw	r3,-16(fp)
 d010050:	e0bffd0b 	ldhu	r2,-12(fp)
 d010054:	1880020d 	sth	r2,8(r3)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 d010058:	e0bffc17 	ldw	r2,-16(fp)
 d01005c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 d010060:	e0fffc17 	ldw	r3,-16(fp)
 d010064:	00800fc4 	movi	r2,63
 d010068:	18800285 	stb	r2,10(r3)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 d01006c:	e0bffc17 	ldw	r2,-16(fp)
 d010070:	100002c5 	stb	zero,11(r2)
 d010074:	e0bffb17 	ldw	r2,-20(fp)
 d010078:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01007c:	e0bff917 	ldw	r2,-28(fp)
 d010080:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 d010084:	e0bffe17 	ldw	r2,-8(fp)
 d010088:	10000005 	stb	zero,0(r2)
 d01008c:	00000706 	br	d0100ac <OSFlagCreate+0x120>
 d010090:	e0bffb17 	ldw	r2,-20(fp)
 d010094:	e0bff815 	stw	r2,-32(fp)
 d010098:	e0bff817 	ldw	r2,-32(fp)
 d01009c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 d0100a0:	e0fffe17 	ldw	r3,-8(fp)
 d0100a4:	00801c84 	movi	r2,114
 d0100a8:	18800005 	stb	r2,0(r3)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 d0100ac:	e0bffc17 	ldw	r2,-16(fp)
 d0100b0:	e0bfff15 	stw	r2,-4(fp)
 d0100b4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0100b8:	e037883a 	mov	sp,fp
 d0100bc:	df000017 	ldw	fp,0(sp)
 d0100c0:	dec00104 	addi	sp,sp,4
 d0100c4:	f800283a 	ret

0d0100c8 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 d0100c8:	defff004 	addi	sp,sp,-64
 d0100cc:	dfc00f15 	stw	ra,60(sp)
 d0100d0:	df000e15 	stw	fp,56(sp)
 d0100d4:	df000e04 	addi	fp,sp,56
 d0100d8:	e13ffb15 	stw	r4,-20(fp)
 d0100dc:	e1bffd15 	stw	r6,-12(fp)
 d0100e0:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d0100e4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d0100e8:	e0bffd17 	ldw	r2,-12(fp)
 d0100ec:	1004c03a 	cmpne	r2,r2,zero
 d0100f0:	1000031e 	bne	r2,zero,d010100 <OSFlagDel+0x38>
        return (pgrp);
 d0100f4:	e0bffb17 	ldw	r2,-20(fp)
 d0100f8:	e0bfff15 	stw	r2,-4(fp)
 d0100fc:	00009606 	br	d010358 <OSFlagDel+0x290>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 d010100:	e0bffb17 	ldw	r2,-20(fp)
 d010104:	1004c03a 	cmpne	r2,r2,zero
 d010108:	1000061e 	bne	r2,zero,d010124 <OSFlagDel+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d01010c:	e0fffd17 	ldw	r3,-12(fp)
 d010110:	00801b84 	movi	r2,110
 d010114:	18800005 	stb	r2,0(r3)
        return (pgrp);
 d010118:	e0fffb17 	ldw	r3,-20(fp)
 d01011c:	e0ffff15 	stw	r3,-4(fp)
 d010120:	00008d06 	br	d010358 <OSFlagDel+0x290>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d010124:	00834174 	movhi	r2,3333
 d010128:	109b1704 	addi	r2,r2,27740
 d01012c:	10800003 	ldbu	r2,0(r2)
 d010130:	10803fcc 	andi	r2,r2,255
 d010134:	1005003a 	cmpeq	r2,r2,zero
 d010138:	1000061e 	bne	r2,zero,d010154 <OSFlagDel+0x8c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 d01013c:	e0fffd17 	ldw	r3,-12(fp)
 d010140:	008003c4 	movi	r2,15
 d010144:	18800005 	stb	r2,0(r3)
        return (pgrp);
 d010148:	e0bffb17 	ldw	r2,-20(fp)
 d01014c:	e0bfff15 	stw	r2,-4(fp)
 d010150:	00008106 	br	d010358 <OSFlagDel+0x290>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 d010154:	e0bffb17 	ldw	r2,-20(fp)
 d010158:	10800003 	ldbu	r2,0(r2)
 d01015c:	10803fcc 	andi	r2,r2,255
 d010160:	10800160 	cmpeqi	r2,r2,5
 d010164:	1000061e 	bne	r2,zero,d010180 <OSFlagDel+0xb8>
        *perr = OS_ERR_EVENT_TYPE;
 d010168:	e0fffd17 	ldw	r3,-12(fp)
 d01016c:	00800044 	movi	r2,1
 d010170:	18800005 	stb	r2,0(r3)
        return (pgrp);
 d010174:	e0fffb17 	ldw	r3,-20(fp)
 d010178:	e0ffff15 	stw	r3,-4(fp)
 d01017c:	00007606 	br	d010358 <OSFlagDel+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010180:	0005303a 	rdctl	r2,status
 d010184:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010188:	e0fff617 	ldw	r3,-40(fp)
 d01018c:	00bfff84 	movi	r2,-2
 d010190:	1884703a 	and	r2,r3,r2
 d010194:	1001703a 	wrctl	status,r2
  
  return context;
 d010198:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 d01019c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 d0101a0:	e0bffb17 	ldw	r2,-20(fp)
 d0101a4:	10800117 	ldw	r2,4(r2)
 d0101a8:	1005003a 	cmpeq	r2,r2,zero
 d0101ac:	1000031e 	bne	r2,zero,d0101bc <OSFlagDel+0xf4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 d0101b0:	00800044 	movi	r2,1
 d0101b4:	e0bffa05 	stb	r2,-24(fp)
 d0101b8:	00000106 	br	d0101c0 <OSFlagDel+0xf8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 d0101bc:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 d0101c0:	e0bffc03 	ldbu	r2,-16(fp)
 d0101c4:	e0bffe15 	stw	r2,-8(fp)
 d0101c8:	e0fffe17 	ldw	r3,-8(fp)
 d0101cc:	1805003a 	cmpeq	r2,r3,zero
 d0101d0:	1000041e 	bne	r2,zero,d0101e4 <OSFlagDel+0x11c>
 d0101d4:	e0fffe17 	ldw	r3,-8(fp)
 d0101d8:	18800060 	cmpeqi	r2,r3,1
 d0101dc:	1000281e 	bne	r2,zero,d010280 <OSFlagDel+0x1b8>
 d0101e0:	00005206 	br	d01032c <OSFlagDel+0x264>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 d0101e4:	e0bffa03 	ldbu	r2,-24(fp)
 d0101e8:	1004c03a 	cmpne	r2,r2,zero
 d0101ec:	10001a1e 	bne	r2,zero,d010258 <OSFlagDel+0x190>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 d0101f0:	e0fffb17 	ldw	r3,-20(fp)
 d0101f4:	00800fc4 	movi	r2,63
 d0101f8:	18800285 	stb	r2,10(r3)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 d0101fc:	e0bffb17 	ldw	r2,-20(fp)
 d010200:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d010204:	e0bffb17 	ldw	r2,-20(fp)
 d010208:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 d01020c:	00834174 	movhi	r2,3333
 d010210:	109b1a04 	addi	r2,r2,27752
 d010214:	10c00017 	ldw	r3,0(r2)
 d010218:	e0bffb17 	ldw	r2,-20(fp)
 d01021c:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 d010220:	e0bffb17 	ldw	r2,-20(fp)
 d010224:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 d010228:	00c34174 	movhi	r3,3333
 d01022c:	18db1a04 	addi	r3,r3,27752
 d010230:	e0bffb17 	ldw	r2,-20(fp)
 d010234:	18800015 	stw	r2,0(r3)
 d010238:	e0bff717 	ldw	r2,-36(fp)
 d01023c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010240:	e0bff517 	ldw	r2,-44(fp)
 d010244:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 d010248:	e0bffd17 	ldw	r2,-12(fp)
 d01024c:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 d010250:	e03ff815 	stw	zero,-32(fp)
 d010254:	00003e06 	br	d010350 <OSFlagDel+0x288>
 d010258:	e0bff717 	ldw	r2,-36(fp)
 d01025c:	e0bff415 	stw	r2,-48(fp)
 d010260:	e0bff417 	ldw	r2,-48(fp)
 d010264:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 d010268:	e0fffd17 	ldw	r3,-12(fp)
 d01026c:	00801244 	movi	r2,73
 d010270:	18800005 	stb	r2,0(r3)
                 pgrp_return          = pgrp;
 d010274:	e0bffb17 	ldw	r2,-20(fp)
 d010278:	e0bff815 	stw	r2,-32(fp)
             }
             break;
 d01027c:	00003406 	br	d010350 <OSFlagDel+0x288>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 d010280:	e0bffb17 	ldw	r2,-20(fp)
 d010284:	10800117 	ldw	r2,4(r2)
 d010288:	e0bff915 	stw	r2,-28(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 d01028c:	00000606 	br	d0102a8 <OSFlagDel+0x1e0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 d010290:	e13ff917 	ldw	r4,-28(fp)
 d010294:	000b883a 	mov	r5,zero
 d010298:	d0113d80 	call	d0113d8 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 d01029c:	e0bff917 	ldw	r2,-28(fp)
 d0102a0:	10800017 	ldw	r2,0(r2)
 d0102a4:	e0bff915 	stw	r2,-28(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 d0102a8:	e0bff917 	ldw	r2,-28(fp)
 d0102ac:	1004c03a 	cmpne	r2,r2,zero
 d0102b0:	103ff71e 	bne	r2,zero,d010290 <OSFlagDel+0x1c8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 d0102b4:	e0fffb17 	ldw	r3,-20(fp)
 d0102b8:	00800fc4 	movi	r2,63
 d0102bc:	18800285 	stb	r2,10(r3)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 d0102c0:	e0bffb17 	ldw	r2,-20(fp)
 d0102c4:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d0102c8:	e0bffb17 	ldw	r2,-20(fp)
 d0102cc:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 d0102d0:	00834174 	movhi	r2,3333
 d0102d4:	109b1a04 	addi	r2,r2,27752
 d0102d8:	10c00017 	ldw	r3,0(r2)
 d0102dc:	e0bffb17 	ldw	r2,-20(fp)
 d0102e0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 d0102e4:	e0bffb17 	ldw	r2,-20(fp)
 d0102e8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 d0102ec:	00c34174 	movhi	r3,3333
 d0102f0:	18db1a04 	addi	r3,r3,27752
 d0102f4:	e0bffb17 	ldw	r2,-20(fp)
 d0102f8:	18800015 	stw	r2,0(r3)
 d0102fc:	e0bff717 	ldw	r2,-36(fp)
 d010300:	e0bff315 	stw	r2,-52(fp)
 d010304:	e0bff317 	ldw	r2,-52(fp)
 d010308:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 d01030c:	e0bffa03 	ldbu	r2,-24(fp)
 d010310:	10800058 	cmpnei	r2,r2,1
 d010314:	1000011e 	bne	r2,zero,d01031c <OSFlagDel+0x254>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 d010318:	d00f3e40 	call	d00f3e4 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 d01031c:	e0bffd17 	ldw	r2,-12(fp)
 d010320:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 d010324:	e03ff815 	stw	zero,-32(fp)
             break;
 d010328:	00000906 	br	d010350 <OSFlagDel+0x288>
 d01032c:	e0bff717 	ldw	r2,-36(fp)
 d010330:	e0bff215 	stw	r2,-56(fp)
 d010334:	e0bff217 	ldw	r2,-56(fp)
 d010338:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 d01033c:	e0fffd17 	ldw	r3,-12(fp)
 d010340:	008001c4 	movi	r2,7
 d010344:	18800005 	stb	r2,0(r3)
             pgrp_return          = pgrp;
 d010348:	e0bffb17 	ldw	r2,-20(fp)
 d01034c:	e0bff815 	stw	r2,-32(fp)
             break;
    }
    return (pgrp_return);
 d010350:	e0bff817 	ldw	r2,-32(fp)
 d010354:	e0bfff15 	stw	r2,-4(fp)
 d010358:	e0bfff17 	ldw	r2,-4(fp)
}
 d01035c:	e037883a 	mov	sp,fp
 d010360:	dfc00117 	ldw	ra,4(sp)
 d010364:	df000017 	ldw	fp,0(sp)
 d010368:	dec00204 	addi	sp,sp,8
 d01036c:	f800283a 	ret

0d010370 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 d010370:	defff504 	addi	sp,sp,-44
 d010374:	dfc00a15 	stw	ra,40(sp)
 d010378:	df000915 	stw	fp,36(sp)
 d01037c:	df000904 	addi	fp,sp,36
 d010380:	e13ffc15 	stw	r4,-16(fp)
 d010384:	e17ffd15 	stw	r5,-12(fp)
 d010388:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d01038c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d010390:	e0bffe17 	ldw	r2,-8(fp)
 d010394:	1004c03a 	cmpne	r2,r2,zero
 d010398:	1000021e 	bne	r2,zero,d0103a4 <OSFlagNameGet+0x34>
        return (0);
 d01039c:	e03fff15 	stw	zero,-4(fp)
 d0103a0:	00003e06 	br	d01049c <OSFlagNameGet+0x12c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 d0103a4:	e0bffc17 	ldw	r2,-16(fp)
 d0103a8:	1004c03a 	cmpne	r2,r2,zero
 d0103ac:	1000051e 	bne	r2,zero,d0103c4 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d0103b0:	e0fffe17 	ldw	r3,-8(fp)
 d0103b4:	00801b84 	movi	r2,110
 d0103b8:	18800005 	stb	r2,0(r3)
        return (0);
 d0103bc:	e03fff15 	stw	zero,-4(fp)
 d0103c0:	00003606 	br	d01049c <OSFlagNameGet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d0103c4:	e0bffd17 	ldw	r2,-12(fp)
 d0103c8:	1004c03a 	cmpne	r2,r2,zero
 d0103cc:	1000051e 	bne	r2,zero,d0103e4 <OSFlagNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 d0103d0:	e0fffe17 	ldw	r3,-8(fp)
 d0103d4:	00800304 	movi	r2,12
 d0103d8:	18800005 	stb	r2,0(r3)
        return (0);
 d0103dc:	e03fff15 	stw	zero,-4(fp)
 d0103e0:	00002e06 	br	d01049c <OSFlagNameGet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d0103e4:	00834174 	movhi	r2,3333
 d0103e8:	109b1704 	addi	r2,r2,27740
 d0103ec:	10800003 	ldbu	r2,0(r2)
 d0103f0:	10803fcc 	andi	r2,r2,255
 d0103f4:	1005003a 	cmpeq	r2,r2,zero
 d0103f8:	1000051e 	bne	r2,zero,d010410 <OSFlagNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 d0103fc:	e0fffe17 	ldw	r3,-8(fp)
 d010400:	00800444 	movi	r2,17
 d010404:	18800005 	stb	r2,0(r3)
        return (0);
 d010408:	e03fff15 	stw	zero,-4(fp)
 d01040c:	00002306 	br	d01049c <OSFlagNameGet+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010410:	0005303a 	rdctl	r2,status
 d010414:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010418:	e0fff917 	ldw	r3,-28(fp)
 d01041c:	00bfff84 	movi	r2,-2
 d010420:	1884703a 	and	r2,r3,r2
 d010424:	1001703a 	wrctl	status,r2
  
  return context;
 d010428:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d01042c:	e0bffa15 	stw	r2,-24(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 d010430:	e0bffc17 	ldw	r2,-16(fp)
 d010434:	10800003 	ldbu	r2,0(r2)
 d010438:	10803fcc 	andi	r2,r2,255
 d01043c:	10800160 	cmpeqi	r2,r2,5
 d010440:	1000091e 	bne	r2,zero,d010468 <OSFlagNameGet+0xf8>
 d010444:	e0bffa17 	ldw	r2,-24(fp)
 d010448:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01044c:	e0bff817 	ldw	r2,-32(fp)
 d010450:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 d010454:	e0fffe17 	ldw	r3,-8(fp)
 d010458:	00800044 	movi	r2,1
 d01045c:	18800005 	stb	r2,0(r3)
        return (0);
 d010460:	e03fff15 	stw	zero,-4(fp)
 d010464:	00000d06 	br	d01049c <OSFlagNameGet+0x12c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 d010468:	e0bffc17 	ldw	r2,-16(fp)
 d01046c:	11400284 	addi	r5,r2,10
 d010470:	e13ffd17 	ldw	r4,-12(fp)
 d010474:	d00f5280 	call	d00f528 <OS_StrCopy>
 d010478:	e0bffb05 	stb	r2,-20(fp)
 d01047c:	e0bffa17 	ldw	r2,-24(fp)
 d010480:	e0bff715 	stw	r2,-36(fp)
 d010484:	e0bff717 	ldw	r2,-36(fp)
 d010488:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d01048c:	e0bffe17 	ldw	r2,-8(fp)
 d010490:	10000005 	stb	zero,0(r2)
    return (len);
 d010494:	e0bffb03 	ldbu	r2,-20(fp)
 d010498:	e0bfff15 	stw	r2,-4(fp)
 d01049c:	e0bfff17 	ldw	r2,-4(fp)
}
 d0104a0:	e037883a 	mov	sp,fp
 d0104a4:	dfc00117 	ldw	ra,4(sp)
 d0104a8:	df000017 	ldw	fp,0(sp)
 d0104ac:	dec00204 	addi	sp,sp,8
 d0104b0:	f800283a 	ret

0d0104b4 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 d0104b4:	defff504 	addi	sp,sp,-44
 d0104b8:	dfc00a15 	stw	ra,40(sp)
 d0104bc:	df000915 	stw	fp,36(sp)
 d0104c0:	df000904 	addi	fp,sp,36
 d0104c4:	e13ffd15 	stw	r4,-12(fp)
 d0104c8:	e17ffe15 	stw	r5,-8(fp)
 d0104cc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0104d0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0104d4:	e0bfff17 	ldw	r2,-4(fp)
 d0104d8:	1005003a 	cmpeq	r2,r2,zero
 d0104dc:	1000451e 	bne	r2,zero,d0105f4 <OSFlagNameSet+0x140>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 d0104e0:	e0bffd17 	ldw	r2,-12(fp)
 d0104e4:	1004c03a 	cmpne	r2,r2,zero
 d0104e8:	1000041e 	bne	r2,zero,d0104fc <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d0104ec:	e0ffff17 	ldw	r3,-4(fp)
 d0104f0:	00801b84 	movi	r2,110
 d0104f4:	18800005 	stb	r2,0(r3)
        return;
 d0104f8:	00003e06 	br	d0105f4 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d0104fc:	e0bffe17 	ldw	r2,-8(fp)
 d010500:	1004c03a 	cmpne	r2,r2,zero
 d010504:	1000041e 	bne	r2,zero,d010518 <OSFlagNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 d010508:	e0ffff17 	ldw	r3,-4(fp)
 d01050c:	00800304 	movi	r2,12
 d010510:	18800005 	stb	r2,0(r3)
        return;
 d010514:	00003706 	br	d0105f4 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d010518:	00834174 	movhi	r2,3333
 d01051c:	109b1704 	addi	r2,r2,27740
 d010520:	10800003 	ldbu	r2,0(r2)
 d010524:	10803fcc 	andi	r2,r2,255
 d010528:	1005003a 	cmpeq	r2,r2,zero
 d01052c:	1000041e 	bne	r2,zero,d010540 <OSFlagNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 d010530:	e0ffff17 	ldw	r3,-4(fp)
 d010534:	00800484 	movi	r2,18
 d010538:	18800005 	stb	r2,0(r3)
        return;
 d01053c:	00002d06 	br	d0105f4 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010540:	0005303a 	rdctl	r2,status
 d010544:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010548:	e0fffa17 	ldw	r3,-24(fp)
 d01054c:	00bfff84 	movi	r2,-2
 d010550:	1884703a 	and	r2,r3,r2
 d010554:	1001703a 	wrctl	status,r2
  
  return context;
 d010558:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d01055c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 d010560:	e0bffd17 	ldw	r2,-12(fp)
 d010564:	10800003 	ldbu	r2,0(r2)
 d010568:	10803fcc 	andi	r2,r2,255
 d01056c:	10800160 	cmpeqi	r2,r2,5
 d010570:	1000081e 	bne	r2,zero,d010594 <OSFlagNameSet+0xe0>
 d010574:	e0bffb17 	ldw	r2,-20(fp)
 d010578:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01057c:	e0bff917 	ldw	r2,-28(fp)
 d010580:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 d010584:	e0ffff17 	ldw	r3,-4(fp)
 d010588:	00800044 	movi	r2,1
 d01058c:	18800005 	stb	r2,0(r3)
        return;
 d010590:	00001806 	br	d0105f4 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 d010594:	e13ffe17 	ldw	r4,-8(fp)
 d010598:	d00f5a80 	call	d00f5a8 <OS_StrLen>
 d01059c:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 d0105a0:	e0bffc03 	ldbu	r2,-16(fp)
 d0105a4:	10800830 	cmpltui	r2,r2,32
 d0105a8:	1000081e 	bne	r2,zero,d0105cc <OSFlagNameSet+0x118>
 d0105ac:	e0bffb17 	ldw	r2,-20(fp)
 d0105b0:	e0bff815 	stw	r2,-32(fp)
 d0105b4:	e0bff817 	ldw	r2,-32(fp)
 d0105b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 d0105bc:	e0ffff17 	ldw	r3,-4(fp)
 d0105c0:	00801cc4 	movi	r2,115
 d0105c4:	18800005 	stb	r2,0(r3)
        return;
 d0105c8:	00000a06 	br	d0105f4 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 d0105cc:	e0bffd17 	ldw	r2,-12(fp)
 d0105d0:	11000284 	addi	r4,r2,10
 d0105d4:	e17ffe17 	ldw	r5,-8(fp)
 d0105d8:	d00f5280 	call	d00f528 <OS_StrCopy>
 d0105dc:	e0bffb17 	ldw	r2,-20(fp)
 d0105e0:	e0bff715 	stw	r2,-36(fp)
 d0105e4:	e0bff717 	ldw	r2,-36(fp)
 d0105e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d0105ec:	e0bfff17 	ldw	r2,-4(fp)
 d0105f0:	10000005 	stb	zero,0(r2)
    return;
}
 d0105f4:	e037883a 	mov	sp,fp
 d0105f8:	dfc00117 	ldw	ra,4(sp)
 d0105fc:	df000017 	ldw	fp,0(sp)
 d010600:	dec00204 	addi	sp,sp,8
 d010604:	f800283a 	ret

0d010608 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 d010608:	deffe004 	addi	sp,sp,-128
 d01060c:	dfc01f15 	stw	ra,124(sp)
 d010610:	df001e15 	stw	fp,120(sp)
 d010614:	df001e04 	addi	fp,sp,120
 d010618:	e13ff915 	stw	r4,-28(fp)
 d01061c:	e17ffa0d 	sth	r5,-24(fp)
 d010620:	e1bffb05 	stb	r6,-20(fp)
 d010624:	e1fffc0d 	sth	r7,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d010628:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d01062c:	e0800217 	ldw	r2,8(fp)
 d010630:	1004c03a 	cmpne	r2,r2,zero
 d010634:	1000021e 	bne	r2,zero,d010640 <OSFlagPend+0x38>
        return ((OS_FLAGS)0);
 d010638:	e03fff15 	stw	zero,-4(fp)
 d01063c:	00017d06 	br	d010c34 <OSFlagPend+0x62c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 d010640:	e0bff917 	ldw	r2,-28(fp)
 d010644:	1004c03a 	cmpne	r2,r2,zero
 d010648:	1000051e 	bne	r2,zero,d010660 <OSFlagPend+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d01064c:	e0c00217 	ldw	r3,8(fp)
 d010650:	00801b84 	movi	r2,110
 d010654:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010658:	e03fff15 	stw	zero,-4(fp)
 d01065c:	00017506 	br	d010c34 <OSFlagPend+0x62c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d010660:	00834174 	movhi	r2,3333
 d010664:	109b1704 	addi	r2,r2,27740
 d010668:	10800003 	ldbu	r2,0(r2)
 d01066c:	10803fcc 	andi	r2,r2,255
 d010670:	1005003a 	cmpeq	r2,r2,zero
 d010674:	1000051e 	bne	r2,zero,d01068c <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 d010678:	e0c00217 	ldw	r3,8(fp)
 d01067c:	00800084 	movi	r2,2
 d010680:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010684:	e03fff15 	stw	zero,-4(fp)
 d010688:	00016a06 	br	d010c34 <OSFlagPend+0x62c>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 d01068c:	00834174 	movhi	r2,3333
 d010690:	109b0904 	addi	r2,r2,27684
 d010694:	10800003 	ldbu	r2,0(r2)
 d010698:	10803fcc 	andi	r2,r2,255
 d01069c:	1005003a 	cmpeq	r2,r2,zero
 d0106a0:	1000051e 	bne	r2,zero,d0106b8 <OSFlagPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 d0106a4:	e0c00217 	ldw	r3,8(fp)
 d0106a8:	00800344 	movi	r2,13
 d0106ac:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d0106b0:	e03fff15 	stw	zero,-4(fp)
 d0106b4:	00015f06 	br	d010c34 <OSFlagPend+0x62c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 d0106b8:	e0bff917 	ldw	r2,-28(fp)
 d0106bc:	10800003 	ldbu	r2,0(r2)
 d0106c0:	10803fcc 	andi	r2,r2,255
 d0106c4:	10800160 	cmpeqi	r2,r2,5
 d0106c8:	1000051e 	bne	r2,zero,d0106e0 <OSFlagPend+0xd8>
        *perr = OS_ERR_EVENT_TYPE;
 d0106cc:	e0c00217 	ldw	r3,8(fp)
 d0106d0:	00800044 	movi	r2,1
 d0106d4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d0106d8:	e03fff15 	stw	zero,-4(fp)
 d0106dc:	00015506 	br	d010c34 <OSFlagPend+0x62c>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 d0106e0:	e0fffb03 	ldbu	r3,-20(fp)
 d0106e4:	00bfe004 	movi	r2,-128
 d0106e8:	1884703a 	and	r2,r3,r2
 d0106ec:	e0bff285 	stb	r2,-54(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 d0106f0:	e0bff283 	ldbu	r2,-54(fp)
 d0106f4:	1005003a 	cmpeq	r2,r2,zero
 d0106f8:	1000071e 	bne	r2,zero,d010718 <OSFlagPend+0x110>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 d0106fc:	00c01fc4 	movi	r3,127
 d010700:	e0bffb03 	ldbu	r2,-20(fp)
 d010704:	10c4703a 	and	r2,r2,r3
 d010708:	e0bffb05 	stb	r2,-20(fp)
        consume    = OS_TRUE;
 d01070c:	00800044 	movi	r2,1
 d010710:	e0bff205 	stb	r2,-56(fp)
 d010714:	00000106 	br	d01071c <OSFlagPend+0x114>
    } else {
        consume    = OS_FALSE;
 d010718:	e03ff205 	stb	zero,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01071c:	0005303a 	rdctl	r2,status
 d010720:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010724:	e0fff017 	ldw	r3,-64(fp)
 d010728:	00bfff84 	movi	r2,-2
 d01072c:	1884703a 	and	r2,r3,r2
 d010730:	1001703a 	wrctl	status,r2
  
  return context;
 d010734:	e0bff017 	ldw	r2,-64(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 d010738:	e0bff115 	stw	r2,-60(fp)
    switch (wait_type) {
 d01073c:	e0bffb03 	ldbu	r2,-20(fp)
 d010740:	e0bffe15 	stw	r2,-8(fp)
 d010744:	e0fffe17 	ldw	r3,-8(fp)
 d010748:	18800060 	cmpeqi	r2,r3,1
 d01074c:	1000981e 	bne	r2,zero,d0109b0 <OSFlagPend+0x3a8>
 d010750:	e0fffe17 	ldw	r3,-8(fp)
 d010754:	18800088 	cmpgei	r2,r3,2
 d010758:	1000041e 	bne	r2,zero,d01076c <OSFlagPend+0x164>
 d01075c:	e0fffe17 	ldw	r3,-8(fp)
 d010760:	1805003a 	cmpeq	r2,r3,zero
 d010764:	1000641e 	bne	r2,zero,d0108f8 <OSFlagPend+0x2f0>
 d010768:	0000bf06 	br	d010a68 <OSFlagPend+0x460>
 d01076c:	e0fffe17 	ldw	r3,-8(fp)
 d010770:	188000a0 	cmpeqi	r2,r3,2
 d010774:	1000041e 	bne	r2,zero,d010788 <OSFlagPend+0x180>
 d010778:	e0fffe17 	ldw	r3,-8(fp)
 d01077c:	188000e0 	cmpeqi	r2,r3,3
 d010780:	10002f1e 	bne	r2,zero,d010840 <OSFlagPend+0x238>
 d010784:	0000b806 	br	d010a68 <OSFlagPend+0x460>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 d010788:	e0bff917 	ldw	r2,-28(fp)
 d01078c:	10c0020b 	ldhu	r3,8(r2)
 d010790:	e0bffa0b 	ldhu	r2,-24(fp)
 d010794:	1884703a 	and	r2,r3,r2
 d010798:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d01079c:	e0fff30b 	ldhu	r3,-52(fp)
 d0107a0:	e0bffa0b 	ldhu	r2,-24(fp)
 d0107a4:	18801a1e 	bne	r3,r2,d010810 <OSFlagPend+0x208>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d0107a8:	e0bff203 	ldbu	r2,-56(fp)
 d0107ac:	10800058 	cmpnei	r2,r2,1
 d0107b0:	1000091e 	bne	r2,zero,d0107d8 <OSFlagPend+0x1d0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 d0107b4:	e0bff917 	ldw	r2,-28(fp)
 d0107b8:	1080020b 	ldhu	r2,8(r2)
 d0107bc:	1007883a 	mov	r3,r2
 d0107c0:	e0bff30b 	ldhu	r2,-52(fp)
 d0107c4:	0084303a 	nor	r2,zero,r2
 d0107c8:	1884703a 	and	r2,r3,r2
 d0107cc:	1007883a 	mov	r3,r2
 d0107d0:	e0bff917 	ldw	r2,-28(fp)
 d0107d4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d0107d8:	00834174 	movhi	r2,3333
 d0107dc:	109b1804 	addi	r2,r2,27744
 d0107e0:	10c00017 	ldw	r3,0(r2)
 d0107e4:	e0bff30b 	ldhu	r2,-52(fp)
 d0107e8:	18800b0d 	sth	r2,44(r3)
 d0107ec:	e0bff117 	ldw	r2,-60(fp)
 d0107f0:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0107f4:	e0bfef17 	ldw	r2,-68(fp)
 d0107f8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d0107fc:	e0800217 	ldw	r2,8(fp)
 d010800:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d010804:	e0bff30b 	ldhu	r2,-52(fp)
 d010808:	e0bfff15 	stw	r2,-4(fp)
 d01080c:	00010906 	br	d010c34 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d010810:	e1bffa0b 	ldhu	r6,-24(fp)
 d010814:	e1fffb03 	ldbu	r7,-20(fp)
 d010818:	e0bffc0b 	ldhu	r2,-16(fp)
 d01081c:	e17ff404 	addi	r5,fp,-48
 d010820:	d8800015 	stw	r2,0(sp)
 d010824:	e13ff917 	ldw	r4,-28(fp)
 d010828:	d0111300 	call	d011130 <OS_FlagBlock>
 d01082c:	e0bff117 	ldw	r2,-60(fp)
 d010830:	e0bfee15 	stw	r2,-72(fp)
 d010834:	e0bfee17 	ldw	r2,-72(fp)
 d010838:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d01083c:	00009506 	br	d010a94 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 d010840:	e0bff917 	ldw	r2,-28(fp)
 d010844:	10c0020b 	ldhu	r3,8(r2)
 d010848:	e0bffa0b 	ldhu	r2,-24(fp)
 d01084c:	1884703a 	and	r2,r3,r2
 d010850:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 d010854:	e0bff30b 	ldhu	r2,-52(fp)
 d010858:	1005003a 	cmpeq	r2,r2,zero
 d01085c:	10001a1e 	bne	r2,zero,d0108c8 <OSFlagPend+0x2c0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d010860:	e0bff203 	ldbu	r2,-56(fp)
 d010864:	10800058 	cmpnei	r2,r2,1
 d010868:	1000091e 	bne	r2,zero,d010890 <OSFlagPend+0x288>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 d01086c:	e0bff917 	ldw	r2,-28(fp)
 d010870:	1080020b 	ldhu	r2,8(r2)
 d010874:	1007883a 	mov	r3,r2
 d010878:	e0bff30b 	ldhu	r2,-52(fp)
 d01087c:	0084303a 	nor	r2,zero,r2
 d010880:	1884703a 	and	r2,r3,r2
 d010884:	1007883a 	mov	r3,r2
 d010888:	e0bff917 	ldw	r2,-28(fp)
 d01088c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d010890:	00834174 	movhi	r2,3333
 d010894:	109b1804 	addi	r2,r2,27744
 d010898:	10c00017 	ldw	r3,0(r2)
 d01089c:	e0bff30b 	ldhu	r2,-52(fp)
 d0108a0:	18800b0d 	sth	r2,44(r3)
 d0108a4:	e0bff117 	ldw	r2,-60(fp)
 d0108a8:	e0bfed15 	stw	r2,-76(fp)
 d0108ac:	e0bfed17 	ldw	r2,-76(fp)
 d0108b0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d0108b4:	e0800217 	ldw	r2,8(fp)
 d0108b8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d0108bc:	e0fff30b 	ldhu	r3,-52(fp)
 d0108c0:	e0ffff15 	stw	r3,-4(fp)
 d0108c4:	0000db06 	br	d010c34 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d0108c8:	e1bffa0b 	ldhu	r6,-24(fp)
 d0108cc:	e1fffb03 	ldbu	r7,-20(fp)
 d0108d0:	e0bffc0b 	ldhu	r2,-16(fp)
 d0108d4:	e17ff404 	addi	r5,fp,-48
 d0108d8:	d8800015 	stw	r2,0(sp)
 d0108dc:	e13ff917 	ldw	r4,-28(fp)
 d0108e0:	d0111300 	call	d011130 <OS_FlagBlock>
 d0108e4:	e0bff117 	ldw	r2,-60(fp)
 d0108e8:	e0bfec15 	stw	r2,-80(fp)
 d0108ec:	e0bfec17 	ldw	r2,-80(fp)
 d0108f0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d0108f4:	00006706 	br	d010a94 <OSFlagPend+0x48c>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 d0108f8:	e0bff917 	ldw	r2,-28(fp)
 d0108fc:	1080020b 	ldhu	r2,8(r2)
 d010900:	0084303a 	nor	r2,zero,r2
 d010904:	1007883a 	mov	r3,r2
 d010908:	e0bffa0b 	ldhu	r2,-24(fp)
 d01090c:	1884703a 	and	r2,r3,r2
 d010910:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d010914:	e0fff30b 	ldhu	r3,-52(fp)
 d010918:	e0bffa0b 	ldhu	r2,-24(fp)
 d01091c:	1880181e 	bne	r3,r2,d010980 <OSFlagPend+0x378>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d010920:	e0bff203 	ldbu	r2,-56(fp)
 d010924:	10800058 	cmpnei	r2,r2,1
 d010928:	1000071e 	bne	r2,zero,d010948 <OSFlagPend+0x340>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 d01092c:	e0bff917 	ldw	r2,-28(fp)
 d010930:	10c0020b 	ldhu	r3,8(r2)
 d010934:	e0bff30b 	ldhu	r2,-52(fp)
 d010938:	1884b03a 	or	r2,r3,r2
 d01093c:	1007883a 	mov	r3,r2
 d010940:	e0bff917 	ldw	r2,-28(fp)
 d010944:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d010948:	00834174 	movhi	r2,3333
 d01094c:	109b1804 	addi	r2,r2,27744
 d010950:	10c00017 	ldw	r3,0(r2)
 d010954:	e0bff30b 	ldhu	r2,-52(fp)
 d010958:	18800b0d 	sth	r2,44(r3)
 d01095c:	e0bff117 	ldw	r2,-60(fp)
 d010960:	e0bfeb15 	stw	r2,-84(fp)
 d010964:	e0bfeb17 	ldw	r2,-84(fp)
 d010968:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d01096c:	e0800217 	ldw	r2,8(fp)
 d010970:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d010974:	e0bff30b 	ldhu	r2,-52(fp)
 d010978:	e0bfff15 	stw	r2,-4(fp)
 d01097c:	0000ad06 	br	d010c34 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d010980:	e1bffa0b 	ldhu	r6,-24(fp)
 d010984:	e1fffb03 	ldbu	r7,-20(fp)
 d010988:	e0bffc0b 	ldhu	r2,-16(fp)
 d01098c:	e17ff404 	addi	r5,fp,-48
 d010990:	d8800015 	stw	r2,0(sp)
 d010994:	e13ff917 	ldw	r4,-28(fp)
 d010998:	d0111300 	call	d011130 <OS_FlagBlock>
 d01099c:	e0bff117 	ldw	r2,-60(fp)
 d0109a0:	e0bfea15 	stw	r2,-88(fp)
 d0109a4:	e0bfea17 	ldw	r2,-88(fp)
 d0109a8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d0109ac:	00003906 	br	d010a94 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 d0109b0:	e0bff917 	ldw	r2,-28(fp)
 d0109b4:	1080020b 	ldhu	r2,8(r2)
 d0109b8:	0084303a 	nor	r2,zero,r2
 d0109bc:	1007883a 	mov	r3,r2
 d0109c0:	e0bffa0b 	ldhu	r2,-24(fp)
 d0109c4:	1884703a 	and	r2,r3,r2
 d0109c8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 d0109cc:	e0bff30b 	ldhu	r2,-52(fp)
 d0109d0:	1005003a 	cmpeq	r2,r2,zero
 d0109d4:	1000181e 	bne	r2,zero,d010a38 <OSFlagPend+0x430>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d0109d8:	e0bff203 	ldbu	r2,-56(fp)
 d0109dc:	10800058 	cmpnei	r2,r2,1
 d0109e0:	1000071e 	bne	r2,zero,d010a00 <OSFlagPend+0x3f8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 d0109e4:	e0bff917 	ldw	r2,-28(fp)
 d0109e8:	10c0020b 	ldhu	r3,8(r2)
 d0109ec:	e0bff30b 	ldhu	r2,-52(fp)
 d0109f0:	1884b03a 	or	r2,r3,r2
 d0109f4:	1007883a 	mov	r3,r2
 d0109f8:	e0bff917 	ldw	r2,-28(fp)
 d0109fc:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d010a00:	00834174 	movhi	r2,3333
 d010a04:	109b1804 	addi	r2,r2,27744
 d010a08:	10c00017 	ldw	r3,0(r2)
 d010a0c:	e0bff30b 	ldhu	r2,-52(fp)
 d010a10:	18800b0d 	sth	r2,44(r3)
 d010a14:	e0bff117 	ldw	r2,-60(fp)
 d010a18:	e0bfe915 	stw	r2,-92(fp)
 d010a1c:	e0bfe917 	ldw	r2,-92(fp)
 d010a20:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d010a24:	e0800217 	ldw	r2,8(fp)
 d010a28:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d010a2c:	e0fff30b 	ldhu	r3,-52(fp)
 d010a30:	e0ffff15 	stw	r3,-4(fp)
 d010a34:	00007f06 	br	d010c34 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d010a38:	e1bffa0b 	ldhu	r6,-24(fp)
 d010a3c:	e1fffb03 	ldbu	r7,-20(fp)
 d010a40:	e0bffc0b 	ldhu	r2,-16(fp)
 d010a44:	e17ff404 	addi	r5,fp,-48
 d010a48:	d8800015 	stw	r2,0(sp)
 d010a4c:	e13ff917 	ldw	r4,-28(fp)
 d010a50:	d0111300 	call	d011130 <OS_FlagBlock>
 d010a54:	e0bff117 	ldw	r2,-60(fp)
 d010a58:	e0bfe815 	stw	r2,-96(fp)
 d010a5c:	e0bfe817 	ldw	r2,-96(fp)
 d010a60:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d010a64:	00000b06 	br	d010a94 <OSFlagPend+0x48c>
 d010a68:	e0bff117 	ldw	r2,-60(fp)
 d010a6c:	e0bfe715 	stw	r2,-100(fp)
 d010a70:	e0bfe717 	ldw	r2,-100(fp)
 d010a74:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 d010a78:	e03ff30d 	sth	zero,-52(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 d010a7c:	e0c00217 	ldw	r3,8(fp)
 d010a80:	00801bc4 	movi	r2,111
 d010a84:	18800005 	stb	r2,0(r3)
             return (flags_rdy);
 d010a88:	e0bff30b 	ldhu	r2,-52(fp)
 d010a8c:	e0bfff15 	stw	r2,-4(fp)
 d010a90:	00006806 	br	d010c34 <OSFlagPend+0x62c>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 d010a94:	d00f3e40 	call	d00f3e4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010a98:	0005303a 	rdctl	r2,status
 d010a9c:	e0bfe615 	stw	r2,-104(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010aa0:	e0ffe617 	ldw	r3,-104(fp)
 d010aa4:	00bfff84 	movi	r2,-2
 d010aa8:	1884703a 	and	r2,r3,r2
 d010aac:	1001703a 	wrctl	status,r2
  
  return context;
 d010ab0:	e0bfe617 	ldw	r2,-104(fp)
    OS_ENTER_CRITICAL();
 d010ab4:	e0bff115 	stw	r2,-60(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 d010ab8:	00834174 	movhi	r2,3333
 d010abc:	109b1804 	addi	r2,r2,27744
 d010ac0:	10800017 	ldw	r2,0(r2)
 d010ac4:	10800c43 	ldbu	r2,49(r2)
 d010ac8:	10803fcc 	andi	r2,r2,255
 d010acc:	1005003a 	cmpeq	r2,r2,zero
 d010ad0:	1000221e 	bne	r2,zero,d010b5c <OSFlagPend+0x554>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 d010ad4:	00834174 	movhi	r2,3333
 d010ad8:	109b1804 	addi	r2,r2,27744
 d010adc:	10800017 	ldw	r2,0(r2)
 d010ae0:	10800c43 	ldbu	r2,49(r2)
 d010ae4:	e0bff245 	stb	r2,-55(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d010ae8:	00834174 	movhi	r2,3333
 d010aec:	109b1804 	addi	r2,r2,27744
 d010af0:	10800017 	ldw	r2,0(r2)
 d010af4:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 d010af8:	e13ff404 	addi	r4,fp,-48
 d010afc:	d0114e80 	call	d0114e8 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 d010b00:	00834174 	movhi	r2,3333
 d010b04:	109b1804 	addi	r2,r2,27744
 d010b08:	10800017 	ldw	r2,0(r2)
 d010b0c:	10000c05 	stb	zero,48(r2)
 d010b10:	e0bff117 	ldw	r2,-60(fp)
 d010b14:	e0bfe515 	stw	r2,-108(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010b18:	e0bfe517 	ldw	r2,-108(fp)
 d010b1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 d010b20:	e03ff30d 	sth	zero,-52(fp)
        switch (pend_stat) {
 d010b24:	e0bff243 	ldbu	r2,-55(fp)
 d010b28:	108000a0 	cmpeqi	r2,r2,2
 d010b2c:	1000011e 	bne	r2,zero,d010b34 <OSFlagPend+0x52c>
 d010b30:	00000406 	br	d010b44 <OSFlagPend+0x53c>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 d010b34:	e0c00217 	ldw	r3,8(fp)
 d010b38:	00800384 	movi	r2,14
 d010b3c:	18800005 	stb	r2,0(r3)
                 break;
 d010b40:	00000306 	br	d010b50 <OSFlagPend+0x548>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 d010b44:	e0c00217 	ldw	r3,8(fp)
 d010b48:	00800284 	movi	r2,10
 d010b4c:	18800005 	stb	r2,0(r3)
                 break;
        }
        return (flags_rdy);
 d010b50:	e0fff30b 	ldhu	r3,-52(fp)
 d010b54:	e0ffff15 	stw	r3,-4(fp)
 d010b58:	00003606 	br	d010c34 <OSFlagPend+0x62c>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 d010b5c:	00834174 	movhi	r2,3333
 d010b60:	109b1804 	addi	r2,r2,27744
 d010b64:	10800017 	ldw	r2,0(r2)
 d010b68:	10800b0b 	ldhu	r2,44(r2)
 d010b6c:	e0bff30d 	sth	r2,-52(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 d010b70:	e0bff203 	ldbu	r2,-56(fp)
 d010b74:	10800058 	cmpnei	r2,r2,1
 d010b78:	1000261e 	bne	r2,zero,d010c14 <OSFlagPend+0x60c>
        switch (wait_type) {
 d010b7c:	e0bffb03 	ldbu	r2,-20(fp)
 d010b80:	e0bffd15 	stw	r2,-12(fp)
 d010b84:	e0fffd17 	ldw	r3,-12(fp)
 d010b88:	1804803a 	cmplt	r2,r3,zero
 d010b8c:	1000181e 	bne	r2,zero,d010bf0 <OSFlagPend+0x5e8>
 d010b90:	e0fffd17 	ldw	r3,-12(fp)
 d010b94:	18800090 	cmplti	r2,r3,2
 d010b98:	10000d1e 	bne	r2,zero,d010bd0 <OSFlagPend+0x5c8>
 d010b9c:	e0fffd17 	ldw	r3,-12(fp)
 d010ba0:	18800108 	cmpgei	r2,r3,4
 d010ba4:	1000121e 	bne	r2,zero,d010bf0 <OSFlagPend+0x5e8>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 d010ba8:	e0bff917 	ldw	r2,-28(fp)
 d010bac:	1080020b 	ldhu	r2,8(r2)
 d010bb0:	1007883a 	mov	r3,r2
 d010bb4:	e0bff30b 	ldhu	r2,-52(fp)
 d010bb8:	0084303a 	nor	r2,zero,r2
 d010bbc:	1884703a 	and	r2,r3,r2
 d010bc0:	1007883a 	mov	r3,r2
 d010bc4:	e0bff917 	ldw	r2,-28(fp)
 d010bc8:	10c0020d 	sth	r3,8(r2)
                 break;
 d010bcc:	00001106 	br	d010c14 <OSFlagPend+0x60c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 d010bd0:	e0bff917 	ldw	r2,-28(fp)
 d010bd4:	10c0020b 	ldhu	r3,8(r2)
 d010bd8:	e0bff30b 	ldhu	r2,-52(fp)
 d010bdc:	1884b03a 	or	r2,r3,r2
 d010be0:	1007883a 	mov	r3,r2
 d010be4:	e0bff917 	ldw	r2,-28(fp)
 d010be8:	10c0020d 	sth	r3,8(r2)
                 break;
 d010bec:	00000906 	br	d010c14 <OSFlagPend+0x60c>
 d010bf0:	e0bff117 	ldw	r2,-60(fp)
 d010bf4:	e0bfe415 	stw	r2,-112(fp)
 d010bf8:	e0bfe417 	ldw	r2,-112(fp)
 d010bfc:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 d010c00:	e0c00217 	ldw	r3,8(fp)
 d010c04:	00801bc4 	movi	r2,111
 d010c08:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 d010c0c:	e03fff15 	stw	zero,-4(fp)
 d010c10:	00000806 	br	d010c34 <OSFlagPend+0x62c>
 d010c14:	e0bff117 	ldw	r2,-60(fp)
 d010c18:	e0bfe315 	stw	r2,-116(fp)
 d010c1c:	e0bfe317 	ldw	r2,-116(fp)
 d010c20:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 d010c24:	e0800217 	ldw	r2,8(fp)
 d010c28:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 d010c2c:	e0bff30b 	ldhu	r2,-52(fp)
 d010c30:	e0bfff15 	stw	r2,-4(fp)
 d010c34:	e0bfff17 	ldw	r2,-4(fp)
}
 d010c38:	e037883a 	mov	sp,fp
 d010c3c:	dfc00117 	ldw	ra,4(sp)
 d010c40:	df000017 	ldw	fp,0(sp)
 d010c44:	dec00204 	addi	sp,sp,8
 d010c48:	f800283a 	ret

0d010c4c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 d010c4c:	defffb04 	addi	sp,sp,-20
 d010c50:	df000415 	stw	fp,16(sp)
 d010c54:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d010c58:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010c5c:	0005303a 	rdctl	r2,status
 d010c60:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010c64:	e0fffd17 	ldw	r3,-12(fp)
 d010c68:	00bfff84 	movi	r2,-2
 d010c6c:	1884703a 	and	r2,r3,r2
 d010c70:	1001703a 	wrctl	status,r2
  
  return context;
 d010c74:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 d010c78:	e0bffe15 	stw	r2,-8(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 d010c7c:	00834174 	movhi	r2,3333
 d010c80:	109b1804 	addi	r2,r2,27744
 d010c84:	10800017 	ldw	r2,0(r2)
 d010c88:	10800b0b 	ldhu	r2,44(r2)
 d010c8c:	e0bfff0d 	sth	r2,-4(fp)
 d010c90:	e0bffe17 	ldw	r2,-8(fp)
 d010c94:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010c98:	e0bffc17 	ldw	r2,-16(fp)
 d010c9c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 d010ca0:	e0bfff0b 	ldhu	r2,-4(fp)
}
 d010ca4:	e037883a 	mov	sp,fp
 d010ca8:	df000017 	ldw	fp,0(sp)
 d010cac:	dec00104 	addi	sp,sp,4
 d010cb0:	f800283a 	ret

0d010cb4 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 d010cb4:	deffed04 	addi	sp,sp,-76
 d010cb8:	dfc01215 	stw	ra,72(sp)
 d010cbc:	df001115 	stw	fp,68(sp)
 d010cc0:	df001104 	addi	fp,sp,68
 d010cc4:	e13ff915 	stw	r4,-28(fp)
 d010cc8:	e1fffc15 	stw	r7,-16(fp)
 d010ccc:	e17ffa0d 	sth	r5,-24(fp)
 d010cd0:	e1bffb05 	stb	r6,-20(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 d010cd4:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 d010cd8:	e0bffc17 	ldw	r2,-16(fp)
 d010cdc:	1004c03a 	cmpne	r2,r2,zero
 d010ce0:	1000021e 	bne	r2,zero,d010cec <OSFlagPost+0x38>
        return ((OS_FLAGS)0);
 d010ce4:	e03fff15 	stw	zero,-4(fp)
 d010ce8:	0000d606 	br	d011044 <OSFlagPost+0x390>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 d010cec:	e0bff917 	ldw	r2,-28(fp)
 d010cf0:	1004c03a 	cmpne	r2,r2,zero
 d010cf4:	1000051e 	bne	r2,zero,d010d0c <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d010cf8:	e0fffc17 	ldw	r3,-16(fp)
 d010cfc:	00801b84 	movi	r2,110
 d010d00:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010d04:	e03fff15 	stw	zero,-4(fp)
 d010d08:	0000ce06 	br	d011044 <OSFlagPost+0x390>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 d010d0c:	e0bff917 	ldw	r2,-28(fp)
 d010d10:	10800003 	ldbu	r2,0(r2)
 d010d14:	10803fcc 	andi	r2,r2,255
 d010d18:	10800160 	cmpeqi	r2,r2,5
 d010d1c:	1000051e 	bne	r2,zero,d010d34 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 d010d20:	e0fffc17 	ldw	r3,-16(fp)
 d010d24:	00800044 	movi	r2,1
 d010d28:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010d2c:	e03fff15 	stw	zero,-4(fp)
 d010d30:	0000c406 	br	d011044 <OSFlagPost+0x390>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010d34:	0005303a 	rdctl	r2,status
 d010d38:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010d3c:	e0fff417 	ldw	r3,-48(fp)
 d010d40:	00bfff84 	movi	r2,-2
 d010d44:	1884703a 	and	r2,r3,r2
 d010d48:	1001703a 	wrctl	status,r2
  
  return context;
 d010d4c:	e0bff417 	ldw	r2,-48(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 d010d50:	e0bff515 	stw	r2,-44(fp)
    switch (opt) {
 d010d54:	e0bffb03 	ldbu	r2,-20(fp)
 d010d58:	e0bffe15 	stw	r2,-8(fp)
 d010d5c:	e0fffe17 	ldw	r3,-8(fp)
 d010d60:	1805003a 	cmpeq	r2,r3,zero
 d010d64:	1000041e 	bne	r2,zero,d010d78 <OSFlagPost+0xc4>
 d010d68:	e0fffe17 	ldw	r3,-8(fp)
 d010d6c:	18800060 	cmpeqi	r2,r3,1
 d010d70:	10000b1e 	bne	r2,zero,d010da0 <OSFlagPost+0xec>
 d010d74:	00001206 	br	d010dc0 <OSFlagPost+0x10c>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 d010d78:	e0bff917 	ldw	r2,-28(fp)
 d010d7c:	1080020b 	ldhu	r2,8(r2)
 d010d80:	1007883a 	mov	r3,r2
 d010d84:	e0bffa0b 	ldhu	r2,-24(fp)
 d010d88:	0084303a 	nor	r2,zero,r2
 d010d8c:	1884703a 	and	r2,r3,r2
 d010d90:	1007883a 	mov	r3,r2
 d010d94:	e0bff917 	ldw	r2,-28(fp)
 d010d98:	10c0020d 	sth	r3,8(r2)
             break;
 d010d9c:	00001106 	br	d010de4 <OSFlagPost+0x130>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 d010da0:	e0bff917 	ldw	r2,-28(fp)
 d010da4:	10c0020b 	ldhu	r3,8(r2)
 d010da8:	e0bffa0b 	ldhu	r2,-24(fp)
 d010dac:	1884b03a 	or	r2,r3,r2
 d010db0:	1007883a 	mov	r3,r2
 d010db4:	e0bff917 	ldw	r2,-28(fp)
 d010db8:	10c0020d 	sth	r3,8(r2)
             break;
 d010dbc:	00000906 	br	d010de4 <OSFlagPost+0x130>
 d010dc0:	e0bff517 	ldw	r2,-44(fp)
 d010dc4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010dc8:	e0bff317 	ldw	r2,-52(fp)
 d010dcc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 d010dd0:	e0fffc17 	ldw	r3,-16(fp)
 d010dd4:	00801c44 	movi	r2,113
 d010dd8:	18800005 	stb	r2,0(r3)
             return ((OS_FLAGS)0);
 d010ddc:	e03fff15 	stw	zero,-4(fp)
 d010de0:	00009806 	br	d011044 <OSFlagPost+0x390>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 d010de4:	e03ff785 	stb	zero,-34(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 d010de8:	e0bff917 	ldw	r2,-28(fp)
 d010dec:	10800117 	ldw	r2,4(r2)
 d010df0:	e0bff815 	stw	r2,-32(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 d010df4:	00007506 	br	d010fcc <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
 d010df8:	e0bff817 	ldw	r2,-32(fp)
 d010dfc:	10800483 	ldbu	r2,18(r2)
 d010e00:	10803fcc 	andi	r2,r2,255
 d010e04:	e0bffd15 	stw	r2,-12(fp)
 d010e08:	e0fffd17 	ldw	r3,-12(fp)
 d010e0c:	18800060 	cmpeqi	r2,r3,1
 d010e10:	10004d1e 	bne	r2,zero,d010f48 <OSFlagPost+0x294>
 d010e14:	e0fffd17 	ldw	r3,-12(fp)
 d010e18:	18800088 	cmpgei	r2,r3,2
 d010e1c:	1000041e 	bne	r2,zero,d010e30 <OSFlagPost+0x17c>
 d010e20:	e0fffd17 	ldw	r3,-12(fp)
 d010e24:	1805003a 	cmpeq	r2,r3,zero
 d010e28:	1000301e 	bne	r2,zero,d010eec <OSFlagPost+0x238>
 d010e2c:	00005b06 	br	d010f9c <OSFlagPost+0x2e8>
 d010e30:	e0fffd17 	ldw	r3,-12(fp)
 d010e34:	188000a0 	cmpeqi	r2,r3,2
 d010e38:	1000041e 	bne	r2,zero,d010e4c <OSFlagPost+0x198>
 d010e3c:	e0fffd17 	ldw	r3,-12(fp)
 d010e40:	188000e0 	cmpeqi	r2,r3,3
 d010e44:	1000161e 	bne	r2,zero,d010ea0 <OSFlagPost+0x1ec>
 d010e48:	00005406 	br	d010f9c <OSFlagPost+0x2e8>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010e4c:	e0bff917 	ldw	r2,-28(fp)
 d010e50:	10c0020b 	ldhu	r3,8(r2)
 d010e54:	e0bff817 	ldw	r2,-32(fp)
 d010e58:	1080040b 	ldhu	r2,16(r2)
 d010e5c:	1884703a 	and	r2,r3,r2
 d010e60:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 d010e64:	e0bff817 	ldw	r2,-32(fp)
 d010e68:	1080040b 	ldhu	r2,16(r2)
 d010e6c:	10ffffcc 	andi	r3,r2,65535
 d010e70:	e0bff68b 	ldhu	r2,-38(fp)
 d010e74:	1880521e 	bne	r3,r2,d010fc0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010e78:	e17ff68b 	ldhu	r5,-38(fp)
 d010e7c:	e13ff817 	ldw	r4,-32(fp)
 d010e80:	d0113d80 	call	d0113d8 <OS_FlagTaskRdy>
 d010e84:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010e88:	e0bff603 	ldbu	r2,-40(fp)
 d010e8c:	10800058 	cmpnei	r2,r2,1
 d010e90:	10004b1e 	bne	r2,zero,d010fc0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010e94:	00800044 	movi	r2,1
 d010e98:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010e9c:	00004806 	br	d010fc0 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010ea0:	e0bff917 	ldw	r2,-28(fp)
 d010ea4:	10c0020b 	ldhu	r3,8(r2)
 d010ea8:	e0bff817 	ldw	r2,-32(fp)
 d010eac:	1080040b 	ldhu	r2,16(r2)
 d010eb0:	1884703a 	and	r2,r3,r2
 d010eb4:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 d010eb8:	e0bff68b 	ldhu	r2,-38(fp)
 d010ebc:	1005003a 	cmpeq	r2,r2,zero
 d010ec0:	10003f1e 	bne	r2,zero,d010fc0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010ec4:	e17ff68b 	ldhu	r5,-38(fp)
 d010ec8:	e13ff817 	ldw	r4,-32(fp)
 d010ecc:	d0113d80 	call	d0113d8 <OS_FlagTaskRdy>
 d010ed0:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010ed4:	e0bff603 	ldbu	r2,-40(fp)
 d010ed8:	10800058 	cmpnei	r2,r2,1
 d010edc:	1000381e 	bne	r2,zero,d010fc0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010ee0:	00800044 	movi	r2,1
 d010ee4:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010ee8:	00003506 	br	d010fc0 <OSFlagPost+0x30c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010eec:	e0bff917 	ldw	r2,-28(fp)
 d010ef0:	1080020b 	ldhu	r2,8(r2)
 d010ef4:	0084303a 	nor	r2,zero,r2
 d010ef8:	1007883a 	mov	r3,r2
 d010efc:	e0bff817 	ldw	r2,-32(fp)
 d010f00:	1080040b 	ldhu	r2,16(r2)
 d010f04:	1884703a 	and	r2,r3,r2
 d010f08:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 d010f0c:	e0bff817 	ldw	r2,-32(fp)
 d010f10:	1080040b 	ldhu	r2,16(r2)
 d010f14:	10ffffcc 	andi	r3,r2,65535
 d010f18:	e0bff68b 	ldhu	r2,-38(fp)
 d010f1c:	1880281e 	bne	r3,r2,d010fc0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010f20:	e17ff68b 	ldhu	r5,-38(fp)
 d010f24:	e13ff817 	ldw	r4,-32(fp)
 d010f28:	d0113d80 	call	d0113d8 <OS_FlagTaskRdy>
 d010f2c:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010f30:	e0bff603 	ldbu	r2,-40(fp)
 d010f34:	10800058 	cmpnei	r2,r2,1
 d010f38:	1000211e 	bne	r2,zero,d010fc0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010f3c:	00800044 	movi	r2,1
 d010f40:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010f44:	00001e06 	br	d010fc0 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010f48:	e0bff917 	ldw	r2,-28(fp)
 d010f4c:	1080020b 	ldhu	r2,8(r2)
 d010f50:	0084303a 	nor	r2,zero,r2
 d010f54:	1007883a 	mov	r3,r2
 d010f58:	e0bff817 	ldw	r2,-32(fp)
 d010f5c:	1080040b 	ldhu	r2,16(r2)
 d010f60:	1884703a 	and	r2,r3,r2
 d010f64:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 d010f68:	e0bff68b 	ldhu	r2,-38(fp)
 d010f6c:	1005003a 	cmpeq	r2,r2,zero
 d010f70:	1000131e 	bne	r2,zero,d010fc0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010f74:	e17ff68b 	ldhu	r5,-38(fp)
 d010f78:	e13ff817 	ldw	r4,-32(fp)
 d010f7c:	d0113d80 	call	d0113d8 <OS_FlagTaskRdy>
 d010f80:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010f84:	e0bff603 	ldbu	r2,-40(fp)
 d010f88:	10800058 	cmpnei	r2,r2,1
 d010f8c:	10000c1e 	bne	r2,zero,d010fc0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010f90:	00800044 	movi	r2,1
 d010f94:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010f98:	00000906 	br	d010fc0 <OSFlagPost+0x30c>
 d010f9c:	e0bff517 	ldw	r2,-44(fp)
 d010fa0:	e0bff215 	stw	r2,-56(fp)
 d010fa4:	e0bff217 	ldw	r2,-56(fp)
 d010fa8:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 d010fac:	e0fffc17 	ldw	r3,-16(fp)
 d010fb0:	00801bc4 	movi	r2,111
 d010fb4:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 d010fb8:	e03fff15 	stw	zero,-4(fp)
 d010fbc:	00002106 	br	d011044 <OSFlagPost+0x390>
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 d010fc0:	e0bff817 	ldw	r2,-32(fp)
 d010fc4:	10800017 	ldw	r2,0(r2)
 d010fc8:	e0bff815 	stw	r2,-32(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 d010fcc:	e0bff817 	ldw	r2,-32(fp)
 d010fd0:	1004c03a 	cmpne	r2,r2,zero
 d010fd4:	103f881e 	bne	r2,zero,d010df8 <OSFlagPost+0x144>
 d010fd8:	e0bff517 	ldw	r2,-44(fp)
 d010fdc:	e0bff115 	stw	r2,-60(fp)
 d010fe0:	e0bff117 	ldw	r2,-60(fp)
 d010fe4:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 d010fe8:	e0bff783 	ldbu	r2,-34(fp)
 d010fec:	10800058 	cmpnei	r2,r2,1
 d010ff0:	1000011e 	bne	r2,zero,d010ff8 <OSFlagPost+0x344>
        OS_Sched();
 d010ff4:	d00f3e40 	call	d00f3e4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010ff8:	0005303a 	rdctl	r2,status
 d010ffc:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011000:	e0fff017 	ldw	r3,-64(fp)
 d011004:	00bfff84 	movi	r2,-2
 d011008:	1884703a 	and	r2,r3,r2
 d01100c:	1001703a 	wrctl	status,r2
  
  return context;
 d011010:	e0bff017 	ldw	r2,-64(fp)
    }
    OS_ENTER_CRITICAL();
 d011014:	e0bff515 	stw	r2,-44(fp)
    flags_cur = pgrp->OSFlagFlags;
 d011018:	e0bff917 	ldw	r2,-28(fp)
 d01101c:	1080020b 	ldhu	r2,8(r2)
 d011020:	e0bff70d 	sth	r2,-36(fp)
 d011024:	e0bff517 	ldw	r2,-44(fp)
 d011028:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01102c:	e0bfef17 	ldw	r2,-68(fp)
 d011030:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 d011034:	e0bffc17 	ldw	r2,-16(fp)
 d011038:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 d01103c:	e0bff70b 	ldhu	r2,-36(fp)
 d011040:	e0bfff15 	stw	r2,-4(fp)
 d011044:	e0bfff17 	ldw	r2,-4(fp)
}
 d011048:	e037883a 	mov	sp,fp
 d01104c:	dfc00117 	ldw	ra,4(sp)
 d011050:	df000017 	ldw	fp,0(sp)
 d011054:	dec00204 	addi	sp,sp,8
 d011058:	f800283a 	ret

0d01105c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 d01105c:	defff804 	addi	sp,sp,-32
 d011060:	df000715 	stw	fp,28(sp)
 d011064:	df000704 	addi	fp,sp,28
 d011068:	e13ffd15 	stw	r4,-12(fp)
 d01106c:	e17ffe15 	stw	r5,-8(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 d011070:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 d011074:	e0bffe17 	ldw	r2,-8(fp)
 d011078:	1004c03a 	cmpne	r2,r2,zero
 d01107c:	1000021e 	bne	r2,zero,d011088 <OSFlagQuery+0x2c>
        return ((OS_FLAGS)0);
 d011080:	e03fff15 	stw	zero,-4(fp)
 d011084:	00002506 	br	d01111c <OSFlagQuery+0xc0>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 d011088:	e0bffd17 	ldw	r2,-12(fp)
 d01108c:	1004c03a 	cmpne	r2,r2,zero
 d011090:	1000051e 	bne	r2,zero,d0110a8 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d011094:	e0fffe17 	ldw	r3,-8(fp)
 d011098:	00801b84 	movi	r2,110
 d01109c:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d0110a0:	e03fff15 	stw	zero,-4(fp)
 d0110a4:	00001d06 	br	d01111c <OSFlagQuery+0xc0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 d0110a8:	e0bffd17 	ldw	r2,-12(fp)
 d0110ac:	10800003 	ldbu	r2,0(r2)
 d0110b0:	10803fcc 	andi	r2,r2,255
 d0110b4:	10800160 	cmpeqi	r2,r2,5
 d0110b8:	1000051e 	bne	r2,zero,d0110d0 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 d0110bc:	e0fffe17 	ldw	r3,-8(fp)
 d0110c0:	00800044 	movi	r2,1
 d0110c4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d0110c8:	e03fff15 	stw	zero,-4(fp)
 d0110cc:	00001306 	br	d01111c <OSFlagQuery+0xc0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0110d0:	0005303a 	rdctl	r2,status
 d0110d4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0110d8:	e0fffa17 	ldw	r3,-24(fp)
 d0110dc:	00bfff84 	movi	r2,-2
 d0110e0:	1884703a 	and	r2,r3,r2
 d0110e4:	1001703a 	wrctl	status,r2
  
  return context;
 d0110e8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d0110ec:	e0bffb15 	stw	r2,-20(fp)
    flags = pgrp->OSFlagFlags;
 d0110f0:	e0bffd17 	ldw	r2,-12(fp)
 d0110f4:	1080020b 	ldhu	r2,8(r2)
 d0110f8:	e0bffc0d 	sth	r2,-16(fp)
 d0110fc:	e0bffb17 	ldw	r2,-20(fp)
 d011100:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011104:	e0bff917 	ldw	r2,-28(fp)
 d011108:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d01110c:	e0bffe17 	ldw	r2,-8(fp)
 d011110:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 d011114:	e0bffc0b 	ldhu	r2,-16(fp)
 d011118:	e0bfff15 	stw	r2,-4(fp)
 d01111c:	e0bfff17 	ldw	r2,-4(fp)
}
 d011120:	e037883a 	mov	sp,fp
 d011124:	df000017 	ldw	fp,0(sp)
 d011128:	dec00104 	addi	sp,sp,4
 d01112c:	f800283a 	ret

0d011130 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 d011130:	defff804 	addi	sp,sp,-32
 d011134:	df000715 	stw	fp,28(sp)
 d011138:	df000704 	addi	fp,sp,28
 d01113c:	e13ffb15 	stw	r4,-20(fp)
 d011140:	e17ffc15 	stw	r5,-16(fp)
 d011144:	e0800117 	ldw	r2,4(fp)
 d011148:	e1bffd0d 	sth	r6,-12(fp)
 d01114c:	e1fffe05 	stb	r7,-8(fp)
 d011150:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 d011154:	00834174 	movhi	r2,3333
 d011158:	109b1804 	addi	r2,r2,27744
 d01115c:	10c00017 	ldw	r3,0(r2)
 d011160:	00834174 	movhi	r2,3333
 d011164:	109b1804 	addi	r2,r2,27744
 d011168:	10800017 	ldw	r2,0(r2)
 d01116c:	10800c03 	ldbu	r2,48(r2)
 d011170:	10800814 	ori	r2,r2,32
 d011174:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 d011178:	00834174 	movhi	r2,3333
 d01117c:	109b1804 	addi	r2,r2,27744
 d011180:	10800017 	ldw	r2,0(r2)
 d011184:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 d011188:	00834174 	movhi	r2,3333
 d01118c:	109b1804 	addi	r2,r2,27744
 d011190:	10c00017 	ldw	r3,0(r2)
 d011194:	e0bfff0b 	ldhu	r2,-4(fp)
 d011198:	18800b8d 	sth	r2,46(r3)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 d01119c:	00834174 	movhi	r2,3333
 d0111a0:	109b1804 	addi	r2,r2,27744
 d0111a4:	10c00017 	ldw	r3,0(r2)
 d0111a8:	e0bffc17 	ldw	r2,-16(fp)
 d0111ac:	18800a15 	stw	r2,40(r3)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 d0111b0:	e0fffc17 	ldw	r3,-16(fp)
 d0111b4:	e0bffd0b 	ldhu	r2,-12(fp)
 d0111b8:	1880040d 	sth	r2,16(r3)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 d0111bc:	e0fffc17 	ldw	r3,-16(fp)
 d0111c0:	e0bffe03 	ldbu	r2,-8(fp)
 d0111c4:	18800485 	stb	r2,18(r3)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 d0111c8:	00834174 	movhi	r2,3333
 d0111cc:	109b1804 	addi	r2,r2,27744
 d0111d0:	10c00017 	ldw	r3,0(r2)
 d0111d4:	e0bffc17 	ldw	r2,-16(fp)
 d0111d8:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 d0111dc:	e0bffb17 	ldw	r2,-20(fp)
 d0111e0:	10c00117 	ldw	r3,4(r2)
 d0111e4:	e0bffc17 	ldw	r2,-16(fp)
 d0111e8:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 d0111ec:	e0bffc17 	ldw	r2,-16(fp)
 d0111f0:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 d0111f4:	e0fffc17 	ldw	r3,-16(fp)
 d0111f8:	e0bffb17 	ldw	r2,-20(fp)
 d0111fc:	18800315 	stw	r2,12(r3)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 d011200:	e0bffb17 	ldw	r2,-20(fp)
 d011204:	10800117 	ldw	r2,4(r2)
 d011208:	e0bffa15 	stw	r2,-24(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 d01120c:	e0bffa17 	ldw	r2,-24(fp)
 d011210:	1005003a 	cmpeq	r2,r2,zero
 d011214:	1000031e 	bne	r2,zero,d011224 <OS_FlagBlock+0xf4>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 d011218:	e0fffa17 	ldw	r3,-24(fp)
 d01121c:	e0bffc17 	ldw	r2,-16(fp)
 d011220:	18800115 	stw	r2,4(r3)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 d011224:	e0fffb17 	ldw	r3,-20(fp)
 d011228:	e0bffc17 	ldw	r2,-16(fp)
 d01122c:	18800115 	stw	r2,4(r3)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 d011230:	00834174 	movhi	r2,3333
 d011234:	109b1804 	addi	r2,r2,27744
 d011238:	10800017 	ldw	r2,0(r2)
 d01123c:	10800d03 	ldbu	r2,52(r2)
 d011240:	e0bff905 	stb	r2,-28(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 d011244:	e13ff903 	ldbu	r4,-28(fp)
 d011248:	e0fff903 	ldbu	r3,-28(fp)
 d01124c:	00834174 	movhi	r2,3333
 d011250:	109b1544 	addi	r2,r2,27733
 d011254:	10c5883a 	add	r2,r2,r3
 d011258:	10800003 	ldbu	r2,0(r2)
 d01125c:	1007883a 	mov	r3,r2
 d011260:	00834174 	movhi	r2,3333
 d011264:	109b1804 	addi	r2,r2,27744
 d011268:	10800017 	ldw	r2,0(r2)
 d01126c:	10800d43 	ldbu	r2,53(r2)
 d011270:	0084303a 	nor	r2,zero,r2
 d011274:	1884703a 	and	r2,r3,r2
 d011278:	1007883a 	mov	r3,r2
 d01127c:	00834174 	movhi	r2,3333
 d011280:	109b1544 	addi	r2,r2,27733
 d011284:	1105883a 	add	r2,r2,r4
 d011288:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 d01128c:	e0fff903 	ldbu	r3,-28(fp)
 d011290:	00834174 	movhi	r2,3333
 d011294:	109b1544 	addi	r2,r2,27733
 d011298:	10c5883a 	add	r2,r2,r3
 d01129c:	10800003 	ldbu	r2,0(r2)
 d0112a0:	10803fcc 	andi	r2,r2,255
 d0112a4:	1004c03a 	cmpne	r2,r2,zero
 d0112a8:	10000e1e 	bne	r2,zero,d0112e4 <OS_FlagBlock+0x1b4>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 d0112ac:	00834174 	movhi	r2,3333
 d0112b0:	109b1804 	addi	r2,r2,27744
 d0112b4:	10800017 	ldw	r2,0(r2)
 d0112b8:	10800d83 	ldbu	r2,54(r2)
 d0112bc:	0084303a 	nor	r2,zero,r2
 d0112c0:	1007883a 	mov	r3,r2
 d0112c4:	00834174 	movhi	r2,3333
 d0112c8:	109b1504 	addi	r2,r2,27732
 d0112cc:	10800003 	ldbu	r2,0(r2)
 d0112d0:	1884703a 	and	r2,r3,r2
 d0112d4:	1007883a 	mov	r3,r2
 d0112d8:	00834174 	movhi	r2,3333
 d0112dc:	109b1504 	addi	r2,r2,27732
 d0112e0:	10c00005 	stb	r3,0(r2)
    }
}
 d0112e4:	e037883a 	mov	sp,fp
 d0112e8:	df000017 	ldw	fp,0(sp)
 d0112ec:	dec00104 	addi	sp,sp,4
 d0112f0:	f800283a 	ret

0d0112f4 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 d0112f4:	defffb04 	addi	sp,sp,-20
 d0112f8:	dfc00415 	stw	ra,16(sp)
 d0112fc:	df000315 	stw	fp,12(sp)
 d011300:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 d011304:	010341b4 	movhi	r4,3334
 d011308:	21353c04 	addi	r4,r4,-11024
 d01130c:	0140dc04 	movi	r5,880
 d011310:	d00f3240 	call	d00f324 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 d011314:	008341b4 	movhi	r2,3334
 d011318:	10b53c04 	addi	r2,r2,-11024
 d01131c:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 d011320:	008341b4 	movhi	r2,3334
 d011324:	10b54704 	addi	r2,r2,-10980
 d011328:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 d01132c:	e03fff0d 	sth	zero,-4(fp)
 d011330:	00001306 	br	d011380 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d011334:	e0bffe17 	ldw	r2,-8(fp)
 d011338:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 d01133c:	e0fffe17 	ldw	r3,-8(fp)
 d011340:	e0bffd17 	ldw	r2,-12(fp)
 d011344:	18800115 	stw	r2,4(r3)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 d011348:	e0fffe17 	ldw	r3,-8(fp)
 d01134c:	00800fc4 	movi	r2,63
 d011350:	18800285 	stb	r2,10(r3)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 d011354:	e0bffe17 	ldw	r2,-8(fp)
 d011358:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 d01135c:	e0bffe17 	ldw	r2,-8(fp)
 d011360:	10800b04 	addi	r2,r2,44
 d011364:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 d011368:	e0bffd17 	ldw	r2,-12(fp)
 d01136c:	10800b04 	addi	r2,r2,44
 d011370:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 d011374:	e0bfff0b 	ldhu	r2,-4(fp)
 d011378:	10800044 	addi	r2,r2,1
 d01137c:	e0bfff0d 	sth	r2,-4(fp)
 d011380:	e0bfff0b 	ldhu	r2,-4(fp)
 d011384:	108004f0 	cmpltui	r2,r2,19
 d011388:	103fea1e 	bne	r2,zero,d011334 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d01138c:	e0bffe17 	ldw	r2,-8(fp)
 d011390:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 d011394:	e0bffe17 	ldw	r2,-8(fp)
 d011398:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 d01139c:	e0fffe17 	ldw	r3,-8(fp)
 d0113a0:	00800fc4 	movi	r2,63
 d0113a4:	18800285 	stb	r2,10(r3)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 d0113a8:	e0bffe17 	ldw	r2,-8(fp)
 d0113ac:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 d0113b0:	00c34174 	movhi	r3,3333
 d0113b4:	18db1a04 	addi	r3,r3,27752
 d0113b8:	008341b4 	movhi	r2,3334
 d0113bc:	10b53c04 	addi	r2,r2,-11024
 d0113c0:	18800015 	stw	r2,0(r3)
#endif
}
 d0113c4:	e037883a 	mov	sp,fp
 d0113c8:	dfc00117 	ldw	ra,4(sp)
 d0113cc:	df000017 	ldw	fp,0(sp)
 d0113d0:	dec00204 	addi	sp,sp,8
 d0113d4:	f800283a 	ret

0d0113d8 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 d0113d8:	defffa04 	addi	sp,sp,-24
 d0113dc:	dfc00515 	stw	ra,20(sp)
 d0113e0:	df000415 	stw	fp,16(sp)
 d0113e4:	df000404 	addi	fp,sp,16
 d0113e8:	e13ffe15 	stw	r4,-8(fp)
 d0113ec:	e17fff0d 	sth	r5,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 d0113f0:	e0bffe17 	ldw	r2,-8(fp)
 d0113f4:	10800217 	ldw	r2,8(r2)
 d0113f8:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 d0113fc:	e0bffd17 	ldw	r2,-12(fp)
 d011400:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 d011404:	e0fffd17 	ldw	r3,-12(fp)
 d011408:	e0bfff0b 	ldhu	r2,-4(fp)
 d01140c:	18800b0d 	sth	r2,44(r3)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 d011410:	e0bffd17 	ldw	r2,-12(fp)
 d011414:	10c00c03 	ldbu	r3,48(r2)
 d011418:	00bff7c4 	movi	r2,-33
 d01141c:	1884703a 	and	r2,r3,r2
 d011420:	1007883a 	mov	r3,r2
 d011424:	e0bffd17 	ldw	r2,-12(fp)
 d011428:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 d01142c:	e0bffd17 	ldw	r2,-12(fp)
 d011430:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 d011434:	e0bffd17 	ldw	r2,-12(fp)
 d011438:	10800c03 	ldbu	r2,48(r2)
 d01143c:	10803fcc 	andi	r2,r2,255
 d011440:	1004c03a 	cmpne	r2,r2,zero
 d011444:	10001f1e 	bne	r2,zero,d0114c4 <OS_FlagTaskRdy+0xec>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 d011448:	e0bffd17 	ldw	r2,-12(fp)
 d01144c:	10c00d83 	ldbu	r3,54(r2)
 d011450:	00834174 	movhi	r2,3333
 d011454:	109b1504 	addi	r2,r2,27732
 d011458:	10800003 	ldbu	r2,0(r2)
 d01145c:	1884b03a 	or	r2,r3,r2
 d011460:	1007883a 	mov	r3,r2
 d011464:	00834174 	movhi	r2,3333
 d011468:	109b1504 	addi	r2,r2,27732
 d01146c:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d011470:	e0bffd17 	ldw	r2,-12(fp)
 d011474:	10800d03 	ldbu	r2,52(r2)
 d011478:	11003fcc 	andi	r4,r2,255
 d01147c:	e0bffd17 	ldw	r2,-12(fp)
 d011480:	10800d03 	ldbu	r2,52(r2)
 d011484:	10c03fcc 	andi	r3,r2,255
 d011488:	00834174 	movhi	r2,3333
 d01148c:	109b1544 	addi	r2,r2,27733
 d011490:	10c5883a 	add	r2,r2,r3
 d011494:	10c00003 	ldbu	r3,0(r2)
 d011498:	e0bffd17 	ldw	r2,-12(fp)
 d01149c:	10800d43 	ldbu	r2,53(r2)
 d0114a0:	1884b03a 	or	r2,r3,r2
 d0114a4:	1007883a 	mov	r3,r2
 d0114a8:	00834174 	movhi	r2,3333
 d0114ac:	109b1544 	addi	r2,r2,27733
 d0114b0:	1105883a 	add	r2,r2,r4
 d0114b4:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
 d0114b8:	00800044 	movi	r2,1
 d0114bc:	e0bffc05 	stb	r2,-16(fp)
 d0114c0:	00000106 	br	d0114c8 <OS_FlagTaskRdy+0xf0>
    } else {
        sched                   = OS_FALSE;
 d0114c4:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 d0114c8:	e13ffe17 	ldw	r4,-8(fp)
 d0114cc:	d0114e80 	call	d0114e8 <OS_FlagUnlink>
    return (sched);
 d0114d0:	e0bffc03 	ldbu	r2,-16(fp)
}
 d0114d4:	e037883a 	mov	sp,fp
 d0114d8:	dfc00117 	ldw	ra,4(sp)
 d0114dc:	df000017 	ldw	fp,0(sp)
 d0114e0:	dec00204 	addi	sp,sp,8
 d0114e4:	f800283a 	ret

0d0114e8 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 d0114e8:	defffa04 	addi	sp,sp,-24
 d0114ec:	df000515 	stw	fp,20(sp)
 d0114f0:	df000504 	addi	fp,sp,20
 d0114f4:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 d0114f8:	e0bfff17 	ldw	r2,-4(fp)
 d0114fc:	10800117 	ldw	r2,4(r2)
 d011500:	e0bffc15 	stw	r2,-16(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 d011504:	e0bfff17 	ldw	r2,-4(fp)
 d011508:	10800017 	ldw	r2,0(r2)
 d01150c:	e0bffb15 	stw	r2,-20(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 d011510:	e0bffc17 	ldw	r2,-16(fp)
 d011514:	1004c03a 	cmpne	r2,r2,zero
 d011518:	10000c1e 	bne	r2,zero,d01154c <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 d01151c:	e0bfff17 	ldw	r2,-4(fp)
 d011520:	10800317 	ldw	r2,12(r2)
 d011524:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 d011528:	e0fffd17 	ldw	r3,-12(fp)
 d01152c:	e0bffb17 	ldw	r2,-20(fp)
 d011530:	18800115 	stw	r2,4(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 d011534:	e0bffb17 	ldw	r2,-20(fp)
 d011538:	1005003a 	cmpeq	r2,r2,zero
 d01153c:	10000c1e 	bne	r2,zero,d011570 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 d011540:	e0bffb17 	ldw	r2,-20(fp)
 d011544:	10000115 	stw	zero,4(r2)
 d011548:	00000906 	br	d011570 <OS_FlagUnlink+0x88>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 d01154c:	e0fffc17 	ldw	r3,-16(fp)
 d011550:	e0bffb17 	ldw	r2,-20(fp)
 d011554:	18800015 	stw	r2,0(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 d011558:	e0bffb17 	ldw	r2,-20(fp)
 d01155c:	1005003a 	cmpeq	r2,r2,zero
 d011560:	1000031e 	bne	r2,zero,d011570 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 d011564:	e0fffb17 	ldw	r3,-20(fp)
 d011568:	e0bffc17 	ldw	r2,-16(fp)
 d01156c:	18800115 	stw	r2,4(r3)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 d011570:	e0bfff17 	ldw	r2,-4(fp)
 d011574:	10800217 	ldw	r2,8(r2)
 d011578:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 d01157c:	e0bffe17 	ldw	r2,-8(fp)
 d011580:	10000a15 	stw	zero,40(r2)
#endif
}
 d011584:	e037883a 	mov	sp,fp
 d011588:	df000017 	ldw	fp,0(sp)
 d01158c:	dec00104 	addi	sp,sp,4
 d011590:	f800283a 	ret

0d011594 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 d011594:	defff304 	addi	sp,sp,-52
 d011598:	df000c15 	stw	fp,48(sp)
 d01159c:	df000c04 	addi	fp,sp,48
 d0115a0:	e13ffb15 	stw	r4,-20(fp)
 d0115a4:	e17ffc15 	stw	r5,-16(fp)
 d0115a8:	e1bffd15 	stw	r6,-12(fp)
 d0115ac:	e1fffe15 	stw	r7,-8(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0115b0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d0115b4:	e0bffe17 	ldw	r2,-8(fp)
 d0115b8:	1004c03a 	cmpne	r2,r2,zero
 d0115bc:	1000021e 	bne	r2,zero,d0115c8 <OSMemCreate+0x34>
        return ((OS_MEM *)0);
 d0115c0:	e03fff15 	stw	zero,-4(fp)
 d0115c4:	00007506 	br	d01179c <OSMemCreate+0x208>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 d0115c8:	e0bffb17 	ldw	r2,-20(fp)
 d0115cc:	1004c03a 	cmpne	r2,r2,zero
 d0115d0:	1000051e 	bne	r2,zero,d0115e8 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 d0115d4:	e0fffe17 	ldw	r3,-8(fp)
 d0115d8:	00801884 	movi	r2,98
 d0115dc:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d0115e0:	e03fff15 	stw	zero,-4(fp)
 d0115e4:	00006d06 	br	d01179c <OSMemCreate+0x208>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 d0115e8:	e0bffb17 	ldw	r2,-20(fp)
 d0115ec:	108000cc 	andi	r2,r2,3
 d0115f0:	1005003a 	cmpeq	r2,r2,zero
 d0115f4:	1000051e 	bne	r2,zero,d01160c <OSMemCreate+0x78>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 d0115f8:	e0fffe17 	ldw	r3,-8(fp)
 d0115fc:	00801884 	movi	r2,98
 d011600:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d011604:	e03fff15 	stw	zero,-4(fp)
 d011608:	00006406 	br	d01179c <OSMemCreate+0x208>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 d01160c:	e0bffc17 	ldw	r2,-16(fp)
 d011610:	108000a8 	cmpgeui	r2,r2,2
 d011614:	1000051e 	bne	r2,zero,d01162c <OSMemCreate+0x98>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 d011618:	e0fffe17 	ldw	r3,-8(fp)
 d01161c:	008016c4 	movi	r2,91
 d011620:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d011624:	e03fff15 	stw	zero,-4(fp)
 d011628:	00005c06 	br	d01179c <OSMemCreate+0x208>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 d01162c:	e0bffd17 	ldw	r2,-12(fp)
 d011630:	10800128 	cmpgeui	r2,r2,4
 d011634:	1000051e 	bne	r2,zero,d01164c <OSMemCreate+0xb8>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 d011638:	e0fffe17 	ldw	r3,-8(fp)
 d01163c:	00801704 	movi	r2,92
 d011640:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d011644:	e03fff15 	stw	zero,-4(fp)
 d011648:	00005406 	br	d01179c <OSMemCreate+0x208>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01164c:	0005303a 	rdctl	r2,status
 d011650:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011654:	e0fff517 	ldw	r3,-44(fp)
 d011658:	00bfff84 	movi	r2,-2
 d01165c:	1884703a 	and	r2,r3,r2
 d011660:	1001703a 	wrctl	status,r2
  
  return context;
 d011664:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011668:	e0bff615 	stw	r2,-40(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 d01166c:	00834174 	movhi	r2,3333
 d011670:	109b1204 	addi	r2,r2,27720
 d011674:	10800017 	ldw	r2,0(r2)
 d011678:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 d01167c:	00834174 	movhi	r2,3333
 d011680:	109b1204 	addi	r2,r2,27720
 d011684:	10800017 	ldw	r2,0(r2)
 d011688:	1005003a 	cmpeq	r2,r2,zero
 d01168c:	1000081e 	bne	r2,zero,d0116b0 <OSMemCreate+0x11c>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 d011690:	00834174 	movhi	r2,3333
 d011694:	109b1204 	addi	r2,r2,27720
 d011698:	10800017 	ldw	r2,0(r2)
 d01169c:	10800117 	ldw	r2,4(r2)
 d0116a0:	1007883a 	mov	r3,r2
 d0116a4:	00834174 	movhi	r2,3333
 d0116a8:	109b1204 	addi	r2,r2,27720
 d0116ac:	10c00015 	stw	r3,0(r2)
 d0116b0:	e0bff617 	ldw	r2,-40(fp)
 d0116b4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0116b8:	e0bff417 	ldw	r2,-48(fp)
 d0116bc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 d0116c0:	e0bffa17 	ldw	r2,-24(fp)
 d0116c4:	1004c03a 	cmpne	r2,r2,zero
 d0116c8:	1000051e 	bne	r2,zero,d0116e0 <OSMemCreate+0x14c>
        *perr = OS_ERR_MEM_INVALID_PART;
 d0116cc:	e0fffe17 	ldw	r3,-8(fp)
 d0116d0:	00801684 	movi	r2,90
 d0116d4:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d0116d8:	e03fff15 	stw	zero,-4(fp)
 d0116dc:	00002f06 	br	d01179c <OSMemCreate+0x208>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 d0116e0:	e0bffb17 	ldw	r2,-20(fp)
 d0116e4:	e0bff815 	stw	r2,-32(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 d0116e8:	e0bffb17 	ldw	r2,-20(fp)
 d0116ec:	1007883a 	mov	r3,r2
 d0116f0:	e0bffd17 	ldw	r2,-12(fp)
 d0116f4:	1885883a 	add	r2,r3,r2
 d0116f8:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < (nblks - 1); i++) {
 d0116fc:	e03ff715 	stw	zero,-36(fp)
 d011700:	00000d06 	br	d011738 <OSMemCreate+0x1a4>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 d011704:	e0fff817 	ldw	r3,-32(fp)
 d011708:	e0bff917 	ldw	r2,-28(fp)
 d01170c:	18800015 	stw	r2,0(r3)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 d011710:	e0bff917 	ldw	r2,-28(fp)
 d011714:	e0bff815 	stw	r2,-32(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 d011718:	e0bff917 	ldw	r2,-28(fp)
 d01171c:	1007883a 	mov	r3,r2
 d011720:	e0bffd17 	ldw	r2,-12(fp)
 d011724:	1885883a 	add	r2,r3,r2
 d011728:	e0bff915 	stw	r2,-28(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 d01172c:	e0bff717 	ldw	r2,-36(fp)
 d011730:	10800044 	addi	r2,r2,1
 d011734:	e0bff715 	stw	r2,-36(fp)
 d011738:	e0bffc17 	ldw	r2,-16(fp)
 d01173c:	10ffffc4 	addi	r3,r2,-1
 d011740:	e0bff717 	ldw	r2,-36(fp)
 d011744:	10ffef36 	bltu	r2,r3,d011704 <OSMemCreate+0x170>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 d011748:	e0bff817 	ldw	r2,-32(fp)
 d01174c:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 d011750:	e0fffa17 	ldw	r3,-24(fp)
 d011754:	e0bffb17 	ldw	r2,-20(fp)
 d011758:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 d01175c:	e0fffa17 	ldw	r3,-24(fp)
 d011760:	e0bffb17 	ldw	r2,-20(fp)
 d011764:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 d011768:	e0fffa17 	ldw	r3,-24(fp)
 d01176c:	e0bffc17 	ldw	r2,-16(fp)
 d011770:	18800415 	stw	r2,16(r3)
    pmem->OSMemNBlks    = nblks;
 d011774:	e0fffa17 	ldw	r3,-24(fp)
 d011778:	e0bffc17 	ldw	r2,-16(fp)
 d01177c:	18800315 	stw	r2,12(r3)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 d011780:	e0fffa17 	ldw	r3,-24(fp)
 d011784:	e0bffd17 	ldw	r2,-12(fp)
 d011788:	18800215 	stw	r2,8(r3)
    *perr               = OS_ERR_NONE;
 d01178c:	e0bffe17 	ldw	r2,-8(fp)
 d011790:	10000005 	stb	zero,0(r2)
    return (pmem);
 d011794:	e0bffa17 	ldw	r2,-24(fp)
 d011798:	e0bfff15 	stw	r2,-4(fp)
 d01179c:	e0bfff17 	ldw	r2,-4(fp)
}
 d0117a0:	e037883a 	mov	sp,fp
 d0117a4:	df000017 	ldw	fp,0(sp)
 d0117a8:	dec00104 	addi	sp,sp,4
 d0117ac:	f800283a 	ret

0d0117b0 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 d0117b0:	defff704 	addi	sp,sp,-36
 d0117b4:	df000815 	stw	fp,32(sp)
 d0117b8:	df000804 	addi	fp,sp,32
 d0117bc:	e13ffd15 	stw	r4,-12(fp)
 d0117c0:	e17ffe15 	stw	r5,-8(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0117c4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d0117c8:	e0bffe17 	ldw	r2,-8(fp)
 d0117cc:	1004c03a 	cmpne	r2,r2,zero
 d0117d0:	1000021e 	bne	r2,zero,d0117dc <OSMemGet+0x2c>
        return ((void *)0);
 d0117d4:	e03fff15 	stw	zero,-4(fp)
 d0117d8:	00003106 	br	d0118a0 <OSMemGet+0xf0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 d0117dc:	e0bffd17 	ldw	r2,-12(fp)
 d0117e0:	1004c03a 	cmpne	r2,r2,zero
 d0117e4:	1000051e 	bne	r2,zero,d0117fc <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 d0117e8:	e0fffe17 	ldw	r3,-8(fp)
 d0117ec:	00801804 	movi	r2,96
 d0117f0:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d0117f4:	e03fff15 	stw	zero,-4(fp)
 d0117f8:	00002906 	br	d0118a0 <OSMemGet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0117fc:	0005303a 	rdctl	r2,status
 d011800:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011804:	e0fffa17 	ldw	r3,-24(fp)
 d011808:	00bfff84 	movi	r2,-2
 d01180c:	1884703a 	and	r2,r3,r2
 d011810:	1001703a 	wrctl	status,r2
  
  return context;
 d011814:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011818:	e0bffb15 	stw	r2,-20(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 d01181c:	e0bffd17 	ldw	r2,-12(fp)
 d011820:	10800417 	ldw	r2,16(r2)
 d011824:	1005003a 	cmpeq	r2,r2,zero
 d011828:	1000151e 	bne	r2,zero,d011880 <OSMemGet+0xd0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 d01182c:	e0bffd17 	ldw	r2,-12(fp)
 d011830:	10800117 	ldw	r2,4(r2)
 d011834:	e0bffc15 	stw	r2,-16(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 d011838:	e0bffc17 	ldw	r2,-16(fp)
 d01183c:	10c00017 	ldw	r3,0(r2)
 d011840:	e0bffd17 	ldw	r2,-12(fp)
 d011844:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 d011848:	e0bffd17 	ldw	r2,-12(fp)
 d01184c:	10800417 	ldw	r2,16(r2)
 d011850:	10ffffc4 	addi	r3,r2,-1
 d011854:	e0bffd17 	ldw	r2,-12(fp)
 d011858:	10c00415 	stw	r3,16(r2)
 d01185c:	e0bffb17 	ldw	r2,-20(fp)
 d011860:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011864:	e0bff917 	ldw	r2,-28(fp)
 d011868:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 d01186c:	e0bffe17 	ldw	r2,-8(fp)
 d011870:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 d011874:	e0bffc17 	ldw	r2,-16(fp)
 d011878:	e0bfff15 	stw	r2,-4(fp)
 d01187c:	00000806 	br	d0118a0 <OSMemGet+0xf0>
 d011880:	e0bffb17 	ldw	r2,-20(fp)
 d011884:	e0bff815 	stw	r2,-32(fp)
 d011888:	e0bff817 	ldw	r2,-32(fp)
 d01188c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 d011890:	e0fffe17 	ldw	r3,-8(fp)
 d011894:	00801744 	movi	r2,93
 d011898:	18800005 	stb	r2,0(r3)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 d01189c:	e03fff15 	stw	zero,-4(fp)
 d0118a0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0118a4:	e037883a 	mov	sp,fp
 d0118a8:	df000017 	ldw	fp,0(sp)
 d0118ac:	dec00104 	addi	sp,sp,4
 d0118b0:	f800283a 	ret

0d0118b4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 d0118b4:	defff604 	addi	sp,sp,-40
 d0118b8:	dfc00915 	stw	ra,36(sp)
 d0118bc:	df000815 	stw	fp,32(sp)
 d0118c0:	df000804 	addi	fp,sp,32
 d0118c4:	e13ffc15 	stw	r4,-16(fp)
 d0118c8:	e17ffd15 	stw	r5,-12(fp)
 d0118cc:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0118d0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0118d4:	e0bffe17 	ldw	r2,-8(fp)
 d0118d8:	1004c03a 	cmpne	r2,r2,zero
 d0118dc:	1000021e 	bne	r2,zero,d0118e8 <OSMemNameGet+0x34>
        return (0);
 d0118e0:	e03fff15 	stw	zero,-4(fp)
 d0118e4:	00003006 	br	d0119a8 <OSMemNameGet+0xf4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 d0118e8:	e0bffc17 	ldw	r2,-16(fp)
 d0118ec:	1004c03a 	cmpne	r2,r2,zero
 d0118f0:	1000051e 	bne	r2,zero,d011908 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 d0118f4:	e0fffe17 	ldw	r3,-8(fp)
 d0118f8:	00801804 	movi	r2,96
 d0118fc:	18800005 	stb	r2,0(r3)
        return (0);
 d011900:	e03fff15 	stw	zero,-4(fp)
 d011904:	00002806 	br	d0119a8 <OSMemNameGet+0xf4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d011908:	e0bffd17 	ldw	r2,-12(fp)
 d01190c:	1004c03a 	cmpne	r2,r2,zero
 d011910:	1000051e 	bne	r2,zero,d011928 <OSMemNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 d011914:	e0fffe17 	ldw	r3,-8(fp)
 d011918:	00800304 	movi	r2,12
 d01191c:	18800005 	stb	r2,0(r3)
        return (0);
 d011920:	e03fff15 	stw	zero,-4(fp)
 d011924:	00002006 	br	d0119a8 <OSMemNameGet+0xf4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d011928:	00834174 	movhi	r2,3333
 d01192c:	109b1704 	addi	r2,r2,27740
 d011930:	10800003 	ldbu	r2,0(r2)
 d011934:	10803fcc 	andi	r2,r2,255
 d011938:	1005003a 	cmpeq	r2,r2,zero
 d01193c:	1000051e 	bne	r2,zero,d011954 <OSMemNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 d011940:	e0fffe17 	ldw	r3,-8(fp)
 d011944:	00800444 	movi	r2,17
 d011948:	18800005 	stb	r2,0(r3)
        return (0);
 d01194c:	e03fff15 	stw	zero,-4(fp)
 d011950:	00001506 	br	d0119a8 <OSMemNameGet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011954:	0005303a 	rdctl	r2,status
 d011958:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01195c:	e0fff917 	ldw	r3,-28(fp)
 d011960:	00bfff84 	movi	r2,-2
 d011964:	1884703a 	and	r2,r3,r2
 d011968:	1001703a 	wrctl	status,r2
  
  return context;
 d01196c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d011970:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 d011974:	e0bffc17 	ldw	r2,-16(fp)
 d011978:	11400504 	addi	r5,r2,20
 d01197c:	e13ffd17 	ldw	r4,-12(fp)
 d011980:	d00f5280 	call	d00f528 <OS_StrCopy>
 d011984:	e0bffb05 	stb	r2,-20(fp)
 d011988:	e0bffa17 	ldw	r2,-24(fp)
 d01198c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011990:	e0bff817 	ldw	r2,-32(fp)
 d011994:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d011998:	e0bffe17 	ldw	r2,-8(fp)
 d01199c:	10000005 	stb	zero,0(r2)
    return (len);
 d0119a0:	e0bffb03 	ldbu	r2,-20(fp)
 d0119a4:	e0bfff15 	stw	r2,-4(fp)
 d0119a8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0119ac:	e037883a 	mov	sp,fp
 d0119b0:	dfc00117 	ldw	ra,4(sp)
 d0119b4:	df000017 	ldw	fp,0(sp)
 d0119b8:	dec00204 	addi	sp,sp,8
 d0119bc:	f800283a 	ret

0d0119c0 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 d0119c0:	defff604 	addi	sp,sp,-40
 d0119c4:	dfc00915 	stw	ra,36(sp)
 d0119c8:	df000815 	stw	fp,32(sp)
 d0119cc:	df000804 	addi	fp,sp,32
 d0119d0:	e13ffd15 	stw	r4,-12(fp)
 d0119d4:	e17ffe15 	stw	r5,-8(fp)
 d0119d8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0119dc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0119e0:	e0bfff17 	ldw	r2,-4(fp)
 d0119e4:	1005003a 	cmpeq	r2,r2,zero
 d0119e8:	1000381e 	bne	r2,zero,d011acc <OSMemNameSet+0x10c>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 d0119ec:	e0bffd17 	ldw	r2,-12(fp)
 d0119f0:	1004c03a 	cmpne	r2,r2,zero
 d0119f4:	1000041e 	bne	r2,zero,d011a08 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 d0119f8:	e0ffff17 	ldw	r3,-4(fp)
 d0119fc:	00801804 	movi	r2,96
 d011a00:	18800005 	stb	r2,0(r3)
        return;
 d011a04:	00003106 	br	d011acc <OSMemNameSet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d011a08:	e0bffe17 	ldw	r2,-8(fp)
 d011a0c:	1004c03a 	cmpne	r2,r2,zero
 d011a10:	1000041e 	bne	r2,zero,d011a24 <OSMemNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 d011a14:	e0ffff17 	ldw	r3,-4(fp)
 d011a18:	00800304 	movi	r2,12
 d011a1c:	18800005 	stb	r2,0(r3)
        return;
 d011a20:	00002a06 	br	d011acc <OSMemNameSet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d011a24:	00834174 	movhi	r2,3333
 d011a28:	109b1704 	addi	r2,r2,27740
 d011a2c:	10800003 	ldbu	r2,0(r2)
 d011a30:	10803fcc 	andi	r2,r2,255
 d011a34:	1005003a 	cmpeq	r2,r2,zero
 d011a38:	1000041e 	bne	r2,zero,d011a4c <OSMemNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 d011a3c:	e0ffff17 	ldw	r3,-4(fp)
 d011a40:	00800484 	movi	r2,18
 d011a44:	18800005 	stb	r2,0(r3)
        return;
 d011a48:	00002006 	br	d011acc <OSMemNameSet+0x10c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011a4c:	0005303a 	rdctl	r2,status
 d011a50:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011a54:	e0fffa17 	ldw	r3,-24(fp)
 d011a58:	00bfff84 	movi	r2,-2
 d011a5c:	1884703a 	and	r2,r3,r2
 d011a60:	1001703a 	wrctl	status,r2
  
  return context;
 d011a64:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d011a68:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 d011a6c:	e13ffe17 	ldw	r4,-8(fp)
 d011a70:	d00f5a80 	call	d00f5a8 <OS_StrLen>
 d011a74:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 d011a78:	e0bffc03 	ldbu	r2,-16(fp)
 d011a7c:	10800830 	cmpltui	r2,r2,32
 d011a80:	1000081e 	bne	r2,zero,d011aa4 <OSMemNameSet+0xe4>
 d011a84:	e0bffb17 	ldw	r2,-20(fp)
 d011a88:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011a8c:	e0bff917 	ldw	r2,-28(fp)
 d011a90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 d011a94:	e0ffff17 	ldw	r3,-4(fp)
 d011a98:	008018c4 	movi	r2,99
 d011a9c:	18800005 	stb	r2,0(r3)
        return;
 d011aa0:	00000a06 	br	d011acc <OSMemNameSet+0x10c>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 d011aa4:	e0bffd17 	ldw	r2,-12(fp)
 d011aa8:	11000504 	addi	r4,r2,20
 d011aac:	e17ffe17 	ldw	r5,-8(fp)
 d011ab0:	d00f5280 	call	d00f528 <OS_StrCopy>
 d011ab4:	e0bffb17 	ldw	r2,-20(fp)
 d011ab8:	e0bff815 	stw	r2,-32(fp)
 d011abc:	e0bff817 	ldw	r2,-32(fp)
 d011ac0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d011ac4:	e0bfff17 	ldw	r2,-4(fp)
 d011ac8:	10000005 	stb	zero,0(r2)
}
 d011acc:	e037883a 	mov	sp,fp
 d011ad0:	dfc00117 	ldw	ra,4(sp)
 d011ad4:	df000017 	ldw	fp,0(sp)
 d011ad8:	dec00204 	addi	sp,sp,8
 d011adc:	f800283a 	ret

0d011ae0 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 d011ae0:	defff804 	addi	sp,sp,-32
 d011ae4:	df000715 	stw	fp,28(sp)
 d011ae8:	df000704 	addi	fp,sp,28
 d011aec:	e13ffd15 	stw	r4,-12(fp)
 d011af0:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d011af4:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 d011af8:	e0bffd17 	ldw	r2,-12(fp)
 d011afc:	1004c03a 	cmpne	r2,r2,zero
 d011b00:	1000031e 	bne	r2,zero,d011b10 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 d011b04:	00801804 	movi	r2,96
 d011b08:	e0bfff15 	stw	r2,-4(fp)
 d011b0c:	00002b06 	br	d011bbc <OSMemPut+0xdc>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 d011b10:	e0bffe17 	ldw	r2,-8(fp)
 d011b14:	1004c03a 	cmpne	r2,r2,zero
 d011b18:	1000031e 	bne	r2,zero,d011b28 <OSMemPut+0x48>
        return (OS_ERR_MEM_INVALID_PBLK);
 d011b1c:	008017c4 	movi	r2,95
 d011b20:	e0bfff15 	stw	r2,-4(fp)
 d011b24:	00002506 	br	d011bbc <OSMemPut+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011b28:	0005303a 	rdctl	r2,status
 d011b2c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011b30:	e0fffb17 	ldw	r3,-20(fp)
 d011b34:	00bfff84 	movi	r2,-2
 d011b38:	1884703a 	and	r2,r3,r2
 d011b3c:	1001703a 	wrctl	status,r2
  
  return context;
 d011b40:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011b44:	e0bffc15 	stw	r2,-16(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 d011b48:	e0bffd17 	ldw	r2,-12(fp)
 d011b4c:	10c00417 	ldw	r3,16(r2)
 d011b50:	e0bffd17 	ldw	r2,-12(fp)
 d011b54:	10800317 	ldw	r2,12(r2)
 d011b58:	18800736 	bltu	r3,r2,d011b78 <OSMemPut+0x98>
 d011b5c:	e0bffc17 	ldw	r2,-16(fp)
 d011b60:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011b64:	e0bffa17 	ldw	r2,-24(fp)
 d011b68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 d011b6c:	00801784 	movi	r2,94
 d011b70:	e0bfff15 	stw	r2,-4(fp)
 d011b74:	00001106 	br	d011bbc <OSMemPut+0xdc>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 d011b78:	e0fffe17 	ldw	r3,-8(fp)
 d011b7c:	e0bffd17 	ldw	r2,-12(fp)
 d011b80:	10800117 	ldw	r2,4(r2)
 d011b84:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = pblk;
 d011b88:	e0fffd17 	ldw	r3,-12(fp)
 d011b8c:	e0bffe17 	ldw	r2,-8(fp)
 d011b90:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 d011b94:	e0bffd17 	ldw	r2,-12(fp)
 d011b98:	10800417 	ldw	r2,16(r2)
 d011b9c:	10c00044 	addi	r3,r2,1
 d011ba0:	e0bffd17 	ldw	r2,-12(fp)
 d011ba4:	10c00415 	stw	r3,16(r2)
 d011ba8:	e0bffc17 	ldw	r2,-16(fp)
 d011bac:	e0bff915 	stw	r2,-28(fp)
 d011bb0:	e0bff917 	ldw	r2,-28(fp)
 d011bb4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 d011bb8:	e03fff15 	stw	zero,-4(fp)
 d011bbc:	e0bfff17 	ldw	r2,-4(fp)
}
 d011bc0:	e037883a 	mov	sp,fp
 d011bc4:	df000017 	ldw	fp,0(sp)
 d011bc8:	dec00104 	addi	sp,sp,4
 d011bcc:	f800283a 	ret

0d011bd0 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 d011bd0:	defff904 	addi	sp,sp,-28
 d011bd4:	df000615 	stw	fp,24(sp)
 d011bd8:	df000604 	addi	fp,sp,24
 d011bdc:	e13ffd15 	stw	r4,-12(fp)
 d011be0:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d011be4:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 d011be8:	e0bffd17 	ldw	r2,-12(fp)
 d011bec:	1004c03a 	cmpne	r2,r2,zero
 d011bf0:	1000031e 	bne	r2,zero,d011c00 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 d011bf4:	00801804 	movi	r2,96
 d011bf8:	e0bfff15 	stw	r2,-4(fp)
 d011bfc:	00002e06 	br	d011cb8 <OSMemQuery+0xe8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 d011c00:	e0bffe17 	ldw	r2,-8(fp)
 d011c04:	1004c03a 	cmpne	r2,r2,zero
 d011c08:	1000031e 	bne	r2,zero,d011c18 <OSMemQuery+0x48>
        return (OS_ERR_MEM_INVALID_PDATA);
 d011c0c:	00801844 	movi	r2,97
 d011c10:	e0bfff15 	stw	r2,-4(fp)
 d011c14:	00002806 	br	d011cb8 <OSMemQuery+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011c18:	0005303a 	rdctl	r2,status
 d011c1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011c20:	e0fffb17 	ldw	r3,-20(fp)
 d011c24:	00bfff84 	movi	r2,-2
 d011c28:	1884703a 	and	r2,r3,r2
 d011c2c:	1001703a 	wrctl	status,r2
  
  return context;
 d011c30:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011c34:	e0bffc15 	stw	r2,-16(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 d011c38:	e0bffd17 	ldw	r2,-12(fp)
 d011c3c:	10c00017 	ldw	r3,0(r2)
 d011c40:	e0bffe17 	ldw	r2,-8(fp)
 d011c44:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 d011c48:	e0bffd17 	ldw	r2,-12(fp)
 d011c4c:	10c00117 	ldw	r3,4(r2)
 d011c50:	e0bffe17 	ldw	r2,-8(fp)
 d011c54:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 d011c58:	e0bffd17 	ldw	r2,-12(fp)
 d011c5c:	10c00217 	ldw	r3,8(r2)
 d011c60:	e0bffe17 	ldw	r2,-8(fp)
 d011c64:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 d011c68:	e0bffd17 	ldw	r2,-12(fp)
 d011c6c:	10c00317 	ldw	r3,12(r2)
 d011c70:	e0bffe17 	ldw	r2,-8(fp)
 d011c74:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 d011c78:	e0bffd17 	ldw	r2,-12(fp)
 d011c7c:	10c00417 	ldw	r3,16(r2)
 d011c80:	e0bffe17 	ldw	r2,-8(fp)
 d011c84:	10c00415 	stw	r3,16(r2)
 d011c88:	e0bffc17 	ldw	r2,-16(fp)
 d011c8c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011c90:	e0bffa17 	ldw	r2,-24(fp)
 d011c94:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 d011c98:	e0bffe17 	ldw	r2,-8(fp)
 d011c9c:	10c00317 	ldw	r3,12(r2)
 d011ca0:	e0bffe17 	ldw	r2,-8(fp)
 d011ca4:	10800417 	ldw	r2,16(r2)
 d011ca8:	1887c83a 	sub	r3,r3,r2
 d011cac:	e0bffe17 	ldw	r2,-8(fp)
 d011cb0:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 d011cb4:	e03fff15 	stw	zero,-4(fp)
 d011cb8:	e0bfff17 	ldw	r2,-4(fp)
}
 d011cbc:	e037883a 	mov	sp,fp
 d011cc0:	df000017 	ldw	fp,0(sp)
 d011cc4:	dec00104 	addi	sp,sp,4
 d011cc8:	f800283a 	ret

0d011ccc <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 d011ccc:	defffc04 	addi	sp,sp,-16
 d011cd0:	dfc00315 	stw	ra,12(sp)
 d011cd4:	df000215 	stw	fp,8(sp)
 d011cd8:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 d011cdc:	010341b4 	movhi	r4,3334
 d011ce0:	21361804 	addi	r4,r4,-10144
 d011ce4:	01430c04 	movi	r5,3120
 d011ce8:	d00f3240 	call	d00f324 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 d011cec:	008341b4 	movhi	r2,3334
 d011cf0:	10b61804 	addi	r2,r2,-10144
 d011cf4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 d011cf8:	e03ffe0d 	sth	zero,-8(fp)
 d011cfc:	00001406 	br	d011d50 <OS_MemInit+0x84>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 d011d00:	e13ffe0b 	ldhu	r4,-8(fp)
 d011d04:	01400d04 	movi	r5,52
 d011d08:	d00235c0 	call	d00235c <__mulsi3>
 d011d0c:	1007883a 	mov	r3,r2
 d011d10:	008341b4 	movhi	r2,3334
 d011d14:	10b62504 	addi	r2,r2,-10092
 d011d18:	1887883a 	add	r3,r3,r2
 d011d1c:	e0bfff17 	ldw	r2,-4(fp)
 d011d20:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 d011d24:	e0ffff17 	ldw	r3,-4(fp)
 d011d28:	00800fc4 	movi	r2,63
 d011d2c:	18800505 	stb	r2,20(r3)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 d011d30:	e0bfff17 	ldw	r2,-4(fp)
 d011d34:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 d011d38:	e0bfff17 	ldw	r2,-4(fp)
 d011d3c:	10800d04 	addi	r2,r2,52
 d011d40:	e0bfff15 	stw	r2,-4(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 d011d44:	e0bffe0b 	ldhu	r2,-8(fp)
 d011d48:	10800044 	addi	r2,r2,1
 d011d4c:	e0bffe0d 	sth	r2,-8(fp)
 d011d50:	e0bffe0b 	ldhu	r2,-8(fp)
 d011d54:	10800ef0 	cmpltui	r2,r2,59
 d011d58:	103fe91e 	bne	r2,zero,d011d00 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 d011d5c:	e0bfff17 	ldw	r2,-4(fp)
 d011d60:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 d011d64:	e0ffff17 	ldw	r3,-4(fp)
 d011d68:	00800fc4 	movi	r2,63
 d011d6c:	18800505 	stb	r2,20(r3)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 d011d70:	e0bfff17 	ldw	r2,-4(fp)
 d011d74:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 d011d78:	00c34174 	movhi	r3,3333
 d011d7c:	18db1204 	addi	r3,r3,27720
 d011d80:	008341b4 	movhi	r2,3334
 d011d84:	10b61804 	addi	r2,r2,-10144
 d011d88:	18800015 	stw	r2,0(r3)
#endif
}
 d011d8c:	e037883a 	mov	sp,fp
 d011d90:	dfc00117 	ldw	ra,4(sp)
 d011d94:	df000017 	ldw	fp,0(sp)
 d011d98:	dec00204 	addi	sp,sp,8
 d011d9c:	f800283a 	ret

0d011da0 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 d011da0:	defff704 	addi	sp,sp,-36
 d011da4:	df000815 	stw	fp,32(sp)
 d011da8:	df000804 	addi	fp,sp,32
 d011dac:	e13ffd15 	stw	r4,-12(fp)
 d011db0:	e17ffe15 	stw	r5,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d011db4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d011db8:	e0bffe17 	ldw	r2,-8(fp)
 d011dbc:	1004c03a 	cmpne	r2,r2,zero
 d011dc0:	1000021e 	bne	r2,zero,d011dcc <OSQAccept+0x2c>
        return ((void *)0);
 d011dc4:	e03fff15 	stw	zero,-4(fp)
 d011dc8:	00004506 	br	d011ee0 <OSQAccept+0x140>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 d011dcc:	e0bffd17 	ldw	r2,-12(fp)
 d011dd0:	1004c03a 	cmpne	r2,r2,zero
 d011dd4:	1000051e 	bne	r2,zero,d011dec <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 d011dd8:	e0fffe17 	ldw	r3,-8(fp)
 d011ddc:	00800104 	movi	r2,4
 d011de0:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d011de4:	e03fff15 	stw	zero,-4(fp)
 d011de8:	00003d06 	br	d011ee0 <OSQAccept+0x140>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 d011dec:	e0bffd17 	ldw	r2,-12(fp)
 d011df0:	10800003 	ldbu	r2,0(r2)
 d011df4:	10803fcc 	andi	r2,r2,255
 d011df8:	108000a0 	cmpeqi	r2,r2,2
 d011dfc:	1000051e 	bne	r2,zero,d011e14 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 d011e00:	e0fffe17 	ldw	r3,-8(fp)
 d011e04:	00800044 	movi	r2,1
 d011e08:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d011e0c:	e03fff15 	stw	zero,-4(fp)
 d011e10:	00003306 	br	d011ee0 <OSQAccept+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011e14:	0005303a 	rdctl	r2,status
 d011e18:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011e1c:	e0fff917 	ldw	r3,-28(fp)
 d011e20:	00bfff84 	movi	r2,-2
 d011e24:	1884703a 	and	r2,r3,r2
 d011e28:	1001703a 	wrctl	status,r2
  
  return context;
 d011e2c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d011e30:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 d011e34:	e0bffd17 	ldw	r2,-12(fp)
 d011e38:	10800117 	ldw	r2,4(r2)
 d011e3c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 d011e40:	e0bffb17 	ldw	r2,-20(fp)
 d011e44:	1080058b 	ldhu	r2,22(r2)
 d011e48:	10bfffcc 	andi	r2,r2,65535
 d011e4c:	1005003a 	cmpeq	r2,r2,zero
 d011e50:	1000191e 	bne	r2,zero,d011eb8 <OSQAccept+0x118>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 d011e54:	e0bffb17 	ldw	r2,-20(fp)
 d011e58:	10c00417 	ldw	r3,16(r2)
 d011e5c:	18800017 	ldw	r2,0(r3)
 d011e60:	e0bffc15 	stw	r2,-16(fp)
 d011e64:	18c00104 	addi	r3,r3,4
 d011e68:	e0bffb17 	ldw	r2,-20(fp)
 d011e6c:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 d011e70:	e0bffb17 	ldw	r2,-20(fp)
 d011e74:	1080058b 	ldhu	r2,22(r2)
 d011e78:	10bfffc4 	addi	r2,r2,-1
 d011e7c:	1007883a 	mov	r3,r2
 d011e80:	e0bffb17 	ldw	r2,-20(fp)
 d011e84:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 d011e88:	e0bffb17 	ldw	r2,-20(fp)
 d011e8c:	10c00417 	ldw	r3,16(r2)
 d011e90:	e0bffb17 	ldw	r2,-20(fp)
 d011e94:	10800217 	ldw	r2,8(r2)
 d011e98:	1880041e 	bne	r3,r2,d011eac <OSQAccept+0x10c>
            pq->OSQOut = pq->OSQStart;
 d011e9c:	e0bffb17 	ldw	r2,-20(fp)
 d011ea0:	10c00117 	ldw	r3,4(r2)
 d011ea4:	e0bffb17 	ldw	r2,-20(fp)
 d011ea8:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 d011eac:	e0bffe17 	ldw	r2,-8(fp)
 d011eb0:	10000005 	stb	zero,0(r2)
 d011eb4:	00000406 	br	d011ec8 <OSQAccept+0x128>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 d011eb8:	e0fffe17 	ldw	r3,-8(fp)
 d011ebc:	008007c4 	movi	r2,31
 d011ec0:	18800005 	stb	r2,0(r3)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 d011ec4:	e03ffc15 	stw	zero,-16(fp)
 d011ec8:	e0bffa17 	ldw	r2,-24(fp)
 d011ecc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011ed0:	e0bff817 	ldw	r2,-32(fp)
 d011ed4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 d011ed8:	e0bffc17 	ldw	r2,-16(fp)
 d011edc:	e0bfff15 	stw	r2,-4(fp)
 d011ee0:	e0bfff17 	ldw	r2,-4(fp)
}
 d011ee4:	e037883a 	mov	sp,fp
 d011ee8:	df000017 	ldw	fp,0(sp)
 d011eec:	dec00104 	addi	sp,sp,4
 d011ef0:	f800283a 	ret

0d011ef4 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 d011ef4:	defff304 	addi	sp,sp,-52
 d011ef8:	dfc00c15 	stw	ra,48(sp)
 d011efc:	df000b15 	stw	fp,44(sp)
 d011f00:	df000b04 	addi	fp,sp,44
 d011f04:	e13ffd15 	stw	r4,-12(fp)
 d011f08:	e17ffe0d 	sth	r5,-8(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d011f0c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 d011f10:	00834174 	movhi	r2,3333
 d011f14:	109b1704 	addi	r2,r2,27740
 d011f18:	10800003 	ldbu	r2,0(r2)
 d011f1c:	10803fcc 	andi	r2,r2,255
 d011f20:	1005003a 	cmpeq	r2,r2,zero
 d011f24:	1000021e 	bne	r2,zero,d011f30 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 d011f28:	e03fff15 	stw	zero,-4(fp)
 d011f2c:	00007006 	br	d0120f0 <OSQCreate+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011f30:	0005303a 	rdctl	r2,status
 d011f34:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011f38:	e0fff917 	ldw	r3,-28(fp)
 d011f3c:	00bfff84 	movi	r2,-2
 d011f40:	1884703a 	and	r2,r3,r2
 d011f44:	1001703a 	wrctl	status,r2
  
  return context;
 d011f48:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d011f4c:	e0bffa15 	stw	r2,-24(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 d011f50:	00834174 	movhi	r2,3333
 d011f54:	109b1604 	addi	r2,r2,27736
 d011f58:	10800017 	ldw	r2,0(r2)
 d011f5c:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 d011f60:	00834174 	movhi	r2,3333
 d011f64:	109b1604 	addi	r2,r2,27736
 d011f68:	10800017 	ldw	r2,0(r2)
 d011f6c:	1005003a 	cmpeq	r2,r2,zero
 d011f70:	1000081e 	bne	r2,zero,d011f94 <OSQCreate+0xa0>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 d011f74:	00834174 	movhi	r2,3333
 d011f78:	109b1604 	addi	r2,r2,27736
 d011f7c:	10800017 	ldw	r2,0(r2)
 d011f80:	10800117 	ldw	r2,4(r2)
 d011f84:	1007883a 	mov	r3,r2
 d011f88:	00834174 	movhi	r2,3333
 d011f8c:	109b1604 	addi	r2,r2,27736
 d011f90:	10c00015 	stw	r3,0(r2)
 d011f94:	e0bffa17 	ldw	r2,-24(fp)
 d011f98:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011f9c:	e0bff817 	ldw	r2,-32(fp)
 d011fa0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 d011fa4:	e0bffc17 	ldw	r2,-16(fp)
 d011fa8:	1005003a 	cmpeq	r2,r2,zero
 d011fac:	10004e1e 	bne	r2,zero,d0120e8 <OSQCreate+0x1f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011fb0:	0005303a 	rdctl	r2,status
 d011fb4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011fb8:	e0fff717 	ldw	r3,-36(fp)
 d011fbc:	00bfff84 	movi	r2,-2
 d011fc0:	1884703a 	and	r2,r3,r2
 d011fc4:	1001703a 	wrctl	status,r2
  
  return context;
 d011fc8:	e0bff717 	ldw	r2,-36(fp)
        OS_ENTER_CRITICAL();
 d011fcc:	e0bffa15 	stw	r2,-24(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 d011fd0:	00834174 	movhi	r2,3333
 d011fd4:	109b1404 	addi	r2,r2,27728
 d011fd8:	10800017 	ldw	r2,0(r2)
 d011fdc:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 d011fe0:	e0bffb17 	ldw	r2,-20(fp)
 d011fe4:	1005003a 	cmpeq	r2,r2,zero
 d011fe8:	1000311e 	bne	r2,zero,d0120b0 <OSQCreate+0x1bc>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 d011fec:	00834174 	movhi	r2,3333
 d011ff0:	109b1404 	addi	r2,r2,27728
 d011ff4:	10800017 	ldw	r2,0(r2)
 d011ff8:	10c00017 	ldw	r3,0(r2)
 d011ffc:	00834174 	movhi	r2,3333
 d012000:	109b1404 	addi	r2,r2,27728
 d012004:	10c00015 	stw	r3,0(r2)
 d012008:	e0bffa17 	ldw	r2,-24(fp)
 d01200c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012010:	e0bff617 	ldw	r2,-40(fp)
 d012014:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 d012018:	e0fffb17 	ldw	r3,-20(fp)
 d01201c:	e0bffd17 	ldw	r2,-12(fp)
 d012020:	18800115 	stw	r2,4(r3)
            pq->OSQEnd             = &start[size];
 d012024:	e0bffe0b 	ldhu	r2,-8(fp)
 d012028:	1085883a 	add	r2,r2,r2
 d01202c:	1085883a 	add	r2,r2,r2
 d012030:	1007883a 	mov	r3,r2
 d012034:	e0bffd17 	ldw	r2,-12(fp)
 d012038:	1887883a 	add	r3,r3,r2
 d01203c:	e0bffb17 	ldw	r2,-20(fp)
 d012040:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 d012044:	e0fffb17 	ldw	r3,-20(fp)
 d012048:	e0bffd17 	ldw	r2,-12(fp)
 d01204c:	18800315 	stw	r2,12(r3)
            pq->OSQOut             = start;
 d012050:	e0fffb17 	ldw	r3,-20(fp)
 d012054:	e0bffd17 	ldw	r2,-12(fp)
 d012058:	18800415 	stw	r2,16(r3)
            pq->OSQSize            = size;
 d01205c:	e0fffb17 	ldw	r3,-20(fp)
 d012060:	e0bffe0b 	ldhu	r2,-8(fp)
 d012064:	1880050d 	sth	r2,20(r3)
            pq->OSQEntries         = 0;
 d012068:	e0bffb17 	ldw	r2,-20(fp)
 d01206c:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 d012070:	e0fffc17 	ldw	r3,-16(fp)
 d012074:	00800084 	movi	r2,2
 d012078:	18800005 	stb	r2,0(r3)
            pevent->OSEventCnt     = 0;
 d01207c:	e0bffc17 	ldw	r2,-16(fp)
 d012080:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 d012084:	e0fffc17 	ldw	r3,-16(fp)
 d012088:	e0bffb17 	ldw	r2,-20(fp)
 d01208c:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 d012090:	e0fffc17 	ldw	r3,-16(fp)
 d012094:	00800fc4 	movi	r2,63
 d012098:	18800385 	stb	r2,14(r3)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 d01209c:	e0bffc17 	ldw	r2,-16(fp)
 d0120a0:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 d0120a4:	e13ffc17 	ldw	r4,-16(fp)
 d0120a8:	d00ef580 	call	d00ef58 <OS_EventWaitListInit>
 d0120ac:	00000e06 	br	d0120e8 <OSQCreate+0x1f4>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 d0120b0:	00834174 	movhi	r2,3333
 d0120b4:	109b1604 	addi	r2,r2,27736
 d0120b8:	10c00017 	ldw	r3,0(r2)
 d0120bc:	e0bffc17 	ldw	r2,-16(fp)
 d0120c0:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 d0120c4:	00c34174 	movhi	r3,3333
 d0120c8:	18db1604 	addi	r3,r3,27736
 d0120cc:	e0bffc17 	ldw	r2,-16(fp)
 d0120d0:	18800015 	stw	r2,0(r3)
 d0120d4:	e0bffa17 	ldw	r2,-24(fp)
 d0120d8:	e0bff515 	stw	r2,-44(fp)
 d0120dc:	e0bff517 	ldw	r2,-44(fp)
 d0120e0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 d0120e4:	e03ffc15 	stw	zero,-16(fp)
        }
    }
    return (pevent);
 d0120e8:	e0bffc17 	ldw	r2,-16(fp)
 d0120ec:	e0bfff15 	stw	r2,-4(fp)
 d0120f0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0120f4:	e037883a 	mov	sp,fp
 d0120f8:	dfc00117 	ldw	ra,4(sp)
 d0120fc:	df000017 	ldw	fp,0(sp)
 d012100:	dec00204 	addi	sp,sp,8
 d012104:	f800283a 	ret

0d012108 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d012108:	defff004 	addi	sp,sp,-64
 d01210c:	dfc00f15 	stw	ra,60(sp)
 d012110:	df000e15 	stw	fp,56(sp)
 d012114:	df000e04 	addi	fp,sp,56
 d012118:	e13ffb15 	stw	r4,-20(fp)
 d01211c:	e1bffd15 	stw	r6,-12(fp)
 d012120:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d012124:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d012128:	e0bffd17 	ldw	r2,-12(fp)
 d01212c:	1004c03a 	cmpne	r2,r2,zero
 d012130:	1000031e 	bne	r2,zero,d012140 <OSQDel+0x38>
        return (pevent);
 d012134:	e0bffb17 	ldw	r2,-20(fp)
 d012138:	e0bfff15 	stw	r2,-4(fp)
 d01213c:	0000ac06 	br	d0123f0 <OSQDel+0x2e8>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d012140:	e0bffb17 	ldw	r2,-20(fp)
 d012144:	1004c03a 	cmpne	r2,r2,zero
 d012148:	1000061e 	bne	r2,zero,d012164 <OSQDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 d01214c:	e0fffd17 	ldw	r3,-12(fp)
 d012150:	00800104 	movi	r2,4
 d012154:	18800005 	stb	r2,0(r3)
        return (pevent);
 d012158:	e0fffb17 	ldw	r3,-20(fp)
 d01215c:	e0ffff15 	stw	r3,-4(fp)
 d012160:	0000a306 	br	d0123f0 <OSQDel+0x2e8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 d012164:	e0bffb17 	ldw	r2,-20(fp)
 d012168:	10800003 	ldbu	r2,0(r2)
 d01216c:	10803fcc 	andi	r2,r2,255
 d012170:	108000a0 	cmpeqi	r2,r2,2
 d012174:	1000061e 	bne	r2,zero,d012190 <OSQDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 d012178:	e0fffd17 	ldw	r3,-12(fp)
 d01217c:	00800044 	movi	r2,1
 d012180:	18800005 	stb	r2,0(r3)
        return (pevent);
 d012184:	e0bffb17 	ldw	r2,-20(fp)
 d012188:	e0bfff15 	stw	r2,-4(fp)
 d01218c:	00009806 	br	d0123f0 <OSQDel+0x2e8>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d012190:	00834174 	movhi	r2,3333
 d012194:	109b1704 	addi	r2,r2,27740
 d012198:	10800003 	ldbu	r2,0(r2)
 d01219c:	10803fcc 	andi	r2,r2,255
 d0121a0:	1005003a 	cmpeq	r2,r2,zero
 d0121a4:	1000061e 	bne	r2,zero,d0121c0 <OSQDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 d0121a8:	e0fffd17 	ldw	r3,-12(fp)
 d0121ac:	008003c4 	movi	r2,15
 d0121b0:	18800005 	stb	r2,0(r3)
        return (pevent);
 d0121b4:	e0fffb17 	ldw	r3,-20(fp)
 d0121b8:	e0ffff15 	stw	r3,-4(fp)
 d0121bc:	00008c06 	br	d0123f0 <OSQDel+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0121c0:	0005303a 	rdctl	r2,status
 d0121c4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0121c8:	e0fff617 	ldw	r3,-40(fp)
 d0121cc:	00bfff84 	movi	r2,-2
 d0121d0:	1884703a 	and	r2,r3,r2
 d0121d4:	1001703a 	wrctl	status,r2
  
  return context;
 d0121d8:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 d0121dc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 d0121e0:	e0bffb17 	ldw	r2,-20(fp)
 d0121e4:	10800283 	ldbu	r2,10(r2)
 d0121e8:	10803fcc 	andi	r2,r2,255
 d0121ec:	1005003a 	cmpeq	r2,r2,zero
 d0121f0:	1000031e 	bne	r2,zero,d012200 <OSQDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 d0121f4:	00800044 	movi	r2,1
 d0121f8:	e0bffa05 	stb	r2,-24(fp)
 d0121fc:	00000106 	br	d012204 <OSQDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 d012200:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 d012204:	e0bffc03 	ldbu	r2,-16(fp)
 d012208:	e0bffe15 	stw	r2,-8(fp)
 d01220c:	e0fffe17 	ldw	r3,-8(fp)
 d012210:	1805003a 	cmpeq	r2,r3,zero
 d012214:	1000041e 	bne	r2,zero,d012228 <OSQDel+0x120>
 d012218:	e0fffe17 	ldw	r3,-8(fp)
 d01221c:	18800060 	cmpeqi	r2,r3,1
 d012220:	1000391e 	bne	r2,zero,d012308 <OSQDel+0x200>
 d012224:	00006706 	br	d0123c4 <OSQDel+0x2bc>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 d012228:	e0bffa03 	ldbu	r2,-24(fp)
 d01222c:	1004c03a 	cmpne	r2,r2,zero
 d012230:	1000261e 	bne	r2,zero,d0122cc <OSQDel+0x1c4>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 d012234:	e0fffb17 	ldw	r3,-20(fp)
 d012238:	00800fc4 	movi	r2,63
 d01223c:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 d012240:	e0bffb17 	ldw	r2,-20(fp)
 d012244:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 d012248:	e0bffb17 	ldw	r2,-20(fp)
 d01224c:	10800117 	ldw	r2,4(r2)
 d012250:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 d012254:	00834174 	movhi	r2,3333
 d012258:	109b1404 	addi	r2,r2,27728
 d01225c:	10c00017 	ldw	r3,0(r2)
 d012260:	e0bff817 	ldw	r2,-32(fp)
 d012264:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 d012268:	00c34174 	movhi	r3,3333
 d01226c:	18db1404 	addi	r3,r3,27728
 d012270:	e0bff817 	ldw	r2,-32(fp)
 d012274:	18800015 	stw	r2,0(r3)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d012278:	e0bffb17 	ldw	r2,-20(fp)
 d01227c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 d012280:	00834174 	movhi	r2,3333
 d012284:	109b1604 	addi	r2,r2,27736
 d012288:	10c00017 	ldw	r3,0(r2)
 d01228c:	e0bffb17 	ldw	r2,-20(fp)
 d012290:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 d012294:	e0bffb17 	ldw	r2,-20(fp)
 d012298:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 d01229c:	00c34174 	movhi	r3,3333
 d0122a0:	18db1604 	addi	r3,r3,27736
 d0122a4:	e0bffb17 	ldw	r2,-20(fp)
 d0122a8:	18800015 	stw	r2,0(r3)
 d0122ac:	e0bff717 	ldw	r2,-36(fp)
 d0122b0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0122b4:	e0bff517 	ldw	r2,-44(fp)
 d0122b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 d0122bc:	e0bffd17 	ldw	r2,-12(fp)
 d0122c0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 d0122c4:	e03ff915 	stw	zero,-28(fp)
 d0122c8:	00004706 	br	d0123e8 <OSQDel+0x2e0>
 d0122cc:	e0bff717 	ldw	r2,-36(fp)
 d0122d0:	e0bff415 	stw	r2,-48(fp)
 d0122d4:	e0bff417 	ldw	r2,-48(fp)
 d0122d8:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 d0122dc:	e0fffd17 	ldw	r3,-12(fp)
 d0122e0:	00801244 	movi	r2,73
 d0122e4:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 d0122e8:	e0bffb17 	ldw	r2,-20(fp)
 d0122ec:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 d0122f0:	00003d06 	br	d0123e8 <OSQDel+0x2e0>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 d0122f4:	e13ffb17 	ldw	r4,-20(fp)
 d0122f8:	000b883a 	mov	r5,zero
 d0122fc:	01800104 	movi	r6,4
 d012300:	000f883a 	mov	r7,zero
 d012304:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 d012308:	e0bffb17 	ldw	r2,-20(fp)
 d01230c:	10800283 	ldbu	r2,10(r2)
 d012310:	10803fcc 	andi	r2,r2,255
 d012314:	1004c03a 	cmpne	r2,r2,zero
 d012318:	103ff61e 	bne	r2,zero,d0122f4 <OSQDel+0x1ec>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 d01231c:	e0fffb17 	ldw	r3,-20(fp)
 d012320:	00800fc4 	movi	r2,63
 d012324:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 d012328:	e0bffb17 	ldw	r2,-20(fp)
 d01232c:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 d012330:	e0bffb17 	ldw	r2,-20(fp)
 d012334:	10800117 	ldw	r2,4(r2)
 d012338:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 d01233c:	00834174 	movhi	r2,3333
 d012340:	109b1404 	addi	r2,r2,27728
 d012344:	10c00017 	ldw	r3,0(r2)
 d012348:	e0bff817 	ldw	r2,-32(fp)
 d01234c:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 d012350:	00c34174 	movhi	r3,3333
 d012354:	18db1404 	addi	r3,r3,27728
 d012358:	e0bff817 	ldw	r2,-32(fp)
 d01235c:	18800015 	stw	r2,0(r3)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d012360:	e0bffb17 	ldw	r2,-20(fp)
 d012364:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 d012368:	00834174 	movhi	r2,3333
 d01236c:	109b1604 	addi	r2,r2,27736
 d012370:	10c00017 	ldw	r3,0(r2)
 d012374:	e0bffb17 	ldw	r2,-20(fp)
 d012378:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 d01237c:	e0bffb17 	ldw	r2,-20(fp)
 d012380:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 d012384:	00c34174 	movhi	r3,3333
 d012388:	18db1604 	addi	r3,r3,27736
 d01238c:	e0bffb17 	ldw	r2,-20(fp)
 d012390:	18800015 	stw	r2,0(r3)
 d012394:	e0bff717 	ldw	r2,-36(fp)
 d012398:	e0bff315 	stw	r2,-52(fp)
 d01239c:	e0bff317 	ldw	r2,-52(fp)
 d0123a0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 d0123a4:	e0bffa03 	ldbu	r2,-24(fp)
 d0123a8:	10800058 	cmpnei	r2,r2,1
 d0123ac:	1000011e 	bne	r2,zero,d0123b4 <OSQDel+0x2ac>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 d0123b0:	d00f3e40 	call	d00f3e4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 d0123b4:	e0bffd17 	ldw	r2,-12(fp)
 d0123b8:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 d0123bc:	e03ff915 	stw	zero,-28(fp)
             break;
 d0123c0:	00000906 	br	d0123e8 <OSQDel+0x2e0>
 d0123c4:	e0bff717 	ldw	r2,-36(fp)
 d0123c8:	e0bff215 	stw	r2,-56(fp)
 d0123cc:	e0bff217 	ldw	r2,-56(fp)
 d0123d0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 d0123d4:	e0fffd17 	ldw	r3,-12(fp)
 d0123d8:	008001c4 	movi	r2,7
 d0123dc:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 d0123e0:	e0bffb17 	ldw	r2,-20(fp)
 d0123e4:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 d0123e8:	e0bff917 	ldw	r2,-28(fp)
 d0123ec:	e0bfff15 	stw	r2,-4(fp)
 d0123f0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0123f4:	e037883a 	mov	sp,fp
 d0123f8:	dfc00117 	ldw	ra,4(sp)
 d0123fc:	df000017 	ldw	fp,0(sp)
 d012400:	dec00204 	addi	sp,sp,8
 d012404:	f800283a 	ret

0d012408 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 d012408:	defff904 	addi	sp,sp,-28
 d01240c:	df000615 	stw	fp,24(sp)
 d012410:	df000604 	addi	fp,sp,24
 d012414:	e13ffe15 	stw	r4,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d012418:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d01241c:	e0bffe17 	ldw	r2,-8(fp)
 d012420:	1004c03a 	cmpne	r2,r2,zero
 d012424:	1000031e 	bne	r2,zero,d012434 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
 d012428:	00800104 	movi	r2,4
 d01242c:	e0bfff15 	stw	r2,-4(fp)
 d012430:	00002206 	br	d0124bc <OSQFlush+0xb4>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 d012434:	e0bffe17 	ldw	r2,-8(fp)
 d012438:	10800003 	ldbu	r2,0(r2)
 d01243c:	10803fcc 	andi	r2,r2,255
 d012440:	108000a0 	cmpeqi	r2,r2,2
 d012444:	1000031e 	bne	r2,zero,d012454 <OSQFlush+0x4c>
        return (OS_ERR_EVENT_TYPE);
 d012448:	00800044 	movi	r2,1
 d01244c:	e0bfff15 	stw	r2,-4(fp)
 d012450:	00001a06 	br	d0124bc <OSQFlush+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012454:	0005303a 	rdctl	r2,status
 d012458:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01245c:	e0fffb17 	ldw	r3,-20(fp)
 d012460:	00bfff84 	movi	r2,-2
 d012464:	1884703a 	and	r2,r3,r2
 d012468:	1001703a 	wrctl	status,r2
  
  return context;
 d01246c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d012470:	e0bffc15 	stw	r2,-16(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 d012474:	e0bffe17 	ldw	r2,-8(fp)
 d012478:	10800117 	ldw	r2,4(r2)
 d01247c:	e0bffd15 	stw	r2,-12(fp)
    pq->OSQIn      = pq->OSQStart;
 d012480:	e0bffd17 	ldw	r2,-12(fp)
 d012484:	10c00117 	ldw	r3,4(r2)
 d012488:	e0bffd17 	ldw	r2,-12(fp)
 d01248c:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 d012490:	e0bffd17 	ldw	r2,-12(fp)
 d012494:	10c00117 	ldw	r3,4(r2)
 d012498:	e0bffd17 	ldw	r2,-12(fp)
 d01249c:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 d0124a0:	e0bffd17 	ldw	r2,-12(fp)
 d0124a4:	1000058d 	sth	zero,22(r2)
 d0124a8:	e0bffc17 	ldw	r2,-16(fp)
 d0124ac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0124b0:	e0bffa17 	ldw	r2,-24(fp)
 d0124b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d0124b8:	e03fff15 	stw	zero,-4(fp)
 d0124bc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0124c0:	e037883a 	mov	sp,fp
 d0124c4:	df000017 	ldw	fp,0(sp)
 d0124c8:	dec00104 	addi	sp,sp,4
 d0124cc:	f800283a 	ret

0d0124d0 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 d0124d0:	defff104 	addi	sp,sp,-60
 d0124d4:	dfc00e15 	stw	ra,56(sp)
 d0124d8:	df000d15 	stw	fp,52(sp)
 d0124dc:	df000d04 	addi	fp,sp,52
 d0124e0:	e13ffb15 	stw	r4,-20(fp)
 d0124e4:	e1bffd15 	stw	r6,-12(fp)
 d0124e8:	e17ffc0d 	sth	r5,-16(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0124ec:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0124f0:	e0bffd17 	ldw	r2,-12(fp)
 d0124f4:	1004c03a 	cmpne	r2,r2,zero
 d0124f8:	1000021e 	bne	r2,zero,d012504 <OSQPend+0x34>
        return ((void *)0);
 d0124fc:	e03fff15 	stw	zero,-4(fp)
 d012500:	0000b506 	br	d0127d8 <OSQPend+0x308>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 d012504:	e0bffb17 	ldw	r2,-20(fp)
 d012508:	1004c03a 	cmpne	r2,r2,zero
 d01250c:	1000051e 	bne	r2,zero,d012524 <OSQPend+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d012510:	e0fffd17 	ldw	r3,-12(fp)
 d012514:	00800104 	movi	r2,4
 d012518:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d01251c:	e03fff15 	stw	zero,-4(fp)
 d012520:	0000ad06 	br	d0127d8 <OSQPend+0x308>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 d012524:	e0bffb17 	ldw	r2,-20(fp)
 d012528:	10800003 	ldbu	r2,0(r2)
 d01252c:	10803fcc 	andi	r2,r2,255
 d012530:	108000a0 	cmpeqi	r2,r2,2
 d012534:	1000051e 	bne	r2,zero,d01254c <OSQPend+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d012538:	e0fffd17 	ldw	r3,-12(fp)
 d01253c:	00800044 	movi	r2,1
 d012540:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d012544:	e03fff15 	stw	zero,-4(fp)
 d012548:	0000a306 	br	d0127d8 <OSQPend+0x308>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 d01254c:	00834174 	movhi	r2,3333
 d012550:	109b1704 	addi	r2,r2,27740
 d012554:	10800003 	ldbu	r2,0(r2)
 d012558:	10803fcc 	andi	r2,r2,255
 d01255c:	1005003a 	cmpeq	r2,r2,zero
 d012560:	1000051e 	bne	r2,zero,d012578 <OSQPend+0xa8>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 d012564:	e0fffd17 	ldw	r3,-12(fp)
 d012568:	00800084 	movi	r2,2
 d01256c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d012570:	e03fff15 	stw	zero,-4(fp)
 d012574:	00009806 	br	d0127d8 <OSQPend+0x308>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 d012578:	00834174 	movhi	r2,3333
 d01257c:	109b0904 	addi	r2,r2,27684
 d012580:	10800003 	ldbu	r2,0(r2)
 d012584:	10803fcc 	andi	r2,r2,255
 d012588:	1005003a 	cmpeq	r2,r2,zero
 d01258c:	1000051e 	bne	r2,zero,d0125a4 <OSQPend+0xd4>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 d012590:	e0fffd17 	ldw	r3,-12(fp)
 d012594:	00800344 	movi	r2,13
 d012598:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d01259c:	e03fff15 	stw	zero,-4(fp)
 d0125a0:	00008d06 	br	d0127d8 <OSQPend+0x308>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0125a4:	0005303a 	rdctl	r2,status
 d0125a8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0125ac:	e0fff717 	ldw	r3,-36(fp)
 d0125b0:	00bfff84 	movi	r2,-2
 d0125b4:	1884703a 	and	r2,r3,r2
 d0125b8:	1001703a 	wrctl	status,r2
  
  return context;
 d0125bc:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 d0125c0:	e0bff815 	stw	r2,-32(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 d0125c4:	e0bffb17 	ldw	r2,-20(fp)
 d0125c8:	10800117 	ldw	r2,4(r2)
 d0125cc:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 d0125d0:	e0bff917 	ldw	r2,-28(fp)
 d0125d4:	1080058b 	ldhu	r2,22(r2)
 d0125d8:	10bfffcc 	andi	r2,r2,65535
 d0125dc:	1005003a 	cmpeq	r2,r2,zero
 d0125e0:	10001f1e 	bne	r2,zero,d012660 <OSQPend+0x190>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 d0125e4:	e0bff917 	ldw	r2,-28(fp)
 d0125e8:	10c00417 	ldw	r3,16(r2)
 d0125ec:	18800017 	ldw	r2,0(r3)
 d0125f0:	e0bffa15 	stw	r2,-24(fp)
 d0125f4:	18c00104 	addi	r3,r3,4
 d0125f8:	e0bff917 	ldw	r2,-28(fp)
 d0125fc:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 d012600:	e0bff917 	ldw	r2,-28(fp)
 d012604:	1080058b 	ldhu	r2,22(r2)
 d012608:	10bfffc4 	addi	r2,r2,-1
 d01260c:	1007883a 	mov	r3,r2
 d012610:	e0bff917 	ldw	r2,-28(fp)
 d012614:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 d012618:	e0bff917 	ldw	r2,-28(fp)
 d01261c:	10c00417 	ldw	r3,16(r2)
 d012620:	e0bff917 	ldw	r2,-28(fp)
 d012624:	10800217 	ldw	r2,8(r2)
 d012628:	1880041e 	bne	r3,r2,d01263c <OSQPend+0x16c>
            pq->OSQOut = pq->OSQStart;
 d01262c:	e0bff917 	ldw	r2,-28(fp)
 d012630:	10c00117 	ldw	r3,4(r2)
 d012634:	e0bff917 	ldw	r2,-28(fp)
 d012638:	10c00415 	stw	r3,16(r2)
 d01263c:	e0bff817 	ldw	r2,-32(fp)
 d012640:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012644:	e0bff617 	ldw	r2,-40(fp)
 d012648:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 d01264c:	e0bffd17 	ldw	r2,-12(fp)
 d012650:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 d012654:	e0bffa17 	ldw	r2,-24(fp)
 d012658:	e0bfff15 	stw	r2,-4(fp)
 d01265c:	00005e06 	br	d0127d8 <OSQPend+0x308>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 d012660:	00834174 	movhi	r2,3333
 d012664:	109b1804 	addi	r2,r2,27744
 d012668:	10c00017 	ldw	r3,0(r2)
 d01266c:	00834174 	movhi	r2,3333
 d012670:	109b1804 	addi	r2,r2,27744
 d012674:	10800017 	ldw	r2,0(r2)
 d012678:	10800c03 	ldbu	r2,48(r2)
 d01267c:	10800114 	ori	r2,r2,4
 d012680:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d012684:	00834174 	movhi	r2,3333
 d012688:	109b1804 	addi	r2,r2,27744
 d01268c:	10800017 	ldw	r2,0(r2)
 d012690:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 d012694:	00834174 	movhi	r2,3333
 d012698:	109b1804 	addi	r2,r2,27744
 d01269c:	10c00017 	ldw	r3,0(r2)
 d0126a0:	e0bffc0b 	ldhu	r2,-16(fp)
 d0126a4:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 d0126a8:	e13ffb17 	ldw	r4,-20(fp)
 d0126ac:	d00eb380 	call	d00eb38 <OS_EventTaskWait>
 d0126b0:	e0bff817 	ldw	r2,-32(fp)
 d0126b4:	e0bff515 	stw	r2,-44(fp)
 d0126b8:	e0bff517 	ldw	r2,-44(fp)
 d0126bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 d0126c0:	d00f3e40 	call	d00f3e4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0126c4:	0005303a 	rdctl	r2,status
 d0126c8:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0126cc:	e0fff417 	ldw	r3,-48(fp)
 d0126d0:	00bfff84 	movi	r2,-2
 d0126d4:	1884703a 	and	r2,r3,r2
 d0126d8:	1001703a 	wrctl	status,r2
  
  return context;
 d0126dc:	e0bff417 	ldw	r2,-48(fp)
    OS_ENTER_CRITICAL();
 d0126e0:	e0bff815 	stw	r2,-32(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 d0126e4:	00834174 	movhi	r2,3333
 d0126e8:	109b1804 	addi	r2,r2,27744
 d0126ec:	10800017 	ldw	r2,0(r2)
 d0126f0:	10800c43 	ldbu	r2,49(r2)
 d0126f4:	10803fcc 	andi	r2,r2,255
 d0126f8:	e0bffe15 	stw	r2,-8(fp)
 d0126fc:	e0fffe17 	ldw	r3,-8(fp)
 d012700:	1805003a 	cmpeq	r2,r3,zero
 d012704:	1000041e 	bne	r2,zero,d012718 <OSQPend+0x248>
 d012708:	e0fffe17 	ldw	r3,-8(fp)
 d01270c:	188000a0 	cmpeqi	r2,r3,2
 d012710:	1000091e 	bne	r2,zero,d012738 <OSQPend+0x268>
 d012714:	00000d06 	br	d01274c <OSQPend+0x27c>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 d012718:	00834174 	movhi	r2,3333
 d01271c:	109b1804 	addi	r2,r2,27744
 d012720:	10800017 	ldw	r2,0(r2)
 d012724:	10800917 	ldw	r2,36(r2)
 d012728:	e0bffa15 	stw	r2,-24(fp)
            *perr =  OS_ERR_NONE;
 d01272c:	e0bffd17 	ldw	r2,-12(fp)
 d012730:	10000005 	stb	zero,0(r2)
             break;
 d012734:	00000e06 	br	d012770 <OSQPend+0x2a0>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 d012738:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 d01273c:	e0fffd17 	ldw	r3,-12(fp)
 d012740:	00800384 	movi	r2,14
 d012744:	18800005 	stb	r2,0(r3)
             break;
 d012748:	00000906 	br	d012770 <OSQPend+0x2a0>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 d01274c:	00834174 	movhi	r2,3333
 d012750:	109b1804 	addi	r2,r2,27744
 d012754:	11000017 	ldw	r4,0(r2)
 d012758:	e17ffb17 	ldw	r5,-20(fp)
 d01275c:	d00ed9c0 	call	d00ed9c <OS_EventTaskRemove>
             pmsg = (void *)0;
 d012760:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 d012764:	e0fffd17 	ldw	r3,-12(fp)
 d012768:	00800284 	movi	r2,10
 d01276c:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 d012770:	00834174 	movhi	r2,3333
 d012774:	109b1804 	addi	r2,r2,27744
 d012778:	10800017 	ldw	r2,0(r2)
 d01277c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 d012780:	00834174 	movhi	r2,3333
 d012784:	109b1804 	addi	r2,r2,27744
 d012788:	10800017 	ldw	r2,0(r2)
 d01278c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 d012790:	00834174 	movhi	r2,3333
 d012794:	109b1804 	addi	r2,r2,27744
 d012798:	10800017 	ldw	r2,0(r2)
 d01279c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 d0127a0:	00834174 	movhi	r2,3333
 d0127a4:	109b1804 	addi	r2,r2,27744
 d0127a8:	10800017 	ldw	r2,0(r2)
 d0127ac:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 d0127b0:	00834174 	movhi	r2,3333
 d0127b4:	109b1804 	addi	r2,r2,27744
 d0127b8:	10800017 	ldw	r2,0(r2)
 d0127bc:	10000915 	stw	zero,36(r2)
 d0127c0:	e0bff817 	ldw	r2,-32(fp)
 d0127c4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0127c8:	e0bff317 	ldw	r2,-52(fp)
 d0127cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 d0127d0:	e0bffa17 	ldw	r2,-24(fp)
 d0127d4:	e0bfff15 	stw	r2,-4(fp)
 d0127d8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0127dc:	e037883a 	mov	sp,fp
 d0127e0:	dfc00117 	ldw	ra,4(sp)
 d0127e4:	df000017 	ldw	fp,0(sp)
 d0127e8:	dec00204 	addi	sp,sp,8
 d0127ec:	f800283a 	ret

0d0127f0 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d0127f0:	defff504 	addi	sp,sp,-44
 d0127f4:	dfc00a15 	stw	ra,40(sp)
 d0127f8:	df000915 	stw	fp,36(sp)
 d0127fc:	df000904 	addi	fp,sp,36
 d012800:	e13ffc15 	stw	r4,-16(fp)
 d012804:	e1bffe15 	stw	r6,-8(fp)
 d012808:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d01280c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d012810:	e0bffe17 	ldw	r2,-8(fp)
 d012814:	1004c03a 	cmpne	r2,r2,zero
 d012818:	1000021e 	bne	r2,zero,d012824 <OSQPendAbort+0x34>
        return (0);
 d01281c:	e03fff15 	stw	zero,-4(fp)
 d012820:	00004c06 	br	d012954 <OSQPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d012824:	e0bffc17 	ldw	r2,-16(fp)
 d012828:	1004c03a 	cmpne	r2,r2,zero
 d01282c:	1000051e 	bne	r2,zero,d012844 <OSQPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d012830:	e0fffe17 	ldw	r3,-8(fp)
 d012834:	00800104 	movi	r2,4
 d012838:	18800005 	stb	r2,0(r3)
        return (0);
 d01283c:	e03fff15 	stw	zero,-4(fp)
 d012840:	00004406 	br	d012954 <OSQPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 d012844:	e0bffc17 	ldw	r2,-16(fp)
 d012848:	10800003 	ldbu	r2,0(r2)
 d01284c:	10803fcc 	andi	r2,r2,255
 d012850:	108000a0 	cmpeqi	r2,r2,2
 d012854:	1000051e 	bne	r2,zero,d01286c <OSQPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d012858:	e0fffe17 	ldw	r3,-8(fp)
 d01285c:	00800044 	movi	r2,1
 d012860:	18800005 	stb	r2,0(r3)
        return (0);
 d012864:	e03fff15 	stw	zero,-4(fp)
 d012868:	00003a06 	br	d012954 <OSQPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01286c:	0005303a 	rdctl	r2,status
 d012870:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012874:	e0fff917 	ldw	r3,-28(fp)
 d012878:	00bfff84 	movi	r2,-2
 d01287c:	1884703a 	and	r2,r3,r2
 d012880:	1001703a 	wrctl	status,r2
  
  return context;
 d012884:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d012888:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 d01288c:	e0bffc17 	ldw	r2,-16(fp)
 d012890:	10800283 	ldbu	r2,10(r2)
 d012894:	10803fcc 	andi	r2,r2,255
 d012898:	1005003a 	cmpeq	r2,r2,zero
 d01289c:	1000261e 	bne	r2,zero,d012938 <OSQPendAbort+0x148>
        nbr_tasks = 0;
 d0128a0:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 d0128a4:	e0bffd03 	ldbu	r2,-12(fp)
 d0128a8:	10800060 	cmpeqi	r2,r2,1
 d0128ac:	1000091e 	bne	r2,zero,d0128d4 <OSQPendAbort+0xe4>
 d0128b0:	00000e06 	br	d0128ec <OSQPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 d0128b4:	e13ffc17 	ldw	r4,-16(fp)
 d0128b8:	000b883a 	mov	r5,zero
 d0128bc:	01800104 	movi	r6,4
 d0128c0:	01c00084 	movi	r7,2
 d0128c4:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
                     nbr_tasks++;
 d0128c8:	e0bffb03 	ldbu	r2,-20(fp)
 d0128cc:	10800044 	addi	r2,r2,1
 d0128d0:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 d0128d4:	e0bffc17 	ldw	r2,-16(fp)
 d0128d8:	10800283 	ldbu	r2,10(r2)
 d0128dc:	10803fcc 	andi	r2,r2,255
 d0128e0:	1004c03a 	cmpne	r2,r2,zero
 d0128e4:	103ff31e 	bne	r2,zero,d0128b4 <OSQPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 d0128e8:	00000806 	br	d01290c <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 d0128ec:	e13ffc17 	ldw	r4,-16(fp)
 d0128f0:	000b883a 	mov	r5,zero
 d0128f4:	01800104 	movi	r6,4
 d0128f8:	01c00084 	movi	r7,2
 d0128fc:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
                 nbr_tasks++;
 d012900:	e0bffb03 	ldbu	r2,-20(fp)
 d012904:	10800044 	addi	r2,r2,1
 d012908:	e0bffb05 	stb	r2,-20(fp)
 d01290c:	e0bffa17 	ldw	r2,-24(fp)
 d012910:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012914:	e0bff817 	ldw	r2,-32(fp)
 d012918:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 d01291c:	d00f3e40 	call	d00f3e4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 d012920:	e0fffe17 	ldw	r3,-8(fp)
 d012924:	00800384 	movi	r2,14
 d012928:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 d01292c:	e0bffb03 	ldbu	r2,-20(fp)
 d012930:	e0bfff15 	stw	r2,-4(fp)
 d012934:	00000706 	br	d012954 <OSQPendAbort+0x164>
 d012938:	e0bffa17 	ldw	r2,-24(fp)
 d01293c:	e0bff715 	stw	r2,-36(fp)
 d012940:	e0bff717 	ldw	r2,-36(fp)
 d012944:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d012948:	e0bffe17 	ldw	r2,-8(fp)
 d01294c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 d012950:	e03fff15 	stw	zero,-4(fp)
 d012954:	e0bfff17 	ldw	r2,-4(fp)
}
 d012958:	e037883a 	mov	sp,fp
 d01295c:	dfc00117 	ldw	ra,4(sp)
 d012960:	df000017 	ldw	fp,0(sp)
 d012964:	dec00204 	addi	sp,sp,8
 d012968:	f800283a 	ret

0d01296c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 d01296c:	defff504 	addi	sp,sp,-44
 d012970:	dfc00a15 	stw	ra,40(sp)
 d012974:	df000915 	stw	fp,36(sp)
 d012978:	df000904 	addi	fp,sp,36
 d01297c:	e13ffd15 	stw	r4,-12(fp)
 d012980:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d012984:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 d012988:	e0bffd17 	ldw	r2,-12(fp)
 d01298c:	1004c03a 	cmpne	r2,r2,zero
 d012990:	1000031e 	bne	r2,zero,d0129a0 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
 d012994:	00800104 	movi	r2,4
 d012998:	e0bfff15 	stw	r2,-4(fp)
 d01299c:	00004d06 	br	d012ad4 <OSQPost+0x168>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 d0129a0:	e0bffd17 	ldw	r2,-12(fp)
 d0129a4:	10800003 	ldbu	r2,0(r2)
 d0129a8:	10803fcc 	andi	r2,r2,255
 d0129ac:	108000a0 	cmpeqi	r2,r2,2
 d0129b0:	1000031e 	bne	r2,zero,d0129c0 <OSQPost+0x54>
        return (OS_ERR_EVENT_TYPE);
 d0129b4:	00800044 	movi	r2,1
 d0129b8:	e0bfff15 	stw	r2,-4(fp)
 d0129bc:	00004506 	br	d012ad4 <OSQPost+0x168>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0129c0:	0005303a 	rdctl	r2,status
 d0129c4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0129c8:	e0fffa17 	ldw	r3,-24(fp)
 d0129cc:	00bfff84 	movi	r2,-2
 d0129d0:	1884703a 	and	r2,r3,r2
 d0129d4:	1001703a 	wrctl	status,r2
  
  return context;
 d0129d8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d0129dc:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 d0129e0:	e0bffd17 	ldw	r2,-12(fp)
 d0129e4:	10800283 	ldbu	r2,10(r2)
 d0129e8:	10803fcc 	andi	r2,r2,255
 d0129ec:	1005003a 	cmpeq	r2,r2,zero
 d0129f0:	10000c1e 	bne	r2,zero,d012a24 <OSQPost+0xb8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d0129f4:	e13ffd17 	ldw	r4,-12(fp)
 d0129f8:	e17ffe17 	ldw	r5,-8(fp)
 d0129fc:	01800104 	movi	r6,4
 d012a00:	000f883a 	mov	r7,zero
 d012a04:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
 d012a08:	e0bffb17 	ldw	r2,-20(fp)
 d012a0c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012a10:	e0bff917 	ldw	r2,-28(fp)
 d012a14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 d012a18:	d00f3e40 	call	d00f3e4 <OS_Sched>
        return (OS_ERR_NONE);
 d012a1c:	e03fff15 	stw	zero,-4(fp)
 d012a20:	00002c06 	br	d012ad4 <OSQPost+0x168>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 d012a24:	e0bffd17 	ldw	r2,-12(fp)
 d012a28:	10800117 	ldw	r2,4(r2)
 d012a2c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 d012a30:	e0bffc17 	ldw	r2,-16(fp)
 d012a34:	10c0058b 	ldhu	r3,22(r2)
 d012a38:	e0bffc17 	ldw	r2,-16(fp)
 d012a3c:	1080050b 	ldhu	r2,20(r2)
 d012a40:	18ffffcc 	andi	r3,r3,65535
 d012a44:	10bfffcc 	andi	r2,r2,65535
 d012a48:	18800736 	bltu	r3,r2,d012a68 <OSQPost+0xfc>
 d012a4c:	e0bffb17 	ldw	r2,-20(fp)
 d012a50:	e0bff815 	stw	r2,-32(fp)
 d012a54:	e0bff817 	ldw	r2,-32(fp)
 d012a58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 d012a5c:	00800784 	movi	r2,30
 d012a60:	e0bfff15 	stw	r2,-4(fp)
 d012a64:	00001b06 	br	d012ad4 <OSQPost+0x168>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 d012a68:	e0bffc17 	ldw	r2,-16(fp)
 d012a6c:	10c00317 	ldw	r3,12(r2)
 d012a70:	e0bffe17 	ldw	r2,-8(fp)
 d012a74:	18800015 	stw	r2,0(r3)
 d012a78:	18c00104 	addi	r3,r3,4
 d012a7c:	e0bffc17 	ldw	r2,-16(fp)
 d012a80:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 d012a84:	e0bffc17 	ldw	r2,-16(fp)
 d012a88:	1080058b 	ldhu	r2,22(r2)
 d012a8c:	10800044 	addi	r2,r2,1
 d012a90:	1007883a 	mov	r3,r2
 d012a94:	e0bffc17 	ldw	r2,-16(fp)
 d012a98:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 d012a9c:	e0bffc17 	ldw	r2,-16(fp)
 d012aa0:	10c00317 	ldw	r3,12(r2)
 d012aa4:	e0bffc17 	ldw	r2,-16(fp)
 d012aa8:	10800217 	ldw	r2,8(r2)
 d012aac:	1880041e 	bne	r3,r2,d012ac0 <OSQPost+0x154>
        pq->OSQIn = pq->OSQStart;
 d012ab0:	e0bffc17 	ldw	r2,-16(fp)
 d012ab4:	10c00117 	ldw	r3,4(r2)
 d012ab8:	e0bffc17 	ldw	r2,-16(fp)
 d012abc:	10c00315 	stw	r3,12(r2)
 d012ac0:	e0bffb17 	ldw	r2,-20(fp)
 d012ac4:	e0bff715 	stw	r2,-36(fp)
 d012ac8:	e0bff717 	ldw	r2,-36(fp)
 d012acc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d012ad0:	e03fff15 	stw	zero,-4(fp)
 d012ad4:	e0bfff17 	ldw	r2,-4(fp)
}
 d012ad8:	e037883a 	mov	sp,fp
 d012adc:	dfc00117 	ldw	ra,4(sp)
 d012ae0:	df000017 	ldw	fp,0(sp)
 d012ae4:	dec00204 	addi	sp,sp,8
 d012ae8:	f800283a 	ret

0d012aec <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 d012aec:	defff504 	addi	sp,sp,-44
 d012af0:	dfc00a15 	stw	ra,40(sp)
 d012af4:	df000915 	stw	fp,36(sp)
 d012af8:	df000904 	addi	fp,sp,36
 d012afc:	e13ffd15 	stw	r4,-12(fp)
 d012b00:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d012b04:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d012b08:	e0bffd17 	ldw	r2,-12(fp)
 d012b0c:	1004c03a 	cmpne	r2,r2,zero
 d012b10:	1000031e 	bne	r2,zero,d012b20 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
 d012b14:	00800104 	movi	r2,4
 d012b18:	e0bfff15 	stw	r2,-4(fp)
 d012b1c:	00004f06 	br	d012c5c <OSQPostFront+0x170>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 d012b20:	e0bffd17 	ldw	r2,-12(fp)
 d012b24:	10800003 	ldbu	r2,0(r2)
 d012b28:	10803fcc 	andi	r2,r2,255
 d012b2c:	108000a0 	cmpeqi	r2,r2,2
 d012b30:	1000031e 	bne	r2,zero,d012b40 <OSQPostFront+0x54>
        return (OS_ERR_EVENT_TYPE);
 d012b34:	00800044 	movi	r2,1
 d012b38:	e0bfff15 	stw	r2,-4(fp)
 d012b3c:	00004706 	br	d012c5c <OSQPostFront+0x170>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012b40:	0005303a 	rdctl	r2,status
 d012b44:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012b48:	e0fffa17 	ldw	r3,-24(fp)
 d012b4c:	00bfff84 	movi	r2,-2
 d012b50:	1884703a 	and	r2,r3,r2
 d012b54:	1001703a 	wrctl	status,r2
  
  return context;
 d012b58:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d012b5c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 d012b60:	e0bffd17 	ldw	r2,-12(fp)
 d012b64:	10800283 	ldbu	r2,10(r2)
 d012b68:	10803fcc 	andi	r2,r2,255
 d012b6c:	1005003a 	cmpeq	r2,r2,zero
 d012b70:	10000c1e 	bne	r2,zero,d012ba4 <OSQPostFront+0xb8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d012b74:	e13ffd17 	ldw	r4,-12(fp)
 d012b78:	e17ffe17 	ldw	r5,-8(fp)
 d012b7c:	01800104 	movi	r6,4
 d012b80:	000f883a 	mov	r7,zero
 d012b84:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
 d012b88:	e0bffb17 	ldw	r2,-20(fp)
 d012b8c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012b90:	e0bff917 	ldw	r2,-28(fp)
 d012b94:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 d012b98:	d00f3e40 	call	d00f3e4 <OS_Sched>
        return (OS_ERR_NONE);
 d012b9c:	e03fff15 	stw	zero,-4(fp)
 d012ba0:	00002e06 	br	d012c5c <OSQPostFront+0x170>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 d012ba4:	e0bffd17 	ldw	r2,-12(fp)
 d012ba8:	10800117 	ldw	r2,4(r2)
 d012bac:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 d012bb0:	e0bffc17 	ldw	r2,-16(fp)
 d012bb4:	10c0058b 	ldhu	r3,22(r2)
 d012bb8:	e0bffc17 	ldw	r2,-16(fp)
 d012bbc:	1080050b 	ldhu	r2,20(r2)
 d012bc0:	18ffffcc 	andi	r3,r3,65535
 d012bc4:	10bfffcc 	andi	r2,r2,65535
 d012bc8:	18800736 	bltu	r3,r2,d012be8 <OSQPostFront+0xfc>
 d012bcc:	e0bffb17 	ldw	r2,-20(fp)
 d012bd0:	e0bff815 	stw	r2,-32(fp)
 d012bd4:	e0bff817 	ldw	r2,-32(fp)
 d012bd8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 d012bdc:	00800784 	movi	r2,30
 d012be0:	e0bfff15 	stw	r2,-4(fp)
 d012be4:	00001d06 	br	d012c5c <OSQPostFront+0x170>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 d012be8:	e0bffc17 	ldw	r2,-16(fp)
 d012bec:	10c00417 	ldw	r3,16(r2)
 d012bf0:	e0bffc17 	ldw	r2,-16(fp)
 d012bf4:	10800117 	ldw	r2,4(r2)
 d012bf8:	1880041e 	bne	r3,r2,d012c0c <OSQPostFront+0x120>
        pq->OSQOut = pq->OSQEnd;
 d012bfc:	e0bffc17 	ldw	r2,-16(fp)
 d012c00:	10c00217 	ldw	r3,8(r2)
 d012c04:	e0bffc17 	ldw	r2,-16(fp)
 d012c08:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 d012c0c:	e0bffc17 	ldw	r2,-16(fp)
 d012c10:	10800417 	ldw	r2,16(r2)
 d012c14:	10ffff04 	addi	r3,r2,-4
 d012c18:	e0bffc17 	ldw	r2,-16(fp)
 d012c1c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 d012c20:	e0bffc17 	ldw	r2,-16(fp)
 d012c24:	10c00417 	ldw	r3,16(r2)
 d012c28:	e0bffe17 	ldw	r2,-8(fp)
 d012c2c:	18800015 	stw	r2,0(r3)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 d012c30:	e0bffc17 	ldw	r2,-16(fp)
 d012c34:	1080058b 	ldhu	r2,22(r2)
 d012c38:	10800044 	addi	r2,r2,1
 d012c3c:	1007883a 	mov	r3,r2
 d012c40:	e0bffc17 	ldw	r2,-16(fp)
 d012c44:	10c0058d 	sth	r3,22(r2)
 d012c48:	e0bffb17 	ldw	r2,-20(fp)
 d012c4c:	e0bff715 	stw	r2,-36(fp)
 d012c50:	e0bff717 	ldw	r2,-36(fp)
 d012c54:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d012c58:	e03fff15 	stw	zero,-4(fp)
 d012c5c:	e0bfff17 	ldw	r2,-4(fp)
}
 d012c60:	e037883a 	mov	sp,fp
 d012c64:	dfc00117 	ldw	ra,4(sp)
 d012c68:	df000017 	ldw	fp,0(sp)
 d012c6c:	dec00204 	addi	sp,sp,8
 d012c70:	f800283a 	ret

0d012c74 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 d012c74:	defff404 	addi	sp,sp,-48
 d012c78:	dfc00b15 	stw	ra,44(sp)
 d012c7c:	df000a15 	stw	fp,40(sp)
 d012c80:	df000a04 	addi	fp,sp,40
 d012c84:	e13ffc15 	stw	r4,-16(fp)
 d012c88:	e17ffd15 	stw	r5,-12(fp)
 d012c8c:	e1bffe05 	stb	r6,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d012c90:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d012c94:	e0bffc17 	ldw	r2,-16(fp)
 d012c98:	1004c03a 	cmpne	r2,r2,zero
 d012c9c:	1000031e 	bne	r2,zero,d012cac <OSQPostOpt+0x38>
        return (OS_ERR_PEVENT_NULL);
 d012ca0:	00800104 	movi	r2,4
 d012ca4:	e0bfff15 	stw	r2,-4(fp)
 d012ca8:	00007906 	br	d012e90 <OSQPostOpt+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 d012cac:	e0bffc17 	ldw	r2,-16(fp)
 d012cb0:	10800003 	ldbu	r2,0(r2)
 d012cb4:	10803fcc 	andi	r2,r2,255
 d012cb8:	108000a0 	cmpeqi	r2,r2,2
 d012cbc:	1000031e 	bne	r2,zero,d012ccc <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
 d012cc0:	00800044 	movi	r2,1
 d012cc4:	e0bfff15 	stw	r2,-4(fp)
 d012cc8:	00007106 	br	d012e90 <OSQPostOpt+0x21c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012ccc:	0005303a 	rdctl	r2,status
 d012cd0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012cd4:	e0fff917 	ldw	r3,-28(fp)
 d012cd8:	00bfff84 	movi	r2,-2
 d012cdc:	1884703a 	and	r2,r3,r2
 d012ce0:	1001703a 	wrctl	status,r2
  
  return context;
 d012ce4:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d012ce8:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 d012cec:	e0bffc17 	ldw	r2,-16(fp)
 d012cf0:	10800283 	ldbu	r2,10(r2)
 d012cf4:	10803fcc 	andi	r2,r2,255
 d012cf8:	1005003a 	cmpeq	r2,r2,zero
 d012cfc:	1000211e 	bne	r2,zero,d012d84 <OSQPostOpt+0x110>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 d012d00:	e0bffe03 	ldbu	r2,-8(fp)
 d012d04:	1080004c 	andi	r2,r2,1
 d012d08:	10803fcc 	andi	r2,r2,255
 d012d0c:	1005003a 	cmpeq	r2,r2,zero
 d012d10:	10000c1e 	bne	r2,zero,d012d44 <OSQPostOpt+0xd0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 d012d14:	00000506 	br	d012d2c <OSQPostOpt+0xb8>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d012d18:	e13ffc17 	ldw	r4,-16(fp)
 d012d1c:	e17ffd17 	ldw	r5,-12(fp)
 d012d20:	01800104 	movi	r6,4
 d012d24:	000f883a 	mov	r7,zero
 d012d28:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 d012d2c:	e0bffc17 	ldw	r2,-16(fp)
 d012d30:	10800283 	ldbu	r2,10(r2)
 d012d34:	10803fcc 	andi	r2,r2,255
 d012d38:	1004c03a 	cmpne	r2,r2,zero
 d012d3c:	103ff61e 	bne	r2,zero,d012d18 <OSQPostOpt+0xa4>
 d012d40:	00000506 	br	d012d58 <OSQPostOpt+0xe4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d012d44:	e13ffc17 	ldw	r4,-16(fp)
 d012d48:	e17ffd17 	ldw	r5,-12(fp)
 d012d4c:	01800104 	movi	r6,4
 d012d50:	000f883a 	mov	r7,zero
 d012d54:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
 d012d58:	e0bffa17 	ldw	r2,-24(fp)
 d012d5c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012d60:	e0bff817 	ldw	r2,-32(fp)
 d012d64:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 d012d68:	e0bffe03 	ldbu	r2,-8(fp)
 d012d6c:	1080010c 	andi	r2,r2,4
 d012d70:	1004c03a 	cmpne	r2,r2,zero
 d012d74:	1000011e 	bne	r2,zero,d012d7c <OSQPostOpt+0x108>
            OS_Sched();                               /* Find highest priority task ready to run       */
 d012d78:	d00f3e40 	call	d00f3e4 <OS_Sched>
        }
        return (OS_ERR_NONE);
 d012d7c:	e03fff15 	stw	zero,-4(fp)
 d012d80:	00004306 	br	d012e90 <OSQPostOpt+0x21c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 d012d84:	e0bffc17 	ldw	r2,-16(fp)
 d012d88:	10800117 	ldw	r2,4(r2)
 d012d8c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 d012d90:	e0bffb17 	ldw	r2,-20(fp)
 d012d94:	10c0058b 	ldhu	r3,22(r2)
 d012d98:	e0bffb17 	ldw	r2,-20(fp)
 d012d9c:	1080050b 	ldhu	r2,20(r2)
 d012da0:	18ffffcc 	andi	r3,r3,65535
 d012da4:	10bfffcc 	andi	r2,r2,65535
 d012da8:	18800736 	bltu	r3,r2,d012dc8 <OSQPostOpt+0x154>
 d012dac:	e0bffa17 	ldw	r2,-24(fp)
 d012db0:	e0bff715 	stw	r2,-36(fp)
 d012db4:	e0bff717 	ldw	r2,-36(fp)
 d012db8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 d012dbc:	00800784 	movi	r2,30
 d012dc0:	e0bfff15 	stw	r2,-4(fp)
 d012dc4:	00003206 	br	d012e90 <OSQPostOpt+0x21c>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 d012dc8:	e0bffe03 	ldbu	r2,-8(fp)
 d012dcc:	1080008c 	andi	r2,r2,2
 d012dd0:	1005003a 	cmpeq	r2,r2,zero
 d012dd4:	1000131e 	bne	r2,zero,d012e24 <OSQPostOpt+0x1b0>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 d012dd8:	e0bffb17 	ldw	r2,-20(fp)
 d012ddc:	10c00417 	ldw	r3,16(r2)
 d012de0:	e0bffb17 	ldw	r2,-20(fp)
 d012de4:	10800117 	ldw	r2,4(r2)
 d012de8:	1880041e 	bne	r3,r2,d012dfc <OSQPostOpt+0x188>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 d012dec:	e0bffb17 	ldw	r2,-20(fp)
 d012df0:	10c00217 	ldw	r3,8(r2)
 d012df4:	e0bffb17 	ldw	r2,-20(fp)
 d012df8:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 d012dfc:	e0bffb17 	ldw	r2,-20(fp)
 d012e00:	10800417 	ldw	r2,16(r2)
 d012e04:	10ffff04 	addi	r3,r2,-4
 d012e08:	e0bffb17 	ldw	r2,-20(fp)
 d012e0c:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 d012e10:	e0bffb17 	ldw	r2,-20(fp)
 d012e14:	10c00417 	ldw	r3,16(r2)
 d012e18:	e0bffd17 	ldw	r2,-12(fp)
 d012e1c:	18800015 	stw	r2,0(r3)
 d012e20:	00001006 	br	d012e64 <OSQPostOpt+0x1f0>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 d012e24:	e0bffb17 	ldw	r2,-20(fp)
 d012e28:	10c00317 	ldw	r3,12(r2)
 d012e2c:	e0bffd17 	ldw	r2,-12(fp)
 d012e30:	18800015 	stw	r2,0(r3)
 d012e34:	18c00104 	addi	r3,r3,4
 d012e38:	e0bffb17 	ldw	r2,-20(fp)
 d012e3c:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 d012e40:	e0bffb17 	ldw	r2,-20(fp)
 d012e44:	10c00317 	ldw	r3,12(r2)
 d012e48:	e0bffb17 	ldw	r2,-20(fp)
 d012e4c:	10800217 	ldw	r2,8(r2)
 d012e50:	1880041e 	bne	r3,r2,d012e64 <OSQPostOpt+0x1f0>
            pq->OSQIn = pq->OSQStart;
 d012e54:	e0bffb17 	ldw	r2,-20(fp)
 d012e58:	10c00117 	ldw	r3,4(r2)
 d012e5c:	e0bffb17 	ldw	r2,-20(fp)
 d012e60:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 d012e64:	e0bffb17 	ldw	r2,-20(fp)
 d012e68:	1080058b 	ldhu	r2,22(r2)
 d012e6c:	10800044 	addi	r2,r2,1
 d012e70:	1007883a 	mov	r3,r2
 d012e74:	e0bffb17 	ldw	r2,-20(fp)
 d012e78:	10c0058d 	sth	r3,22(r2)
 d012e7c:	e0bffa17 	ldw	r2,-24(fp)
 d012e80:	e0bff615 	stw	r2,-40(fp)
 d012e84:	e0bff617 	ldw	r2,-40(fp)
 d012e88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d012e8c:	e03fff15 	stw	zero,-4(fp)
 d012e90:	e0bfff17 	ldw	r2,-4(fp)
}
 d012e94:	e037883a 	mov	sp,fp
 d012e98:	dfc00117 	ldw	ra,4(sp)
 d012e9c:	df000017 	ldw	fp,0(sp)
 d012ea0:	dec00204 	addi	sp,sp,8
 d012ea4:	f800283a 	ret

0d012ea8 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 d012ea8:	defff504 	addi	sp,sp,-44
 d012eac:	df000a15 	stw	fp,40(sp)
 d012eb0:	df000a04 	addi	fp,sp,40
 d012eb4:	e13ffd15 	stw	r4,-12(fp)
 d012eb8:	e17ffe15 	stw	r5,-8(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d012ebc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 d012ec0:	e0bffd17 	ldw	r2,-12(fp)
 d012ec4:	1004c03a 	cmpne	r2,r2,zero
 d012ec8:	1000031e 	bne	r2,zero,d012ed8 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 d012ecc:	00800104 	movi	r2,4
 d012ed0:	e0bfff15 	stw	r2,-4(fp)
 d012ed4:	00004f06 	br	d013014 <OSQQuery+0x16c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 d012ed8:	e0bffe17 	ldw	r2,-8(fp)
 d012edc:	1004c03a 	cmpne	r2,r2,zero
 d012ee0:	1000031e 	bne	r2,zero,d012ef0 <OSQQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 d012ee4:	00800244 	movi	r2,9
 d012ee8:	e0bfff15 	stw	r2,-4(fp)
 d012eec:	00004906 	br	d013014 <OSQQuery+0x16c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 d012ef0:	e0bffd17 	ldw	r2,-12(fp)
 d012ef4:	10800003 	ldbu	r2,0(r2)
 d012ef8:	10803fcc 	andi	r2,r2,255
 d012efc:	108000a0 	cmpeqi	r2,r2,2
 d012f00:	1000031e 	bne	r2,zero,d012f10 <OSQQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 d012f04:	00800044 	movi	r2,1
 d012f08:	e0bfff15 	stw	r2,-4(fp)
 d012f0c:	00004106 	br	d013014 <OSQQuery+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012f10:	0005303a 	rdctl	r2,status
 d012f14:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012f18:	e0fff717 	ldw	r3,-36(fp)
 d012f1c:	00bfff84 	movi	r2,-2
 d012f20:	1884703a 	and	r2,r3,r2
 d012f24:	1001703a 	wrctl	status,r2
  
  return context;
 d012f28:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 d012f2c:	e0bff815 	stw	r2,-32(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 d012f30:	e0bffd17 	ldw	r2,-12(fp)
 d012f34:	10c00283 	ldbu	r3,10(r2)
 d012f38:	e0bffe17 	ldw	r2,-8(fp)
 d012f3c:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 d012f40:	e0bffd17 	ldw	r2,-12(fp)
 d012f44:	108002c4 	addi	r2,r2,11
 d012f48:	e0bffa15 	stw	r2,-24(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 d012f4c:	e0bffe17 	ldw	r2,-8(fp)
 d012f50:	10800204 	addi	r2,r2,8
 d012f54:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d012f58:	e03ffb05 	stb	zero,-20(fp)
 d012f5c:	00000d06 	br	d012f94 <OSQQuery+0xec>
        *pdest++ = *psrc++;
 d012f60:	e0bffa17 	ldw	r2,-24(fp)
 d012f64:	10c00003 	ldbu	r3,0(r2)
 d012f68:	e0bff917 	ldw	r2,-28(fp)
 d012f6c:	10c00005 	stb	r3,0(r2)
 d012f70:	e0bff917 	ldw	r2,-28(fp)
 d012f74:	10800044 	addi	r2,r2,1
 d012f78:	e0bff915 	stw	r2,-28(fp)
 d012f7c:	e0bffa17 	ldw	r2,-24(fp)
 d012f80:	10800044 	addi	r2,r2,1
 d012f84:	e0bffa15 	stw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d012f88:	e0bffb03 	ldbu	r2,-20(fp)
 d012f8c:	10800044 	addi	r2,r2,1
 d012f90:	e0bffb05 	stb	r2,-20(fp)
 d012f94:	e0bffb03 	ldbu	r2,-20(fp)
 d012f98:	108000f0 	cmpltui	r2,r2,3
 d012f9c:	103ff01e 	bne	r2,zero,d012f60 <OSQQuery+0xb8>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 d012fa0:	e0bffd17 	ldw	r2,-12(fp)
 d012fa4:	10800117 	ldw	r2,4(r2)
 d012fa8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 d012fac:	e0bffc17 	ldw	r2,-16(fp)
 d012fb0:	1080058b 	ldhu	r2,22(r2)
 d012fb4:	10bfffcc 	andi	r2,r2,65535
 d012fb8:	1005003a 	cmpeq	r2,r2,zero
 d012fbc:	1000061e 	bne	r2,zero,d012fd8 <OSQQuery+0x130>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 d012fc0:	e0bffc17 	ldw	r2,-16(fp)
 d012fc4:	10800417 	ldw	r2,16(r2)
 d012fc8:	10c00017 	ldw	r3,0(r2)
 d012fcc:	e0bffe17 	ldw	r2,-8(fp)
 d012fd0:	10c00015 	stw	r3,0(r2)
 d012fd4:	00000206 	br	d012fe0 <OSQQuery+0x138>
    } else {
        p_q_data->OSMsg = (void *)0;
 d012fd8:	e0bffe17 	ldw	r2,-8(fp)
 d012fdc:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 d012fe0:	e0bffc17 	ldw	r2,-16(fp)
 d012fe4:	10c0058b 	ldhu	r3,22(r2)
 d012fe8:	e0bffe17 	ldw	r2,-8(fp)
 d012fec:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 d012ff0:	e0bffc17 	ldw	r2,-16(fp)
 d012ff4:	10c0050b 	ldhu	r3,20(r2)
 d012ff8:	e0bffe17 	ldw	r2,-8(fp)
 d012ffc:	10c0018d 	sth	r3,6(r2)
 d013000:	e0bff817 	ldw	r2,-32(fp)
 d013004:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013008:	e0bff617 	ldw	r2,-40(fp)
 d01300c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d013010:	e03fff15 	stw	zero,-4(fp)
 d013014:	e0bfff17 	ldw	r2,-4(fp)
}
 d013018:	e037883a 	mov	sp,fp
 d01301c:	df000017 	ldw	fp,0(sp)
 d013020:	dec00104 	addi	sp,sp,4
 d013024:	f800283a 	ret

0d013028 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 d013028:	defffb04 	addi	sp,sp,-20
 d01302c:	dfc00415 	stw	ra,16(sp)
 d013030:	df000315 	stw	fp,12(sp)
 d013034:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 d013038:	010341b4 	movhi	r4,3334
 d01303c:	213b2404 	addi	r4,r4,-4976
 d013040:	01407804 	movi	r5,480
 d013044:	d00f3240 	call	d00f324 <OS_MemClr>
    pq1 = &OSQTbl[0];
 d013048:	008341b4 	movhi	r2,3334
 d01304c:	10bb2404 	addi	r2,r2,-4976
 d013050:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 d013054:	008341b4 	movhi	r2,3334
 d013058:	10bb2a04 	addi	r2,r2,-4952
 d01305c:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 d013060:	e03fff0d 	sth	zero,-4(fp)
 d013064:	00000c06 	br	d013098 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 d013068:	e0fffe17 	ldw	r3,-8(fp)
 d01306c:	e0bffd17 	ldw	r2,-12(fp)
 d013070:	18800015 	stw	r2,0(r3)
        pq1++;
 d013074:	e0bffe17 	ldw	r2,-8(fp)
 d013078:	10800604 	addi	r2,r2,24
 d01307c:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 d013080:	e0bffd17 	ldw	r2,-12(fp)
 d013084:	10800604 	addi	r2,r2,24
 d013088:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 d01308c:	e0bfff0b 	ldhu	r2,-4(fp)
 d013090:	10800044 	addi	r2,r2,1
 d013094:	e0bfff0d 	sth	r2,-4(fp)
 d013098:	e0bfff0b 	ldhu	r2,-4(fp)
 d01309c:	108004f0 	cmpltui	r2,r2,19
 d0130a0:	103ff11e 	bne	r2,zero,d013068 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 d0130a4:	e0bffe17 	ldw	r2,-8(fp)
 d0130a8:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 d0130ac:	00c34174 	movhi	r3,3333
 d0130b0:	18db1404 	addi	r3,r3,27728
 d0130b4:	008341b4 	movhi	r2,3334
 d0130b8:	10bb2404 	addi	r2,r2,-4976
 d0130bc:	18800015 	stw	r2,0(r3)
#endif
}
 d0130c0:	e037883a 	mov	sp,fp
 d0130c4:	dfc00117 	ldw	ra,4(sp)
 d0130c8:	df000017 	ldw	fp,0(sp)
 d0130cc:	dec00204 	addi	sp,sp,8
 d0130d0:	f800283a 	ret

0d0130d4 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 d0130d4:	defff904 	addi	sp,sp,-28
 d0130d8:	df000615 	stw	fp,24(sp)
 d0130dc:	df000604 	addi	fp,sp,24
 d0130e0:	e13ffe15 	stw	r4,-8(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0130e4:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d0130e8:	e0bffe17 	ldw	r2,-8(fp)
 d0130ec:	1004c03a 	cmpne	r2,r2,zero
 d0130f0:	1000021e 	bne	r2,zero,d0130fc <OSSemAccept+0x28>
        return (0);
 d0130f4:	e03fff15 	stw	zero,-4(fp)
 d0130f8:	00002106 	br	d013180 <OSSemAccept+0xac>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d0130fc:	e0bffe17 	ldw	r2,-8(fp)
 d013100:	10800003 	ldbu	r2,0(r2)
 d013104:	10803fcc 	andi	r2,r2,255
 d013108:	108000e0 	cmpeqi	r2,r2,3
 d01310c:	1000021e 	bne	r2,zero,d013118 <OSSemAccept+0x44>
        return (0);
 d013110:	e03fff15 	stw	zero,-4(fp)
 d013114:	00001a06 	br	d013180 <OSSemAccept+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013118:	0005303a 	rdctl	r2,status
 d01311c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013120:	e0fffb17 	ldw	r3,-20(fp)
 d013124:	00bfff84 	movi	r2,-2
 d013128:	1884703a 	and	r2,r3,r2
 d01312c:	1001703a 	wrctl	status,r2
  
  return context;
 d013130:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d013134:	e0bffc15 	stw	r2,-16(fp)
    cnt = pevent->OSEventCnt;
 d013138:	e0bffe17 	ldw	r2,-8(fp)
 d01313c:	1080020b 	ldhu	r2,8(r2)
 d013140:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 d013144:	e0bffd0b 	ldhu	r2,-12(fp)
 d013148:	1005003a 	cmpeq	r2,r2,zero
 d01314c:	1000061e 	bne	r2,zero,d013168 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 d013150:	e0bffe17 	ldw	r2,-8(fp)
 d013154:	1080020b 	ldhu	r2,8(r2)
 d013158:	10bfffc4 	addi	r2,r2,-1
 d01315c:	1007883a 	mov	r3,r2
 d013160:	e0bffe17 	ldw	r2,-8(fp)
 d013164:	10c0020d 	sth	r3,8(r2)
 d013168:	e0bffc17 	ldw	r2,-16(fp)
 d01316c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013170:	e0bffa17 	ldw	r2,-24(fp)
 d013174:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 d013178:	e0bffd0b 	ldhu	r2,-12(fp)
 d01317c:	e0bfff15 	stw	r2,-4(fp)
 d013180:	e0bfff17 	ldw	r2,-4(fp)
}
 d013184:	e037883a 	mov	sp,fp
 d013188:	df000017 	ldw	fp,0(sp)
 d01318c:	dec00104 	addi	sp,sp,4
 d013190:	f800283a 	ret

0d013194 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 d013194:	defff804 	addi	sp,sp,-32
 d013198:	dfc00715 	stw	ra,28(sp)
 d01319c:	df000615 	stw	fp,24(sp)
 d0131a0:	df000604 	addi	fp,sp,24
 d0131a4:	e13ffe0d 	sth	r4,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d0131a8:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d0131ac:	00834174 	movhi	r2,3333
 d0131b0:	109b1704 	addi	r2,r2,27740
 d0131b4:	10800003 	ldbu	r2,0(r2)
 d0131b8:	10803fcc 	andi	r2,r2,255
 d0131bc:	1005003a 	cmpeq	r2,r2,zero
 d0131c0:	1000021e 	bne	r2,zero,d0131cc <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 d0131c4:	e03fff15 	stw	zero,-4(fp)
 d0131c8:	00003106 	br	d013290 <OSSemCreate+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0131cc:	0005303a 	rdctl	r2,status
 d0131d0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0131d4:	e0fffb17 	ldw	r3,-20(fp)
 d0131d8:	00bfff84 	movi	r2,-2
 d0131dc:	1884703a 	and	r2,r3,r2
 d0131e0:	1001703a 	wrctl	status,r2
  
  return context;
 d0131e4:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d0131e8:	e0bffc15 	stw	r2,-16(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 d0131ec:	00834174 	movhi	r2,3333
 d0131f0:	109b1604 	addi	r2,r2,27736
 d0131f4:	10800017 	ldw	r2,0(r2)
 d0131f8:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 d0131fc:	00834174 	movhi	r2,3333
 d013200:	109b1604 	addi	r2,r2,27736
 d013204:	10800017 	ldw	r2,0(r2)
 d013208:	1005003a 	cmpeq	r2,r2,zero
 d01320c:	1000081e 	bne	r2,zero,d013230 <OSSemCreate+0x9c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 d013210:	00834174 	movhi	r2,3333
 d013214:	109b1604 	addi	r2,r2,27736
 d013218:	10800017 	ldw	r2,0(r2)
 d01321c:	10800117 	ldw	r2,4(r2)
 d013220:	1007883a 	mov	r3,r2
 d013224:	00834174 	movhi	r2,3333
 d013228:	109b1604 	addi	r2,r2,27736
 d01322c:	10c00015 	stw	r3,0(r2)
 d013230:	e0bffc17 	ldw	r2,-16(fp)
 d013234:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013238:	e0bffa17 	ldw	r2,-24(fp)
 d01323c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 d013240:	e0bffd17 	ldw	r2,-12(fp)
 d013244:	1005003a 	cmpeq	r2,r2,zero
 d013248:	10000f1e 	bne	r2,zero,d013288 <OSSemCreate+0xf4>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 d01324c:	e0fffd17 	ldw	r3,-12(fp)
 d013250:	008000c4 	movi	r2,3
 d013254:	18800005 	stb	r2,0(r3)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 d013258:	e0fffd17 	ldw	r3,-12(fp)
 d01325c:	e0bffe0b 	ldhu	r2,-8(fp)
 d013260:	1880020d 	sth	r2,8(r3)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 d013264:	e0bffd17 	ldw	r2,-12(fp)
 d013268:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 d01326c:	e0fffd17 	ldw	r3,-12(fp)
 d013270:	00800fc4 	movi	r2,63
 d013274:	18800385 	stb	r2,14(r3)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 d013278:	e0bffd17 	ldw	r2,-12(fp)
 d01327c:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 d013280:	e13ffd17 	ldw	r4,-12(fp)
 d013284:	d00ef580 	call	d00ef58 <OS_EventWaitListInit>
    }
    return (pevent);
 d013288:	e0bffd17 	ldw	r2,-12(fp)
 d01328c:	e0bfff15 	stw	r2,-4(fp)
 d013290:	e0bfff17 	ldw	r2,-4(fp)
}
 d013294:	e037883a 	mov	sp,fp
 d013298:	dfc00117 	ldw	ra,4(sp)
 d01329c:	df000017 	ldw	fp,0(sp)
 d0132a0:	dec00204 	addi	sp,sp,8
 d0132a4:	f800283a 	ret

0d0132a8 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d0132a8:	defff104 	addi	sp,sp,-60
 d0132ac:	dfc00e15 	stw	ra,56(sp)
 d0132b0:	df000d15 	stw	fp,52(sp)
 d0132b4:	df000d04 	addi	fp,sp,52
 d0132b8:	e13ffb15 	stw	r4,-20(fp)
 d0132bc:	e1bffd15 	stw	r6,-12(fp)
 d0132c0:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d0132c4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d0132c8:	e0bffd17 	ldw	r2,-12(fp)
 d0132cc:	1004c03a 	cmpne	r2,r2,zero
 d0132d0:	1000031e 	bne	r2,zero,d0132e0 <OSSemDel+0x38>
        return (pevent);
 d0132d4:	e0bffb17 	ldw	r2,-20(fp)
 d0132d8:	e0bfff15 	stw	r2,-4(fp)
 d0132dc:	00009406 	br	d013530 <OSSemDel+0x288>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d0132e0:	e0bffb17 	ldw	r2,-20(fp)
 d0132e4:	1004c03a 	cmpne	r2,r2,zero
 d0132e8:	1000061e 	bne	r2,zero,d013304 <OSSemDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 d0132ec:	e0fffd17 	ldw	r3,-12(fp)
 d0132f0:	00800104 	movi	r2,4
 d0132f4:	18800005 	stb	r2,0(r3)
        return (pevent);
 d0132f8:	e0fffb17 	ldw	r3,-20(fp)
 d0132fc:	e0ffff15 	stw	r3,-4(fp)
 d013300:	00008b06 	br	d013530 <OSSemDel+0x288>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 d013304:	e0bffb17 	ldw	r2,-20(fp)
 d013308:	10800003 	ldbu	r2,0(r2)
 d01330c:	10803fcc 	andi	r2,r2,255
 d013310:	108000e0 	cmpeqi	r2,r2,3
 d013314:	1000061e 	bne	r2,zero,d013330 <OSSemDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 d013318:	e0fffd17 	ldw	r3,-12(fp)
 d01331c:	00800044 	movi	r2,1
 d013320:	18800005 	stb	r2,0(r3)
        return (pevent);
 d013324:	e0bffb17 	ldw	r2,-20(fp)
 d013328:	e0bfff15 	stw	r2,-4(fp)
 d01332c:	00008006 	br	d013530 <OSSemDel+0x288>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d013330:	00834174 	movhi	r2,3333
 d013334:	109b1704 	addi	r2,r2,27740
 d013338:	10800003 	ldbu	r2,0(r2)
 d01333c:	10803fcc 	andi	r2,r2,255
 d013340:	1005003a 	cmpeq	r2,r2,zero
 d013344:	1000061e 	bne	r2,zero,d013360 <OSSemDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 d013348:	e0fffd17 	ldw	r3,-12(fp)
 d01334c:	008003c4 	movi	r2,15
 d013350:	18800005 	stb	r2,0(r3)
        return (pevent);
 d013354:	e0fffb17 	ldw	r3,-20(fp)
 d013358:	e0ffff15 	stw	r3,-4(fp)
 d01335c:	00007406 	br	d013530 <OSSemDel+0x288>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013360:	0005303a 	rdctl	r2,status
 d013364:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013368:	e0fff717 	ldw	r3,-36(fp)
 d01336c:	00bfff84 	movi	r2,-2
 d013370:	1884703a 	and	r2,r3,r2
 d013374:	1001703a 	wrctl	status,r2
  
  return context;
 d013378:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 d01337c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 d013380:	e0bffb17 	ldw	r2,-20(fp)
 d013384:	10800283 	ldbu	r2,10(r2)
 d013388:	10803fcc 	andi	r2,r2,255
 d01338c:	1005003a 	cmpeq	r2,r2,zero
 d013390:	1000031e 	bne	r2,zero,d0133a0 <OSSemDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 d013394:	00800044 	movi	r2,1
 d013398:	e0bffa05 	stb	r2,-24(fp)
 d01339c:	00000106 	br	d0133a4 <OSSemDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 d0133a0:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 d0133a4:	e0bffc03 	ldbu	r2,-16(fp)
 d0133a8:	e0bffe15 	stw	r2,-8(fp)
 d0133ac:	e0fffe17 	ldw	r3,-8(fp)
 d0133b0:	1805003a 	cmpeq	r2,r3,zero
 d0133b4:	1000041e 	bne	r2,zero,d0133c8 <OSSemDel+0x120>
 d0133b8:	e0fffe17 	ldw	r3,-8(fp)
 d0133bc:	18800060 	cmpeqi	r2,r3,1
 d0133c0:	10002d1e 	bne	r2,zero,d013478 <OSSemDel+0x1d0>
 d0133c4:	00004f06 	br	d013504 <OSSemDel+0x25c>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 d0133c8:	e0bffa03 	ldbu	r2,-24(fp)
 d0133cc:	1004c03a 	cmpne	r2,r2,zero
 d0133d0:	10001a1e 	bne	r2,zero,d01343c <OSSemDel+0x194>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 d0133d4:	e0fffb17 	ldw	r3,-20(fp)
 d0133d8:	00800fc4 	movi	r2,63
 d0133dc:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 d0133e0:	e0bffb17 	ldw	r2,-20(fp)
 d0133e4:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d0133e8:	e0bffb17 	ldw	r2,-20(fp)
 d0133ec:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 d0133f0:	00834174 	movhi	r2,3333
 d0133f4:	109b1604 	addi	r2,r2,27736
 d0133f8:	10c00017 	ldw	r3,0(r2)
 d0133fc:	e0bffb17 	ldw	r2,-20(fp)
 d013400:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 d013404:	e0bffb17 	ldw	r2,-20(fp)
 d013408:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 d01340c:	00c34174 	movhi	r3,3333
 d013410:	18db1604 	addi	r3,r3,27736
 d013414:	e0bffb17 	ldw	r2,-20(fp)
 d013418:	18800015 	stw	r2,0(r3)
 d01341c:	e0bff817 	ldw	r2,-32(fp)
 d013420:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013424:	e0bff617 	ldw	r2,-40(fp)
 d013428:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 d01342c:	e0bffd17 	ldw	r2,-12(fp)
 d013430:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 d013434:	e03ff915 	stw	zero,-28(fp)
 d013438:	00003b06 	br	d013528 <OSSemDel+0x280>
 d01343c:	e0bff817 	ldw	r2,-32(fp)
 d013440:	e0bff515 	stw	r2,-44(fp)
 d013444:	e0bff517 	ldw	r2,-44(fp)
 d013448:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 d01344c:	e0fffd17 	ldw	r3,-12(fp)
 d013450:	00801244 	movi	r2,73
 d013454:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 d013458:	e0bffb17 	ldw	r2,-20(fp)
 d01345c:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 d013460:	00003106 	br	d013528 <OSSemDel+0x280>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 d013464:	e13ffb17 	ldw	r4,-20(fp)
 d013468:	000b883a 	mov	r5,zero
 d01346c:	01800044 	movi	r6,1
 d013470:	000f883a 	mov	r7,zero
 d013474:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 d013478:	e0bffb17 	ldw	r2,-20(fp)
 d01347c:	10800283 	ldbu	r2,10(r2)
 d013480:	10803fcc 	andi	r2,r2,255
 d013484:	1004c03a 	cmpne	r2,r2,zero
 d013488:	103ff61e 	bne	r2,zero,d013464 <OSSemDel+0x1bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 d01348c:	e0fffb17 	ldw	r3,-20(fp)
 d013490:	00800fc4 	movi	r2,63
 d013494:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 d013498:	e0bffb17 	ldw	r2,-20(fp)
 d01349c:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d0134a0:	e0bffb17 	ldw	r2,-20(fp)
 d0134a4:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 d0134a8:	00834174 	movhi	r2,3333
 d0134ac:	109b1604 	addi	r2,r2,27736
 d0134b0:	10c00017 	ldw	r3,0(r2)
 d0134b4:	e0bffb17 	ldw	r2,-20(fp)
 d0134b8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 d0134bc:	e0bffb17 	ldw	r2,-20(fp)
 d0134c0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 d0134c4:	00c34174 	movhi	r3,3333
 d0134c8:	18db1604 	addi	r3,r3,27736
 d0134cc:	e0bffb17 	ldw	r2,-20(fp)
 d0134d0:	18800015 	stw	r2,0(r3)
 d0134d4:	e0bff817 	ldw	r2,-32(fp)
 d0134d8:	e0bff415 	stw	r2,-48(fp)
 d0134dc:	e0bff417 	ldw	r2,-48(fp)
 d0134e0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 d0134e4:	e0bffa03 	ldbu	r2,-24(fp)
 d0134e8:	10800058 	cmpnei	r2,r2,1
 d0134ec:	1000011e 	bne	r2,zero,d0134f4 <OSSemDel+0x24c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 d0134f0:	d00f3e40 	call	d00f3e4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 d0134f4:	e0bffd17 	ldw	r2,-12(fp)
 d0134f8:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 d0134fc:	e03ff915 	stw	zero,-28(fp)
             break;
 d013500:	00000906 	br	d013528 <OSSemDel+0x280>
 d013504:	e0bff817 	ldw	r2,-32(fp)
 d013508:	e0bff315 	stw	r2,-52(fp)
 d01350c:	e0bff317 	ldw	r2,-52(fp)
 d013510:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 d013514:	e0fffd17 	ldw	r3,-12(fp)
 d013518:	008001c4 	movi	r2,7
 d01351c:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 d013520:	e0bffb17 	ldw	r2,-20(fp)
 d013524:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 d013528:	e0bff917 	ldw	r2,-28(fp)
 d01352c:	e0bfff15 	stw	r2,-4(fp)
 d013530:	e0bfff17 	ldw	r2,-4(fp)
}
 d013534:	e037883a 	mov	sp,fp
 d013538:	dfc00117 	ldw	ra,4(sp)
 d01353c:	df000017 	ldw	fp,0(sp)
 d013540:	dec00204 	addi	sp,sp,8
 d013544:	f800283a 	ret

0d013548 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 d013548:	defff404 	addi	sp,sp,-48
 d01354c:	dfc00b15 	stw	ra,44(sp)
 d013550:	df000a15 	stw	fp,40(sp)
 d013554:	df000a04 	addi	fp,sp,40
 d013558:	e13ffc15 	stw	r4,-16(fp)
 d01355c:	e1bffe15 	stw	r6,-8(fp)
 d013560:	e17ffd0d 	sth	r5,-12(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d013564:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d013568:	e0bffe17 	ldw	r2,-8(fp)
 d01356c:	1005003a 	cmpeq	r2,r2,zero
 d013570:	10008f1e 	bne	r2,zero,d0137b0 <OSSemPend+0x268>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d013574:	e0bffc17 	ldw	r2,-16(fp)
 d013578:	1004c03a 	cmpne	r2,r2,zero
 d01357c:	1000041e 	bne	r2,zero,d013590 <OSSemPend+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 d013580:	e0fffe17 	ldw	r3,-8(fp)
 d013584:	00800104 	movi	r2,4
 d013588:	18800005 	stb	r2,0(r3)
        return;
 d01358c:	00008806 	br	d0137b0 <OSSemPend+0x268>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d013590:	e0bffc17 	ldw	r2,-16(fp)
 d013594:	10800003 	ldbu	r2,0(r2)
 d013598:	10803fcc 	andi	r2,r2,255
 d01359c:	108000e0 	cmpeqi	r2,r2,3
 d0135a0:	1000041e 	bne	r2,zero,d0135b4 <OSSemPend+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 d0135a4:	e0fffe17 	ldw	r3,-8(fp)
 d0135a8:	00800044 	movi	r2,1
 d0135ac:	18800005 	stb	r2,0(r3)
        return;
 d0135b0:	00007f06 	br	d0137b0 <OSSemPend+0x268>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 d0135b4:	00834174 	movhi	r2,3333
 d0135b8:	109b1704 	addi	r2,r2,27740
 d0135bc:	10800003 	ldbu	r2,0(r2)
 d0135c0:	10803fcc 	andi	r2,r2,255
 d0135c4:	1005003a 	cmpeq	r2,r2,zero
 d0135c8:	1000041e 	bne	r2,zero,d0135dc <OSSemPend+0x94>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 d0135cc:	e0fffe17 	ldw	r3,-8(fp)
 d0135d0:	00800084 	movi	r2,2
 d0135d4:	18800005 	stb	r2,0(r3)
        return;
 d0135d8:	00007506 	br	d0137b0 <OSSemPend+0x268>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 d0135dc:	00834174 	movhi	r2,3333
 d0135e0:	109b0904 	addi	r2,r2,27684
 d0135e4:	10800003 	ldbu	r2,0(r2)
 d0135e8:	10803fcc 	andi	r2,r2,255
 d0135ec:	1005003a 	cmpeq	r2,r2,zero
 d0135f0:	1000041e 	bne	r2,zero,d013604 <OSSemPend+0xbc>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 d0135f4:	e0fffe17 	ldw	r3,-8(fp)
 d0135f8:	00800344 	movi	r2,13
 d0135fc:	18800005 	stb	r2,0(r3)
        return;
 d013600:	00006b06 	br	d0137b0 <OSSemPend+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013604:	0005303a 	rdctl	r2,status
 d013608:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01360c:	e0fffa17 	ldw	r3,-24(fp)
 d013610:	00bfff84 	movi	r2,-2
 d013614:	1884703a 	and	r2,r3,r2
 d013618:	1001703a 	wrctl	status,r2
  
  return context;
 d01361c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d013620:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 d013624:	e0bffc17 	ldw	r2,-16(fp)
 d013628:	1080020b 	ldhu	r2,8(r2)
 d01362c:	10bfffcc 	andi	r2,r2,65535
 d013630:	1005003a 	cmpeq	r2,r2,zero
 d013634:	10000d1e 	bne	r2,zero,d01366c <OSSemPend+0x124>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 d013638:	e0bffc17 	ldw	r2,-16(fp)
 d01363c:	1080020b 	ldhu	r2,8(r2)
 d013640:	10bfffc4 	addi	r2,r2,-1
 d013644:	1007883a 	mov	r3,r2
 d013648:	e0bffc17 	ldw	r2,-16(fp)
 d01364c:	10c0020d 	sth	r3,8(r2)
 d013650:	e0bffb17 	ldw	r2,-20(fp)
 d013654:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013658:	e0bff917 	ldw	r2,-28(fp)
 d01365c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 d013660:	e0bffe17 	ldw	r2,-8(fp)
 d013664:	10000005 	stb	zero,0(r2)
        return;
 d013668:	00005106 	br	d0137b0 <OSSemPend+0x268>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 d01366c:	00834174 	movhi	r2,3333
 d013670:	109b1804 	addi	r2,r2,27744
 d013674:	10c00017 	ldw	r3,0(r2)
 d013678:	00834174 	movhi	r2,3333
 d01367c:	109b1804 	addi	r2,r2,27744
 d013680:	10800017 	ldw	r2,0(r2)
 d013684:	10800c03 	ldbu	r2,48(r2)
 d013688:	10800054 	ori	r2,r2,1
 d01368c:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d013690:	00834174 	movhi	r2,3333
 d013694:	109b1804 	addi	r2,r2,27744
 d013698:	10800017 	ldw	r2,0(r2)
 d01369c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 d0136a0:	00834174 	movhi	r2,3333
 d0136a4:	109b1804 	addi	r2,r2,27744
 d0136a8:	10c00017 	ldw	r3,0(r2)
 d0136ac:	e0bffd0b 	ldhu	r2,-12(fp)
 d0136b0:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 d0136b4:	e13ffc17 	ldw	r4,-16(fp)
 d0136b8:	d00eb380 	call	d00eb38 <OS_EventTaskWait>
 d0136bc:	e0bffb17 	ldw	r2,-20(fp)
 d0136c0:	e0bff815 	stw	r2,-32(fp)
 d0136c4:	e0bff817 	ldw	r2,-32(fp)
 d0136c8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 d0136cc:	d00f3e40 	call	d00f3e4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0136d0:	0005303a 	rdctl	r2,status
 d0136d4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0136d8:	e0fff717 	ldw	r3,-36(fp)
 d0136dc:	00bfff84 	movi	r2,-2
 d0136e0:	1884703a 	and	r2,r3,r2
 d0136e4:	1001703a 	wrctl	status,r2
  
  return context;
 d0136e8:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 d0136ec:	e0bffb15 	stw	r2,-20(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 d0136f0:	00834174 	movhi	r2,3333
 d0136f4:	109b1804 	addi	r2,r2,27744
 d0136f8:	10800017 	ldw	r2,0(r2)
 d0136fc:	10800c43 	ldbu	r2,49(r2)
 d013700:	10803fcc 	andi	r2,r2,255
 d013704:	e0bfff15 	stw	r2,-4(fp)
 d013708:	e0ffff17 	ldw	r3,-4(fp)
 d01370c:	1805003a 	cmpeq	r2,r3,zero
 d013710:	1000041e 	bne	r2,zero,d013724 <OSSemPend+0x1dc>
 d013714:	e0ffff17 	ldw	r3,-4(fp)
 d013718:	188000a0 	cmpeqi	r2,r3,2
 d01371c:	1000041e 	bne	r2,zero,d013730 <OSSemPend+0x1e8>
 d013720:	00000706 	br	d013740 <OSSemPend+0x1f8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 d013724:	e0bffe17 	ldw	r2,-8(fp)
 d013728:	10000005 	stb	zero,0(r2)
             break;
 d01372c:	00000c06 	br	d013760 <OSSemPend+0x218>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 d013730:	e0fffe17 	ldw	r3,-8(fp)
 d013734:	00800384 	movi	r2,14
 d013738:	18800005 	stb	r2,0(r3)
             break;
 d01373c:	00000806 	br	d013760 <OSSemPend+0x218>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 d013740:	00834174 	movhi	r2,3333
 d013744:	109b1804 	addi	r2,r2,27744
 d013748:	11000017 	ldw	r4,0(r2)
 d01374c:	e17ffc17 	ldw	r5,-16(fp)
 d013750:	d00ed9c0 	call	d00ed9c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 d013754:	e0fffe17 	ldw	r3,-8(fp)
 d013758:	00800284 	movi	r2,10
 d01375c:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 d013760:	00834174 	movhi	r2,3333
 d013764:	109b1804 	addi	r2,r2,27744
 d013768:	10800017 	ldw	r2,0(r2)
 d01376c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 d013770:	00834174 	movhi	r2,3333
 d013774:	109b1804 	addi	r2,r2,27744
 d013778:	10800017 	ldw	r2,0(r2)
 d01377c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 d013780:	00834174 	movhi	r2,3333
 d013784:	109b1804 	addi	r2,r2,27744
 d013788:	10800017 	ldw	r2,0(r2)
 d01378c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 d013790:	00834174 	movhi	r2,3333
 d013794:	109b1804 	addi	r2,r2,27744
 d013798:	10800017 	ldw	r2,0(r2)
 d01379c:	10000815 	stw	zero,32(r2)
 d0137a0:	e0bffb17 	ldw	r2,-20(fp)
 d0137a4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0137a8:	e0bff617 	ldw	r2,-40(fp)
 d0137ac:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
}
 d0137b0:	e037883a 	mov	sp,fp
 d0137b4:	dfc00117 	ldw	ra,4(sp)
 d0137b8:	df000017 	ldw	fp,0(sp)
 d0137bc:	dec00204 	addi	sp,sp,8
 d0137c0:	f800283a 	ret

0d0137c4 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d0137c4:	defff504 	addi	sp,sp,-44
 d0137c8:	dfc00a15 	stw	ra,40(sp)
 d0137cc:	df000915 	stw	fp,36(sp)
 d0137d0:	df000904 	addi	fp,sp,36
 d0137d4:	e13ffc15 	stw	r4,-16(fp)
 d0137d8:	e1bffe15 	stw	r6,-8(fp)
 d0137dc:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0137e0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d0137e4:	e0bffe17 	ldw	r2,-8(fp)
 d0137e8:	1004c03a 	cmpne	r2,r2,zero
 d0137ec:	1000021e 	bne	r2,zero,d0137f8 <OSSemPendAbort+0x34>
        return (0);
 d0137f0:	e03fff15 	stw	zero,-4(fp)
 d0137f4:	00004c06 	br	d013928 <OSSemPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d0137f8:	e0bffc17 	ldw	r2,-16(fp)
 d0137fc:	1004c03a 	cmpne	r2,r2,zero
 d013800:	1000051e 	bne	r2,zero,d013818 <OSSemPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d013804:	e0fffe17 	ldw	r3,-8(fp)
 d013808:	00800104 	movi	r2,4
 d01380c:	18800005 	stb	r2,0(r3)
        return (0);
 d013810:	e03fff15 	stw	zero,-4(fp)
 d013814:	00004406 	br	d013928 <OSSemPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d013818:	e0bffc17 	ldw	r2,-16(fp)
 d01381c:	10800003 	ldbu	r2,0(r2)
 d013820:	10803fcc 	andi	r2,r2,255
 d013824:	108000e0 	cmpeqi	r2,r2,3
 d013828:	1000051e 	bne	r2,zero,d013840 <OSSemPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d01382c:	e0fffe17 	ldw	r3,-8(fp)
 d013830:	00800044 	movi	r2,1
 d013834:	18800005 	stb	r2,0(r3)
        return (0);
 d013838:	e03fff15 	stw	zero,-4(fp)
 d01383c:	00003a06 	br	d013928 <OSSemPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013840:	0005303a 	rdctl	r2,status
 d013844:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013848:	e0fff917 	ldw	r3,-28(fp)
 d01384c:	00bfff84 	movi	r2,-2
 d013850:	1884703a 	and	r2,r3,r2
 d013854:	1001703a 	wrctl	status,r2
  
  return context;
 d013858:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d01385c:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 d013860:	e0bffc17 	ldw	r2,-16(fp)
 d013864:	10800283 	ldbu	r2,10(r2)
 d013868:	10803fcc 	andi	r2,r2,255
 d01386c:	1005003a 	cmpeq	r2,r2,zero
 d013870:	1000261e 	bne	r2,zero,d01390c <OSSemPendAbort+0x148>
        nbr_tasks = 0;
 d013874:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 d013878:	e0bffd03 	ldbu	r2,-12(fp)
 d01387c:	10800060 	cmpeqi	r2,r2,1
 d013880:	1000091e 	bne	r2,zero,d0138a8 <OSSemPendAbort+0xe4>
 d013884:	00000e06 	br	d0138c0 <OSSemPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 d013888:	e13ffc17 	ldw	r4,-16(fp)
 d01388c:	000b883a 	mov	r5,zero
 d013890:	01800044 	movi	r6,1
 d013894:	01c00084 	movi	r7,2
 d013898:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
                     nbr_tasks++;
 d01389c:	e0bffb03 	ldbu	r2,-20(fp)
 d0138a0:	10800044 	addi	r2,r2,1
 d0138a4:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 d0138a8:	e0bffc17 	ldw	r2,-16(fp)
 d0138ac:	10800283 	ldbu	r2,10(r2)
 d0138b0:	10803fcc 	andi	r2,r2,255
 d0138b4:	1004c03a 	cmpne	r2,r2,zero
 d0138b8:	103ff31e 	bne	r2,zero,d013888 <OSSemPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 d0138bc:	00000806 	br	d0138e0 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 d0138c0:	e13ffc17 	ldw	r4,-16(fp)
 d0138c4:	000b883a 	mov	r5,zero
 d0138c8:	01800044 	movi	r6,1
 d0138cc:	01c00084 	movi	r7,2
 d0138d0:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
                 nbr_tasks++;
 d0138d4:	e0bffb03 	ldbu	r2,-20(fp)
 d0138d8:	10800044 	addi	r2,r2,1
 d0138dc:	e0bffb05 	stb	r2,-20(fp)
 d0138e0:	e0bffa17 	ldw	r2,-24(fp)
 d0138e4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0138e8:	e0bff817 	ldw	r2,-32(fp)
 d0138ec:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 d0138f0:	d00f3e40 	call	d00f3e4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 d0138f4:	e0fffe17 	ldw	r3,-8(fp)
 d0138f8:	00800384 	movi	r2,14
 d0138fc:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 d013900:	e0bffb03 	ldbu	r2,-20(fp)
 d013904:	e0bfff15 	stw	r2,-4(fp)
 d013908:	00000706 	br	d013928 <OSSemPendAbort+0x164>
 d01390c:	e0bffa17 	ldw	r2,-24(fp)
 d013910:	e0bff715 	stw	r2,-36(fp)
 d013914:	e0bff717 	ldw	r2,-36(fp)
 d013918:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d01391c:	e0bffe17 	ldw	r2,-8(fp)
 d013920:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 d013924:	e03fff15 	stw	zero,-4(fp)
 d013928:	e0bfff17 	ldw	r2,-4(fp)
}
 d01392c:	e037883a 	mov	sp,fp
 d013930:	dfc00117 	ldw	ra,4(sp)
 d013934:	df000017 	ldw	fp,0(sp)
 d013938:	dec00204 	addi	sp,sp,8
 d01393c:	f800283a 	ret

0d013940 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 d013940:	defff704 	addi	sp,sp,-36
 d013944:	dfc00815 	stw	ra,32(sp)
 d013948:	df000715 	stw	fp,28(sp)
 d01394c:	df000704 	addi	fp,sp,28
 d013950:	e13ffe15 	stw	r4,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d013954:	e03ffd15 	stw	zero,-12(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d013958:	e0bffe17 	ldw	r2,-8(fp)
 d01395c:	1004c03a 	cmpne	r2,r2,zero
 d013960:	1000031e 	bne	r2,zero,d013970 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
 d013964:	00800104 	movi	r2,4
 d013968:	e0bfff15 	stw	r2,-4(fp)
 d01396c:	00003806 	br	d013a50 <OSSemPost+0x110>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d013970:	e0bffe17 	ldw	r2,-8(fp)
 d013974:	10800003 	ldbu	r2,0(r2)
 d013978:	10803fcc 	andi	r2,r2,255
 d01397c:	108000e0 	cmpeqi	r2,r2,3
 d013980:	1000031e 	bne	r2,zero,d013990 <OSSemPost+0x50>
        return (OS_ERR_EVENT_TYPE);
 d013984:	00800044 	movi	r2,1
 d013988:	e0bfff15 	stw	r2,-4(fp)
 d01398c:	00003006 	br	d013a50 <OSSemPost+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013990:	0005303a 	rdctl	r2,status
 d013994:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013998:	e0fffc17 	ldw	r3,-16(fp)
 d01399c:	00bfff84 	movi	r2,-2
 d0139a0:	1884703a 	and	r2,r3,r2
 d0139a4:	1001703a 	wrctl	status,r2
  
  return context;
 d0139a8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 d0139ac:	e0bffd15 	stw	r2,-12(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 d0139b0:	e0bffe17 	ldw	r2,-8(fp)
 d0139b4:	10800283 	ldbu	r2,10(r2)
 d0139b8:	10803fcc 	andi	r2,r2,255
 d0139bc:	1005003a 	cmpeq	r2,r2,zero
 d0139c0:	10000c1e 	bne	r2,zero,d0139f4 <OSSemPost+0xb4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 d0139c4:	e13ffe17 	ldw	r4,-8(fp)
 d0139c8:	000b883a 	mov	r5,zero
 d0139cc:	01800044 	movi	r6,1
 d0139d0:	000f883a 	mov	r7,zero
 d0139d4:	d00e9a40 	call	d00e9a4 <OS_EventTaskRdy>
 d0139d8:	e0bffd17 	ldw	r2,-12(fp)
 d0139dc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0139e0:	e0bffb17 	ldw	r2,-20(fp)
 d0139e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 d0139e8:	d00f3e40 	call	d00f3e4 <OS_Sched>
        return (OS_ERR_NONE);
 d0139ec:	e03fff15 	stw	zero,-4(fp)
 d0139f0:	00001706 	br	d013a50 <OSSemPost+0x110>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 d0139f4:	e0bffe17 	ldw	r2,-8(fp)
 d0139f8:	1080020b 	ldhu	r2,8(r2)
 d0139fc:	10ffffcc 	andi	r3,r2,65535
 d013a00:	00bfffd4 	movui	r2,65535
 d013a04:	18800c26 	beq	r3,r2,d013a38 <OSSemPost+0xf8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 d013a08:	e0bffe17 	ldw	r2,-8(fp)
 d013a0c:	1080020b 	ldhu	r2,8(r2)
 d013a10:	10800044 	addi	r2,r2,1
 d013a14:	1007883a 	mov	r3,r2
 d013a18:	e0bffe17 	ldw	r2,-8(fp)
 d013a1c:	10c0020d 	sth	r3,8(r2)
 d013a20:	e0bffd17 	ldw	r2,-12(fp)
 d013a24:	e0bffa15 	stw	r2,-24(fp)
 d013a28:	e0bffa17 	ldw	r2,-24(fp)
 d013a2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 d013a30:	e03fff15 	stw	zero,-4(fp)
 d013a34:	00000606 	br	d013a50 <OSSemPost+0x110>
 d013a38:	e0bffd17 	ldw	r2,-12(fp)
 d013a3c:	e0bff915 	stw	r2,-28(fp)
 d013a40:	e0bff917 	ldw	r2,-28(fp)
 d013a44:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 d013a48:	00800c84 	movi	r2,50
 d013a4c:	e0bfff15 	stw	r2,-4(fp)
 d013a50:	e0bfff17 	ldw	r2,-4(fp)
}
 d013a54:	e037883a 	mov	sp,fp
 d013a58:	dfc00117 	ldw	ra,4(sp)
 d013a5c:	df000017 	ldw	fp,0(sp)
 d013a60:	dec00204 	addi	sp,sp,8
 d013a64:	f800283a 	ret

0d013a68 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 d013a68:	defff604 	addi	sp,sp,-40
 d013a6c:	df000915 	stw	fp,36(sp)
 d013a70:	df000904 	addi	fp,sp,36
 d013a74:	e13ffd15 	stw	r4,-12(fp)
 d013a78:	e17ffe15 	stw	r5,-8(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d013a7c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d013a80:	e0bffd17 	ldw	r2,-12(fp)
 d013a84:	1004c03a 	cmpne	r2,r2,zero
 d013a88:	1000031e 	bne	r2,zero,d013a98 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 d013a8c:	00800104 	movi	r2,4
 d013a90:	e0bfff15 	stw	r2,-4(fp)
 d013a94:	00003b06 	br	d013b84 <OSSemQuery+0x11c>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 d013a98:	e0bffe17 	ldw	r2,-8(fp)
 d013a9c:	1004c03a 	cmpne	r2,r2,zero
 d013aa0:	1000031e 	bne	r2,zero,d013ab0 <OSSemQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 d013aa4:	00800244 	movi	r2,9
 d013aa8:	e0bfff15 	stw	r2,-4(fp)
 d013aac:	00003506 	br	d013b84 <OSSemQuery+0x11c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 d013ab0:	e0bffd17 	ldw	r2,-12(fp)
 d013ab4:	10800003 	ldbu	r2,0(r2)
 d013ab8:	10803fcc 	andi	r2,r2,255
 d013abc:	108000e0 	cmpeqi	r2,r2,3
 d013ac0:	1000031e 	bne	r2,zero,d013ad0 <OSSemQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 d013ac4:	00800044 	movi	r2,1
 d013ac8:	e0bfff15 	stw	r2,-4(fp)
 d013acc:	00002d06 	br	d013b84 <OSSemQuery+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013ad0:	0005303a 	rdctl	r2,status
 d013ad4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013ad8:	e0fff817 	ldw	r3,-32(fp)
 d013adc:	00bfff84 	movi	r2,-2
 d013ae0:	1884703a 	and	r2,r3,r2
 d013ae4:	1001703a 	wrctl	status,r2
  
  return context;
 d013ae8:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 d013aec:	e0bff915 	stw	r2,-28(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 d013af0:	e0bffd17 	ldw	r2,-12(fp)
 d013af4:	10c00283 	ldbu	r3,10(r2)
 d013af8:	e0bffe17 	ldw	r2,-8(fp)
 d013afc:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 d013b00:	e0bffd17 	ldw	r2,-12(fp)
 d013b04:	108002c4 	addi	r2,r2,11
 d013b08:	e0bffc15 	stw	r2,-16(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 d013b0c:	e0bffe17 	ldw	r2,-8(fp)
 d013b10:	10800084 	addi	r2,r2,2
 d013b14:	e0bffb15 	stw	r2,-20(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d013b18:	e03ffa05 	stb	zero,-24(fp)
 d013b1c:	00000d06 	br	d013b54 <OSSemQuery+0xec>
        *pdest++ = *psrc++;
 d013b20:	e0bffc17 	ldw	r2,-16(fp)
 d013b24:	10c00003 	ldbu	r3,0(r2)
 d013b28:	e0bffb17 	ldw	r2,-20(fp)
 d013b2c:	10c00005 	stb	r3,0(r2)
 d013b30:	e0bffb17 	ldw	r2,-20(fp)
 d013b34:	10800044 	addi	r2,r2,1
 d013b38:	e0bffb15 	stw	r2,-20(fp)
 d013b3c:	e0bffc17 	ldw	r2,-16(fp)
 d013b40:	10800044 	addi	r2,r2,1
 d013b44:	e0bffc15 	stw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d013b48:	e0bffa03 	ldbu	r2,-24(fp)
 d013b4c:	10800044 	addi	r2,r2,1
 d013b50:	e0bffa05 	stb	r2,-24(fp)
 d013b54:	e0bffa03 	ldbu	r2,-24(fp)
 d013b58:	108000f0 	cmpltui	r2,r2,3
 d013b5c:	103ff01e 	bne	r2,zero,d013b20 <OSSemQuery+0xb8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 d013b60:	e0bffd17 	ldw	r2,-12(fp)
 d013b64:	10c0020b 	ldhu	r3,8(r2)
 d013b68:	e0bffe17 	ldw	r2,-8(fp)
 d013b6c:	10c0000d 	sth	r3,0(r2)
 d013b70:	e0bff917 	ldw	r2,-28(fp)
 d013b74:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013b78:	e0bff717 	ldw	r2,-36(fp)
 d013b7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d013b80:	e03fff15 	stw	zero,-4(fp)
 d013b84:	e0bfff17 	ldw	r2,-4(fp)
}
 d013b88:	e037883a 	mov	sp,fp
 d013b8c:	df000017 	ldw	fp,0(sp)
 d013b90:	dec00104 	addi	sp,sp,4
 d013b94:	f800283a 	ret

0d013b98 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 d013b98:	defff904 	addi	sp,sp,-28
 d013b9c:	df000615 	stw	fp,24(sp)
 d013ba0:	df000604 	addi	fp,sp,24
 d013ba4:	e13ffd15 	stw	r4,-12(fp)
 d013ba8:	e1bfff15 	stw	r6,-4(fp)
 d013bac:	e17ffe0d 	sth	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d013bb0:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d013bb4:	e0bfff17 	ldw	r2,-4(fp)
 d013bb8:	1005003a 	cmpeq	r2,r2,zero
 d013bbc:	1000331e 	bne	r2,zero,d013c8c <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d013bc0:	e0bffd17 	ldw	r2,-12(fp)
 d013bc4:	1004c03a 	cmpne	r2,r2,zero
 d013bc8:	1000041e 	bne	r2,zero,d013bdc <OSSemSet+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 d013bcc:	e0ffff17 	ldw	r3,-4(fp)
 d013bd0:	00800104 	movi	r2,4
 d013bd4:	18800005 	stb	r2,0(r3)
        return;
 d013bd8:	00002c06 	br	d013c8c <OSSemSet+0xf4>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d013bdc:	e0bffd17 	ldw	r2,-12(fp)
 d013be0:	10800003 	ldbu	r2,0(r2)
 d013be4:	10803fcc 	andi	r2,r2,255
 d013be8:	108000e0 	cmpeqi	r2,r2,3
 d013bec:	1000041e 	bne	r2,zero,d013c00 <OSSemSet+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 d013bf0:	e0ffff17 	ldw	r3,-4(fp)
 d013bf4:	00800044 	movi	r2,1
 d013bf8:	18800005 	stb	r2,0(r3)
        return;
 d013bfc:	00002306 	br	d013c8c <OSSemSet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013c00:	0005303a 	rdctl	r2,status
 d013c04:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013c08:	e0fffb17 	ldw	r3,-20(fp)
 d013c0c:	00bfff84 	movi	r2,-2
 d013c10:	1884703a 	and	r2,r3,r2
 d013c14:	1001703a 	wrctl	status,r2
  
  return context;
 d013c18:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d013c1c:	e0bffc15 	stw	r2,-16(fp)
    *perr = OS_ERR_NONE;
 d013c20:	e0bfff17 	ldw	r2,-4(fp)
 d013c24:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 d013c28:	e0bffd17 	ldw	r2,-12(fp)
 d013c2c:	1080020b 	ldhu	r2,8(r2)
 d013c30:	10bfffcc 	andi	r2,r2,65535
 d013c34:	1005003a 	cmpeq	r2,r2,zero
 d013c38:	1000041e 	bne	r2,zero,d013c4c <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 d013c3c:	e0fffd17 	ldw	r3,-12(fp)
 d013c40:	e0bffe0b 	ldhu	r2,-8(fp)
 d013c44:	1880020d 	sth	r2,8(r3)
 d013c48:	00000c06 	br	d013c7c <OSSemSet+0xe4>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 d013c4c:	e0bffd17 	ldw	r2,-12(fp)
 d013c50:	10800283 	ldbu	r2,10(r2)
 d013c54:	10803fcc 	andi	r2,r2,255
 d013c58:	1004c03a 	cmpne	r2,r2,zero
 d013c5c:	1000041e 	bne	r2,zero,d013c70 <OSSemSet+0xd8>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 d013c60:	e0fffd17 	ldw	r3,-12(fp)
 d013c64:	e0bffe0b 	ldhu	r2,-8(fp)
 d013c68:	1880020d 	sth	r2,8(r3)
 d013c6c:	00000306 	br	d013c7c <OSSemSet+0xe4>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 d013c70:	e0ffff17 	ldw	r3,-4(fp)
 d013c74:	00801244 	movi	r2,73
 d013c78:	18800005 	stb	r2,0(r3)
 d013c7c:	e0bffc17 	ldw	r2,-16(fp)
 d013c80:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013c84:	e0bffa17 	ldw	r2,-24(fp)
 d013c88:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
}
 d013c8c:	e037883a 	mov	sp,fp
 d013c90:	df000017 	ldw	fp,0(sp)
 d013c94:	dec00104 	addi	sp,sp,4
 d013c98:	f800283a 	ret

0d013c9c <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 d013c9c:	defff004 	addi	sp,sp,-64
 d013ca0:	dfc00f15 	stw	ra,60(sp)
 d013ca4:	df000e15 	stw	fp,56(sp)
 d013ca8:	df000e04 	addi	fp,sp,56
 d013cac:	e13ffd05 	stb	r4,-12(fp)
 d013cb0:	e17ffe05 	stb	r5,-8(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 d013cb4:	e03ff715 	stw	zero,-36(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 d013cb8:	e0bffd03 	ldbu	r2,-12(fp)
 d013cbc:	10800530 	cmpltui	r2,r2,20
 d013cc0:	1000061e 	bne	r2,zero,d013cdc <OSTaskChangePrio+0x40>
        if (oldprio != OS_PRIO_SELF) {
 d013cc4:	e0bffd03 	ldbu	r2,-12(fp)
 d013cc8:	10803fe0 	cmpeqi	r2,r2,255
 d013ccc:	1000031e 	bne	r2,zero,d013cdc <OSTaskChangePrio+0x40>
            return (OS_ERR_PRIO_INVALID);
 d013cd0:	00800a84 	movi	r2,42
 d013cd4:	e0bfff15 	stw	r2,-4(fp)
 d013cd8:	00014706 	br	d0141f8 <OSTaskChangePrio+0x55c>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 d013cdc:	e0bffe03 	ldbu	r2,-8(fp)
 d013ce0:	10800530 	cmpltui	r2,r2,20
 d013ce4:	1000031e 	bne	r2,zero,d013cf4 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 d013ce8:	00800a84 	movi	r2,42
 d013cec:	e0bfff15 	stw	r2,-4(fp)
 d013cf0:	00014106 	br	d0141f8 <OSTaskChangePrio+0x55c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013cf4:	0005303a 	rdctl	r2,status
 d013cf8:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013cfc:	e0fff617 	ldw	r3,-40(fp)
 d013d00:	00bfff84 	movi	r2,-2
 d013d04:	1884703a 	and	r2,r3,r2
 d013d08:	1001703a 	wrctl	status,r2
  
  return context;
 d013d0c:	e0bff617 	ldw	r2,-40(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d013d10:	e0bff715 	stw	r2,-36(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 d013d14:	e0bffe03 	ldbu	r2,-8(fp)
 d013d18:	00c341b4 	movhi	r3,3334
 d013d1c:	18c1b004 	addi	r3,r3,1728
 d013d20:	1085883a 	add	r2,r2,r2
 d013d24:	1085883a 	add	r2,r2,r2
 d013d28:	10c5883a 	add	r2,r2,r3
 d013d2c:	10800017 	ldw	r2,0(r2)
 d013d30:	1005003a 	cmpeq	r2,r2,zero
 d013d34:	1000071e 	bne	r2,zero,d013d54 <OSTaskChangePrio+0xb8>
 d013d38:	e0bff717 	ldw	r2,-36(fp)
 d013d3c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013d40:	e0bff517 	ldw	r2,-44(fp)
 d013d44:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 d013d48:	00800a04 	movi	r2,40
 d013d4c:	e0bfff15 	stw	r2,-4(fp)
 d013d50:	00012906 	br	d0141f8 <OSTaskChangePrio+0x55c>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 d013d54:	e0bffd03 	ldbu	r2,-12(fp)
 d013d58:	10803fd8 	cmpnei	r2,r2,255
 d013d5c:	1000051e 	bne	r2,zero,d013d74 <OSTaskChangePrio+0xd8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 d013d60:	00834174 	movhi	r2,3333
 d013d64:	109b1804 	addi	r2,r2,27744
 d013d68:	10800017 	ldw	r2,0(r2)
 d013d6c:	10800c83 	ldbu	r2,50(r2)
 d013d70:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 d013d74:	e0bffd03 	ldbu	r2,-12(fp)
 d013d78:	00c341b4 	movhi	r3,3334
 d013d7c:	18c1b004 	addi	r3,r3,1728
 d013d80:	1085883a 	add	r2,r2,r2
 d013d84:	1085883a 	add	r2,r2,r2
 d013d88:	10c5883a 	add	r2,r2,r3
 d013d8c:	10800017 	ldw	r2,0(r2)
 d013d90:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 d013d94:	e0bffa17 	ldw	r2,-24(fp)
 d013d98:	1004c03a 	cmpne	r2,r2,zero
 d013d9c:	1000071e 	bne	r2,zero,d013dbc <OSTaskChangePrio+0x120>
 d013da0:	e0bff717 	ldw	r2,-36(fp)
 d013da4:	e0bff415 	stw	r2,-48(fp)
 d013da8:	e0bff417 	ldw	r2,-48(fp)
 d013dac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 d013db0:	00800a44 	movi	r2,41
 d013db4:	e0bfff15 	stw	r2,-4(fp)
 d013db8:	00010f06 	br	d0141f8 <OSTaskChangePrio+0x55c>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 d013dbc:	e0bffa17 	ldw	r2,-24(fp)
 d013dc0:	10800058 	cmpnei	r2,r2,1
 d013dc4:	1000071e 	bne	r2,zero,d013de4 <OSTaskChangePrio+0x148>
 d013dc8:	e0bff717 	ldw	r2,-36(fp)
 d013dcc:	e0bff315 	stw	r2,-52(fp)
 d013dd0:	e0bff317 	ldw	r2,-52(fp)
 d013dd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 d013dd8:	008010c4 	movi	r2,67
 d013ddc:	e0bfff15 	stw	r2,-4(fp)
 d013de0:	00010506 	br	d0141f8 <OSTaskChangePrio+0x55c>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 d013de4:	e0bffe03 	ldbu	r2,-8(fp)
 d013de8:	1004d0fa 	srli	r2,r2,3
 d013dec:	e0bff985 	stb	r2,-26(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 d013df0:	e0bffe03 	ldbu	r2,-8(fp)
 d013df4:	108001cc 	andi	r2,r2,7
 d013df8:	e0bff945 	stb	r2,-27(fp)
    bity_new              = (INT8U)(1 << y_new);
 d013dfc:	e0fff983 	ldbu	r3,-26(fp)
 d013e00:	00800044 	movi	r2,1
 d013e04:	10c4983a 	sll	r2,r2,r3
 d013e08:	e0bff8c5 	stb	r2,-29(fp)
    bitx_new              = (INT8U)(1 << x_new);
 d013e0c:	e0fff943 	ldbu	r3,-27(fp)
 d013e10:	00800044 	movi	r2,1
 d013e14:	10c4983a 	sll	r2,r2,r3
 d013e18:	e0bff885 	stb	r2,-30(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 d013e1c:	e0bffd03 	ldbu	r2,-12(fp)
 d013e20:	00c341b4 	movhi	r3,3334
 d013e24:	18c1b004 	addi	r3,r3,1728
 d013e28:	1085883a 	add	r2,r2,r2
 d013e2c:	1085883a 	add	r2,r2,r2
 d013e30:	10c5883a 	add	r2,r2,r3
 d013e34:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 d013e38:	e0bffe03 	ldbu	r2,-8(fp)
 d013e3c:	00c341b4 	movhi	r3,3334
 d013e40:	18c1b004 	addi	r3,r3,1728
 d013e44:	1085883a 	add	r2,r2,r2
 d013e48:	1085883a 	add	r2,r2,r2
 d013e4c:	10c7883a 	add	r3,r2,r3
 d013e50:	e0bffa17 	ldw	r2,-24(fp)
 d013e54:	18800015 	stw	r2,0(r3)
    y_old                 =  ptcb->OSTCBY;
 d013e58:	e0bffa17 	ldw	r2,-24(fp)
 d013e5c:	10800d03 	ldbu	r2,52(r2)
 d013e60:	e0bff905 	stb	r2,-28(fp)
    bity_old              =  ptcb->OSTCBBitY;
 d013e64:	e0bffa17 	ldw	r2,-24(fp)
 d013e68:	10800d83 	ldbu	r2,54(r2)
 d013e6c:	e0bff845 	stb	r2,-31(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 d013e70:	e0bffa17 	ldw	r2,-24(fp)
 d013e74:	10800d43 	ldbu	r2,53(r2)
 d013e78:	e0bff805 	stb	r2,-32(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 d013e7c:	e0fff903 	ldbu	r3,-28(fp)
 d013e80:	00834174 	movhi	r2,3333
 d013e84:	109b1544 	addi	r2,r2,27733
 d013e88:	10c5883a 	add	r2,r2,r3
 d013e8c:	10c00003 	ldbu	r3,0(r2)
 d013e90:	e0bff803 	ldbu	r2,-32(fp)
 d013e94:	1884703a 	and	r2,r3,r2
 d013e98:	10803fcc 	andi	r2,r2,255
 d013e9c:	1005003a 	cmpeq	r2,r2,zero
 d013ea0:	1000381e 	bne	r2,zero,d013f84 <OSTaskChangePrio+0x2e8>
         OSRdyTbl[y_old] &= ~bitx_old;
 d013ea4:	e13ff903 	ldbu	r4,-28(fp)
 d013ea8:	e0fff903 	ldbu	r3,-28(fp)
 d013eac:	00834174 	movhi	r2,3333
 d013eb0:	109b1544 	addi	r2,r2,27733
 d013eb4:	10c5883a 	add	r2,r2,r3
 d013eb8:	10800003 	ldbu	r2,0(r2)
 d013ebc:	1007883a 	mov	r3,r2
 d013ec0:	e0bff803 	ldbu	r2,-32(fp)
 d013ec4:	0084303a 	nor	r2,zero,r2
 d013ec8:	1884703a 	and	r2,r3,r2
 d013ecc:	1007883a 	mov	r3,r2
 d013ed0:	00834174 	movhi	r2,3333
 d013ed4:	109b1544 	addi	r2,r2,27733
 d013ed8:	1105883a 	add	r2,r2,r4
 d013edc:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 d013ee0:	e0fff903 	ldbu	r3,-28(fp)
 d013ee4:	00834174 	movhi	r2,3333
 d013ee8:	109b1544 	addi	r2,r2,27733
 d013eec:	10c5883a 	add	r2,r2,r3
 d013ef0:	10800003 	ldbu	r2,0(r2)
 d013ef4:	10803fcc 	andi	r2,r2,255
 d013ef8:	1004c03a 	cmpne	r2,r2,zero
 d013efc:	10000b1e 	bne	r2,zero,d013f2c <OSTaskChangePrio+0x290>
             OSRdyGrp &= ~bity_old;
 d013f00:	e0bff843 	ldbu	r2,-31(fp)
 d013f04:	0084303a 	nor	r2,zero,r2
 d013f08:	1007883a 	mov	r3,r2
 d013f0c:	00834174 	movhi	r2,3333
 d013f10:	109b1504 	addi	r2,r2,27732
 d013f14:	10800003 	ldbu	r2,0(r2)
 d013f18:	1884703a 	and	r2,r3,r2
 d013f1c:	1007883a 	mov	r3,r2
 d013f20:	00834174 	movhi	r2,3333
 d013f24:	109b1504 	addi	r2,r2,27732
 d013f28:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 d013f2c:	00834174 	movhi	r2,3333
 d013f30:	109b1504 	addi	r2,r2,27732
 d013f34:	10c00003 	ldbu	r3,0(r2)
 d013f38:	e0bff8c3 	ldbu	r2,-29(fp)
 d013f3c:	1884b03a 	or	r2,r3,r2
 d013f40:	1007883a 	mov	r3,r2
 d013f44:	00834174 	movhi	r2,3333
 d013f48:	109b1504 	addi	r2,r2,27732
 d013f4c:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
 d013f50:	e13ff983 	ldbu	r4,-26(fp)
 d013f54:	e0fff983 	ldbu	r3,-26(fp)
 d013f58:	00834174 	movhi	r2,3333
 d013f5c:	109b1544 	addi	r2,r2,27733
 d013f60:	10c5883a 	add	r2,r2,r3
 d013f64:	10c00003 	ldbu	r3,0(r2)
 d013f68:	e0bff883 	ldbu	r2,-30(fp)
 d013f6c:	1884b03a 	or	r2,r3,r2
 d013f70:	1007883a 	mov	r3,r2
 d013f74:	00834174 	movhi	r2,3333
 d013f78:	109b1544 	addi	r2,r2,27733
 d013f7c:	1105883a 	add	r2,r2,r4
 d013f80:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 d013f84:	e0bffa17 	ldw	r2,-24(fp)
 d013f88:	10800717 	ldw	r2,28(r2)
 d013f8c:	e0bffc15 	stw	r2,-16(fp)
    if (pevent != (OS_EVENT *)0) {
 d013f90:	e0bffc17 	ldw	r2,-16(fp)
 d013f94:	1005003a 	cmpeq	r2,r2,zero
 d013f98:	1000341e 	bne	r2,zero,d01406c <OSTaskChangePrio+0x3d0>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 d013f9c:	e13ff903 	ldbu	r4,-28(fp)
 d013fa0:	e0fff903 	ldbu	r3,-28(fp)
 d013fa4:	e0bffc17 	ldw	r2,-16(fp)
 d013fa8:	1885883a 	add	r2,r3,r2
 d013fac:	10800204 	addi	r2,r2,8
 d013fb0:	108000c3 	ldbu	r2,3(r2)
 d013fb4:	1007883a 	mov	r3,r2
 d013fb8:	e0bff803 	ldbu	r2,-32(fp)
 d013fbc:	0084303a 	nor	r2,zero,r2
 d013fc0:	1884703a 	and	r2,r3,r2
 d013fc4:	1007883a 	mov	r3,r2
 d013fc8:	e0bffc17 	ldw	r2,-16(fp)
 d013fcc:	2085883a 	add	r2,r4,r2
 d013fd0:	10800204 	addi	r2,r2,8
 d013fd4:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 d013fd8:	e0fff903 	ldbu	r3,-28(fp)
 d013fdc:	e0bffc17 	ldw	r2,-16(fp)
 d013fe0:	1885883a 	add	r2,r3,r2
 d013fe4:	10800204 	addi	r2,r2,8
 d013fe8:	108000c3 	ldbu	r2,3(r2)
 d013fec:	10803fcc 	andi	r2,r2,255
 d013ff0:	1004c03a 	cmpne	r2,r2,zero
 d013ff4:	1000091e 	bne	r2,zero,d01401c <OSTaskChangePrio+0x380>
            pevent->OSEventGrp    &= ~bity_old;
 d013ff8:	e0bffc17 	ldw	r2,-16(fp)
 d013ffc:	10800283 	ldbu	r2,10(r2)
 d014000:	1007883a 	mov	r3,r2
 d014004:	e0bff843 	ldbu	r2,-31(fp)
 d014008:	0084303a 	nor	r2,zero,r2
 d01400c:	1884703a 	and	r2,r3,r2
 d014010:	1007883a 	mov	r3,r2
 d014014:	e0bffc17 	ldw	r2,-16(fp)
 d014018:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 d01401c:	e0bffc17 	ldw	r2,-16(fp)
 d014020:	10c00283 	ldbu	r3,10(r2)
 d014024:	e0bff8c3 	ldbu	r2,-29(fp)
 d014028:	1884b03a 	or	r2,r3,r2
 d01402c:	1007883a 	mov	r3,r2
 d014030:	e0bffc17 	ldw	r2,-16(fp)
 d014034:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 d014038:	e13ff983 	ldbu	r4,-26(fp)
 d01403c:	e0fff983 	ldbu	r3,-26(fp)
 d014040:	e0bffc17 	ldw	r2,-16(fp)
 d014044:	1885883a 	add	r2,r3,r2
 d014048:	10800204 	addi	r2,r2,8
 d01404c:	10c000c3 	ldbu	r3,3(r2)
 d014050:	e0bff883 	ldbu	r2,-30(fp)
 d014054:	1884b03a 	or	r2,r3,r2
 d014058:	1007883a 	mov	r3,r2
 d01405c:	e0bffc17 	ldw	r2,-16(fp)
 d014060:	2085883a 	add	r2,r4,r2
 d014064:	10800204 	addi	r2,r2,8
 d014068:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 d01406c:	e0bffa17 	ldw	r2,-24(fp)
 d014070:	10800817 	ldw	r2,32(r2)
 d014074:	1005003a 	cmpeq	r2,r2,zero
 d014078:	1000441e 	bne	r2,zero,d01418c <OSTaskChangePrio+0x4f0>
        pevents =  ptcb->OSTCBEventMultiPtr;
 d01407c:	e0bffa17 	ldw	r2,-24(fp)
 d014080:	10800817 	ldw	r2,32(r2)
 d014084:	e0bffb15 	stw	r2,-20(fp)
        pevent  = *pevents;
 d014088:	e0bffb17 	ldw	r2,-20(fp)
 d01408c:	10800017 	ldw	r2,0(r2)
 d014090:	e0bffc15 	stw	r2,-16(fp)
        while (pevent != (OS_EVENT *)0) {
 d014094:	00003a06 	br	d014180 <OSTaskChangePrio+0x4e4>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 d014098:	e13ff903 	ldbu	r4,-28(fp)
 d01409c:	e0fff903 	ldbu	r3,-28(fp)
 d0140a0:	e0bffc17 	ldw	r2,-16(fp)
 d0140a4:	1885883a 	add	r2,r3,r2
 d0140a8:	10800204 	addi	r2,r2,8
 d0140ac:	108000c3 	ldbu	r2,3(r2)
 d0140b0:	1007883a 	mov	r3,r2
 d0140b4:	e0bff803 	ldbu	r2,-32(fp)
 d0140b8:	0084303a 	nor	r2,zero,r2
 d0140bc:	1884703a 	and	r2,r3,r2
 d0140c0:	1007883a 	mov	r3,r2
 d0140c4:	e0bffc17 	ldw	r2,-16(fp)
 d0140c8:	2085883a 	add	r2,r4,r2
 d0140cc:	10800204 	addi	r2,r2,8
 d0140d0:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 d0140d4:	e0fff903 	ldbu	r3,-28(fp)
 d0140d8:	e0bffc17 	ldw	r2,-16(fp)
 d0140dc:	1885883a 	add	r2,r3,r2
 d0140e0:	10800204 	addi	r2,r2,8
 d0140e4:	108000c3 	ldbu	r2,3(r2)
 d0140e8:	10803fcc 	andi	r2,r2,255
 d0140ec:	1004c03a 	cmpne	r2,r2,zero
 d0140f0:	1000091e 	bne	r2,zero,d014118 <OSTaskChangePrio+0x47c>
                pevent->OSEventGrp    &= ~bity_old;
 d0140f4:	e0bffc17 	ldw	r2,-16(fp)
 d0140f8:	10800283 	ldbu	r2,10(r2)
 d0140fc:	1007883a 	mov	r3,r2
 d014100:	e0bff843 	ldbu	r2,-31(fp)
 d014104:	0084303a 	nor	r2,zero,r2
 d014108:	1884703a 	and	r2,r3,r2
 d01410c:	1007883a 	mov	r3,r2
 d014110:	e0bffc17 	ldw	r2,-16(fp)
 d014114:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 d014118:	e0bffc17 	ldw	r2,-16(fp)
 d01411c:	10c00283 	ldbu	r3,10(r2)
 d014120:	e0bff8c3 	ldbu	r2,-29(fp)
 d014124:	1884b03a 	or	r2,r3,r2
 d014128:	1007883a 	mov	r3,r2
 d01412c:	e0bffc17 	ldw	r2,-16(fp)
 d014130:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 d014134:	e13ff983 	ldbu	r4,-26(fp)
 d014138:	e0fff983 	ldbu	r3,-26(fp)
 d01413c:	e0bffc17 	ldw	r2,-16(fp)
 d014140:	1885883a 	add	r2,r3,r2
 d014144:	10800204 	addi	r2,r2,8
 d014148:	10c000c3 	ldbu	r3,3(r2)
 d01414c:	e0bff883 	ldbu	r2,-30(fp)
 d014150:	1884b03a 	or	r2,r3,r2
 d014154:	1007883a 	mov	r3,r2
 d014158:	e0bffc17 	ldw	r2,-16(fp)
 d01415c:	2085883a 	add	r2,r4,r2
 d014160:	10800204 	addi	r2,r2,8
 d014164:	10c000c5 	stb	r3,3(r2)
            pevents++;
 d014168:	e0bffb17 	ldw	r2,-20(fp)
 d01416c:	10800104 	addi	r2,r2,4
 d014170:	e0bffb15 	stw	r2,-20(fp)
            pevent                     = *pevents;
 d014174:	e0bffb17 	ldw	r2,-20(fp)
 d014178:	10800017 	ldw	r2,0(r2)
 d01417c:	e0bffc15 	stw	r2,-16(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 d014180:	e0bffc17 	ldw	r2,-16(fp)
 d014184:	1004c03a 	cmpne	r2,r2,zero
 d014188:	103fc31e 	bne	r2,zero,d014098 <OSTaskChangePrio+0x3fc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 d01418c:	e0fffa17 	ldw	r3,-24(fp)
 d014190:	e0bffe03 	ldbu	r2,-8(fp)
 d014194:	18800c85 	stb	r2,50(r3)
    ptcb->OSTCBY    = y_new;
 d014198:	e0fffa17 	ldw	r3,-24(fp)
 d01419c:	e0bff983 	ldbu	r2,-26(fp)
 d0141a0:	18800d05 	stb	r2,52(r3)
    ptcb->OSTCBX    = x_new;
 d0141a4:	e0fffa17 	ldw	r3,-24(fp)
 d0141a8:	e0bff943 	ldbu	r2,-27(fp)
 d0141ac:	18800cc5 	stb	r2,51(r3)
    ptcb->OSTCBBitY = bity_new;
 d0141b0:	e0fffa17 	ldw	r3,-24(fp)
 d0141b4:	e0bff8c3 	ldbu	r2,-29(fp)
 d0141b8:	18800d85 	stb	r2,54(r3)
    ptcb->OSTCBBitX = bitx_new;
 d0141bc:	e0fffa17 	ldw	r3,-24(fp)
 d0141c0:	e0bff883 	ldbu	r2,-30(fp)
 d0141c4:	18800d45 	stb	r2,53(r3)
 d0141c8:	e0bff717 	ldw	r2,-36(fp)
 d0141cc:	e0bff215 	stw	r2,-56(fp)
 d0141d0:	e0bff217 	ldw	r2,-56(fp)
 d0141d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 d0141d8:	00834174 	movhi	r2,3333
 d0141dc:	109b0944 	addi	r2,r2,27685
 d0141e0:	10800003 	ldbu	r2,0(r2)
 d0141e4:	10803fcc 	andi	r2,r2,255
 d0141e8:	10800058 	cmpnei	r2,r2,1
 d0141ec:	1000011e 	bne	r2,zero,d0141f4 <OSTaskChangePrio+0x558>
        OS_Sched();                                         /* Find new highest priority task          */
 d0141f0:	d00f3e40 	call	d00f3e4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 d0141f4:	e03fff15 	stw	zero,-4(fp)
 d0141f8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0141fc:	e037883a 	mov	sp,fp
 d014200:	dfc00117 	ldw	ra,4(sp)
 d014204:	df000017 	ldw	fp,0(sp)
 d014208:	dec00204 	addi	sp,sp,8
 d01420c:	f800283a 	ret

0d014210 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 d014210:	deffed04 	addi	sp,sp,-76
 d014214:	dfc01215 	stw	ra,72(sp)
 d014218:	df001115 	stw	fp,68(sp)
 d01421c:	df001104 	addi	fp,sp,68
 d014220:	e13ffb15 	stw	r4,-20(fp)
 d014224:	e17ffc15 	stw	r5,-16(fp)
 d014228:	e1bffd15 	stw	r6,-12(fp)
 d01422c:	e1fffe05 	stb	r7,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 d014230:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 d014234:	e0bffe03 	ldbu	r2,-8(fp)
 d014238:	10800570 	cmpltui	r2,r2,21
 d01423c:	1000031e 	bne	r2,zero,d01424c <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 d014240:	00800a84 	movi	r2,42
 d014244:	e0bfff15 	stw	r2,-4(fp)
 d014248:	00006006 	br	d0143cc <OSTaskCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01424c:	0005303a 	rdctl	r2,status
 d014250:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014254:	e0fff717 	ldw	r3,-36(fp)
 d014258:	00bfff84 	movi	r2,-2
 d01425c:	1884703a 	and	r2,r3,r2
 d014260:	1001703a 	wrctl	status,r2
  
  return context;
 d014264:	e0bff717 	ldw	r2,-36(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d014268:	e0bff815 	stw	r2,-32(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 d01426c:	00834174 	movhi	r2,3333
 d014270:	109b1704 	addi	r2,r2,27740
 d014274:	10800003 	ldbu	r2,0(r2)
 d014278:	10803fcc 	andi	r2,r2,255
 d01427c:	1005003a 	cmpeq	r2,r2,zero
 d014280:	1000071e 	bne	r2,zero,d0142a0 <OSTaskCreate+0x90>
 d014284:	e0bff817 	ldw	r2,-32(fp)
 d014288:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01428c:	e0bff617 	ldw	r2,-40(fp)
 d014290:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 d014294:	00800f04 	movi	r2,60
 d014298:	e0bfff15 	stw	r2,-4(fp)
 d01429c:	00004b06 	br	d0143cc <OSTaskCreate+0x1bc>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 d0142a0:	e0bffe03 	ldbu	r2,-8(fp)
 d0142a4:	00c341b4 	movhi	r3,3334
 d0142a8:	18c1b004 	addi	r3,r3,1728
 d0142ac:	1085883a 	add	r2,r2,r2
 d0142b0:	1085883a 	add	r2,r2,r2
 d0142b4:	10c5883a 	add	r2,r2,r3
 d0142b8:	10800017 	ldw	r2,0(r2)
 d0142bc:	1004c03a 	cmpne	r2,r2,zero
 d0142c0:	10003c1e 	bne	r2,zero,d0143b4 <OSTaskCreate+0x1a4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 d0142c4:	e0bffe03 	ldbu	r2,-8(fp)
 d0142c8:	00c341b4 	movhi	r3,3334
 d0142cc:	18c1b004 	addi	r3,r3,1728
 d0142d0:	1085883a 	add	r2,r2,r2
 d0142d4:	1085883a 	add	r2,r2,r2
 d0142d8:	10c7883a 	add	r3,r2,r3
 d0142dc:	00800044 	movi	r2,1
 d0142e0:	18800015 	stw	r2,0(r3)
 d0142e4:	e0bff817 	ldw	r2,-32(fp)
 d0142e8:	e0bff515 	stw	r2,-44(fp)
 d0142ec:	e0bff517 	ldw	r2,-44(fp)
 d0142f0:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 d0142f4:	e13ffb17 	ldw	r4,-20(fp)
 d0142f8:	e17ffc17 	ldw	r5,-16(fp)
 d0142fc:	e1bffd17 	ldw	r6,-12(fp)
 d014300:	000f883a 	mov	r7,zero
 d014304:	d0363640 	call	d036364 <OSTaskStkInit>
 d014308:	e0bffa15 	stw	r2,-24(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 d01430c:	e13ffe03 	ldbu	r4,-8(fp)
 d014310:	d8000015 	stw	zero,0(sp)
 d014314:	d8000115 	stw	zero,4(sp)
 d014318:	d8000215 	stw	zero,8(sp)
 d01431c:	e17ffa17 	ldw	r5,-24(fp)
 d014320:	000d883a 	mov	r6,zero
 d014324:	000f883a 	mov	r7,zero
 d014328:	d00f7ec0 	call	d00f7ec <OS_TCBInit>
 d01432c:	e0bff905 	stb	r2,-28(fp)
        if (err == OS_ERR_NONE) {
 d014330:	e0bff903 	ldbu	r2,-28(fp)
 d014334:	1004c03a 	cmpne	r2,r2,zero
 d014338:	1000081e 	bne	r2,zero,d01435c <OSTaskCreate+0x14c>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 d01433c:	00834174 	movhi	r2,3333
 d014340:	109b0944 	addi	r2,r2,27685
 d014344:	10800003 	ldbu	r2,0(r2)
 d014348:	10803fcc 	andi	r2,r2,255
 d01434c:	10800058 	cmpnei	r2,r2,1
 d014350:	1000151e 	bne	r2,zero,d0143a8 <OSTaskCreate+0x198>
                OS_Sched();
 d014354:	d00f3e40 	call	d00f3e4 <OS_Sched>
 d014358:	00001306 	br	d0143a8 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01435c:	0005303a 	rdctl	r2,status
 d014360:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014364:	e0fff417 	ldw	r3,-48(fp)
 d014368:	00bfff84 	movi	r2,-2
 d01436c:	1884703a 	and	r2,r3,r2
 d014370:	1001703a 	wrctl	status,r2
  
  return context;
 d014374:	e0bff417 	ldw	r2,-48(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 d014378:	e0bff815 	stw	r2,-32(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 d01437c:	e0bffe03 	ldbu	r2,-8(fp)
 d014380:	00c341b4 	movhi	r3,3334
 d014384:	18c1b004 	addi	r3,r3,1728
 d014388:	1085883a 	add	r2,r2,r2
 d01438c:	1085883a 	add	r2,r2,r2
 d014390:	10c5883a 	add	r2,r2,r3
 d014394:	10000015 	stw	zero,0(r2)
 d014398:	e0bff817 	ldw	r2,-32(fp)
 d01439c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0143a0:	e0bff317 	ldw	r2,-52(fp)
 d0143a4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 d0143a8:	e0bff903 	ldbu	r2,-28(fp)
 d0143ac:	e0bfff15 	stw	r2,-4(fp)
 d0143b0:	00000606 	br	d0143cc <OSTaskCreate+0x1bc>
 d0143b4:	e0bff817 	ldw	r2,-32(fp)
 d0143b8:	e0bff215 	stw	r2,-56(fp)
 d0143bc:	e0bff217 	ldw	r2,-56(fp)
 d0143c0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 d0143c4:	00800a04 	movi	r2,40
 d0143c8:	e0bfff15 	stw	r2,-4(fp)
 d0143cc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0143d0:	e037883a 	mov	sp,fp
 d0143d4:	dfc00117 	ldw	ra,4(sp)
 d0143d8:	df000017 	ldw	fp,0(sp)
 d0143dc:	dec00204 	addi	sp,sp,8
 d0143e0:	f800283a 	ret

0d0143e4 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 d0143e4:	deffeb04 	addi	sp,sp,-84
 d0143e8:	dfc01415 	stw	ra,80(sp)
 d0143ec:	df001315 	stw	fp,76(sp)
 d0143f0:	df001304 	addi	fp,sp,76
 d0143f4:	e13ff915 	stw	r4,-28(fp)
 d0143f8:	e17ffa15 	stw	r5,-24(fp)
 d0143fc:	e1bffb15 	stw	r6,-20(fp)
 d014400:	e0800217 	ldw	r2,8(fp)
 d014404:	e0c00617 	ldw	r3,24(fp)
 d014408:	e1fffc05 	stb	r7,-16(fp)
 d01440c:	e0bffd0d 	sth	r2,-12(fp)
 d014410:	e0fffe0d 	sth	r3,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 d014414:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 d014418:	e0bffc03 	ldbu	r2,-16(fp)
 d01441c:	10800570 	cmpltui	r2,r2,21
 d014420:	1000031e 	bne	r2,zero,d014430 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 d014424:	00800a84 	movi	r2,42
 d014428:	e0bfff15 	stw	r2,-4(fp)
 d01442c:	00006706 	br	d0145cc <OSTaskCreateExt+0x1e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014430:	0005303a 	rdctl	r2,status
 d014434:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014438:	e0fff517 	ldw	r3,-44(fp)
 d01443c:	00bfff84 	movi	r2,-2
 d014440:	1884703a 	and	r2,r3,r2
 d014444:	1001703a 	wrctl	status,r2
  
  return context;
 d014448:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d01444c:	e0bff615 	stw	r2,-40(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 d014450:	00834174 	movhi	r2,3333
 d014454:	109b1704 	addi	r2,r2,27740
 d014458:	10800003 	ldbu	r2,0(r2)
 d01445c:	10803fcc 	andi	r2,r2,255
 d014460:	1005003a 	cmpeq	r2,r2,zero
 d014464:	1000071e 	bne	r2,zero,d014484 <OSTaskCreateExt+0xa0>
 d014468:	e0bff617 	ldw	r2,-40(fp)
 d01446c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014470:	e0bff417 	ldw	r2,-48(fp)
 d014474:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 d014478:	00800f04 	movi	r2,60
 d01447c:	e0bfff15 	stw	r2,-4(fp)
 d014480:	00005206 	br	d0145cc <OSTaskCreateExt+0x1e8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 d014484:	e0bffc03 	ldbu	r2,-16(fp)
 d014488:	00c341b4 	movhi	r3,3334
 d01448c:	18c1b004 	addi	r3,r3,1728
 d014490:	1085883a 	add	r2,r2,r2
 d014494:	1085883a 	add	r2,r2,r2
 d014498:	10c5883a 	add	r2,r2,r3
 d01449c:	10800017 	ldw	r2,0(r2)
 d0144a0:	1004c03a 	cmpne	r2,r2,zero
 d0144a4:	1000431e 	bne	r2,zero,d0145b4 <OSTaskCreateExt+0x1d0>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 d0144a8:	e0bffc03 	ldbu	r2,-16(fp)
 d0144ac:	00c341b4 	movhi	r3,3334
 d0144b0:	18c1b004 	addi	r3,r3,1728
 d0144b4:	1085883a 	add	r2,r2,r2
 d0144b8:	1085883a 	add	r2,r2,r2
 d0144bc:	10c7883a 	add	r3,r2,r3
 d0144c0:	00800044 	movi	r2,1
 d0144c4:	18800015 	stw	r2,0(r3)
 d0144c8:	e0bff617 	ldw	r2,-40(fp)
 d0144cc:	e0bff315 	stw	r2,-52(fp)
 d0144d0:	e0bff317 	ldw	r2,-52(fp)
 d0144d4:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 d0144d8:	e1bffe0b 	ldhu	r6,-8(fp)
 d0144dc:	e1000317 	ldw	r4,12(fp)
 d0144e0:	e1400417 	ldw	r5,16(fp)
 d0144e4:	d0156600 	call	d015660 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 d0144e8:	e1fffe0b 	ldhu	r7,-8(fp)
 d0144ec:	e13ff917 	ldw	r4,-28(fp)
 d0144f0:	e17ffa17 	ldw	r5,-24(fp)
 d0144f4:	e1bffb17 	ldw	r6,-20(fp)
 d0144f8:	d0363640 	call	d036364 <OSTaskStkInit>
 d0144fc:	e0bff815 	stw	r2,-32(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 d014500:	e13ffc03 	ldbu	r4,-16(fp)
 d014504:	e1fffd0b 	ldhu	r7,-12(fp)
 d014508:	e0fffe0b 	ldhu	r3,-8(fp)
 d01450c:	e0800417 	ldw	r2,16(fp)
 d014510:	d8800015 	stw	r2,0(sp)
 d014514:	e0800517 	ldw	r2,20(fp)
 d014518:	d8800115 	stw	r2,4(sp)
 d01451c:	d8c00215 	stw	r3,8(sp)
 d014520:	e17ff817 	ldw	r5,-32(fp)
 d014524:	e1800317 	ldw	r6,12(fp)
 d014528:	d00f7ec0 	call	d00f7ec <OS_TCBInit>
 d01452c:	e0bff705 	stb	r2,-36(fp)
        if (err == OS_ERR_NONE) {
 d014530:	e0bff703 	ldbu	r2,-36(fp)
 d014534:	1004c03a 	cmpne	r2,r2,zero
 d014538:	1000081e 	bne	r2,zero,d01455c <OSTaskCreateExt+0x178>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 d01453c:	00834174 	movhi	r2,3333
 d014540:	109b0944 	addi	r2,r2,27685
 d014544:	10800003 	ldbu	r2,0(r2)
 d014548:	10803fcc 	andi	r2,r2,255
 d01454c:	10800058 	cmpnei	r2,r2,1
 d014550:	1000151e 	bne	r2,zero,d0145a8 <OSTaskCreateExt+0x1c4>
                OS_Sched();
 d014554:	d00f3e40 	call	d00f3e4 <OS_Sched>
 d014558:	00001306 	br	d0145a8 <OSTaskCreateExt+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01455c:	0005303a 	rdctl	r2,status
 d014560:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014564:	e0fff217 	ldw	r3,-56(fp)
 d014568:	00bfff84 	movi	r2,-2
 d01456c:	1884703a 	and	r2,r3,r2
 d014570:	1001703a 	wrctl	status,r2
  
  return context;
 d014574:	e0bff217 	ldw	r2,-56(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 d014578:	e0bff615 	stw	r2,-40(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 d01457c:	e0bffc03 	ldbu	r2,-16(fp)
 d014580:	00c341b4 	movhi	r3,3334
 d014584:	18c1b004 	addi	r3,r3,1728
 d014588:	1085883a 	add	r2,r2,r2
 d01458c:	1085883a 	add	r2,r2,r2
 d014590:	10c5883a 	add	r2,r2,r3
 d014594:	10000015 	stw	zero,0(r2)
 d014598:	e0bff617 	ldw	r2,-40(fp)
 d01459c:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0145a0:	e0bff117 	ldw	r2,-60(fp)
 d0145a4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 d0145a8:	e0bff703 	ldbu	r2,-36(fp)
 d0145ac:	e0bfff15 	stw	r2,-4(fp)
 d0145b0:	00000606 	br	d0145cc <OSTaskCreateExt+0x1e8>
 d0145b4:	e0bff617 	ldw	r2,-40(fp)
 d0145b8:	e0bff015 	stw	r2,-64(fp)
 d0145bc:	e0bff017 	ldw	r2,-64(fp)
 d0145c0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 d0145c4:	00800a04 	movi	r2,40
 d0145c8:	e0bfff15 	stw	r2,-4(fp)
 d0145cc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0145d0:	e037883a 	mov	sp,fp
 d0145d4:	dfc00117 	ldw	ra,4(sp)
 d0145d8:	df000017 	ldw	fp,0(sp)
 d0145dc:	dec00204 	addi	sp,sp,8
 d0145e0:	f800283a 	ret

0d0145e4 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 d0145e4:	defff304 	addi	sp,sp,-52
 d0145e8:	dfc00c15 	stw	ra,48(sp)
 d0145ec:	df000b15 	stw	fp,44(sp)
 d0145f0:	df000b04 	addi	fp,sp,44
 d0145f4:	e13ffe05 	stb	r4,-8(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 d0145f8:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 d0145fc:	00834174 	movhi	r2,3333
 d014600:	109b1704 	addi	r2,r2,27740
 d014604:	10800003 	ldbu	r2,0(r2)
 d014608:	10803fcc 	andi	r2,r2,255
 d01460c:	1005003a 	cmpeq	r2,r2,zero
 d014610:	1000031e 	bne	r2,zero,d014620 <OSTaskDel+0x3c>
        return (OS_ERR_TASK_DEL_ISR);
 d014614:	00801004 	movi	r2,64
 d014618:	e0bfff15 	stw	r2,-4(fp)
 d01461c:	0000ee06 	br	d0149d8 <OSTaskDel+0x3f4>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 d014620:	e0bffe03 	ldbu	r2,-8(fp)
 d014624:	10800518 	cmpnei	r2,r2,20
 d014628:	1000031e 	bne	r2,zero,d014638 <OSTaskDel+0x54>
        return (OS_ERR_TASK_DEL_IDLE);
 d01462c:	00800f84 	movi	r2,62
 d014630:	e0bfff15 	stw	r2,-4(fp)
 d014634:	0000e806 	br	d0149d8 <OSTaskDel+0x3f4>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 d014638:	e0bffe03 	ldbu	r2,-8(fp)
 d01463c:	10800530 	cmpltui	r2,r2,20
 d014640:	1000061e 	bne	r2,zero,d01465c <OSTaskDel+0x78>
        if (prio != OS_PRIO_SELF) {
 d014644:	e0bffe03 	ldbu	r2,-8(fp)
 d014648:	10803fe0 	cmpeqi	r2,r2,255
 d01464c:	1000031e 	bne	r2,zero,d01465c <OSTaskDel+0x78>
            return (OS_ERR_PRIO_INVALID);
 d014650:	00800a84 	movi	r2,42
 d014654:	e0bfff15 	stw	r2,-4(fp)
 d014658:	0000df06 	br	d0149d8 <OSTaskDel+0x3f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01465c:	0005303a 	rdctl	r2,status
 d014660:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014664:	e0fffa17 	ldw	r3,-24(fp)
 d014668:	00bfff84 	movi	r2,-2
 d01466c:	1884703a 	and	r2,r3,r2
 d014670:	1001703a 	wrctl	status,r2
  
  return context;
 d014674:	e0bffa17 	ldw	r2,-24(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 d014678:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 d01467c:	e0bffe03 	ldbu	r2,-8(fp)
 d014680:	10803fd8 	cmpnei	r2,r2,255
 d014684:	1000051e 	bne	r2,zero,d01469c <OSTaskDel+0xb8>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 d014688:	00834174 	movhi	r2,3333
 d01468c:	109b1804 	addi	r2,r2,27744
 d014690:	10800017 	ldw	r2,0(r2)
 d014694:	10800c83 	ldbu	r2,50(r2)
 d014698:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d01469c:	e0bffe03 	ldbu	r2,-8(fp)
 d0146a0:	00c341b4 	movhi	r3,3334
 d0146a4:	18c1b004 	addi	r3,r3,1728
 d0146a8:	1085883a 	add	r2,r2,r2
 d0146ac:	1085883a 	add	r2,r2,r2
 d0146b0:	10c5883a 	add	r2,r2,r3
 d0146b4:	10800017 	ldw	r2,0(r2)
 d0146b8:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 d0146bc:	e0bffc17 	ldw	r2,-16(fp)
 d0146c0:	1004c03a 	cmpne	r2,r2,zero
 d0146c4:	1000071e 	bne	r2,zero,d0146e4 <OSTaskDel+0x100>
 d0146c8:	e0bffb17 	ldw	r2,-20(fp)
 d0146cc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0146d0:	e0bff917 	ldw	r2,-28(fp)
 d0146d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d0146d8:	008010c4 	movi	r2,67
 d0146dc:	e0bfff15 	stw	r2,-4(fp)
 d0146e0:	0000bd06 	br	d0149d8 <OSTaskDel+0x3f4>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 d0146e4:	e0bffc17 	ldw	r2,-16(fp)
 d0146e8:	10800058 	cmpnei	r2,r2,1
 d0146ec:	1000071e 	bne	r2,zero,d01470c <OSTaskDel+0x128>
 d0146f0:	e0bffb17 	ldw	r2,-20(fp)
 d0146f4:	e0bff815 	stw	r2,-32(fp)
 d0146f8:	e0bff817 	ldw	r2,-32(fp)
 d0146fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 d014700:	00800f44 	movi	r2,61
 d014704:	e0bfff15 	stw	r2,-4(fp)
 d014708:	0000b306 	br	d0149d8 <OSTaskDel+0x3f4>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 d01470c:	e0bffc17 	ldw	r2,-16(fp)
 d014710:	10800d03 	ldbu	r2,52(r2)
 d014714:	11003fcc 	andi	r4,r2,255
 d014718:	e0bffc17 	ldw	r2,-16(fp)
 d01471c:	10800d03 	ldbu	r2,52(r2)
 d014720:	10c03fcc 	andi	r3,r2,255
 d014724:	00834174 	movhi	r2,3333
 d014728:	109b1544 	addi	r2,r2,27733
 d01472c:	10c5883a 	add	r2,r2,r3
 d014730:	10800003 	ldbu	r2,0(r2)
 d014734:	1007883a 	mov	r3,r2
 d014738:	e0bffc17 	ldw	r2,-16(fp)
 d01473c:	10800d43 	ldbu	r2,53(r2)
 d014740:	0084303a 	nor	r2,zero,r2
 d014744:	1884703a 	and	r2,r3,r2
 d014748:	1007883a 	mov	r3,r2
 d01474c:	00834174 	movhi	r2,3333
 d014750:	109b1544 	addi	r2,r2,27733
 d014754:	1105883a 	add	r2,r2,r4
 d014758:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 d01475c:	e0bffc17 	ldw	r2,-16(fp)
 d014760:	10800d03 	ldbu	r2,52(r2)
 d014764:	10c03fcc 	andi	r3,r2,255
 d014768:	00834174 	movhi	r2,3333
 d01476c:	109b1544 	addi	r2,r2,27733
 d014770:	10c5883a 	add	r2,r2,r3
 d014774:	10800003 	ldbu	r2,0(r2)
 d014778:	10803fcc 	andi	r2,r2,255
 d01477c:	1004c03a 	cmpne	r2,r2,zero
 d014780:	10000c1e 	bne	r2,zero,d0147b4 <OSTaskDel+0x1d0>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 d014784:	e0bffc17 	ldw	r2,-16(fp)
 d014788:	10800d83 	ldbu	r2,54(r2)
 d01478c:	0084303a 	nor	r2,zero,r2
 d014790:	1007883a 	mov	r3,r2
 d014794:	00834174 	movhi	r2,3333
 d014798:	109b1504 	addi	r2,r2,27732
 d01479c:	10800003 	ldbu	r2,0(r2)
 d0147a0:	1884703a 	and	r2,r3,r2
 d0147a4:	1007883a 	mov	r3,r2
 d0147a8:	00834174 	movhi	r2,3333
 d0147ac:	109b1504 	addi	r2,r2,27732
 d0147b0:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 d0147b4:	e0bffc17 	ldw	r2,-16(fp)
 d0147b8:	10800717 	ldw	r2,28(r2)
 d0147bc:	1005003a 	cmpeq	r2,r2,zero
 d0147c0:	1000041e 	bne	r2,zero,d0147d4 <OSTaskDel+0x1f0>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 d0147c4:	e0bffc17 	ldw	r2,-16(fp)
 d0147c8:	11400717 	ldw	r5,28(r2)
 d0147cc:	e13ffc17 	ldw	r4,-16(fp)
 d0147d0:	d00ed9c0 	call	d00ed9c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 d0147d4:	e0bffc17 	ldw	r2,-16(fp)
 d0147d8:	10800817 	ldw	r2,32(r2)
 d0147dc:	1005003a 	cmpeq	r2,r2,zero
 d0147e0:	1000041e 	bne	r2,zero,d0147f4 <OSTaskDel+0x210>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 d0147e4:	e0bffc17 	ldw	r2,-16(fp)
 d0147e8:	11400817 	ldw	r5,32(r2)
 d0147ec:	e13ffc17 	ldw	r4,-16(fp)
 d0147f0:	d00ee540 	call	d00ee54 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 d0147f4:	e0bffc17 	ldw	r2,-16(fp)
 d0147f8:	10800a17 	ldw	r2,40(r2)
 d0147fc:	e0bffd15 	stw	r2,-12(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 d014800:	e0bffd17 	ldw	r2,-12(fp)
 d014804:	1005003a 	cmpeq	r2,r2,zero
 d014808:	1000021e 	bne	r2,zero,d014814 <OSTaskDel+0x230>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 d01480c:	e13ffd17 	ldw	r4,-12(fp)
 d014810:	d0114e80 	call	d0114e8 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 d014814:	e0bffc17 	ldw	r2,-16(fp)
 d014818:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 d01481c:	e0bffc17 	ldw	r2,-16(fp)
 d014820:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 d014824:	e0bffc17 	ldw	r2,-16(fp)
 d014828:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 d01482c:	00834174 	movhi	r2,3333
 d014830:	109b0904 	addi	r2,r2,27684
 d014834:	10800003 	ldbu	r2,0(r2)
 d014838:	10803fcc 	andi	r2,r2,255
 d01483c:	10803fe0 	cmpeqi	r2,r2,255
 d014840:	1000081e 	bne	r2,zero,d014864 <OSTaskDel+0x280>
        OSLockNesting++;
 d014844:	00834174 	movhi	r2,3333
 d014848:	109b0904 	addi	r2,r2,27684
 d01484c:	10800003 	ldbu	r2,0(r2)
 d014850:	10800044 	addi	r2,r2,1
 d014854:	1007883a 	mov	r3,r2
 d014858:	00834174 	movhi	r2,3333
 d01485c:	109b0904 	addi	r2,r2,27684
 d014860:	10c00005 	stb	r3,0(r2)
 d014864:	e0bffb17 	ldw	r2,-20(fp)
 d014868:	e0bff715 	stw	r2,-36(fp)
 d01486c:	e0bff717 	ldw	r2,-36(fp)
 d014870:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 d014874:	d00e9880 	call	d00e988 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014878:	0005303a 	rdctl	r2,status
 d01487c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014880:	e0fff617 	ldw	r3,-40(fp)
 d014884:	00bfff84 	movi	r2,-2
 d014888:	1884703a 	and	r2,r3,r2
 d01488c:	1001703a 	wrctl	status,r2
  
  return context;
 d014890:	e0bff617 	ldw	r2,-40(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 d014894:	e0bffb15 	stw	r2,-20(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 d014898:	00834174 	movhi	r2,3333
 d01489c:	109b0904 	addi	r2,r2,27684
 d0148a0:	10800003 	ldbu	r2,0(r2)
 d0148a4:	10803fcc 	andi	r2,r2,255
 d0148a8:	1005003a 	cmpeq	r2,r2,zero
 d0148ac:	1000081e 	bne	r2,zero,d0148d0 <OSTaskDel+0x2ec>
        OSLockNesting--;
 d0148b0:	00834174 	movhi	r2,3333
 d0148b4:	109b0904 	addi	r2,r2,27684
 d0148b8:	10800003 	ldbu	r2,0(r2)
 d0148bc:	10bfffc4 	addi	r2,r2,-1
 d0148c0:	1007883a 	mov	r3,r2
 d0148c4:	00834174 	movhi	r2,3333
 d0148c8:	109b0904 	addi	r2,r2,27684
 d0148cc:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 d0148d0:	e13ffc17 	ldw	r4,-16(fp)
 d0148d4:	d0366940 	call	d036694 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 d0148d8:	00834174 	movhi	r2,3333
 d0148dc:	109b1144 	addi	r2,r2,27717
 d0148e0:	10800003 	ldbu	r2,0(r2)
 d0148e4:	10bfffc4 	addi	r2,r2,-1
 d0148e8:	1007883a 	mov	r3,r2
 d0148ec:	00834174 	movhi	r2,3333
 d0148f0:	109b1144 	addi	r2,r2,27717
 d0148f4:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 d0148f8:	e0bffe03 	ldbu	r2,-8(fp)
 d0148fc:	00c341b4 	movhi	r3,3334
 d014900:	18c1b004 	addi	r3,r3,1728
 d014904:	1085883a 	add	r2,r2,r2
 d014908:	1085883a 	add	r2,r2,r2
 d01490c:	10c5883a 	add	r2,r2,r3
 d014910:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 d014914:	e0bffc17 	ldw	r2,-16(fp)
 d014918:	10800617 	ldw	r2,24(r2)
 d01491c:	1004c03a 	cmpne	r2,r2,zero
 d014920:	1000091e 	bne	r2,zero,d014948 <OSTaskDel+0x364>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 d014924:	e0bffc17 	ldw	r2,-16(fp)
 d014928:	10800517 	ldw	r2,20(r2)
 d01492c:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 d014930:	e0bffc17 	ldw	r2,-16(fp)
 d014934:	10c00517 	ldw	r3,20(r2)
 d014938:	00834174 	movhi	r2,3333
 d01493c:	109b0c04 	addi	r2,r2,27696
 d014940:	10c00015 	stw	r3,0(r2)
 d014944:	00000a06 	br	d014970 <OSTaskDel+0x38c>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 d014948:	e0bffc17 	ldw	r2,-16(fp)
 d01494c:	10c00617 	ldw	r3,24(r2)
 d014950:	e0bffc17 	ldw	r2,-16(fp)
 d014954:	10800517 	ldw	r2,20(r2)
 d014958:	18800515 	stw	r2,20(r3)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 d01495c:	e0bffc17 	ldw	r2,-16(fp)
 d014960:	10c00517 	ldw	r3,20(r2)
 d014964:	e0bffc17 	ldw	r2,-16(fp)
 d014968:	10800617 	ldw	r2,24(r2)
 d01496c:	18800615 	stw	r2,24(r3)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 d014970:	00834174 	movhi	r2,3333
 d014974:	109b1004 	addi	r2,r2,27712
 d014978:	10c00017 	ldw	r3,0(r2)
 d01497c:	e0bffc17 	ldw	r2,-16(fp)
 d014980:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 d014984:	00c34174 	movhi	r3,3333
 d014988:	18db1004 	addi	r3,r3,27712
 d01498c:	e0bffc17 	ldw	r2,-16(fp)
 d014990:	18800015 	stw	r2,0(r3)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 d014994:	e0fffc17 	ldw	r3,-16(fp)
 d014998:	00800fc4 	movi	r2,63
 d01499c:	18801305 	stb	r2,76(r3)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 d0149a0:	e0bffc17 	ldw	r2,-16(fp)
 d0149a4:	10001345 	stb	zero,77(r2)
 d0149a8:	e0bffb17 	ldw	r2,-20(fp)
 d0149ac:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0149b0:	e0bff517 	ldw	r2,-44(fp)
 d0149b4:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 d0149b8:	00834174 	movhi	r2,3333
 d0149bc:	109b0944 	addi	r2,r2,27685
 d0149c0:	10800003 	ldbu	r2,0(r2)
 d0149c4:	10803fcc 	andi	r2,r2,255
 d0149c8:	10800058 	cmpnei	r2,r2,1
 d0149cc:	1000011e 	bne	r2,zero,d0149d4 <OSTaskDel+0x3f0>
        OS_Sched();                                     /* Find new highest priority task              */
 d0149d0:	d00f3e40 	call	d00f3e4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 d0149d4:	e03fff15 	stw	zero,-4(fp)
 d0149d8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0149dc:	e037883a 	mov	sp,fp
 d0149e0:	dfc00117 	ldw	ra,4(sp)
 d0149e4:	df000017 	ldw	fp,0(sp)
 d0149e8:	dec00204 	addi	sp,sp,8
 d0149ec:	f800283a 	ret

0d0149f0 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 d0149f0:	defff404 	addi	sp,sp,-48
 d0149f4:	df000b15 	stw	fp,44(sp)
 d0149f8:	df000b04 	addi	fp,sp,44
 d0149fc:	e13ffe05 	stb	r4,-8(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d014a00:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 d014a04:	e0bffe03 	ldbu	r2,-8(fp)
 d014a08:	10800518 	cmpnei	r2,r2,20
 d014a0c:	1000031e 	bne	r2,zero,d014a1c <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 d014a10:	00800f84 	movi	r2,62
 d014a14:	e0bfff15 	stw	r2,-4(fp)
 d014a18:	00004c06 	br	d014b4c <OSTaskDelReq+0x15c>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 d014a1c:	e0bffe03 	ldbu	r2,-8(fp)
 d014a20:	10800530 	cmpltui	r2,r2,20
 d014a24:	1000061e 	bne	r2,zero,d014a40 <OSTaskDelReq+0x50>
        if (prio != OS_PRIO_SELF) {
 d014a28:	e0bffe03 	ldbu	r2,-8(fp)
 d014a2c:	10803fe0 	cmpeqi	r2,r2,255
 d014a30:	1000031e 	bne	r2,zero,d014a40 <OSTaskDelReq+0x50>
            return (OS_ERR_PRIO_INVALID);
 d014a34:	00800a84 	movi	r2,42
 d014a38:	e0bfff15 	stw	r2,-4(fp)
 d014a3c:	00004306 	br	d014b4c <OSTaskDelReq+0x15c>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 d014a40:	e0bffe03 	ldbu	r2,-8(fp)
 d014a44:	10803fd8 	cmpnei	r2,r2,255
 d014a48:	1000141e 	bne	r2,zero,d014a9c <OSTaskDelReq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014a4c:	0005303a 	rdctl	r2,status
 d014a50:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014a54:	e0fffa17 	ldw	r3,-24(fp)
 d014a58:	00bfff84 	movi	r2,-2
 d014a5c:	1884703a 	and	r2,r3,r2
 d014a60:	1001703a 	wrctl	status,r2
  
  return context;
 d014a64:	e0bffa17 	ldw	r2,-24(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 d014a68:	e0bffb15 	stw	r2,-20(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 d014a6c:	00834174 	movhi	r2,3333
 d014a70:	109b1804 	addi	r2,r2,27744
 d014a74:	10800017 	ldw	r2,0(r2)
 d014a78:	10800dc3 	ldbu	r2,55(r2)
 d014a7c:	e0bffd05 	stb	r2,-12(fp)
 d014a80:	e0bffb17 	ldw	r2,-20(fp)
 d014a84:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014a88:	e0bff917 	ldw	r2,-28(fp)
 d014a8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 d014a90:	e0bffd03 	ldbu	r2,-12(fp)
 d014a94:	e0bfff15 	stw	r2,-4(fp)
 d014a98:	00002c06 	br	d014b4c <OSTaskDelReq+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014a9c:	0005303a 	rdctl	r2,status
 d014aa0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014aa4:	e0fff817 	ldw	r3,-32(fp)
 d014aa8:	00bfff84 	movi	r2,-2
 d014aac:	1884703a 	and	r2,r3,r2
 d014ab0:	1001703a 	wrctl	status,r2
  
  return context;
 d014ab4:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 d014ab8:	e0bffb15 	stw	r2,-20(fp)
    ptcb = OSTCBPrioTbl[prio];
 d014abc:	e0bffe03 	ldbu	r2,-8(fp)
 d014ac0:	00c341b4 	movhi	r3,3334
 d014ac4:	18c1b004 	addi	r3,r3,1728
 d014ac8:	1085883a 	add	r2,r2,r2
 d014acc:	1085883a 	add	r2,r2,r2
 d014ad0:	10c5883a 	add	r2,r2,r3
 d014ad4:	10800017 	ldw	r2,0(r2)
 d014ad8:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 d014adc:	e0bffc17 	ldw	r2,-16(fp)
 d014ae0:	1004c03a 	cmpne	r2,r2,zero
 d014ae4:	1000071e 	bne	r2,zero,d014b04 <OSTaskDelReq+0x114>
 d014ae8:	e0bffb17 	ldw	r2,-20(fp)
 d014aec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014af0:	e0bff717 	ldw	r2,-36(fp)
 d014af4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 d014af8:	008010c4 	movi	r2,67
 d014afc:	e0bfff15 	stw	r2,-4(fp)
 d014b00:	00001206 	br	d014b4c <OSTaskDelReq+0x15c>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 d014b04:	e0bffc17 	ldw	r2,-16(fp)
 d014b08:	10800058 	cmpnei	r2,r2,1
 d014b0c:	1000071e 	bne	r2,zero,d014b2c <OSTaskDelReq+0x13c>
 d014b10:	e0bffb17 	ldw	r2,-20(fp)
 d014b14:	e0bff615 	stw	r2,-40(fp)
 d014b18:	e0bff617 	ldw	r2,-40(fp)
 d014b1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 d014b20:	00800f44 	movi	r2,61
 d014b24:	e0bfff15 	stw	r2,-4(fp)
 d014b28:	00000806 	br	d014b4c <OSTaskDelReq+0x15c>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 d014b2c:	e0fffc17 	ldw	r3,-16(fp)
 d014b30:	00800fc4 	movi	r2,63
 d014b34:	18800dc5 	stb	r2,55(r3)
 d014b38:	e0bffb17 	ldw	r2,-20(fp)
 d014b3c:	e0bff515 	stw	r2,-44(fp)
 d014b40:	e0bff517 	ldw	r2,-44(fp)
 d014b44:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d014b48:	e03fff15 	stw	zero,-4(fp)
 d014b4c:	e0bfff17 	ldw	r2,-4(fp)
}
 d014b50:	e037883a 	mov	sp,fp
 d014b54:	df000017 	ldw	fp,0(sp)
 d014b58:	dec00104 	addi	sp,sp,4
 d014b5c:	f800283a 	ret

0d014b60 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 d014b60:	defff304 	addi	sp,sp,-52
 d014b64:	dfc00c15 	stw	ra,48(sp)
 d014b68:	df000b15 	stw	fp,44(sp)
 d014b6c:	df000b04 	addi	fp,sp,44
 d014b70:	e17ffd15 	stw	r5,-12(fp)
 d014b74:	e1bffe15 	stw	r6,-8(fp)
 d014b78:	e13ffc05 	stb	r4,-16(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 d014b7c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 d014b80:	e0bffe17 	ldw	r2,-8(fp)
 d014b84:	1004c03a 	cmpne	r2,r2,zero
 d014b88:	1000021e 	bne	r2,zero,d014b94 <OSTaskNameGet+0x34>
        return (0);
 d014b8c:	e03fff15 	stw	zero,-4(fp)
 d014b90:	00005b06 	br	d014d00 <OSTaskNameGet+0x1a0>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 d014b94:	e0bffc03 	ldbu	r2,-16(fp)
 d014b98:	10800570 	cmpltui	r2,r2,21
 d014b9c:	1000081e 	bne	r2,zero,d014bc0 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 d014ba0:	e0bffc03 	ldbu	r2,-16(fp)
 d014ba4:	10803fe0 	cmpeqi	r2,r2,255
 d014ba8:	1000051e 	bne	r2,zero,d014bc0 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 d014bac:	e0fffe17 	ldw	r3,-8(fp)
 d014bb0:	00800a84 	movi	r2,42
 d014bb4:	18800005 	stb	r2,0(r3)
            return (0);
 d014bb8:	e03fff15 	stw	zero,-4(fp)
 d014bbc:	00005006 	br	d014d00 <OSTaskNameGet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 d014bc0:	e0bffd17 	ldw	r2,-12(fp)
 d014bc4:	1004c03a 	cmpne	r2,r2,zero
 d014bc8:	1000051e 	bne	r2,zero,d014be0 <OSTaskNameGet+0x80>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 d014bcc:	e0fffe17 	ldw	r3,-8(fp)
 d014bd0:	00800304 	movi	r2,12
 d014bd4:	18800005 	stb	r2,0(r3)
        return (0);
 d014bd8:	e03fff15 	stw	zero,-4(fp)
 d014bdc:	00004806 	br	d014d00 <OSTaskNameGet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 d014be0:	00834174 	movhi	r2,3333
 d014be4:	109b1704 	addi	r2,r2,27740
 d014be8:	10800003 	ldbu	r2,0(r2)
 d014bec:	10803fcc 	andi	r2,r2,255
 d014bf0:	1005003a 	cmpeq	r2,r2,zero
 d014bf4:	1000051e 	bne	r2,zero,d014c0c <OSTaskNameGet+0xac>
        *perr = OS_ERR_NAME_GET_ISR;
 d014bf8:	e0fffe17 	ldw	r3,-8(fp)
 d014bfc:	00800444 	movi	r2,17
 d014c00:	18800005 	stb	r2,0(r3)
        return (0);
 d014c04:	e03fff15 	stw	zero,-4(fp)
 d014c08:	00003d06 	br	d014d00 <OSTaskNameGet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014c0c:	0005303a 	rdctl	r2,status
 d014c10:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014c14:	e0fff817 	ldw	r3,-32(fp)
 d014c18:	00bfff84 	movi	r2,-2
 d014c1c:	1884703a 	and	r2,r3,r2
 d014c20:	1001703a 	wrctl	status,r2
  
  return context;
 d014c24:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 d014c28:	e0bff915 	stw	r2,-28(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 d014c2c:	e0bffc03 	ldbu	r2,-16(fp)
 d014c30:	10803fd8 	cmpnei	r2,r2,255
 d014c34:	1000051e 	bne	r2,zero,d014c4c <OSTaskNameGet+0xec>
        prio = OSTCBCur->OSTCBPrio;
 d014c38:	00834174 	movhi	r2,3333
 d014c3c:	109b1804 	addi	r2,r2,27744
 d014c40:	10800017 	ldw	r2,0(r2)
 d014c44:	10800c83 	ldbu	r2,50(r2)
 d014c48:	e0bffc05 	stb	r2,-16(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d014c4c:	e0bffc03 	ldbu	r2,-16(fp)
 d014c50:	00c341b4 	movhi	r3,3334
 d014c54:	18c1b004 	addi	r3,r3,1728
 d014c58:	1085883a 	add	r2,r2,r2
 d014c5c:	1085883a 	add	r2,r2,r2
 d014c60:	10c5883a 	add	r2,r2,r3
 d014c64:	10800017 	ldw	r2,0(r2)
 d014c68:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 d014c6c:	e0bffb17 	ldw	r2,-20(fp)
 d014c70:	1004c03a 	cmpne	r2,r2,zero
 d014c74:	1000091e 	bne	r2,zero,d014c9c <OSTaskNameGet+0x13c>
 d014c78:	e0bff917 	ldw	r2,-28(fp)
 d014c7c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014c80:	e0bff717 	ldw	r2,-36(fp)
 d014c84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d014c88:	e0fffe17 	ldw	r3,-8(fp)
 d014c8c:	008010c4 	movi	r2,67
 d014c90:	18800005 	stb	r2,0(r3)
        return (0);
 d014c94:	e03fff15 	stw	zero,-4(fp)
 d014c98:	00001906 	br	d014d00 <OSTaskNameGet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 d014c9c:	e0bffb17 	ldw	r2,-20(fp)
 d014ca0:	10800058 	cmpnei	r2,r2,1
 d014ca4:	1000091e 	bne	r2,zero,d014ccc <OSTaskNameGet+0x16c>
 d014ca8:	e0bff917 	ldw	r2,-28(fp)
 d014cac:	e0bff615 	stw	r2,-40(fp)
 d014cb0:	e0bff617 	ldw	r2,-40(fp)
 d014cb4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d014cb8:	e0fffe17 	ldw	r3,-8(fp)
 d014cbc:	008010c4 	movi	r2,67
 d014cc0:	18800005 	stb	r2,0(r3)
        return (0);
 d014cc4:	e03fff15 	stw	zero,-4(fp)
 d014cc8:	00000d06 	br	d014d00 <OSTaskNameGet+0x1a0>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 d014ccc:	e0bffb17 	ldw	r2,-20(fp)
 d014cd0:	11401304 	addi	r5,r2,76
 d014cd4:	e13ffd17 	ldw	r4,-12(fp)
 d014cd8:	d00f5280 	call	d00f528 <OS_StrCopy>
 d014cdc:	e0bffa05 	stb	r2,-24(fp)
 d014ce0:	e0bff917 	ldw	r2,-28(fp)
 d014ce4:	e0bff515 	stw	r2,-44(fp)
 d014ce8:	e0bff517 	ldw	r2,-44(fp)
 d014cec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d014cf0:	e0bffe17 	ldw	r2,-8(fp)
 d014cf4:	10000005 	stb	zero,0(r2)
    return (len);
 d014cf8:	e0bffa03 	ldbu	r2,-24(fp)
 d014cfc:	e0bfff15 	stw	r2,-4(fp)
 d014d00:	e0bfff17 	ldw	r2,-4(fp)
}
 d014d04:	e037883a 	mov	sp,fp
 d014d08:	dfc00117 	ldw	ra,4(sp)
 d014d0c:	df000017 	ldw	fp,0(sp)
 d014d10:	dec00204 	addi	sp,sp,8
 d014d14:	f800283a 	ret

0d014d18 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 d014d18:	defff304 	addi	sp,sp,-52
 d014d1c:	dfc00c15 	stw	ra,48(sp)
 d014d20:	df000b15 	stw	fp,44(sp)
 d014d24:	df000b04 	addi	fp,sp,44
 d014d28:	e17ffe15 	stw	r5,-8(fp)
 d014d2c:	e1bfff15 	stw	r6,-4(fp)
 d014d30:	e13ffd05 	stb	r4,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 d014d34:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 d014d38:	e0bfff17 	ldw	r2,-4(fp)
 d014d3c:	1005003a 	cmpeq	r2,r2,zero
 d014d40:	1000611e 	bne	r2,zero,d014ec8 <OSTaskNameSet+0x1b0>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 d014d44:	e0bffd03 	ldbu	r2,-12(fp)
 d014d48:	10800570 	cmpltui	r2,r2,21
 d014d4c:	1000071e 	bne	r2,zero,d014d6c <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 d014d50:	e0bffd03 	ldbu	r2,-12(fp)
 d014d54:	10803fe0 	cmpeqi	r2,r2,255
 d014d58:	1000041e 	bne	r2,zero,d014d6c <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 d014d5c:	e0ffff17 	ldw	r3,-4(fp)
 d014d60:	00800a84 	movi	r2,42
 d014d64:	18800005 	stb	r2,0(r3)
            return;
 d014d68:	00005706 	br	d014ec8 <OSTaskNameSet+0x1b0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 d014d6c:	e0bffe17 	ldw	r2,-8(fp)
 d014d70:	1004c03a 	cmpne	r2,r2,zero
 d014d74:	1000041e 	bne	r2,zero,d014d88 <OSTaskNameSet+0x70>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 d014d78:	e0ffff17 	ldw	r3,-4(fp)
 d014d7c:	00800304 	movi	r2,12
 d014d80:	18800005 	stb	r2,0(r3)
        return;
 d014d84:	00005006 	br	d014ec8 <OSTaskNameSet+0x1b0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 d014d88:	00834174 	movhi	r2,3333
 d014d8c:	109b1704 	addi	r2,r2,27740
 d014d90:	10800003 	ldbu	r2,0(r2)
 d014d94:	10803fcc 	andi	r2,r2,255
 d014d98:	1005003a 	cmpeq	r2,r2,zero
 d014d9c:	1000041e 	bne	r2,zero,d014db0 <OSTaskNameSet+0x98>
        *perr = OS_ERR_NAME_SET_ISR;
 d014da0:	e0ffff17 	ldw	r3,-4(fp)
 d014da4:	00800484 	movi	r2,18
 d014da8:	18800005 	stb	r2,0(r3)
        return;
 d014dac:	00004606 	br	d014ec8 <OSTaskNameSet+0x1b0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014db0:	0005303a 	rdctl	r2,status
 d014db4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014db8:	e0fff917 	ldw	r3,-28(fp)
 d014dbc:	00bfff84 	movi	r2,-2
 d014dc0:	1884703a 	and	r2,r3,r2
 d014dc4:	1001703a 	wrctl	status,r2
  
  return context;
 d014dc8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d014dcc:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 d014dd0:	e0bffd03 	ldbu	r2,-12(fp)
 d014dd4:	10803fd8 	cmpnei	r2,r2,255
 d014dd8:	1000051e 	bne	r2,zero,d014df0 <OSTaskNameSet+0xd8>
        prio = OSTCBCur->OSTCBPrio;
 d014ddc:	00834174 	movhi	r2,3333
 d014de0:	109b1804 	addi	r2,r2,27744
 d014de4:	10800017 	ldw	r2,0(r2)
 d014de8:	10800c83 	ldbu	r2,50(r2)
 d014dec:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d014df0:	e0bffd03 	ldbu	r2,-12(fp)
 d014df4:	00c341b4 	movhi	r3,3334
 d014df8:	18c1b004 	addi	r3,r3,1728
 d014dfc:	1085883a 	add	r2,r2,r2
 d014e00:	1085883a 	add	r2,r2,r2
 d014e04:	10c5883a 	add	r2,r2,r3
 d014e08:	10800017 	ldw	r2,0(r2)
 d014e0c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 d014e10:	e0bffb17 	ldw	r2,-20(fp)
 d014e14:	1004c03a 	cmpne	r2,r2,zero
 d014e18:	1000081e 	bne	r2,zero,d014e3c <OSTaskNameSet+0x124>
 d014e1c:	e0bffa17 	ldw	r2,-24(fp)
 d014e20:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014e24:	e0bff817 	ldw	r2,-32(fp)
 d014e28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d014e2c:	e0ffff17 	ldw	r3,-4(fp)
 d014e30:	008010c4 	movi	r2,67
 d014e34:	18800005 	stb	r2,0(r3)
        return;
 d014e38:	00002306 	br	d014ec8 <OSTaskNameSet+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 d014e3c:	e0bffb17 	ldw	r2,-20(fp)
 d014e40:	10800058 	cmpnei	r2,r2,1
 d014e44:	1000081e 	bne	r2,zero,d014e68 <OSTaskNameSet+0x150>
 d014e48:	e0bffa17 	ldw	r2,-24(fp)
 d014e4c:	e0bff715 	stw	r2,-36(fp)
 d014e50:	e0bff717 	ldw	r2,-36(fp)
 d014e54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d014e58:	e0ffff17 	ldw	r3,-4(fp)
 d014e5c:	008010c4 	movi	r2,67
 d014e60:	18800005 	stb	r2,0(r3)
        return;
 d014e64:	00001806 	br	d014ec8 <OSTaskNameSet+0x1b0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 d014e68:	e13ffe17 	ldw	r4,-8(fp)
 d014e6c:	d00f5a80 	call	d00f5a8 <OS_StrLen>
 d014e70:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 d014e74:	e0bffc03 	ldbu	r2,-16(fp)
 d014e78:	10800830 	cmpltui	r2,r2,32
 d014e7c:	1000081e 	bne	r2,zero,d014ea0 <OSTaskNameSet+0x188>
 d014e80:	e0bffa17 	ldw	r2,-24(fp)
 d014e84:	e0bff615 	stw	r2,-40(fp)
 d014e88:	e0bff617 	ldw	r2,-40(fp)
 d014e8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 d014e90:	e0ffff17 	ldw	r3,-4(fp)
 d014e94:	00801044 	movi	r2,65
 d014e98:	18800005 	stb	r2,0(r3)
        return;
 d014e9c:	00000a06 	br	d014ec8 <OSTaskNameSet+0x1b0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 d014ea0:	e0bffb17 	ldw	r2,-20(fp)
 d014ea4:	11001304 	addi	r4,r2,76
 d014ea8:	e17ffe17 	ldw	r5,-8(fp)
 d014eac:	d00f5280 	call	d00f528 <OS_StrCopy>
 d014eb0:	e0bffa17 	ldw	r2,-24(fp)
 d014eb4:	e0bff515 	stw	r2,-44(fp)
 d014eb8:	e0bff517 	ldw	r2,-44(fp)
 d014ebc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d014ec0:	e0bfff17 	ldw	r2,-4(fp)
 d014ec4:	10000005 	stb	zero,0(r2)
}
 d014ec8:	e037883a 	mov	sp,fp
 d014ecc:	dfc00117 	ldw	ra,4(sp)
 d014ed0:	df000017 	ldw	fp,0(sp)
 d014ed4:	dec00204 	addi	sp,sp,8
 d014ed8:	f800283a 	ret

0d014edc <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 d014edc:	defff304 	addi	sp,sp,-52
 d014ee0:	dfc00c15 	stw	ra,48(sp)
 d014ee4:	df000b15 	stw	fp,44(sp)
 d014ee8:	df000b04 	addi	fp,sp,44
 d014eec:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 d014ef0:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 d014ef4:	e0bffe03 	ldbu	r2,-8(fp)
 d014ef8:	10800530 	cmpltui	r2,r2,20
 d014efc:	1000031e 	bne	r2,zero,d014f0c <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 d014f00:	00800a84 	movi	r2,42
 d014f04:	e0bfff15 	stw	r2,-4(fp)
 d014f08:	00007406 	br	d0150dc <OSTaskResume+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014f0c:	0005303a 	rdctl	r2,status
 d014f10:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014f14:	e0fffb17 	ldw	r3,-20(fp)
 d014f18:	00bfff84 	movi	r2,-2
 d014f1c:	1884703a 	and	r2,r3,r2
 d014f20:	1001703a 	wrctl	status,r2
  
  return context;
 d014f24:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d014f28:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];
 d014f2c:	e0bffe03 	ldbu	r2,-8(fp)
 d014f30:	00c341b4 	movhi	r3,3334
 d014f34:	18c1b004 	addi	r3,r3,1728
 d014f38:	1085883a 	add	r2,r2,r2
 d014f3c:	1085883a 	add	r2,r2,r2
 d014f40:	10c5883a 	add	r2,r2,r3
 d014f44:	10800017 	ldw	r2,0(r2)
 d014f48:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 d014f4c:	e0bffd17 	ldw	r2,-12(fp)
 d014f50:	1004c03a 	cmpne	r2,r2,zero
 d014f54:	1000071e 	bne	r2,zero,d014f74 <OSTaskResume+0x98>
 d014f58:	e0bffc17 	ldw	r2,-16(fp)
 d014f5c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014f60:	e0bffa17 	ldw	r2,-24(fp)
 d014f64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 d014f68:	00801184 	movi	r2,70
 d014f6c:	e0bfff15 	stw	r2,-4(fp)
 d014f70:	00005a06 	br	d0150dc <OSTaskResume+0x200>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 d014f74:	e0bffd17 	ldw	r2,-12(fp)
 d014f78:	10800058 	cmpnei	r2,r2,1
 d014f7c:	1000071e 	bne	r2,zero,d014f9c <OSTaskResume+0xc0>
 d014f80:	e0bffc17 	ldw	r2,-16(fp)
 d014f84:	e0bff915 	stw	r2,-28(fp)
 d014f88:	e0bff917 	ldw	r2,-28(fp)
 d014f8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d014f90:	008010c4 	movi	r2,67
 d014f94:	e0bfff15 	stw	r2,-4(fp)
 d014f98:	00005006 	br	d0150dc <OSTaskResume+0x200>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 d014f9c:	e0bffd17 	ldw	r2,-12(fp)
 d014fa0:	10800c03 	ldbu	r2,48(r2)
 d014fa4:	10803fcc 	andi	r2,r2,255
 d014fa8:	1080020c 	andi	r2,r2,8
 d014fac:	1005003a 	cmpeq	r2,r2,zero
 d014fb0:	1000441e 	bne	r2,zero,d0150c4 <OSTaskResume+0x1e8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 d014fb4:	e0bffd17 	ldw	r2,-12(fp)
 d014fb8:	10c00c03 	ldbu	r3,48(r2)
 d014fbc:	00bffdc4 	movi	r2,-9
 d014fc0:	1884703a 	and	r2,r3,r2
 d014fc4:	1007883a 	mov	r3,r2
 d014fc8:	e0bffd17 	ldw	r2,-12(fp)
 d014fcc:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 d014fd0:	e0bffd17 	ldw	r2,-12(fp)
 d014fd4:	10800c03 	ldbu	r2,48(r2)
 d014fd8:	10803fcc 	andi	r2,r2,255
 d014fdc:	1004c03a 	cmpne	r2,r2,zero
 d014fe0:	1000321e 	bne	r2,zero,d0150ac <OSTaskResume+0x1d0>
            if (ptcb->OSTCBDly == 0) {
 d014fe4:	e0bffd17 	ldw	r2,-12(fp)
 d014fe8:	10800b8b 	ldhu	r2,46(r2)
 d014fec:	10bfffcc 	andi	r2,r2,65535
 d014ff0:	1004c03a 	cmpne	r2,r2,zero
 d014ff4:	1000281e 	bne	r2,zero,d015098 <OSTaskResume+0x1bc>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 d014ff8:	e0bffd17 	ldw	r2,-12(fp)
 d014ffc:	10c00d83 	ldbu	r3,54(r2)
 d015000:	00834174 	movhi	r2,3333
 d015004:	109b1504 	addi	r2,r2,27732
 d015008:	10800003 	ldbu	r2,0(r2)
 d01500c:	1884b03a 	or	r2,r3,r2
 d015010:	1007883a 	mov	r3,r2
 d015014:	00834174 	movhi	r2,3333
 d015018:	109b1504 	addi	r2,r2,27732
 d01501c:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d015020:	e0bffd17 	ldw	r2,-12(fp)
 d015024:	10800d03 	ldbu	r2,52(r2)
 d015028:	11003fcc 	andi	r4,r2,255
 d01502c:	e0bffd17 	ldw	r2,-12(fp)
 d015030:	10800d03 	ldbu	r2,52(r2)
 d015034:	10c03fcc 	andi	r3,r2,255
 d015038:	00834174 	movhi	r2,3333
 d01503c:	109b1544 	addi	r2,r2,27733
 d015040:	10c5883a 	add	r2,r2,r3
 d015044:	10c00003 	ldbu	r3,0(r2)
 d015048:	e0bffd17 	ldw	r2,-12(fp)
 d01504c:	10800d43 	ldbu	r2,53(r2)
 d015050:	1884b03a 	or	r2,r3,r2
 d015054:	1007883a 	mov	r3,r2
 d015058:	00834174 	movhi	r2,3333
 d01505c:	109b1544 	addi	r2,r2,27733
 d015060:	1105883a 	add	r2,r2,r4
 d015064:	10c00005 	stb	r3,0(r2)
 d015068:	e0bffc17 	ldw	r2,-16(fp)
 d01506c:	e0bff815 	stw	r2,-32(fp)
 d015070:	e0bff817 	ldw	r2,-32(fp)
 d015074:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 d015078:	00834174 	movhi	r2,3333
 d01507c:	109b0944 	addi	r2,r2,27685
 d015080:	10800003 	ldbu	r2,0(r2)
 d015084:	10803fcc 	andi	r2,r2,255
 d015088:	10800058 	cmpnei	r2,r2,1
 d01508c:	10000b1e 	bne	r2,zero,d0150bc <OSTaskResume+0x1e0>
                    OS_Sched();                               /* Find new highest priority task        */
 d015090:	d00f3e40 	call	d00f3e4 <OS_Sched>
 d015094:	00000906 	br	d0150bc <OSTaskResume+0x1e0>
 d015098:	e0bffc17 	ldw	r2,-16(fp)
 d01509c:	e0bff715 	stw	r2,-36(fp)
 d0150a0:	e0bff717 	ldw	r2,-36(fp)
 d0150a4:	1001703a 	wrctl	status,r2
 d0150a8:	00000406 	br	d0150bc <OSTaskResume+0x1e0>
 d0150ac:	e0bffc17 	ldw	r2,-16(fp)
 d0150b0:	e0bff615 	stw	r2,-40(fp)
 d0150b4:	e0bff617 	ldw	r2,-40(fp)
 d0150b8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 d0150bc:	e03fff15 	stw	zero,-4(fp)
 d0150c0:	00000606 	br	d0150dc <OSTaskResume+0x200>
 d0150c4:	e0bffc17 	ldw	r2,-16(fp)
 d0150c8:	e0bff515 	stw	r2,-44(fp)
 d0150cc:	e0bff517 	ldw	r2,-44(fp)
 d0150d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 d0150d4:	00801104 	movi	r2,68
 d0150d8:	e0bfff15 	stw	r2,-4(fp)
 d0150dc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0150e0:	e037883a 	mov	sp,fp
 d0150e4:	dfc00117 	ldw	ra,4(sp)
 d0150e8:	df000017 	ldw	fp,0(sp)
 d0150ec:	dec00204 	addi	sp,sp,8
 d0150f0:	f800283a 	ret

0d0150f4 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 d0150f4:	defff204 	addi	sp,sp,-56
 d0150f8:	df000d15 	stw	fp,52(sp)
 d0150fc:	df000d04 	addi	fp,sp,52
 d015100:	e17ffe15 	stw	r5,-8(fp)
 d015104:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d015108:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 d01510c:	e0bffd03 	ldbu	r2,-12(fp)
 d015110:	10800570 	cmpltui	r2,r2,21
 d015114:	1000061e 	bne	r2,zero,d015130 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 d015118:	e0bffd03 	ldbu	r2,-12(fp)
 d01511c:	10803fe0 	cmpeqi	r2,r2,255
 d015120:	1000031e 	bne	r2,zero,d015130 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 d015124:	00800a84 	movi	r2,42
 d015128:	e0bfff15 	stw	r2,-4(fp)
 d01512c:	00006b06 	br	d0152dc <OSTaskStkChk+0x1e8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 d015130:	e0bffe17 	ldw	r2,-8(fp)
 d015134:	1004c03a 	cmpne	r2,r2,zero
 d015138:	1000031e 	bne	r2,zero,d015148 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
 d01513c:	00800244 	movi	r2,9
 d015140:	e0bfff15 	stw	r2,-4(fp)
 d015144:	00006506 	br	d0152dc <OSTaskStkChk+0x1e8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 d015148:	e0bffe17 	ldw	r2,-8(fp)
 d01514c:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 d015150:	e0bffe17 	ldw	r2,-8(fp)
 d015154:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015158:	0005303a 	rdctl	r2,status
 d01515c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d015160:	e0fff717 	ldw	r3,-36(fp)
 d015164:	00bfff84 	movi	r2,-2
 d015168:	1884703a 	and	r2,r3,r2
 d01516c:	1001703a 	wrctl	status,r2
  
  return context;
 d015170:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 d015174:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 d015178:	e0bffd03 	ldbu	r2,-12(fp)
 d01517c:	10803fd8 	cmpnei	r2,r2,255
 d015180:	1000051e 	bne	r2,zero,d015198 <OSTaskStkChk+0xa4>
        prio = OSTCBCur->OSTCBPrio;
 d015184:	00834174 	movhi	r2,3333
 d015188:	109b1804 	addi	r2,r2,27744
 d01518c:	10800017 	ldw	r2,0(r2)
 d015190:	10800c83 	ldbu	r2,50(r2)
 d015194:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d015198:	e0bffd03 	ldbu	r2,-12(fp)
 d01519c:	00c341b4 	movhi	r3,3334
 d0151a0:	18c1b004 	addi	r3,r3,1728
 d0151a4:	1085883a 	add	r2,r2,r2
 d0151a8:	1085883a 	add	r2,r2,r2
 d0151ac:	10c5883a 	add	r2,r2,r3
 d0151b0:	10800017 	ldw	r2,0(r2)
 d0151b4:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 d0151b8:	e0bffc17 	ldw	r2,-16(fp)
 d0151bc:	1004c03a 	cmpne	r2,r2,zero
 d0151c0:	1000071e 	bne	r2,zero,d0151e0 <OSTaskStkChk+0xec>
 d0151c4:	e0bff817 	ldw	r2,-32(fp)
 d0151c8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0151cc:	e0bff617 	ldw	r2,-40(fp)
 d0151d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d0151d4:	008010c4 	movi	r2,67
 d0151d8:	e0bfff15 	stw	r2,-4(fp)
 d0151dc:	00003f06 	br	d0152dc <OSTaskStkChk+0x1e8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 d0151e0:	e0bffc17 	ldw	r2,-16(fp)
 d0151e4:	10800058 	cmpnei	r2,r2,1
 d0151e8:	1000071e 	bne	r2,zero,d015208 <OSTaskStkChk+0x114>
 d0151ec:	e0bff817 	ldw	r2,-32(fp)
 d0151f0:	e0bff515 	stw	r2,-44(fp)
 d0151f4:	e0bff517 	ldw	r2,-44(fp)
 d0151f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d0151fc:	008010c4 	movi	r2,67
 d015200:	e0bfff15 	stw	r2,-4(fp)
 d015204:	00003506 	br	d0152dc <OSTaskStkChk+0x1e8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 d015208:	e0bffc17 	ldw	r2,-16(fp)
 d01520c:	1080040b 	ldhu	r2,16(r2)
 d015210:	10bfffcc 	andi	r2,r2,65535
 d015214:	1080004c 	andi	r2,r2,1
 d015218:	1004c03a 	cmpne	r2,r2,zero
 d01521c:	1000071e 	bne	r2,zero,d01523c <OSTaskStkChk+0x148>
 d015220:	e0bff817 	ldw	r2,-32(fp)
 d015224:	e0bff415 	stw	r2,-48(fp)
 d015228:	e0bff417 	ldw	r2,-48(fp)
 d01522c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 d015230:	00801144 	movi	r2,69
 d015234:	e0bfff15 	stw	r2,-4(fp)
 d015238:	00002806 	br	d0152dc <OSTaskStkChk+0x1e8>
    }
    nfree = 0;
 d01523c:	e03ffa15 	stw	zero,-24(fp)
    size  = ptcb->OSTCBStkSize;
 d015240:	e0bffc17 	ldw	r2,-16(fp)
 d015244:	10800317 	ldw	r2,12(r2)
 d015248:	e0bff915 	stw	r2,-28(fp)
    pchk  = ptcb->OSTCBStkBottom;
 d01524c:	e0bffc17 	ldw	r2,-16(fp)
 d015250:	10800217 	ldw	r2,8(r2)
 d015254:	e0bffb15 	stw	r2,-20(fp)
 d015258:	e0bff817 	ldw	r2,-32(fp)
 d01525c:	e0bff315 	stw	r2,-52(fp)
 d015260:	e0bff317 	ldw	r2,-52(fp)
 d015264:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 d015268:	00000306 	br	d015278 <OSTaskStkChk+0x184>
        nfree++;
 d01526c:	e0bffa17 	ldw	r2,-24(fp)
 d015270:	10800044 	addi	r2,r2,1
 d015274:	e0bffa15 	stw	r2,-24(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 d015278:	e0bffb17 	ldw	r2,-20(fp)
 d01527c:	10800017 	ldw	r2,0(r2)
 d015280:	1005003a 	cmpeq	r2,r2,zero
 d015284:	1007883a 	mov	r3,r2
 d015288:	e0bffb17 	ldw	r2,-20(fp)
 d01528c:	10800104 	addi	r2,r2,4
 d015290:	e0bffb15 	stw	r2,-20(fp)
 d015294:	18803fcc 	andi	r2,r3,255
 d015298:	1004c03a 	cmpne	r2,r2,zero
 d01529c:	103ff31e 	bne	r2,zero,d01526c <OSTaskStkChk+0x178>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 d0152a0:	e0bffa17 	ldw	r2,-24(fp)
 d0152a4:	1085883a 	add	r2,r2,r2
 d0152a8:	1085883a 	add	r2,r2,r2
 d0152ac:	1007883a 	mov	r3,r2
 d0152b0:	e0bffe17 	ldw	r2,-8(fp)
 d0152b4:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 d0152b8:	e0fff917 	ldw	r3,-28(fp)
 d0152bc:	e0bffa17 	ldw	r2,-24(fp)
 d0152c0:	1885c83a 	sub	r2,r3,r2
 d0152c4:	1085883a 	add	r2,r2,r2
 d0152c8:	1085883a 	add	r2,r2,r2
 d0152cc:	1007883a 	mov	r3,r2
 d0152d0:	e0bffe17 	ldw	r2,-8(fp)
 d0152d4:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 d0152d8:	e03fff15 	stw	zero,-4(fp)
 d0152dc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0152e0:	e037883a 	mov	sp,fp
 d0152e4:	df000017 	ldw	fp,0(sp)
 d0152e8:	dec00104 	addi	sp,sp,4
 d0152ec:	f800283a 	ret

0d0152f0 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 d0152f0:	defff404 	addi	sp,sp,-48
 d0152f4:	dfc00b15 	stw	ra,44(sp)
 d0152f8:	df000a15 	stw	fp,40(sp)
 d0152fc:	df000a04 	addi	fp,sp,40
 d015300:	e13ffe05 	stb	r4,-8(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d015304:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 d015308:	e0bffe03 	ldbu	r2,-8(fp)
 d01530c:	10800518 	cmpnei	r2,r2,20
 d015310:	1000031e 	bne	r2,zero,d015320 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 d015314:	008011c4 	movi	r2,71
 d015318:	e0bfff15 	stw	r2,-4(fp)
 d01531c:	00007906 	br	d015504 <OSTaskSuspend+0x214>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 d015320:	e0bffe03 	ldbu	r2,-8(fp)
 d015324:	10800530 	cmpltui	r2,r2,20
 d015328:	1000061e 	bne	r2,zero,d015344 <OSTaskSuspend+0x54>
        if (prio != OS_PRIO_SELF) {
 d01532c:	e0bffe03 	ldbu	r2,-8(fp)
 d015330:	10803fe0 	cmpeqi	r2,r2,255
 d015334:	1000031e 	bne	r2,zero,d015344 <OSTaskSuspend+0x54>
            return (OS_ERR_PRIO_INVALID);
 d015338:	00800a84 	movi	r2,42
 d01533c:	e0bfff15 	stw	r2,-4(fp)
 d015340:	00007006 	br	d015504 <OSTaskSuspend+0x214>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015344:	0005303a 	rdctl	r2,status
 d015348:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01534c:	e0fff917 	ldw	r3,-28(fp)
 d015350:	00bfff84 	movi	r2,-2
 d015354:	1884703a 	and	r2,r3,r2
 d015358:	1001703a 	wrctl	status,r2
  
  return context;
 d01535c:	e0bff917 	ldw	r2,-28(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 d015360:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 d015364:	e0bffe03 	ldbu	r2,-8(fp)
 d015368:	10803fd8 	cmpnei	r2,r2,255
 d01536c:	1000081e 	bne	r2,zero,d015390 <OSTaskSuspend+0xa0>
        prio = OSTCBCur->OSTCBPrio;
 d015370:	00834174 	movhi	r2,3333
 d015374:	109b1804 	addi	r2,r2,27744
 d015378:	10800017 	ldw	r2,0(r2)
 d01537c:	10800c83 	ldbu	r2,50(r2)
 d015380:	e0bffe05 	stb	r2,-8(fp)
        self = OS_TRUE;
 d015384:	00800044 	movi	r2,1
 d015388:	e0bffd05 	stb	r2,-12(fp)
 d01538c:	00000b06 	br	d0153bc <OSTaskSuspend+0xcc>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 d015390:	00834174 	movhi	r2,3333
 d015394:	109b1804 	addi	r2,r2,27744
 d015398:	10800017 	ldw	r2,0(r2)
 d01539c:	10800c83 	ldbu	r2,50(r2)
 d0153a0:	10c03fcc 	andi	r3,r2,255
 d0153a4:	e0bffe03 	ldbu	r2,-8(fp)
 d0153a8:	1880031e 	bne	r3,r2,d0153b8 <OSTaskSuspend+0xc8>
        self = OS_TRUE;
 d0153ac:	00800044 	movi	r2,1
 d0153b0:	e0bffd05 	stb	r2,-12(fp)
 d0153b4:	00000106 	br	d0153bc <OSTaskSuspend+0xcc>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 d0153b8:	e03ffd05 	stb	zero,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d0153bc:	e0bffe03 	ldbu	r2,-8(fp)
 d0153c0:	00c341b4 	movhi	r3,3334
 d0153c4:	18c1b004 	addi	r3,r3,1728
 d0153c8:	1085883a 	add	r2,r2,r2
 d0153cc:	1085883a 	add	r2,r2,r2
 d0153d0:	10c5883a 	add	r2,r2,r3
 d0153d4:	10800017 	ldw	r2,0(r2)
 d0153d8:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 d0153dc:	e0bffc17 	ldw	r2,-16(fp)
 d0153e0:	1004c03a 	cmpne	r2,r2,zero
 d0153e4:	1000071e 	bne	r2,zero,d015404 <OSTaskSuspend+0x114>
 d0153e8:	e0bffa17 	ldw	r2,-24(fp)
 d0153ec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0153f0:	e0bff817 	ldw	r2,-32(fp)
 d0153f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 d0153f8:	00801204 	movi	r2,72
 d0153fc:	e0bfff15 	stw	r2,-4(fp)
 d015400:	00004006 	br	d015504 <OSTaskSuspend+0x214>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 d015404:	e0bffc17 	ldw	r2,-16(fp)
 d015408:	10800058 	cmpnei	r2,r2,1
 d01540c:	1000071e 	bne	r2,zero,d01542c <OSTaskSuspend+0x13c>
 d015410:	e0bffa17 	ldw	r2,-24(fp)
 d015414:	e0bff715 	stw	r2,-36(fp)
 d015418:	e0bff717 	ldw	r2,-36(fp)
 d01541c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d015420:	008010c4 	movi	r2,67
 d015424:	e0bfff15 	stw	r2,-4(fp)
 d015428:	00003606 	br	d015504 <OSTaskSuspend+0x214>
    }
    y            = ptcb->OSTCBY;
 d01542c:	e0bffc17 	ldw	r2,-16(fp)
 d015430:	10800d03 	ldbu	r2,52(r2)
 d015434:	e0bffb05 	stb	r2,-20(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 d015438:	e13ffb03 	ldbu	r4,-20(fp)
 d01543c:	e0fffb03 	ldbu	r3,-20(fp)
 d015440:	00834174 	movhi	r2,3333
 d015444:	109b1544 	addi	r2,r2,27733
 d015448:	10c5883a 	add	r2,r2,r3
 d01544c:	10800003 	ldbu	r2,0(r2)
 d015450:	1007883a 	mov	r3,r2
 d015454:	e0bffc17 	ldw	r2,-16(fp)
 d015458:	10800d43 	ldbu	r2,53(r2)
 d01545c:	0084303a 	nor	r2,zero,r2
 d015460:	1884703a 	and	r2,r3,r2
 d015464:	1007883a 	mov	r3,r2
 d015468:	00834174 	movhi	r2,3333
 d01546c:	109b1544 	addi	r2,r2,27733
 d015470:	1105883a 	add	r2,r2,r4
 d015474:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 d015478:	e0fffb03 	ldbu	r3,-20(fp)
 d01547c:	00834174 	movhi	r2,3333
 d015480:	109b1544 	addi	r2,r2,27733
 d015484:	10c5883a 	add	r2,r2,r3
 d015488:	10800003 	ldbu	r2,0(r2)
 d01548c:	10803fcc 	andi	r2,r2,255
 d015490:	1004c03a 	cmpne	r2,r2,zero
 d015494:	10000c1e 	bne	r2,zero,d0154c8 <OSTaskSuspend+0x1d8>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 d015498:	e0bffc17 	ldw	r2,-16(fp)
 d01549c:	10800d83 	ldbu	r2,54(r2)
 d0154a0:	0084303a 	nor	r2,zero,r2
 d0154a4:	1007883a 	mov	r3,r2
 d0154a8:	00834174 	movhi	r2,3333
 d0154ac:	109b1504 	addi	r2,r2,27732
 d0154b0:	10800003 	ldbu	r2,0(r2)
 d0154b4:	1884703a 	and	r2,r3,r2
 d0154b8:	1007883a 	mov	r3,r2
 d0154bc:	00834174 	movhi	r2,3333
 d0154c0:	109b1504 	addi	r2,r2,27732
 d0154c4:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 d0154c8:	e0bffc17 	ldw	r2,-16(fp)
 d0154cc:	10800c03 	ldbu	r2,48(r2)
 d0154d0:	10800214 	ori	r2,r2,8
 d0154d4:	1007883a 	mov	r3,r2
 d0154d8:	e0bffc17 	ldw	r2,-16(fp)
 d0154dc:	10c00c05 	stb	r3,48(r2)
 d0154e0:	e0bffa17 	ldw	r2,-24(fp)
 d0154e4:	e0bff615 	stw	r2,-40(fp)
 d0154e8:	e0bff617 	ldw	r2,-40(fp)
 d0154ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 d0154f0:	e0bffd03 	ldbu	r2,-12(fp)
 d0154f4:	10800058 	cmpnei	r2,r2,1
 d0154f8:	1000011e 	bne	r2,zero,d015500 <OSTaskSuspend+0x210>
        OS_Sched();                                             /* Find new highest priority task      */
 d0154fc:	d00f3e40 	call	d00f3e4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 d015500:	e03fff15 	stw	zero,-4(fp)
 d015504:	e0bfff17 	ldw	r2,-4(fp)
}
 d015508:	e037883a 	mov	sp,fp
 d01550c:	dfc00117 	ldw	ra,4(sp)
 d015510:	df000017 	ldw	fp,0(sp)
 d015514:	dec00204 	addi	sp,sp,8
 d015518:	f800283a 	ret

0d01551c <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 d01551c:	defff504 	addi	sp,sp,-44
 d015520:	dfc00a15 	stw	ra,40(sp)
 d015524:	df000915 	stw	fp,36(sp)
 d015528:	df000904 	addi	fp,sp,36
 d01552c:	e17ffe15 	stw	r5,-8(fp)
 d015530:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d015534:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 d015538:	e0bffd03 	ldbu	r2,-12(fp)
 d01553c:	10800570 	cmpltui	r2,r2,21
 d015540:	1000061e 	bne	r2,zero,d01555c <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 d015544:	e0bffd03 	ldbu	r2,-12(fp)
 d015548:	10803fe0 	cmpeqi	r2,r2,255
 d01554c:	1000031e 	bne	r2,zero,d01555c <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 d015550:	00800a84 	movi	r2,42
 d015554:	e0bfff15 	stw	r2,-4(fp)
 d015558:	00003b06 	br	d015648 <OSTaskQuery+0x12c>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 d01555c:	e0bffe17 	ldw	r2,-8(fp)
 d015560:	1004c03a 	cmpne	r2,r2,zero
 d015564:	1000031e 	bne	r2,zero,d015574 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
 d015568:	00800244 	movi	r2,9
 d01556c:	e0bfff15 	stw	r2,-4(fp)
 d015570:	00003506 	br	d015648 <OSTaskQuery+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015574:	0005303a 	rdctl	r2,status
 d015578:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01557c:	e0fffa17 	ldw	r3,-24(fp)
 d015580:	00bfff84 	movi	r2,-2
 d015584:	1884703a 	and	r2,r3,r2
 d015588:	1001703a 	wrctl	status,r2
  
  return context;
 d01558c:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d015590:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 d015594:	e0bffd03 	ldbu	r2,-12(fp)
 d015598:	10803fd8 	cmpnei	r2,r2,255
 d01559c:	1000051e 	bne	r2,zero,d0155b4 <OSTaskQuery+0x98>
        prio = OSTCBCur->OSTCBPrio;
 d0155a0:	00834174 	movhi	r2,3333
 d0155a4:	109b1804 	addi	r2,r2,27744
 d0155a8:	10800017 	ldw	r2,0(r2)
 d0155ac:	10800c83 	ldbu	r2,50(r2)
 d0155b0:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d0155b4:	e0bffd03 	ldbu	r2,-12(fp)
 d0155b8:	00c341b4 	movhi	r3,3334
 d0155bc:	18c1b004 	addi	r3,r3,1728
 d0155c0:	1085883a 	add	r2,r2,r2
 d0155c4:	1085883a 	add	r2,r2,r2
 d0155c8:	10c5883a 	add	r2,r2,r3
 d0155cc:	10800017 	ldw	r2,0(r2)
 d0155d0:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 d0155d4:	e0bffc17 	ldw	r2,-16(fp)
 d0155d8:	1004c03a 	cmpne	r2,r2,zero
 d0155dc:	1000071e 	bne	r2,zero,d0155fc <OSTaskQuery+0xe0>
 d0155e0:	e0bffb17 	ldw	r2,-20(fp)
 d0155e4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0155e8:	e0bff917 	ldw	r2,-28(fp)
 d0155ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 d0155f0:	00800a44 	movi	r2,41
 d0155f4:	e0bfff15 	stw	r2,-4(fp)
 d0155f8:	00001306 	br	d015648 <OSTaskQuery+0x12c>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 d0155fc:	e0bffc17 	ldw	r2,-16(fp)
 d015600:	10800058 	cmpnei	r2,r2,1
 d015604:	1000071e 	bne	r2,zero,d015624 <OSTaskQuery+0x108>
 d015608:	e0bffb17 	ldw	r2,-20(fp)
 d01560c:	e0bff815 	stw	r2,-32(fp)
 d015610:	e0bff817 	ldw	r2,-32(fp)
 d015614:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d015618:	008010c4 	movi	r2,67
 d01561c:	e0bfff15 	stw	r2,-4(fp)
 d015620:	00000906 	br	d015648 <OSTaskQuery+0x12c>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 d015624:	e13ffe17 	ldw	r4,-8(fp)
 d015628:	e17ffc17 	ldw	r5,-16(fp)
 d01562c:	01801b04 	movi	r6,108
 d015630:	d00f3780 	call	d00f378 <OS_MemCopy>
 d015634:	e0bffb17 	ldw	r2,-20(fp)
 d015638:	e0bff715 	stw	r2,-36(fp)
 d01563c:	e0bff717 	ldw	r2,-36(fp)
 d015640:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d015644:	e03fff15 	stw	zero,-4(fp)
 d015648:	e0bfff17 	ldw	r2,-4(fp)
}
 d01564c:	e037883a 	mov	sp,fp
 d015650:	dfc00117 	ldw	ra,4(sp)
 d015654:	df000017 	ldw	fp,0(sp)
 d015658:	dec00204 	addi	sp,sp,8
 d01565c:	f800283a 	ret

0d015660 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 d015660:	defffc04 	addi	sp,sp,-16
 d015664:	df000315 	stw	fp,12(sp)
 d015668:	df000304 	addi	fp,sp,12
 d01566c:	e13ffd15 	stw	r4,-12(fp)
 d015670:	e17ffe15 	stw	r5,-8(fp)
 d015674:	e1bfff0d 	sth	r6,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 d015678:	e0bfff0b 	ldhu	r2,-4(fp)
 d01567c:	1080004c 	andi	r2,r2,1
 d015680:	10803fcc 	andi	r2,r2,255
 d015684:	1005003a 	cmpeq	r2,r2,zero
 d015688:	1000101e 	bne	r2,zero,d0156cc <OS_TaskStkClr+0x6c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 d01568c:	e0bfff0b 	ldhu	r2,-4(fp)
 d015690:	1080008c 	andi	r2,r2,2
 d015694:	1005003a 	cmpeq	r2,r2,zero
 d015698:	10000c1e 	bne	r2,zero,d0156cc <OS_TaskStkClr+0x6c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 d01569c:	00000806 	br	d0156c0 <OS_TaskStkClr+0x60>
                size--;
 d0156a0:	e0bffe17 	ldw	r2,-8(fp)
 d0156a4:	10bfffc4 	addi	r2,r2,-1
 d0156a8:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 d0156ac:	e0bffd17 	ldw	r2,-12(fp)
 d0156b0:	10000015 	stw	zero,0(r2)
 d0156b4:	e0bffd17 	ldw	r2,-12(fp)
 d0156b8:	10800104 	addi	r2,r2,4
 d0156bc:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 d0156c0:	e0bffe17 	ldw	r2,-8(fp)
 d0156c4:	1004c03a 	cmpne	r2,r2,zero
 d0156c8:	103ff51e 	bne	r2,zero,d0156a0 <OS_TaskStkClr+0x40>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 d0156cc:	e037883a 	mov	sp,fp
 d0156d0:	df000017 	ldw	fp,0(sp)
 d0156d4:	dec00104 	addi	sp,sp,4
 d0156d8:	f800283a 	ret

0d0156dc <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 d0156dc:	defff904 	addi	sp,sp,-28
 d0156e0:	dfc00615 	stw	ra,24(sp)
 d0156e4:	df000515 	stw	fp,20(sp)
 d0156e8:	df000504 	addi	fp,sp,20
 d0156ec:	e13fff0d 	sth	r4,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0156f0:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d0156f4:	00834174 	movhi	r2,3333
 d0156f8:	109b1704 	addi	r2,r2,27740
 d0156fc:	10800003 	ldbu	r2,0(r2)
 d015700:	10803fcc 	andi	r2,r2,255
 d015704:	1004c03a 	cmpne	r2,r2,zero
 d015708:	1000421e 	bne	r2,zero,d015814 <OSTimeDly+0x138>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 d01570c:	e0bfff0b 	ldhu	r2,-4(fp)
 d015710:	1005003a 	cmpeq	r2,r2,zero
 d015714:	10003f1e 	bne	r2,zero,d015814 <OSTimeDly+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015718:	0005303a 	rdctl	r2,status
 d01571c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d015720:	e0fffc17 	ldw	r3,-16(fp)
 d015724:	00bfff84 	movi	r2,-2
 d015728:	1884703a 	and	r2,r3,r2
 d01572c:	1001703a 	wrctl	status,r2
  
  return context;
 d015730:	e0bffc17 	ldw	r2,-16(fp)
        OS_ENTER_CRITICAL();
 d015734:	e0bffd15 	stw	r2,-12(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 d015738:	00834174 	movhi	r2,3333
 d01573c:	109b1804 	addi	r2,r2,27744
 d015740:	10800017 	ldw	r2,0(r2)
 d015744:	10800d03 	ldbu	r2,52(r2)
 d015748:	e0bffe05 	stb	r2,-8(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 d01574c:	e13ffe03 	ldbu	r4,-8(fp)
 d015750:	e0fffe03 	ldbu	r3,-8(fp)
 d015754:	00834174 	movhi	r2,3333
 d015758:	109b1544 	addi	r2,r2,27733
 d01575c:	10c5883a 	add	r2,r2,r3
 d015760:	10800003 	ldbu	r2,0(r2)
 d015764:	1007883a 	mov	r3,r2
 d015768:	00834174 	movhi	r2,3333
 d01576c:	109b1804 	addi	r2,r2,27744
 d015770:	10800017 	ldw	r2,0(r2)
 d015774:	10800d43 	ldbu	r2,53(r2)
 d015778:	0084303a 	nor	r2,zero,r2
 d01577c:	1884703a 	and	r2,r3,r2
 d015780:	1007883a 	mov	r3,r2
 d015784:	00834174 	movhi	r2,3333
 d015788:	109b1544 	addi	r2,r2,27733
 d01578c:	1105883a 	add	r2,r2,r4
 d015790:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
 d015794:	e0fffe03 	ldbu	r3,-8(fp)
 d015798:	00834174 	movhi	r2,3333
 d01579c:	109b1544 	addi	r2,r2,27733
 d0157a0:	10c5883a 	add	r2,r2,r3
 d0157a4:	10800003 	ldbu	r2,0(r2)
 d0157a8:	10803fcc 	andi	r2,r2,255
 d0157ac:	1004c03a 	cmpne	r2,r2,zero
 d0157b0:	10000e1e 	bne	r2,zero,d0157ec <OSTimeDly+0x110>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 d0157b4:	00834174 	movhi	r2,3333
 d0157b8:	109b1804 	addi	r2,r2,27744
 d0157bc:	10800017 	ldw	r2,0(r2)
 d0157c0:	10800d83 	ldbu	r2,54(r2)
 d0157c4:	0084303a 	nor	r2,zero,r2
 d0157c8:	1007883a 	mov	r3,r2
 d0157cc:	00834174 	movhi	r2,3333
 d0157d0:	109b1504 	addi	r2,r2,27732
 d0157d4:	10800003 	ldbu	r2,0(r2)
 d0157d8:	1884703a 	and	r2,r3,r2
 d0157dc:	1007883a 	mov	r3,r2
 d0157e0:	00834174 	movhi	r2,3333
 d0157e4:	109b1504 	addi	r2,r2,27732
 d0157e8:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 d0157ec:	00834174 	movhi	r2,3333
 d0157f0:	109b1804 	addi	r2,r2,27744
 d0157f4:	10c00017 	ldw	r3,0(r2)
 d0157f8:	e0bfff0b 	ldhu	r2,-4(fp)
 d0157fc:	18800b8d 	sth	r2,46(r3)
 d015800:	e0bffd17 	ldw	r2,-12(fp)
 d015804:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d015808:	e0bffb17 	ldw	r2,-20(fp)
 d01580c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 d015810:	d00f3e40 	call	d00f3e4 <OS_Sched>
    }
}
 d015814:	e037883a 	mov	sp,fp
 d015818:	dfc00117 	ldw	ra,4(sp)
 d01581c:	df000017 	ldw	fp,0(sp)
 d015820:	dec00204 	addi	sp,sp,8
 d015824:	f800283a 	ret

0d015828 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 d015828:	defff604 	addi	sp,sp,-40
 d01582c:	dfc00915 	stw	ra,36(sp)
 d015830:	df000815 	stw	fp,32(sp)
 d015834:	dc000715 	stw	r16,28(sp)
 d015838:	df000704 	addi	fp,sp,28
 d01583c:	e13ffb05 	stb	r4,-20(fp)
 d015840:	e17ffc05 	stb	r5,-16(fp)
 d015844:	e1bffd05 	stb	r6,-12(fp)
 d015848:	e1fffe0d 	sth	r7,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d01584c:	00834174 	movhi	r2,3333
 d015850:	109b1704 	addi	r2,r2,27740
 d015854:	10800003 	ldbu	r2,0(r2)
 d015858:	10803fcc 	andi	r2,r2,255
 d01585c:	1005003a 	cmpeq	r2,r2,zero
 d015860:	1000031e 	bne	r2,zero,d015870 <OSTimeDlyHMSM+0x48>
        return (OS_ERR_TIME_DLY_ISR);
 d015864:	00801544 	movi	r2,85
 d015868:	e0bfff15 	stw	r2,-4(fp)
 d01586c:	00004b06 	br	d01599c <OSTimeDlyHMSM+0x174>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 d015870:	e0bffb03 	ldbu	r2,-20(fp)
 d015874:	1004c03a 	cmpne	r2,r2,zero
 d015878:	10000c1e 	bne	r2,zero,d0158ac <OSTimeDlyHMSM+0x84>
        if (minutes == 0) {
 d01587c:	e0bffc03 	ldbu	r2,-16(fp)
 d015880:	1004c03a 	cmpne	r2,r2,zero
 d015884:	1000091e 	bne	r2,zero,d0158ac <OSTimeDlyHMSM+0x84>
            if (seconds == 0) {
 d015888:	e0bffd03 	ldbu	r2,-12(fp)
 d01588c:	1004c03a 	cmpne	r2,r2,zero
 d015890:	1000061e 	bne	r2,zero,d0158ac <OSTimeDlyHMSM+0x84>
                if (ms == 0) {
 d015894:	e0bffe0b 	ldhu	r2,-8(fp)
 d015898:	1004c03a 	cmpne	r2,r2,zero
 d01589c:	1000031e 	bne	r2,zero,d0158ac <OSTimeDlyHMSM+0x84>
                    return (OS_ERR_TIME_ZERO_DLY);
 d0158a0:	00801504 	movi	r2,84
 d0158a4:	e0bfff15 	stw	r2,-4(fp)
 d0158a8:	00003c06 	br	d01599c <OSTimeDlyHMSM+0x174>
                }
            }
        }
    }
    if (minutes > 59) {
 d0158ac:	e0bffc03 	ldbu	r2,-16(fp)
 d0158b0:	10800f30 	cmpltui	r2,r2,60
 d0158b4:	1000031e 	bne	r2,zero,d0158c4 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 d0158b8:	00801444 	movi	r2,81
 d0158bc:	e0bfff15 	stw	r2,-4(fp)
 d0158c0:	00003606 	br	d01599c <OSTimeDlyHMSM+0x174>
    }
    if (seconds > 59) {
 d0158c4:	e0bffd03 	ldbu	r2,-12(fp)
 d0158c8:	10800f30 	cmpltui	r2,r2,60
 d0158cc:	1000031e 	bne	r2,zero,d0158dc <OSTimeDlyHMSM+0xb4>
        return (OS_ERR_TIME_INVALID_SECONDS);
 d0158d0:	00801484 	movi	r2,82
 d0158d4:	e0bfff15 	stw	r2,-4(fp)
 d0158d8:	00003006 	br	d01599c <OSTimeDlyHMSM+0x174>
    }
    if (ms > 999) {
 d0158dc:	e0bffe0b 	ldhu	r2,-8(fp)
 d0158e0:	1080fa30 	cmpltui	r2,r2,1000
 d0158e4:	1000031e 	bne	r2,zero,d0158f4 <OSTimeDlyHMSM+0xcc>
        return (OS_ERR_TIME_INVALID_MS);
 d0158e8:	008014c4 	movi	r2,83
 d0158ec:	e0bfff15 	stw	r2,-4(fp)
 d0158f0:	00002a06 	br	d01599c <OSTimeDlyHMSM+0x174>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 d0158f4:	e13ffb03 	ldbu	r4,-20(fp)
 d0158f8:	01438404 	movi	r5,3600
 d0158fc:	d00235c0 	call	d00235c <__mulsi3>
 d015900:	1021883a 	mov	r16,r2
 d015904:	e13ffc03 	ldbu	r4,-16(fp)
 d015908:	01400f04 	movi	r5,60
 d01590c:	d00235c0 	call	d00235c <__mulsi3>
 d015910:	8087883a 	add	r3,r16,r2
 d015914:	e0bffd03 	ldbu	r2,-12(fp)
 d015918:	1889883a 	add	r4,r3,r2
 d01591c:	01401904 	movi	r5,100
 d015920:	d00235c0 	call	d00235c <__mulsi3>
 d015924:	1021883a 	mov	r16,r2
 d015928:	e13ffe0b 	ldhu	r4,-8(fp)
 d01592c:	01401904 	movi	r5,100
 d015930:	d00235c0 	call	d00235c <__mulsi3>
 d015934:	11007d04 	addi	r4,r2,500
 d015938:	0140fa04 	movi	r5,1000
 d01593c:	d00c90c0 	call	d00c90c <__udivsi3>
 d015940:	8085883a 	add	r2,r16,r2
 d015944:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 d015948:	e0bffa17 	ldw	r2,-24(fp)
 d01594c:	1004d43a 	srli	r2,r2,16
 d015950:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 d015954:	e0bffa17 	ldw	r2,-24(fp)
 d015958:	10bfffcc 	andi	r2,r2,65535
 d01595c:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 d015960:	e0bffa17 	ldw	r2,-24(fp)
 d015964:	113fffcc 	andi	r4,r2,65535
 d015968:	d0156dc0 	call	d0156dc <OSTimeDly>
    while (loops > 0) {
 d01596c:	00000706 	br	d01598c <OSTimeDlyHMSM+0x164>
        OSTimeDly((INT16U)32768u);
 d015970:	01200014 	movui	r4,32768
 d015974:	d0156dc0 	call	d0156dc <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 d015978:	01200014 	movui	r4,32768
 d01597c:	d0156dc0 	call	d0156dc <OSTimeDly>
        loops--;
 d015980:	e0bff90b 	ldhu	r2,-28(fp)
 d015984:	10bfffc4 	addi	r2,r2,-1
 d015988:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 d01598c:	e0bff90b 	ldhu	r2,-28(fp)
 d015990:	1004c03a 	cmpne	r2,r2,zero
 d015994:	103ff61e 	bne	r2,zero,d015970 <OSTimeDlyHMSM+0x148>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 d015998:	e03fff15 	stw	zero,-4(fp)
 d01599c:	e0bfff17 	ldw	r2,-4(fp)
}
 d0159a0:	e037883a 	mov	sp,fp
 d0159a4:	dfc00217 	ldw	ra,8(sp)
 d0159a8:	df000117 	ldw	fp,4(sp)
 d0159ac:	dc000017 	ldw	r16,0(sp)
 d0159b0:	dec00304 	addi	sp,sp,12
 d0159b4:	f800283a 	ret

0d0159b8 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 d0159b8:	defff404 	addi	sp,sp,-48
 d0159bc:	dfc00b15 	stw	ra,44(sp)
 d0159c0:	df000a15 	stw	fp,40(sp)
 d0159c4:	df000a04 	addi	fp,sp,40
 d0159c8:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0159cc:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 d0159d0:	e0bffe03 	ldbu	r2,-8(fp)
 d0159d4:	10800530 	cmpltui	r2,r2,20
 d0159d8:	1000031e 	bne	r2,zero,d0159e8 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 d0159dc:	00800a84 	movi	r2,42
 d0159e0:	e0bfff15 	stw	r2,-4(fp)
 d0159e4:	00007206 	br	d015bb0 <OSTimeDlyResume+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0159e8:	0005303a 	rdctl	r2,status
 d0159ec:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0159f0:	e0fffb17 	ldw	r3,-20(fp)
 d0159f4:	00bfff84 	movi	r2,-2
 d0159f8:	1884703a 	and	r2,r3,r2
 d0159fc:	1001703a 	wrctl	status,r2
  
  return context;
 d015a00:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d015a04:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 d015a08:	e0bffe03 	ldbu	r2,-8(fp)
 d015a0c:	00c341b4 	movhi	r3,3334
 d015a10:	18c1b004 	addi	r3,r3,1728
 d015a14:	1085883a 	add	r2,r2,r2
 d015a18:	1085883a 	add	r2,r2,r2
 d015a1c:	10c5883a 	add	r2,r2,r3
 d015a20:	10800017 	ldw	r2,0(r2)
 d015a24:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {
 d015a28:	e0bffd17 	ldw	r2,-12(fp)
 d015a2c:	1004c03a 	cmpne	r2,r2,zero
 d015a30:	1000071e 	bne	r2,zero,d015a50 <OSTimeDlyResume+0x98>
 d015a34:	e0bffc17 	ldw	r2,-16(fp)
 d015a38:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d015a3c:	e0bffa17 	ldw	r2,-24(fp)
 d015a40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 d015a44:	008010c4 	movi	r2,67
 d015a48:	e0bfff15 	stw	r2,-4(fp)
 d015a4c:	00005806 	br	d015bb0 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 d015a50:	e0bffd17 	ldw	r2,-12(fp)
 d015a54:	10800058 	cmpnei	r2,r2,1
 d015a58:	1000071e 	bne	r2,zero,d015a78 <OSTimeDlyResume+0xc0>
 d015a5c:	e0bffc17 	ldw	r2,-16(fp)
 d015a60:	e0bff915 	stw	r2,-28(fp)
 d015a64:	e0bff917 	ldw	r2,-28(fp)
 d015a68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 d015a6c:	008010c4 	movi	r2,67
 d015a70:	e0bfff15 	stw	r2,-4(fp)
 d015a74:	00004e06 	br	d015bb0 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 d015a78:	e0bffd17 	ldw	r2,-12(fp)
 d015a7c:	10800b8b 	ldhu	r2,46(r2)
 d015a80:	10bfffcc 	andi	r2,r2,65535
 d015a84:	1004c03a 	cmpne	r2,r2,zero
 d015a88:	1000071e 	bne	r2,zero,d015aa8 <OSTimeDlyResume+0xf0>
 d015a8c:	e0bffc17 	ldw	r2,-16(fp)
 d015a90:	e0bff815 	stw	r2,-32(fp)
 d015a94:	e0bff817 	ldw	r2,-32(fp)
 d015a98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 d015a9c:	00801404 	movi	r2,80
 d015aa0:	e0bfff15 	stw	r2,-4(fp)
 d015aa4:	00004206 	br	d015bb0 <OSTimeDlyResume+0x1f8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 d015aa8:	e0bffd17 	ldw	r2,-12(fp)
 d015aac:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 d015ab0:	e0bffd17 	ldw	r2,-12(fp)
 d015ab4:	10800c03 	ldbu	r2,48(r2)
 d015ab8:	10803fcc 	andi	r2,r2,255
 d015abc:	10800dcc 	andi	r2,r2,55
 d015ac0:	1005003a 	cmpeq	r2,r2,zero
 d015ac4:	10000b1e 	bne	r2,zero,d015af4 <OSTimeDlyResume+0x13c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 d015ac8:	e0bffd17 	ldw	r2,-12(fp)
 d015acc:	10c00c03 	ldbu	r3,48(r2)
 d015ad0:	00bff204 	movi	r2,-56
 d015ad4:	1884703a 	and	r2,r3,r2
 d015ad8:	1007883a 	mov	r3,r2
 d015adc:	e0bffd17 	ldw	r2,-12(fp)
 d015ae0:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 d015ae4:	e0fffd17 	ldw	r3,-12(fp)
 d015ae8:	00800044 	movi	r2,1
 d015aec:	18800c45 	stb	r2,49(r3)
 d015af0:	00000206 	br	d015afc <OSTimeDlyResume+0x144>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 d015af4:	e0bffd17 	ldw	r2,-12(fp)
 d015af8:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 d015afc:	e0bffd17 	ldw	r2,-12(fp)
 d015b00:	10800c03 	ldbu	r2,48(r2)
 d015b04:	10803fcc 	andi	r2,r2,255
 d015b08:	1080020c 	andi	r2,r2,8
 d015b0c:	1004c03a 	cmpne	r2,r2,zero
 d015b10:	1000221e 	bne	r2,zero,d015b9c <OSTimeDlyResume+0x1e4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 d015b14:	e0bffd17 	ldw	r2,-12(fp)
 d015b18:	10c00d83 	ldbu	r3,54(r2)
 d015b1c:	00834174 	movhi	r2,3333
 d015b20:	109b1504 	addi	r2,r2,27732
 d015b24:	10800003 	ldbu	r2,0(r2)
 d015b28:	1884b03a 	or	r2,r3,r2
 d015b2c:	1007883a 	mov	r3,r2
 d015b30:	00834174 	movhi	r2,3333
 d015b34:	109b1504 	addi	r2,r2,27732
 d015b38:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d015b3c:	e0bffd17 	ldw	r2,-12(fp)
 d015b40:	10800d03 	ldbu	r2,52(r2)
 d015b44:	11003fcc 	andi	r4,r2,255
 d015b48:	e0bffd17 	ldw	r2,-12(fp)
 d015b4c:	10800d03 	ldbu	r2,52(r2)
 d015b50:	10c03fcc 	andi	r3,r2,255
 d015b54:	00834174 	movhi	r2,3333
 d015b58:	109b1544 	addi	r2,r2,27733
 d015b5c:	10c5883a 	add	r2,r2,r3
 d015b60:	10c00003 	ldbu	r3,0(r2)
 d015b64:	e0bffd17 	ldw	r2,-12(fp)
 d015b68:	10800d43 	ldbu	r2,53(r2)
 d015b6c:	1884b03a 	or	r2,r3,r2
 d015b70:	1007883a 	mov	r3,r2
 d015b74:	00834174 	movhi	r2,3333
 d015b78:	109b1544 	addi	r2,r2,27733
 d015b7c:	1105883a 	add	r2,r2,r4
 d015b80:	10c00005 	stb	r3,0(r2)
 d015b84:	e0bffc17 	ldw	r2,-16(fp)
 d015b88:	e0bff715 	stw	r2,-36(fp)
 d015b8c:	e0bff717 	ldw	r2,-36(fp)
 d015b90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 d015b94:	d00f3e40 	call	d00f3e4 <OS_Sched>
 d015b98:	00000406 	br	d015bac <OSTimeDlyResume+0x1f4>
 d015b9c:	e0bffc17 	ldw	r2,-16(fp)
 d015ba0:	e0bff615 	stw	r2,-40(fp)
 d015ba4:	e0bff617 	ldw	r2,-40(fp)
 d015ba8:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 d015bac:	e03fff15 	stw	zero,-4(fp)
 d015bb0:	e0bfff17 	ldw	r2,-4(fp)
}
 d015bb4:	e037883a 	mov	sp,fp
 d015bb8:	dfc00117 	ldw	ra,4(sp)
 d015bbc:	df000017 	ldw	fp,0(sp)
 d015bc0:	dec00204 	addi	sp,sp,8
 d015bc4:	f800283a 	ret

0d015bc8 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 d015bc8:	defffb04 	addi	sp,sp,-20
 d015bcc:	df000415 	stw	fp,16(sp)
 d015bd0:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d015bd4:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015bd8:	0005303a 	rdctl	r2,status
 d015bdc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d015be0:	e0fffd17 	ldw	r3,-12(fp)
 d015be4:	00bfff84 	movi	r2,-2
 d015be8:	1884703a 	and	r2,r3,r2
 d015bec:	1001703a 	wrctl	status,r2
  
  return context;
 d015bf0:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 d015bf4:	e0bffe15 	stw	r2,-8(fp)
    ticks = OSTime;
 d015bf8:	00834174 	movhi	r2,3333
 d015bfc:	109b1904 	addi	r2,r2,27748
 d015c00:	10800017 	ldw	r2,0(r2)
 d015c04:	e0bfff15 	stw	r2,-4(fp)
 d015c08:	e0bffe17 	ldw	r2,-8(fp)
 d015c0c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d015c10:	e0bffc17 	ldw	r2,-16(fp)
 d015c14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 d015c18:	e0bfff17 	ldw	r2,-4(fp)
}
 d015c1c:	e037883a 	mov	sp,fp
 d015c20:	df000017 	ldw	fp,0(sp)
 d015c24:	dec00104 	addi	sp,sp,4
 d015c28:	f800283a 	ret

0d015c2c <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 d015c2c:	defffb04 	addi	sp,sp,-20
 d015c30:	df000415 	stw	fp,16(sp)
 d015c34:	df000404 	addi	fp,sp,16
 d015c38:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d015c3c:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015c40:	0005303a 	rdctl	r2,status
 d015c44:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d015c48:	e0fffd17 	ldw	r3,-12(fp)
 d015c4c:	00bfff84 	movi	r2,-2
 d015c50:	1884703a 	and	r2,r3,r2
 d015c54:	1001703a 	wrctl	status,r2
  
  return context;
 d015c58:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 d015c5c:	e0bffe15 	stw	r2,-8(fp)
    OSTime = ticks;
 d015c60:	00c34174 	movhi	r3,3333
 d015c64:	18db1904 	addi	r3,r3,27748
 d015c68:	e0bfff17 	ldw	r2,-4(fp)
 d015c6c:	18800015 	stw	r2,0(r3)
 d015c70:	e0bffe17 	ldw	r2,-8(fp)
 d015c74:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d015c78:	e0bffc17 	ldw	r2,-16(fp)
 d015c7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 d015c80:	e037883a 	mov	sp,fp
 d015c84:	df000017 	ldw	fp,0(sp)
 d015c88:	dec00104 	addi	sp,sp,4
 d015c8c:	f800283a 	ret

0d015c90 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 d015c90:	defffd04 	addi	sp,sp,-12
 d015c94:	dfc00215 	stw	ra,8(sp)
 d015c98:	df000115 	stw	fp,4(sp)
 d015c9c:	df000104 	addi	fp,sp,4
 d015ca0:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_IRQ_INIT ( CPU, cpu);
 d015ca4:	d0362740 	call	d036274 <altera_nios2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 d015ca8:	00800044 	movi	r2,1
 d015cac:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 d015cb0:	e037883a 	mov	sp,fp
 d015cb4:	dfc00117 	ldw	ra,4(sp)
 d015cb8:	df000017 	ldw	fp,0(sp)
 d015cbc:	dec00204 	addi	sp,sp,8
 d015cc0:	f800283a 	ret

0d015cc4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 d015cc4:	defff704 	addi	sp,sp,-36
 d015cc8:	dfc00815 	stw	ra,32(sp)
 d015ccc:	df000715 	stw	fp,28(sp)
 d015cd0:	dc800615 	stw	r18,24(sp)
 d015cd4:	dc400515 	stw	r17,20(sp)
 d015cd8:	dc000415 	stw	r16,16(sp)
 d015cdc:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 d015ce0:	01000804 	movi	r4,32
 d015ce4:	000b883a 	mov	r5,zero
 d015ce8:	01800084 	movi	r6,2
 d015cec:	01c01904 	movi	r7,100
 d015cf0:	d01a2cc0 	call	d01a2cc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
 d015cf4:	01034174 	movhi	r4,3333
 d015cf8:	210c4904 	addi	r4,r4,12580
 d015cfc:	d015fbc0 	call	d015fbc <alt_flash_cfi_init>
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS_FLASH_CONTROLLER_0, epcs_flash_controller_0);
 d015d00:	01034174 	movhi	r4,3333
 d015d04:	210c7f04 	addi	r4,r4,12796
 d015d08:	d017d380 	call	d017d38 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 d015d0c:	01034174 	movhi	r4,3333
 d015d10:	210cbb04 	addi	r4,r4,13036
 d015d14:	000b883a 	mov	r5,zero
 d015d18:	000d883a 	mov	r6,zero
 d015d1c:	d0188640 	call	d018864 <altera_avalon_jtag_uart_init>
 d015d20:	01034174 	movhi	r4,3333
 d015d24:	210cb104 	addi	r4,r4,12996
 d015d28:	d015f840 	call	d015f84 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 d015d2c:	01034174 	movhi	r4,3333
 d015d30:	2110cc04 	addi	r4,r4,17200
 d015d34:	000b883a 	mov	r5,zero
 d015d38:	01800144 	movi	r6,5
 d015d3c:	d01a1b00 	call	d01a1b0 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 d015d40:	01034174 	movhi	r4,3333
 d015d44:	2110d804 	addi	r4,r4,17248
 d015d48:	000b883a 	mov	r5,zero
 d015d4c:	01800104 	movi	r6,4
 d015d50:	d01a1b00 	call	d01a1b0 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_INIT ( SYSID, sysid);
    TRIPLE_SPEED_ETHERNET_INIT ( TSE_MAC, tse_mac);
 d015d54:	e03fff15 	stw	zero,-4(fp)
 d015d58:	00800044 	movi	r2,1
 d015d5c:	e0bffe15 	stw	r2,-8(fp)
 d015d60:	e0bffe17 	ldw	r2,-8(fp)
 d015d64:	10800048 	cmpgei	r2,r2,1
 d015d68:	1000021e 	bne	r2,zero,d015d74 <alt_sys_init+0xb0>
 d015d6c:	00800044 	movi	r2,1
 d015d70:	e0bffe15 	stw	r2,-8(fp)
 d015d74:	e03fff15 	stw	zero,-4(fp)
 d015d78:	00007106 	br	d015f40 <alt_sys_init+0x27c>
 d015d7c:	e13fff17 	ldw	r4,-4(fp)
 d015d80:	040341b4 	movhi	r16,3334
 d015d84:	8401c504 	addi	r16,r16,1812
 d015d88:	01400704 	movi	r5,28
 d015d8c:	d00235c0 	call	d00235c <__mulsi3>
 d015d90:	1405883a 	add	r2,r2,r16
 d015d94:	10000015 	stw	zero,0(r2)
 d015d98:	e13fff17 	ldw	r4,-4(fp)
 d015d9c:	040341b4 	movhi	r16,3334
 d015da0:	8401c504 	addi	r16,r16,1812
 d015da4:	01400704 	movi	r5,28
 d015da8:	d00235c0 	call	d00235c <__mulsi3>
 d015dac:	1405883a 	add	r2,r2,r16
 d015db0:	10800104 	addi	r2,r2,4
 d015db4:	10000015 	stw	zero,0(r2)
 d015db8:	e13fff17 	ldw	r4,-4(fp)
 d015dbc:	d4602917 	ldw	r17,-32604(gp)
 d015dc0:	040341b4 	movhi	r16,3334
 d015dc4:	8401c504 	addi	r16,r16,1812
 d015dc8:	01400704 	movi	r5,28
 d015dcc:	d00235c0 	call	d00235c <__mulsi3>
 d015dd0:	1405883a 	add	r2,r2,r16
 d015dd4:	10800204 	addi	r2,r2,8
 d015dd8:	14400015 	stw	r17,0(r2)
 d015ddc:	e13fff17 	ldw	r4,-4(fp)
 d015de0:	040341b4 	movhi	r16,3334
 d015de4:	8401c504 	addi	r16,r16,1812
 d015de8:	01400704 	movi	r5,28
 d015dec:	d00235c0 	call	d00235c <__mulsi3>
 d015df0:	1405883a 	add	r2,r2,r16
 d015df4:	10c00304 	addi	r3,r2,12
 d015df8:	008340b4 	movhi	r2,3330
 d015dfc:	10aa8c04 	addi	r2,r2,-21968
 d015e00:	18800015 	stw	r2,0(r3)
 d015e04:	e13fff17 	ldw	r4,-4(fp)
 d015e08:	01400704 	movi	r5,28
 d015e0c:	d00235c0 	call	d00235c <__mulsi3>
 d015e10:	1007883a 	mov	r3,r2
 d015e14:	008341b4 	movhi	r2,3334
 d015e18:	1081c504 	addi	r2,r2,1812
 d015e1c:	1887883a 	add	r3,r3,r2
 d015e20:	00834174 	movhi	r2,3333
 d015e24:	10924c04 	addi	r2,r2,18736
 d015e28:	e0bffc15 	stw	r2,-16(fp)
 d015e2c:	e0fffd15 	stw	r3,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 d015e30:	e0fffd17 	ldw	r3,-12(fp)
 d015e34:	e0bffc17 	ldw	r2,-16(fp)
 d015e38:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 d015e3c:	e0bffc17 	ldw	r2,-16(fp)
 d015e40:	10c00017 	ldw	r3,0(r2)
 d015e44:	e0bffd17 	ldw	r2,-12(fp)
 d015e48:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 d015e4c:	e0bffc17 	ldw	r2,-16(fp)
 d015e50:	10c00017 	ldw	r3,0(r2)
 d015e54:	e0bffd17 	ldw	r2,-12(fp)
 d015e58:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 d015e5c:	e0fffc17 	ldw	r3,-16(fp)
 d015e60:	e0bffd17 	ldw	r2,-12(fp)
 d015e64:	18800015 	stw	r2,0(r3)
 d015e68:	00834174 	movhi	r2,3333
 d015e6c:	109b1d04 	addi	r2,r2,27764
 d015e70:	10800003 	ldbu	r2,0(r2)
 d015e74:	14403fcc 	andi	r17,r2,255
 d015e78:	e13fff17 	ldw	r4,-4(fp)
 d015e7c:	01400704 	movi	r5,28
 d015e80:	d00235c0 	call	d00235c <__mulsi3>
 d015e84:	1007883a 	mov	r3,r2
 d015e88:	008341b4 	movhi	r2,3334
 d015e8c:	1081c504 	addi	r2,r2,1812
 d015e90:	18a5883a 	add	r18,r3,r2
 d015e94:	040341b4 	movhi	r16,3334
 d015e98:	8401fd04 	addi	r16,r16,2036
 d015e9c:	8809883a 	mov	r4,r17
 d015ea0:	01400304 	movi	r5,12
 d015ea4:	d00235c0 	call	d00235c <__mulsi3>
 d015ea8:	1405883a 	add	r2,r2,r16
 d015eac:	14800015 	stw	r18,0(r2)
 d015eb0:	00834174 	movhi	r2,3333
 d015eb4:	109b1d04 	addi	r2,r2,27764
 d015eb8:	10800003 	ldbu	r2,0(r2)
 d015ebc:	11003fcc 	andi	r4,r2,255
 d015ec0:	040341b4 	movhi	r16,3334
 d015ec4:	8401fd04 	addi	r16,r16,2036
 d015ec8:	01400304 	movi	r5,12
 d015ecc:	d00235c0 	call	d00235c <__mulsi3>
 d015ed0:	1405883a 	add	r2,r2,r16
 d015ed4:	10c00104 	addi	r3,r2,4
 d015ed8:	008a0004 	movi	r2,10240
 d015edc:	18800015 	stw	r2,0(r3)
 d015ee0:	00834174 	movhi	r2,3333
 d015ee4:	109b1d04 	addi	r2,r2,27764
 d015ee8:	10800003 	ldbu	r2,0(r2)
 d015eec:	11003fcc 	andi	r4,r2,255
 d015ef0:	e0bfff17 	ldw	r2,-4(fp)
 d015ef4:	1023883a 	mov	r17,r2
 d015ef8:	040341b4 	movhi	r16,3334
 d015efc:	8401fd04 	addi	r16,r16,2036
 d015f00:	01400304 	movi	r5,12
 d015f04:	d00235c0 	call	d00235c <__mulsi3>
 d015f08:	1405883a 	add	r2,r2,r16
 d015f0c:	10800204 	addi	r2,r2,8
 d015f10:	14400005 	stb	r17,0(r2)
 d015f14:	00834174 	movhi	r2,3333
 d015f18:	109b1d04 	addi	r2,r2,27764
 d015f1c:	10800003 	ldbu	r2,0(r2)
 d015f20:	10800044 	addi	r2,r2,1
 d015f24:	1007883a 	mov	r3,r2
 d015f28:	00834174 	movhi	r2,3333
 d015f2c:	109b1d04 	addi	r2,r2,27764
 d015f30:	10c00005 	stb	r3,0(r2)
 d015f34:	e0bfff17 	ldw	r2,-4(fp)
 d015f38:	10800044 	addi	r2,r2,1
 d015f3c:	e0bfff15 	stw	r2,-4(fp)
 d015f40:	e0ffff17 	ldw	r3,-4(fp)
 d015f44:	e0bffe17 	ldw	r2,-8(fp)
 d015f48:	18bf8c16 	blt	r3,r2,d015d7c <alt_sys_init+0xb8>
    TRISTATE_AVALON_LCD_16207_INIT ( TRISTATE_LCD, tristate_lcd);
 d015f4c:	01034174 	movhi	r4,3333
 d015f50:	2110ee04 	addi	r4,r4,17336
 d015f54:	d01d1480 	call	d01d148 <tristate_avalon_lcd_16207_init>
 d015f58:	01034174 	movhi	r4,3333
 d015f5c:	2110e404 	addi	r4,r4,17296
 d015f60:	d015f840 	call	d015f84 <alt_dev_reg>
}
 d015f64:	e037883a 	mov	sp,fp
 d015f68:	dfc00417 	ldw	ra,16(sp)
 d015f6c:	df000317 	ldw	fp,12(sp)
 d015f70:	dc800217 	ldw	r18,8(sp)
 d015f74:	dc400117 	ldw	r17,4(sp)
 d015f78:	dc000017 	ldw	r16,0(sp)
 d015f7c:	dec00504 	addi	sp,sp,20
 d015f80:	f800283a 	ret

0d015f84 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 d015f84:	defffd04 	addi	sp,sp,-12
 d015f88:	dfc00215 	stw	ra,8(sp)
 d015f8c:	df000115 	stw	fp,4(sp)
 d015f90:	df000104 	addi	fp,sp,4
 d015f94:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 d015f98:	e13fff17 	ldw	r4,-4(fp)
 d015f9c:	01434174 	movhi	r5,3333
 d015fa0:	29526204 	addi	r5,r5,18824
 d015fa4:	d0351b00 	call	d0351b0 <alt_dev_llist_insert>
}
 d015fa8:	e037883a 	mov	sp,fp
 d015fac:	dfc00117 	ldw	ra,4(sp)
 d015fb0:	df000017 	ldw	fp,0(sp)
 d015fb4:	dec00204 	addi	sp,sp,8
 d015fb8:	f800283a 	ret

0d015fbc <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 d015fbc:	defffc04 	addi	sp,sp,-16
 d015fc0:	dfc00315 	stw	ra,12(sp)
 d015fc4:	df000215 	stw	fp,8(sp)
 d015fc8:	df000204 	addi	fp,sp,8
 d015fcc:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 d015fd0:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 d015fd4:	e13fff17 	ldw	r4,-4(fp)
 d015fd8:	d0174b00 	call	d0174b0 <alt_read_cfi_width>
 d015fdc:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 d015fe0:	e0bffe17 	ldw	r2,-8(fp)
 d015fe4:	1004c03a 	cmpne	r2,r2,zero
 d015fe8:	1000031e 	bne	r2,zero,d015ff8 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 d015fec:	e13fff17 	ldw	r4,-4(fp)
 d015ff0:	d016bbc0 	call	d016bbc <alt_set_flash_width_func>
 d015ff4:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 d015ff8:	e0bffe17 	ldw	r2,-8(fp)
 d015ffc:	1004c03a 	cmpne	r2,r2,zero
 d016000:	1000031e 	bne	r2,zero,d016010 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 d016004:	e13fff17 	ldw	r4,-4(fp)
 d016008:	d016ec40 	call	d016ec4 <alt_read_cfi_table>
 d01600c:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 d016010:	e0bffe17 	ldw	r2,-8(fp)
 d016014:	1004c03a 	cmpne	r2,r2,zero
 d016018:	1000031e 	bne	r2,zero,d016028 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 d01601c:	e13fff17 	ldw	r4,-4(fp)
 d016020:	d016d9c0 	call	d016d9c <alt_set_flash_algorithm_func>
 d016024:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 d016028:	e0bffe17 	ldw	r2,-8(fp)
 d01602c:	1004c03a 	cmpne	r2,r2,zero
 d016030:	1000031e 	bne	r2,zero,d016040 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 d016034:	e13fff17 	ldw	r4,-4(fp)
 d016038:	d0160580 	call	d016058 <alt_flash_device_register>
 d01603c:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 d016040:	e0bffe17 	ldw	r2,-8(fp)
}
 d016044:	e037883a 	mov	sp,fp
 d016048:	dfc00117 	ldw	ra,4(sp)
 d01604c:	df000017 	ldw	fp,0(sp)
 d016050:	dec00204 	addi	sp,sp,8
 d016054:	f800283a 	ret

0d016058 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 d016058:	defffd04 	addi	sp,sp,-12
 d01605c:	dfc00215 	stw	ra,8(sp)
 d016060:	df000115 	stw	fp,4(sp)
 d016064:	df000104 	addi	fp,sp,4
 d016068:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 d01606c:	e13fff17 	ldw	r4,-4(fp)
 d016070:	01434174 	movhi	r5,3333
 d016074:	29522604 	addi	r5,r5,18584
 d016078:	d0351b00 	call	d0351b0 <alt_dev_llist_insert>
}
 d01607c:	e037883a 	mov	sp,fp
 d016080:	dfc00117 	ldw	ra,4(sp)
 d016084:	df000017 	ldw	fp,0(sp)
 d016088:	dec00204 	addi	sp,sp,8
 d01608c:	f800283a 	ret

0d016090 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 d016090:	deffef04 	addi	sp,sp,-68
 d016094:	dfc01015 	stw	ra,64(sp)
 d016098:	df000f15 	stw	fp,60(sp)
 d01609c:	df000f04 	addi	fp,sp,60
 d0160a0:	e13ffa15 	stw	r4,-24(fp)
 d0160a4:	e17ffb15 	stw	r5,-20(fp)
 d0160a8:	e1bffc15 	stw	r6,-16(fp)
 d0160ac:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 d0160b0:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 d0160b4:	e0bffd17 	ldw	r2,-12(fp)
 d0160b8:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 d0160bc:	e0bffb17 	ldw	r2,-20(fp)
 d0160c0:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d0160c4:	e0bffa17 	ldw	r2,-24(fp)
 d0160c8:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 d0160cc:	e03ff815 	stw	zero,-32(fp)
 d0160d0:	00008e06 	br	d01630c <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 d0160d4:	e0bff817 	ldw	r2,-32(fp)
 d0160d8:	e0fff217 	ldw	r3,-56(fp)
 d0160dc:	1004913a 	slli	r2,r2,4
 d0160e0:	10c5883a 	add	r2,r2,r3
 d0160e4:	10800d04 	addi	r2,r2,52
 d0160e8:	10c00017 	ldw	r3,0(r2)
 d0160ec:	e0bffb17 	ldw	r2,-20(fp)
 d0160f0:	10c08316 	blt	r2,r3,d016300 <alt_flash_cfi_write+0x270>
 d0160f4:	e0bff817 	ldw	r2,-32(fp)
 d0160f8:	e0fff217 	ldw	r3,-56(fp)
 d0160fc:	1004913a 	slli	r2,r2,4
 d016100:	10c5883a 	add	r2,r2,r3
 d016104:	10800d04 	addi	r2,r2,52
 d016108:	11000017 	ldw	r4,0(r2)
 d01610c:	e0bff817 	ldw	r2,-32(fp)
 d016110:	e0fff217 	ldw	r3,-56(fp)
 d016114:	1004913a 	slli	r2,r2,4
 d016118:	10c5883a 	add	r2,r2,r3
 d01611c:	10800e04 	addi	r2,r2,56
 d016120:	10800017 	ldw	r2,0(r2)
 d016124:	2087883a 	add	r3,r4,r2
 d016128:	e0bffb17 	ldw	r2,-20(fp)
 d01612c:	10c0740e 	bge	r2,r3,d016300 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 d016130:	e0bff817 	ldw	r2,-32(fp)
 d016134:	e0fff217 	ldw	r3,-56(fp)
 d016138:	1004913a 	slli	r2,r2,4
 d01613c:	10c5883a 	add	r2,r2,r3
 d016140:	10800d04 	addi	r2,r2,52
 d016144:	10800017 	ldw	r2,0(r2)
 d016148:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 d01614c:	e03ff715 	stw	zero,-36(fp)
 d016150:	00006306 	br	d0162e0 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 d016154:	e0fffb17 	ldw	r3,-20(fp)
 d016158:	e0bff417 	ldw	r2,-48(fp)
 d01615c:	18805416 	blt	r3,r2,d0162b0 <alt_flash_cfi_write+0x220>
 d016160:	e0bff817 	ldw	r2,-32(fp)
 d016164:	e0fff217 	ldw	r3,-56(fp)
 d016168:	1004913a 	slli	r2,r2,4
 d01616c:	10c5883a 	add	r2,r2,r3
 d016170:	10801004 	addi	r2,r2,64
 d016174:	10c00017 	ldw	r3,0(r2)
 d016178:	e0bff417 	ldw	r2,-48(fp)
 d01617c:	1887883a 	add	r3,r3,r2
 d016180:	e0bffb17 	ldw	r2,-20(fp)
 d016184:	10c04a0e 	bge	r2,r3,d0162b0 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 d016188:	e0bff817 	ldw	r2,-32(fp)
 d01618c:	e0fff217 	ldw	r3,-56(fp)
 d016190:	1004913a 	slli	r2,r2,4
 d016194:	10c5883a 	add	r2,r2,r3
 d016198:	10801004 	addi	r2,r2,64
 d01619c:	10c00017 	ldw	r3,0(r2)
 d0161a0:	e0bff417 	ldw	r2,-48(fp)
 d0161a4:	1887883a 	add	r3,r3,r2
 d0161a8:	e0bffb17 	ldw	r2,-20(fp)
 d0161ac:	1885c83a 	sub	r2,r3,r2
 d0161b0:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 d0161b4:	e0bff617 	ldw	r2,-40(fp)
 d0161b8:	e0bfff15 	stw	r2,-4(fp)
 d0161bc:	e0fffd17 	ldw	r3,-12(fp)
 d0161c0:	e0fffe15 	stw	r3,-8(fp)
 d0161c4:	e0bfff17 	ldw	r2,-4(fp)
 d0161c8:	e0fffe17 	ldw	r3,-8(fp)
 d0161cc:	10c0020e 	bge	r2,r3,d0161d8 <alt_flash_cfi_write+0x148>
 d0161d0:	e0bfff17 	ldw	r2,-4(fp)
 d0161d4:	e0bffe15 	stw	r2,-8(fp)
 d0161d8:	e0fffe17 	ldw	r3,-8(fp)
 d0161dc:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 d0161e0:	e0bff217 	ldw	r2,-56(fp)
 d0161e4:	10800a17 	ldw	r2,40(r2)
 d0161e8:	1007883a 	mov	r3,r2
 d0161ec:	e0bffb17 	ldw	r2,-20(fp)
 d0161f0:	188b883a 	add	r5,r3,r2
 d0161f4:	e1bff617 	ldw	r6,-40(fp)
 d0161f8:	e13ffc17 	ldw	r4,-16(fp)
 d0161fc:	d04be440 	call	d04be44 <memcmp>
 d016200:	1005003a 	cmpeq	r2,r2,zero
 d016204:	1000131e 	bne	r2,zero,d016254 <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 d016208:	e0bff217 	ldw	r2,-56(fp)
 d01620c:	10800817 	ldw	r2,32(r2)
 d016210:	e13ff217 	ldw	r4,-56(fp)
 d016214:	e17ff417 	ldw	r5,-48(fp)
 d016218:	103ee83a 	callr	r2
 d01621c:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 d016220:	e0bff917 	ldw	r2,-28(fp)
 d016224:	1004c03a 	cmpne	r2,r2,zero
 d016228:	10000a1e 	bne	r2,zero,d016254 <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 d01622c:	e0bff217 	ldw	r2,-56(fp)
 d016230:	10c00917 	ldw	r3,36(r2)
 d016234:	e13ff217 	ldw	r4,-56(fp)
 d016238:	e0bff617 	ldw	r2,-40(fp)
 d01623c:	d8800015 	stw	r2,0(sp)
 d016240:	e17ff417 	ldw	r5,-48(fp)
 d016244:	e1bffb17 	ldw	r6,-20(fp)
 d016248:	e1fffc17 	ldw	r7,-16(fp)
 d01624c:	183ee83a 	callr	r3
 d016250:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 d016254:	e0fffd17 	ldw	r3,-12(fp)
 d016258:	e0bff617 	ldw	r2,-40(fp)
 d01625c:	18802f26 	beq	r3,r2,d01631c <alt_flash_cfi_write+0x28c>
 d016260:	e0bff917 	ldw	r2,-28(fp)
 d016264:	1004c03a 	cmpne	r2,r2,zero
 d016268:	10002c1e 	bne	r2,zero,d01631c <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 d01626c:	e0fffd17 	ldw	r3,-12(fp)
 d016270:	e0bff617 	ldw	r2,-40(fp)
 d016274:	1885c83a 	sub	r2,r3,r2
 d016278:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 d01627c:	e0bff817 	ldw	r2,-32(fp)
 d016280:	e0fff217 	ldw	r3,-56(fp)
 d016284:	1004913a 	slli	r2,r2,4
 d016288:	10c5883a 	add	r2,r2,r3
 d01628c:	10801004 	addi	r2,r2,64
 d016290:	10c00017 	ldw	r3,0(r2)
 d016294:	e0bff417 	ldw	r2,-48(fp)
 d016298:	1885883a 	add	r2,r3,r2
 d01629c:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 d0162a0:	e0fffc17 	ldw	r3,-16(fp)
 d0162a4:	e0bff617 	ldw	r2,-40(fp)
 d0162a8:	1885883a 	add	r2,r3,r2
 d0162ac:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 d0162b0:	e0bff817 	ldw	r2,-32(fp)
 d0162b4:	e0fff217 	ldw	r3,-56(fp)
 d0162b8:	1004913a 	slli	r2,r2,4
 d0162bc:	10c5883a 	add	r2,r2,r3
 d0162c0:	10801004 	addi	r2,r2,64
 d0162c4:	10c00017 	ldw	r3,0(r2)
 d0162c8:	e0bff417 	ldw	r2,-48(fp)
 d0162cc:	10c5883a 	add	r2,r2,r3
 d0162d0:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 d0162d4:	e0bff717 	ldw	r2,-36(fp)
 d0162d8:	10800044 	addi	r2,r2,1
 d0162dc:	e0bff715 	stw	r2,-36(fp)
 d0162e0:	e0bff817 	ldw	r2,-32(fp)
 d0162e4:	e0fff217 	ldw	r3,-56(fp)
 d0162e8:	1004913a 	slli	r2,r2,4
 d0162ec:	10c5883a 	add	r2,r2,r3
 d0162f0:	10800f04 	addi	r2,r2,60
 d0162f4:	10c00017 	ldw	r3,0(r2)
 d0162f8:	e0bff717 	ldw	r2,-36(fp)
 d0162fc:	10ff9516 	blt	r2,r3,d016154 <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 d016300:	e0bff817 	ldw	r2,-32(fp)
 d016304:	10800044 	addi	r2,r2,1
 d016308:	e0bff815 	stw	r2,-32(fp)
 d01630c:	e0bff217 	ldw	r2,-56(fp)
 d016310:	10c00c17 	ldw	r3,48(r2)
 d016314:	e0bff817 	ldw	r2,-32(fp)
 d016318:	10ff6e16 	blt	r2,r3,d0160d4 <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 d01631c:	e0bff217 	ldw	r2,-56(fp)
 d016320:	10800a17 	ldw	r2,40(r2)
 d016324:	1007883a 	mov	r3,r2
 d016328:	e0bff317 	ldw	r2,-52(fp)
 d01632c:	1889883a 	add	r4,r3,r2
 d016330:	e17ff517 	ldw	r5,-44(fp)
 d016334:	d0351440 	call	d035144 <alt_dcache_flush>
  return ret_code;
 d016338:	e0bff917 	ldw	r2,-28(fp)
}
 d01633c:	e037883a 	mov	sp,fp
 d016340:	dfc00117 	ldw	ra,4(sp)
 d016344:	df000017 	ldw	fp,0(sp)
 d016348:	dec00204 	addi	sp,sp,8
 d01634c:	f800283a 	ret

0d016350 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 d016350:	defffa04 	addi	sp,sp,-24
 d016354:	df000515 	stw	fp,20(sp)
 d016358:	df000504 	addi	fp,sp,20
 d01635c:	e13ffd15 	stw	r4,-12(fp)
 d016360:	e17ffe15 	stw	r5,-8(fp)
 d016364:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 d016368:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 d01636c:	e0bffd17 	ldw	r2,-12(fp)
 d016370:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 d016374:	e0bffb17 	ldw	r2,-20(fp)
 d016378:	10c00c17 	ldw	r3,48(r2)
 d01637c:	e0bfff17 	ldw	r2,-4(fp)
 d016380:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 d016384:	e0bffb17 	ldw	r2,-20(fp)
 d016388:	10800c17 	ldw	r2,48(r2)
 d01638c:	1004c03a 	cmpne	r2,r2,zero
 d016390:	1000031e 	bne	r2,zero,d0163a0 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 d016394:	00bffec4 	movi	r2,-5
 d016398:	e0bffc15 	stw	r2,-16(fp)
 d01639c:	00000b06 	br	d0163cc <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 d0163a0:	e0bffb17 	ldw	r2,-20(fp)
 d0163a4:	10800c17 	ldw	r2,48(r2)
 d0163a8:	10800250 	cmplti	r2,r2,9
 d0163ac:	1000031e 	bne	r2,zero,d0163bc <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 d0163b0:	00bffd04 	movi	r2,-12
 d0163b4:	e0bffc15 	stw	r2,-16(fp)
 d0163b8:	00000406 	br	d0163cc <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 d0163bc:	e0bffb17 	ldw	r2,-20(fp)
 d0163c0:	10c00d04 	addi	r3,r2,52
 d0163c4:	e0bffe17 	ldw	r2,-8(fp)
 d0163c8:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 d0163cc:	e0bffc17 	ldw	r2,-16(fp)
}
 d0163d0:	e037883a 	mov	sp,fp
 d0163d4:	df000017 	ldw	fp,0(sp)
 d0163d8:	dec00104 	addi	sp,sp,4
 d0163dc:	f800283a 	ret

0d0163e0 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 d0163e0:	defff904 	addi	sp,sp,-28
 d0163e4:	dfc00615 	stw	ra,24(sp)
 d0163e8:	df000515 	stw	fp,20(sp)
 d0163ec:	df000504 	addi	fp,sp,20
 d0163f0:	e13ffc15 	stw	r4,-16(fp)
 d0163f4:	e17ffd15 	stw	r5,-12(fp)
 d0163f8:	e1bffe15 	stw	r6,-8(fp)
 d0163fc:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d016400:	e0bffc17 	ldw	r2,-16(fp)
 d016404:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 d016408:	e0bffb17 	ldw	r2,-20(fp)
 d01640c:	10800a17 	ldw	r2,40(r2)
 d016410:	1007883a 	mov	r3,r2
 d016414:	e0bffd17 	ldw	r2,-12(fp)
 d016418:	1887883a 	add	r3,r3,r2
 d01641c:	e1bfff17 	ldw	r6,-4(fp)
 d016420:	e0bffe17 	ldw	r2,-8(fp)
 d016424:	1009883a 	mov	r4,r2
 d016428:	180b883a 	mov	r5,r3
 d01642c:	d0026080 	call	d002608 <memcpy>
  return 0;
 d016430:	0005883a 	mov	r2,zero
}
 d016434:	e037883a 	mov	sp,fp
 d016438:	dfc00117 	ldw	ra,4(sp)
 d01643c:	df000017 	ldw	fp,0(sp)
 d016440:	dec00204 	addi	sp,sp,8
 d016444:	f800283a 	ret

0d016448 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 d016448:	defffa04 	addi	sp,sp,-24
 d01644c:	df000515 	stw	fp,20(sp)
 d016450:	df000504 	addi	fp,sp,20
 d016454:	e13ffd15 	stw	r4,-12(fp)
 d016458:	e17ffe15 	stw	r5,-8(fp)
 d01645c:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 d016460:	e0bffd17 	ldw	r2,-12(fp)
 d016464:	10802e17 	ldw	r2,184(r2)
 d016468:	10800058 	cmpnei	r2,r2,1
 d01646c:	10000b1e 	bne	r2,zero,d01649c <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 d016470:	e0bffd17 	ldw	r2,-12(fp)
 d016474:	10800a17 	ldw	r2,40(r2)
 d016478:	1007883a 	mov	r3,r2
 d01647c:	e0bffe17 	ldw	r2,-8(fp)
 d016480:	1889883a 	add	r4,r3,r2
 d016484:	e0bfff17 	ldw	r2,-4(fp)
 d016488:	10800003 	ldbu	r2,0(r2)
 d01648c:	10c03fcc 	andi	r3,r2,255
 d016490:	2005883a 	mov	r2,r4
 d016494:	10c00025 	stbio	r3,0(r2)
 d016498:	00004006 	br	d01659c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 d01649c:	e0bffd17 	ldw	r2,-12(fp)
 d0164a0:	10802e17 	ldw	r2,184(r2)
 d0164a4:	10800098 	cmpnei	r2,r2,2
 d0164a8:	1000151e 	bne	r2,zero,d016500 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 d0164ac:	e0bfff17 	ldw	r2,-4(fp)
 d0164b0:	10800003 	ldbu	r2,0(r2)
 d0164b4:	10803fcc 	andi	r2,r2,255
 d0164b8:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 d0164bc:	e0bfff17 	ldw	r2,-4(fp)
 d0164c0:	10800044 	addi	r2,r2,1
 d0164c4:	10800003 	ldbu	r2,0(r2)
 d0164c8:	10803fcc 	andi	r2,r2,255
 d0164cc:	1004923a 	slli	r2,r2,8
 d0164d0:	1007883a 	mov	r3,r2
 d0164d4:	e0bffc0b 	ldhu	r2,-16(fp)
 d0164d8:	1884b03a 	or	r2,r3,r2
 d0164dc:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 d0164e0:	e0bffd17 	ldw	r2,-12(fp)
 d0164e4:	10800a17 	ldw	r2,40(r2)
 d0164e8:	1007883a 	mov	r3,r2
 d0164ec:	e0bffe17 	ldw	r2,-8(fp)
 d0164f0:	1885883a 	add	r2,r3,r2
 d0164f4:	e0fffc0b 	ldhu	r3,-16(fp)
 d0164f8:	10c0002d 	sthio	r3,0(r2)
 d0164fc:	00002706 	br	d01659c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 d016500:	e0bffd17 	ldw	r2,-12(fp)
 d016504:	10802e17 	ldw	r2,184(r2)
 d016508:	10800118 	cmpnei	r2,r2,4
 d01650c:	1000231e 	bne	r2,zero,d01659c <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 d016510:	e0bfff17 	ldw	r2,-4(fp)
 d016514:	10800003 	ldbu	r2,0(r2)
 d016518:	10803fcc 	andi	r2,r2,255
 d01651c:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 d016520:	e0bfff17 	ldw	r2,-4(fp)
 d016524:	10800044 	addi	r2,r2,1
 d016528:	10800003 	ldbu	r2,0(r2)
 d01652c:	10803fcc 	andi	r2,r2,255
 d016530:	1006923a 	slli	r3,r2,8
 d016534:	e0bffb17 	ldw	r2,-20(fp)
 d016538:	10c4b03a 	or	r2,r2,r3
 d01653c:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 d016540:	e0bfff17 	ldw	r2,-4(fp)
 d016544:	10800084 	addi	r2,r2,2
 d016548:	10800003 	ldbu	r2,0(r2)
 d01654c:	10803fcc 	andi	r2,r2,255
 d016550:	1006943a 	slli	r3,r2,16
 d016554:	e0bffb17 	ldw	r2,-20(fp)
 d016558:	10c4b03a 	or	r2,r2,r3
 d01655c:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 d016560:	e0bfff17 	ldw	r2,-4(fp)
 d016564:	108000c4 	addi	r2,r2,3
 d016568:	10800003 	ldbu	r2,0(r2)
 d01656c:	10803fcc 	andi	r2,r2,255
 d016570:	1006963a 	slli	r3,r2,24
 d016574:	e0bffb17 	ldw	r2,-20(fp)
 d016578:	10c4b03a 	or	r2,r2,r3
 d01657c:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 d016580:	e0bffd17 	ldw	r2,-12(fp)
 d016584:	10800a17 	ldw	r2,40(r2)
 d016588:	1007883a 	mov	r3,r2
 d01658c:	e0bffe17 	ldw	r2,-8(fp)
 d016590:	1885883a 	add	r2,r3,r2
 d016594:	e0fffb17 	ldw	r3,-20(fp)
 d016598:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 d01659c:	e037883a 	mov	sp,fp
 d0165a0:	df000017 	ldw	fp,0(sp)
 d0165a4:	dec00104 	addi	sp,sp,4
 d0165a8:	f800283a 	ret

0d0165ac <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 d0165ac:	defff304 	addi	sp,sp,-52
 d0165b0:	dfc00c15 	stw	ra,48(sp)
 d0165b4:	df000b15 	stw	fp,44(sp)
 d0165b8:	df000b04 	addi	fp,sp,44
 d0165bc:	e13ffc15 	stw	r4,-16(fp)
 d0165c0:	e17ffd15 	stw	r5,-12(fp)
 d0165c4:	e1bffe15 	stw	r6,-8(fp)
 d0165c8:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 d0165cc:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 d0165d0:	e0bffc17 	ldw	r2,-16(fp)
 d0165d4:	10800a17 	ldw	r2,40(r2)
 d0165d8:	1007883a 	mov	r3,r2
 d0165dc:	e0bffd17 	ldw	r2,-12(fp)
 d0165e0:	1885883a 	add	r2,r3,r2
 d0165e4:	1009883a 	mov	r4,r2
 d0165e8:	e0bffc17 	ldw	r2,-16(fp)
 d0165ec:	11402e17 	ldw	r5,184(r2)
 d0165f0:	d00c8ac0 	call	d00c8ac <__modsi3>
 d0165f4:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 d0165f8:	e0bff917 	ldw	r2,-28(fp)
 d0165fc:	1005003a 	cmpeq	r2,r2,zero
 d016600:	10003a1e 	bne	r2,zero,d0166ec <alt_flash_program_block+0x140>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 d016604:	e0bffc17 	ldw	r2,-16(fp)
 d016608:	10c02e17 	ldw	r3,184(r2)
 d01660c:	e0bff917 	ldw	r2,-28(fp)
 d016610:	1885c83a 	sub	r2,r3,r2
 d016614:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 d016618:	e03ff615 	stw	zero,-40(fp)
 d01661c:	00001206 	br	d016668 <alt_flash_program_block+0xbc>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 d016620:	e17ff617 	ldw	r5,-40(fp)
 d016624:	e0bffc17 	ldw	r2,-16(fp)
 d016628:	10800a17 	ldw	r2,40(r2)
 d01662c:	1009883a 	mov	r4,r2
 d016630:	e0fffd17 	ldw	r3,-12(fp)
 d016634:	e0bff917 	ldw	r2,-28(fp)
 d016638:	1887c83a 	sub	r3,r3,r2
 d01663c:	e0bff617 	ldw	r2,-40(fp)
 d016640:	1885883a 	add	r2,r3,r2
 d016644:	2085883a 	add	r2,r4,r2
 d016648:	10800023 	ldbuio	r2,0(r2)
 d01664c:	1007883a 	mov	r3,r2
 d016650:	e0bffb04 	addi	r2,fp,-20
 d016654:	1145883a 	add	r2,r2,r5
 d016658:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 d01665c:	e0bff617 	ldw	r2,-40(fp)
 d016660:	10800044 	addi	r2,r2,1
 d016664:	e0bff615 	stw	r2,-40(fp)
 d016668:	e0fff617 	ldw	r3,-40(fp)
 d01666c:	e0bff917 	ldw	r2,-28(fp)
 d016670:	18bfeb16 	blt	r3,r2,d016620 <alt_flash_program_block+0x74>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 d016674:	e03ff615 	stw	zero,-40(fp)
 d016678:	00000e06 	br	d0166b4 <alt_flash_program_block+0x108>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 d01667c:	e0fff917 	ldw	r3,-28(fp)
 d016680:	e0bff617 	ldw	r2,-40(fp)
 d016684:	1889883a 	add	r4,r3,r2
 d016688:	e0bff617 	ldw	r2,-40(fp)
 d01668c:	1007883a 	mov	r3,r2
 d016690:	e0bffe17 	ldw	r2,-8(fp)
 d016694:	1885883a 	add	r2,r3,r2
 d016698:	10c00003 	ldbu	r3,0(r2)
 d01669c:	e0bffb04 	addi	r2,fp,-20
 d0166a0:	1105883a 	add	r2,r2,r4
 d0166a4:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 d0166a8:	e0bff617 	ldw	r2,-40(fp)
 d0166ac:	10800044 	addi	r2,r2,1
 d0166b0:	e0bff615 	stw	r2,-40(fp)
 d0166b4:	e0fff617 	ldw	r3,-40(fp)
 d0166b8:	e0bff817 	ldw	r2,-32(fp)
 d0166bc:	18bfef16 	blt	r3,r2,d01667c <alt_flash_program_block+0xd0>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 d0166c0:	e0fffd17 	ldw	r3,-12(fp)
 d0166c4:	e0bff917 	ldw	r2,-28(fp)
 d0166c8:	188bc83a 	sub	r5,r3,r2
 d0166cc:	e1bffb04 	addi	r6,fp,-20
 d0166d0:	e0800217 	ldw	r2,8(fp)
 d0166d4:	e13ffc17 	ldw	r4,-16(fp)
 d0166d8:	103ee83a 	callr	r2
 d0166dc:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 d0166e0:	e0bff817 	ldw	r2,-32(fp)
 d0166e4:	e0bff615 	stw	r2,-40(fp)
 d0166e8:	00000106 	br	d0166f0 <alt_flash_program_block+0x144>
  }
  else
  {
    i = 0;
 d0166ec:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 d0166f0:	e0fffd17 	ldw	r3,-12(fp)
 d0166f4:	e0bfff17 	ldw	r2,-4(fp)
 d0166f8:	1889883a 	add	r4,r3,r2
 d0166fc:	e0bffc17 	ldw	r2,-16(fp)
 d016700:	11402e17 	ldw	r5,184(r2)
 d016704:	d00c8ac0 	call	d00c8ac <__modsi3>
 d016708:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 d01670c:	00001006 	br	d016750 <alt_flash_program_block+0x1a4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 d016710:	e0fffd17 	ldw	r3,-12(fp)
 d016714:	e0bff617 	ldw	r2,-40(fp)
 d016718:	188b883a 	add	r5,r3,r2
 d01671c:	e0bff617 	ldw	r2,-40(fp)
 d016720:	1007883a 	mov	r3,r2
 d016724:	e0bffe17 	ldw	r2,-8(fp)
 d016728:	188d883a 	add	r6,r3,r2
 d01672c:	e0800217 	ldw	r2,8(fp)
 d016730:	e13ffc17 	ldw	r4,-16(fp)
 d016734:	103ee83a 	callr	r2
 d016738:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 d01673c:	e0bffc17 	ldw	r2,-16(fp)
 d016740:	10c02e17 	ldw	r3,184(r2)
 d016744:	e0bff617 	ldw	r2,-40(fp)
 d016748:	10c5883a 	add	r2,r2,r3
 d01674c:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 d016750:	e0bffa17 	ldw	r2,-24(fp)
 d016754:	1004c03a 	cmpne	r2,r2,zero
 d016758:	1000051e 	bne	r2,zero,d016770 <alt_flash_program_block+0x1c4>
 d01675c:	e0ffff17 	ldw	r3,-4(fp)
 d016760:	e0bff717 	ldw	r2,-36(fp)
 d016764:	1887c83a 	sub	r3,r3,r2
 d016768:	e0bff617 	ldw	r2,-40(fp)
 d01676c:	10ffe816 	blt	r2,r3,d016710 <alt_flash_program_block+0x164>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 d016770:	e0bff717 	ldw	r2,-36(fp)
 d016774:	1005003a 	cmpeq	r2,r2,zero
 d016778:	10003c1e 	bne	r2,zero,d01686c <alt_flash_program_block+0x2c0>
 d01677c:	e0bffa17 	ldw	r2,-24(fp)
 d016780:	1004c03a 	cmpne	r2,r2,zero
 d016784:	1000391e 	bne	r2,zero,d01686c <alt_flash_program_block+0x2c0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 d016788:	e0bffc17 	ldw	r2,-16(fp)
 d01678c:	10c02e17 	ldw	r3,184(r2)
 d016790:	e0bff717 	ldw	r2,-36(fp)
 d016794:	1885c83a 	sub	r2,r3,r2
 d016798:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 d01679c:	e03ff515 	stw	zero,-44(fp)
 d0167a0:	00000e06 	br	d0167dc <alt_flash_program_block+0x230>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 d0167a4:	e13ff517 	ldw	r4,-44(fp)
 d0167a8:	e0bff617 	ldw	r2,-40(fp)
 d0167ac:	1007883a 	mov	r3,r2
 d0167b0:	e0bffe17 	ldw	r2,-8(fp)
 d0167b4:	1887883a 	add	r3,r3,r2
 d0167b8:	e0bff517 	ldw	r2,-44(fp)
 d0167bc:	1885883a 	add	r2,r3,r2
 d0167c0:	10c00003 	ldbu	r3,0(r2)
 d0167c4:	e0bffb04 	addi	r2,fp,-20
 d0167c8:	1105883a 	add	r2,r2,r4
 d0167cc:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 d0167d0:	e0bff517 	ldw	r2,-44(fp)
 d0167d4:	10800044 	addi	r2,r2,1
 d0167d8:	e0bff515 	stw	r2,-44(fp)
 d0167dc:	e0fff517 	ldw	r3,-44(fp)
 d0167e0:	e0bff717 	ldw	r2,-36(fp)
 d0167e4:	18bfef16 	blt	r3,r2,d0167a4 <alt_flash_program_block+0x1f8>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 d0167e8:	e03ff515 	stw	zero,-44(fp)
 d0167ec:	00001406 	br	d016840 <alt_flash_program_block+0x294>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 d0167f0:	e0fff717 	ldw	r3,-36(fp)
 d0167f4:	e0bff517 	ldw	r2,-44(fp)
 d0167f8:	188b883a 	add	r5,r3,r2
 d0167fc:	e0bffc17 	ldw	r2,-16(fp)
 d016800:	10800a17 	ldw	r2,40(r2)
 d016804:	1009883a 	mov	r4,r2
 d016808:	e0fffd17 	ldw	r3,-12(fp)
 d01680c:	e0bfff17 	ldw	r2,-4(fp)
 d016810:	1887883a 	add	r3,r3,r2
 d016814:	e0bff517 	ldw	r2,-44(fp)
 d016818:	1885883a 	add	r2,r3,r2
 d01681c:	2085883a 	add	r2,r4,r2
 d016820:	10800023 	ldbuio	r2,0(r2)
 d016824:	1007883a 	mov	r3,r2
 d016828:	e0bffb04 	addi	r2,fp,-20
 d01682c:	1145883a 	add	r2,r2,r5
 d016830:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 d016834:	e0bff517 	ldw	r2,-44(fp)
 d016838:	10800044 	addi	r2,r2,1
 d01683c:	e0bff515 	stw	r2,-44(fp)
 d016840:	e0fff517 	ldw	r3,-44(fp)
 d016844:	e0bff917 	ldw	r2,-28(fp)
 d016848:	18bfe916 	blt	r3,r2,d0167f0 <alt_flash_program_block+0x244>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 d01684c:	e0fffd17 	ldw	r3,-12(fp)
 d016850:	e0bff617 	ldw	r2,-40(fp)
 d016854:	188b883a 	add	r5,r3,r2
 d016858:	e1bffb04 	addi	r6,fp,-20
 d01685c:	e0800217 	ldw	r2,8(fp)
 d016860:	e13ffc17 	ldw	r4,-16(fp)
 d016864:	103ee83a 	callr	r2
 d016868:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 d01686c:	e0bffa17 	ldw	r2,-24(fp)
}
 d016870:	e037883a 	mov	sp,fp
 d016874:	dfc00117 	ldw	ra,4(sp)
 d016878:	df000017 	ldw	fp,0(sp)
 d01687c:	dec00204 	addi	sp,sp,8
 d016880:	f800283a 	ret

0d016884 <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 d016884:	defffd04 	addi	sp,sp,-12
 d016888:	df000215 	stw	fp,8(sp)
 d01688c:	df000204 	addi	fp,sp,8
 d016890:	e13ffe15 	stw	r4,-8(fp)
 d016894:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 d016898:	e0bffe17 	ldw	r2,-8(fp)
 d01689c:	10800a17 	ldw	r2,40(r2)
 d0168a0:	1007883a 	mov	r3,r2
 d0168a4:	e0bfff17 	ldw	r2,-4(fp)
 d0168a8:	1885883a 	add	r2,r3,r2
 d0168ac:	10800023 	ldbuio	r2,0(r2)
 d0168b0:	10803fcc 	andi	r2,r2,255
}
 d0168b4:	e037883a 	mov	sp,fp
 d0168b8:	df000017 	ldw	fp,0(sp)
 d0168bc:	dec00104 	addi	sp,sp,4
 d0168c0:	f800283a 	ret

0d0168c4 <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 d0168c4:	defffd04 	addi	sp,sp,-12
 d0168c8:	df000215 	stw	fp,8(sp)
 d0168cc:	df000204 	addi	fp,sp,8
 d0168d0:	e13ffe15 	stw	r4,-8(fp)
 d0168d4:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 d0168d8:	e0bffe17 	ldw	r2,-8(fp)
 d0168dc:	10800a17 	ldw	r2,40(r2)
 d0168e0:	1007883a 	mov	r3,r2
 d0168e4:	e0bfff17 	ldw	r2,-4(fp)
 d0168e8:	1085883a 	add	r2,r2,r2
 d0168ec:	1885883a 	add	r2,r3,r2
 d0168f0:	1080002b 	ldhuio	r2,0(r2)
 d0168f4:	10803fcc 	andi	r2,r2,255
}
 d0168f8:	e037883a 	mov	sp,fp
 d0168fc:	df000017 	ldw	fp,0(sp)
 d016900:	dec00104 	addi	sp,sp,4
 d016904:	f800283a 	ret

0d016908 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 d016908:	defffd04 	addi	sp,sp,-12
 d01690c:	df000215 	stw	fp,8(sp)
 d016910:	df000204 	addi	fp,sp,8
 d016914:	e13ffe15 	stw	r4,-8(fp)
 d016918:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 d01691c:	e0bffe17 	ldw	r2,-8(fp)
 d016920:	10800a17 	ldw	r2,40(r2)
 d016924:	1007883a 	mov	r3,r2
 d016928:	e0bfff17 	ldw	r2,-4(fp)
 d01692c:	1085883a 	add	r2,r2,r2
 d016930:	1085883a 	add	r2,r2,r2
 d016934:	1885883a 	add	r2,r3,r2
 d016938:	10800037 	ldwio	r2,0(r2)
 d01693c:	10803fcc 	andi	r2,r2,255
}
 d016940:	e037883a 	mov	sp,fp
 d016944:	df000017 	ldw	fp,0(sp)
 d016948:	dec00104 	addi	sp,sp,4
 d01694c:	f800283a 	ret

0d016950 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016950:	defffc04 	addi	sp,sp,-16
 d016954:	df000315 	stw	fp,12(sp)
 d016958:	df000304 	addi	fp,sp,12
 d01695c:	e13ffd15 	stw	r4,-12(fp)
 d016960:	e17ffe15 	stw	r5,-8(fp)
 d016964:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 d016968:	e0fffd17 	ldw	r3,-12(fp)
 d01696c:	e0bffe17 	ldw	r2,-8(fp)
 d016970:	1885883a 	add	r2,r3,r2
 d016974:	e0ffff03 	ldbu	r3,-4(fp)
 d016978:	10c00025 	stbio	r3,0(r2)
  return;
}
 d01697c:	e037883a 	mov	sp,fp
 d016980:	df000017 	ldw	fp,0(sp)
 d016984:	dec00104 	addi	sp,sp,4
 d016988:	f800283a 	ret

0d01698c <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d01698c:	defffc04 	addi	sp,sp,-16
 d016990:	df000315 	stw	fp,12(sp)
 d016994:	df000304 	addi	fp,sp,12
 d016998:	e13ffd15 	stw	r4,-12(fp)
 d01699c:	e17ffe15 	stw	r5,-8(fp)
 d0169a0:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 d0169a4:	e0bffe17 	ldw	r2,-8(fp)
 d0169a8:	1080004c 	andi	r2,r2,1
 d0169ac:	10803fcc 	andi	r2,r2,255
 d0169b0:	1005003a 	cmpeq	r2,r2,zero
 d0169b4:	1000081e 	bne	r2,zero,d0169d8 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 d0169b8:	e0bffe17 	ldw	r2,-8(fp)
 d0169bc:	1085883a 	add	r2,r2,r2
 d0169c0:	1007883a 	mov	r3,r2
 d0169c4:	e0bffd17 	ldw	r2,-12(fp)
 d0169c8:	1885883a 	add	r2,r3,r2
 d0169cc:	e0ffff03 	ldbu	r3,-4(fp)
 d0169d0:	10c00025 	stbio	r3,0(r2)
 d0169d4:	00000806 	br	d0169f8 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 d0169d8:	e0bffe17 	ldw	r2,-8(fp)
 d0169dc:	1085883a 	add	r2,r2,r2
 d0169e0:	1007883a 	mov	r3,r2
 d0169e4:	e0bffd17 	ldw	r2,-12(fp)
 d0169e8:	1885883a 	add	r2,r3,r2
 d0169ec:	10800044 	addi	r2,r2,1
 d0169f0:	e0ffff03 	ldbu	r3,-4(fp)
 d0169f4:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 d0169f8:	e037883a 	mov	sp,fp
 d0169fc:	df000017 	ldw	fp,0(sp)
 d016a00:	dec00104 	addi	sp,sp,4
 d016a04:	f800283a 	ret

0d016a08 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016a08:	defffc04 	addi	sp,sp,-16
 d016a0c:	df000315 	stw	fp,12(sp)
 d016a10:	df000304 	addi	fp,sp,12
 d016a14:	e13ffd15 	stw	r4,-12(fp)
 d016a18:	e17ffe15 	stw	r5,-8(fp)
 d016a1c:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 d016a20:	e0bffe17 	ldw	r2,-8(fp)
 d016a24:	1085883a 	add	r2,r2,r2
 d016a28:	1085883a 	add	r2,r2,r2
 d016a2c:	1007883a 	mov	r3,r2
 d016a30:	e0bffd17 	ldw	r2,-12(fp)
 d016a34:	1885883a 	add	r2,r3,r2
 d016a38:	e0ffff03 	ldbu	r3,-4(fp)
 d016a3c:	10c00025 	stbio	r3,0(r2)
  return;
}
 d016a40:	e037883a 	mov	sp,fp
 d016a44:	df000017 	ldw	fp,0(sp)
 d016a48:	dec00104 	addi	sp,sp,4
 d016a4c:	f800283a 	ret

0d016a50 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016a50:	defffc04 	addi	sp,sp,-16
 d016a54:	df000315 	stw	fp,12(sp)
 d016a58:	df000304 	addi	fp,sp,12
 d016a5c:	e13ffd15 	stw	r4,-12(fp)
 d016a60:	e17ffe15 	stw	r5,-8(fp)
 d016a64:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 d016a68:	e0bffe17 	ldw	r2,-8(fp)
 d016a6c:	1085883a 	add	r2,r2,r2
 d016a70:	1007883a 	mov	r3,r2
 d016a74:	e0bffd17 	ldw	r2,-12(fp)
 d016a78:	1885883a 	add	r2,r3,r2
 d016a7c:	e0ffff03 	ldbu	r3,-4(fp)
 d016a80:	10c0002d 	sthio	r3,0(r2)
  return;
}
 d016a84:	e037883a 	mov	sp,fp
 d016a88:	df000017 	ldw	fp,0(sp)
 d016a8c:	dec00104 	addi	sp,sp,4
 d016a90:	f800283a 	ret

0d016a94 <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016a94:	defffc04 	addi	sp,sp,-16
 d016a98:	df000315 	stw	fp,12(sp)
 d016a9c:	df000304 	addi	fp,sp,12
 d016aa0:	e13ffd15 	stw	r4,-12(fp)
 d016aa4:	e17ffe15 	stw	r5,-8(fp)
 d016aa8:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 d016aac:	e0bffe17 	ldw	r2,-8(fp)
 d016ab0:	1085883a 	add	r2,r2,r2
 d016ab4:	1085883a 	add	r2,r2,r2
 d016ab8:	1007883a 	mov	r3,r2
 d016abc:	e0bffd17 	ldw	r2,-12(fp)
 d016ac0:	1885883a 	add	r2,r3,r2
 d016ac4:	e0ffff03 	ldbu	r3,-4(fp)
 d016ac8:	10c0002d 	sthio	r3,0(r2)
  return;
}
 d016acc:	e037883a 	mov	sp,fp
 d016ad0:	df000017 	ldw	fp,0(sp)
 d016ad4:	dec00104 	addi	sp,sp,4
 d016ad8:	f800283a 	ret

0d016adc <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016adc:	defffc04 	addi	sp,sp,-16
 d016ae0:	df000315 	stw	fp,12(sp)
 d016ae4:	df000304 	addi	fp,sp,12
 d016ae8:	e13ffd15 	stw	r4,-12(fp)
 d016aec:	e17ffe15 	stw	r5,-8(fp)
 d016af0:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 d016af4:	e0bffe17 	ldw	r2,-8(fp)
 d016af8:	1085883a 	add	r2,r2,r2
 d016afc:	1085883a 	add	r2,r2,r2
 d016b00:	1007883a 	mov	r3,r2
 d016b04:	e0bffd17 	ldw	r2,-12(fp)
 d016b08:	1885883a 	add	r2,r3,r2
 d016b0c:	e0ffff03 	ldbu	r3,-4(fp)
 d016b10:	10c00035 	stwio	r3,0(r2)
  return;
}
 d016b14:	e037883a 	mov	sp,fp
 d016b18:	df000017 	ldw	fp,0(sp)
 d016b1c:	dec00104 	addi	sp,sp,4
 d016b20:	f800283a 	ret

0d016b24 <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 d016b24:	defffd04 	addi	sp,sp,-12
 d016b28:	df000215 	stw	fp,8(sp)
 d016b2c:	df000204 	addi	fp,sp,8
 d016b30:	e13ffe15 	stw	r4,-8(fp)
 d016b34:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 d016b38:	e0bfff17 	ldw	r2,-4(fp)
 d016b3c:	10c03fcc 	andi	r3,r2,255
 d016b40:	e0bffe17 	ldw	r2,-8(fp)
 d016b44:	10c00025 	stbio	r3,0(r2)
  return;
}
 d016b48:	e037883a 	mov	sp,fp
 d016b4c:	df000017 	ldw	fp,0(sp)
 d016b50:	dec00104 	addi	sp,sp,4
 d016b54:	f800283a 	ret

0d016b58 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 d016b58:	defffd04 	addi	sp,sp,-12
 d016b5c:	df000215 	stw	fp,8(sp)
 d016b60:	df000204 	addi	fp,sp,8
 d016b64:	e13ffe15 	stw	r4,-8(fp)
 d016b68:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 d016b6c:	e0bfff17 	ldw	r2,-4(fp)
 d016b70:	10ffffcc 	andi	r3,r2,65535
 d016b74:	e0bffe17 	ldw	r2,-8(fp)
 d016b78:	10c0002d 	sthio	r3,0(r2)
  return;
}
 d016b7c:	e037883a 	mov	sp,fp
 d016b80:	df000017 	ldw	fp,0(sp)
 d016b84:	dec00104 	addi	sp,sp,4
 d016b88:	f800283a 	ret

0d016b8c <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 d016b8c:	defffd04 	addi	sp,sp,-12
 d016b90:	df000215 	stw	fp,8(sp)
 d016b94:	df000204 	addi	fp,sp,8
 d016b98:	e13ffe15 	stw	r4,-8(fp)
 d016b9c:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 d016ba0:	e0ffff17 	ldw	r3,-4(fp)
 d016ba4:	e0bffe17 	ldw	r2,-8(fp)
 d016ba8:	10c00035 	stwio	r3,0(r2)
  return;
}
 d016bac:	e037883a 	mov	sp,fp
 d016bb0:	df000017 	ldw	fp,0(sp)
 d016bb4:	dec00104 	addi	sp,sp,4
 d016bb8:	f800283a 	ret

0d016bbc <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 d016bbc:	defffb04 	addi	sp,sp,-20
 d016bc0:	df000415 	stw	fp,16(sp)
 d016bc4:	df000404 	addi	fp,sp,16
 d016bc8:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 d016bcc:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 d016bd0:	e0bffd17 	ldw	r2,-12(fp)
 d016bd4:	10802e17 	ldw	r2,184(r2)
 d016bd8:	e0bfff15 	stw	r2,-4(fp)
 d016bdc:	e0ffff17 	ldw	r3,-4(fp)
 d016be0:	188000a0 	cmpeqi	r2,r3,2
 d016be4:	1000261e 	bne	r2,zero,d016c80 <alt_set_flash_width_func+0xc4>
 d016be8:	e0ffff17 	ldw	r3,-4(fp)
 d016bec:	18800120 	cmpeqi	r2,r3,4
 d016bf0:	1000391e 	bne	r2,zero,d016cd8 <alt_set_flash_width_func+0x11c>
 d016bf4:	e0ffff17 	ldw	r3,-4(fp)
 d016bf8:	18800060 	cmpeqi	r2,r3,1
 d016bfc:	1000011e 	bne	r2,zero,d016c04 <alt_set_flash_width_func+0x48>
 d016c00:	00003e06 	br	d016cfc <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 d016c04:	e0fffd17 	ldw	r3,-12(fp)
 d016c08:	00834074 	movhi	r2,3329
 d016c0c:	109ac904 	addi	r2,r2,27428
 d016c10:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 d016c14:	e0bffd17 	ldw	r2,-12(fp)
 d016c18:	10802f17 	ldw	r2,188(r2)
 d016c1c:	10800058 	cmpnei	r2,r2,1
 d016c20:	1000051e 	bne	r2,zero,d016c38 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 d016c24:	e0fffd17 	ldw	r3,-12(fp)
 d016c28:	00834074 	movhi	r2,3329
 d016c2c:	109a5404 	addi	r2,r2,26960
 d016c30:	18803315 	stw	r2,204(r3)
 d016c34:	00003306 	br	d016d04 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 d016c38:	e0bffd17 	ldw	r2,-12(fp)
 d016c3c:	10802f17 	ldw	r2,188(r2)
 d016c40:	10800098 	cmpnei	r2,r2,2
 d016c44:	1000051e 	bne	r2,zero,d016c5c <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 d016c48:	e0fffd17 	ldw	r3,-12(fp)
 d016c4c:	00834074 	movhi	r2,3329
 d016c50:	109a6304 	addi	r2,r2,27020
 d016c54:	18803315 	stw	r2,204(r3)
 d016c58:	00002a06 	br	d016d04 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 d016c5c:	e0bffd17 	ldw	r2,-12(fp)
 d016c60:	10802f17 	ldw	r2,188(r2)
 d016c64:	10800118 	cmpnei	r2,r2,4
 d016c68:	1000261e 	bne	r2,zero,d016d04 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 d016c6c:	e0fffd17 	ldw	r3,-12(fp)
 d016c70:	00834074 	movhi	r2,3329
 d016c74:	109a8204 	addi	r2,r2,27144
 d016c78:	18803315 	stw	r2,204(r3)
      }
      break;
 d016c7c:	00002106 	br	d016d04 <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 d016c80:	e0fffd17 	ldw	r3,-12(fp)
 d016c84:	00834074 	movhi	r2,3329
 d016c88:	109ad604 	addi	r2,r2,27480
 d016c8c:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 d016c90:	e0bffd17 	ldw	r2,-12(fp)
 d016c94:	10802f17 	ldw	r2,188(r2)
 d016c98:	10800098 	cmpnei	r2,r2,2
 d016c9c:	1000051e 	bne	r2,zero,d016cb4 <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 d016ca0:	e0fffd17 	ldw	r3,-12(fp)
 d016ca4:	00834074 	movhi	r2,3329
 d016ca8:	109a9404 	addi	r2,r2,27216
 d016cac:	18803315 	stw	r2,204(r3)
 d016cb0:	00001406 	br	d016d04 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 d016cb4:	e0bffd17 	ldw	r2,-12(fp)
 d016cb8:	10802f17 	ldw	r2,188(r2)
 d016cbc:	10800118 	cmpnei	r2,r2,4
 d016cc0:	1000101e 	bne	r2,zero,d016d04 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 d016cc4:	e0fffd17 	ldw	r3,-12(fp)
 d016cc8:	00834074 	movhi	r2,3329
 d016ccc:	109aa504 	addi	r2,r2,27284
 d016cd0:	18803315 	stw	r2,204(r3)
      }

      break;
 d016cd4:	00000b06 	br	d016d04 <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 d016cd8:	e0fffd17 	ldw	r3,-12(fp)
 d016cdc:	00834074 	movhi	r2,3329
 d016ce0:	109ae304 	addi	r2,r2,27532
 d016ce4:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 d016ce8:	e0fffd17 	ldw	r3,-12(fp)
 d016cec:	00834074 	movhi	r2,3329
 d016cf0:	109ab704 	addi	r2,r2,27356
 d016cf4:	18803315 	stw	r2,204(r3)
      break;
 d016cf8:	00000206 	br	d016d04 <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 d016cfc:	00bffcc4 	movi	r2,-13
 d016d00:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 d016d04:	e0bffc17 	ldw	r2,-16(fp)
 d016d08:	1004c03a 	cmpne	r2,r2,zero
 d016d0c:	10001e1e 	bne	r2,zero,d016d88 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 d016d10:	e0bffd17 	ldw	r2,-12(fp)
 d016d14:	10802f17 	ldw	r2,188(r2)
 d016d18:	e0bffe15 	stw	r2,-8(fp)
 d016d1c:	e0fffe17 	ldw	r3,-8(fp)
 d016d20:	188000a0 	cmpeqi	r2,r3,2
 d016d24:	10000c1e 	bne	r2,zero,d016d58 <alt_set_flash_width_func+0x19c>
 d016d28:	e0fffe17 	ldw	r3,-8(fp)
 d016d2c:	18800120 	cmpeqi	r2,r3,4
 d016d30:	10000e1e 	bne	r2,zero,d016d6c <alt_set_flash_width_func+0x1b0>
 d016d34:	e0fffe17 	ldw	r3,-8(fp)
 d016d38:	18800060 	cmpeqi	r2,r3,1
 d016d3c:	1000011e 	bne	r2,zero,d016d44 <alt_set_flash_width_func+0x188>
 d016d40:	00000f06 	br	d016d80 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 d016d44:	e0fffd17 	ldw	r3,-12(fp)
 d016d48:	00834074 	movhi	r2,3329
 d016d4c:	109a2104 	addi	r2,r2,26756
 d016d50:	18803415 	stw	r2,208(r3)
        break;
 d016d54:	00000c06 	br	d016d88 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 d016d58:	e0fffd17 	ldw	r3,-12(fp)
 d016d5c:	00834074 	movhi	r2,3329
 d016d60:	109a3104 	addi	r2,r2,26820
 d016d64:	18803415 	stw	r2,208(r3)
        break;
 d016d68:	00000706 	br	d016d88 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 d016d6c:	e0fffd17 	ldw	r3,-12(fp)
 d016d70:	00834074 	movhi	r2,3329
 d016d74:	109a4204 	addi	r2,r2,26888
 d016d78:	18803415 	stw	r2,208(r3)
        break;
 d016d7c:	00000206 	br	d016d88 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 d016d80:	00bffcc4 	movi	r2,-13
 d016d84:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 d016d88:	e0bffc17 	ldw	r2,-16(fp)
}
 d016d8c:	e037883a 	mov	sp,fp
 d016d90:	df000017 	ldw	fp,0(sp)
 d016d94:	dec00104 	addi	sp,sp,4
 d016d98:	f800283a 	ret

0d016d9c <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 d016d9c:	defffc04 	addi	sp,sp,-16
 d016da0:	df000315 	stw	fp,12(sp)
 d016da4:	df000304 	addi	fp,sp,12
 d016da8:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 d016dac:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 d016db0:	e0bffe17 	ldw	r2,-8(fp)
 d016db4:	10802d17 	ldw	r2,180(r2)
 d016db8:	e0bfff15 	stw	r2,-4(fp)
 d016dbc:	e0ffff17 	ldw	r3,-4(fp)
 d016dc0:	188000a0 	cmpeqi	r2,r3,2
 d016dc4:	1000071e 	bne	r2,zero,d016de4 <alt_set_flash_algorithm_func+0x48>
 d016dc8:	e0ffff17 	ldw	r3,-4(fp)
 d016dcc:	188000e0 	cmpeqi	r2,r3,3
 d016dd0:	10000d1e 	bne	r2,zero,d016e08 <alt_set_flash_algorithm_func+0x6c>
 d016dd4:	e0ffff17 	ldw	r3,-4(fp)
 d016dd8:	18800060 	cmpeqi	r2,r3,1
 d016ddc:	10000a1e 	bne	r2,zero,d016e08 <alt_set_flash_algorithm_func+0x6c>
 d016de0:	00001206 	br	d016e2c <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 d016de4:	e0fffe17 	ldw	r3,-8(fp)
 d016de8:	008340f4 	movhi	r2,3331
 d016dec:	1099fc04 	addi	r2,r2,26608
 d016df0:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 d016df4:	e0fffe17 	ldw	r3,-8(fp)
 d016df8:	008340f4 	movhi	r2,3331
 d016dfc:	1099e204 	addi	r2,r2,26504
 d016e00:	18800915 	stw	r2,36(r3)
      break;
 d016e04:	00000b06 	br	d016e34 <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 d016e08:	e0fffe17 	ldw	r3,-8(fp)
 d016e0c:	008340f4 	movhi	r2,3331
 d016e10:	109b1c04 	addi	r2,r2,27760
 d016e14:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 d016e18:	e0fffe17 	ldw	r3,-8(fp)
 d016e1c:	008340f4 	movhi	r2,3331
 d016e20:	109afb04 	addi	r2,r2,27628
 d016e24:	18800915 	stw	r2,36(r3)
      break;
 d016e28:	00000206 	br	d016e34 <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 d016e2c:	00bffec4 	movi	r2,-5
 d016e30:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 d016e34:	e0bffd17 	ldw	r2,-12(fp)
}
 d016e38:	e037883a 	mov	sp,fp
 d016e3c:	df000017 	ldw	fp,0(sp)
 d016e40:	dec00104 	addi	sp,sp,4
 d016e44:	f800283a 	ret

0d016e48 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 d016e48:	defffb04 	addi	sp,sp,-20
 d016e4c:	dfc00415 	stw	ra,16(sp)
 d016e50:	df000315 	stw	fp,12(sp)
 d016e54:	df000304 	addi	fp,sp,12
 d016e58:	e13ffe15 	stw	r4,-8(fp)
 d016e5c:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 d016e60:	e0bffe17 	ldw	r2,-8(fp)
 d016e64:	10803417 	ldw	r2,208(r2)
 d016e68:	e13ffe17 	ldw	r4,-8(fp)
 d016e6c:	e17fff17 	ldw	r5,-4(fp)
 d016e70:	103ee83a 	callr	r2
 d016e74:	10803fcc 	andi	r2,r2,255
 d016e78:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 d016e7c:	e0bffe17 	ldw	r2,-8(fp)
 d016e80:	10c03417 	ldw	r3,208(r2)
 d016e84:	e0bfff17 	ldw	r2,-4(fp)
 d016e88:	11400044 	addi	r5,r2,1
 d016e8c:	e13ffe17 	ldw	r4,-8(fp)
 d016e90:	183ee83a 	callr	r3
 d016e94:	10803fcc 	andi	r2,r2,255
 d016e98:	1004923a 	slli	r2,r2,8
 d016e9c:	1007883a 	mov	r3,r2
 d016ea0:	e0bffd0b 	ldhu	r2,-12(fp)
 d016ea4:	1884b03a 	or	r2,r3,r2
 d016ea8:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 d016eac:	e0bffd0b 	ldhu	r2,-12(fp)
}
 d016eb0:	e037883a 	mov	sp,fp
 d016eb4:	dfc00117 	ldw	ra,4(sp)
 d016eb8:	df000017 	ldw	fp,0(sp)
 d016ebc:	dec00204 	addi	sp,sp,8
 d016ec0:	f800283a 	ret

0d016ec4 <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 d016ec4:	defff104 	addi	sp,sp,-60
 d016ec8:	dfc00e15 	stw	ra,56(sp)
 d016ecc:	df000d15 	stw	fp,52(sp)
 d016ed0:	dc000c15 	stw	r16,48(sp)
 d016ed4:	df000c04 	addi	fp,sp,48
 d016ed8:	e13ffe15 	stw	r4,-8(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 d016edc:	e03ffa15 	stw	zero,-24(fp)
  int   size = 0;
 d016ee0:	e03ff915 	stw	zero,-28(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 d016ee4:	e03ff515 	stw	zero,-44(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 d016ee8:	e13ffe17 	ldw	r4,-8(fp)
 d016eec:	d017c5c0 	call	d017c5c <alt_check_primary_table>
 d016ef0:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
 d016ef4:	e0bffa17 	ldw	r2,-24(fp)
 d016ef8:	1004c03a 	cmpne	r2,r2,zero
 d016efc:	1001651e 	bne	r2,zero,d017494 <alt_read_cfi_table+0x5d0>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 d016f00:	e0bffe17 	ldw	r2,-8(fp)
 d016f04:	10803417 	ldw	r2,208(r2)
 d016f08:	e13ffe17 	ldw	r4,-8(fp)
 d016f0c:	014004c4 	movi	r5,19
 d016f10:	103ee83a 	callr	r2
 d016f14:	10c03fcc 	andi	r3,r2,255
 d016f18:	e0bffe17 	ldw	r2,-8(fp)
 d016f1c:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 d016f20:	e0bffe17 	ldw	r2,-8(fp)
 d016f24:	10803417 	ldw	r2,208(r2)
 d016f28:	e13ffe17 	ldw	r4,-8(fp)
 d016f2c:	014007c4 	movi	r5,31
 d016f30:	103ee83a 	callr	r2
 d016f34:	10803fcc 	andi	r2,r2,255
 d016f38:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 d016f3c:	e0bffe17 	ldw	r2,-8(fp)
 d016f40:	10803417 	ldw	r2,208(r2)
 d016f44:	e13ffe17 	ldw	r4,-8(fp)
 d016f48:	014008c4 	movi	r5,35
 d016f4c:	103ee83a 	callr	r2
 d016f50:	10803fcc 	andi	r2,r2,255
 d016f54:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016f58:	e0bff717 	ldw	r2,-36(fp)
 d016f5c:	1005003a 	cmpeq	r2,r2,zero
 d016f60:	1000031e 	bne	r2,zero,d016f70 <alt_read_cfi_table+0xac>
 d016f64:	e0bff617 	ldw	r2,-40(fp)
 d016f68:	1004c03a 	cmpne	r2,r2,zero
 d016f6c:	1000041e 	bne	r2,zero,d016f80 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 d016f70:	e0fffe17 	ldw	r3,-8(fp)
 d016f74:	0080fa04 	movi	r2,1000
 d016f78:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016f7c:	00000706 	br	d016f9c <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 d016f80:	00c00044 	movi	r3,1
 d016f84:	e0bff717 	ldw	r2,-36(fp)
 d016f88:	1886983a 	sll	r3,r3,r2
 d016f8c:	e0bff617 	ldw	r2,-40(fp)
 d016f90:	1886983a 	sll	r3,r3,r2
 d016f94:	e0bffe17 	ldw	r2,-8(fp)
 d016f98:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 d016f9c:	e0bffe17 	ldw	r2,-8(fp)
 d016fa0:	10803417 	ldw	r2,208(r2)
 d016fa4:	e13ffe17 	ldw	r4,-8(fp)
 d016fa8:	01400844 	movi	r5,33
 d016fac:	103ee83a 	callr	r2
 d016fb0:	10803fcc 	andi	r2,r2,255
 d016fb4:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 d016fb8:	e0bffe17 	ldw	r2,-8(fp)
 d016fbc:	10803417 	ldw	r2,208(r2)
 d016fc0:	e13ffe17 	ldw	r4,-8(fp)
 d016fc4:	01400944 	movi	r5,37
 d016fc8:	103ee83a 	callr	r2
 d016fcc:	10803fcc 	andi	r2,r2,255
 d016fd0:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016fd4:	e0bff717 	ldw	r2,-36(fp)
 d016fd8:	1005003a 	cmpeq	r2,r2,zero
 d016fdc:	1000031e 	bne	r2,zero,d016fec <alt_read_cfi_table+0x128>
 d016fe0:	e0bff617 	ldw	r2,-40(fp)
 d016fe4:	1004c03a 	cmpne	r2,r2,zero
 d016fe8:	1000051e 	bne	r2,zero,d017000 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 d016fec:	e0fffe17 	ldw	r3,-8(fp)
 d016ff0:	00804c74 	movhi	r2,305
 d016ff4:	108b4004 	addi	r2,r2,11520
 d016ff8:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016ffc:	00000a06 	br	d017028 <alt_read_cfi_table+0x164>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 d017000:	00c00044 	movi	r3,1
 d017004:	e0bff717 	ldw	r2,-36(fp)
 d017008:	1886983a 	sll	r3,r3,r2
 d01700c:	e0bff617 	ldw	r2,-40(fp)
 d017010:	1888983a 	sll	r4,r3,r2
 d017014:	0140fa04 	movi	r5,1000
 d017018:	d00235c0 	call	d00235c <__mulsi3>
 d01701c:	1007883a 	mov	r3,r2
 d017020:	e0bffe17 	ldw	r2,-8(fp)
 d017024:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 d017028:	e0bffe17 	ldw	r2,-8(fp)
 d01702c:	10803417 	ldw	r2,208(r2)
 d017030:	e13ffe17 	ldw	r4,-8(fp)
 d017034:	014009c4 	movi	r5,39
 d017038:	103ee83a 	callr	r2
 d01703c:	10c03fcc 	andi	r3,r2,255
 d017040:	00800044 	movi	r2,1
 d017044:	10c4983a 	sll	r2,r2,r3
 d017048:	e0bffb15 	stw	r2,-20(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 d01704c:	e0bffe17 	ldw	r2,-8(fp)
 d017050:	10803417 	ldw	r2,208(r2)
 d017054:	e13ffe17 	ldw	r4,-8(fp)
 d017058:	01400b04 	movi	r5,44
 d01705c:	103ee83a 	callr	r2
 d017060:	10c03fcc 	andi	r3,r2,255
 d017064:	e0bffe17 	ldw	r2,-8(fp)
 d017068:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 d01706c:	e0bffe17 	ldw	r2,-8(fp)
 d017070:	10800c17 	ldw	r2,48(r2)
 d017074:	10800250 	cmplti	r2,r2,9
 d017078:	1000031e 	bne	r2,zero,d017088 <alt_read_cfi_table+0x1c4>
    {
      ret_code = -ENOMEM;
 d01707c:	00bffd04 	movi	r2,-12
 d017080:	e0bffa15 	stw	r2,-24(fp)
 d017084:	00005f06 	br	d017204 <alt_read_cfi_table+0x340>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 d017088:	e03ffd15 	stw	zero,-12(fp)
 d01708c:	00005406 	br	d0171e0 <alt_read_cfi_table+0x31c>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 d017090:	e43ffd17 	ldw	r16,-12(fp)
 d017094:	e0bffd17 	ldw	r2,-12(fp)
 d017098:	1085883a 	add	r2,r2,r2
 d01709c:	1085883a 	add	r2,r2,r2
 d0170a0:	11400b44 	addi	r5,r2,45
 d0170a4:	e13ffe17 	ldw	r4,-8(fp)
 d0170a8:	d016e480 	call	d016e48 <alt_read_16bit_query_entry>
 d0170ac:	113fffcc 	andi	r4,r2,65535
 d0170b0:	e0fffe17 	ldw	r3,-8(fp)
 d0170b4:	8004913a 	slli	r2,r16,4
 d0170b8:	10c5883a 	add	r2,r2,r3
 d0170bc:	10800f04 	addi	r2,r2,60
 d0170c0:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 d0170c4:	e17ffd17 	ldw	r5,-12(fp)
 d0170c8:	e0bffd17 	ldw	r2,-12(fp)
 d0170cc:	e0fffe17 	ldw	r3,-8(fp)
 d0170d0:	1004913a 	slli	r2,r2,4
 d0170d4:	10c5883a 	add	r2,r2,r3
 d0170d8:	10800f04 	addi	r2,r2,60
 d0170dc:	10800017 	ldw	r2,0(r2)
 d0170e0:	11000044 	addi	r4,r2,1
 d0170e4:	e0fffe17 	ldw	r3,-8(fp)
 d0170e8:	2804913a 	slli	r2,r5,4
 d0170ec:	10c5883a 	add	r2,r2,r3
 d0170f0:	10800f04 	addi	r2,r2,60
 d0170f4:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 d0170f8:	e43ffd17 	ldw	r16,-12(fp)
 d0170fc:	e0bffd17 	ldw	r2,-12(fp)
 d017100:	1085883a 	add	r2,r2,r2
 d017104:	1085883a 	add	r2,r2,r2
 d017108:	11400bc4 	addi	r5,r2,47
 d01710c:	e13ffe17 	ldw	r4,-8(fp)
 d017110:	d016e480 	call	d016e48 <alt_read_16bit_query_entry>
 d017114:	113fffcc 	andi	r4,r2,65535
 d017118:	e0fffe17 	ldw	r3,-8(fp)
 d01711c:	8004913a 	slli	r2,r16,4
 d017120:	10c5883a 	add	r2,r2,r3
 d017124:	10801004 	addi	r2,r2,64
 d017128:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 d01712c:	e17ffd17 	ldw	r5,-12(fp)
 d017130:	e0bffd17 	ldw	r2,-12(fp)
 d017134:	e0fffe17 	ldw	r3,-8(fp)
 d017138:	1004913a 	slli	r2,r2,4
 d01713c:	10c5883a 	add	r2,r2,r3
 d017140:	10801004 	addi	r2,r2,64
 d017144:	10800017 	ldw	r2,0(r2)
 d017148:	1008923a 	slli	r4,r2,8
 d01714c:	e0fffe17 	ldw	r3,-8(fp)
 d017150:	2804913a 	slli	r2,r5,4
 d017154:	10c5883a 	add	r2,r2,r3
 d017158:	10801004 	addi	r2,r2,64
 d01715c:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 d017160:	e43ffd17 	ldw	r16,-12(fp)
 d017164:	e0bffd17 	ldw	r2,-12(fp)
 d017168:	e0fffe17 	ldw	r3,-8(fp)
 d01716c:	1004913a 	slli	r2,r2,4
 d017170:	10c5883a 	add	r2,r2,r3
 d017174:	10800f04 	addi	r2,r2,60
 d017178:	11000017 	ldw	r4,0(r2)
 d01717c:	e0bffd17 	ldw	r2,-12(fp)
 d017180:	e0fffe17 	ldw	r3,-8(fp)
 d017184:	1004913a 	slli	r2,r2,4
 d017188:	10c5883a 	add	r2,r2,r3
 d01718c:	10801004 	addi	r2,r2,64
 d017190:	11400017 	ldw	r5,0(r2)
 d017194:	d00235c0 	call	d00235c <__mulsi3>
 d017198:	1009883a 	mov	r4,r2
 d01719c:	e0fffe17 	ldw	r3,-8(fp)
 d0171a0:	8004913a 	slli	r2,r16,4
 d0171a4:	10c5883a 	add	r2,r2,r3
 d0171a8:	10800e04 	addi	r2,r2,56
 d0171ac:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 d0171b0:	e0bffd17 	ldw	r2,-12(fp)
 d0171b4:	e0fffe17 	ldw	r3,-8(fp)
 d0171b8:	1004913a 	slli	r2,r2,4
 d0171bc:	10c5883a 	add	r2,r2,r3
 d0171c0:	10800e04 	addi	r2,r2,56
 d0171c4:	10c00017 	ldw	r3,0(r2)
 d0171c8:	e0bff917 	ldw	r2,-28(fp)
 d0171cc:	10c5883a 	add	r2,r2,r3
 d0171d0:	e0bff915 	stw	r2,-28(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 d0171d4:	e0bffd17 	ldw	r2,-12(fp)
 d0171d8:	10800044 	addi	r2,r2,1
 d0171dc:	e0bffd15 	stw	r2,-12(fp)
 d0171e0:	e0bffe17 	ldw	r2,-8(fp)
 d0171e4:	10c00c17 	ldw	r3,48(r2)
 d0171e8:	e0bffd17 	ldw	r2,-12(fp)
 d0171ec:	10ffa816 	blt	r2,r3,d017090 <alt_read_cfi_table+0x1cc>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 d0171f0:	e0fff917 	ldw	r3,-28(fp)
 d0171f4:	e0bffb17 	ldw	r2,-20(fp)
 d0171f8:	18800226 	beq	r3,r2,d017204 <alt_read_cfi_table+0x340>
      {
        ret_code = -ENODEV;
 d0171fc:	00bffb44 	movi	r2,-19
 d017200:	e0bffa15 	stw	r2,-24(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 d017204:	e0bffe17 	ldw	r2,-8(fp)
 d017208:	10c03417 	ldw	r3,208(r2)
 d01720c:	e0bffe17 	ldw	r2,-8(fp)
 d017210:	10803217 	ldw	r2,200(r2)
 d017214:	114003c4 	addi	r5,r2,15
 d017218:	e13ffe17 	ldw	r4,-8(fp)
 d01721c:	183ee83a 	callr	r3
 d017220:	e0bff405 	stb	r2,-48(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 d017224:	e0bffe17 	ldw	r2,-8(fp)
 d017228:	10802d17 	ldw	r2,180(r2)
 d01722c:	10800098 	cmpnei	r2,r2,2
 d017230:	1000601e 	bne	r2,zero,d0173b4 <alt_read_cfi_table+0x4f0>
 d017234:	e0bff403 	ldbu	r2,-48(fp)
 d017238:	108000d8 	cmpnei	r2,r2,3
 d01723c:	10005d1e 	bne	r2,zero,d0173b4 <alt_read_cfi_table+0x4f0>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 d017240:	e0bffe17 	ldw	r2,-8(fp)
 d017244:	10800c17 	ldw	r2,48(r2)
 d017248:	10bfffc4 	addi	r2,r2,-1
 d01724c:	e0bffd15 	stw	r2,-12(fp)
 d017250:	e03ffc15 	stw	zero,-16(fp)
          j<=i;i--,j++)
 d017254:	00005406 	br	d0173a8 <alt_read_cfi_table+0x4e4>
      {
        swap = flash->dev.region_info[i].region_size;
 d017258:	e0bffd17 	ldw	r2,-12(fp)
 d01725c:	e0fffe17 	ldw	r3,-8(fp)
 d017260:	1004913a 	slli	r2,r2,4
 d017264:	10c5883a 	add	r2,r2,r3
 d017268:	10800e04 	addi	r2,r2,56
 d01726c:	10800017 	ldw	r2,0(r2)
 d017270:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].region_size =  
 d017274:	e17ffd17 	ldw	r5,-12(fp)
 d017278:	e0bffc17 	ldw	r2,-16(fp)
 d01727c:	e0fffe17 	ldw	r3,-8(fp)
 d017280:	1004913a 	slli	r2,r2,4
 d017284:	10c5883a 	add	r2,r2,r3
 d017288:	10800e04 	addi	r2,r2,56
 d01728c:	11000017 	ldw	r4,0(r2)
 d017290:	e0fffe17 	ldw	r3,-8(fp)
 d017294:	2804913a 	slli	r2,r5,4
 d017298:	10c5883a 	add	r2,r2,r3
 d01729c:	10800e04 	addi	r2,r2,56
 d0172a0:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 d0172a4:	e0bffc17 	ldw	r2,-16(fp)
 d0172a8:	e0fffe17 	ldw	r3,-8(fp)
 d0172ac:	1004913a 	slli	r2,r2,4
 d0172b0:	10c5883a 	add	r2,r2,r3
 d0172b4:	10c00e04 	addi	r3,r2,56
 d0172b8:	e0bff817 	ldw	r2,-32(fp)
 d0172bc:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 d0172c0:	e0bffd17 	ldw	r2,-12(fp)
 d0172c4:	e0fffe17 	ldw	r3,-8(fp)
 d0172c8:	1004913a 	slli	r2,r2,4
 d0172cc:	10c5883a 	add	r2,r2,r3
 d0172d0:	10801004 	addi	r2,r2,64
 d0172d4:	10800017 	ldw	r2,0(r2)
 d0172d8:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].block_size =  
 d0172dc:	e17ffd17 	ldw	r5,-12(fp)
 d0172e0:	e0bffc17 	ldw	r2,-16(fp)
 d0172e4:	e0fffe17 	ldw	r3,-8(fp)
 d0172e8:	1004913a 	slli	r2,r2,4
 d0172ec:	10c5883a 	add	r2,r2,r3
 d0172f0:	10801004 	addi	r2,r2,64
 d0172f4:	11000017 	ldw	r4,0(r2)
 d0172f8:	e0fffe17 	ldw	r3,-8(fp)
 d0172fc:	2804913a 	slli	r2,r5,4
 d017300:	10c5883a 	add	r2,r2,r3
 d017304:	10801004 	addi	r2,r2,64
 d017308:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 d01730c:	e0bffc17 	ldw	r2,-16(fp)
 d017310:	e0fffe17 	ldw	r3,-8(fp)
 d017314:	1004913a 	slli	r2,r2,4
 d017318:	10c5883a 	add	r2,r2,r3
 d01731c:	10c01004 	addi	r3,r2,64
 d017320:	e0bff817 	ldw	r2,-32(fp)
 d017324:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 d017328:	e0bffd17 	ldw	r2,-12(fp)
 d01732c:	e0fffe17 	ldw	r3,-8(fp)
 d017330:	1004913a 	slli	r2,r2,4
 d017334:	10c5883a 	add	r2,r2,r3
 d017338:	10800f04 	addi	r2,r2,60
 d01733c:	10800017 	ldw	r2,0(r2)
 d017340:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].number_of_blocks =  
 d017344:	e17ffd17 	ldw	r5,-12(fp)
 d017348:	e0bffc17 	ldw	r2,-16(fp)
 d01734c:	e0fffe17 	ldw	r3,-8(fp)
 d017350:	1004913a 	slli	r2,r2,4
 d017354:	10c5883a 	add	r2,r2,r3
 d017358:	10800f04 	addi	r2,r2,60
 d01735c:	11000017 	ldw	r4,0(r2)
 d017360:	e0fffe17 	ldw	r3,-8(fp)
 d017364:	2804913a 	slli	r2,r5,4
 d017368:	10c5883a 	add	r2,r2,r3
 d01736c:	10800f04 	addi	r2,r2,60
 d017370:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 d017374:	e0bffc17 	ldw	r2,-16(fp)
 d017378:	e0fffe17 	ldw	r3,-8(fp)
 d01737c:	1004913a 	slli	r2,r2,4
 d017380:	10c5883a 	add	r2,r2,r3
 d017384:	10c00f04 	addi	r3,r2,60
 d017388:	e0bff817 	ldw	r2,-32(fp)
 d01738c:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 d017390:	e0bffd17 	ldw	r2,-12(fp)
 d017394:	10bfffc4 	addi	r2,r2,-1
 d017398:	e0bffd15 	stw	r2,-12(fp)
 d01739c:	e0bffc17 	ldw	r2,-16(fp)
 d0173a0:	10800044 	addi	r2,r2,1
 d0173a4:	e0bffc15 	stw	r2,-16(fp)
 d0173a8:	e0fffc17 	ldw	r3,-16(fp)
 d0173ac:	e0bffd17 	ldw	r2,-12(fp)
 d0173b0:	10ffa90e 	bge	r2,r3,d017258 <alt_read_cfi_table+0x394>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 d0173b4:	e03ffd15 	stw	zero,-12(fp)
 d0173b8:	00001306 	br	d017408 <alt_read_cfi_table+0x544>
    {
      flash->dev.region_info[i].offset = offset;
 d0173bc:	e0bffd17 	ldw	r2,-12(fp)
 d0173c0:	e0fffe17 	ldw	r3,-8(fp)
 d0173c4:	1004913a 	slli	r2,r2,4
 d0173c8:	10c5883a 	add	r2,r2,r3
 d0173cc:	10c00d04 	addi	r3,r2,52
 d0173d0:	e0bff517 	ldw	r2,-44(fp)
 d0173d4:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 d0173d8:	e0bffd17 	ldw	r2,-12(fp)
 d0173dc:	e0fffe17 	ldw	r3,-8(fp)
 d0173e0:	1004913a 	slli	r2,r2,4
 d0173e4:	10c5883a 	add	r2,r2,r3
 d0173e8:	10800e04 	addi	r2,r2,56
 d0173ec:	10c00017 	ldw	r3,0(r2)
 d0173f0:	e0bff517 	ldw	r2,-44(fp)
 d0173f4:	10c5883a 	add	r2,r2,r3
 d0173f8:	e0bff515 	stw	r2,-44(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 d0173fc:	e0bffd17 	ldw	r2,-12(fp)
 d017400:	10800044 	addi	r2,r2,1
 d017404:	e0bffd15 	stw	r2,-12(fp)
 d017408:	e0bffe17 	ldw	r2,-8(fp)
 d01740c:	10c00c17 	ldw	r3,48(r2)
 d017410:	e0bffd17 	ldw	r2,-12(fp)
 d017414:	10ffe916 	blt	r2,r3,d0173bc <alt_read_cfi_table+0x4f8>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
 d017418:	e0bffe17 	ldw	r2,-8(fp)
 d01741c:	10802d17 	ldw	r2,180(r2)
 d017420:	e0bfff15 	stw	r2,-4(fp)
 d017424:	e0ffff17 	ldw	r3,-4(fp)
 d017428:	188000a0 	cmpeqi	r2,r3,2
 d01742c:	1000071e 	bne	r2,zero,d01744c <alt_read_cfi_table+0x588>
 d017430:	e0ffff17 	ldw	r3,-4(fp)
 d017434:	188000e0 	cmpeqi	r2,r3,3
 d017438:	10000c1e 	bne	r2,zero,d01746c <alt_read_cfi_table+0x5a8>
 d01743c:	e0ffff17 	ldw	r3,-4(fp)
 d017440:	18800060 	cmpeqi	r2,r3,1
 d017444:	1000091e 	bne	r2,zero,d01746c <alt_read_cfi_table+0x5a8>
 d017448:	00001006 	br	d01748c <alt_read_cfi_table+0x5c8>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 d01744c:	e0bffe17 	ldw	r2,-8(fp)
 d017450:	10c03317 	ldw	r3,204(r2)
 d017454:	e0bffe17 	ldw	r2,-8(fp)
 d017458:	11000a17 	ldw	r4,40(r2)
 d01745c:	01401544 	movi	r5,85
 d017460:	01803c04 	movi	r6,240
 d017464:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
 d017468:	00000a06 	br	d017494 <alt_read_cfi_table+0x5d0>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 d01746c:	e0bffe17 	ldw	r2,-8(fp)
 d017470:	10c03317 	ldw	r3,204(r2)
 d017474:	e0bffe17 	ldw	r2,-8(fp)
 d017478:	11000a17 	ldw	r4,40(r2)
 d01747c:	01401544 	movi	r5,85
 d017480:	01803fc4 	movi	r6,255
 d017484:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
 d017488:	00000206 	br	d017494 <alt_read_cfi_table+0x5d0>
      }
      default:
      {
        ret_code = -EIO;
 d01748c:	00bffec4 	movi	r2,-5
 d017490:	e0bffa15 	stw	r2,-24(fp)
      }
    } 
  }  

  return ret_code;
 d017494:	e0bffa17 	ldw	r2,-24(fp)
}
 d017498:	e037883a 	mov	sp,fp
 d01749c:	dfc00217 	ldw	ra,8(sp)
 d0174a0:	df000117 	ldw	fp,4(sp)
 d0174a4:	dc000017 	ldw	r16,0(sp)
 d0174a8:	dec00304 	addi	sp,sp,12
 d0174ac:	f800283a 	ret

0d0174b0 <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 d0174b0:	defff704 	addi	sp,sp,-36
 d0174b4:	dfc00815 	stw	ra,32(sp)
 d0174b8:	df000715 	stw	fp,28(sp)
 d0174bc:	df000704 	addi	fp,sp,28
 d0174c0:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 d0174c4:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d0174c8:	e0bfff17 	ldw	r2,-4(fp)
 d0174cc:	11000a17 	ldw	r4,40(r2)
 d0174d0:	01401544 	movi	r5,85
 d0174d4:	01802604 	movi	r6,152
 d0174d8:	d0169500 	call	d016950 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 d0174dc:	e03ffb15 	stw	zero,-20(fp)
 d0174e0:	00000f06 	br	d017520 <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 d0174e4:	e13ffb17 	ldw	r4,-20(fp)
 d0174e8:	e0bfff17 	ldw	r2,-4(fp)
 d0174ec:	10800a17 	ldw	r2,40(r2)
 d0174f0:	1007883a 	mov	r3,r2
 d0174f4:	e0bffb17 	ldw	r2,-20(fp)
 d0174f8:	1885883a 	add	r2,r3,r2
 d0174fc:	10800404 	addi	r2,r2,16
 d017500:	10800023 	ldbuio	r2,0(r2)
 d017504:	1007883a 	mov	r3,r2
 d017508:	e0bffc04 	addi	r2,fp,-16
 d01750c:	1105883a 	add	r2,r2,r4
 d017510:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 d017514:	e0bffb17 	ldw	r2,-20(fp)
 d017518:	10800044 	addi	r2,r2,1
 d01751c:	e0bffb15 	stw	r2,-20(fp)
 d017520:	e0bffb17 	ldw	r2,-20(fp)
 d017524:	108000d0 	cmplti	r2,r2,3
 d017528:	103fee1e 	bne	r2,zero,d0174e4 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 d01752c:	e0bffc03 	ldbu	r2,-16(fp)
 d017530:	10803fcc 	andi	r2,r2,255
 d017534:	10801458 	cmpnei	r2,r2,81
 d017538:	10001d1e 	bne	r2,zero,d0175b0 <alt_read_cfi_width+0x100>
 d01753c:	e0bffc43 	ldbu	r2,-15(fp)
 d017540:	10803fcc 	andi	r2,r2,255
 d017544:	10801498 	cmpnei	r2,r2,82
 d017548:	1000191e 	bne	r2,zero,d0175b0 <alt_read_cfi_width+0x100>
 d01754c:	e0bffc83 	ldbu	r2,-14(fp)
 d017550:	10803fcc 	andi	r2,r2,255
 d017554:	10801658 	cmpnei	r2,r2,89
 d017558:	1000151e 	bne	r2,zero,d0175b0 <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 d01755c:	e0ffff17 	ldw	r3,-4(fp)
 d017560:	00800044 	movi	r2,1
 d017564:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 d017568:	e0ffff17 	ldw	r3,-4(fp)
 d01756c:	00800044 	movi	r2,1
 d017570:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 d017574:	e0bfff17 	ldw	r2,-4(fp)
 d017578:	10800a17 	ldw	r2,40(r2)
 d01757c:	10800a04 	addi	r2,r2,40
 d017580:	1080002b 	ldhuio	r2,0(r2)
 d017584:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 d017588:	e0bffa0b 	ldhu	r2,-24(fp)
 d01758c:	10800044 	addi	r2,r2,1
 d017590:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 d017594:	e0bffa0b 	ldhu	r2,-24(fp)
 d017598:	1080004c 	andi	r2,r2,1
 d01759c:	1004c03a 	cmpne	r2,r2,zero
 d0175a0:	1001a81e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 d0175a4:	00bffb44 	movi	r2,-19
 d0175a8:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 d0175ac:	0001a506 	br	d017c44 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d0175b0:	e0bfff17 	ldw	r2,-4(fp)
 d0175b4:	11000a17 	ldw	r4,40(r2)
 d0175b8:	01401544 	movi	r5,85
 d0175bc:	01802604 	movi	r6,152
 d0175c0:	d01698c0 	call	d01698c <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 d0175c4:	e03ffb15 	stw	zero,-20(fp)
 d0175c8:	00000f06 	br	d017608 <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 d0175cc:	e13ffb17 	ldw	r4,-20(fp)
 d0175d0:	e0bfff17 	ldw	r2,-4(fp)
 d0175d4:	10800a17 	ldw	r2,40(r2)
 d0175d8:	1007883a 	mov	r3,r2
 d0175dc:	e0bffb17 	ldw	r2,-20(fp)
 d0175e0:	1885883a 	add	r2,r3,r2
 d0175e4:	10800804 	addi	r2,r2,32
 d0175e8:	10800023 	ldbuio	r2,0(r2)
 d0175ec:	1007883a 	mov	r3,r2
 d0175f0:	e0bffc04 	addi	r2,fp,-16
 d0175f4:	1105883a 	add	r2,r2,r4
 d0175f8:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 d0175fc:	e0bffb17 	ldw	r2,-20(fp)
 d017600:	10800044 	addi	r2,r2,1
 d017604:	e0bffb15 	stw	r2,-20(fp)
 d017608:	e0bffb17 	ldw	r2,-20(fp)
 d01760c:	10800190 	cmplti	r2,r2,6
 d017610:	103fee1e 	bne	r2,zero,d0175cc <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 d017614:	e0bffc03 	ldbu	r2,-16(fp)
 d017618:	10803fcc 	andi	r2,r2,255
 d01761c:	10801458 	cmpnei	r2,r2,81
 d017620:	1000291e 	bne	r2,zero,d0176c8 <alt_read_cfi_width+0x218>
 d017624:	e0bffc43 	ldbu	r2,-15(fp)
 d017628:	10803fcc 	andi	r2,r2,255
 d01762c:	10801458 	cmpnei	r2,r2,81
 d017630:	1000251e 	bne	r2,zero,d0176c8 <alt_read_cfi_width+0x218>
 d017634:	e0bffc83 	ldbu	r2,-14(fp)
 d017638:	10803fcc 	andi	r2,r2,255
 d01763c:	10801498 	cmpnei	r2,r2,82
 d017640:	1000211e 	bne	r2,zero,d0176c8 <alt_read_cfi_width+0x218>
 d017644:	e0bffcc3 	ldbu	r2,-13(fp)
 d017648:	10803fcc 	andi	r2,r2,255
 d01764c:	10801498 	cmpnei	r2,r2,82
 d017650:	10001d1e 	bne	r2,zero,d0176c8 <alt_read_cfi_width+0x218>
 d017654:	e0bffd03 	ldbu	r2,-12(fp)
 d017658:	10803fcc 	andi	r2,r2,255
 d01765c:	10801658 	cmpnei	r2,r2,89
 d017660:	1000191e 	bne	r2,zero,d0176c8 <alt_read_cfi_width+0x218>
 d017664:	e0bffd43 	ldbu	r2,-11(fp)
 d017668:	10803fcc 	andi	r2,r2,255
 d01766c:	10801658 	cmpnei	r2,r2,89
 d017670:	1000151e 	bne	r2,zero,d0176c8 <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 d017674:	e0ffff17 	ldw	r3,-4(fp)
 d017678:	00800044 	movi	r2,1
 d01767c:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 d017680:	e0ffff17 	ldw	r3,-4(fp)
 d017684:	00800084 	movi	r2,2
 d017688:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 d01768c:	e0bfff17 	ldw	r2,-4(fp)
 d017690:	10800a17 	ldw	r2,40(r2)
 d017694:	10801404 	addi	r2,r2,80
 d017698:	1080002b 	ldhuio	r2,0(r2)
 d01769c:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 d0176a0:	e0bffa0b 	ldhu	r2,-24(fp)
 d0176a4:	10800044 	addi	r2,r2,1
 d0176a8:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 d0176ac:	e0bffa0b 	ldhu	r2,-24(fp)
 d0176b0:	1080004c 	andi	r2,r2,1
 d0176b4:	1004c03a 	cmpne	r2,r2,zero
 d0176b8:	1001621e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 d0176bc:	00bffb44 	movi	r2,-19
 d0176c0:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 d0176c4:	00015f06 	br	d017c44 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d0176c8:	e0bfff17 	ldw	r2,-4(fp)
 d0176cc:	11000a17 	ldw	r4,40(r2)
 d0176d0:	01401544 	movi	r5,85
 d0176d4:	01802604 	movi	r6,152
 d0176d8:	d016a500 	call	d016a50 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 d0176dc:	e03ffb15 	stw	zero,-20(fp)
 d0176e0:	00000f06 	br	d017720 <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 d0176e4:	e13ffb17 	ldw	r4,-20(fp)
 d0176e8:	e0bfff17 	ldw	r2,-4(fp)
 d0176ec:	10800a17 	ldw	r2,40(r2)
 d0176f0:	1007883a 	mov	r3,r2
 d0176f4:	e0bffb17 	ldw	r2,-20(fp)
 d0176f8:	1885883a 	add	r2,r3,r2
 d0176fc:	10800804 	addi	r2,r2,32
 d017700:	10800023 	ldbuio	r2,0(r2)
 d017704:	1007883a 	mov	r3,r2
 d017708:	e0bffc04 	addi	r2,fp,-16
 d01770c:	1105883a 	add	r2,r2,r4
 d017710:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 d017714:	e0bffb17 	ldw	r2,-20(fp)
 d017718:	10800044 	addi	r2,r2,1
 d01771c:	e0bffb15 	stw	r2,-20(fp)
 d017720:	e0bffb17 	ldw	r2,-20(fp)
 d017724:	10800190 	cmplti	r2,r2,6
 d017728:	103fee1e 	bne	r2,zero,d0176e4 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 d01772c:	e0bffc03 	ldbu	r2,-16(fp)
 d017730:	10803fcc 	andi	r2,r2,255
 d017734:	10801458 	cmpnei	r2,r2,81
 d017738:	1000291e 	bne	r2,zero,d0177e0 <alt_read_cfi_width+0x330>
 d01773c:	e0bffc43 	ldbu	r2,-15(fp)
 d017740:	10803fcc 	andi	r2,r2,255
 d017744:	1004c03a 	cmpne	r2,r2,zero
 d017748:	1000251e 	bne	r2,zero,d0177e0 <alt_read_cfi_width+0x330>
 d01774c:	e0bffc83 	ldbu	r2,-14(fp)
 d017750:	10803fcc 	andi	r2,r2,255
 d017754:	10801498 	cmpnei	r2,r2,82
 d017758:	1000211e 	bne	r2,zero,d0177e0 <alt_read_cfi_width+0x330>
 d01775c:	e0bffcc3 	ldbu	r2,-13(fp)
 d017760:	10803fcc 	andi	r2,r2,255
 d017764:	1004c03a 	cmpne	r2,r2,zero
 d017768:	10001d1e 	bne	r2,zero,d0177e0 <alt_read_cfi_width+0x330>
 d01776c:	e0bffd03 	ldbu	r2,-12(fp)
 d017770:	10803fcc 	andi	r2,r2,255
 d017774:	10801658 	cmpnei	r2,r2,89
 d017778:	1000191e 	bne	r2,zero,d0177e0 <alt_read_cfi_width+0x330>
 d01777c:	e0bffd43 	ldbu	r2,-11(fp)
 d017780:	10803fcc 	andi	r2,r2,255
 d017784:	1004c03a 	cmpne	r2,r2,zero
 d017788:	1000151e 	bne	r2,zero,d0177e0 <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 d01778c:	e0ffff17 	ldw	r3,-4(fp)
 d017790:	00800084 	movi	r2,2
 d017794:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 d017798:	e0ffff17 	ldw	r3,-4(fp)
 d01779c:	00800084 	movi	r2,2
 d0177a0:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 d0177a4:	e0bfff17 	ldw	r2,-4(fp)
 d0177a8:	10800a17 	ldw	r2,40(r2)
 d0177ac:	10801404 	addi	r2,r2,80
 d0177b0:	1080002b 	ldhuio	r2,0(r2)
 d0177b4:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 d0177b8:	e0bffa0b 	ldhu	r2,-24(fp)
 d0177bc:	10800044 	addi	r2,r2,1
 d0177c0:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 d0177c4:	e0bffa0b 	ldhu	r2,-24(fp)
 d0177c8:	1080008c 	andi	r2,r2,2
 d0177cc:	1004c03a 	cmpne	r2,r2,zero
 d0177d0:	10011c1e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 d0177d4:	00bffb44 	movi	r2,-19
 d0177d8:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 d0177dc:	00011906 	br	d017c44 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d0177e0:	e0bfff17 	ldw	r2,-4(fp)
 d0177e4:	11000a17 	ldw	r4,40(r2)
 d0177e8:	01401544 	movi	r5,85
 d0177ec:	01802604 	movi	r6,152
 d0177f0:	d016adc0 	call	d016adc <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 d0177f4:	e03ffb15 	stw	zero,-20(fp)
 d0177f8:	00000f06 	br	d017838 <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 d0177fc:	e13ffb17 	ldw	r4,-20(fp)
 d017800:	e0bfff17 	ldw	r2,-4(fp)
 d017804:	10800a17 	ldw	r2,40(r2)
 d017808:	1007883a 	mov	r3,r2
 d01780c:	e0bffb17 	ldw	r2,-20(fp)
 d017810:	1885883a 	add	r2,r3,r2
 d017814:	10801004 	addi	r2,r2,64
 d017818:	10800023 	ldbuio	r2,0(r2)
 d01781c:	1007883a 	mov	r3,r2
 d017820:	e0bffc04 	addi	r2,fp,-16
 d017824:	1105883a 	add	r2,r2,r4
 d017828:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 d01782c:	e0bffb17 	ldw	r2,-20(fp)
 d017830:	10800044 	addi	r2,r2,1
 d017834:	e0bffb15 	stw	r2,-20(fp)
 d017838:	e0bffb17 	ldw	r2,-20(fp)
 d01783c:	10800310 	cmplti	r2,r2,12
 d017840:	103fee1e 	bne	r2,zero,d0177fc <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 d017844:	e0bffc03 	ldbu	r2,-16(fp)
 d017848:	10803fcc 	andi	r2,r2,255
 d01784c:	10801458 	cmpnei	r2,r2,81
 d017850:	1000411e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d017854:	e0bffc43 	ldbu	r2,-15(fp)
 d017858:	10803fcc 	andi	r2,r2,255
 d01785c:	1004c03a 	cmpne	r2,r2,zero
 d017860:	10003d1e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d017864:	e0bffc83 	ldbu	r2,-14(fp)
 d017868:	10803fcc 	andi	r2,r2,255
 d01786c:	1004c03a 	cmpne	r2,r2,zero
 d017870:	1000391e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d017874:	e0bffcc3 	ldbu	r2,-13(fp)
 d017878:	10803fcc 	andi	r2,r2,255
 d01787c:	1004c03a 	cmpne	r2,r2,zero
 d017880:	1000351e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d017884:	e0bffd03 	ldbu	r2,-12(fp)
 d017888:	10803fcc 	andi	r2,r2,255
 d01788c:	10801498 	cmpnei	r2,r2,82
 d017890:	1000311e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d017894:	e0bffd43 	ldbu	r2,-11(fp)
 d017898:	10803fcc 	andi	r2,r2,255
 d01789c:	1004c03a 	cmpne	r2,r2,zero
 d0178a0:	10002d1e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d0178a4:	e0bffd83 	ldbu	r2,-10(fp)
 d0178a8:	10803fcc 	andi	r2,r2,255
 d0178ac:	1004c03a 	cmpne	r2,r2,zero
 d0178b0:	1000291e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d0178b4:	e0bffdc3 	ldbu	r2,-9(fp)
 d0178b8:	10803fcc 	andi	r2,r2,255
 d0178bc:	1004c03a 	cmpne	r2,r2,zero
 d0178c0:	1000251e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d0178c4:	e0bffe03 	ldbu	r2,-8(fp)
 d0178c8:	10803fcc 	andi	r2,r2,255
 d0178cc:	10801658 	cmpnei	r2,r2,89
 d0178d0:	1000211e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d0178d4:	e0bffe43 	ldbu	r2,-7(fp)
 d0178d8:	10803fcc 	andi	r2,r2,255
 d0178dc:	1004c03a 	cmpne	r2,r2,zero
 d0178e0:	10001d1e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d0178e4:	e0bffe83 	ldbu	r2,-6(fp)
 d0178e8:	10803fcc 	andi	r2,r2,255
 d0178ec:	1004c03a 	cmpne	r2,r2,zero
 d0178f0:	1000191e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
 d0178f4:	e0bffec3 	ldbu	r2,-5(fp)
 d0178f8:	10803fcc 	andi	r2,r2,255
 d0178fc:	1004c03a 	cmpne	r2,r2,zero
 d017900:	1000151e 	bne	r2,zero,d017958 <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 d017904:	e0ffff17 	ldw	r3,-4(fp)
 d017908:	00800104 	movi	r2,4
 d01790c:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 d017910:	e0ffff17 	ldw	r3,-4(fp)
 d017914:	00800104 	movi	r2,4
 d017918:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 d01791c:	e0bfff17 	ldw	r2,-4(fp)
 d017920:	10800a17 	ldw	r2,40(r2)
 d017924:	10802804 	addi	r2,r2,160
 d017928:	10800037 	ldwio	r2,0(r2)
 d01792c:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 d017930:	e0bffa0b 	ldhu	r2,-24(fp)
 d017934:	10800044 	addi	r2,r2,1
 d017938:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 d01793c:	e0bffa0b 	ldhu	r2,-24(fp)
 d017940:	1080010c 	andi	r2,r2,4
 d017944:	1004c03a 	cmpne	r2,r2,zero
 d017948:	1000be1e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 d01794c:	00bffb44 	movi	r2,-19
 d017950:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 d017954:	0000bb06 	br	d017c44 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d017958:	e0bfff17 	ldw	r2,-4(fp)
 d01795c:	11000a17 	ldw	r4,40(r2)
 d017960:	01401544 	movi	r5,85
 d017964:	01802604 	movi	r6,152
 d017968:	d016a940 	call	d016a94 <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 d01796c:	e03ffb15 	stw	zero,-20(fp)
 d017970:	00000f06 	br	d0179b0 <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 d017974:	e13ffb17 	ldw	r4,-20(fp)
 d017978:	e0bfff17 	ldw	r2,-4(fp)
 d01797c:	10800a17 	ldw	r2,40(r2)
 d017980:	1007883a 	mov	r3,r2
 d017984:	e0bffb17 	ldw	r2,-20(fp)
 d017988:	1885883a 	add	r2,r3,r2
 d01798c:	10801004 	addi	r2,r2,64
 d017990:	10800023 	ldbuio	r2,0(r2)
 d017994:	1007883a 	mov	r3,r2
 d017998:	e0bffc04 	addi	r2,fp,-16
 d01799c:	1105883a 	add	r2,r2,r4
 d0179a0:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 d0179a4:	e0bffb17 	ldw	r2,-20(fp)
 d0179a8:	10800044 	addi	r2,r2,1
 d0179ac:	e0bffb15 	stw	r2,-20(fp)
 d0179b0:	e0bffb17 	ldw	r2,-20(fp)
 d0179b4:	10800310 	cmplti	r2,r2,12
 d0179b8:	103fee1e 	bne	r2,zero,d017974 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 d0179bc:	e0bffc03 	ldbu	r2,-16(fp)
 d0179c0:	10803fcc 	andi	r2,r2,255
 d0179c4:	10801458 	cmpnei	r2,r2,81
 d0179c8:	1000411e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d0179cc:	e0bffc43 	ldbu	r2,-15(fp)
 d0179d0:	10803fcc 	andi	r2,r2,255
 d0179d4:	1004c03a 	cmpne	r2,r2,zero
 d0179d8:	10003d1e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d0179dc:	e0bffc83 	ldbu	r2,-14(fp)
 d0179e0:	10803fcc 	andi	r2,r2,255
 d0179e4:	10801458 	cmpnei	r2,r2,81
 d0179e8:	1000391e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d0179ec:	e0bffcc3 	ldbu	r2,-13(fp)
 d0179f0:	10803fcc 	andi	r2,r2,255
 d0179f4:	1004c03a 	cmpne	r2,r2,zero
 d0179f8:	1000351e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d0179fc:	e0bffd03 	ldbu	r2,-12(fp)
 d017a00:	10803fcc 	andi	r2,r2,255
 d017a04:	10801498 	cmpnei	r2,r2,82
 d017a08:	1000311e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d017a0c:	e0bffd43 	ldbu	r2,-11(fp)
 d017a10:	10803fcc 	andi	r2,r2,255
 d017a14:	1004c03a 	cmpne	r2,r2,zero
 d017a18:	10002d1e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d017a1c:	e0bffd83 	ldbu	r2,-10(fp)
 d017a20:	10803fcc 	andi	r2,r2,255
 d017a24:	10801498 	cmpnei	r2,r2,82
 d017a28:	1000291e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d017a2c:	e0bffdc3 	ldbu	r2,-9(fp)
 d017a30:	10803fcc 	andi	r2,r2,255
 d017a34:	1004c03a 	cmpne	r2,r2,zero
 d017a38:	1000251e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d017a3c:	e0bffe03 	ldbu	r2,-8(fp)
 d017a40:	10803fcc 	andi	r2,r2,255
 d017a44:	10801658 	cmpnei	r2,r2,89
 d017a48:	1000211e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d017a4c:	e0bffe43 	ldbu	r2,-7(fp)
 d017a50:	10803fcc 	andi	r2,r2,255
 d017a54:	1004c03a 	cmpne	r2,r2,zero
 d017a58:	10001d1e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d017a5c:	e0bffe83 	ldbu	r2,-6(fp)
 d017a60:	10803fcc 	andi	r2,r2,255
 d017a64:	10801658 	cmpnei	r2,r2,89
 d017a68:	1000191e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
 d017a6c:	e0bffec3 	ldbu	r2,-5(fp)
 d017a70:	10803fcc 	andi	r2,r2,255
 d017a74:	1004c03a 	cmpne	r2,r2,zero
 d017a78:	1000151e 	bne	r2,zero,d017ad0 <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 d017a7c:	e0ffff17 	ldw	r3,-4(fp)
 d017a80:	00800084 	movi	r2,2
 d017a84:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 d017a88:	e0ffff17 	ldw	r3,-4(fp)
 d017a8c:	00800104 	movi	r2,4
 d017a90:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 d017a94:	e0bfff17 	ldw	r2,-4(fp)
 d017a98:	10800a17 	ldw	r2,40(r2)
 d017a9c:	10802804 	addi	r2,r2,160
 d017aa0:	10800037 	ldwio	r2,0(r2)
 d017aa4:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 d017aa8:	e0bffa0b 	ldhu	r2,-24(fp)
 d017aac:	10800044 	addi	r2,r2,1
 d017ab0:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 d017ab4:	e0bffa0b 	ldhu	r2,-24(fp)
 d017ab8:	1080010c 	andi	r2,r2,4
 d017abc:	1004c03a 	cmpne	r2,r2,zero
 d017ac0:	1000601e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 d017ac4:	00bffb44 	movi	r2,-19
 d017ac8:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 d017acc:	00005d06 	br	d017c44 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d017ad0:	e0bfff17 	ldw	r2,-4(fp)
 d017ad4:	11000a17 	ldw	r4,40(r2)
 d017ad8:	01401544 	movi	r5,85
 d017adc:	01802604 	movi	r6,152
 d017ae0:	d016a080 	call	d016a08 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 d017ae4:	e03ffb15 	stw	zero,-20(fp)
 d017ae8:	00000f06 	br	d017b28 <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 d017aec:	e13ffb17 	ldw	r4,-20(fp)
 d017af0:	e0bfff17 	ldw	r2,-4(fp)
 d017af4:	10800a17 	ldw	r2,40(r2)
 d017af8:	1007883a 	mov	r3,r2
 d017afc:	e0bffb17 	ldw	r2,-20(fp)
 d017b00:	1885883a 	add	r2,r3,r2
 d017b04:	10801004 	addi	r2,r2,64
 d017b08:	10800023 	ldbuio	r2,0(r2)
 d017b0c:	1007883a 	mov	r3,r2
 d017b10:	e0bffc04 	addi	r2,fp,-16
 d017b14:	1105883a 	add	r2,r2,r4
 d017b18:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 d017b1c:	e0bffb17 	ldw	r2,-20(fp)
 d017b20:	10800044 	addi	r2,r2,1
 d017b24:	e0bffb15 	stw	r2,-20(fp)
 d017b28:	e0bffb17 	ldw	r2,-20(fp)
 d017b2c:	10800310 	cmplti	r2,r2,12
 d017b30:	103fee1e 	bne	r2,zero,d017aec <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 d017b34:	e0bffc03 	ldbu	r2,-16(fp)
 d017b38:	10803fcc 	andi	r2,r2,255
 d017b3c:	10801458 	cmpnei	r2,r2,81
 d017b40:	1000401e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017b44:	e0bffc43 	ldbu	r2,-15(fp)
 d017b48:	10803fcc 	andi	r2,r2,255
 d017b4c:	10801458 	cmpnei	r2,r2,81
 d017b50:	10003c1e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017b54:	e0bffc83 	ldbu	r2,-14(fp)
 d017b58:	10803fcc 	andi	r2,r2,255
 d017b5c:	10801458 	cmpnei	r2,r2,81
 d017b60:	1000381e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017b64:	e0bffcc3 	ldbu	r2,-13(fp)
 d017b68:	10803fcc 	andi	r2,r2,255
 d017b6c:	10801458 	cmpnei	r2,r2,81
 d017b70:	1000341e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017b74:	e0bffd03 	ldbu	r2,-12(fp)
 d017b78:	10803fcc 	andi	r2,r2,255
 d017b7c:	10801498 	cmpnei	r2,r2,82
 d017b80:	1000301e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017b84:	e0bffd43 	ldbu	r2,-11(fp)
 d017b88:	10803fcc 	andi	r2,r2,255
 d017b8c:	10801498 	cmpnei	r2,r2,82
 d017b90:	10002c1e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017b94:	e0bffd83 	ldbu	r2,-10(fp)
 d017b98:	10803fcc 	andi	r2,r2,255
 d017b9c:	10801498 	cmpnei	r2,r2,82
 d017ba0:	1000281e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017ba4:	e0bffdc3 	ldbu	r2,-9(fp)
 d017ba8:	10803fcc 	andi	r2,r2,255
 d017bac:	10801498 	cmpnei	r2,r2,82
 d017bb0:	1000241e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017bb4:	e0bffe03 	ldbu	r2,-8(fp)
 d017bb8:	10803fcc 	andi	r2,r2,255
 d017bbc:	10801658 	cmpnei	r2,r2,89
 d017bc0:	1000201e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017bc4:	e0bffe43 	ldbu	r2,-7(fp)
 d017bc8:	10803fcc 	andi	r2,r2,255
 d017bcc:	10801658 	cmpnei	r2,r2,89
 d017bd0:	10001c1e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017bd4:	e0bffe83 	ldbu	r2,-6(fp)
 d017bd8:	10803fcc 	andi	r2,r2,255
 d017bdc:	10801658 	cmpnei	r2,r2,89
 d017be0:	1000181e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
 d017be4:	e0bffec3 	ldbu	r2,-5(fp)
 d017be8:	10803fcc 	andi	r2,r2,255
 d017bec:	10801658 	cmpnei	r2,r2,89
 d017bf0:	1000141e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 d017bf4:	e0ffff17 	ldw	r3,-4(fp)
 d017bf8:	00800044 	movi	r2,1
 d017bfc:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 d017c00:	e0ffff17 	ldw	r3,-4(fp)
 d017c04:	00800104 	movi	r2,4
 d017c08:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 d017c0c:	e0bfff17 	ldw	r2,-4(fp)
 d017c10:	10800a17 	ldw	r2,40(r2)
 d017c14:	10802804 	addi	r2,r2,160
 d017c18:	10800037 	ldwio	r2,0(r2)
 d017c1c:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 d017c20:	e0bffa0b 	ldhu	r2,-24(fp)
 d017c24:	10800044 	addi	r2,r2,1
 d017c28:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 d017c2c:	e0bffa0b 	ldhu	r2,-24(fp)
 d017c30:	1080010c 	andi	r2,r2,4
 d017c34:	1004c03a 	cmpne	r2,r2,zero
 d017c38:	1000021e 	bne	r2,zero,d017c44 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 d017c3c:	00bffb44 	movi	r2,-19
 d017c40:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 d017c44:	e0bff917 	ldw	r2,-28(fp)
}
 d017c48:	e037883a 	mov	sp,fp
 d017c4c:	dfc00117 	ldw	ra,4(sp)
 d017c50:	df000017 	ldw	fp,0(sp)
 d017c54:	dec00204 	addi	sp,sp,8
 d017c58:	f800283a 	ret

0d017c5c <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 d017c5c:	defff904 	addi	sp,sp,-28
 d017c60:	dfc00615 	stw	ra,24(sp)
 d017c64:	df000515 	stw	fp,20(sp)
 d017c68:	dc000415 	stw	r16,16(sp)
 d017c6c:	df000404 	addi	fp,sp,16
 d017c70:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 d017c74:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 d017c78:	e13fff17 	ldw	r4,-4(fp)
 d017c7c:	01400544 	movi	r5,21
 d017c80:	d016e480 	call	d016e48 <alt_read_16bit_query_entry>
 d017c84:	10ffffcc 	andi	r3,r2,65535
 d017c88:	e0bfff17 	ldw	r2,-4(fp)
 d017c8c:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 d017c90:	e03ffd15 	stw	zero,-12(fp)
 d017c94:	00001006 	br	d017cd8 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 d017c98:	e43ffd17 	ldw	r16,-12(fp)
 d017c9c:	e0bfff17 	ldw	r2,-4(fp)
 d017ca0:	11803417 	ldw	r6,208(r2)
 d017ca4:	e0bfff17 	ldw	r2,-4(fp)
 d017ca8:	10c03217 	ldw	r3,200(r2)
 d017cac:	e0bffd17 	ldw	r2,-12(fp)
 d017cb0:	188b883a 	add	r5,r3,r2
 d017cb4:	e13fff17 	ldw	r4,-4(fp)
 d017cb8:	303ee83a 	callr	r6
 d017cbc:	1007883a 	mov	r3,r2
 d017cc0:	e0bffe04 	addi	r2,fp,-8
 d017cc4:	1405883a 	add	r2,r2,r16
 d017cc8:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 d017ccc:	e0bffd17 	ldw	r2,-12(fp)
 d017cd0:	10800044 	addi	r2,r2,1
 d017cd4:	e0bffd15 	stw	r2,-12(fp)
 d017cd8:	e0bffd17 	ldw	r2,-12(fp)
 d017cdc:	108000d0 	cmplti	r2,r2,3
 d017ce0:	103fed1e 	bne	r2,zero,d017c98 <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 d017ce4:	e0bffe03 	ldbu	r2,-8(fp)
 d017ce8:	10803fcc 	andi	r2,r2,255
 d017cec:	10801418 	cmpnei	r2,r2,80
 d017cf0:	1000081e 	bne	r2,zero,d017d14 <alt_check_primary_table+0xb8>
 d017cf4:	e0bffe43 	ldbu	r2,-7(fp)
 d017cf8:	10803fcc 	andi	r2,r2,255
 d017cfc:	10801498 	cmpnei	r2,r2,82
 d017d00:	1000041e 	bne	r2,zero,d017d14 <alt_check_primary_table+0xb8>
 d017d04:	e0bffe83 	ldbu	r2,-6(fp)
 d017d08:	10803fcc 	andi	r2,r2,255
 d017d0c:	10801260 	cmpeqi	r2,r2,73
 d017d10:	1000021e 	bne	r2,zero,d017d1c <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 d017d14:	00bffb44 	movi	r2,-19
 d017d18:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 d017d1c:	e0bffc17 	ldw	r2,-16(fp)
}
 d017d20:	e037883a 	mov	sp,fp
 d017d24:	dfc00217 	ldw	ra,8(sp)
 d017d28:	df000117 	ldw	fp,4(sp)
 d017d2c:	dc000017 	ldw	r16,0(sp)
 d017d30:	dec00304 	addi	sp,sp,12
 d017d34:	f800283a 	ret

0d017d38 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
 d017d38:	defffc04 	addi	sp,sp,-16
 d017d3c:	dfc00315 	stw	ra,12(sp)
 d017d40:	df000215 	stw	fp,8(sp)
 d017d44:	df000204 	addi	fp,sp,8
 d017d48:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 d017d4c:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
 d017d50:	e13fff17 	ldw	r4,-4(fp)
 d017d54:	d017dc40 	call	d017dc4 <alt_epcs_flash_query>
 d017d58:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
 d017d5c:	e0bffe17 	ldw	r2,-8(fp)
 d017d60:	1004c03a 	cmpne	r2,r2,zero
 d017d64:	1000031e 	bne	r2,zero,d017d74 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
 d017d68:	e13fff17 	ldw	r4,-4(fp)
 d017d6c:	d017d8c0 	call	d017d8c <alt_flash_device_register>
 d017d70:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
 d017d74:	e0bffe17 	ldw	r2,-8(fp)
}
 d017d78:	e037883a 	mov	sp,fp
 d017d7c:	dfc00117 	ldw	ra,4(sp)
 d017d80:	df000017 	ldw	fp,0(sp)
 d017d84:	dec00204 	addi	sp,sp,8
 d017d88:	f800283a 	ret

0d017d8c <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 d017d8c:	defffd04 	addi	sp,sp,-12
 d017d90:	dfc00215 	stw	ra,8(sp)
 d017d94:	df000115 	stw	fp,4(sp)
 d017d98:	df000104 	addi	fp,sp,4
 d017d9c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 d017da0:	e13fff17 	ldw	r4,-4(fp)
 d017da4:	01434174 	movhi	r5,3333
 d017da8:	29522604 	addi	r5,r5,18584
 d017dac:	d0351b00 	call	d0351b0 <alt_dev_llist_insert>
}
 d017db0:	e037883a 	mov	sp,fp
 d017db4:	dfc00117 	ldw	ra,4(sp)
 d017db8:	df000017 	ldw	fp,0(sp)
 d017dbc:	dec00204 	addi	sp,sp,8
 d017dc0:	f800283a 	ret

0d017dc4 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
 d017dc4:	defffc04 	addi	sp,sp,-16
 d017dc8:	dfc00315 	stw	ra,12(sp)
 d017dcc:	df000215 	stw	fp,8(sp)
 d017dd0:	df000204 	addi	fp,sp,8
 d017dd4:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 d017dd8:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
 d017ddc:	e0bfff17 	ldw	r2,-4(fp)
 d017de0:	10003115 	stw	zero,196(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
 d017de4:	e0bfff17 	ldw	r2,-4(fp)
 d017de8:	11002d17 	ldw	r4,180(r2)
 d017dec:	d01a8940 	call	d01a894 <epcs_read_electronic_signature>
 d017df0:	10c03fcc 	andi	r3,r2,255
 d017df4:	e0bfff17 	ldw	r2,-4(fp)
 d017df8:	10c02f15 	stw	r3,188(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
 d017dfc:	e0bfff17 	ldw	r2,-4(fp)
 d017e00:	10802f17 	ldw	r2,188(r2)
 d017e04:	10800598 	cmpnei	r2,r2,22
 d017e08:	10000a1e 	bne	r2,zero,d017e34 <alt_epcs_flash_query+0x70>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 d017e0c:	e0ffff17 	ldw	r3,-4(fp)
 d017e10:	00802034 	movhi	r2,128
 d017e14:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 128;
 d017e18:	e0ffff17 	ldw	r3,-4(fp)
 d017e1c:	00802004 	movi	r2,128
 d017e20:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 d017e24:	e0ffff17 	ldw	r3,-4(fp)
 d017e28:	00800074 	movhi	r2,1
 d017e2c:	18801015 	stw	r2,64(r3)
 d017e30:	00007306 	br	d018000 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
 d017e34:	e0bfff17 	ldw	r2,-4(fp)
 d017e38:	10802f17 	ldw	r2,188(r2)
 d017e3c:	10800518 	cmpnei	r2,r2,20
 d017e40:	10000a1e 	bne	r2,zero,d017e6c <alt_epcs_flash_query+0xa8>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 d017e44:	e0ffff17 	ldw	r3,-4(fp)
 d017e48:	00800834 	movhi	r2,32
 d017e4c:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 32;
 d017e50:	e0ffff17 	ldw	r3,-4(fp)
 d017e54:	00800804 	movi	r2,32
 d017e58:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 d017e5c:	e0ffff17 	ldw	r3,-4(fp)
 d017e60:	00800074 	movhi	r2,1
 d017e64:	18801015 	stw	r2,64(r3)
 d017e68:	00006506 	br	d018000 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
 d017e6c:	e0bfff17 	ldw	r2,-4(fp)
 d017e70:	10802f17 	ldw	r2,188(r2)
 d017e74:	108004d8 	cmpnei	r2,r2,19
 d017e78:	10000a1e 	bne	r2,zero,d017ea4 <alt_epcs_flash_query+0xe0>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
 d017e7c:	e0ffff17 	ldw	r3,-4(fp)
 d017e80:	00800434 	movhi	r2,16
 d017e84:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 16;
 d017e88:	e0ffff17 	ldw	r3,-4(fp)
 d017e8c:	00800404 	movi	r2,16
 d017e90:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 d017e94:	e0ffff17 	ldw	r3,-4(fp)
 d017e98:	00800074 	movhi	r2,1
 d017e9c:	18801015 	stw	r2,64(r3)
 d017ea0:	00005706 	br	d018000 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
 d017ea4:	e0bfff17 	ldw	r2,-4(fp)
 d017ea8:	10802f17 	ldw	r2,188(r2)
 d017eac:	10800498 	cmpnei	r2,r2,18
 d017eb0:	10000a1e 	bne	r2,zero,d017edc <alt_epcs_flash_query+0x118>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
 d017eb4:	e0ffff17 	ldw	r3,-4(fp)
 d017eb8:	00800234 	movhi	r2,8
 d017ebc:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 8;
 d017ec0:	e0ffff17 	ldw	r3,-4(fp)
 d017ec4:	00800204 	movi	r2,8
 d017ec8:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 d017ecc:	e0ffff17 	ldw	r3,-4(fp)
 d017ed0:	00800074 	movhi	r2,1
 d017ed4:	18801015 	stw	r2,64(r3)
 d017ed8:	00004906 	br	d018000 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
 d017edc:	e0bfff17 	ldw	r2,-4(fp)
 d017ee0:	10802f17 	ldw	r2,188(r2)
 d017ee4:	10800418 	cmpnei	r2,r2,16
 d017ee8:	10000a1e 	bne	r2,zero,d017f14 <alt_epcs_flash_query+0x150>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
 d017eec:	e0ffff17 	ldw	r3,-4(fp)
 d017ef0:	008000b4 	movhi	r2,2
 d017ef4:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 4;
 d017ef8:	e0ffff17 	ldw	r3,-4(fp)
 d017efc:	00800104 	movi	r2,4
 d017f00:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 32768;
 d017f04:	e0ffff17 	ldw	r3,-4(fp)
 d017f08:	00a00014 	movui	r2,32768
 d017f0c:	18801015 	stw	r2,64(r3)
 d017f10:	00003b06 	br	d018000 <alt_epcs_flash_query+0x23c>
  {
    /* 
     * Read electronic signature doesn't work for the EPCS128; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
 d017f14:	e0bfff17 	ldw	r2,-4(fp)
 d017f18:	11002d17 	ldw	r4,180(r2)
 d017f1c:	d01a9000 	call	d01a900 <epcs_read_device_id>
 d017f20:	1007883a 	mov	r3,r2
 d017f24:	e0bfff17 	ldw	r2,-4(fp)
 d017f28:	10c02f15 	stw	r3,188(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
 d017f2c:	e0bfff17 	ldw	r2,-4(fp)
 d017f30:	10c02f17 	ldw	r3,188(r2)
 d017f34:	00804034 	movhi	r2,256
 d017f38:	10bfffc4 	addi	r2,r2,-1
 d017f3c:	1886703a 	and	r3,r3,r2
 d017f40:	00800874 	movhi	r2,33
 d017f44:	10ae8604 	addi	r2,r2,-17896
 d017f48:	18800a1e 	bne	r3,r2,d017f74 <alt_epcs_flash_query+0x1b0>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 d017f4c:	e0ffff17 	ldw	r3,-4(fp)
 d017f50:	00804034 	movhi	r2,256
 d017f54:	18800e15 	stw	r2,56(r3)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
 d017f58:	e0ffff17 	ldw	r3,-4(fp)
 d017f5c:	00804004 	movi	r2,256
 d017f60:	18800f15 	stw	r2,60(r3)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 d017f64:	e0ffff17 	ldw	r3,-4(fp)
 d017f68:	00800074 	movhi	r2,1
 d017f6c:	18801015 	stw	r2,64(r3)
 d017f70:	00002306 	br	d018000 <alt_epcs_flash_query+0x23c>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
 d017f74:	e0bfff17 	ldw	r2,-4(fp)
 d017f78:	10802f17 	ldw	r2,188(r2)
 d017f7c:	10803fcc 	andi	r2,r2,255
 d017f80:	10800618 	cmpnei	r2,r2,24
 d017f84:	10000a1e 	bne	r2,zero,d017fb0 <alt_epcs_flash_query+0x1ec>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 d017f88:	e0ffff17 	ldw	r3,-4(fp)
 d017f8c:	00804034 	movhi	r2,256
 d017f90:	18800e15 	stw	r2,56(r3)
      flash->dev.region_info[0].number_of_blocks = 64;
 d017f94:	e0ffff17 	ldw	r3,-4(fp)
 d017f98:	00801004 	movi	r2,64
 d017f9c:	18800f15 	stw	r2,60(r3)
      flash->dev.region_info[0].block_size = 262144;
 d017fa0:	e0ffff17 	ldw	r3,-4(fp)
 d017fa4:	00800134 	movhi	r2,4
 d017fa8:	18801015 	stw	r2,64(r3)
 d017fac:	00001406 	br	d018000 <alt_epcs_flash_query+0x23c>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
 d017fb0:	e0bfff17 	ldw	r2,-4(fp)
 d017fb4:	10802f17 	ldw	r2,188(r2)
 d017fb8:	10803fcc 	andi	r2,r2,255
 d017fbc:	10800658 	cmpnei	r2,r2,25
 d017fc0:	10000d1e 	bne	r2,zero,d017ff8 <alt_epcs_flash_query+0x234>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
 d017fc4:	e0ffff17 	ldw	r3,-4(fp)
 d017fc8:	00808034 	movhi	r2,512
 d017fcc:	18800e15 	stw	r2,56(r3)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
 d017fd0:	e0ffff17 	ldw	r3,-4(fp)
 d017fd4:	00808004 	movi	r2,512
 d017fd8:	18800f15 	stw	r2,60(r3)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 d017fdc:	e0ffff17 	ldw	r3,-4(fp)
 d017fe0:	00800074 	movhi	r2,1
 d017fe4:	18801015 	stw	r2,64(r3)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
 d017fe8:	e0ffff17 	ldw	r3,-4(fp)
 d017fec:	00800044 	movi	r2,1
 d017ff0:	18803115 	stw	r2,196(r3)
 d017ff4:	00000206 	br	d018000 <alt_epcs_flash_query+0x23c>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
 d017ff8:	00bffb44 	movi	r2,-19
 d017ffc:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
 d018000:	e0bfff17 	ldw	r2,-4(fp)
 d018004:	10800e17 	ldw	r2,56(r2)
 d018008:	1007883a 	mov	r3,r2
 d01800c:	e0bfff17 	ldw	r2,-4(fp)
 d018010:	10c02e15 	stw	r3,184(r2)
  flash->dev.number_of_regions = 1;
 d018014:	e0ffff17 	ldw	r3,-4(fp)
 d018018:	00800044 	movi	r2,1
 d01801c:	18800c15 	stw	r2,48(r3)
  flash->dev.region_info[0].offset = 0;
 d018020:	e0bfff17 	ldw	r2,-4(fp)
 d018024:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
 d018028:	e0ffff17 	ldw	r3,-4(fp)
 d01802c:	00804004 	movi	r2,256
 d018030:	18803015 	stw	r2,192(r3)

  /* Consider clearing all BP bits here. */
  return ret_code;
 d018034:	e0bffe17 	ldw	r2,-8(fp)
}
 d018038:	e037883a 	mov	sp,fp
 d01803c:	dfc00117 	ldw	ra,4(sp)
 d018040:	df000017 	ldw	fp,0(sp)
 d018044:	dec00204 	addi	sp,sp,8
 d018048:	f800283a 	ret

0d01804c <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
 d01804c:	deffeb04 	addi	sp,sp,-84
 d018050:	dfc01415 	stw	ra,80(sp)
 d018054:	df001315 	stw	fp,76(sp)
 d018058:	df001304 	addi	fp,sp,76
 d01805c:	e13ff915 	stw	r4,-28(fp)
 d018060:	e17ffa15 	stw	r5,-24(fp)
 d018064:	e1bffb15 	stw	r6,-20(fp)
 d018068:	e1fffc15 	stw	r7,-16(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
 d01806c:	00800804 	movi	r2,32
 d018070:	e0bff015 	stw	r2,-64(fp)
  int current_offset = 0;
 d018074:	e03fef15 	stw	zero,-68(fp)

  while (n > 0)
 d018078:	00002c06 	br	d01812c <alt_epcs_flash_memcmp+0xe0>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
 d01807c:	e0bff017 	ldw	r2,-64(fp)
 d018080:	e0bfff15 	stw	r2,-4(fp)
 d018084:	e0fffc17 	ldw	r3,-16(fp)
 d018088:	e0fffe15 	stw	r3,-8(fp)
 d01808c:	e0bfff17 	ldw	r2,-4(fp)
 d018090:	e0fffe17 	ldw	r3,-8(fp)
 d018094:	10c0022e 	bgeu	r2,r3,d0180a0 <alt_epcs_flash_memcmp+0x54>
 d018098:	e0bfff17 	ldw	r2,-4(fp)
 d01809c:	e0bffe15 	stw	r2,-8(fp)
 d0180a0:	e0fffe17 	ldw	r3,-8(fp)
 d0180a4:	e0ffee15 	stw	r3,-72(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
 d0180a8:	e0fffb17 	ldw	r3,-20(fp)
 d0180ac:	e0bfef17 	ldw	r2,-68(fp)
 d0180b0:	188b883a 	add	r5,r3,r2
 d0180b4:	e1bff104 	addi	r6,fp,-60
 d0180b8:	e13ff917 	ldw	r4,-28(fp)
 d0180bc:	e1ffee17 	ldw	r7,-72(fp)
 d0180c0:	d0186840 	call	d018684 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
 d0180c4:	1004403a 	cmpge	r2,r2,zero
 d0180c8:	1000031e 	bne	r2,zero,d0180d8 <alt_epcs_flash_memcmp+0x8c>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
 d0180cc:	00bfffc4 	movi	r2,-1
 d0180d0:	e0bffd15 	stw	r2,-12(fp)
 d0180d4:	00001906 	br	d01813c <alt_epcs_flash_memcmp+0xf0>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
 d0180d8:	e0fffa17 	ldw	r3,-24(fp)
 d0180dc:	e0bfef17 	ldw	r2,-68(fp)
 d0180e0:	1889883a 	add	r4,r3,r2
 d0180e4:	e1bfee17 	ldw	r6,-72(fp)
 d0180e8:	e17ff104 	addi	r5,fp,-60
 d0180ec:	d04be440 	call	d04be44 <memcmp>
 d0180f0:	e0bfed15 	stw	r2,-76(fp)
    if (this_chunk_cmp)
 d0180f4:	e0bfed17 	ldw	r2,-76(fp)
 d0180f8:	1005003a 	cmpeq	r2,r2,zero
 d0180fc:	1000031e 	bne	r2,zero,d01810c <alt_epcs_flash_memcmp+0xc0>
    {
      return this_chunk_cmp;
 d018100:	e0ffed17 	ldw	r3,-76(fp)
 d018104:	e0fffd15 	stw	r3,-12(fp)
 d018108:	00000c06 	br	d01813c <alt_epcs_flash_memcmp+0xf0>
    }

    n -= this_chunk_size;
 d01810c:	e0ffee17 	ldw	r3,-72(fp)
 d018110:	e0bffc17 	ldw	r2,-16(fp)
 d018114:	10c5c83a 	sub	r2,r2,r3
 d018118:	e0bffc15 	stw	r2,-16(fp)
    current_offset += this_chunk_size;
 d01811c:	e0ffef17 	ldw	r3,-68(fp)
 d018120:	e0bfee17 	ldw	r2,-72(fp)
 d018124:	1885883a 	add	r2,r3,r2
 d018128:	e0bfef15 	stw	r2,-68(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
 d01812c:	e0bffc17 	ldw	r2,-16(fp)
 d018130:	1004c03a 	cmpne	r2,r2,zero
 d018134:	103fd11e 	bne	r2,zero,d01807c <alt_epcs_flash_memcmp+0x30>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
 d018138:	e03ffd15 	stw	zero,-12(fp)
 d01813c:	e0bffd17 	ldw	r2,-12(fp)
}
 d018140:	e037883a 	mov	sp,fp
 d018144:	dfc00117 	ldw	ra,4(sp)
 d018148:	df000017 	ldw	fp,0(sp)
 d01814c:	dec00204 	addi	sp,sp,8
 d018150:	f800283a 	ret

0d018154 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
 d018154:	defff204 	addi	sp,sp,-56
 d018158:	dfc00d15 	stw	ra,52(sp)
 d01815c:	df000c15 	stw	fp,48(sp)
 d018160:	df000c04 	addi	fp,sp,48
 d018164:	e13ffa15 	stw	r4,-24(fp)
 d018168:	e17ffb15 	stw	r5,-20(fp)
 d01816c:	e1bffc15 	stw	r6,-16(fp)
 d018170:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 d018174:	e03ff915 	stw	zero,-28(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 d018178:	e03ff815 	stw	zero,-32(fp)
 d01817c:	00008b06 	br	d0183ac <alt_epcs_flash_write+0x258>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 d018180:	e0bff817 	ldw	r2,-32(fp)
 d018184:	e0fffa17 	ldw	r3,-24(fp)
 d018188:	1004913a 	slli	r2,r2,4
 d01818c:	10c5883a 	add	r2,r2,r3
 d018190:	10800d04 	addi	r2,r2,52
 d018194:	10c00017 	ldw	r3,0(r2)
 d018198:	e0bffb17 	ldw	r2,-20(fp)
 d01819c:	10c08016 	blt	r2,r3,d0183a0 <alt_epcs_flash_write+0x24c>
 d0181a0:	e0bff817 	ldw	r2,-32(fp)
 d0181a4:	e0fffa17 	ldw	r3,-24(fp)
 d0181a8:	1004913a 	slli	r2,r2,4
 d0181ac:	10c5883a 	add	r2,r2,r3
 d0181b0:	10800d04 	addi	r2,r2,52
 d0181b4:	11000017 	ldw	r4,0(r2)
 d0181b8:	e0bff817 	ldw	r2,-32(fp)
 d0181bc:	e0fffa17 	ldw	r3,-24(fp)
 d0181c0:	1004913a 	slli	r2,r2,4
 d0181c4:	10c5883a 	add	r2,r2,r3
 d0181c8:	10800e04 	addi	r2,r2,56
 d0181cc:	10800017 	ldw	r2,0(r2)
 d0181d0:	2087883a 	add	r3,r4,r2
 d0181d4:	e0bffb17 	ldw	r2,-20(fp)
 d0181d8:	10c0710e 	bge	r2,r3,d0183a0 <alt_epcs_flash_write+0x24c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
 d0181dc:	e0bff817 	ldw	r2,-32(fp)
 d0181e0:	e0fffa17 	ldw	r3,-24(fp)
 d0181e4:	1004913a 	slli	r2,r2,4
 d0181e8:	10c5883a 	add	r2,r2,r3
 d0181ec:	10800d04 	addi	r2,r2,52
 d0181f0:	10800017 	ldw	r2,0(r2)
 d0181f4:	e0bff515 	stw	r2,-44(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 d0181f8:	e03ff715 	stw	zero,-36(fp)
 d0181fc:	00006006 	br	d018380 <alt_epcs_flash_write+0x22c>
      {
        if ((offset >= current_offset ) &&
 d018200:	e0fffb17 	ldw	r3,-20(fp)
 d018204:	e0bff517 	ldw	r2,-44(fp)
 d018208:	18805116 	blt	r3,r2,d018350 <alt_epcs_flash_write+0x1fc>
 d01820c:	e0bff817 	ldw	r2,-32(fp)
 d018210:	e0fffa17 	ldw	r3,-24(fp)
 d018214:	1004913a 	slli	r2,r2,4
 d018218:	10c5883a 	add	r2,r2,r3
 d01821c:	10801004 	addi	r2,r2,64
 d018220:	10c00017 	ldw	r3,0(r2)
 d018224:	e0bff517 	ldw	r2,-44(fp)
 d018228:	1887883a 	add	r3,r3,r2
 d01822c:	e0bffb17 	ldw	r2,-20(fp)
 d018230:	10c0470e 	bge	r2,r3,d018350 <alt_epcs_flash_write+0x1fc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
 d018234:	e0bff817 	ldw	r2,-32(fp)
 d018238:	e0fffa17 	ldw	r3,-24(fp)
 d01823c:	1004913a 	slli	r2,r2,4
 d018240:	10c5883a 	add	r2,r2,r3
 d018244:	10801004 	addi	r2,r2,64
 d018248:	10c00017 	ldw	r3,0(r2)
 d01824c:	e0bff517 	ldw	r2,-44(fp)
 d018250:	1887883a 	add	r3,r3,r2
 d018254:	e0bffb17 	ldw	r2,-20(fp)
 d018258:	1885c83a 	sub	r2,r3,r2
 d01825c:	e0bff615 	stw	r2,-40(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
 d018260:	e0bff617 	ldw	r2,-40(fp)
 d018264:	e0bfff15 	stw	r2,-4(fp)
 d018268:	e0fffd17 	ldw	r3,-12(fp)
 d01826c:	e0fffe15 	stw	r3,-8(fp)
 d018270:	e0bfff17 	ldw	r2,-4(fp)
 d018274:	e0fffe17 	ldw	r3,-8(fp)
 d018278:	10c0020e 	bge	r2,r3,d018284 <alt_epcs_flash_write+0x130>
 d01827c:	e0bfff17 	ldw	r2,-4(fp)
 d018280:	e0bffe15 	stw	r2,-8(fp)
 d018284:	e0fffe17 	ldw	r3,-8(fp)
 d018288:	e0fff615 	stw	r3,-40(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
 d01828c:	e1fff617 	ldw	r7,-40(fp)
 d018290:	e13ffa17 	ldw	r4,-24(fp)
 d018294:	e17ffc17 	ldw	r5,-16(fp)
 d018298:	e1bffb17 	ldw	r6,-20(fp)
 d01829c:	d01804c0 	call	d01804c <alt_epcs_flash_memcmp>
 d0182a0:	1005003a 	cmpeq	r2,r2,zero
 d0182a4:	1000131e 	bne	r2,zero,d0182f4 <alt_epcs_flash_write+0x1a0>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
 d0182a8:	e0bffa17 	ldw	r2,-24(fp)
 d0182ac:	10800817 	ldw	r2,32(r2)
 d0182b0:	e13ffa17 	ldw	r4,-24(fp)
 d0182b4:	e17ff517 	ldw	r5,-44(fp)
 d0182b8:	103ee83a 	callr	r2
 d0182bc:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 d0182c0:	e0bff917 	ldw	r2,-28(fp)
 d0182c4:	1004c03a 	cmpne	r2,r2,zero
 d0182c8:	10000a1e 	bne	r2,zero,d0182f4 <alt_epcs_flash_write+0x1a0>
            {
              ret_code = (*flash_info->write_block)(
 d0182cc:	e0bffa17 	ldw	r2,-24(fp)
 d0182d0:	10c00917 	ldw	r3,36(r2)
 d0182d4:	e0bff617 	ldw	r2,-40(fp)
 d0182d8:	d8800015 	stw	r2,0(sp)
 d0182dc:	e13ffa17 	ldw	r4,-24(fp)
 d0182e0:	e17ff517 	ldw	r5,-44(fp)
 d0182e4:	e1bffb17 	ldw	r6,-20(fp)
 d0182e8:	e1fffc17 	ldw	r7,-16(fp)
 d0182ec:	183ee83a 	callr	r3
 d0182f0:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
 d0182f4:	e0fffd17 	ldw	r3,-12(fp)
 d0182f8:	e0bff617 	ldw	r2,-40(fp)
 d0182fc:	18802f26 	beq	r3,r2,d0183bc <alt_epcs_flash_write+0x268>
 d018300:	e0bff917 	ldw	r2,-28(fp)
 d018304:	1004c03a 	cmpne	r2,r2,zero
 d018308:	10002c1e 	bne	r2,zero,d0183bc <alt_epcs_flash_write+0x268>
          {
            goto finished;
          }

          length -= data_to_write;
 d01830c:	e0fffd17 	ldw	r3,-12(fp)
 d018310:	e0bff617 	ldw	r2,-40(fp)
 d018314:	1885c83a 	sub	r2,r3,r2
 d018318:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
 d01831c:	e0bff817 	ldw	r2,-32(fp)
 d018320:	e0fffa17 	ldw	r3,-24(fp)
 d018324:	1004913a 	slli	r2,r2,4
 d018328:	10c5883a 	add	r2,r2,r3
 d01832c:	10801004 	addi	r2,r2,64
 d018330:	10c00017 	ldw	r3,0(r2)
 d018334:	e0bff517 	ldw	r2,-44(fp)
 d018338:	1885883a 	add	r2,r3,r2
 d01833c:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 d018340:	e0fffc17 	ldw	r3,-16(fp)
 d018344:	e0bff617 	ldw	r2,-40(fp)
 d018348:	1885883a 	add	r2,r3,r2
 d01834c:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
 d018350:	e0bff817 	ldw	r2,-32(fp)
 d018354:	e0fffa17 	ldw	r3,-24(fp)
 d018358:	1004913a 	slli	r2,r2,4
 d01835c:	10c5883a 	add	r2,r2,r3
 d018360:	10801004 	addi	r2,r2,64
 d018364:	10c00017 	ldw	r3,0(r2)
 d018368:	e0bff517 	ldw	r2,-44(fp)
 d01836c:	10c5883a 	add	r2,r2,r3
 d018370:	e0bff515 	stw	r2,-44(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 d018374:	e0bff717 	ldw	r2,-36(fp)
 d018378:	10800044 	addi	r2,r2,1
 d01837c:	e0bff715 	stw	r2,-36(fp)
 d018380:	e0bff817 	ldw	r2,-32(fp)
 d018384:	e0fffa17 	ldw	r3,-24(fp)
 d018388:	1004913a 	slli	r2,r2,4
 d01838c:	10c5883a 	add	r2,r2,r3
 d018390:	10800f04 	addi	r2,r2,60
 d018394:	10c00017 	ldw	r3,0(r2)
 d018398:	e0bff717 	ldw	r2,-36(fp)
 d01839c:	10ff9816 	blt	r2,r3,d018200 <alt_epcs_flash_write+0xac>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 d0183a0:	e0bff817 	ldw	r2,-32(fp)
 d0183a4:	10800044 	addi	r2,r2,1
 d0183a8:	e0bff815 	stw	r2,-32(fp)
 d0183ac:	e0bffa17 	ldw	r2,-24(fp)
 d0183b0:	10c00c17 	ldw	r3,48(r2)
 d0183b4:	e0bff817 	ldw	r2,-32(fp)
 d0183b8:	10ff7116 	blt	r2,r3,d018180 <alt_epcs_flash_write+0x2c>
      }
    }
  }

finished:
  return ret_code;
 d0183bc:	e0bff917 	ldw	r2,-28(fp)
}
 d0183c0:	e037883a 	mov	sp,fp
 d0183c4:	dfc00117 	ldw	ra,4(sp)
 d0183c8:	df000017 	ldw	fp,0(sp)
 d0183cc:	dec00204 	addi	sp,sp,8
 d0183d0:	f800283a 	ret

0d0183d4 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
 d0183d4:	defffa04 	addi	sp,sp,-24
 d0183d8:	df000515 	stw	fp,20(sp)
 d0183dc:	df000504 	addi	fp,sp,20
 d0183e0:	e13ffd15 	stw	r4,-12(fp)
 d0183e4:	e17ffe15 	stw	r5,-8(fp)
 d0183e8:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 d0183ec:	e03ffc15 	stw	zero,-16(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
 d0183f0:	e0bffd17 	ldw	r2,-12(fp)
 d0183f4:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 d0183f8:	e0bffb17 	ldw	r2,-20(fp)
 d0183fc:	10c00c17 	ldw	r3,48(r2)
 d018400:	e0bfff17 	ldw	r2,-4(fp)
 d018404:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 d018408:	e0bffb17 	ldw	r2,-20(fp)
 d01840c:	10800c17 	ldw	r2,48(r2)
 d018410:	1004c03a 	cmpne	r2,r2,zero
 d018414:	1000031e 	bne	r2,zero,d018424 <alt_epcs_flash_get_info+0x50>
  {
    ret_code = -EIO;
 d018418:	00bffec4 	movi	r2,-5
 d01841c:	e0bffc15 	stw	r2,-16(fp)
 d018420:	00000b06 	br	d018450 <alt_epcs_flash_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 d018424:	e0bffb17 	ldw	r2,-20(fp)
 d018428:	10800c17 	ldw	r2,48(r2)
 d01842c:	10800250 	cmplti	r2,r2,9
 d018430:	1000031e 	bne	r2,zero,d018440 <alt_epcs_flash_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 d018434:	00bffd04 	movi	r2,-12
 d018438:	e0bffc15 	stw	r2,-16(fp)
 d01843c:	00000406 	br	d018450 <alt_epcs_flash_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 d018440:	e0bffb17 	ldw	r2,-20(fp)
 d018444:	10c00d04 	addi	r3,r2,52
 d018448:	e0bffe17 	ldw	r2,-8(fp)
 d01844c:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 d018450:	e0bffc17 	ldw	r2,-16(fp)
}
 d018454:	e037883a 	mov	sp,fp
 d018458:	df000017 	ldw	fp,0(sp)
 d01845c:	dec00104 	addi	sp,sp,4
 d018460:	f800283a 	ret

0d018464 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
 d018464:	defffa04 	addi	sp,sp,-24
 d018468:	dfc00515 	stw	ra,20(sp)
 d01846c:	df000415 	stw	fp,16(sp)
 d018470:	df000404 	addi	fp,sp,16
 d018474:	e13ffe15 	stw	r4,-8(fp)
 d018478:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 d01847c:	e03ffd15 	stw	zero,-12(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 d018480:	e0bffe17 	ldw	r2,-8(fp)
 d018484:	e0bffc15 	stw	r2,-16(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
 d018488:	e13ffe17 	ldw	r4,-8(fp)
 d01848c:	e17fff17 	ldw	r5,-4(fp)
 d018490:	d0184d40 	call	d0184d4 <alt_epcs_test_address>
 d018494:	e0bffd15 	stw	r2,-12(fp)

  if (ret_code >= 0)
 d018498:	e0bffd17 	ldw	r2,-12(fp)
 d01849c:	1004803a 	cmplt	r2,r2,zero
 d0184a0:	1000061e 	bne	r2,zero,d0184bc <alt_epcs_flash_erase_block+0x58>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
 d0184a4:	e0bffc17 	ldw	r2,-16(fp)
 d0184a8:	11002d17 	ldw	r4,180(r2)
 d0184ac:	e17fff17 	ldw	r5,-4(fp)
 d0184b0:	e0bffc17 	ldw	r2,-16(fp)
 d0184b4:	11803117 	ldw	r6,196(r2)
 d0184b8:	d01a3bc0 	call	d01a3bc <epcs_sector_erase>
  }
  return ret_code;
 d0184bc:	e0bffd17 	ldw	r2,-12(fp)
}
 d0184c0:	e037883a 	mov	sp,fp
 d0184c4:	dfc00117 	ldw	ra,4(sp)
 d0184c8:	df000017 	ldw	fp,0(sp)
 d0184cc:	dec00204 	addi	sp,sp,8
 d0184d0:	f800283a 	ret

0d0184d4 <alt_epcs_test_address>:
}


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
 d0184d4:	defff904 	addi	sp,sp,-28
 d0184d8:	df000615 	stw	fp,24(sp)
 d0184dc:	df000604 	addi	fp,sp,24
 d0184e0:	e13ffe15 	stw	r4,-8(fp)
 d0184e4:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 d0184e8:	e03ffd15 	stw	zero,-12(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 d0184ec:	e0bffe17 	ldw	r2,-8(fp)
 d0184f0:	e0bffc15 	stw	r2,-16(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
 d0184f4:	e0bffc17 	ldw	r2,-16(fp)
 d0184f8:	10800c17 	ldw	r2,48(r2)
 d0184fc:	10bfffc4 	addi	r2,r2,-1
 d018500:	e0bffb15 	stw	r2,-20(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
 d018504:	e0bffb17 	ldw	r2,-20(fp)
 d018508:	e0fffc17 	ldw	r3,-16(fp)
 d01850c:	1004913a 	slli	r2,r2,4
 d018510:	10c5883a 	add	r2,r2,r3
 d018514:	10800d04 	addi	r2,r2,52
 d018518:	11000017 	ldw	r4,0(r2)
 d01851c:	e0bffb17 	ldw	r2,-20(fp)
 d018520:	e0fffc17 	ldw	r3,-16(fp)
 d018524:	1004913a 	slli	r2,r2,4
 d018528:	10c5883a 	add	r2,r2,r3
 d01852c:	10800e04 	addi	r2,r2,56
 d018530:	10800017 	ldw	r2,0(r2)
 d018534:	2085883a 	add	r2,r4,r2
 d018538:	10bfffc4 	addi	r2,r2,-1
 d01853c:	e0bffa15 	stw	r2,-24(fp)

  if (offset > last_device_address)
 d018540:	e0ffff17 	ldw	r3,-4(fp)
 d018544:	e0bffa17 	ldw	r2,-24(fp)
 d018548:	10c0022e 	bgeu	r2,r3,d018554 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
 d01854c:	00bffec4 	movi	r2,-5
 d018550:	e0bffd15 	stw	r2,-12(fp)
  }
  return ret_code;
 d018554:	e0bffd17 	ldw	r2,-12(fp)
}
 d018558:	e037883a 	mov	sp,fp
 d01855c:	df000017 	ldw	fp,0(sp)
 d018560:	dec00104 	addi	sp,sp,4
 d018564:	f800283a 	ret

0d018568 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
 d018568:	defff204 	addi	sp,sp,-56
 d01856c:	dfc00d15 	stw	ra,52(sp)
 d018570:	df000c15 	stw	fp,48(sp)
 d018574:	df000c04 	addi	fp,sp,48
 d018578:	e13ffa15 	stw	r4,-24(fp)
 d01857c:	e17ffb15 	stw	r5,-20(fp)
 d018580:	e1bffc15 	stw	r6,-16(fp)
 d018584:	e1fffd15 	stw	r7,-12(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 d018588:	e0bffa17 	ldw	r2,-24(fp)
 d01858c:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
 d018590:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
 d018594:	e13ffa17 	ldw	r4,-24(fp)
 d018598:	e17ffc17 	ldw	r5,-16(fp)
 d01859c:	d0184d40 	call	d0184d4 <alt_epcs_test_address>
 d0185a0:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
 d0185a4:	e0bff917 	ldw	r2,-28(fp)
 d0185a8:	1004803a 	cmplt	r2,r2,zero
 d0185ac:	10002f1e 	bne	r2,zero,d01866c <alt_epcs_flash_write_block+0x104>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 d0185b0:	00002b06 	br	d018660 <alt_epcs_flash_write_block+0xf8>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
 d0185b4:	e0bff817 	ldw	r2,-32(fp)
 d0185b8:	10c03017 	ldw	r3,192(r2)
 d0185bc:	e0bffc17 	ldw	r2,-16(fp)
 d0185c0:	1887883a 	add	r3,r3,r2
 d0185c4:	e0bff817 	ldw	r2,-32(fp)
 d0185c8:	10803017 	ldw	r2,192(r2)
 d0185cc:	0085c83a 	sub	r2,zero,r2
 d0185d0:	1884703a 	and	r2,r3,r2
 d0185d4:	e0bff515 	stw	r2,-44(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
 d0185d8:	e0fff517 	ldw	r3,-44(fp)
 d0185dc:	e0bffc17 	ldw	r2,-16(fp)
 d0185e0:	1885c83a 	sub	r2,r3,r2
 d0185e4:	e0c00217 	ldw	r3,8(fp)
 d0185e8:	e0ffff15 	stw	r3,-4(fp)
 d0185ec:	e0bffe15 	stw	r2,-8(fp)
 d0185f0:	e0bfff17 	ldw	r2,-4(fp)
 d0185f4:	e0fffe17 	ldw	r3,-8(fp)
 d0185f8:	10c0020e 	bge	r2,r3,d018604 <alt_epcs_flash_write_block+0x9c>
 d0185fc:	e0bfff17 	ldw	r2,-4(fp)
 d018600:	e0bffe15 	stw	r2,-8(fp)
 d018604:	e0fffe17 	ldw	r3,-8(fp)
 d018608:	e0fff615 	stw	r3,-40(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
 d01860c:	e0bff817 	ldw	r2,-32(fp)
 d018610:	11002d17 	ldw	r4,180(r2)
 d018614:	e0fffd17 	ldw	r3,-12(fp)
 d018618:	e0bff717 	ldw	r2,-36(fp)
 d01861c:	188d883a 	add	r6,r3,r2
 d018620:	e0bff817 	ldw	r2,-32(fp)
 d018624:	10803117 	ldw	r2,196(r2)
 d018628:	d8800015 	stw	r2,0(sp)
 d01862c:	e17ffc17 	ldw	r5,-16(fp)
 d018630:	e1fff617 	ldw	r7,-40(fp)
 d018634:	d01a7240 	call	d01a724 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
 d018638:	e0c00217 	ldw	r3,8(fp)
 d01863c:	e0bff617 	ldw	r2,-40(fp)
 d018640:	1885c83a 	sub	r2,r3,r2
 d018644:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
 d018648:	e0fff717 	ldw	r3,-36(fp)
 d01864c:	e0bff617 	ldw	r2,-40(fp)
 d018650:	1885883a 	add	r2,r3,r2
 d018654:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
 d018658:	e0bff517 	ldw	r2,-44(fp)
 d01865c:	e0bffc15 	stw	r2,-16(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 d018660:	e0800217 	ldw	r2,8(fp)
 d018664:	1004c03a 	cmpne	r2,r2,zero
 d018668:	103fd21e 	bne	r2,zero,d0185b4 <alt_epcs_flash_write_block+0x4c>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
 d01866c:	e0bff917 	ldw	r2,-28(fp)
}
 d018670:	e037883a 	mov	sp,fp
 d018674:	dfc00117 	ldw	ra,4(sp)
 d018678:	df000017 	ldw	fp,0(sp)
 d01867c:	dec00204 	addi	sp,sp,8
 d018680:	f800283a 	ret

0d018684 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
 d018684:	defff704 	addi	sp,sp,-36
 d018688:	dfc00815 	stw	ra,32(sp)
 d01868c:	df000715 	stw	fp,28(sp)
 d018690:	df000704 	addi	fp,sp,28
 d018694:	e13ffc15 	stw	r4,-16(fp)
 d018698:	e17ffd15 	stw	r5,-12(fp)
 d01869c:	e1bffe15 	stw	r6,-8(fp)
 d0186a0:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 d0186a4:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 d0186a8:	e0bffc17 	ldw	r2,-16(fp)
 d0186ac:	e0bffa15 	stw	r2,-24(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
 d0186b0:	e13ffc17 	ldw	r4,-16(fp)
 d0186b4:	e17ffd17 	ldw	r5,-12(fp)
 d0186b8:	d0184d40 	call	d0184d4 <alt_epcs_test_address>
 d0186bc:	e0bffb15 	stw	r2,-20(fp)

  if (ret_code >= 0)
 d0186c0:	e0bffb17 	ldw	r2,-20(fp)
 d0186c4:	1004803a 	cmplt	r2,r2,zero
 d0186c8:	10000e1e 	bne	r2,zero,d018704 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
 d0186cc:	e0bffa17 	ldw	r2,-24(fp)
 d0186d0:	11002d17 	ldw	r4,180(r2)
 d0186d4:	e1bffe17 	ldw	r6,-8(fp)
 d0186d8:	e0bffa17 	ldw	r2,-24(fp)
 d0186dc:	10803117 	ldw	r2,196(r2)
 d0186e0:	d8800015 	stw	r2,0(sp)
 d0186e4:	e17ffd17 	ldw	r5,-12(fp)
 d0186e8:	e1ffff17 	ldw	r7,-4(fp)
 d0186ec:	d01a5240 	call	d01a524 <epcs_read_buffer>
 d0186f0:	e0bffb15 	stw	r2,-20(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
 d0186f4:	e0fffb17 	ldw	r3,-20(fp)
 d0186f8:	e0bfff17 	ldw	r2,-4(fp)
 d0186fc:	1880011e 	bne	r3,r2,d018704 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
 d018700:	e03ffb15 	stw	zero,-20(fp)
    }
  }
  return ret_code;
 d018704:	e0bffb17 	ldw	r2,-20(fp)
}
 d018708:	e037883a 	mov	sp,fp
 d01870c:	dfc00117 	ldw	ra,4(sp)
 d018710:	df000017 	ldw	fp,0(sp)
 d018714:	dec00204 	addi	sp,sp,8
 d018718:	f800283a 	ret

0d01871c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 d01871c:	defffa04 	addi	sp,sp,-24
 d018720:	dfc00515 	stw	ra,20(sp)
 d018724:	df000415 	stw	fp,16(sp)
 d018728:	df000404 	addi	fp,sp,16
 d01872c:	e13ffd15 	stw	r4,-12(fp)
 d018730:	e17ffe15 	stw	r5,-8(fp)
 d018734:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 d018738:	e0bffd17 	ldw	r2,-12(fp)
 d01873c:	10800017 	ldw	r2,0(r2)
 d018740:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 d018744:	e0bffc17 	ldw	r2,-16(fp)
 d018748:	11000a04 	addi	r4,r2,40
 d01874c:	e0bffd17 	ldw	r2,-12(fp)
 d018750:	11c00217 	ldw	r7,8(r2)
 d018754:	e17ffe17 	ldw	r5,-8(fp)
 d018758:	e1bfff17 	ldw	r6,-4(fp)
 d01875c:	d018edc0 	call	d018edc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 d018760:	e037883a 	mov	sp,fp
 d018764:	dfc00117 	ldw	ra,4(sp)
 d018768:	df000017 	ldw	fp,0(sp)
 d01876c:	dec00204 	addi	sp,sp,8
 d018770:	f800283a 	ret

0d018774 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 d018774:	defffa04 	addi	sp,sp,-24
 d018778:	dfc00515 	stw	ra,20(sp)
 d01877c:	df000415 	stw	fp,16(sp)
 d018780:	df000404 	addi	fp,sp,16
 d018784:	e13ffd15 	stw	r4,-12(fp)
 d018788:	e17ffe15 	stw	r5,-8(fp)
 d01878c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 d018790:	e0bffd17 	ldw	r2,-12(fp)
 d018794:	10800017 	ldw	r2,0(r2)
 d018798:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 d01879c:	e0bffc17 	ldw	r2,-16(fp)
 d0187a0:	11000a04 	addi	r4,r2,40
 d0187a4:	e0bffd17 	ldw	r2,-12(fp)
 d0187a8:	11c00217 	ldw	r7,8(r2)
 d0187ac:	e17ffe17 	ldw	r5,-8(fp)
 d0187b0:	e1bfff17 	ldw	r6,-4(fp)
 d0187b4:	d01919c0 	call	d01919c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 d0187b8:	e037883a 	mov	sp,fp
 d0187bc:	dfc00117 	ldw	ra,4(sp)
 d0187c0:	df000017 	ldw	fp,0(sp)
 d0187c4:	dec00204 	addi	sp,sp,8
 d0187c8:	f800283a 	ret

0d0187cc <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 d0187cc:	defffc04 	addi	sp,sp,-16
 d0187d0:	dfc00315 	stw	ra,12(sp)
 d0187d4:	df000215 	stw	fp,8(sp)
 d0187d8:	df000204 	addi	fp,sp,8
 d0187dc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 d0187e0:	e0bfff17 	ldw	r2,-4(fp)
 d0187e4:	10800017 	ldw	r2,0(r2)
 d0187e8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 d0187ec:	e0bffe17 	ldw	r2,-8(fp)
 d0187f0:	11000a04 	addi	r4,r2,40
 d0187f4:	e0bfff17 	ldw	r2,-4(fp)
 d0187f8:	11400217 	ldw	r5,8(r2)
 d0187fc:	d018d740 	call	d018d74 <altera_avalon_jtag_uart_close>
}
 d018800:	e037883a 	mov	sp,fp
 d018804:	dfc00117 	ldw	ra,4(sp)
 d018808:	df000017 	ldw	fp,0(sp)
 d01880c:	dec00204 	addi	sp,sp,8
 d018810:	f800283a 	ret

0d018814 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 d018814:	defffa04 	addi	sp,sp,-24
 d018818:	dfc00515 	stw	ra,20(sp)
 d01881c:	df000415 	stw	fp,16(sp)
 d018820:	df000404 	addi	fp,sp,16
 d018824:	e13ffd15 	stw	r4,-12(fp)
 d018828:	e17ffe15 	stw	r5,-8(fp)
 d01882c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 d018830:	e0bffd17 	ldw	r2,-12(fp)
 d018834:	10800017 	ldw	r2,0(r2)
 d018838:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 d01883c:	e0bffc17 	ldw	r2,-16(fp)
 d018840:	11000a04 	addi	r4,r2,40
 d018844:	e17ffe17 	ldw	r5,-8(fp)
 d018848:	e1bfff17 	ldw	r6,-4(fp)
 d01884c:	d018de80 	call	d018de8 <altera_avalon_jtag_uart_ioctl>
}
 d018850:	e037883a 	mov	sp,fp
 d018854:	dfc00117 	ldw	ra,4(sp)
 d018858:	df000017 	ldw	fp,0(sp)
 d01885c:	dec00204 	addi	sp,sp,8
 d018860:	f800283a 	ret

0d018864 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 d018864:	defff404 	addi	sp,sp,-48
 d018868:	dfc00b15 	stw	ra,44(sp)
 d01886c:	df000a15 	stw	fp,40(sp)
 d018870:	df000a04 	addi	fp,sp,40
 d018874:	e13ffd15 	stw	r4,-12(fp)
 d018878:	e17ffe15 	stw	r5,-8(fp)
 d01887c:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 d018880:	e0bffd17 	ldw	r2,-12(fp)
 d018884:	10800c04 	addi	r2,r2,48
 d018888:	e0bffb15 	stw	r2,-20(fp)
 d01888c:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 d018890:	e13ffc0b 	ldhu	r4,-16(fp)
 d018894:	e17ffc84 	addi	r5,fp,-14
 d018898:	d00ff8c0 	call	d00ff8c <OSFlagCreate>
 d01889c:	1007883a 	mov	r3,r2
 d0188a0:	e0bffb17 	ldw	r2,-20(fp)
 d0188a4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 d0188a8:	e0bffd17 	ldw	r2,-12(fp)
 d0188ac:	10800a04 	addi	r2,r2,40
 d0188b0:	e0bff915 	stw	r2,-28(fp)
 d0188b4:	00800044 	movi	r2,1
 d0188b8:	e0bffa0d 	sth	r2,-24(fp)
 d0188bc:	e13ffa0b 	ldhu	r4,-24(fp)
 d0188c0:	d0131940 	call	d013194 <OSSemCreate>
 d0188c4:	1007883a 	mov	r3,r2
 d0188c8:	e0bff917 	ldw	r2,-28(fp)
 d0188cc:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 d0188d0:	e0bffd17 	ldw	r2,-12(fp)
 d0188d4:	10800b04 	addi	r2,r2,44
 d0188d8:	e0bff715 	stw	r2,-36(fp)
 d0188dc:	00800044 	movi	r2,1
 d0188e0:	e0bff80d 	sth	r2,-32(fp)
 d0188e4:	e13ff80b 	ldhu	r4,-32(fp)
 d0188e8:	d0131940 	call	d013194 <OSSemCreate>
 d0188ec:	1007883a 	mov	r3,r2
 d0188f0:	e0bff717 	ldw	r2,-36(fp)
 d0188f4:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 d0188f8:	e0fffd17 	ldw	r3,-12(fp)
 d0188fc:	00800044 	movi	r2,1
 d018900:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 d018904:	e0bffd17 	ldw	r2,-12(fp)
 d018908:	10800017 	ldw	r2,0(r2)
 d01890c:	11000104 	addi	r4,r2,4
 d018910:	e0bffd17 	ldw	r2,-12(fp)
 d018914:	10800817 	ldw	r2,32(r2)
 d018918:	1007883a 	mov	r3,r2
 d01891c:	2005883a 	mov	r2,r4
 d018920:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 d018924:	e13ffe17 	ldw	r4,-8(fp)
 d018928:	e17fff17 	ldw	r5,-4(fp)
 d01892c:	d8000015 	stw	zero,0(sp)
 d018930:	018340b4 	movhi	r6,3330
 d018934:	31a26704 	addi	r6,r6,-30308
 d018938:	e1fffd17 	ldw	r7,-12(fp)
 d01893c:	d0354500 	call	d035450 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 d018940:	e0bffd17 	ldw	r2,-12(fp)
 d018944:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 d018948:	e0bffd17 	ldw	r2,-12(fp)
 d01894c:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 d018950:	00834174 	movhi	r2,3333
 d018954:	109b5504 	addi	r2,r2,27988
 d018958:	10800017 	ldw	r2,0(r2)
 d01895c:	100b883a 	mov	r5,r2
 d018960:	018340b4 	movhi	r6,3330
 d018964:	31a31804 	addi	r6,r6,-29600
 d018968:	e1fffd17 	ldw	r7,-12(fp)
 d01896c:	d034e900 	call	d034e90 <alt_alarm_start>
 d018970:	1004403a 	cmpge	r2,r2,zero
 d018974:	1000041e 	bne	r2,zero,d018988 <altera_avalon_jtag_uart_init+0x124>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 d018978:	e0fffd17 	ldw	r3,-12(fp)
 d01897c:	00a00034 	movhi	r2,32768
 d018980:	10bfffc4 	addi	r2,r2,-1
 d018984:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 d018988:	e037883a 	mov	sp,fp
 d01898c:	dfc00117 	ldw	ra,4(sp)
 d018990:	df000017 	ldw	fp,0(sp)
 d018994:	dec00204 	addi	sp,sp,8
 d018998:	f800283a 	ret

0d01899c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 d01899c:	defff204 	addi	sp,sp,-56
 d0189a0:	dfc00d15 	stw	ra,52(sp)
 d0189a4:	df000c15 	stw	fp,48(sp)
 d0189a8:	df000c04 	addi	fp,sp,48
 d0189ac:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 d0189b0:	e0bfff17 	ldw	r2,-4(fp)
 d0189b4:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 d0189b8:	e0bffd17 	ldw	r2,-12(fp)
 d0189bc:	10800017 	ldw	r2,0(r2)
 d0189c0:	e0bffc15 	stw	r2,-16(fp)
 d0189c4:	00000006 	br	d0189c8 <altera_avalon_jtag_uart_irq+0x2c>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 d0189c8:	e0bffc17 	ldw	r2,-16(fp)
 d0189cc:	10800104 	addi	r2,r2,4
 d0189d0:	10800037 	ldwio	r2,0(r2)
 d0189d4:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 d0189d8:	e0bffb17 	ldw	r2,-20(fp)
 d0189dc:	1080c00c 	andi	r2,r2,768
 d0189e0:	1005003a 	cmpeq	r2,r2,zero
 d0189e4:	1000991e 	bne	r2,zero,d018c4c <altera_avalon_jtag_uart_irq+0x2b0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 d0189e8:	e0bffb17 	ldw	r2,-20(fp)
 d0189ec:	1080400c 	andi	r2,r2,256
 d0189f0:	1005003a 	cmpeq	r2,r2,zero
 d0189f4:	1000481e 	bne	r2,zero,d018b18 <altera_avalon_jtag_uart_irq+0x17c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 d0189f8:	00800074 	movhi	r2,1
 d0189fc:	e0bffa15 	stw	r2,-24(fp)
 d018a00:	00000006 	br	d018a04 <altera_avalon_jtag_uart_irq+0x68>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d018a04:	e0bffd17 	ldw	r2,-12(fp)
 d018a08:	10800d17 	ldw	r2,52(r2)
 d018a0c:	10800044 	addi	r2,r2,1
 d018a10:	1081ffcc 	andi	r2,r2,2047
 d018a14:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 d018a18:	e0bffd17 	ldw	r2,-12(fp)
 d018a1c:	10c00e17 	ldw	r3,56(r2)
 d018a20:	e0bff917 	ldw	r2,-28(fp)
 d018a24:	18802826 	beq	r3,r2,d018ac8 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 d018a28:	e0bffc17 	ldw	r2,-16(fp)
 d018a2c:	10800037 	ldwio	r2,0(r2)
 d018a30:	e0bffa15 	stw	r2,-24(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 d018a34:	e0bffa17 	ldw	r2,-24(fp)
 d018a38:	10a0000c 	andi	r2,r2,32768
 d018a3c:	1005003a 	cmpeq	r2,r2,zero
 d018a40:	1000211e 	bne	r2,zero,d018ac8 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 d018a44:	e0bffd17 	ldw	r2,-12(fp)
 d018a48:	10c00d17 	ldw	r3,52(r2)
 d018a4c:	e0bffa17 	ldw	r2,-24(fp)
 d018a50:	1009883a 	mov	r4,r2
 d018a54:	e0bffd17 	ldw	r2,-12(fp)
 d018a58:	1885883a 	add	r2,r3,r2
 d018a5c:	10801104 	addi	r2,r2,68
 d018a60:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d018a64:	e0bffd17 	ldw	r2,-12(fp)
 d018a68:	10800d17 	ldw	r2,52(r2)
 d018a6c:	10800044 	addi	r2,r2,1
 d018a70:	10c1ffcc 	andi	r3,r2,2047
 d018a74:	e0bffd17 	ldw	r2,-12(fp)
 d018a78:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 d018a7c:	e0bffd17 	ldw	r2,-12(fp)
 d018a80:	10800c17 	ldw	r2,48(r2)
 d018a84:	e0bff615 	stw	r2,-40(fp)
 d018a88:	00800044 	movi	r2,1
 d018a8c:	e0bff70d 	sth	r2,-36(fp)
 d018a90:	00800044 	movi	r2,1
 d018a94:	e0bff785 	stb	r2,-34(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 d018a98:	00834174 	movhi	r2,3333
 d018a9c:	109b0944 	addi	r2,r2,27685
 d018aa0:	10800003 	ldbu	r2,0(r2)
 d018aa4:	10803fcc 	andi	r2,r2,255
 d018aa8:	1005003a 	cmpeq	r2,r2,zero
 d018aac:	103fd51e 	bne	r2,zero,d018a04 <altera_avalon_jtag_uart_irq+0x68>
  {
    OSFlagPost (group, flags, opt, &err);
 d018ab0:	e17ff70b 	ldhu	r5,-36(fp)
 d018ab4:	e1bff783 	ldbu	r6,-34(fp)
 d018ab8:	e1fffe04 	addi	r7,fp,-8
 d018abc:	e13ff617 	ldw	r4,-40(fp)
 d018ac0:	d010cb40 	call	d010cb4 <OSFlagPost>
    return err;
 d018ac4:	003fcf06 	br	d018a04 <altera_avalon_jtag_uart_irq+0x68>
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 d018ac8:	e0bffa17 	ldw	r2,-24(fp)
 d018acc:	10bfffec 	andhi	r2,r2,65535
 d018ad0:	1005003a 	cmpeq	r2,r2,zero
 d018ad4:	1000101e 	bne	r2,zero,d018b18 <altera_avalon_jtag_uart_irq+0x17c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 d018ad8:	e0bffd17 	ldw	r2,-12(fp)
 d018adc:	10c00817 	ldw	r3,32(r2)
 d018ae0:	00bfff84 	movi	r2,-2
 d018ae4:	1886703a 	and	r3,r3,r2
 d018ae8:	e0bffd17 	ldw	r2,-12(fp)
 d018aec:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 d018af0:	e0bffc17 	ldw	r2,-16(fp)
 d018af4:	11000104 	addi	r4,r2,4
 d018af8:	e0bffd17 	ldw	r2,-12(fp)
 d018afc:	10800817 	ldw	r2,32(r2)
 d018b00:	1007883a 	mov	r3,r2
 d018b04:	2005883a 	mov	r2,r4
 d018b08:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 d018b0c:	e0bffc17 	ldw	r2,-16(fp)
 d018b10:	10800104 	addi	r2,r2,4
 d018b14:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 d018b18:	e0bffb17 	ldw	r2,-20(fp)
 d018b1c:	1080800c 	andi	r2,r2,512
 d018b20:	1005003a 	cmpeq	r2,r2,zero
 d018b24:	103fa81e 	bne	r2,zero,d0189c8 <altera_avalon_jtag_uart_irq+0x2c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 d018b28:	e0bffb17 	ldw	r2,-20(fp)
 d018b2c:	10bfffec 	andhi	r2,r2,65535
 d018b30:	1004d43a 	srli	r2,r2,16
 d018b34:	e0bff815 	stw	r2,-32(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 d018b38:	00002706 	br	d018bd8 <altera_avalon_jtag_uart_irq+0x23c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 d018b3c:	e13ffc17 	ldw	r4,-16(fp)
 d018b40:	e0bffd17 	ldw	r2,-12(fp)
 d018b44:	10c01017 	ldw	r3,64(r2)
 d018b48:	e0bffd17 	ldw	r2,-12(fp)
 d018b4c:	1885883a 	add	r2,r3,r2
 d018b50:	10821104 	addi	r2,r2,2116
 d018b54:	10800003 	ldbu	r2,0(r2)
 d018b58:	10c03fcc 	andi	r3,r2,255
 d018b5c:	18c0201c 	xori	r3,r3,128
 d018b60:	18ffe004 	addi	r3,r3,-128
 d018b64:	2005883a 	mov	r2,r4
 d018b68:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d018b6c:	e0bffd17 	ldw	r2,-12(fp)
 d018b70:	10801017 	ldw	r2,64(r2)
 d018b74:	10800044 	addi	r2,r2,1
 d018b78:	10c1ffcc 	andi	r3,r2,2047
 d018b7c:	e0bffd17 	ldw	r2,-12(fp)
 d018b80:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 d018b84:	e0bffd17 	ldw	r2,-12(fp)
 d018b88:	10800c17 	ldw	r2,48(r2)
 d018b8c:	e0bff415 	stw	r2,-48(fp)
 d018b90:	00800084 	movi	r2,2
 d018b94:	e0bff50d 	sth	r2,-44(fp)
 d018b98:	00800044 	movi	r2,1
 d018b9c:	e0bff585 	stb	r2,-42(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 d018ba0:	00834174 	movhi	r2,3333
 d018ba4:	109b0944 	addi	r2,r2,27685
 d018ba8:	10800003 	ldbu	r2,0(r2)
 d018bac:	10803fcc 	andi	r2,r2,255
 d018bb0:	1005003a 	cmpeq	r2,r2,zero
 d018bb4:	1000051e 	bne	r2,zero,d018bcc <altera_avalon_jtag_uart_irq+0x230>
  {
    OSFlagPost (group, flags, opt, &err);
 d018bb8:	e17ff50b 	ldhu	r5,-44(fp)
 d018bbc:	e1bff583 	ldbu	r6,-42(fp)
 d018bc0:	e1fffe44 	addi	r7,fp,-7
 d018bc4:	e13ff417 	ldw	r4,-48(fp)
 d018bc8:	d010cb40 	call	d010cb4 <OSFlagPost>

        space--;
 d018bcc:	e0bff817 	ldw	r2,-32(fp)
 d018bd0:	10bfffc4 	addi	r2,r2,-1
 d018bd4:	e0bff815 	stw	r2,-32(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 d018bd8:	e0bff817 	ldw	r2,-32(fp)
 d018bdc:	1005003a 	cmpeq	r2,r2,zero
 d018be0:	1000051e 	bne	r2,zero,d018bf8 <altera_avalon_jtag_uart_irq+0x25c>
 d018be4:	e0bffd17 	ldw	r2,-12(fp)
 d018be8:	10c01017 	ldw	r3,64(r2)
 d018bec:	e0bffd17 	ldw	r2,-12(fp)
 d018bf0:	10800f17 	ldw	r2,60(r2)
 d018bf4:	18bfd11e 	bne	r3,r2,d018b3c <altera_avalon_jtag_uart_irq+0x1a0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 d018bf8:	e0bff817 	ldw	r2,-32(fp)
 d018bfc:	1005003a 	cmpeq	r2,r2,zero
 d018c00:	103f711e 	bne	r2,zero,d0189c8 <altera_avalon_jtag_uart_irq+0x2c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 d018c04:	e0bffd17 	ldw	r2,-12(fp)
 d018c08:	10c00817 	ldw	r3,32(r2)
 d018c0c:	00bfff44 	movi	r2,-3
 d018c10:	1886703a 	and	r3,r3,r2
 d018c14:	e0bffd17 	ldw	r2,-12(fp)
 d018c18:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 d018c1c:	e0bffd17 	ldw	r2,-12(fp)
 d018c20:	10800017 	ldw	r2,0(r2)
 d018c24:	11000104 	addi	r4,r2,4
 d018c28:	e0bffd17 	ldw	r2,-12(fp)
 d018c2c:	10800817 	ldw	r2,32(r2)
 d018c30:	1007883a 	mov	r3,r2
 d018c34:	2005883a 	mov	r2,r4
 d018c38:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 d018c3c:	e0bffc17 	ldw	r2,-16(fp)
 d018c40:	10800104 	addi	r2,r2,4
 d018c44:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 d018c48:	003f5f06 	br	d0189c8 <altera_avalon_jtag_uart_irq+0x2c>
}
 d018c4c:	e037883a 	mov	sp,fp
 d018c50:	dfc00117 	ldw	ra,4(sp)
 d018c54:	df000017 	ldw	fp,0(sp)
 d018c58:	dec00204 	addi	sp,sp,8
 d018c5c:	f800283a 	ret

0d018c60 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 d018c60:	defff804 	addi	sp,sp,-32
 d018c64:	dfc00715 	stw	ra,28(sp)
 d018c68:	df000615 	stw	fp,24(sp)
 d018c6c:	df000604 	addi	fp,sp,24
 d018c70:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 d018c74:	e0bfff17 	ldw	r2,-4(fp)
 d018c78:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 d018c7c:	e0bffd17 	ldw	r2,-12(fp)
 d018c80:	10800017 	ldw	r2,0(r2)
 d018c84:	10800104 	addi	r2,r2,4
 d018c88:	10800037 	ldwio	r2,0(r2)
 d018c8c:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 d018c90:	e0bffc17 	ldw	r2,-16(fp)
 d018c94:	1081000c 	andi	r2,r2,1024
 d018c98:	1005003a 	cmpeq	r2,r2,zero
 d018c9c:	10000c1e 	bne	r2,zero,d018cd0 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 d018ca0:	e0bffd17 	ldw	r2,-12(fp)
 d018ca4:	10800017 	ldw	r2,0(r2)
 d018ca8:	11000104 	addi	r4,r2,4
 d018cac:	e0bffd17 	ldw	r2,-12(fp)
 d018cb0:	10800817 	ldw	r2,32(r2)
 d018cb4:	10810014 	ori	r2,r2,1024
 d018cb8:	1007883a 	mov	r3,r2
 d018cbc:	2005883a 	mov	r2,r4
 d018cc0:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 d018cc4:	e0bffd17 	ldw	r2,-12(fp)
 d018cc8:	10000915 	stw	zero,36(r2)
 d018ccc:	00002106 	br	d018d54 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 d018cd0:	e0bffd17 	ldw	r2,-12(fp)
 d018cd4:	10c00917 	ldw	r3,36(r2)
 d018cd8:	00a00034 	movhi	r2,32768
 d018cdc:	10bfff04 	addi	r2,r2,-4
 d018ce0:	10c01c36 	bltu	r2,r3,d018d54 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
 d018ce4:	e0bffd17 	ldw	r2,-12(fp)
 d018ce8:	10800917 	ldw	r2,36(r2)
 d018cec:	10c00044 	addi	r3,r2,1
 d018cf0:	e0bffd17 	ldw	r2,-12(fp)
 d018cf4:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 d018cf8:	e0bffd17 	ldw	r2,-12(fp)
 d018cfc:	10c00917 	ldw	r3,36(r2)
 d018d00:	e0bffd17 	ldw	r2,-12(fp)
 d018d04:	10800117 	ldw	r2,4(r2)
 d018d08:	18801236 	bltu	r3,r2,d018d54 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 d018d0c:	e0bffd17 	ldw	r2,-12(fp)
 d018d10:	10800c17 	ldw	r2,48(r2)
 d018d14:	e0bffa15 	stw	r2,-24(fp)
 d018d18:	00800104 	movi	r2,4
 d018d1c:	e0bffb0d 	sth	r2,-20(fp)
 d018d20:	00800044 	movi	r2,1
 d018d24:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 d018d28:	00834174 	movhi	r2,3333
 d018d2c:	109b0944 	addi	r2,r2,27685
 d018d30:	10800003 	ldbu	r2,0(r2)
 d018d34:	10803fcc 	andi	r2,r2,255
 d018d38:	1005003a 	cmpeq	r2,r2,zero
 d018d3c:	1000051e 	bne	r2,zero,d018d54 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
 d018d40:	e17ffb0b 	ldhu	r5,-20(fp)
 d018d44:	e1bffb83 	ldbu	r6,-18(fp)
 d018d48:	e1fffe04 	addi	r7,fp,-8
 d018d4c:	e13ffa17 	ldw	r4,-24(fp)
 d018d50:	d010cb40 	call	d010cb4 <OSFlagPost>
 d018d54:	00834174 	movhi	r2,3333
 d018d58:	109b5504 	addi	r2,r2,27988
 d018d5c:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
 d018d60:	e037883a 	mov	sp,fp
 d018d64:	dfc00117 	ldw	ra,4(sp)
 d018d68:	df000017 	ldw	fp,0(sp)
 d018d6c:	dec00204 	addi	sp,sp,8
 d018d70:	f800283a 	ret

0d018d74 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 d018d74:	defffc04 	addi	sp,sp,-16
 d018d78:	df000315 	stw	fp,12(sp)
 d018d7c:	df000304 	addi	fp,sp,12
 d018d80:	e13ffd15 	stw	r4,-12(fp)
 d018d84:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 d018d88:	00000706 	br	d018da8 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 d018d8c:	e0bffe17 	ldw	r2,-8(fp)
 d018d90:	1090000c 	andi	r2,r2,16384
 d018d94:	1005003a 	cmpeq	r2,r2,zero
 d018d98:	1000031e 	bne	r2,zero,d018da8 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 d018d9c:	00bffd44 	movi	r2,-11
 d018da0:	e0bfff15 	stw	r2,-4(fp)
 d018da4:	00000b06 	br	d018dd4 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 d018da8:	e0bffd17 	ldw	r2,-12(fp)
 d018dac:	10c01017 	ldw	r3,64(r2)
 d018db0:	e0bffd17 	ldw	r2,-12(fp)
 d018db4:	10800f17 	ldw	r2,60(r2)
 d018db8:	18800526 	beq	r3,r2,d018dd0 <altera_avalon_jtag_uart_close+0x5c>
 d018dbc:	e0bffd17 	ldw	r2,-12(fp)
 d018dc0:	10c00917 	ldw	r3,36(r2)
 d018dc4:	e0bffd17 	ldw	r2,-12(fp)
 d018dc8:	10800117 	ldw	r2,4(r2)
 d018dcc:	18bfef36 	bltu	r3,r2,d018d8c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 d018dd0:	e03fff15 	stw	zero,-4(fp)
 d018dd4:	e0bfff17 	ldw	r2,-4(fp)
}
 d018dd8:	e037883a 	mov	sp,fp
 d018ddc:	df000017 	ldw	fp,0(sp)
 d018de0:	dec00104 	addi	sp,sp,4
 d018de4:	f800283a 	ret

0d018de8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 d018de8:	defff804 	addi	sp,sp,-32
 d018dec:	df000715 	stw	fp,28(sp)
 d018df0:	df000704 	addi	fp,sp,28
 d018df4:	e13ffb15 	stw	r4,-20(fp)
 d018df8:	e17ffc15 	stw	r5,-16(fp)
 d018dfc:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 d018e00:	00bff9c4 	movi	r2,-25
 d018e04:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 d018e08:	e0bffc17 	ldw	r2,-16(fp)
 d018e0c:	e0bfff15 	stw	r2,-4(fp)
 d018e10:	e0ffff17 	ldw	r3,-4(fp)
 d018e14:	189a8060 	cmpeqi	r2,r3,27137
 d018e18:	1000041e 	bne	r2,zero,d018e2c <altera_avalon_jtag_uart_ioctl+0x44>
 d018e1c:	e0ffff17 	ldw	r3,-4(fp)
 d018e20:	189a80a0 	cmpeqi	r2,r3,27138
 d018e24:	10001b1e 	bne	r2,zero,d018e94 <altera_avalon_jtag_uart_ioctl+0xac>
 d018e28:	00002706 	br	d018ec8 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 d018e2c:	e0bffb17 	ldw	r2,-20(fp)
 d018e30:	10c00117 	ldw	r3,4(r2)
 d018e34:	00a00034 	movhi	r2,32768
 d018e38:	10bfffc4 	addi	r2,r2,-1
 d018e3c:	18802226 	beq	r3,r2,d018ec8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 d018e40:	e0bffd17 	ldw	r2,-12(fp)
 d018e44:	10800017 	ldw	r2,0(r2)
 d018e48:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 d018e4c:	e0bff917 	ldw	r2,-28(fp)
 d018e50:	10800090 	cmplti	r2,r2,2
 d018e54:	1000071e 	bne	r2,zero,d018e74 <altera_avalon_jtag_uart_ioctl+0x8c>
 d018e58:	e0fff917 	ldw	r3,-28(fp)
 d018e5c:	00a00034 	movhi	r2,32768
 d018e60:	10bfffc4 	addi	r2,r2,-1
 d018e64:	18800326 	beq	r3,r2,d018e74 <altera_avalon_jtag_uart_ioctl+0x8c>
 d018e68:	e0bff917 	ldw	r2,-28(fp)
 d018e6c:	e0bffe15 	stw	r2,-8(fp)
 d018e70:	00000306 	br	d018e80 <altera_avalon_jtag_uart_ioctl+0x98>
 d018e74:	00e00034 	movhi	r3,32768
 d018e78:	18ffff84 	addi	r3,r3,-2
 d018e7c:	e0fffe15 	stw	r3,-8(fp)
 d018e80:	e0bffb17 	ldw	r2,-20(fp)
 d018e84:	e0fffe17 	ldw	r3,-8(fp)
 d018e88:	10c00115 	stw	r3,4(r2)
      rc = 0;
 d018e8c:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 d018e90:	00000d06 	br	d018ec8 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 d018e94:	e0bffb17 	ldw	r2,-20(fp)
 d018e98:	10c00117 	ldw	r3,4(r2)
 d018e9c:	00a00034 	movhi	r2,32768
 d018ea0:	10bfffc4 	addi	r2,r2,-1
 d018ea4:	18800826 	beq	r3,r2,d018ec8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 d018ea8:	e13ffd17 	ldw	r4,-12(fp)
 d018eac:	e0bffb17 	ldw	r2,-20(fp)
 d018eb0:	10c00917 	ldw	r3,36(r2)
 d018eb4:	e0bffb17 	ldw	r2,-20(fp)
 d018eb8:	10800117 	ldw	r2,4(r2)
 d018ebc:	1885803a 	cmpltu	r2,r3,r2
 d018ec0:	20800015 	stw	r2,0(r4)
      rc = 0;
 d018ec4:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 d018ec8:	e0bffa17 	ldw	r2,-24(fp)
}
 d018ecc:	e037883a 	mov	sp,fp
 d018ed0:	df000017 	ldw	fp,0(sp)
 d018ed4:	dec00104 	addi	sp,sp,4
 d018ed8:	f800283a 	ret

0d018edc <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 d018edc:	deffeb04 	addi	sp,sp,-84
 d018ee0:	dfc01415 	stw	ra,80(sp)
 d018ee4:	df001315 	stw	fp,76(sp)
 d018ee8:	df001304 	addi	fp,sp,76
 d018eec:	e13ffb15 	stw	r4,-20(fp)
 d018ef0:	e17ffc15 	stw	r5,-16(fp)
 d018ef4:	e1bffd15 	stw	r6,-12(fp)
 d018ef8:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 d018efc:	e0bffc17 	ldw	r2,-16(fp)
 d018f00:	e0bff915 	stw	r2,-28(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 d018f04:	e0bffb17 	ldw	r2,-20(fp)
 d018f08:	10800a17 	ldw	r2,40(r2)
 d018f0c:	e0bff315 	stw	r2,-52(fp)
 d018f10:	e03ff40d 	sth	zero,-48(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 d018f14:	e17ff40b 	ldhu	r5,-48(fp)
 d018f18:	e1bffa44 	addi	r6,fp,-23
 d018f1c:	e13ff317 	ldw	r4,-52(fp)
 d018f20:	d0135480 	call	d013548 <OSSemPend>

  while (space > 0)
 d018f24:	00006406 	br	d0190b8 <altera_avalon_jtag_uart_read+0x1dc>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 d018f28:	e0bffb17 	ldw	r2,-20(fp)
 d018f2c:	10800d17 	ldw	r2,52(r2)
 d018f30:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
 d018f34:	e0bffb17 	ldw	r2,-20(fp)
 d018f38:	10800e17 	ldw	r2,56(r2)
 d018f3c:	e0bff515 	stw	r2,-44(fp)

      if (in >= out)
 d018f40:	e0fff617 	ldw	r3,-40(fp)
 d018f44:	e0bff517 	ldw	r2,-44(fp)
 d018f48:	18800536 	bltu	r3,r2,d018f60 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 d018f4c:	e0bff617 	ldw	r2,-40(fp)
 d018f50:	e0fff517 	ldw	r3,-44(fp)
 d018f54:	10c5c83a 	sub	r2,r2,r3
 d018f58:	e0bff715 	stw	r2,-36(fp)
 d018f5c:	00000406 	br	d018f70 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 d018f60:	00820004 	movi	r2,2048
 d018f64:	e0fff517 	ldw	r3,-44(fp)
 d018f68:	10c5c83a 	sub	r2,r2,r3
 d018f6c:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 d018f70:	e0bff717 	ldw	r2,-36(fp)
 d018f74:	1005003a 	cmpeq	r2,r2,zero
 d018f78:	10001f1e 	bne	r2,zero,d018ff8 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 d018f7c:	e0fffd17 	ldw	r3,-12(fp)
 d018f80:	e0bff717 	ldw	r2,-36(fp)
 d018f84:	1880022e 	bgeu	r3,r2,d018f90 <altera_avalon_jtag_uart_read+0xb4>
        n = space;
 d018f88:	e0bffd17 	ldw	r2,-12(fp)
 d018f8c:	e0bff715 	stw	r2,-36(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 d018f90:	e0bffb17 	ldw	r2,-20(fp)
 d018f94:	10c01104 	addi	r3,r2,68
 d018f98:	e0bff517 	ldw	r2,-44(fp)
 d018f9c:	1887883a 	add	r3,r3,r2
 d018fa0:	e0bff917 	ldw	r2,-28(fp)
 d018fa4:	1009883a 	mov	r4,r2
 d018fa8:	180b883a 	mov	r5,r3
 d018fac:	e1bff717 	ldw	r6,-36(fp)
 d018fb0:	d0026080 	call	d002608 <memcpy>
      ptr   += n;
 d018fb4:	e0fff717 	ldw	r3,-36(fp)
 d018fb8:	e0bff917 	ldw	r2,-28(fp)
 d018fbc:	10c5883a 	add	r2,r2,r3
 d018fc0:	e0bff915 	stw	r2,-28(fp)
      space -= n;
 d018fc4:	e0fffd17 	ldw	r3,-12(fp)
 d018fc8:	e0bff717 	ldw	r2,-36(fp)
 d018fcc:	1885c83a 	sub	r2,r3,r2
 d018fd0:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d018fd4:	e0fff517 	ldw	r3,-44(fp)
 d018fd8:	e0bff717 	ldw	r2,-36(fp)
 d018fdc:	1885883a 	add	r2,r3,r2
 d018fe0:	10c1ffcc 	andi	r3,r2,2047
 d018fe4:	e0bffb17 	ldw	r2,-20(fp)
 d018fe8:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 d018fec:	e0bffd17 	ldw	r2,-12(fp)
 d018ff0:	10800048 	cmpgei	r2,r2,1
 d018ff4:	103fcc1e 	bne	r2,zero,d018f28 <altera_avalon_jtag_uart_read+0x4c>

    /* If we read any data then return it */
    if (ptr != buffer)
 d018ff8:	e0fff917 	ldw	r3,-28(fp)
 d018ffc:	e0bffc17 	ldw	r2,-16(fp)
 d019000:	1880301e 	bne	r3,r2,d0190c4 <altera_avalon_jtag_uart_read+0x1e8>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 d019004:	e0bffe17 	ldw	r2,-8(fp)
 d019008:	1090000c 	andi	r2,r2,16384
 d01900c:	1004c03a 	cmpne	r2,r2,zero
 d019010:	10002c1e 	bne	r2,zero,d0190c4 <altera_avalon_jtag_uart_read+0x1e8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 d019014:	00834174 	movhi	r2,3333
 d019018:	109b0944 	addi	r2,r2,27685
 d01901c:	10800003 	ldbu	r2,0(r2)
 d019020:	10803fcc 	andi	r2,r2,255
 d019024:	10800058 	cmpnei	r2,r2,1
 d019028:	1000161e 	bne	r2,zero,d019084 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 d01902c:	e0bffb17 	ldw	r2,-20(fp)
 d019030:	10800c17 	ldw	r2,48(r2)
 d019034:	e0bff015 	stw	r2,-64(fp)
 d019038:	00800144 	movi	r2,5
 d01903c:	e0bff10d 	sth	r2,-60(fp)
 d019040:	00bfe0c4 	movi	r2,-125
 d019044:	e0bff185 	stb	r2,-58(fp)
 d019048:	e03ff20d 	sth	zero,-56(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 d01904c:	00834174 	movhi	r2,3333
 d019050:	109b0944 	addi	r2,r2,27685
 d019054:	10800003 	ldbu	r2,0(r2)
 d019058:	10803fcc 	andi	r2,r2,255
 d01905c:	1005003a 	cmpeq	r2,r2,zero
 d019060:	1000111e 	bne	r2,zero,d0190a8 <altera_avalon_jtag_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 d019064:	e17ff10b 	ldhu	r5,-60(fp)
 d019068:	e1bff183 	ldbu	r6,-58(fp)
 d01906c:	e1fff20b 	ldhu	r7,-56(fp)
 d019070:	e0bffa04 	addi	r2,fp,-24
 d019074:	d8800015 	stw	r2,0(sp)
 d019078:	e13ff017 	ldw	r4,-64(fp)
 d01907c:	d0106080 	call	d010608 <OSFlagPend>
    return err;
 d019080:	00000906 	br	d0190a8 <altera_avalon_jtag_uart_read+0x1cc>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 d019084:	e0bffb17 	ldw	r2,-20(fp)
 d019088:	10c00d17 	ldw	r3,52(r2)
 d01908c:	e0bff617 	ldw	r2,-40(fp)
 d019090:	1880051e 	bne	r3,r2,d0190a8 <altera_avalon_jtag_uart_read+0x1cc>
 d019094:	e0bffb17 	ldw	r2,-20(fp)
 d019098:	10c00917 	ldw	r3,36(r2)
 d01909c:	e0bffb17 	ldw	r2,-20(fp)
 d0190a0:	10800117 	ldw	r2,4(r2)
 d0190a4:	18bff736 	bltu	r3,r2,d019084 <altera_avalon_jtag_uart_read+0x1a8>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 d0190a8:	e0bffb17 	ldw	r2,-20(fp)
 d0190ac:	10c00d17 	ldw	r3,52(r2)
 d0190b0:	e0bff617 	ldw	r2,-40(fp)
 d0190b4:	18800326 	beq	r3,r2,d0190c4 <altera_avalon_jtag_uart_read+0x1e8>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 d0190b8:	e0bffd17 	ldw	r2,-12(fp)
 d0190bc:	10800048 	cmpgei	r2,r2,1
 d0190c0:	103f991e 	bne	r2,zero,d018f28 <altera_avalon_jtag_uart_read+0x4c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 d0190c4:	e0bffb17 	ldw	r2,-20(fp)
 d0190c8:	11000a17 	ldw	r4,40(r2)
 d0190cc:	d0139400 	call	d013940 <OSSemPost>

  if (ptr != buffer)
 d0190d0:	e0fff917 	ldw	r3,-28(fp)
 d0190d4:	e0bffc17 	ldw	r2,-16(fp)
 d0190d8:	18801926 	beq	r3,r2,d019140 <altera_avalon_jtag_uart_read+0x264>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0190dc:	0005303a 	rdctl	r2,status
 d0190e0:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0190e4:	e0ffef17 	ldw	r3,-68(fp)
 d0190e8:	00bfff84 	movi	r2,-2
 d0190ec:	1884703a 	and	r2,r3,r2
 d0190f0:	1001703a 	wrctl	status,r2
  
  return context;
 d0190f4:	e0bfef17 	ldw	r2,-68(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 d0190f8:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 d0190fc:	e0bffb17 	ldw	r2,-20(fp)
 d019100:	10800817 	ldw	r2,32(r2)
 d019104:	10c00054 	ori	r3,r2,1
 d019108:	e0bffb17 	ldw	r2,-20(fp)
 d01910c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 d019110:	e0bffb17 	ldw	r2,-20(fp)
 d019114:	10800017 	ldw	r2,0(r2)
 d019118:	11000104 	addi	r4,r2,4
 d01911c:	e0bffb17 	ldw	r2,-20(fp)
 d019120:	10800817 	ldw	r2,32(r2)
 d019124:	1007883a 	mov	r3,r2
 d019128:	2005883a 	mov	r2,r4
 d01912c:	10c00035 	stwio	r3,0(r2)
 d019130:	e0bff817 	ldw	r2,-32(fp)
 d019134:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d019138:	e0bfee17 	ldw	r2,-72(fp)
 d01913c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 d019140:	e0fff917 	ldw	r3,-28(fp)
 d019144:	e0bffc17 	ldw	r2,-16(fp)
 d019148:	18800526 	beq	r3,r2,d019160 <altera_avalon_jtag_uart_read+0x284>
    return ptr - buffer;
 d01914c:	e0fff917 	ldw	r3,-28(fp)
 d019150:	e0bffc17 	ldw	r2,-16(fp)
 d019154:	1887c83a 	sub	r3,r3,r2
 d019158:	e0ffff15 	stw	r3,-4(fp)
 d01915c:	00000906 	br	d019184 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 d019160:	e0bffe17 	ldw	r2,-8(fp)
 d019164:	1090000c 	andi	r2,r2,16384
 d019168:	1005003a 	cmpeq	r2,r2,zero
 d01916c:	1000031e 	bne	r2,zero,d01917c <altera_avalon_jtag_uart_read+0x2a0>
    return -EWOULDBLOCK;
 d019170:	00bffd44 	movi	r2,-11
 d019174:	e0bfff15 	stw	r2,-4(fp)
 d019178:	00000206 	br	d019184 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 d01917c:	00bffec4 	movi	r2,-5
 d019180:	e0bfff15 	stw	r2,-4(fp)
 d019184:	e0bfff17 	ldw	r2,-4(fp)
}
 d019188:	e037883a 	mov	sp,fp
 d01918c:	dfc00117 	ldw	ra,4(sp)
 d019190:	df000017 	ldw	fp,0(sp)
 d019194:	dec00204 	addi	sp,sp,8
 d019198:	f800283a 	ret

0d01919c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 d01919c:	deffeb04 	addi	sp,sp,-84
 d0191a0:	dfc01415 	stw	ra,80(sp)
 d0191a4:	df001315 	stw	fp,76(sp)
 d0191a8:	df001304 	addi	fp,sp,76
 d0191ac:	e13ffb15 	stw	r4,-20(fp)
 d0191b0:	e17ffc15 	stw	r5,-16(fp)
 d0191b4:	e1bffd15 	stw	r6,-12(fp)
 d0191b8:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 d0191bc:	e03ff815 	stw	zero,-32(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 d0191c0:	e0bffc17 	ldw	r2,-16(fp)
 d0191c4:	e0bff515 	stw	r2,-44(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 d0191c8:	e0bffb17 	ldw	r2,-20(fp)
 d0191cc:	10800b17 	ldw	r2,44(r2)
 d0191d0:	e0bff315 	stw	r2,-52(fp)
 d0191d4:	e03ff40d 	sth	zero,-48(fp)
 d0191d8:	e17ff40b 	ldhu	r5,-48(fp)
 d0191dc:	e1bffa04 	addi	r6,fp,-24
 d0191e0:	e13ff317 	ldw	r4,-52(fp)
 d0191e4:	d0135480 	call	d013548 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 d0191e8:	00003a06 	br	d0192d4 <altera_avalon_jtag_uart_write+0x138>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 d0191ec:	e0bffb17 	ldw	r2,-20(fp)
 d0191f0:	10800f17 	ldw	r2,60(r2)
 d0191f4:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 d0191f8:	e0bffb17 	ldw	r2,-20(fp)
 d0191fc:	10801017 	ldw	r2,64(r2)
 d019200:	e0bff815 	stw	r2,-32(fp)

      if (in < out)
 d019204:	e0fff917 	ldw	r3,-28(fp)
 d019208:	e0bff817 	ldw	r2,-32(fp)
 d01920c:	1880062e 	bgeu	r3,r2,d019228 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 d019210:	e0fff817 	ldw	r3,-32(fp)
 d019214:	e0bff917 	ldw	r2,-28(fp)
 d019218:	1885c83a 	sub	r2,r3,r2
 d01921c:	10bfffc4 	addi	r2,r2,-1
 d019220:	e0bff715 	stw	r2,-36(fp)
 d019224:	00000c06 	br	d019258 <altera_avalon_jtag_uart_write+0xbc>
      else if (out > 0)
 d019228:	e0bff817 	ldw	r2,-32(fp)
 d01922c:	1005003a 	cmpeq	r2,r2,zero
 d019230:	1000051e 	bne	r2,zero,d019248 <altera_avalon_jtag_uart_write+0xac>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 d019234:	00820004 	movi	r2,2048
 d019238:	e0fff917 	ldw	r3,-28(fp)
 d01923c:	10c5c83a 	sub	r2,r2,r3
 d019240:	e0bff715 	stw	r2,-36(fp)
 d019244:	00000406 	br	d019258 <altera_avalon_jtag_uart_write+0xbc>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 d019248:	0081ffc4 	movi	r2,2047
 d01924c:	e0fff917 	ldw	r3,-28(fp)
 d019250:	10c5c83a 	sub	r2,r2,r3
 d019254:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 d019258:	e0bff717 	ldw	r2,-36(fp)
 d01925c:	1005003a 	cmpeq	r2,r2,zero
 d019260:	10001f1e 	bne	r2,zero,d0192e0 <altera_avalon_jtag_uart_write+0x144>
        break;

      if (n > count)
 d019264:	e0fffd17 	ldw	r3,-12(fp)
 d019268:	e0bff717 	ldw	r2,-36(fp)
 d01926c:	1880022e 	bgeu	r3,r2,d019278 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 d019270:	e0bffd17 	ldw	r2,-12(fp)
 d019274:	e0bff715 	stw	r2,-36(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 d019278:	e0bffb17 	ldw	r2,-20(fp)
 d01927c:	10c21104 	addi	r3,r2,2116
 d019280:	e0bff917 	ldw	r2,-28(fp)
 d019284:	1885883a 	add	r2,r3,r2
 d019288:	e0fffc17 	ldw	r3,-16(fp)
 d01928c:	1009883a 	mov	r4,r2
 d019290:	180b883a 	mov	r5,r3
 d019294:	e1bff717 	ldw	r6,-36(fp)
 d019298:	d0026080 	call	d002608 <memcpy>
      ptr   += n;
 d01929c:	e0fff717 	ldw	r3,-36(fp)
 d0192a0:	e0bffc17 	ldw	r2,-16(fp)
 d0192a4:	10c5883a 	add	r2,r2,r3
 d0192a8:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 d0192ac:	e0fffd17 	ldw	r3,-12(fp)
 d0192b0:	e0bff717 	ldw	r2,-36(fp)
 d0192b4:	1885c83a 	sub	r2,r3,r2
 d0192b8:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d0192bc:	e0fff917 	ldw	r3,-28(fp)
 d0192c0:	e0bff717 	ldw	r2,-36(fp)
 d0192c4:	1885883a 	add	r2,r3,r2
 d0192c8:	10c1ffcc 	andi	r3,r2,2047
 d0192cc:	e0bffb17 	ldw	r2,-20(fp)
 d0192d0:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 d0192d4:	e0bffd17 	ldw	r2,-12(fp)
 d0192d8:	10800048 	cmpgei	r2,r2,1
 d0192dc:	103fc31e 	bne	r2,zero,d0191ec <altera_avalon_jtag_uart_write+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0192e0:	0005303a 	rdctl	r2,status
 d0192e4:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0192e8:	e0fff217 	ldw	r3,-56(fp)
 d0192ec:	00bfff84 	movi	r2,-2
 d0192f0:	1884703a 	and	r2,r3,r2
 d0192f4:	1001703a 	wrctl	status,r2
  
  return context;
 d0192f8:	e0bff217 	ldw	r2,-56(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 d0192fc:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 d019300:	e0bffb17 	ldw	r2,-20(fp)
 d019304:	10800817 	ldw	r2,32(r2)
 d019308:	10c00094 	ori	r3,r2,2
 d01930c:	e0bffb17 	ldw	r2,-20(fp)
 d019310:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 d019314:	e0bffb17 	ldw	r2,-20(fp)
 d019318:	10800017 	ldw	r2,0(r2)
 d01931c:	11000104 	addi	r4,r2,4
 d019320:	e0bffb17 	ldw	r2,-20(fp)
 d019324:	10800817 	ldw	r2,32(r2)
 d019328:	1007883a 	mov	r3,r2
 d01932c:	2005883a 	mov	r2,r4
 d019330:	10c00035 	stwio	r3,0(r2)
 d019334:	e0bff617 	ldw	r2,-40(fp)
 d019338:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01933c:	e0bff117 	ldw	r2,-60(fp)
 d019340:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 d019344:	e0bffd17 	ldw	r2,-12(fp)
 d019348:	10800050 	cmplti	r2,r2,1
 d01934c:	10002d1e 	bne	r2,zero,d019404 <altera_avalon_jtag_uart_write+0x268>
    {
      if (flags & O_NONBLOCK)
 d019350:	e0bffe17 	ldw	r2,-8(fp)
 d019354:	1090000c 	andi	r2,r2,16384
 d019358:	1004c03a 	cmpne	r2,r2,zero
 d01935c:	10002c1e 	bne	r2,zero,d019410 <altera_avalon_jtag_uart_write+0x274>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 d019360:	00834174 	movhi	r2,3333
 d019364:	109b0944 	addi	r2,r2,27685
 d019368:	10800003 	ldbu	r2,0(r2)
 d01936c:	10803fcc 	andi	r2,r2,255
 d019370:	10800058 	cmpnei	r2,r2,1
 d019374:	1000161e 	bne	r2,zero,d0193d0 <altera_avalon_jtag_uart_write+0x234>
         * When running in a multi-threaded mode, we pend on the write event
         * flag set or the timeout flag in the isr. This avoids wasting CPU
         * cycles waiting in this thread, when we could be doing something
         * more profitable elsewhere.
         */
        ALT_FLAG_PEND (sp->events,
 d019378:	e0bffb17 	ldw	r2,-20(fp)
 d01937c:	10800c17 	ldw	r2,48(r2)
 d019380:	e0bfee15 	stw	r2,-72(fp)
 d019384:	00800184 	movi	r2,6
 d019388:	e0bfef0d 	sth	r2,-68(fp)
 d01938c:	00bfe0c4 	movi	r2,-125
 d019390:	e0bfef85 	stb	r2,-66(fp)
 d019394:	e03ff00d 	sth	zero,-64(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 d019398:	00834174 	movhi	r2,3333
 d01939c:	109b0944 	addi	r2,r2,27685
 d0193a0:	10800003 	ldbu	r2,0(r2)
 d0193a4:	10803fcc 	andi	r2,r2,255
 d0193a8:	1005003a 	cmpeq	r2,r2,zero
 d0193ac:	1000111e 	bne	r2,zero,d0193f4 <altera_avalon_jtag_uart_write+0x258>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 d0193b0:	e17fef0b 	ldhu	r5,-68(fp)
 d0193b4:	e1bfef83 	ldbu	r6,-66(fp)
 d0193b8:	e1fff00b 	ldhu	r7,-64(fp)
 d0193bc:	e0bffa44 	addi	r2,fp,-23
 d0193c0:	d8800015 	stw	r2,0(sp)
 d0193c4:	e13fee17 	ldw	r4,-72(fp)
 d0193c8:	d0106080 	call	d010608 <OSFlagPend>
    return err;
 d0193cc:	00000906 	br	d0193f4 <altera_avalon_jtag_uart_write+0x258>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 d0193d0:	e0bffb17 	ldw	r2,-20(fp)
 d0193d4:	10c01017 	ldw	r3,64(r2)
 d0193d8:	e0bff817 	ldw	r2,-32(fp)
 d0193dc:	1880051e 	bne	r3,r2,d0193f4 <altera_avalon_jtag_uart_write+0x258>
 d0193e0:	e0bffb17 	ldw	r2,-20(fp)
 d0193e4:	10c00917 	ldw	r3,36(r2)
 d0193e8:	e0bffb17 	ldw	r2,-20(fp)
 d0193ec:	10800117 	ldw	r2,4(r2)
 d0193f0:	18bff736 	bltu	r3,r2,d0193d0 <altera_avalon_jtag_uart_write+0x234>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 d0193f4:	e0bffb17 	ldw	r2,-20(fp)
 d0193f8:	10c01017 	ldw	r3,64(r2)
 d0193fc:	e0bff817 	ldw	r2,-32(fp)
 d019400:	18800326 	beq	r3,r2,d019410 <altera_avalon_jtag_uart_write+0x274>
        break;
    }
  }
  while (count > 0);
 d019404:	e0bffd17 	ldw	r2,-12(fp)
 d019408:	10800048 	cmpgei	r2,r2,1
 d01940c:	103fb11e 	bne	r2,zero,d0192d4 <altera_avalon_jtag_uart_write+0x138>

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 d019410:	e0bffb17 	ldw	r2,-20(fp)
 d019414:	11000b17 	ldw	r4,44(r2)
 d019418:	d0139400 	call	d013940 <OSSemPost>

  if (ptr != start)
 d01941c:	e0fffc17 	ldw	r3,-16(fp)
 d019420:	e0bff517 	ldw	r2,-44(fp)
 d019424:	18800526 	beq	r3,r2,d01943c <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
 d019428:	e0fffc17 	ldw	r3,-16(fp)
 d01942c:	e0bff517 	ldw	r2,-44(fp)
 d019430:	1887c83a 	sub	r3,r3,r2
 d019434:	e0ffff15 	stw	r3,-4(fp)
 d019438:	00000906 	br	d019460 <altera_avalon_jtag_uart_write+0x2c4>
  else if (flags & O_NONBLOCK)
 d01943c:	e0bffe17 	ldw	r2,-8(fp)
 d019440:	1090000c 	andi	r2,r2,16384
 d019444:	1005003a 	cmpeq	r2,r2,zero
 d019448:	1000031e 	bne	r2,zero,d019458 <altera_avalon_jtag_uart_write+0x2bc>
    return -EWOULDBLOCK;
 d01944c:	00bffd44 	movi	r2,-11
 d019450:	e0bfff15 	stw	r2,-4(fp)
 d019454:	00000206 	br	d019460 <altera_avalon_jtag_uart_write+0x2c4>
  else
    return -EIO; /* Host not connected */
 d019458:	00bffec4 	movi	r2,-5
 d01945c:	e0bfff15 	stw	r2,-4(fp)
 d019460:	e0bfff17 	ldw	r2,-4(fp)
}
 d019464:	e037883a 	mov	sp,fp
 d019468:	dfc00117 	ldw	ra,4(sp)
 d01946c:	df000017 	ldw	fp,0(sp)
 d019470:	dec00204 	addi	sp,sp,8
 d019474:	f800283a 	ret

0d019478 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 d019478:	defffb04 	addi	sp,sp,-20
 d01947c:	df000415 	stw	fp,16(sp)
 d019480:	df000404 	addi	fp,sp,16
 d019484:	e13ffd15 	stw	r4,-12(fp)
 d019488:	e17ffe15 	stw	r5,-8(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 d01948c:	e0bffd17 	ldw	r2,-12(fp)
 d019490:	10800317 	ldw	r2,12(r2)
 d019494:	10800037 	ldwio	r2,0(r2)
 d019498:	1080040c 	andi	r2,r2,16
 d01949c:	1005003a 	cmpeq	r2,r2,zero
 d0194a0:	1000031e 	bne	r2,zero,d0194b0 <alt_avalon_sgdma_do_async_transfer+0x38>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 d0194a4:	00bffc04 	movi	r2,-16
 d0194a8:	e0bfff15 	stw	r2,-4(fp)
 d0194ac:	00003c06 	br	d0195a0 <alt_avalon_sgdma_do_async_transfer+0x128>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d0194b0:	e0bffd17 	ldw	r2,-12(fp)
 d0194b4:	10800317 	ldw	r2,12(r2)
 d0194b8:	11000404 	addi	r4,r2,16
 d0194bc:	e0bffd17 	ldw	r2,-12(fp)
 d0194c0:	10800317 	ldw	r2,12(r2)
 d0194c4:	10800404 	addi	r2,r2,16
 d0194c8:	10c00037 	ldwio	r3,0(r2)
 d0194cc:	00bff7c4 	movi	r2,-33
 d0194d0:	1886703a 	and	r3,r3,r2
 d0194d4:	2005883a 	mov	r2,r4
 d0194d8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d0194dc:	e0bffd17 	ldw	r2,-12(fp)
 d0194e0:	10800317 	ldw	r2,12(r2)
 d0194e4:	1007883a 	mov	r3,r2
 d0194e8:	00803fc4 	movi	r2,255
 d0194ec:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 d0194f0:	e0bffd17 	ldw	r2,-12(fp)
 d0194f4:	10800317 	ldw	r2,12(r2)
 d0194f8:	10800804 	addi	r2,r2,32
 d0194fc:	e0fffe17 	ldw	r3,-8(fp)
 d019500:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 d019504:	e0bffd17 	ldw	r2,-12(fp)
 d019508:	10800917 	ldw	r2,36(r2)
 d01950c:	1005003a 	cmpeq	r2,r2,zero
 d019510:	1000111e 	bne	r2,zero,d019558 <alt_avalon_sgdma_do_async_transfer+0xe0>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019514:	e0bffd17 	ldw	r2,-12(fp)
 d019518:	10800317 	ldw	r2,12(r2)
 d01951c:	10800404 	addi	r2,r2,16
 d019520:	10800037 	ldwio	r2,0(r2)
 d019524:	e0bffc15 	stw	r2,-16(fp)

    control |= (dev->chain_control                          |
 d019528:	e0bffd17 	ldw	r2,-12(fp)
 d01952c:	10c00b17 	ldw	r3,44(r2)
 d019530:	e0bffc17 	ldw	r2,-16(fp)
 d019534:	1884b03a 	or	r2,r3,r2
 d019538:	10801814 	ori	r2,r2,96
 d01953c:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019540:	e0bffd17 	ldw	r2,-12(fp)
 d019544:	10800317 	ldw	r2,12(r2)
 d019548:	10800404 	addi	r2,r2,16
 d01954c:	e0fffc17 	ldw	r3,-16(fp)
 d019550:	10c00035 	stwio	r3,0(r2)
 d019554:	00001106 	br	d01959c <alt_avalon_sgdma_do_async_transfer+0x124>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019558:	e0bffd17 	ldw	r2,-12(fp)
 d01955c:	10800317 	ldw	r2,12(r2)
 d019560:	10800404 	addi	r2,r2,16
 d019564:	10800037 	ldwio	r2,0(r2)
 d019568:	e0bffc15 	stw	r2,-16(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 d01956c:	e0bffc17 	ldw	r2,-16(fp)
 d019570:	10801814 	ori	r2,r2,96
 d019574:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 d019578:	e0fffc17 	ldw	r3,-16(fp)
 d01957c:	00bffbc4 	movi	r2,-17
 d019580:	1884703a 	and	r2,r3,r2
 d019584:	e0bffc15 	stw	r2,-16(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019588:	e0bffd17 	ldw	r2,-12(fp)
 d01958c:	10800317 	ldw	r2,12(r2)
 d019590:	10800404 	addi	r2,r2,16
 d019594:	e0fffc17 	ldw	r3,-16(fp)
 d019598:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 d01959c:	e03fff15 	stw	zero,-4(fp)
 d0195a0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0195a4:	e037883a 	mov	sp,fp
 d0195a8:	df000017 	ldw	fp,0(sp)
 d0195ac:	dec00104 	addi	sp,sp,4
 d0195b0:	f800283a 	ret

0d0195b4 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 d0195b4:	defffc04 	addi	sp,sp,-16
 d0195b8:	df000315 	stw	fp,12(sp)
 d0195bc:	df000304 	addi	fp,sp,12
 d0195c0:	e13ffe15 	stw	r4,-8(fp)
 d0195c4:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 d0195c8:	e0bffe17 	ldw	r2,-8(fp)
 d0195cc:	10800317 	ldw	r2,12(r2)
 d0195d0:	10800037 	ldwio	r2,0(r2)
 d0195d4:	1080040c 	andi	r2,r2,16
 d0195d8:	1004c03a 	cmpne	r2,r2,zero
 d0195dc:	103ffa1e 	bne	r2,zero,d0195c8 <alt_avalon_sgdma_do_sync_transfer+0x14>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d0195e0:	e0bffe17 	ldw	r2,-8(fp)
 d0195e4:	10800317 	ldw	r2,12(r2)
 d0195e8:	11000404 	addi	r4,r2,16
 d0195ec:	e0bffe17 	ldw	r2,-8(fp)
 d0195f0:	10800317 	ldw	r2,12(r2)
 d0195f4:	10800404 	addi	r2,r2,16
 d0195f8:	10c00037 	ldwio	r3,0(r2)
 d0195fc:	00bff7c4 	movi	r2,-33
 d019600:	1886703a 	and	r3,r3,r2
 d019604:	2005883a 	mov	r2,r4
 d019608:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d01960c:	e0bffe17 	ldw	r2,-8(fp)
 d019610:	10800317 	ldw	r2,12(r2)
 d019614:	1007883a 	mov	r3,r2
 d019618:	00803fc4 	movi	r2,255
 d01961c:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 d019620:	e0bffe17 	ldw	r2,-8(fp)
 d019624:	10800317 	ldw	r2,12(r2)
 d019628:	10800804 	addi	r2,r2,32
 d01962c:	e0ffff17 	ldw	r3,-4(fp)
 d019630:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d019634:	e0bffe17 	ldw	r2,-8(fp)
 d019638:	10800317 	ldw	r2,12(r2)
 d01963c:	11000404 	addi	r4,r2,16
 d019640:	e0bffe17 	ldw	r2,-8(fp)
 d019644:	10800317 	ldw	r2,12(r2)
 d019648:	10800404 	addi	r2,r2,16
 d01964c:	10800037 	ldwio	r2,0(r2)
 d019650:	10c01814 	ori	r3,r2,96
 d019654:	2005883a 	mov	r2,r4
 d019658:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 d01965c:	e0bffe17 	ldw	r2,-8(fp)
 d019660:	10800317 	ldw	r2,12(r2)
 d019664:	10800037 	ldwio	r2,0(r2)
 d019668:	1080040c 	andi	r2,r2,16
 d01966c:	1004c03a 	cmpne	r2,r2,zero
 d019670:	103ffa1e 	bne	r2,zero,d01965c <alt_avalon_sgdma_do_sync_transfer+0xa8>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 d019674:	e0bffe17 	ldw	r2,-8(fp)
 d019678:	10800317 	ldw	r2,12(r2)
 d01967c:	11000404 	addi	r4,r2,16
 d019680:	e0bffe17 	ldw	r2,-8(fp)
 d019684:	10800317 	ldw	r2,12(r2)
 d019688:	10800404 	addi	r2,r2,16
 d01968c:	10c00037 	ldwio	r3,0(r2)
 d019690:	00bff7c4 	movi	r2,-33
 d019694:	1886703a 	and	r3,r3,r2
 d019698:	2005883a 	mov	r2,r4
 d01969c:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 d0196a0:	e0bffe17 	ldw	r2,-8(fp)
 d0196a4:	10800317 	ldw	r2,12(r2)
 d0196a8:	10800037 	ldwio	r2,0(r2)
 d0196ac:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d0196b0:	e0bffe17 	ldw	r2,-8(fp)
 d0196b4:	10800317 	ldw	r2,12(r2)
 d0196b8:	1007883a 	mov	r3,r2
 d0196bc:	00803fc4 	movi	r2,255
 d0196c0:	18800035 	stwio	r2,0(r3)

  return status;
 d0196c4:	e0bffd03 	ldbu	r2,-12(fp)
}
 d0196c8:	e037883a 	mov	sp,fp
 d0196cc:	df000017 	ldw	fp,0(sp)
 d0196d0:	dec00104 	addi	sp,sp,4
 d0196d4:	f800283a 	ret

0d0196d8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 d0196d8:	defff404 	addi	sp,sp,-48
 d0196dc:	dfc00b15 	stw	ra,44(sp)
 d0196e0:	df000a15 	stw	fp,40(sp)
 d0196e4:	df000a04 	addi	fp,sp,40
 d0196e8:	e13ffb15 	stw	r4,-20(fp)
 d0196ec:	e17ffc15 	stw	r5,-16(fp)
 d0196f0:	e1bffd15 	stw	r6,-12(fp)
 d0196f4:	e1fffe15 	stw	r7,-8(fp)
 d0196f8:	e0800217 	ldw	r2,8(fp)
 d0196fc:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 d019700:	e0bfff0b 	ldhu	r2,-4(fp)
 d019704:	d8800015 	stw	r2,0(sp)
 d019708:	e0800317 	ldw	r2,12(fp)
 d01970c:	d8800115 	stw	r2,4(sp)
 d019710:	e0800417 	ldw	r2,16(fp)
 d019714:	d8800215 	stw	r2,8(sp)
 d019718:	d8000315 	stw	zero,12(sp)
 d01971c:	d8000415 	stw	zero,16(sp)
 d019720:	e13ffb17 	ldw	r4,-20(fp)
 d019724:	e17ffc17 	ldw	r5,-16(fp)
 d019728:	e1bffd17 	ldw	r6,-12(fp)
 d01972c:	e1fffe17 	ldw	r7,-8(fp)
 d019730:	d0197480 	call	d019748 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 d019734:	e037883a 	mov	sp,fp
 d019738:	dfc00117 	ldw	ra,4(sp)
 d01973c:	df000017 	ldw	fp,0(sp)
 d019740:	dec00204 	addi	sp,sp,8
 d019744:	f800283a 	ret

0d019748 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 d019748:	defff204 	addi	sp,sp,-56
 d01974c:	dfc00d15 	stw	ra,52(sp)
 d019750:	df000c15 	stw	fp,48(sp)
 d019754:	df000c04 	addi	fp,sp,48
 d019758:	e13ffb15 	stw	r4,-20(fp)
 d01975c:	e17ffc15 	stw	r5,-16(fp)
 d019760:	e1bffd15 	stw	r6,-12(fp)
 d019764:	e1fffe15 	stw	r7,-8(fp)
 d019768:	e0800217 	ldw	r2,8(fp)
 d01976c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 d019770:	e0bfff0b 	ldhu	r2,-4(fp)
 d019774:	d8800015 	stw	r2,0(sp)
 d019778:	d8000115 	stw	zero,4(sp)
 d01977c:	e0800317 	ldw	r2,12(fp)
 d019780:	d8800215 	stw	r2,8(sp)
 d019784:	e0800417 	ldw	r2,16(fp)
 d019788:	d8800315 	stw	r2,12(sp)
 d01978c:	e0800517 	ldw	r2,20(fp)
 d019790:	d8800415 	stw	r2,16(sp)
 d019794:	e0800617 	ldw	r2,24(fp)
 d019798:	d8800515 	stw	r2,20(sp)
 d01979c:	d8000615 	stw	zero,24(sp)
 d0197a0:	e13ffb17 	ldw	r4,-20(fp)
 d0197a4:	e17ffc17 	ldw	r5,-16(fp)
 d0197a8:	e1bffd17 	ldw	r6,-12(fp)
 d0197ac:	e1fffe17 	ldw	r7,-8(fp)
 d0197b0:	d019d080 	call	d019d08 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 d0197b4:	e037883a 	mov	sp,fp
 d0197b8:	dfc00117 	ldw	ra,4(sp)
 d0197bc:	df000017 	ldw	fp,0(sp)
 d0197c0:	dec00204 	addi	sp,sp,8
 d0197c4:	f800283a 	ret

0d0197c8 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 d0197c8:	defff804 	addi	sp,sp,-32
 d0197cc:	dfc00715 	stw	ra,28(sp)
 d0197d0:	df000615 	stw	fp,24(sp)
 d0197d4:	df000604 	addi	fp,sp,24
 d0197d8:	e13ffc15 	stw	r4,-16(fp)
 d0197dc:	e17ffd15 	stw	r5,-12(fp)
 d0197e0:	e1bffe15 	stw	r6,-8(fp)
 d0197e4:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 d0197e8:	e1ffff0b 	ldhu	r7,-4(fp)
 d0197ec:	e0800217 	ldw	r2,8(fp)
 d0197f0:	d8800015 	stw	r2,0(sp)
 d0197f4:	d8000115 	stw	zero,4(sp)
 d0197f8:	e13ffc17 	ldw	r4,-16(fp)
 d0197fc:	e17ffd17 	ldw	r5,-12(fp)
 d019800:	e1bffe17 	ldw	r6,-8(fp)
 d019804:	d01981c0 	call	d01981c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 d019808:	e037883a 	mov	sp,fp
 d01980c:	dfc00117 	ldw	ra,4(sp)
 d019810:	df000017 	ldw	fp,0(sp)
 d019814:	dec00204 	addi	sp,sp,8
 d019818:	f800283a 	ret

0d01981c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 d01981c:	defff304 	addi	sp,sp,-52
 d019820:	dfc00c15 	stw	ra,48(sp)
 d019824:	df000b15 	stw	fp,44(sp)
 d019828:	df000b04 	addi	fp,sp,44
 d01982c:	e13ffc15 	stw	r4,-16(fp)
 d019830:	e17ffd15 	stw	r5,-12(fp)
 d019834:	e1bffe15 	stw	r6,-8(fp)
 d019838:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 d01983c:	e0bfff0b 	ldhu	r2,-4(fp)
 d019840:	d8800015 	stw	r2,0(sp)
 d019844:	d8000115 	stw	zero,4(sp)
 d019848:	d8000215 	stw	zero,8(sp)
 d01984c:	e0800217 	ldw	r2,8(fp)
 d019850:	d8800315 	stw	r2,12(sp)
 d019854:	d8000415 	stw	zero,16(sp)
 d019858:	e0800317 	ldw	r2,12(fp)
 d01985c:	d8800515 	stw	r2,20(sp)
 d019860:	d8000615 	stw	zero,24(sp)
 d019864:	e13ffc17 	ldw	r4,-16(fp)
 d019868:	e17ffd17 	ldw	r5,-12(fp)
 d01986c:	000d883a 	mov	r6,zero
 d019870:	e1fffe17 	ldw	r7,-8(fp)
 d019874:	d019d080 	call	d019d08 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 d019878:	e037883a 	mov	sp,fp
 d01987c:	dfc00117 	ldw	ra,4(sp)
 d019880:	df000017 	ldw	fp,0(sp)
 d019884:	dec00204 	addi	sp,sp,8
 d019888:	f800283a 	ret

0d01988c <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 d01988c:	defff404 	addi	sp,sp,-48
 d019890:	dfc00b15 	stw	ra,44(sp)
 d019894:	df000a15 	stw	fp,40(sp)
 d019898:	df000a04 	addi	fp,sp,40
 d01989c:	e13ffb15 	stw	r4,-20(fp)
 d0198a0:	e17ffc15 	stw	r5,-16(fp)
 d0198a4:	e1bffd15 	stw	r6,-12(fp)
 d0198a8:	e0800517 	ldw	r2,20(fp)
 d0198ac:	e1fffe0d 	sth	r7,-8(fp)
 d0198b0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 d0198b4:	e1fffe0b 	ldhu	r7,-8(fp)
 d0198b8:	e0ffff03 	ldbu	r3,-4(fp)
 d0198bc:	e0800217 	ldw	r2,8(fp)
 d0198c0:	d8800015 	stw	r2,0(sp)
 d0198c4:	e0800317 	ldw	r2,12(fp)
 d0198c8:	d8800115 	stw	r2,4(sp)
 d0198cc:	e0800417 	ldw	r2,16(fp)
 d0198d0:	d8800215 	stw	r2,8(sp)
 d0198d4:	d8000315 	stw	zero,12(sp)
 d0198d8:	d8c00415 	stw	r3,16(sp)
 d0198dc:	e13ffb17 	ldw	r4,-20(fp)
 d0198e0:	e17ffc17 	ldw	r5,-16(fp)
 d0198e4:	e1bffd17 	ldw	r6,-12(fp)
 d0198e8:	d0199000 	call	d019900 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 d0198ec:	e037883a 	mov	sp,fp
 d0198f0:	dfc00117 	ldw	ra,4(sp)
 d0198f4:	df000017 	ldw	fp,0(sp)
 d0198f8:	dec00204 	addi	sp,sp,8
 d0198fc:	f800283a 	ret

0d019900 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 d019900:	defff204 	addi	sp,sp,-56
 d019904:	dfc00d15 	stw	ra,52(sp)
 d019908:	df000c15 	stw	fp,48(sp)
 d01990c:	df000c04 	addi	fp,sp,48
 d019910:	e13ffb15 	stw	r4,-20(fp)
 d019914:	e17ffc15 	stw	r5,-16(fp)
 d019918:	e1bffd15 	stw	r6,-12(fp)
 d01991c:	e0800617 	ldw	r2,24(fp)
 d019920:	e1fffe0d 	sth	r7,-8(fp)
 d019924:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 d019928:	e0bffe0b 	ldhu	r2,-8(fp)
 d01992c:	e0ffff03 	ldbu	r3,-4(fp)
 d019930:	d8800015 	stw	r2,0(sp)
 d019934:	e0800417 	ldw	r2,16(fp)
 d019938:	d8800115 	stw	r2,4(sp)
 d01993c:	e0800217 	ldw	r2,8(fp)
 d019940:	d8800215 	stw	r2,8(sp)
 d019944:	e0800317 	ldw	r2,12(fp)
 d019948:	d8800315 	stw	r2,12(sp)
 d01994c:	e0800517 	ldw	r2,20(fp)
 d019950:	d8800415 	stw	r2,16(sp)
 d019954:	d8000515 	stw	zero,20(sp)
 d019958:	d8c00615 	stw	r3,24(sp)
 d01995c:	e13ffb17 	ldw	r4,-20(fp)
 d019960:	e17ffc17 	ldw	r5,-16(fp)
 d019964:	e1bffd17 	ldw	r6,-12(fp)
 d019968:	000f883a 	mov	r7,zero
 d01996c:	d019d080 	call	d019d08 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 d019970:	e037883a 	mov	sp,fp
 d019974:	dfc00117 	ldw	ra,4(sp)
 d019978:	df000017 	ldw	fp,0(sp)
 d01997c:	dec00204 	addi	sp,sp,8
 d019980:	f800283a 	ret

0d019984 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 d019984:	defffb04 	addi	sp,sp,-20
 d019988:	df000415 	stw	fp,16(sp)
 d01998c:	df000404 	addi	fp,sp,16
 d019990:	e13ffc15 	stw	r4,-16(fp)
 d019994:	e17ffd15 	stw	r5,-12(fp)
 d019998:	e1bffe15 	stw	r6,-8(fp)
 d01999c:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 d0199a0:	e0fffc17 	ldw	r3,-16(fp)
 d0199a4:	e0bffd17 	ldw	r2,-12(fp)
 d0199a8:	18800915 	stw	r2,36(r3)
  dev->callback_context = context;
 d0199ac:	e0fffc17 	ldw	r3,-16(fp)
 d0199b0:	e0bfff17 	ldw	r2,-4(fp)
 d0199b4:	18800a15 	stw	r2,40(r3)
  dev->chain_control    = chain_control;
 d0199b8:	e0fffc17 	ldw	r3,-16(fp)
 d0199bc:	e0bffe17 	ldw	r2,-8(fp)
 d0199c0:	18800b15 	stw	r2,44(r3)
}
 d0199c4:	e037883a 	mov	sp,fp
 d0199c8:	df000017 	ldw	fp,0(sp)
 d0199cc:	dec00104 	addi	sp,sp,4
 d0199d0:	f800283a 	ret

0d0199d4 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 d0199d4:	defffd04 	addi	sp,sp,-12
 d0199d8:	df000215 	stw	fp,8(sp)
 d0199dc:	df000204 	addi	fp,sp,8
 d0199e0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d0199e4:	e0bfff17 	ldw	r2,-4(fp)
 d0199e8:	10800317 	ldw	r2,12(r2)
 d0199ec:	10800404 	addi	r2,r2,16
 d0199f0:	10800037 	ldwio	r2,0(r2)
 d0199f4:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 d0199f8:	e0bffe17 	ldw	r2,-8(fp)
 d0199fc:	10800814 	ori	r2,r2,32
 d019a00:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019a04:	e0bfff17 	ldw	r2,-4(fp)
 d019a08:	10800317 	ldw	r2,12(r2)
 d019a0c:	10800404 	addi	r2,r2,16
 d019a10:	e0fffe17 	ldw	r3,-8(fp)
 d019a14:	10c00035 	stwio	r3,0(r2)
}
 d019a18:	e037883a 	mov	sp,fp
 d019a1c:	df000017 	ldw	fp,0(sp)
 d019a20:	dec00104 	addi	sp,sp,4
 d019a24:	f800283a 	ret

0d019a28 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 d019a28:	defffd04 	addi	sp,sp,-12
 d019a2c:	df000215 	stw	fp,8(sp)
 d019a30:	df000204 	addi	fp,sp,8
 d019a34:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019a38:	e0bfff17 	ldw	r2,-4(fp)
 d019a3c:	10800317 	ldw	r2,12(r2)
 d019a40:	10800404 	addi	r2,r2,16
 d019a44:	10800037 	ldwio	r2,0(r2)
 d019a48:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 d019a4c:	e0fffe17 	ldw	r3,-8(fp)
 d019a50:	00bff7c4 	movi	r2,-33
 d019a54:	1884703a 	and	r2,r3,r2
 d019a58:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019a5c:	e0bfff17 	ldw	r2,-4(fp)
 d019a60:	10800317 	ldw	r2,12(r2)
 d019a64:	10800404 	addi	r2,r2,16
 d019a68:	e0fffe17 	ldw	r3,-8(fp)
 d019a6c:	10c00035 	stwio	r3,0(r2)
}
 d019a70:	e037883a 	mov	sp,fp
 d019a74:	df000017 	ldw	fp,0(sp)
 d019a78:	dec00104 	addi	sp,sp,4
 d019a7c:	f800283a 	ret

0d019a80 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 d019a80:	defffd04 	addi	sp,sp,-12
 d019a84:	df000215 	stw	fp,8(sp)
 d019a88:	df000204 	addi	fp,sp,8
 d019a8c:	e13ffe15 	stw	r4,-8(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 d019a90:	e0bffe17 	ldw	r2,-8(fp)
 d019a94:	10800784 	addi	r2,r2,30
 d019a98:	10800023 	ldbuio	r2,0(r2)
 d019a9c:	10801fcc 	andi	r2,r2,127
 d019aa0:	1005003a 	cmpeq	r2,r2,zero
 d019aa4:	1000031e 	bne	r2,zero,d019ab4 <alt_avalon_sgdma_check_descriptor_status+0x34>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 d019aa8:	00bffec4 	movi	r2,-5
 d019aac:	e0bfff15 	stw	r2,-4(fp)
 d019ab0:	00000a06 	br	d019adc <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 d019ab4:	e0bffe17 	ldw	r2,-8(fp)
 d019ab8:	108007c4 	addi	r2,r2,31
 d019abc:	10800023 	ldbuio	r2,0(r2)
 d019ac0:	1080200c 	andi	r2,r2,128
 d019ac4:	1005003a 	cmpeq	r2,r2,zero
 d019ac8:	1000031e 	bne	r2,zero,d019ad8 <alt_avalon_sgdma_check_descriptor_status+0x58>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 d019acc:	00bfe244 	movi	r2,-119
 d019ad0:	e0bfff15 	stw	r2,-4(fp)
 d019ad4:	00000106 	br	d019adc <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

    return 0;
 d019ad8:	e03fff15 	stw	zero,-4(fp)
 d019adc:	e0bfff17 	ldw	r2,-4(fp)
}
 d019ae0:	e037883a 	mov	sp,fp
 d019ae4:	df000017 	ldw	fp,0(sp)
 d019ae8:	dec00104 	addi	sp,sp,4
 d019aec:	f800283a 	ret

0d019af0 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 d019af0:	defffc04 	addi	sp,sp,-16
 d019af4:	dfc00315 	stw	ra,12(sp)
 d019af8:	df000215 	stw	fp,8(sp)
 d019afc:	df000204 	addi	fp,sp,8
 d019b00:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 d019b04:	e13fff17 	ldw	r4,-4(fp)
 d019b08:	d1602a04 	addi	r5,gp,-32600
 d019b0c:	d03538c0 	call	d03538c <alt_find_dev>
 d019b10:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 d019b14:	e0bffe17 	ldw	r2,-8(fp)
 d019b18:	1004c03a 	cmpne	r2,r2,zero
 d019b1c:	1000041e 	bne	r2,zero,d019b30 <alt_avalon_sgdma_open+0x40>
    ALT_ERRNO = ENODEV;
 d019b20:	d019b480 	call	d019b48 <alt_get_errno>
 d019b24:	1007883a 	mov	r3,r2
 d019b28:	008004c4 	movi	r2,19
 d019b2c:	18800015 	stw	r2,0(r3)
  }

  return dev;
 d019b30:	e0bffe17 	ldw	r2,-8(fp)
}
 d019b34:	e037883a 	mov	sp,fp
 d019b38:	dfc00117 	ldw	ra,4(sp)
 d019b3c:	df000017 	ldw	fp,0(sp)
 d019b40:	dec00204 	addi	sp,sp,8
 d019b44:	f800283a 	ret

0d019b48 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d019b48:	defffd04 	addi	sp,sp,-12
 d019b4c:	dfc00215 	stw	ra,8(sp)
 d019b50:	df000115 	stw	fp,4(sp)
 d019b54:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d019b58:	00834174 	movhi	r2,3333
 d019b5c:	10926504 	addi	r2,r2,18836
 d019b60:	10800017 	ldw	r2,0(r2)
 d019b64:	1005003a 	cmpeq	r2,r2,zero
 d019b68:	1000061e 	bne	r2,zero,d019b84 <alt_get_errno+0x3c>
 d019b6c:	00834174 	movhi	r2,3333
 d019b70:	10926504 	addi	r2,r2,18836
 d019b74:	10800017 	ldw	r2,0(r2)
 d019b78:	103ee83a 	callr	r2
 d019b7c:	e0bfff15 	stw	r2,-4(fp)
 d019b80:	00000306 	br	d019b90 <alt_get_errno+0x48>
 d019b84:	00834174 	movhi	r2,3333
 d019b88:	109b0104 	addi	r2,r2,27652
 d019b8c:	e0bfff15 	stw	r2,-4(fp)
 d019b90:	e0bfff17 	ldw	r2,-4(fp)
}
 d019b94:	e037883a 	mov	sp,fp
 d019b98:	dfc00117 	ldw	ra,4(sp)
 d019b9c:	df000017 	ldw	fp,0(sp)
 d019ba0:	dec00204 	addi	sp,sp,8
 d019ba4:	f800283a 	ret

0d019ba8 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 d019ba8:	defff104 	addi	sp,sp,-60
 d019bac:	dfc00e15 	stw	ra,56(sp)
 d019bb0:	df000d15 	stw	fp,52(sp)
 d019bb4:	df000d04 	addi	fp,sp,52
 d019bb8:	e13ffa15 	stw	r4,-24(fp)
 d019bbc:	e17ffb15 	stw	r5,-20(fp)
 d019bc0:	e1bffc15 	stw	r6,-16(fp)
 d019bc4:	e1fffd15 	stw	r7,-12(fp)
 d019bc8:	e0800217 	ldw	r2,8(fp)
 d019bcc:	e0c00617 	ldw	r3,24(fp)
 d019bd0:	e0bffe0d 	sth	r2,-8(fp)
 d019bd4:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 d019bd8:	e0bffe0b 	ldhu	r2,-8(fp)
 d019bdc:	e0ffff03 	ldbu	r3,-4(fp)
 d019be0:	d8800015 	stw	r2,0(sp)
 d019be4:	e0800317 	ldw	r2,12(fp)
 d019be8:	d8800115 	stw	r2,4(sp)
 d019bec:	e0800417 	ldw	r2,16(fp)
 d019bf0:	d8800215 	stw	r2,8(sp)
 d019bf4:	e0800517 	ldw	r2,20(fp)
 d019bf8:	d8800315 	stw	r2,12(sp)
 d019bfc:	d8000415 	stw	zero,16(sp)
 d019c00:	d8000515 	stw	zero,20(sp)
 d019c04:	d8c00615 	stw	r3,24(sp)
 d019c08:	e13ffa17 	ldw	r4,-24(fp)
 d019c0c:	e17ffb17 	ldw	r5,-20(fp)
 d019c10:	e1bffc17 	ldw	r6,-16(fp)
 d019c14:	e1fffd17 	ldw	r7,-12(fp)
 d019c18:	d019d080 	call	d019d08 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 d019c1c:	e037883a 	mov	sp,fp
 d019c20:	dfc00117 	ldw	ra,4(sp)
 d019c24:	df000017 	ldw	fp,0(sp)
 d019c28:	dec00204 	addi	sp,sp,8
 d019c2c:	f800283a 	ret

0d019c30 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 d019c30:	defffc04 	addi	sp,sp,-16
 d019c34:	df000315 	stw	fp,12(sp)
 d019c38:	df000304 	addi	fp,sp,12
 d019c3c:	e13ffe15 	stw	r4,-8(fp)
 d019c40:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019c44:	e0bffe17 	ldw	r2,-8(fp)
 d019c48:	10800317 	ldw	r2,12(r2)
 d019c4c:	10800404 	addi	r2,r2,16
 d019c50:	10800037 	ldwio	r2,0(r2)
 d019c54:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 d019c58:	e0fffd17 	ldw	r3,-12(fp)
 d019c5c:	00a00434 	movhi	r2,32784
 d019c60:	10bfffc4 	addi	r2,r2,-1
 d019c64:	1884703a 	and	r2,r3,r2
 d019c68:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 d019c6c:	e0bfff17 	ldw	r2,-4(fp)
 d019c70:	1004953a 	slli	r2,r2,20
 d019c74:	10dffc2c 	andhi	r3,r2,32752
 d019c78:	e0bffd17 	ldw	r2,-12(fp)
 d019c7c:	1884b03a 	or	r2,r3,r2
 d019c80:	10800134 	orhi	r2,r2,4
 d019c84:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019c88:	e0bffe17 	ldw	r2,-8(fp)
 d019c8c:	10800317 	ldw	r2,12(r2)
 d019c90:	10800404 	addi	r2,r2,16
 d019c94:	e0fffd17 	ldw	r3,-12(fp)
 d019c98:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 d019c9c:	e037883a 	mov	sp,fp
 d019ca0:	df000017 	ldw	fp,0(sp)
 d019ca4:	dec00104 	addi	sp,sp,4
 d019ca8:	f800283a 	ret

0d019cac <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 d019cac:	defffd04 	addi	sp,sp,-12
 d019cb0:	df000215 	stw	fp,8(sp)
 d019cb4:	df000204 	addi	fp,sp,8
 d019cb8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019cbc:	e0bfff17 	ldw	r2,-4(fp)
 d019cc0:	10800317 	ldw	r2,12(r2)
 d019cc4:	10800404 	addi	r2,r2,16
 d019cc8:	10800037 	ldwio	r2,0(r2)
 d019ccc:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 d019cd0:	e0fffe17 	ldw	r3,-8(fp)
 d019cd4:	00bfff34 	movhi	r2,65532
 d019cd8:	10bfffc4 	addi	r2,r2,-1
 d019cdc:	1884703a 	and	r2,r3,r2
 d019ce0:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019ce4:	e0bfff17 	ldw	r2,-4(fp)
 d019ce8:	10800317 	ldw	r2,12(r2)
 d019cec:	10800404 	addi	r2,r2,16
 d019cf0:	e0fffe17 	ldw	r3,-8(fp)
 d019cf4:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 d019cf8:	e037883a 	mov	sp,fp
 d019cfc:	df000017 	ldw	fp,0(sp)
 d019d00:	dec00104 	addi	sp,sp,4
 d019d04:	f800283a 	ret

0d019d08 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 d019d08:	defff204 	addi	sp,sp,-56
 d019d0c:	dfc00d15 	stw	ra,52(sp)
 d019d10:	df000c15 	stw	fp,48(sp)
 d019d14:	df000c04 	addi	fp,sp,48
 d019d18:	e13ff415 	stw	r4,-48(fp)
 d019d1c:	e17ff515 	stw	r5,-44(fp)
 d019d20:	e1bff615 	stw	r6,-40(fp)
 d019d24:	e1fff715 	stw	r7,-36(fp)
 d019d28:	e0800217 	ldw	r2,8(fp)
 d019d2c:	e0c00817 	ldw	r3,32(fp)
 d019d30:	e0bff80d 	sth	r2,-32(fp)
 d019d34:	e0fff905 	stb	r3,-28(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 d019d38:	e0bff517 	ldw	r2,-44(fp)
 d019d3c:	110007c4 	addi	r4,r2,31
 d019d40:	e0bff517 	ldw	r2,-44(fp)
 d019d44:	108007c3 	ldbu	r2,31(r2)
 d019d48:	10c03fcc 	andi	r3,r2,255
 d019d4c:	00bfdfc4 	movi	r2,-129
 d019d50:	1886703a 	and	r3,r3,r2
 d019d54:	2005883a 	mov	r2,r4
 d019d58:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 d019d5c:	e13ff417 	ldw	r4,-48(fp)
 d019d60:	e0bff617 	ldw	r2,-40(fp)
 d019d64:	11403fcc 	andi	r5,r2,255
 d019d68:	20800003 	ldbu	r2,0(r4)
 d019d6c:	1004703a 	and	r2,r2,zero
 d019d70:	1007883a 	mov	r3,r2
 d019d74:	2805883a 	mov	r2,r5
 d019d78:	1884b03a 	or	r2,r3,r2
 d019d7c:	20800005 	stb	r2,0(r4)
 d019d80:	e0bff617 	ldw	r2,-40(fp)
 d019d84:	1004d23a 	srli	r2,r2,8
 d019d88:	11403fcc 	andi	r5,r2,255
 d019d8c:	20800043 	ldbu	r2,1(r4)
 d019d90:	1004703a 	and	r2,r2,zero
 d019d94:	1007883a 	mov	r3,r2
 d019d98:	2805883a 	mov	r2,r5
 d019d9c:	1884b03a 	or	r2,r3,r2
 d019da0:	20800045 	stb	r2,1(r4)
 d019da4:	e0bff617 	ldw	r2,-40(fp)
 d019da8:	1004d43a 	srli	r2,r2,16
 d019dac:	11403fcc 	andi	r5,r2,255
 d019db0:	20800083 	ldbu	r2,2(r4)
 d019db4:	1004703a 	and	r2,r2,zero
 d019db8:	1007883a 	mov	r3,r2
 d019dbc:	2805883a 	mov	r2,r5
 d019dc0:	1884b03a 	or	r2,r3,r2
 d019dc4:	20800085 	stb	r2,2(r4)
 d019dc8:	e0bff617 	ldw	r2,-40(fp)
 d019dcc:	100ad63a 	srli	r5,r2,24
 d019dd0:	208000c3 	ldbu	r2,3(r4)
 d019dd4:	1004703a 	and	r2,r2,zero
 d019dd8:	1007883a 	mov	r3,r2
 d019ddc:	2805883a 	mov	r2,r5
 d019de0:	1884b03a 	or	r2,r3,r2
 d019de4:	208000c5 	stb	r2,3(r4)
  desc->write_addr               = write_addr;
 d019de8:	e13ff417 	ldw	r4,-48(fp)
 d019dec:	e0bff717 	ldw	r2,-36(fp)
 d019df0:	11403fcc 	andi	r5,r2,255
 d019df4:	20800203 	ldbu	r2,8(r4)
 d019df8:	1004703a 	and	r2,r2,zero
 d019dfc:	1007883a 	mov	r3,r2
 d019e00:	2805883a 	mov	r2,r5
 d019e04:	1884b03a 	or	r2,r3,r2
 d019e08:	20800205 	stb	r2,8(r4)
 d019e0c:	e0bff717 	ldw	r2,-36(fp)
 d019e10:	1004d23a 	srli	r2,r2,8
 d019e14:	11403fcc 	andi	r5,r2,255
 d019e18:	20800243 	ldbu	r2,9(r4)
 d019e1c:	1004703a 	and	r2,r2,zero
 d019e20:	1007883a 	mov	r3,r2
 d019e24:	2805883a 	mov	r2,r5
 d019e28:	1884b03a 	or	r2,r3,r2
 d019e2c:	20800245 	stb	r2,9(r4)
 d019e30:	e0bff717 	ldw	r2,-36(fp)
 d019e34:	1004d43a 	srli	r2,r2,16
 d019e38:	11403fcc 	andi	r5,r2,255
 d019e3c:	20800283 	ldbu	r2,10(r4)
 d019e40:	1004703a 	and	r2,r2,zero
 d019e44:	1007883a 	mov	r3,r2
 d019e48:	2805883a 	mov	r2,r5
 d019e4c:	1884b03a 	or	r2,r3,r2
 d019e50:	20800285 	stb	r2,10(r4)
 d019e54:	e0bff717 	ldw	r2,-36(fp)
 d019e58:	100ad63a 	srli	r5,r2,24
 d019e5c:	208002c3 	ldbu	r2,11(r4)
 d019e60:	1004703a 	and	r2,r2,zero
 d019e64:	1007883a 	mov	r3,r2
 d019e68:	2805883a 	mov	r2,r5
 d019e6c:	1884b03a 	or	r2,r3,r2
 d019e70:	208002c5 	stb	r2,11(r4)
  desc->next                     = (alt_u32 *) next;
 d019e74:	e1bff517 	ldw	r6,-44(fp)
 d019e78:	e13ff417 	ldw	r4,-48(fp)
 d019e7c:	31403fcc 	andi	r5,r6,255
 d019e80:	20800403 	ldbu	r2,16(r4)
 d019e84:	1004703a 	and	r2,r2,zero
 d019e88:	1007883a 	mov	r3,r2
 d019e8c:	2805883a 	mov	r2,r5
 d019e90:	1884b03a 	or	r2,r3,r2
 d019e94:	20800405 	stb	r2,16(r4)
 d019e98:	3004d23a 	srli	r2,r6,8
 d019e9c:	11403fcc 	andi	r5,r2,255
 d019ea0:	20800443 	ldbu	r2,17(r4)
 d019ea4:	1004703a 	and	r2,r2,zero
 d019ea8:	1007883a 	mov	r3,r2
 d019eac:	2805883a 	mov	r2,r5
 d019eb0:	1884b03a 	or	r2,r3,r2
 d019eb4:	20800445 	stb	r2,17(r4)
 d019eb8:	3004d43a 	srli	r2,r6,16
 d019ebc:	11403fcc 	andi	r5,r2,255
 d019ec0:	20800483 	ldbu	r2,18(r4)
 d019ec4:	1004703a 	and	r2,r2,zero
 d019ec8:	1007883a 	mov	r3,r2
 d019ecc:	2805883a 	mov	r2,r5
 d019ed0:	1884b03a 	or	r2,r3,r2
 d019ed4:	20800485 	stb	r2,18(r4)
 d019ed8:	300ad63a 	srli	r5,r6,24
 d019edc:	208004c3 	ldbu	r2,19(r4)
 d019ee0:	1004703a 	and	r2,r2,zero
 d019ee4:	1007883a 	mov	r3,r2
 d019ee8:	2805883a 	mov	r2,r5
 d019eec:	1884b03a 	or	r2,r3,r2
 d019ef0:	208004c5 	stb	r2,19(r4)
  desc->read_addr_pad            = 0x0;
 d019ef4:	e0fff417 	ldw	r3,-48(fp)
 d019ef8:	18800103 	ldbu	r2,4(r3)
 d019efc:	1004703a 	and	r2,r2,zero
 d019f00:	18800105 	stb	r2,4(r3)
 d019f04:	18800143 	ldbu	r2,5(r3)
 d019f08:	1004703a 	and	r2,r2,zero
 d019f0c:	18800145 	stb	r2,5(r3)
 d019f10:	18800183 	ldbu	r2,6(r3)
 d019f14:	1004703a 	and	r2,r2,zero
 d019f18:	18800185 	stb	r2,6(r3)
 d019f1c:	188001c3 	ldbu	r2,7(r3)
 d019f20:	1004703a 	and	r2,r2,zero
 d019f24:	188001c5 	stb	r2,7(r3)
  desc->write_addr_pad           = 0x0;
 d019f28:	e0fff417 	ldw	r3,-48(fp)
 d019f2c:	18800303 	ldbu	r2,12(r3)
 d019f30:	1004703a 	and	r2,r2,zero
 d019f34:	18800305 	stb	r2,12(r3)
 d019f38:	18800343 	ldbu	r2,13(r3)
 d019f3c:	1004703a 	and	r2,r2,zero
 d019f40:	18800345 	stb	r2,13(r3)
 d019f44:	18800383 	ldbu	r2,14(r3)
 d019f48:	1004703a 	and	r2,r2,zero
 d019f4c:	18800385 	stb	r2,14(r3)
 d019f50:	188003c3 	ldbu	r2,15(r3)
 d019f54:	1004703a 	and	r2,r2,zero
 d019f58:	188003c5 	stb	r2,15(r3)
  desc->next_pad                 = 0x0;
 d019f5c:	e0fff417 	ldw	r3,-48(fp)
 d019f60:	18800503 	ldbu	r2,20(r3)
 d019f64:	1004703a 	and	r2,r2,zero
 d019f68:	18800505 	stb	r2,20(r3)
 d019f6c:	18800543 	ldbu	r2,21(r3)
 d019f70:	1004703a 	and	r2,r2,zero
 d019f74:	18800545 	stb	r2,21(r3)
 d019f78:	18800583 	ldbu	r2,22(r3)
 d019f7c:	1004703a 	and	r2,r2,zero
 d019f80:	18800585 	stb	r2,22(r3)
 d019f84:	188005c3 	ldbu	r2,23(r3)
 d019f88:	1004703a 	and	r2,r2,zero
 d019f8c:	188005c5 	stb	r2,23(r3)
  desc->bytes_to_transfer        = length_or_eop;
 d019f90:	e13ff417 	ldw	r4,-48(fp)
 d019f94:	e0bff80b 	ldhu	r2,-32(fp)
 d019f98:	11403fcc 	andi	r5,r2,255
 d019f9c:	20800603 	ldbu	r2,24(r4)
 d019fa0:	1004703a 	and	r2,r2,zero
 d019fa4:	1007883a 	mov	r3,r2
 d019fa8:	2805883a 	mov	r2,r5
 d019fac:	1884b03a 	or	r2,r3,r2
 d019fb0:	20800605 	stb	r2,24(r4)
 d019fb4:	e0bff80b 	ldhu	r2,-32(fp)
 d019fb8:	1004d23a 	srli	r2,r2,8
 d019fbc:	117fffcc 	andi	r5,r2,65535
 d019fc0:	20800643 	ldbu	r2,25(r4)
 d019fc4:	1004703a 	and	r2,r2,zero
 d019fc8:	1007883a 	mov	r3,r2
 d019fcc:	2805883a 	mov	r2,r5
 d019fd0:	1884b03a 	or	r2,r3,r2
 d019fd4:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
 d019fd8:	e0fff417 	ldw	r3,-48(fp)
 d019fdc:	18800703 	ldbu	r2,28(r3)
 d019fe0:	1004703a 	and	r2,r2,zero
 d019fe4:	18800705 	stb	r2,28(r3)
 d019fe8:	18800743 	ldbu	r2,29(r3)
 d019fec:	1004703a 	and	r2,r2,zero
 d019ff0:	18800745 	stb	r2,29(r3)
  desc->status                   = 0x0;
 d019ff4:	e0bff417 	ldw	r2,-48(fp)
 d019ff8:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 d019ffc:	e0800617 	ldw	r2,24(fp)
 d01a000:	1007883a 	mov	r3,r2
 d01a004:	e0bff417 	ldw	r2,-48(fp)
 d01a008:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 d01a00c:	e0800717 	ldw	r2,28(fp)
 d01a010:	1007883a 	mov	r3,r2
 d01a014:	e0bff417 	ldw	r2,-48(fp)
 d01a018:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 d01a01c:	e0800317 	ldw	r2,12(fp)
 d01a020:	1005003a 	cmpeq	r2,r2,zero
 d01a024:	1000031e 	bne	r2,zero,d01a034 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 d01a028:	00bfe044 	movi	r2,-127
 d01a02c:	e0bfff05 	stb	r2,-4(fp)
 d01a030:	00000206 	br	d01a03c <alt_avalon_sgdma_construct_descriptor_burst+0x334>
 d01a034:	00bfe004 	movi	r2,-128
 d01a038:	e0bfff05 	stb	r2,-4(fp)
 d01a03c:	e0800417 	ldw	r2,16(fp)
 d01a040:	1005003a 	cmpeq	r2,r2,zero
 d01a044:	1000031e 	bne	r2,zero,d01a054 <alt_avalon_sgdma_construct_descriptor_burst+0x34c>
 d01a048:	00800084 	movi	r2,2
 d01a04c:	e0bffe05 	stb	r2,-8(fp)
 d01a050:	00000106 	br	d01a058 <alt_avalon_sgdma_construct_descriptor_burst+0x350>
 d01a054:	e03ffe05 	stb	zero,-8(fp)
 d01a058:	e0ffff03 	ldbu	r3,-4(fp)
 d01a05c:	e13ffe03 	ldbu	r4,-8(fp)
 d01a060:	1904b03a 	or	r2,r3,r4
 d01a064:	e0bffd05 	stb	r2,-12(fp)
 d01a068:	e0800517 	ldw	r2,20(fp)
 d01a06c:	1005003a 	cmpeq	r2,r2,zero
 d01a070:	1000031e 	bne	r2,zero,d01a080 <alt_avalon_sgdma_construct_descriptor_burst+0x378>
 d01a074:	00800104 	movi	r2,4
 d01a078:	e0bffc05 	stb	r2,-16(fp)
 d01a07c:	00000106 	br	d01a084 <alt_avalon_sgdma_construct_descriptor_burst+0x37c>
 d01a080:	e03ffc05 	stb	zero,-16(fp)
 d01a084:	e0fffd03 	ldbu	r3,-12(fp)
 d01a088:	e13ffc03 	ldbu	r4,-16(fp)
 d01a08c:	1904b03a 	or	r2,r3,r4
 d01a090:	e0bffb05 	stb	r2,-20(fp)
 d01a094:	e0bff903 	ldbu	r2,-28(fp)
 d01a098:	1005003a 	cmpeq	r2,r2,zero
 d01a09c:	1000051e 	bne	r2,zero,d01a0b4 <alt_avalon_sgdma_construct_descriptor_burst+0x3ac>
 d01a0a0:	e0bff903 	ldbu	r2,-28(fp)
 d01a0a4:	108003cc 	andi	r2,r2,15
 d01a0a8:	100490fa 	slli	r2,r2,3
 d01a0ac:	e0bffa05 	stb	r2,-24(fp)
 d01a0b0:	00000106 	br	d01a0b8 <alt_avalon_sgdma_construct_descriptor_burst+0x3b0>
 d01a0b4:	e03ffa05 	stb	zero,-24(fp)
 d01a0b8:	e0fffb03 	ldbu	r3,-20(fp)
 d01a0bc:	e13ffa03 	ldbu	r4,-24(fp)
 d01a0c0:	1904b03a 	or	r2,r3,r4
 d01a0c4:	1007883a 	mov	r3,r2
 d01a0c8:	e0bff417 	ldw	r2,-48(fp)
 d01a0cc:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
 d01a0d0:	e13ff417 	ldw	r4,-48(fp)
 d01a0d4:	01400804 	movi	r5,32
 d01a0d8:	d035d840 	call	d035d84 <alt_remap_uncached>
}
 d01a0dc:	e037883a 	mov	sp,fp
 d01a0e0:	dfc00117 	ldw	ra,4(sp)
 d01a0e4:	df000017 	ldw	fp,0(sp)
 d01a0e8:	dec00204 	addi	sp,sp,8
 d01a0ec:	f800283a 	ret

0d01a0f0 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 d01a0f0:	defff904 	addi	sp,sp,-28
 d01a0f4:	dfc00615 	stw	ra,24(sp)
 d01a0f8:	df000515 	stw	fp,20(sp)
 d01a0fc:	df000504 	addi	fp,sp,20
 d01a100:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 d01a104:	e0bfff17 	ldw	r2,-4(fp)
 d01a108:	e0bffe15 	stw	r2,-8(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 d01a10c:	e0bffe17 	ldw	r2,-8(fp)
 d01a110:	10800317 	ldw	r2,12(r2)
 d01a114:	11000404 	addi	r4,r2,16
 d01a118:	e0bffe17 	ldw	r2,-8(fp)
 d01a11c:	10800317 	ldw	r2,12(r2)
 d01a120:	10800404 	addi	r2,r2,16
 d01a124:	10800037 	ldwio	r2,0(r2)
 d01a128:	10a00034 	orhi	r2,r2,32768
 d01a12c:	1007883a 	mov	r3,r2
 d01a130:	2005883a 	mov	r2,r4
 d01a134:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d01a138:	e0bffe17 	ldw	r2,-8(fp)
 d01a13c:	10800317 	ldw	r2,12(r2)
 d01a140:	10800404 	addi	r2,r2,16
 d01a144:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 d01a148:	e0bffe17 	ldw	r2,-8(fp)
 d01a14c:	10800917 	ldw	r2,36(r2)
 d01a150:	1005003a 	cmpeq	r2,r2,zero
 d01a154:	1000111e 	bne	r2,zero,d01a19c <alt_avalon_sgdma_irq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01a158:	0005303a 	rdctl	r2,status
 d01a15c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01a160:	e0fffc17 	ldw	r3,-16(fp)
 d01a164:	00bfff84 	movi	r2,-2
 d01a168:	1884703a 	and	r2,r3,r2
 d01a16c:	1001703a 	wrctl	status,r2
  
  return context;
 d01a170:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
 d01a174:	e0bffd15 	stw	r2,-12(fp)
    (dev->callback)(dev->callback_context);
 d01a178:	e0bffe17 	ldw	r2,-8(fp)
 d01a17c:	10c00917 	ldw	r3,36(r2)
 d01a180:	e0bffe17 	ldw	r2,-8(fp)
 d01a184:	11000a17 	ldw	r4,40(r2)
 d01a188:	183ee83a 	callr	r3
 d01a18c:	e0bffd17 	ldw	r2,-12(fp)
 d01a190:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01a194:	e0bffb17 	ldw	r2,-20(fp)
 d01a198:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 d01a19c:	e037883a 	mov	sp,fp
 d01a1a0:	dfc00117 	ldw	ra,4(sp)
 d01a1a4:	df000017 	ldw	fp,0(sp)
 d01a1a8:	dec00204 	addi	sp,sp,8
 d01a1ac:	f800283a 	ret

0d01a1b0 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 d01a1b0:	defffa04 	addi	sp,sp,-24
 d01a1b4:	dfc00515 	stw	ra,20(sp)
 d01a1b8:	df000415 	stw	fp,16(sp)
 d01a1bc:	df000404 	addi	fp,sp,16
 d01a1c0:	e13ffd15 	stw	r4,-12(fp)
 d01a1c4:	e17ffe15 	stw	r5,-8(fp)
 d01a1c8:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d01a1cc:	e0bffd17 	ldw	r2,-12(fp)
 d01a1d0:	10800317 	ldw	r2,12(r2)
 d01a1d4:	10800404 	addi	r2,r2,16
 d01a1d8:	1007883a 	mov	r3,r2
 d01a1dc:	00800074 	movhi	r2,1
 d01a1e0:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d01a1e4:	e0bffd17 	ldw	r2,-12(fp)
 d01a1e8:	10800317 	ldw	r2,12(r2)
 d01a1ec:	10800404 	addi	r2,r2,16
 d01a1f0:	1007883a 	mov	r3,r2
 d01a1f4:	00800074 	movhi	r2,1
 d01a1f8:	18800035 	stwio	r2,0(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 d01a1fc:	e0bffd17 	ldw	r2,-12(fp)
 d01a200:	10800317 	ldw	r2,12(r2)
 d01a204:	10800404 	addi	r2,r2,16
 d01a208:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d01a20c:	e0bffd17 	ldw	r2,-12(fp)
 d01a210:	10800317 	ldw	r2,12(r2)
 d01a214:	1007883a 	mov	r3,r2
 d01a218:	00803fc4 	movi	r2,255
 d01a21c:	18800035 	stwio	r2,0(r3)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 d01a220:	e13ffd17 	ldw	r4,-12(fp)
 d01a224:	d1602a04 	addi	r5,gp,-32600
 d01a228:	d0351b00 	call	d0351b0 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 d01a22c:	d8000015 	stw	zero,0(sp)
 d01a230:	e13ffe17 	ldw	r4,-8(fp)
 d01a234:	e17fff17 	ldw	r5,-4(fp)
 d01a238:	018340b4 	movhi	r6,3330
 d01a23c:	31a83c04 	addi	r6,r6,-24336
 d01a240:	e1fffd17 	ldw	r7,-12(fp)
 d01a244:	d0354500 	call	d035450 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 d01a248:	e037883a 	mov	sp,fp
 d01a24c:	dfc00117 	ldw	ra,4(sp)
 d01a250:	df000017 	ldw	fp,0(sp)
 d01a254:	dec00204 	addi	sp,sp,8
 d01a258:	f800283a 	ret

0d01a25c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 d01a25c:	defffa04 	addi	sp,sp,-24
 d01a260:	dfc00515 	stw	ra,20(sp)
 d01a264:	df000415 	stw	fp,16(sp)
 d01a268:	df000404 	addi	fp,sp,16
 d01a26c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 d01a270:	e0bfff17 	ldw	r2,-4(fp)
 d01a274:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 d01a278:	e0bfff17 	ldw	r2,-4(fp)
 d01a27c:	10800104 	addi	r2,r2,4
 d01a280:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01a284:	0005303a 	rdctl	r2,status
 d01a288:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01a28c:	e0fffd17 	ldw	r3,-12(fp)
 d01a290:	00bfff84 	movi	r2,-2
 d01a294:	1884703a 	and	r2,r3,r2
 d01a298:	1001703a 	wrctl	status,r2
  
  return context;
 d01a29c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 d01a2a0:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
 d01a2a4:	d035e5c0 	call	d035e5c <alt_tick>
 d01a2a8:	e0bffe17 	ldw	r2,-8(fp)
 d01a2ac:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01a2b0:	e0bffc17 	ldw	r2,-16(fp)
 d01a2b4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 d01a2b8:	e037883a 	mov	sp,fp
 d01a2bc:	dfc00117 	ldw	ra,4(sp)
 d01a2c0:	df000017 	ldw	fp,0(sp)
 d01a2c4:	dec00204 	addi	sp,sp,8
 d01a2c8:	f800283a 	ret

0d01a2cc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 d01a2cc:	defff804 	addi	sp,sp,-32
 d01a2d0:	dfc00715 	stw	ra,28(sp)
 d01a2d4:	df000615 	stw	fp,24(sp)
 d01a2d8:	df000604 	addi	fp,sp,24
 d01a2dc:	e13ffc15 	stw	r4,-16(fp)
 d01a2e0:	e17ffd15 	stw	r5,-12(fp)
 d01a2e4:	e1bffe15 	stw	r6,-8(fp)
 d01a2e8:	e1ffff15 	stw	r7,-4(fp)
 d01a2ec:	e0bfff17 	ldw	r2,-4(fp)
 d01a2f0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 d01a2f4:	00834174 	movhi	r2,3333
 d01a2f8:	109b5504 	addi	r2,r2,27988
 d01a2fc:	10800017 	ldw	r2,0(r2)
 d01a300:	1004c03a 	cmpne	r2,r2,zero
 d01a304:	1000041e 	bne	r2,zero,d01a318 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 d01a308:	00c34174 	movhi	r3,3333
 d01a30c:	18db5504 	addi	r3,r3,27988
 d01a310:	e0bffb17 	ldw	r2,-20(fp)
 d01a314:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 d01a318:	e0bffc17 	ldw	r2,-16(fp)
 d01a31c:	10800104 	addi	r2,r2,4
 d01a320:	1007883a 	mov	r3,r2
 d01a324:	008001c4 	movi	r2,7
 d01a328:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 d01a32c:	d8000015 	stw	zero,0(sp)
 d01a330:	e13ffd17 	ldw	r4,-12(fp)
 d01a334:	e17ffe17 	ldw	r5,-8(fp)
 d01a338:	018340b4 	movhi	r6,3330
 d01a33c:	31a89704 	addi	r6,r6,-23972
 d01a340:	e1fffc17 	ldw	r7,-16(fp)
 d01a344:	d0354500 	call	d035450 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 d01a348:	e037883a 	mov	sp,fp
 d01a34c:	dfc00117 	ldw	ra,4(sp)
 d01a350:	df000017 	ldw	fp,0(sp)
 d01a354:	dec00204 	addi	sp,sp,8
 d01a358:	f800283a 	ret

0d01a35c <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
 d01a35c:	defff904 	addi	sp,sp,-28
 d01a360:	dfc00615 	stw	ra,24(sp)
 d01a364:	df000515 	stw	fp,20(sp)
 d01a368:	df000504 	addi	fp,sp,20
 d01a36c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
 d01a370:	00800144 	movi	r2,5
 d01a374:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
 d01a378:	00800044 	movi	r2,1
 d01a37c:	d8800015 	stw	r2,0(sp)
 d01a380:	e0bffe44 	addi	r2,fp,-7
 d01a384:	d8800115 	stw	r2,4(sp)
 d01a388:	d8000215 	stw	zero,8(sp)
 d01a38c:	e13fff17 	ldw	r4,-4(fp)
 d01a390:	000b883a 	mov	r5,zero
 d01a394:	01800044 	movi	r6,1
 d01a398:	e1fffe04 	addi	r7,fp,-8
 d01a39c:	d0370500 	call	d037050 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
 d01a3a0:	e0bffe43 	ldbu	r2,-7(fp)
 d01a3a4:	10803fcc 	andi	r2,r2,255
}
 d01a3a8:	e037883a 	mov	sp,fp
 d01a3ac:	dfc00117 	ldw	ra,4(sp)
 d01a3b0:	df000017 	ldw	fp,0(sp)
 d01a3b4:	dec00204 	addi	sp,sp,8
 d01a3b8:	f800283a 	ret

0d01a3bc <epcs_sector_erase>:
  {
  }
}

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
 d01a3bc:	defff604 	addi	sp,sp,-40
 d01a3c0:	dfc00915 	stw	ra,36(sp)
 d01a3c4:	df000815 	stw	fp,32(sp)
 d01a3c8:	df000804 	addi	fp,sp,32
 d01a3cc:	e13ffd15 	stw	r4,-12(fp)
 d01a3d0:	e17ffe15 	stw	r5,-8(fp)
 d01a3d4:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
 d01a3d8:	e0bfff17 	ldw	r2,-4(fp)
 d01a3dc:	1005003a 	cmpeq	r2,r2,zero
 d01a3e0:	1000121e 	bne	r2,zero,d01a42c <epcs_sector_erase+0x70>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
 d01a3e4:	00bff604 	movi	r2,-40
 d01a3e8:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
 d01a3ec:	e0bffe17 	ldw	r2,-8(fp)
 d01a3f0:	1004d63a 	srli	r2,r2,24
 d01a3f4:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
 d01a3f8:	e0bffe17 	ldw	r2,-8(fp)
 d01a3fc:	1004d43a 	srli	r2,r2,16
 d01a400:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
 d01a404:	e0bffe17 	ldw	r2,-8(fp)
 d01a408:	1004d23a 	srli	r2,r2,8
 d01a40c:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
 d01a410:	e0bffe17 	ldw	r2,-8(fp)
 d01a414:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
 d01a418:	00800144 	movi	r2,5
 d01a41c:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
 d01a420:	e13ffd17 	ldw	r4,-12(fp)
 d01a424:	d01a9800 	call	d01a980 <epcs_enter_4_bytes_mode>
 d01a428:	00000c06 	br	d01a45c <epcs_sector_erase+0xa0>
  }
  else
  {
      se[0] = epcs_se;
 d01a42c:	00bff604 	movi	r2,-40
 d01a430:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
 d01a434:	e0bffe17 	ldw	r2,-8(fp)
 d01a438:	1004d43a 	srli	r2,r2,16
 d01a43c:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
 d01a440:	e0bffe17 	ldw	r2,-8(fp)
 d01a444:	1004d23a 	srli	r2,r2,8
 d01a448:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
 d01a44c:	e0bffe17 	ldw	r2,-8(fp)
 d01a450:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
 d01a454:	00800104 	movi	r2,4
 d01a458:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
 d01a45c:	e13ffd17 	ldw	r4,-12(fp)
 d01a460:	d01a6700 	call	d01a670 <epcs_write_enable>

  alt_avalon_spi_command(
 d01a464:	e1bffb03 	ldbu	r6,-20(fp)
 d01a468:	e1fffb44 	addi	r7,fp,-19
 d01a46c:	d8000015 	stw	zero,0(sp)
 d01a470:	d8000115 	stw	zero,4(sp)
 d01a474:	d8000215 	stw	zero,8(sp)
 d01a478:	e13ffd17 	ldw	r4,-12(fp)
 d01a47c:	000b883a 	mov	r5,zero
 d01a480:	d0370500 	call	d037050 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 d01a484:	e13ffd17 	ldw	r4,-12(fp)
 d01a488:	d01a4b40 	call	d01a4b4 <epcs_await_wip_released>

  if(four_bytes_mode)
 d01a48c:	e0bfff17 	ldw	r2,-4(fp)
 d01a490:	1005003a 	cmpeq	r2,r2,zero
 d01a494:	1000021e 	bne	r2,zero,d01a4a0 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
 d01a498:	e13ffd17 	ldw	r4,-12(fp)
 d01a49c:	d01a9d80 	call	d01a9d8 <epcs_exit_4_bytes_mode>
  }
}
 d01a4a0:	e037883a 	mov	sp,fp
 d01a4a4:	dfc00117 	ldw	ra,4(sp)
 d01a4a8:	df000017 	ldw	fp,0(sp)
 d01a4ac:	dec00204 	addi	sp,sp,8
 d01a4b0:	f800283a 	ret

0d01a4b4 <epcs_await_wip_released>:
{
  return epcs_read_status_register(base) & 1;
}

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
 d01a4b4:	defffd04 	addi	sp,sp,-12
 d01a4b8:	dfc00215 	stw	ra,8(sp)
 d01a4bc:	df000115 	stw	fp,4(sp)
 d01a4c0:	df000104 	addi	fp,sp,4
 d01a4c4:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
 d01a4c8:	e13fff17 	ldw	r4,-4(fp)
 d01a4cc:	d01a4ec0 	call	d01a4ec <epcs_test_wip>
 d01a4d0:	1004c03a 	cmpne	r2,r2,zero
 d01a4d4:	103ffc1e 	bne	r2,zero,d01a4c8 <epcs_await_wip_released+0x14>
  {
  }
}
 d01a4d8:	e037883a 	mov	sp,fp
 d01a4dc:	dfc00117 	ldw	ra,4(sp)
 d01a4e0:	df000017 	ldw	fp,0(sp)
 d01a4e4:	dec00204 	addi	sp,sp,8
 d01a4e8:	f800283a 	ret

0d01a4ec <epcs_test_wip>:

  return status;
}

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
 d01a4ec:	defffd04 	addi	sp,sp,-12
 d01a4f0:	dfc00215 	stw	ra,8(sp)
 d01a4f4:	df000115 	stw	fp,4(sp)
 d01a4f8:	df000104 	addi	fp,sp,4
 d01a4fc:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
 d01a500:	e13fff17 	ldw	r4,-4(fp)
 d01a504:	d01a35c0 	call	d01a35c <epcs_read_status_register>
 d01a508:	10803fcc 	andi	r2,r2,255
 d01a50c:	1080004c 	andi	r2,r2,1
}
 d01a510:	e037883a 	mov	sp,fp
 d01a514:	dfc00117 	ldw	ra,4(sp)
 d01a518:	df000017 	ldw	fp,0(sp)
 d01a51c:	dec00204 	addi	sp,sp,8
 d01a520:	f800283a 	ret

0d01a524 <epcs_read_buffer>:
  }
}

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
 d01a524:	defff404 	addi	sp,sp,-48
 d01a528:	dfc00b15 	stw	ra,44(sp)
 d01a52c:	df000a15 	stw	fp,40(sp)
 d01a530:	df000a04 	addi	fp,sp,40
 d01a534:	e13ffc15 	stw	r4,-16(fp)
 d01a538:	e17ffd15 	stw	r5,-12(fp)
 d01a53c:	e1bffe15 	stw	r6,-8(fp)
 d01a540:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
 d01a544:	008000c4 	movi	r2,3
 d01a548:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 d01a54c:	e0800217 	ldw	r2,8(fp)
 d01a550:	1005003a 	cmpeq	r2,r2,zero
 d01a554:	10001c1e 	bne	r2,zero,d01a5c8 <epcs_read_buffer+0xa4>
  {
        read_command[1] = (offset >> 24) & 0xFF;
 d01a558:	e0bffd17 	ldw	r2,-12(fp)
 d01a55c:	1005d63a 	srai	r2,r2,24
 d01a560:	1007883a 	mov	r3,r2
 d01a564:	00bfffc4 	movi	r2,-1
 d01a568:	1884703a 	and	r2,r3,r2
 d01a56c:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
 d01a570:	e0bffd17 	ldw	r2,-12(fp)
 d01a574:	1005d43a 	srai	r2,r2,16
 d01a578:	1007883a 	mov	r3,r2
 d01a57c:	00bfffc4 	movi	r2,-1
 d01a580:	1884703a 	and	r2,r3,r2
 d01a584:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
 d01a588:	e0bffd17 	ldw	r2,-12(fp)
 d01a58c:	1005d23a 	srai	r2,r2,8
 d01a590:	1007883a 	mov	r3,r2
 d01a594:	00bfffc4 	movi	r2,-1
 d01a598:	1884703a 	and	r2,r3,r2
 d01a59c:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
 d01a5a0:	e0bffd17 	ldw	r2,-12(fp)
 d01a5a4:	1007883a 	mov	r3,r2
 d01a5a8:	00bfffc4 	movi	r2,-1
 d01a5ac:	1884703a 	and	r2,r3,r2
 d01a5b0:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
 d01a5b4:	00800144 	movi	r2,5
 d01a5b8:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
 d01a5bc:	e13ffc17 	ldw	r4,-16(fp)
 d01a5c0:	d01a9800 	call	d01a980 <epcs_enter_4_bytes_mode>
 d01a5c4:	00001306 	br	d01a614 <epcs_read_buffer+0xf0>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
 d01a5c8:	e0bffd17 	ldw	r2,-12(fp)
 d01a5cc:	1005d43a 	srai	r2,r2,16
 d01a5d0:	1007883a 	mov	r3,r2
 d01a5d4:	00bfffc4 	movi	r2,-1
 d01a5d8:	1884703a 	and	r2,r3,r2
 d01a5dc:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
 d01a5e0:	e0bffd17 	ldw	r2,-12(fp)
 d01a5e4:	1005d23a 	srai	r2,r2,8
 d01a5e8:	1007883a 	mov	r3,r2
 d01a5ec:	00bfffc4 	movi	r2,-1
 d01a5f0:	1884703a 	and	r2,r3,r2
 d01a5f4:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
 d01a5f8:	e0bffd17 	ldw	r2,-12(fp)
 d01a5fc:	1007883a 	mov	r3,r2
 d01a600:	00bfffc4 	movi	r2,-1
 d01a604:	1884703a 	and	r2,r3,r2
 d01a608:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
 d01a60c:	00800104 	movi	r2,4
 d01a610:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
 d01a614:	e13ffc17 	ldw	r4,-16(fp)
 d01a618:	d01a4b40 	call	d01a4b4 <epcs_await_wip_released>

  alt_avalon_spi_command(
 d01a61c:	e0bfff17 	ldw	r2,-4(fp)
 d01a620:	e1fffa04 	addi	r7,fp,-24
 d01a624:	d8800015 	stw	r2,0(sp)
 d01a628:	e0bffe17 	ldw	r2,-8(fp)
 d01a62c:	d8800115 	stw	r2,4(sp)
 d01a630:	d8000215 	stw	zero,8(sp)
 d01a634:	e13ffc17 	ldw	r4,-16(fp)
 d01a638:	000b883a 	mov	r5,zero
 d01a63c:	e1bff917 	ldw	r6,-28(fp)
 d01a640:	d0370500 	call	d037050 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
 d01a644:	e0800217 	ldw	r2,8(fp)
 d01a648:	1005003a 	cmpeq	r2,r2,zero
 d01a64c:	1000021e 	bne	r2,zero,d01a658 <epcs_read_buffer+0x134>
  {
    epcs_exit_4_bytes_mode(base);
 d01a650:	e13ffc17 	ldw	r4,-16(fp)
 d01a654:	d01a9d80 	call	d01a9d8 <epcs_exit_4_bytes_mode>
  }

  return length;
 d01a658:	e0bfff17 	ldw	r2,-4(fp)
}
 d01a65c:	e037883a 	mov	sp,fp
 d01a660:	dfc00117 	ldw	ra,4(sp)
 d01a664:	df000017 	ldw	fp,0(sp)
 d01a668:	dec00204 	addi	sp,sp,8
 d01a66c:	f800283a 	ret

0d01a670 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
 d01a670:	defff904 	addi	sp,sp,-28
 d01a674:	dfc00615 	stw	ra,24(sp)
 d01a678:	df000515 	stw	fp,20(sp)
 d01a67c:	df000504 	addi	fp,sp,20
 d01a680:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
 d01a684:	00800184 	movi	r2,6
 d01a688:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
 d01a68c:	d8000015 	stw	zero,0(sp)
 d01a690:	d8000115 	stw	zero,4(sp)
 d01a694:	d8000215 	stw	zero,8(sp)
 d01a698:	e13fff17 	ldw	r4,-4(fp)
 d01a69c:	000b883a 	mov	r5,zero
 d01a6a0:	01800044 	movi	r6,1
 d01a6a4:	e1fffe04 	addi	r7,fp,-8
 d01a6a8:	d0370500 	call	d037050 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
 d01a6ac:	e037883a 	mov	sp,fp
 d01a6b0:	dfc00117 	ldw	ra,4(sp)
 d01a6b4:	df000017 	ldw	fp,0(sp)
 d01a6b8:	dec00204 	addi	sp,sp,8
 d01a6bc:	f800283a 	ret

0d01a6c0 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
 d01a6c0:	defff804 	addi	sp,sp,-32
 d01a6c4:	dfc00715 	stw	ra,28(sp)
 d01a6c8:	df000615 	stw	fp,24(sp)
 d01a6cc:	df000604 	addi	fp,sp,24
 d01a6d0:	e13ffe15 	stw	r4,-8(fp)
 d01a6d4:	e17fff05 	stb	r5,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
 d01a6d8:	00800044 	movi	r2,1
 d01a6dc:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
 d01a6e0:	e0bfff03 	ldbu	r2,-4(fp)
 d01a6e4:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
 d01a6e8:	d8000015 	stw	zero,0(sp)
 d01a6ec:	d8000115 	stw	zero,4(sp)
 d01a6f0:	d8000215 	stw	zero,8(sp)
 d01a6f4:	e13ffe17 	ldw	r4,-8(fp)
 d01a6f8:	000b883a 	mov	r5,zero
 d01a6fc:	01800084 	movi	r6,2
 d01a700:	e1fffd04 	addi	r7,fp,-12
 d01a704:	d0370500 	call	d037050 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 d01a708:	e13ffe17 	ldw	r4,-8(fp)
 d01a70c:	d01a4b40 	call	d01a4b4 <epcs_await_wip_released>
}
 d01a710:	e037883a 	mov	sp,fp
 d01a714:	dfc00117 	ldw	ra,4(sp)
 d01a718:	df000017 	ldw	fp,0(sp)
 d01a71c:	dec00204 	addi	sp,sp,8
 d01a720:	f800283a 	ret

0d01a724 <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
 d01a724:	defff404 	addi	sp,sp,-48
 d01a728:	dfc00b15 	stw	ra,44(sp)
 d01a72c:	df000a15 	stw	fp,40(sp)
 d01a730:	df000a04 	addi	fp,sp,40
 d01a734:	e13ffc15 	stw	r4,-16(fp)
 d01a738:	e17ffd15 	stw	r5,-12(fp)
 d01a73c:	e1bffe15 	stw	r6,-8(fp)
 d01a740:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
 d01a744:	00800084 	movi	r2,2
 d01a748:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 d01a74c:	e0800217 	ldw	r2,8(fp)
 d01a750:	1005003a 	cmpeq	r2,r2,zero
 d01a754:	10001c1e 	bne	r2,zero,d01a7c8 <epcs_write_buffer+0xa4>
  {
      pp[1] = (offset >> 24) & 0xFF;
 d01a758:	e0bffd17 	ldw	r2,-12(fp)
 d01a75c:	1005d63a 	srai	r2,r2,24
 d01a760:	1007883a 	mov	r3,r2
 d01a764:	00bfffc4 	movi	r2,-1
 d01a768:	1884703a 	and	r2,r3,r2
 d01a76c:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
 d01a770:	e0bffd17 	ldw	r2,-12(fp)
 d01a774:	1005d43a 	srai	r2,r2,16
 d01a778:	1007883a 	mov	r3,r2
 d01a77c:	00bfffc4 	movi	r2,-1
 d01a780:	1884703a 	and	r2,r3,r2
 d01a784:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
 d01a788:	e0bffd17 	ldw	r2,-12(fp)
 d01a78c:	1005d23a 	srai	r2,r2,8
 d01a790:	1007883a 	mov	r3,r2
 d01a794:	00bfffc4 	movi	r2,-1
 d01a798:	1884703a 	and	r2,r3,r2
 d01a79c:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
 d01a7a0:	e0bffd17 	ldw	r2,-12(fp)
 d01a7a4:	1007883a 	mov	r3,r2
 d01a7a8:	00bfffc4 	movi	r2,-1
 d01a7ac:	1884703a 	and	r2,r3,r2
 d01a7b0:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
 d01a7b4:	00800144 	movi	r2,5
 d01a7b8:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
 d01a7bc:	e13ffc17 	ldw	r4,-16(fp)
 d01a7c0:	d01a9800 	call	d01a980 <epcs_enter_4_bytes_mode>
 d01a7c4:	00001306 	br	d01a814 <epcs_write_buffer+0xf0>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
 d01a7c8:	e0bffd17 	ldw	r2,-12(fp)
 d01a7cc:	1005d43a 	srai	r2,r2,16
 d01a7d0:	1007883a 	mov	r3,r2
 d01a7d4:	00bfffc4 	movi	r2,-1
 d01a7d8:	1884703a 	and	r2,r3,r2
 d01a7dc:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
 d01a7e0:	e0bffd17 	ldw	r2,-12(fp)
 d01a7e4:	1005d23a 	srai	r2,r2,8
 d01a7e8:	1007883a 	mov	r3,r2
 d01a7ec:	00bfffc4 	movi	r2,-1
 d01a7f0:	1884703a 	and	r2,r3,r2
 d01a7f4:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
 d01a7f8:	e0bffd17 	ldw	r2,-12(fp)
 d01a7fc:	1007883a 	mov	r3,r2
 d01a800:	00bfffc4 	movi	r2,-1
 d01a804:	1884703a 	and	r2,r3,r2
 d01a808:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
 d01a80c:	00800104 	movi	r2,4
 d01a810:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
 d01a814:	e13ffc17 	ldw	r4,-16(fp)
 d01a818:	d01a6700 	call	d01a670 <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
 d01a81c:	e1fffa04 	addi	r7,fp,-24
 d01a820:	d8000015 	stw	zero,0(sp)
 d01a824:	d8000115 	stw	zero,4(sp)
 d01a828:	00800044 	movi	r2,1
 d01a82c:	d8800215 	stw	r2,8(sp)
 d01a830:	e13ffc17 	ldw	r4,-16(fp)
 d01a834:	000b883a 	mov	r5,zero
 d01a838:	e1bff917 	ldw	r6,-28(fp)
 d01a83c:	d0370500 	call	d037050 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
 d01a840:	e1bfff17 	ldw	r6,-4(fp)
 d01a844:	d8000015 	stw	zero,0(sp)
 d01a848:	d8000115 	stw	zero,4(sp)
 d01a84c:	d8000215 	stw	zero,8(sp)
 d01a850:	e13ffc17 	ldw	r4,-16(fp)
 d01a854:	000b883a 	mov	r5,zero
 d01a858:	e1fffe17 	ldw	r7,-8(fp)
 d01a85c:	d0370500 	call	d037050 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
 d01a860:	e13ffc17 	ldw	r4,-16(fp)
 d01a864:	d01a4b40 	call	d01a4b4 <epcs_await_wip_released>

  if(four_bytes_mode)
 d01a868:	e0800217 	ldw	r2,8(fp)
 d01a86c:	1005003a 	cmpeq	r2,r2,zero
 d01a870:	1000021e 	bne	r2,zero,d01a87c <epcs_write_buffer+0x158>
  {
    epcs_exit_4_bytes_mode(base);
 d01a874:	e13ffc17 	ldw	r4,-16(fp)
 d01a878:	d01a9d80 	call	d01a9d8 <epcs_exit_4_bytes_mode>
  }

  return length;
 d01a87c:	e0bfff17 	ldw	r2,-4(fp)
}
 d01a880:	e037883a 	mov	sp,fp
 d01a884:	dfc00117 	ldw	ra,4(sp)
 d01a888:	df000017 	ldw	fp,0(sp)
 d01a88c:	dec00204 	addi	sp,sp,8
 d01a890:	f800283a 	ret

0d01a894 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
 d01a894:	defff804 	addi	sp,sp,-32
 d01a898:	dfc00715 	stw	ra,28(sp)
 d01a89c:	df000615 	stw	fp,24(sp)
 d01a8a0:	df000604 	addi	fp,sp,24
 d01a8a4:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
 d01a8a8:	00bfeac4 	movi	r2,-85
 d01a8ac:	e0bffd05 	stb	r2,-12(fp)
 d01a8b0:	e03ffd45 	stb	zero,-11(fp)
 d01a8b4:	e03ffd85 	stb	zero,-10(fp)
 d01a8b8:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
 d01a8bc:	00800044 	movi	r2,1
 d01a8c0:	d8800015 	stw	r2,0(sp)
 d01a8c4:	e0bffe04 	addi	r2,fp,-8
 d01a8c8:	d8800115 	stw	r2,4(sp)
 d01a8cc:	d8000215 	stw	zero,8(sp)
 d01a8d0:	e13fff17 	ldw	r4,-4(fp)
 d01a8d4:	000b883a 	mov	r5,zero
 d01a8d8:	01800104 	movi	r6,4
 d01a8dc:	e1fffd04 	addi	r7,fp,-12
 d01a8e0:	d0370500 	call	d037050 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
 d01a8e4:	e0bffe03 	ldbu	r2,-8(fp)
 d01a8e8:	10803fcc 	andi	r2,r2,255
}
 d01a8ec:	e037883a 	mov	sp,fp
 d01a8f0:	dfc00117 	ldw	ra,4(sp)
 d01a8f4:	df000017 	ldw	fp,0(sp)
 d01a8f8:	dec00204 	addi	sp,sp,8
 d01a8fc:	f800283a 	ret

0d01a900 <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
 d01a900:	defff904 	addi	sp,sp,-28
 d01a904:	dfc00615 	stw	ra,24(sp)
 d01a908:	df000515 	stw	fp,20(sp)
 d01a90c:	df000504 	addi	fp,sp,20
 d01a910:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
 d01a914:	00bfe7c4 	movi	r2,-97
 d01a918:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
 d01a91c:	008000c4 	movi	r2,3
 d01a920:	d8800015 	stw	r2,0(sp)
 d01a924:	e0bffe44 	addi	r2,fp,-7
 d01a928:	d8800115 	stw	r2,4(sp)
 d01a92c:	d8000215 	stw	zero,8(sp)
 d01a930:	e13fff17 	ldw	r4,-4(fp)
 d01a934:	000b883a 	mov	r5,zero
 d01a938:	01800044 	movi	r6,1
 d01a93c:	e1fffe04 	addi	r7,fp,-8
 d01a940:	d0370500 	call	d037050 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
 d01a944:	e0bffe43 	ldbu	r2,-7(fp)
 d01a948:	10803fcc 	andi	r2,r2,255
 d01a94c:	1006943a 	slli	r3,r2,16
 d01a950:	e0bffe83 	ldbu	r2,-6(fp)
 d01a954:	10803fcc 	andi	r2,r2,255
 d01a958:	1004923a 	slli	r2,r2,8
 d01a95c:	1886b03a 	or	r3,r3,r2
 d01a960:	e0bffec3 	ldbu	r2,-5(fp)
 d01a964:	10803fcc 	andi	r2,r2,255
 d01a968:	1884b03a 	or	r2,r3,r2
}
 d01a96c:	e037883a 	mov	sp,fp
 d01a970:	dfc00117 	ldw	ra,4(sp)
 d01a974:	df000017 	ldw	fp,0(sp)
 d01a978:	dec00204 	addi	sp,sp,8
 d01a97c:	f800283a 	ret

0d01a980 <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
 d01a980:	defff904 	addi	sp,sp,-28
 d01a984:	dfc00615 	stw	ra,24(sp)
 d01a988:	df000515 	stw	fp,20(sp)
 d01a98c:	df000504 	addi	fp,sp,20
 d01a990:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
 d01a994:	00bfedc4 	movi	r2,-73
 d01a998:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 d01a99c:	e13fff17 	ldw	r4,-4(fp)
 d01a9a0:	d01a6700 	call	d01a670 <epcs_write_enable>

  alt_avalon_spi_command(
 d01a9a4:	d8000015 	stw	zero,0(sp)
 d01a9a8:	d8000115 	stw	zero,4(sp)
 d01a9ac:	d8000215 	stw	zero,8(sp)
 d01a9b0:	e13fff17 	ldw	r4,-4(fp)
 d01a9b4:	000b883a 	mov	r5,zero
 d01a9b8:	01800044 	movi	r6,1
 d01a9bc:	e1fffe04 	addi	r7,fp,-8
 d01a9c0:	d0370500 	call	d037050 <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
 d01a9c4:	e037883a 	mov	sp,fp
 d01a9c8:	dfc00117 	ldw	ra,4(sp)
 d01a9cc:	df000017 	ldw	fp,0(sp)
 d01a9d0:	dec00204 	addi	sp,sp,8
 d01a9d4:	f800283a 	ret

0d01a9d8 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
 d01a9d8:	defff904 	addi	sp,sp,-28
 d01a9dc:	dfc00615 	stw	ra,24(sp)
 d01a9e0:	df000515 	stw	fp,20(sp)
 d01a9e4:	df000504 	addi	fp,sp,20
 d01a9e8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
 d01a9ec:	00bffa44 	movi	r2,-23
 d01a9f0:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 d01a9f4:	e13fff17 	ldw	r4,-4(fp)
 d01a9f8:	d01a6700 	call	d01a670 <epcs_write_enable>

  alt_avalon_spi_command(
 d01a9fc:	d8000015 	stw	zero,0(sp)
 d01aa00:	d8000115 	stw	zero,4(sp)
 d01aa04:	d8000215 	stw	zero,8(sp)
 d01aa08:	e13fff17 	ldw	r4,-4(fp)
 d01aa0c:	000b883a 	mov	r5,zero
 d01aa10:	01800044 	movi	r6,1
 d01aa14:	e1fffe04 	addi	r7,fp,-8
 d01aa18:	d0370500 	call	d037050 <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
 d01aa1c:	e037883a 	mov	sp,fp
 d01aa20:	dfc00117 	ldw	ra,4(sp)
 d01aa24:	df000017 	ldw	fp,0(sp)
 d01aa28:	dec00204 	addi	sp,sp,8
 d01aa2c:	f800283a 	ret

0d01aa30 <triple_speed_ethernet_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t triple_speed_ethernet_init(
    alt_iniche_dev              *p_dev)
{
 d01aa30:	defff804 	addi	sp,sp,-32
 d01aa34:	dfc00715 	stw	ra,28(sp)
 d01aa38:	df000615 	stw	fp,24(sp)
 d01aa3c:	dc000515 	stw	r16,20(sp)
 d01aa40:	df000504 	addi	fp,sp,20
 d01aa44:	e13ffe15 	stw	r4,-8(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 d01aa48:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_system_info *psys_info = 0;
 d01aa4c:	e03ffb15 	stw	zero,-20(fp)
    #ifdef PRINTIF
        dprintf("triple_speed_ethernet_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 d01aa50:	e03ffd15 	stw	zero,-12(fp)
 d01aa54:	00001406 	br	d01aaa8 <triple_speed_ethernet_init+0x78>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 d01aa58:	e13ffd17 	ldw	r4,-12(fp)
 d01aa5c:	040341b4 	movhi	r16,3334
 d01aa60:	8401fd04 	addi	r16,r16,2036
 d01aa64:	01400304 	movi	r5,12
 d01aa68:	d00235c0 	call	d00235c <__mulsi3>
 d01aa6c:	1405883a 	add	r2,r2,r16
 d01aa70:	10c00017 	ldw	r3,0(r2)
 d01aa74:	e0bffe17 	ldw	r2,-8(fp)
 d01aa78:	1880081e 	bne	r3,r2,d01aa9c <triple_speed_ethernet_init+0x6c>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 d01aa7c:	e13ffd17 	ldw	r4,-12(fp)
 d01aa80:	01400304 	movi	r5,12
 d01aa84:	d00235c0 	call	d00235c <__mulsi3>
 d01aa88:	1007883a 	mov	r3,r2
 d01aa8c:	008341b4 	movhi	r2,3334
 d01aa90:	1081fd04 	addi	r2,r2,2036
 d01aa94:	1885883a 	add	r2,r3,r2
 d01aa98:	e0bffc15 	stw	r2,-16(fp)
    #ifdef PRINTIF
        dprintf("triple_speed_ethernet_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 d01aa9c:	e0bffd17 	ldw	r2,-12(fp)
 d01aaa0:	10800044 	addi	r2,r2,1
 d01aaa4:	e0bffd15 	stw	r2,-12(fp)
 d01aaa8:	d0a8fe03 	ldbu	r2,-23560(gp)
 d01aaac:	10c03fcc 	andi	r3,r2,255
 d01aab0:	e0bffd17 	ldw	r2,-12(fp)
 d01aab4:	10ffe816 	blt	r2,r3,d01aa58 <triple_speed_ethernet_init+0x28>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 d01aab8:	e0bffc17 	ldw	r2,-16(fp)
 d01aabc:	1004c03a 	cmpne	r2,r2,zero
 d01aac0:	1000031e 	bne	r2,zero,d01aad0 <triple_speed_ethernet_init+0xa0>
        return ENP_HARDWARE;
 d01aac4:	00bff744 	movi	r2,-35
 d01aac8:	e0bfff15 	stw	r2,-4(fp)
 d01aacc:	00003006 	br	d01ab90 <triple_speed_ethernet_init+0x160>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 d01aad0:	e03ffd15 	stw	zero,-12(fp)
 d01aad4:	00001506 	br	d01ab2c <triple_speed_ethernet_init+0xfc>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 d01aad8:	e13ffd17 	ldw	r4,-12(fp)
 d01aadc:	04034174 	movhi	r16,3333
 d01aae0:	8409fc04 	addi	r16,r16,10224
 d01aae4:	01401204 	movi	r5,72
 d01aae8:	d00235c0 	call	d00235c <__mulsi3>
 d01aaec:	1405883a 	add	r2,r2,r16
 d01aaf0:	10c00017 	ldw	r3,0(r2)
 d01aaf4:	e0bffc17 	ldw	r2,-16(fp)
 d01aaf8:	10800117 	ldw	r2,4(r2)
 d01aafc:	1880081e 	bne	r3,r2,d01ab20 <triple_speed_ethernet_init+0xf0>
            psys_info = &tse_mac_device[i];
 d01ab00:	e13ffd17 	ldw	r4,-12(fp)
 d01ab04:	01401204 	movi	r5,72
 d01ab08:	d00235c0 	call	d00235c <__mulsi3>
 d01ab0c:	1007883a 	mov	r3,r2
 d01ab10:	00834174 	movhi	r2,3333
 d01ab14:	1089fc04 	addi	r2,r2,10224
 d01ab18:	1885883a 	add	r2,r3,r2
 d01ab1c:	e0bffb15 	stw	r2,-20(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 d01ab20:	e0bffd17 	ldw	r2,-12(fp)
 d01ab24:	10800044 	addi	r2,r2,1
 d01ab28:	e0bffd15 	stw	r2,-12(fp)
 d01ab2c:	00834174 	movhi	r2,3333
 d01ab30:	10926904 	addi	r2,r2,18852
 d01ab34:	10800003 	ldbu	r2,0(r2)
 d01ab38:	10c03fcc 	andi	r3,r2,255
 d01ab3c:	e0bffd17 	ldw	r2,-12(fp)
 d01ab40:	10ffe516 	blt	r2,r3,d01aad8 <triple_speed_ethernet_init+0xa8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 d01ab44:	e0bffb17 	ldw	r2,-20(fp)
 d01ab48:	1004c03a 	cmpne	r2,r2,zero
 d01ab4c:	1000031e 	bne	r2,zero,d01ab5c <triple_speed_ethernet_init+0x12c>
        return ENP_HARDWARE;
 d01ab50:	00bff744 	movi	r2,-35
 d01ab54:	e0bfff15 	stw	r2,-4(fp)
 d01ab58:	00000d06 	br	d01ab90 <triple_speed_ethernet_init+0x160>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 d01ab5c:	e0bffe17 	ldw	r2,-8(fp)
 d01ab60:	14000517 	ldw	r16,20(r2)
 d01ab64:	e0bffc17 	ldw	r2,-16(fp)
 d01ab68:	10800203 	ldbu	r2,8(r2)
 d01ab6c:	11003fcc 	andi	r4,r2,255
 d01ab70:	01401204 	movi	r5,72
 d01ab74:	d00235c0 	call	d00235c <__mulsi3>
 d01ab78:	1007883a 	mov	r3,r2
 d01ab7c:	e0bffb17 	ldw	r2,-20(fp)
 d01ab80:	188b883a 	add	r5,r3,r2
 d01ab84:	8009883a 	mov	r4,r16
 d01ab88:	d01abac0 	call	d01abac <prep_tse_mac>
    
    return SUCCESS;
 d01ab8c:	e03fff15 	stw	zero,-4(fp)
 d01ab90:	e0bfff17 	ldw	r2,-4(fp)
}
 d01ab94:	e037883a 	mov	sp,fp
 d01ab98:	dfc00217 	ldw	ra,8(sp)
 d01ab9c:	df000117 	ldw	fp,4(sp)
 d01aba0:	dc000017 	ldw	r16,0(sp)
 d01aba4:	dec00304 	addi	sp,sp,12
 d01aba8:	f800283a 	ret

0d01abac <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 d01abac:	defffa04 	addi	sp,sp,-24
 d01abb0:	dfc00515 	stw	ra,20(sp)
 d01abb4:	df000415 	stw	fp,16(sp)
 d01abb8:	dc000315 	stw	r16,12(sp)
 d01abbc:	df000304 	addi	fp,sp,12
 d01abc0:	e13ffe15 	stw	r4,-8(fp)
 d01abc4:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 d01abc8:	01034174 	movhi	r4,3333
 d01abcc:	2139df04 	addi	r4,r4,-6276
 d01abd0:	e17ffe17 	ldw	r5,-8(fp)
 d01abd4:	d0028a00 	call	d0028a0 <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 d01abd8:	e13ffe17 	ldw	r4,-8(fp)
 d01abdc:	040341b4 	movhi	r16,3334
 d01abe0:	84020904 	addi	r16,r16,2084
 d01abe4:	01401304 	movi	r5,76
 d01abe8:	d00235c0 	call	d00235c <__mulsi3>
 d01abec:	1405883a 	add	r2,r2,r16
 d01abf0:	10800c04 	addi	r2,r2,48
 d01abf4:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 d01abf8:	e13ffe17 	ldw	r4,-8(fp)
 d01abfc:	040341b4 	movhi	r16,3334
 d01ac00:	84020904 	addi	r16,r16,2084
 d01ac04:	01401304 	movi	r5,76
 d01ac08:	d00235c0 	call	d00235c <__mulsi3>
 d01ac0c:	1405883a 	add	r2,r2,r16
 d01ac10:	10c01204 	addi	r3,r2,72
 d01ac14:	e0bfff17 	ldw	r2,-4(fp)
 d01ac18:	18800015 	stw	r2,0(r3)

        ifp = nets[index];
 d01ac1c:	e0bffe17 	ldw	r2,-8(fp)
 d01ac20:	00c341b4 	movhi	r3,3334
 d01ac24:	18c31a04 	addi	r3,r3,3176
 d01ac28:	1085883a 	add	r2,r2,r2
 d01ac2c:	1085883a 	add	r2,r2,r2
 d01ac30:	10c5883a 	add	r2,r2,r3
 d01ac34:	10800017 	ldw	r2,0(r2)
 d01ac38:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 d01ac3c:	e0bffd17 	ldw	r2,-12(fp)
 d01ac40:	10c02717 	ldw	r3,156(r2)
 d01ac44:	00800084 	movi	r2,2
 d01ac48:	18800615 	stw	r2,24(r3)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 d01ac4c:	e0bffd17 	ldw	r2,-12(fp)
 d01ac50:	10c02717 	ldw	r3,156(r2)
 d01ac54:	00800084 	movi	r2,2
 d01ac58:	18800715 	stw	r2,28(r3)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 d01ac5c:	e0bffd17 	ldw	r2,-12(fp)
 d01ac60:	10c02717 	ldw	r3,156(r2)
 d01ac64:	00834174 	movhi	r2,3333
 d01ac68:	109b4504 	addi	r2,r2,27924
 d01ac6c:	10800017 	ldw	r2,0(r2)
 d01ac70:	18800815 	stw	r2,32(r3)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 d01ac74:	e0bffd17 	ldw	r2,-12(fp)
 d01ac78:	14002717 	ldw	r16,156(r2)
 d01ac7c:	e13ffe17 	ldw	r4,-8(fp)
 d01ac80:	01401304 	movi	r5,76
 d01ac84:	d00235c0 	call	d00235c <__mulsi3>
 d01ac88:	10c00604 	addi	r3,r2,24
 d01ac8c:	008341b4 	movhi	r2,3334
 d01ac90:	10820904 	addi	r2,r2,2084
 d01ac94:	1885883a 	add	r2,r3,r2
 d01ac98:	80800515 	stw	r2,20(r16)
        ifp->n_mib->ifDescr =       (u_char*)"Altera TSE MAC ethernet";
 d01ac9c:	e0bffd17 	ldw	r2,-12(fp)
 d01aca0:	10c02717 	ldw	r3,156(r2)
 d01aca4:	00834174 	movhi	r2,3333
 d01aca8:	10b9e404 	addi	r2,r2,-6256
 d01acac:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 d01acb0:	e0fffd17 	ldw	r3,-12(fp)
 d01acb4:	00800404 	movi	r2,16
 d01acb8:	18800815 	stw	r2,32(r3)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 d01acbc:	e0fffd17 	ldw	r3,-12(fp)
 d01acc0:	00800184 	movi	r2,6
 d01acc4:	18801115 	stw	r2,68(r3)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 d01acc8:	e0bffd17 	ldw	r2,-12(fp)
 d01accc:	10c02717 	ldw	r3,156(r2)
 d01acd0:	00800184 	movi	r2,6
 d01acd4:	18800215 	stw	r2,8(r3)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 d01acd8:	e0fffd17 	ldw	r3,-12(fp)
 d01acdc:	00817a84 	movi	r2,1514
 d01ace0:	18800915 	stw	r2,36(r3)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 d01ace4:	e0fffd17 	ldw	r3,-12(fp)
 d01ace8:	008340b4 	movhi	r2,3330
 d01acec:	10ab8e04 	addi	r2,r2,-20936
 d01acf0:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 d01acf4:	e0bffd17 	ldw	r2,-12(fp)
 d01acf8:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 d01acfc:	e0fffd17 	ldw	r3,-12(fp)
 d01ad00:	008340b4 	movhi	r2,3330
 d01ad04:	10ae7a04 	addi	r2,r2,-17944
 d01ad08:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 d01ad0c:	e0fffd17 	ldw	r3,-12(fp)
 d01ad10:	008340b4 	movhi	r2,3330
 d01ad14:	10b07004 	addi	r2,r2,-15936
 d01ad18:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 d01ad1c:	00c340b4 	movhi	r3,3330
 d01ad20:	18f06004 	addi	r3,r3,-16000
 d01ad24:	e0bffd17 	ldw	r2,-12(fp)
 d01ad28:	10c00715 	stw	r3,28(r2)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 d01ad2c:	e0bffd17 	ldw	r2,-12(fp)
 d01ad30:	10802a17 	ldw	r2,168(r2)
 d01ad34:	10c00214 	ori	r3,r2,8
 d01ad38:	e0bffd17 	ldw	r2,-12(fp)
 d01ad3c:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 d01ad40:	e0bffe17 	ldw	r2,-8(fp)
 d01ad44:	00c341b4 	movhi	r3,3334
 d01ad48:	18c31a04 	addi	r3,r3,3176
 d01ad4c:	1085883a 	add	r2,r2,r2
 d01ad50:	1085883a 	add	r2,r2,r2
 d01ad54:	10c5883a 	add	r2,r2,r3
 d01ad58:	10800017 	ldw	r2,0(r2)
 d01ad5c:	14002717 	ldw	r16,156(r2)
 d01ad60:	e13ffe17 	ldw	r4,-8(fp)
 d01ad64:	01401304 	movi	r5,76
 d01ad68:	d00235c0 	call	d00235c <__mulsi3>
 d01ad6c:	10c00604 	addi	r3,r2,24
 d01ad70:	008341b4 	movhi	r2,3334
 d01ad74:	10820904 	addi	r2,r2,2084
 d01ad78:	1885883a 	add	r2,r3,r2
 d01ad7c:	80800515 	stw	r2,20(r16)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 d01ad80:	e13ffe17 	ldw	r4,-8(fp)
 d01ad84:	01401304 	movi	r5,76
 d01ad88:	d00235c0 	call	d00235c <__mulsi3>
 d01ad8c:	10c00604 	addi	r3,r2,24
 d01ad90:	008341b4 	movhi	r2,3334
 d01ad94:	10820904 	addi	r2,r2,2084
 d01ad98:	1885883a 	add	r2,r3,r2
 d01ad9c:	100b883a 	mov	r5,r2
 d01ada0:	e13ffd17 	ldw	r4,-12(fp)
 d01ada4:	d0011b80 	call	d0011b8 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 d01ada8:	e13ffe17 	ldw	r4,-8(fp)
 d01adac:	040341b4 	movhi	r16,3334
 d01adb0:	84020904 	addi	r16,r16,2084
 d01adb4:	01401304 	movi	r5,76
 d01adb8:	d00235c0 	call	d00235c <__mulsi3>
 d01adbc:	1407883a 	add	r3,r2,r16
 d01adc0:	e0bffe17 	ldw	r2,-8(fp)
 d01adc4:	18800015 	stw	r2,0(r3)
        tse[index].netp = ifp;
 d01adc8:	e13ffe17 	ldw	r4,-8(fp)
 d01adcc:	040341b4 	movhi	r16,3334
 d01add0:	84020904 	addi	r16,r16,2084
 d01add4:	01401304 	movi	r5,76
 d01add8:	d00235c0 	call	d00235c <__mulsi3>
 d01addc:	1405883a 	add	r2,r2,r16
 d01ade0:	10c00804 	addi	r3,r2,32
 d01ade4:	e0bffd17 	ldw	r2,-12(fp)
 d01ade8:	18800015 	stw	r2,0(r3)
        ifp->n_local = (void*)(&tse[index]);
 d01adec:	e13ffe17 	ldw	r4,-8(fp)
 d01adf0:	01401304 	movi	r5,76
 d01adf4:	d00235c0 	call	d00235c <__mulsi3>
 d01adf8:	1007883a 	mov	r3,r2
 d01adfc:	008341b4 	movhi	r2,3334
 d01ae00:	10820904 	addi	r2,r2,2084
 d01ae04:	1887883a 	add	r3,r3,r2
 d01ae08:	e0bffd17 	ldw	r2,-12(fp)
 d01ae0c:	10c02815 	stw	r3,160(r2)
    
        index++;
 d01ae10:	e0bffe17 	ldw	r2,-8(fp)
 d01ae14:	10800044 	addi	r2,r2,1
 d01ae18:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 d01ae1c:	e0bffe17 	ldw	r2,-8(fp)
}
 d01ae20:	e037883a 	mov	sp,fp
 d01ae24:	dfc00217 	ldw	ra,8(sp)
 d01ae28:	df000117 	ldw	fp,4(sp)
 d01ae2c:	dc000017 	ldw	r16,0(sp)
 d01ae30:	dec00304 	addi	sp,sp,12
 d01ae34:	f800283a 	ret

0d01ae38 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 d01ae38:	deffeb04 	addi	sp,sp,-84
 d01ae3c:	dfc01415 	stw	ra,80(sp)
 d01ae40:	df001315 	stw	fp,76(sp)
 d01ae44:	dc801215 	stw	r18,72(sp)
 d01ae48:	dc401115 	stw	r17,68(sp)
 d01ae4c:	dc001015 	stw	r16,64(sp)
 d01ae50:	df001004 	addi	fp,sp,64
 d01ae54:	e13ffe15 	stw	r4,-8(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 d01ae58:	e03ff815 	stw	zero,-32(fp)
   
   NET ifp;
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 d01ae5c:	e13ffe17 	ldw	r4,-8(fp)
 d01ae60:	040341b4 	movhi	r16,3334
 d01ae64:	84020904 	addi	r16,r16,2084
 d01ae68:	01401304 	movi	r5,76
 d01ae6c:	d00235c0 	call	d00235c <__mulsi3>
 d01ae70:	1405883a 	add	r2,r2,r16
 d01ae74:	10801204 	addi	r2,r2,72
 d01ae78:	10800017 	ldw	r2,0(r2)
 d01ae7c:	e0bff415 	stw	r2,-48(fp)
   
   dprintf("[tse_mac_init]\n");
 d01ae80:	01034174 	movhi	r4,3333
 d01ae84:	2139ea04 	addi	r4,r4,-6232
 d01ae88:	d002bc80 	call	d002bc8 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 d01ae8c:	e0bff417 	ldw	r2,-48(fp)
 d01ae90:	10800783 	ldbu	r2,30(r2)
 d01ae94:	10803fcc 	andi	r2,r2,255
 d01ae98:	10800058 	cmpnei	r2,r2,1
 d01ae9c:	10000c1e 	bne	r2,zero,d01aed0 <tse_mac_init+0x98>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 d01aea0:	e13ffe17 	ldw	r4,-8(fp)
 d01aea4:	e0bff417 	ldw	r2,-48(fp)
 d01aea8:	10800817 	ldw	r2,32(r2)
 d01aeac:	1023883a 	mov	r17,r2
 d01aeb0:	040341b4 	movhi	r16,3334
 d01aeb4:	84020904 	addi	r16,r16,2084
 d01aeb8:	01401304 	movi	r5,76
 d01aebc:	d00235c0 	call	d00235c <__mulsi3>
 d01aec0:	1405883a 	add	r2,r2,r16
 d01aec4:	10800f04 	addi	r2,r2,60
 d01aec8:	14400015 	stw	r17,0(r2)
 d01aecc:	00001406 	br	d01af20 <tse_mac_init+0xe8>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 d01aed0:	01002804 	movi	r4,160
 d01aed4:	d035f6c0 	call	d035f6c <alt_uncached_malloc>
 d01aed8:	e0bff315 	stw	r2,-52(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 d01aedc:	00000306 	br	d01aeec <tse_mac_init+0xb4>
        {
            temp_desc++;
 d01aee0:	e0bff317 	ldw	r2,-52(fp)
 d01aee4:	10800044 	addi	r2,r2,1
 d01aee8:	e0bff315 	stw	r2,-52(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 d01aeec:	e0bff317 	ldw	r2,-52(fp)
 d01aef0:	108007cc 	andi	r2,r2,31
 d01aef4:	1004c03a 	cmpne	r2,r2,zero
 d01aef8:	103ff91e 	bne	r2,zero,d01aee0 <tse_mac_init+0xa8>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 d01aefc:	e13ffe17 	ldw	r4,-8(fp)
 d01af00:	e47ff317 	ldw	r17,-52(fp)
 d01af04:	040341b4 	movhi	r16,3334
 d01af08:	84020904 	addi	r16,r16,2084
 d01af0c:	01401304 	movi	r5,76
 d01af10:	d00235c0 	call	d00235c <__mulsi3>
 d01af14:	1405883a 	add	r2,r2,r16
 d01af18:	10800f04 	addi	r2,r2,60
 d01af1c:	14400015 	stw	r17,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 d01af20:	e0bff417 	ldw	r2,-48(fp)
 d01af24:	11000517 	ldw	r4,20(r2)
 d01af28:	d019af00 	call	d019af0 <alt_avalon_sgdma_open>
 d01af2c:	e0bff615 	stw	r2,-40(fp)
   
   if(!sgdma_tx_dev) {
 d01af30:	e0bff617 	ldw	r2,-40(fp)
 d01af34:	1004c03a 	cmpne	r2,r2,zero
 d01af38:	1000061e 	bne	r2,zero,d01af54 <tse_mac_init+0x11c>
      dprintf("[triple_speed_ethernet_init] Error opening TX SGDMA\n");
 d01af3c:	01034174 	movhi	r4,3333
 d01af40:	2139ee04 	addi	r4,r4,-6216
 d01af44:	d002bc80 	call	d002bc8 <puts>
      return ENP_RESOURCE;
 d01af48:	00bffa84 	movi	r2,-22
 d01af4c:	e0bfff15 	stw	r2,-4(fp)
 d01af50:	00029c06 	br	d01b9c4 <tse_mac_init+0xb8c>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 d01af54:	e0bff417 	ldw	r2,-48(fp)
 d01af58:	11000617 	ldw	r4,24(r2)
 d01af5c:	d019af00 	call	d019af0 <alt_avalon_sgdma_open>
 d01af60:	e0bff515 	stw	r2,-44(fp)
   if(!sgdma_rx_dev) {
 d01af64:	e0bff517 	ldw	r2,-44(fp)
 d01af68:	1004c03a 	cmpne	r2,r2,zero
 d01af6c:	1000061e 	bne	r2,zero,d01af88 <tse_mac_init+0x150>
      dprintf("[triple_speed_ethernet_init] Error opening RX SGDMA\n");
 d01af70:	01034174 	movhi	r4,3333
 d01af74:	2139fb04 	addi	r4,r4,-6164
 d01af78:	d002bc80 	call	d002bc8 <puts>
      return ENP_RESOURCE;
 d01af7c:	00bffa84 	movi	r2,-22
 d01af80:	e0bfff15 	stw	r2,-4(fp)
 d01af84:	00028f06 	br	d01b9c4 <tse_mac_init+0xb8c>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 d01af88:	e13ffe17 	ldw	r4,-8(fp)
 d01af8c:	01401304 	movi	r5,76
 d01af90:	d00235c0 	call	d00235c <__mulsi3>
 d01af94:	10c00104 	addi	r3,r2,4
 d01af98:	008341b4 	movhi	r2,3334
 d01af9c:	10820904 	addi	r2,r2,2084
 d01afa0:	1889883a 	add	r4,r3,r2
 d01afa4:	e0bff417 	ldw	r2,-48(fp)
 d01afa8:	11400017 	ldw	r5,0(r2)
 d01afac:	e0bff617 	ldw	r2,-40(fp)
 d01afb0:	100d883a 	mov	r6,r2
 d01afb4:	e0bff517 	ldw	r2,-44(fp)
 d01afb8:	100f883a 	mov	r7,r2
 d01afbc:	d8000015 	stw	zero,0(sp)
 d01afc0:	d0372b40 	call	d0372b4 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 d01afc4:	e13ffe17 	ldw	r4,-8(fp)
 d01afc8:	040341b4 	movhi	r16,3334
 d01afcc:	84020904 	addi	r16,r16,2084
 d01afd0:	01401304 	movi	r5,76
 d01afd4:	d00235c0 	call	d00235c <__mulsi3>
 d01afd8:	1405883a 	add	r2,r2,r16
 d01afdc:	10800304 	addi	r2,r2,12
 d01afe0:	10800017 	ldw	r2,0(r2)
 d01afe4:	10800317 	ldw	r2,12(r2)
 d01afe8:	10800404 	addi	r2,r2,16
 d01afec:	1007883a 	mov	r3,r2
 d01aff0:	00800074 	movhi	r2,1
 d01aff4:	18800035 	stwio	r2,0(r3)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 d01aff8:	e13ffe17 	ldw	r4,-8(fp)
 d01affc:	040341b4 	movhi	r16,3334
 d01b000:	84020904 	addi	r16,r16,2084
 d01b004:	01401304 	movi	r5,76
 d01b008:	d00235c0 	call	d00235c <__mulsi3>
 d01b00c:	1405883a 	add	r2,r2,r16
 d01b010:	10800304 	addi	r2,r2,12
 d01b014:	10800017 	ldw	r2,0(r2)
 d01b018:	10800317 	ldw	r2,12(r2)
 d01b01c:	10800404 	addi	r2,r2,16
 d01b020:	10000035 	stwio	zero,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 d01b024:	e13ffe17 	ldw	r4,-8(fp)
 d01b028:	e0bff417 	ldw	r2,-48(fp)
 d01b02c:	1080070b 	ldhu	r2,28(r2)
 d01b030:	147fffcc 	andi	r17,r2,65535
 d01b034:	040341b4 	movhi	r16,3334
 d01b038:	84020904 	addi	r16,r16,2084
 d01b03c:	01401304 	movi	r5,76
 d01b040:	d00235c0 	call	d00235c <__mulsi3>
 d01b044:	1405883a 	add	r2,r2,r16
 d01b048:	10800904 	addi	r2,r2,36
 d01b04c:	14400015 	stw	r17,0(r2)
   ifp = tse[iface].netp;
 d01b050:	e13ffe17 	ldw	r4,-8(fp)
 d01b054:	040341b4 	movhi	r16,3334
 d01b058:	84020904 	addi	r16,r16,2084
 d01b05c:	01401304 	movi	r5,76
 d01b060:	d00235c0 	call	d00235c <__mulsi3>
 d01b064:	1405883a 	add	r2,r2,r16
 d01b068:	10800804 	addi	r2,r2,32
 d01b06c:	10800017 	ldw	r2,0(r2)
 d01b070:	e0bff715 	stw	r2,-36(fp)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 d01b074:	e13ffe17 	ldw	r4,-8(fp)
 d01b078:	040341b4 	movhi	r16,3334
 d01b07c:	84020904 	addi	r16,r16,2084
 d01b080:	01401304 	movi	r5,76
 d01b084:	d00235c0 	call	d00235c <__mulsi3>
 d01b088:	1405883a 	add	r2,r2,r16
 d01b08c:	10800104 	addi	r2,r2,4
 d01b090:	11000017 	ldw	r4,0(r2)
 d01b094:	d0388a80 	call	d0388a8 <getPHYSpeed>
 d01b098:	e0bffa15 	stw	r2,-24(fp)
   speed = (result >> 1) & 0x07;
 d01b09c:	e0bffa17 	ldw	r2,-24(fp)
 d01b0a0:	1005d07a 	srai	r2,r2,1
 d01b0a4:	108001cc 	andi	r2,r2,7
 d01b0a8:	e0bffc15 	stw	r2,-16(fp)
   duplex = result & 0x01;
 d01b0ac:	e0bffa17 	ldw	r2,-24(fp)
 d01b0b0:	1080004c 	andi	r2,r2,1
 d01b0b4:	e0bffb15 	stw	r2,-20(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 d01b0b8:	e13ffe17 	ldw	r4,-8(fp)
 d01b0bc:	040341b4 	movhi	r16,3334
 d01b0c0:	84020904 	addi	r16,r16,2084
 d01b0c4:	01401304 	movi	r5,76
 d01b0c8:	d00235c0 	call	d00235c <__mulsi3>
 d01b0cc:	1405883a 	add	r2,r2,r16
 d01b0d0:	10800104 	addi	r2,r2,4
 d01b0d4:	10800017 	ldw	r2,0(r2)
 d01b0d8:	10800204 	addi	r2,r2,8
 d01b0dc:	1007883a 	mov	r3,r2
 d01b0e0:	008800c4 	movi	r2,8195
 d01b0e4:	18800035 	stwio	r2,0(r3)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 d01b0e8:	e03ff915 	stw	zero,-28(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 d01b0ec:	00000906 	br	d01b114 <tse_mac_init+0x2dc>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 d01b0f0:	e0bff917 	ldw	r2,-28(fp)
 d01b0f4:	1089c448 	cmpgei	r2,r2,10001
 d01b0f8:	1007883a 	mov	r3,r2
 d01b0fc:	e0bff917 	ldw	r2,-28(fp)
 d01b100:	10800044 	addi	r2,r2,1
 d01b104:	e0bff915 	stw	r2,-28(fp)
 d01b108:	18803fcc 	andi	r2,r3,255
 d01b10c:	1004c03a 	cmpne	r2,r2,zero
 d01b110:	10000d1e 	bne	r2,zero,d01b148 <tse_mac_init+0x310>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 d01b114:	e13ffe17 	ldw	r4,-8(fp)
 d01b118:	040341b4 	movhi	r16,3334
 d01b11c:	84020904 	addi	r16,r16,2084
 d01b120:	01401304 	movi	r5,76
 d01b124:	d00235c0 	call	d00235c <__mulsi3>
 d01b128:	1405883a 	add	r2,r2,r16
 d01b12c:	10800104 	addi	r2,r2,4
 d01b130:	10800017 	ldw	r2,0(r2)
 d01b134:	10800204 	addi	r2,r2,8
 d01b138:	10800037 	ldwio	r2,0(r2)
 d01b13c:	1088000c 	andi	r2,r2,8192
 d01b140:	1004c03a 	cmpne	r2,r2,zero
 d01b144:	103fea1e 	bne	r2,zero,d01b0f0 <tse_mac_init+0x2b8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
     }
   }
   if(x >= 10000) {
 d01b148:	e0bff917 	ldw	r2,-28(fp)
 d01b14c:	1089c410 	cmplti	r2,r2,10000
 d01b150:	1000031e 	bne	r2,zero,d01b160 <tse_mac_init+0x328>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 d01b154:	01034174 	movhi	r4,3333
 d01b158:	213a0804 	addi	r4,r4,-6112
 d01b15c:	d002bc80 	call	d002bc8 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 d01b160:	e13ffe17 	ldw	r4,-8(fp)
 d01b164:	040341b4 	movhi	r16,3334
 d01b168:	84020904 	addi	r16,r16,2084
 d01b16c:	01401304 	movi	r5,76
 d01b170:	d00235c0 	call	d00235c <__mulsi3>
 d01b174:	1405883a 	add	r2,r2,r16
 d01b178:	10800104 	addi	r2,r2,4
 d01b17c:	10800017 	ldw	r2,0(r2)
 d01b180:	10800204 	addi	r2,r2,8
 d01b184:	10800037 	ldwio	r2,0(r2)
 d01b188:	e0bffd15 	stw	r2,-12(fp)
   if( (dat & 0x03) != 0 ) {
 d01b18c:	e0bffd17 	ldw	r2,-12(fp)
 d01b190:	108000cc 	andi	r2,r2,3
 d01b194:	1005003a 	cmpeq	r2,r2,zero
 d01b198:	1000051e 	bne	r2,zero,d01b1b0 <tse_mac_init+0x378>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 d01b19c:	01034174 	movhi	r4,3333
 d01b1a0:	213a1104 	addi	r4,r4,-6076
 d01b1a4:	e17ffd17 	ldw	r5,-12(fp)
 d01b1a8:	d0028a00 	call	d0028a0 <printf>
 d01b1ac:	00000506 	br	d01b1c4 <tse_mac_init+0x38c>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 d01b1b0:	01034174 	movhi	r4,3333
 d01b1b4:	213a2504 	addi	r4,r4,-5996
 d01b1b8:	e17ff917 	ldw	r5,-28(fp)
 d01b1bc:	e1bffd17 	ldw	r6,-12(fp)
 d01b1c0:	d0028a00 	call	d0028a0 <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 d01b1c4:	e0bff417 	ldw	r2,-48(fp)
 d01b1c8:	10800903 	ldbu	r2,36(r2)
 d01b1cc:	10803fcc 	andi	r2,r2,255
 d01b1d0:	10800058 	cmpnei	r2,r2,1
 d01b1d4:	1000361e 	bne	r2,zero,d01b2b0 <tse_mac_init+0x478>
      int channel_loop = 0;
 d01b1d8:	e03ff215 	stw	zero,-56(fp)
      int mac_loop = 0;
 d01b1dc:	e03ff115 	stw	zero,-60(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 d01b1e0:	e03ff215 	stw	zero,-56(fp)
 d01b1e4:	00002c06 	br	d01b298 <tse_mac_init+0x460>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 d01b1e8:	e03ff115 	stw	zero,-60(fp)
 d01b1ec:	00001c06 	br	d01b260 <tse_mac_init+0x428>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 d01b1f0:	e0bff217 	ldw	r2,-56(fp)
 d01b1f4:	00c341b4 	movhi	r3,3334
 d01b1f8:	18c50204 	addi	r3,r3,5128
 d01b1fc:	1085883a 	add	r2,r2,r2
 d01b200:	1085883a 	add	r2,r2,r2
 d01b204:	10c5883a 	add	r2,r2,r3
 d01b208:	10c00017 	ldw	r3,0(r2)
 d01b20c:	e0bff117 	ldw	r2,-60(fp)
 d01b210:	1085883a 	add	r2,r2,r2
 d01b214:	1085883a 	add	r2,r2,r2
 d01b218:	10c5883a 	add	r2,r2,r3
 d01b21c:	10800104 	addi	r2,r2,4
 d01b220:	10800017 	ldw	r2,0(r2)
 d01b224:	10c00217 	ldw	r3,8(r2)
 d01b228:	e0bff417 	ldw	r2,-48(fp)
 d01b22c:	1880091e 	bne	r3,r2,d01b254 <tse_mac_init+0x41c>
            tse[iface].channel = mac_loop;
 d01b230:	e13ffe17 	ldw	r4,-8(fp)
 d01b234:	040341b4 	movhi	r16,3334
 d01b238:	84020904 	addi	r16,r16,2084
 d01b23c:	01401304 	movi	r5,76
 d01b240:	d00235c0 	call	d00235c <__mulsi3>
 d01b244:	1405883a 	add	r2,r2,r16
 d01b248:	10c00d04 	addi	r3,r2,52
 d01b24c:	e0bff117 	ldw	r2,-60(fp)
 d01b250:	18800015 	stw	r2,0(r3)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 d01b254:	e0bff117 	ldw	r2,-60(fp)
 d01b258:	10800044 	addi	r2,r2,1
 d01b25c:	e0bff115 	stw	r2,-60(fp)
 d01b260:	e0bff217 	ldw	r2,-56(fp)
 d01b264:	00c341b4 	movhi	r3,3334
 d01b268:	18c50204 	addi	r3,r3,5128
 d01b26c:	1085883a 	add	r2,r2,r2
 d01b270:	1085883a 	add	r2,r2,r2
 d01b274:	10c5883a 	add	r2,r2,r3
 d01b278:	10800017 	ldw	r2,0(r2)
 d01b27c:	10800003 	ldbu	r2,0(r2)
 d01b280:	10c03fcc 	andi	r3,r2,255
 d01b284:	e0bff117 	ldw	r2,-60(fp)
 d01b288:	10ffd916 	blt	r2,r3,d01b1f0 <tse_mac_init+0x3b8>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 d01b28c:	e0bff217 	ldw	r2,-56(fp)
 d01b290:	10800044 	addi	r2,r2,1
 d01b294:	e0bff215 	stw	r2,-56(fp)
 d01b298:	00834174 	movhi	r2,3333
 d01b29c:	109b5744 	addi	r2,r2,27997
 d01b2a0:	10800003 	ldbu	r2,0(r2)
 d01b2a4:	10c03fcc 	andi	r3,r2,255
 d01b2a8:	e0bff217 	ldw	r2,-56(fp)
 d01b2ac:	10ffce16 	blt	r2,r3,d01b1e8 <tse_mac_init+0x3b0>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 d01b2b0:	e0bff417 	ldw	r2,-48(fp)
 d01b2b4:	10800903 	ldbu	r2,36(r2)
 d01b2b8:	10803fcc 	andi	r2,r2,255
 d01b2bc:	10800058 	cmpnei	r2,r2,1
 d01b2c0:	1000121e 	bne	r2,zero,d01b30c <tse_mac_init+0x4d4>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 d01b2c4:	e0bff417 	ldw	r2,-48(fp)
 d01b2c8:	10800d17 	ldw	r2,52(r2)
 d01b2cc:	1009883a 	mov	r4,r2
 d01b2d0:	e0bff417 	ldw	r2,-48(fp)
 d01b2d4:	10800f17 	ldw	r2,60(r2)
 d01b2d8:	1007883a 	mov	r3,r2
 d01b2dc:	2005883a 	mov	r2,r4
 d01b2e0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 d01b2e4:	e0bff417 	ldw	r2,-48(fp)
 d01b2e8:	10800d17 	ldw	r2,52(r2)
 d01b2ec:	11000204 	addi	r4,r2,8
 d01b2f0:	e0bff417 	ldw	r2,-48(fp)
 d01b2f4:	10800f17 	ldw	r2,60(r2)
 d01b2f8:	10bfdd04 	addi	r2,r2,-140
 d01b2fc:	1007883a 	mov	r3,r2
 d01b300:	2005883a 	mov	r2,r4
 d01b304:	10c00035 	stwio	r3,0(r2)
 d01b308:	00006e06 	br	d01b4c4 <tse_mac_init+0x68c>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 d01b30c:	e13ffe17 	ldw	r4,-8(fp)
 d01b310:	040341b4 	movhi	r16,3334
 d01b314:	84020904 	addi	r16,r16,2084
 d01b318:	01401304 	movi	r5,76
 d01b31c:	d00235c0 	call	d00235c <__mulsi3>
 d01b320:	1405883a 	add	r2,r2,r16
 d01b324:	10800104 	addi	r2,r2,4
 d01b328:	10800017 	ldw	r2,0(r2)
 d01b32c:	10800504 	addi	r2,r2,20
 d01b330:	1007883a 	mov	r3,r2
 d01b334:	00817b84 	movi	r2,1518
 d01b338:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 d01b33c:	e13ffe17 	ldw	r4,-8(fp)
 d01b340:	040341b4 	movhi	r16,3334
 d01b344:	84020904 	addi	r16,r16,2084
 d01b348:	01401304 	movi	r5,76
 d01b34c:	d00235c0 	call	d00235c <__mulsi3>
 d01b350:	1405883a 	add	r2,r2,r16
 d01b354:	10800104 	addi	r2,r2,4
 d01b358:	10800017 	ldw	r2,0(r2)
 d01b35c:	10800b04 	addi	r2,r2,44
 d01b360:	1007883a 	mov	r3,r2
 d01b364:	00800204 	movi	r2,8
 d01b368:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 d01b36c:	e13ffe17 	ldw	r4,-8(fp)
 d01b370:	040341b4 	movhi	r16,3334
 d01b374:	84020904 	addi	r16,r16,2084
 d01b378:	01401304 	movi	r5,76
 d01b37c:	d00235c0 	call	d00235c <__mulsi3>
 d01b380:	1405883a 	add	r2,r2,r16
 d01b384:	10800104 	addi	r2,r2,4
 d01b388:	10800017 	ldw	r2,0(r2)
 d01b38c:	10800c04 	addi	r2,r2,48
 d01b390:	1007883a 	mov	r3,r2
 d01b394:	00800204 	movi	r2,8
 d01b398:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 d01b39c:	e13ffe17 	ldw	r4,-8(fp)
 d01b3a0:	040341b4 	movhi	r16,3334
 d01b3a4:	84020904 	addi	r16,r16,2084
 d01b3a8:	01401304 	movi	r5,76
 d01b3ac:	d00235c0 	call	d00235c <__mulsi3>
 d01b3b0:	1405883a 	add	r2,r2,r16
 d01b3b4:	10800104 	addi	r2,r2,4
 d01b3b8:	10800017 	ldw	r2,0(r2)
 d01b3bc:	10800d04 	addi	r2,r2,52
 d01b3c0:	1007883a 	mov	r3,r2
 d01b3c4:	00800204 	movi	r2,8
 d01b3c8:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 d01b3cc:	e13ffe17 	ldw	r4,-8(fp)
 d01b3d0:	040341b4 	movhi	r16,3334
 d01b3d4:	84020904 	addi	r16,r16,2084
 d01b3d8:	01401304 	movi	r5,76
 d01b3dc:	d00235c0 	call	d00235c <__mulsi3>
 d01b3e0:	1405883a 	add	r2,r2,r16
 d01b3e4:	10800104 	addi	r2,r2,4
 d01b3e8:	10800017 	ldw	r2,0(r2)
 d01b3ec:	10800e04 	addi	r2,r2,56
 d01b3f0:	1007883a 	mov	r3,r2
 d01b3f4:	008000c4 	movi	r2,3
 d01b3f8:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 d01b3fc:	e13ffe17 	ldw	r4,-8(fp)
 d01b400:	040341b4 	movhi	r16,3334
 d01b404:	84020904 	addi	r16,r16,2084
 d01b408:	01401304 	movi	r5,76
 d01b40c:	d00235c0 	call	d00235c <__mulsi3>
 d01b410:	1405883a 	add	r2,r2,r16
 d01b414:	10800104 	addi	r2,r2,4
 d01b418:	10800017 	ldw	r2,0(r2)
 d01b41c:	11000904 	addi	r4,r2,36
 d01b420:	e0bff417 	ldw	r2,-48(fp)
 d01b424:	1080010b 	ldhu	r2,4(r2)
 d01b428:	10bfffcc 	andi	r2,r2,65535
 d01b42c:	10fffc04 	addi	r3,r2,-16
 d01b430:	2005883a 	mov	r2,r4
 d01b434:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 d01b438:	e13ffe17 	ldw	r4,-8(fp)
 d01b43c:	040341b4 	movhi	r16,3334
 d01b440:	84020904 	addi	r16,r16,2084
 d01b444:	01401304 	movi	r5,76
 d01b448:	d00235c0 	call	d00235c <__mulsi3>
 d01b44c:	1405883a 	add	r2,r2,r16
 d01b450:	10800104 	addi	r2,r2,4
 d01b454:	10800017 	ldw	r2,0(r2)
 d01b458:	10800a04 	addi	r2,r2,40
 d01b45c:	10000035 	stwio	zero,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 d01b460:	e13ffe17 	ldw	r4,-8(fp)
 d01b464:	040341b4 	movhi	r16,3334
 d01b468:	84020904 	addi	r16,r16,2084
 d01b46c:	01401304 	movi	r5,76
 d01b470:	d00235c0 	call	d00235c <__mulsi3>
 d01b474:	1405883a 	add	r2,r2,r16
 d01b478:	10800104 	addi	r2,r2,4
 d01b47c:	10800017 	ldw	r2,0(r2)
 d01b480:	11000704 	addi	r4,r2,28
 d01b484:	e0bff417 	ldw	r2,-48(fp)
 d01b488:	1080018b 	ldhu	r2,6(r2)
 d01b48c:	10bfffcc 	andi	r2,r2,65535
 d01b490:	10fffc04 	addi	r3,r2,-16
 d01b494:	2005883a 	mov	r2,r4
 d01b498:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 d01b49c:	e13ffe17 	ldw	r4,-8(fp)
 d01b4a0:	040341b4 	movhi	r16,3334
 d01b4a4:	84020904 	addi	r16,r16,2084
 d01b4a8:	01401304 	movi	r5,76
 d01b4ac:	d00235c0 	call	d00235c <__mulsi3>
 d01b4b0:	1405883a 	add	r2,r2,r16
 d01b4b4:	10800104 	addi	r2,r2,4
 d01b4b8:	10800017 	ldw	r2,0(r2)
 d01b4bc:	10800804 	addi	r2,r2,32
 d01b4c0:	10000035 	stwio	zero,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 d01b4c4:	e13ffe17 	ldw	r4,-8(fp)
 d01b4c8:	040341b4 	movhi	r16,3334
 d01b4cc:	84020904 	addi	r16,r16,2084
 d01b4d0:	01401304 	movi	r5,76
 d01b4d4:	d00235c0 	call	d00235c <__mulsi3>
 d01b4d8:	1405883a 	add	r2,r2,r16
 d01b4dc:	10800104 	addi	r2,r2,4
 d01b4e0:	10800017 	ldw	r2,0(r2)
 d01b4e4:	10803a04 	addi	r2,r2,232
 d01b4e8:	1007883a 	mov	r3,r2
 d01b4ec:	00800134 	movhi	r2,4
 d01b4f0:	18800035 	stwio	r2,0(r3)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 d01b4f4:	e13ffe17 	ldw	r4,-8(fp)
 d01b4f8:	040341b4 	movhi	r16,3334
 d01b4fc:	84020904 	addi	r16,r16,2084
 d01b500:	01401304 	movi	r5,76
 d01b504:	d00235c0 	call	d00235c <__mulsi3>
 d01b508:	1405883a 	add	r2,r2,r16
 d01b50c:	10800104 	addi	r2,r2,4
 d01b510:	10800017 	ldw	r2,0(r2)
 d01b514:	10803a04 	addi	r2,r2,232
 d01b518:	10800037 	ldwio	r2,0(r2)
 d01b51c:	1080012c 	andhi	r2,r2,4
 d01b520:	1005003a 	cmpeq	r2,r2,zero
 d01b524:	1000231e 	bne	r2,zero,d01b5b4 <tse_mac_init+0x77c>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 d01b528:	e13ffe17 	ldw	r4,-8(fp)
 d01b52c:	040341b4 	movhi	r16,3334
 d01b530:	84020904 	addi	r16,r16,2084
 d01b534:	01401304 	movi	r5,76
 d01b538:	d00235c0 	call	d00235c <__mulsi3>
 d01b53c:	1405883a 	add	r2,r2,r16
 d01b540:	10c00a04 	addi	r3,r2,40
 d01b544:	00800044 	movi	r2,1
 d01b548:	18800015 	stw	r2,0(r3)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 d01b54c:	e13ffe17 	ldw	r4,-8(fp)
 d01b550:	040341b4 	movhi	r16,3334
 d01b554:	84020904 	addi	r16,r16,2084
 d01b558:	01401304 	movi	r5,76
 d01b55c:	d00235c0 	call	d00235c <__mulsi3>
 d01b560:	1405883a 	add	r2,r2,r16
 d01b564:	10800104 	addi	r2,r2,4
 d01b568:	10800017 	ldw	r2,0(r2)
 d01b56c:	10803b04 	addi	r2,r2,236
 d01b570:	1007883a 	mov	r3,r2
 d01b574:	00808034 	movhi	r2,512
 d01b578:	18800035 	stwio	r2,0(r3)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 d01b57c:	e13ffe17 	ldw	r4,-8(fp)
 d01b580:	040341b4 	movhi	r16,3334
 d01b584:	84020904 	addi	r16,r16,2084
 d01b588:	01401304 	movi	r5,76
 d01b58c:	d00235c0 	call	d00235c <__mulsi3>
 d01b590:	1405883a 	add	r2,r2,r16
 d01b594:	10800104 	addi	r2,r2,4
 d01b598:	10800017 	ldw	r2,0(r2)
 d01b59c:	10803b04 	addi	r2,r2,236
 d01b5a0:	10800037 	ldwio	r2,0(r2)
 d01b5a4:	1080802c 	andhi	r2,r2,512
 d01b5a8:	1004c03a 	cmpne	r2,r2,zero
 d01b5ac:	1000101e 	bne	r2,zero,d01b5f0 <tse_mac_init+0x7b8>
 d01b5b0:	00001f06 	br	d01b630 <tse_mac_init+0x7f8>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 d01b5b4:	e13ffe17 	ldw	r4,-8(fp)
 d01b5b8:	040341b4 	movhi	r16,3334
 d01b5bc:	84020904 	addi	r16,r16,2084
 d01b5c0:	01401304 	movi	r5,76
 d01b5c4:	d00235c0 	call	d00235c <__mulsi3>
 d01b5c8:	1405883a 	add	r2,r2,r16
 d01b5cc:	10800a04 	addi	r2,r2,40
 d01b5d0:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 d01b5d4:	01034174 	movhi	r4,3333
 d01b5d8:	213a2d04 	addi	r4,r4,-5964
 d01b5dc:	01400084 	movi	r5,2
 d01b5e0:	d0028a00 	call	d0028a0 <printf>
      return ENP_LOGIC;
 d01b5e4:	00bffd44 	movi	r2,-11
 d01b5e8:	e0bfff15 	stw	r2,-4(fp)
 d01b5ec:	0000f506 	br	d01b9c4 <tse_mac_init+0xb8c>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 d01b5f0:	e13ffe17 	ldw	r4,-8(fp)
 d01b5f4:	040341b4 	movhi	r16,3334
 d01b5f8:	84020904 	addi	r16,r16,2084
 d01b5fc:	01401304 	movi	r5,76
 d01b600:	d00235c0 	call	d00235c <__mulsi3>
 d01b604:	1405883a 	add	r2,r2,r16
 d01b608:	10c00b04 	addi	r3,r2,44
 d01b60c:	00800044 	movi	r2,1
 d01b610:	18800015 	stw	r2,0(r3)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 d01b614:	00810034 	movhi	r2,1024
 d01b618:	108080c4 	addi	r2,r2,515
 d01b61c:	e0bffd15 	stw	r2,-12(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 d01b620:	e0bffc17 	ldw	r2,-16(fp)
 d01b624:	10800060 	cmpeqi	r2,r2,1
 d01b628:	1000101e 	bne	r2,zero,d01b66c <tse_mac_init+0x834>
 d01b62c:	00001806 	br	d01b690 <tse_mac_init+0x858>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 d01b630:	e13ffe17 	ldw	r4,-8(fp)
 d01b634:	040341b4 	movhi	r16,3334
 d01b638:	84020904 	addi	r16,r16,2084
 d01b63c:	01401304 	movi	r5,76
 d01b640:	d00235c0 	call	d00235c <__mulsi3>
 d01b644:	1405883a 	add	r2,r2,r16
 d01b648:	10800b04 	addi	r2,r2,44
 d01b64c:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 d01b650:	01034174 	movhi	r4,3333
 d01b654:	213a4504 	addi	r4,r4,-5868
 d01b658:	01400084 	movi	r5,2
 d01b65c:	d0028a00 	call	d0028a0 <printf>
      return ENP_LOGIC;
 d01b660:	00bffd44 	movi	r2,-11
 d01b664:	e0bfff15 	stw	r2,-4(fp)
 d01b668:	0000d606 	br	d01b9c4 <tse_mac_init+0xb8c>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01b66c:	e0bffd17 	ldw	r2,-12(fp)
 d01b670:	10800214 	ori	r2,r2,8
 d01b674:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d01b678:	e0fffd17 	ldw	r3,-12(fp)
 d01b67c:	00bf8034 	movhi	r2,65024
 d01b680:	10bfffc4 	addi	r2,r2,-1
 d01b684:	1884703a 	and	r2,r3,r2
 d01b688:	e0bffd15 	stw	r2,-12(fp)
 d01b68c:	00002106 	br	d01b714 <tse_mac_init+0x8dc>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 d01b690:	e0bffc17 	ldw	r2,-16(fp)
 d01b694:	10800098 	cmpnei	r2,r2,2
 d01b698:	10000a1e 	bne	r2,zero,d01b6c4 <tse_mac_init+0x88c>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01b69c:	e0fffd17 	ldw	r3,-12(fp)
 d01b6a0:	00bffdc4 	movi	r2,-9
 d01b6a4:	1884703a 	and	r2,r3,r2
 d01b6a8:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d01b6ac:	e0fffd17 	ldw	r3,-12(fp)
 d01b6b0:	00bf8034 	movhi	r2,65024
 d01b6b4:	10bfffc4 	addi	r2,r2,-1
 d01b6b8:	1884703a 	and	r2,r3,r2
 d01b6bc:	e0bffd15 	stw	r2,-12(fp)
 d01b6c0:	00001406 	br	d01b714 <tse_mac_init+0x8dc>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 d01b6c4:	e0bffc17 	ldw	r2,-16(fp)
 d01b6c8:	10800118 	cmpnei	r2,r2,4
 d01b6cc:	1000081e 	bne	r2,zero,d01b6f0 <tse_mac_init+0x8b8>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01b6d0:	e0fffd17 	ldw	r3,-12(fp)
 d01b6d4:	00bffdc4 	movi	r2,-9
 d01b6d8:	1884703a 	and	r2,r3,r2
 d01b6dc:	e0bffd15 	stw	r2,-12(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d01b6e0:	e0bffd17 	ldw	r2,-12(fp)
 d01b6e4:	10808034 	orhi	r2,r2,512
 d01b6e8:	e0bffd15 	stw	r2,-12(fp)
 d01b6ec:	00000906 	br	d01b714 <tse_mac_init+0x8dc>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01b6f0:	e0fffd17 	ldw	r3,-12(fp)
 d01b6f4:	00bffdc4 	movi	r2,-9
 d01b6f8:	1884703a 	and	r2,r3,r2
 d01b6fc:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d01b700:	e0fffd17 	ldw	r3,-12(fp)
 d01b704:	00bf8034 	movhi	r2,65024
 d01b708:	10bfffc4 	addi	r2,r2,-1
 d01b70c:	1884703a 	and	r2,r3,r2
 d01b710:	e0bffd15 	stw	r2,-12(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 d01b714:	e0bffb17 	ldw	r2,-20(fp)
 d01b718:	1004c03a 	cmpne	r2,r2,zero
 d01b71c:	1000041e 	bne	r2,zero,d01b730 <tse_mac_init+0x8f8>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d01b720:	e0bffd17 	ldw	r2,-12(fp)
 d01b724:	10810014 	ori	r2,r2,1024
 d01b728:	e0bffd15 	stw	r2,-12(fp)
 d01b72c:	00000406 	br	d01b740 <tse_mac_init+0x908>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d01b730:	e0bffd17 	ldw	r2,-12(fp)
 d01b734:	00feffc4 	movi	r3,-1025
 d01b738:	10c4703a 	and	r2,r2,r3
 d01b73c:	e0bffd15 	stw	r2,-12(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 d01b740:	e13ffe17 	ldw	r4,-8(fp)
 d01b744:	040341b4 	movhi	r16,3334
 d01b748:	84020904 	addi	r16,r16,2084
 d01b74c:	01401304 	movi	r5,76
 d01b750:	d00235c0 	call	d00235c <__mulsi3>
 d01b754:	1405883a 	add	r2,r2,r16
 d01b758:	10800104 	addi	r2,r2,4
 d01b75c:	10800017 	ldw	r2,0(r2)
 d01b760:	10800204 	addi	r2,r2,8
 d01b764:	1007883a 	mov	r3,r2
 d01b768:	e0bffd17 	ldw	r2,-12(fp)
 d01b76c:	18800035 	stwio	r2,0(r3)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 d01b770:	e13ffe17 	ldw	r4,-8(fp)
 d01b774:	040341b4 	movhi	r16,3334
 d01b778:	84020904 	addi	r16,r16,2084
 d01b77c:	01401304 	movi	r5,76
 d01b780:	d00235c0 	call	d00235c <__mulsi3>
 d01b784:	1405883a 	add	r2,r2,r16
 d01b788:	10800104 	addi	r2,r2,4
 d01b78c:	10800017 	ldw	r2,0(r2)
 d01b790:	10800204 	addi	r2,r2,8
 d01b794:	11400037 	ldwio	r5,0(r2)
 d01b798:	01034174 	movhi	r4,3333
 d01b79c:	213a5d04 	addi	r4,r4,-5772
 d01b7a0:	d0028a00 	call	d0028a0 <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 d01b7a4:	e13ffe17 	ldw	r4,-8(fp)
 d01b7a8:	040341b4 	movhi	r16,3334
 d01b7ac:	84020904 	addi	r16,r16,2084
 d01b7b0:	01401304 	movi	r5,76
 d01b7b4:	d00235c0 	call	d00235c <__mulsi3>
 d01b7b8:	1405883a 	add	r2,r2,r16
 d01b7bc:	10800104 	addi	r2,r2,4
 d01b7c0:	10800017 	ldw	r2,0(r2)
 d01b7c4:	14400304 	addi	r17,r2,12
 d01b7c8:	e13ffe17 	ldw	r4,-8(fp)
 d01b7cc:	040341b4 	movhi	r16,3334
 d01b7d0:	84020904 	addi	r16,r16,2084
 d01b7d4:	01401304 	movi	r5,76
 d01b7d8:	d00235c0 	call	d00235c <__mulsi3>
 d01b7dc:	1405883a 	add	r2,r2,r16
 d01b7e0:	10800604 	addi	r2,r2,24
 d01b7e4:	10800003 	ldbu	r2,0(r2)
 d01b7e8:	14803fcc 	andi	r18,r2,255
 d01b7ec:	e13ffe17 	ldw	r4,-8(fp)
 d01b7f0:	040341b4 	movhi	r16,3334
 d01b7f4:	84020904 	addi	r16,r16,2084
 d01b7f8:	01401304 	movi	r5,76
 d01b7fc:	d00235c0 	call	d00235c <__mulsi3>
 d01b800:	1405883a 	add	r2,r2,r16
 d01b804:	10800644 	addi	r2,r2,25
 d01b808:	10800003 	ldbu	r2,0(r2)
 d01b80c:	10803fcc 	andi	r2,r2,255
 d01b810:	1004923a 	slli	r2,r2,8
 d01b814:	90a4b03a 	or	r18,r18,r2
 d01b818:	e13ffe17 	ldw	r4,-8(fp)
 d01b81c:	040341b4 	movhi	r16,3334
 d01b820:	84020904 	addi	r16,r16,2084
 d01b824:	01401304 	movi	r5,76
 d01b828:	d00235c0 	call	d00235c <__mulsi3>
 d01b82c:	1405883a 	add	r2,r2,r16
 d01b830:	10800684 	addi	r2,r2,26
 d01b834:	10800003 	ldbu	r2,0(r2)
 d01b838:	10803fcc 	andi	r2,r2,255
 d01b83c:	1004943a 	slli	r2,r2,16
 d01b840:	90a4b03a 	or	r18,r18,r2
 d01b844:	e13ffe17 	ldw	r4,-8(fp)
 d01b848:	040341b4 	movhi	r16,3334
 d01b84c:	84020904 	addi	r16,r16,2084
 d01b850:	01401304 	movi	r5,76
 d01b854:	d00235c0 	call	d00235c <__mulsi3>
 d01b858:	1405883a 	add	r2,r2,r16
 d01b85c:	108006c4 	addi	r2,r2,27
 d01b860:	10800003 	ldbu	r2,0(r2)
 d01b864:	10803fcc 	andi	r2,r2,255
 d01b868:	1004963a 	slli	r2,r2,24
 d01b86c:	9086b03a 	or	r3,r18,r2
 d01b870:	8805883a 	mov	r2,r17
 d01b874:	10c00035 	stwio	r3,0(r2)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 d01b878:	e13ffe17 	ldw	r4,-8(fp)
 d01b87c:	040341b4 	movhi	r16,3334
 d01b880:	84020904 	addi	r16,r16,2084
 d01b884:	01401304 	movi	r5,76
 d01b888:	d00235c0 	call	d00235c <__mulsi3>
 d01b88c:	1405883a 	add	r2,r2,r16
 d01b890:	10800104 	addi	r2,r2,4
 d01b894:	10800017 	ldw	r2,0(r2)
 d01b898:	14400404 	addi	r17,r2,16
 d01b89c:	e13ffe17 	ldw	r4,-8(fp)
 d01b8a0:	040341b4 	movhi	r16,3334
 d01b8a4:	84020904 	addi	r16,r16,2084
 d01b8a8:	01401304 	movi	r5,76
 d01b8ac:	d00235c0 	call	d00235c <__mulsi3>
 d01b8b0:	1405883a 	add	r2,r2,r16
 d01b8b4:	10800704 	addi	r2,r2,28
 d01b8b8:	10800003 	ldbu	r2,0(r2)
 d01b8bc:	14803fcc 	andi	r18,r2,255
 d01b8c0:	e13ffe17 	ldw	r4,-8(fp)
 d01b8c4:	040341b4 	movhi	r16,3334
 d01b8c8:	84020904 	addi	r16,r16,2084
 d01b8cc:	01401304 	movi	r5,76
 d01b8d0:	d00235c0 	call	d00235c <__mulsi3>
 d01b8d4:	1405883a 	add	r2,r2,r16
 d01b8d8:	10800744 	addi	r2,r2,29
 d01b8dc:	10800003 	ldbu	r2,0(r2)
 d01b8e0:	10803fcc 	andi	r2,r2,255
 d01b8e4:	1004923a 	slli	r2,r2,8
 d01b8e8:	9084b03a 	or	r2,r18,r2
 d01b8ec:	10ffffcc 	andi	r3,r2,65535
 d01b8f0:	8805883a 	mov	r2,r17
 d01b8f4:	10c00035 	stwio	r3,0(r2)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 d01b8f8:	e0bffe17 	ldw	r2,-8(fp)
 d01b8fc:	00c341b4 	movhi	r3,3334
 d01b900:	18c31a04 	addi	r3,r3,3176
 d01b904:	1085883a 	add	r2,r2,r2
 d01b908:	1085883a 	add	r2,r2,r2
 d01b90c:	10c5883a 	add	r2,r2,r3
 d01b910:	10800017 	ldw	r2,0(r2)
 d01b914:	10c02717 	ldw	r3,156(r2)
 d01b918:	00800044 	movi	r2,1
 d01b91c:	18800615 	stw	r2,24(r3)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 d01b920:	e0bffe17 	ldw	r2,-8(fp)
 d01b924:	00c341b4 	movhi	r3,3334
 d01b928:	18c31a04 	addi	r3,r3,3176
 d01b92c:	1085883a 	add	r2,r2,r2
 d01b930:	1085883a 	add	r2,r2,r2
 d01b934:	10c5883a 	add	r2,r2,r3
 d01b938:	10800017 	ldw	r2,0(r2)
 d01b93c:	10c02717 	ldw	r3,156(r2)
 d01b940:	00800044 	movi	r2,1
 d01b944:	18800715 	stw	r2,28(r3)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 d01b948:	e13ffe17 	ldw	r4,-8(fp)
 d01b94c:	040341b4 	movhi	r16,3334
 d01b950:	84020904 	addi	r16,r16,2084
 d01b954:	01401304 	movi	r5,76
 d01b958:	d00235c0 	call	d00235c <__mulsi3>
 d01b95c:	1405883a 	add	r2,r2,r16
 d01b960:	10800304 	addi	r2,r2,12
 d01b964:	14000017 	ldw	r16,0(r2)
 d01b968:	e13ffe17 	ldw	r4,-8(fp)
 d01b96c:	01401304 	movi	r5,76
 d01b970:	d00235c0 	call	d00235c <__mulsi3>
 d01b974:	1007883a 	mov	r3,r2
 d01b978:	008341b4 	movhi	r2,3334
 d01b97c:	10820904 	addi	r2,r2,2084
 d01b980:	188f883a 	add	r7,r3,r2
 d01b984:	8009883a 	mov	r4,r16
 d01b988:	014340b4 	movhi	r5,3330
 d01b98c:	296f3804 	addi	r5,r5,-17184
 d01b990:	01800604 	movi	r6,24
 d01b994:	d0199840 	call	d019984 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 d01b998:	e13ffe17 	ldw	r4,-8(fp)
 d01b99c:	01401304 	movi	r5,76
 d01b9a0:	d00235c0 	call	d00235c <__mulsi3>
 d01b9a4:	1007883a 	mov	r3,r2
 d01b9a8:	008341b4 	movhi	r2,3334
 d01b9ac:	10820904 	addi	r2,r2,2084
 d01b9b0:	1889883a 	add	r4,r3,r2
 d01b9b4:	d01bd880 	call	d01bd88 <tse_sgdma_read_init>
 d01b9b8:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 d01b9bc:	e0bff817 	ldw	r2,-32(fp)
 d01b9c0:	e0bfff15 	stw	r2,-4(fp)
 d01b9c4:	e0bfff17 	ldw	r2,-4(fp)
}
 d01b9c8:	e037883a 	mov	sp,fp
 d01b9cc:	dfc00417 	ldw	ra,16(sp)
 d01b9d0:	df000317 	ldw	fp,12(sp)
 d01b9d4:	dc800217 	ldw	r18,8(sp)
 d01b9d8:	dc400117 	ldw	r17,4(sp)
 d01b9dc:	dc000017 	ldw	r16,0(sp)
 d01b9e0:	dec00504 	addi	sp,sp,20
 d01b9e4:	f800283a 	ret

0d01b9e8 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 d01b9e8:	defe6304 	addi	sp,sp,-1652
 d01b9ec:	dfc19c15 	stw	ra,1648(sp)
 d01b9f0:	df019b15 	stw	fp,1644(sp)
 d01b9f4:	df019b04 	addi	fp,sp,1644
 d01b9f8:	e13ffc15 	stw	r4,-16(fp)
 d01b9fc:	e17ffd15 	stw	r5,-12(fp)
 d01ba00:	e1bffe15 	stw	r6,-8(fp)
   int result,i,tx_length;
   unsigned len = data_bytes;
 d01ba04:	e0bffe17 	ldw	r2,-8(fp)
 d01ba08:	e0be7215 	stw	r2,-1592(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 d01ba0c:	e0bffc17 	ldw	r2,-16(fp)
 d01ba10:	10802817 	ldw	r2,160(r2)
 d01ba14:	e0be7115 	stw	r2,-1596(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 d01ba18:	e0be7117 	ldw	r2,-1596(fp)
 d01ba1c:	10801217 	ldw	r2,72(r2)
 d01ba20:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01ba24:	0005303a 	rdctl	r2,status
 d01ba28:	e0be6c15 	stw	r2,-1616(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01ba2c:	e0fe6c17 	ldw	r3,-1616(fp)
 d01ba30:	00bfff84 	movi	r2,-2
 d01ba34:	1884703a 	and	r2,r3,r2
 d01ba38:	1001703a 	wrctl	status,r2
  
  return context;
 d01ba3c:	e0be6c17 	ldw	r2,-1616(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 d01ba40:	e0be6d15 	stw	r2,-1612(fp)
   mi = &tse_ptr->mi;
 d01ba44:	e0be7117 	ldw	r2,-1596(fp)
 d01ba48:	10800104 	addi	r2,r2,4
 d01ba4c:	e0be6f15 	stw	r2,-1604(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 d01ba50:	e0be7117 	ldw	r2,-1596(fp)
 d01ba54:	10800c17 	ldw	r2,48(r2)
 d01ba58:	1005003a 	cmpeq	r2,r2,zero
 d01ba5c:	10000a1e 	bne	r2,zero,d01ba88 <tse_mac_raw_send+0xa0>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 d01ba60:	01034174 	movhi	r4,3333
 d01ba64:	213a6904 	addi	r4,r4,-5724
 d01ba68:	d002bc80 	call	d002bc8 <puts>
 d01ba6c:	e0be6d17 	ldw	r2,-1612(fp)
 d01ba70:	e0be6b15 	stw	r2,-1620(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01ba74:	e0be6b17 	ldw	r2,-1620(fp)
 d01ba78:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 d01ba7c:	00bffa84 	movi	r2,-22
 d01ba80:	e0bfff15 	stw	r2,-4(fp)
 d01ba84:	00009006 	br	d01bcc8 <tse_mac_raw_send+0x2e0>
   }
 
   tse_ptr->sem = 1;  
 d01ba88:	e0fe7117 	ldw	r3,-1596(fp)
 d01ba8c:	00800044 	movi	r2,1
 d01ba90:	18800c15 	stw	r2,48(r3)

   if(((unsigned long)data & 0x03) == 0) 
 d01ba94:	e0bffd17 	ldw	r2,-12(fp)
 d01ba98:	108000cc 	andi	r2,r2,3
 d01ba9c:	1004c03a 	cmpne	r2,r2,zero
 d01baa0:	1000031e 	bne	r2,zero,d01bab0 <tse_mac_raw_send+0xc8>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 d01baa4:	e0bffd17 	ldw	r2,-12(fp)
 d01baa8:	e0be6e15 	stw	r2,-1608(fp)
 d01baac:	00001406 	br	d01bb00 <tse_mac_raw_send+0x118>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 d01bab0:	e03e7415 	stw	zero,-1584(fp)
 d01bab4:	00000d06 	br	d01baec <tse_mac_raw_send+0x104>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 d01bab8:	e13e7417 	ldw	r4,-1584(fp)
 d01babc:	e0be7417 	ldw	r2,-1584(fp)
 d01bac0:	1007883a 	mov	r3,r2
 d01bac4:	e0bffd17 	ldw	r2,-12(fp)
 d01bac8:	1885883a 	add	r2,r3,r2
 d01bacc:	10800023 	ldbuio	r2,0(r2)
 d01bad0:	1007883a 	mov	r3,r2
 d01bad4:	e0be7604 	addi	r2,fp,-1576
 d01bad8:	1105883a 	add	r2,r2,r4
 d01badc:	10c00005 	stb	r3,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 d01bae0:	e0be7417 	ldw	r2,-1584(fp)
 d01bae4:	10800044 	addi	r2,r2,1
 d01bae8:	e0be7415 	stw	r2,-1584(fp)
 d01baec:	e0fe7417 	ldw	r3,-1584(fp)
 d01baf0:	e0be7217 	ldw	r2,-1592(fp)
 d01baf4:	18bff036 	bltu	r3,r2,d01bab8 <tse_mac_raw_send+0xd0>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 d01baf8:	e0be7604 	addi	r2,fp,-1576
 d01bafc:	e0be6e15 	stw	r2,-1608(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 d01bb00:	e13e6e17 	ldw	r4,-1608(fp)
 d01bb04:	01400104 	movi	r5,4
 d01bb08:	d035d4c0 	call	d035d4c <alt_remap_cached>
 d01bb0c:	e0be6e15 	stw	r2,-1608(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 d01bb10:	e0be7017 	ldw	r2,-1600(fp)
 d01bb14:	10800903 	ldbu	r2,36(r2)
 d01bb18:	10803fcc 	andi	r2,r2,255
 d01bb1c:	10800058 	cmpnei	r2,r2,1
 d01bb20:	1000241e 	bne	r2,zero,d01bbb4 <tse_mac_raw_send+0x1cc>
 d01bb24:	e0be7217 	ldw	r2,-1592(fp)
 d01bb28:	108003f0 	cmpltui	r2,r2,15
 d01bb2c:	1000211e 	bne	r2,zero,d01bbb4 <tse_mac_raw_send+0x1cc>
 d01bb30:	e0be7017 	ldw	r2,-1600(fp)
 d01bb34:	10800b17 	ldw	r2,44(r2)
 d01bb38:	1007883a 	mov	r3,r2
 d01bb3c:	e0be7117 	ldw	r2,-1596(fp)
 d01bb40:	10800d17 	ldw	r2,52(r2)
 d01bb44:	1085883a 	add	r2,r2,r2
 d01bb48:	1085883a 	add	r2,r2,r2
 d01bb4c:	1885883a 	add	r2,r3,r2
 d01bb50:	10800037 	ldwio	r2,0(r2)
 d01bb54:	10800388 	cmpgei	r2,r2,14
 d01bb58:	1000161e 	bne	r2,zero,d01bbb4 <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 d01bb5c:	e0be7117 	ldw	r2,-1596(fp)
 d01bb60:	11000f17 	ldw	r4,60(r2)
 d01bb64:	e0be7117 	ldw	r2,-1596(fp)
 d01bb68:	10800f17 	ldw	r2,60(r2)
 d01bb6c:	11400804 	addi	r5,r2,32
 d01bb70:	e1be6e17 	ldw	r6,-1608(fp)
 d01bb74:	e0be7217 	ldw	r2,-1592(fp)
 d01bb78:	11ffffcc 	andi	r7,r2,65535
 d01bb7c:	d8000015 	stw	zero,0(sp)
 d01bb80:	00800044 	movi	r2,1
 d01bb84:	d8800115 	stw	r2,4(sp)
 d01bb88:	00800044 	movi	r2,1
 d01bb8c:	d8800215 	stw	r2,8(sp)
 d01bb90:	d8000315 	stw	zero,12(sp)
 d01bb94:	d01988c0 	call	d01988c <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 d01bb98:	e0be7117 	ldw	r2,-1596(fp)
 d01bb9c:	11400f17 	ldw	r5,60(r2)
 d01bba0:	e13e6f17 	ldw	r4,-1604(fp)
 d01bba4:	d0373140 	call	d037314 <tse_mac_sTxWrite>
 d01bba8:	e0be7315 	stw	r2,-1588(fp)
        result = 0;
 d01bbac:	e03e7515 	stw	zero,-1580(fp)
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 d01bbb0:	00001b06 	br	d01bc20 <tse_mac_raw_send+0x238>
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 d01bbb4:	e0be7217 	ldw	r2,-1592(fp)
 d01bbb8:	108003f0 	cmpltui	r2,r2,15
 d01bbbc:	1000161e 	bne	r2,zero,d01bc18 <tse_mac_raw_send+0x230>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 d01bbc0:	e0be7117 	ldw	r2,-1596(fp)
 d01bbc4:	11000f17 	ldw	r4,60(r2)
 d01bbc8:	e0be7117 	ldw	r2,-1596(fp)
 d01bbcc:	10800f17 	ldw	r2,60(r2)
 d01bbd0:	11400804 	addi	r5,r2,32
 d01bbd4:	e1be6e17 	ldw	r6,-1608(fp)
 d01bbd8:	e0be7217 	ldw	r2,-1592(fp)
 d01bbdc:	11ffffcc 	andi	r7,r2,65535
 d01bbe0:	d8000015 	stw	zero,0(sp)
 d01bbe4:	00800044 	movi	r2,1
 d01bbe8:	d8800115 	stw	r2,4(sp)
 d01bbec:	00800044 	movi	r2,1
 d01bbf0:	d8800215 	stw	r2,8(sp)
 d01bbf4:	d8000315 	stw	zero,12(sp)
 d01bbf8:	d01988c0 	call	d01988c <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 d01bbfc:	e0be7117 	ldw	r2,-1596(fp)
 d01bc00:	11400f17 	ldw	r5,60(r2)
 d01bc04:	e13e6f17 	ldw	r4,-1604(fp)
 d01bc08:	d0373140 	call	d037314 <tse_mac_sTxWrite>
 d01bc0c:	e0be7315 	stw	r2,-1588(fp)
       result = 0;
 d01bc10:	e03e7515 	stw	zero,-1580(fp)
 d01bc14:	00000206 	br	d01bc20 <tse_mac_raw_send+0x238>

   } else {
       result = -3;
 d01bc18:	00bfff44 	movi	r2,-3
 d01bc1c:	e0be7515 	stw	r2,-1580(fp)
   }

   if(result < 0)   /* SGDMA not available */
 d01bc20:	e0be7517 	ldw	r2,-1580(fp)
 d01bc24:	1004403a 	cmpge	r2,r2,zero
 d01bc28:	1000131e 	bne	r2,zero,d01bc78 <tse_mac_raw_send+0x290>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 d01bc2c:	01034174 	movhi	r4,3333
 d01bc30:	213a7004 	addi	r4,r4,-5696
 d01bc34:	e17e7517 	ldw	r5,-1580(fp)
 d01bc38:	e1be7217 	ldw	r6,-1592(fp)
 d01bc3c:	d0028a00 	call	d0028a0 <printf>
      net->n_mib->ifOutDiscards++;
 d01bc40:	e0bffc17 	ldw	r2,-16(fp)
 d01bc44:	10c02717 	ldw	r3,156(r2)
 d01bc48:	18801217 	ldw	r2,72(r3)
 d01bc4c:	10800044 	addi	r2,r2,1
 d01bc50:	18801215 	stw	r2,72(r3)
      tse_ptr->sem = 0;
 d01bc54:	e0be7117 	ldw	r2,-1596(fp)
 d01bc58:	10000c15 	stw	zero,48(r2)
 d01bc5c:	e0be6d17 	ldw	r2,-1612(fp)
 d01bc60:	e0be6a15 	stw	r2,-1624(fp)
 d01bc64:	e0be6a17 	ldw	r2,-1624(fp)
 d01bc68:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 d01bc6c:	00bffa84 	movi	r2,-22
 d01bc70:	e0bfff15 	stw	r2,-4(fp)
 d01bc74:	00001406 	br	d01bcc8 <tse_mac_raw_send+0x2e0>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 d01bc78:	e0bffc17 	ldw	r2,-16(fp)
 d01bc7c:	11002717 	ldw	r4,156(r2)
 d01bc80:	e0bffc17 	ldw	r2,-16(fp)
 d01bc84:	10802717 	ldw	r2,156(r2)
 d01bc88:	10c00f17 	ldw	r3,60(r2)
 d01bc8c:	e0bffe17 	ldw	r2,-8(fp)
 d01bc90:	1885883a 	add	r2,r3,r2
 d01bc94:	20800f15 	stw	r2,60(r4)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 d01bc98:	e0bffc17 	ldw	r2,-16(fp)
 d01bc9c:	10c02717 	ldw	r3,156(r2)
 d01bca0:	18801017 	ldw	r2,64(r3)
 d01bca4:	10800044 	addi	r2,r2,1
 d01bca8:	18801015 	stw	r2,64(r3)
      tse_ptr->sem = 0;
 d01bcac:	e0be7117 	ldw	r2,-1596(fp)
 d01bcb0:	10000c15 	stw	zero,48(r2)
 d01bcb4:	e0be6d17 	ldw	r2,-1612(fp)
 d01bcb8:	e0be6915 	stw	r2,-1628(fp)
 d01bcbc:	e0be6917 	ldw	r2,-1628(fp)
 d01bcc0:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 d01bcc4:	e03fff15 	stw	zero,-4(fp)
 d01bcc8:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d01bccc:	e037883a 	mov	sp,fp
 d01bcd0:	dfc00117 	ldw	ra,4(sp)
 d01bcd4:	df000017 	ldw	fp,0(sp)
 d01bcd8:	dec00204 	addi	sp,sp,8
 d01bcdc:	f800283a 	ret

0d01bce0 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 d01bce0:	defffa04 	addi	sp,sp,-24
 d01bce4:	dfc00515 	stw	ra,20(sp)
 d01bce8:	df000415 	stw	fp,16(sp)
 d01bcec:	df000404 	addi	fp,sp,16
 d01bcf0:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 d01bcf4:	e0bfff17 	ldw	r2,-4(fp)
 d01bcf8:	e0bffe15 	stw	r2,-8(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 d01bcfc:	008341b4 	movhi	r2,3334
 d01bd00:	10825504 	addi	r2,r2,2388
 d01bd04:	10800217 	ldw	r2,8(r2)
 d01bd08:	e0bffc15 	stw	r2,-16(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 d01bd0c:	e0bffe17 	ldw	r2,-8(fp)
 d01bd10:	10800317 	ldw	r2,12(r2)
 d01bd14:	10800317 	ldw	r2,12(r2)
 d01bd18:	10800037 	ldwio	r2,0(r2)
 d01bd1c:	e0bffd05 	stb	r2,-12(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 d01bd20:	e0bffd03 	ldbu	r2,-12(fp)
 d01bd24:	1080030c 	andi	r2,r2,12
 d01bd28:	1005003a 	cmpeq	r2,r2,zero
 d01bd2c:	1000111e 	bne	r2,zero,d01bd74 <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 d01bd30:	e13ffe17 	ldw	r4,-8(fp)
 d01bd34:	d01bf300 	call	d01bf30 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 d01bd38:	e0bffe17 	ldw	r2,-8(fp)
 d01bd3c:	11000317 	ldw	r4,12(r2)
 d01bd40:	e0bffe17 	ldw	r2,-8(fp)
 d01bd44:	10800f17 	ldw	r2,60(r2)
 d01bd48:	11401004 	addi	r5,r2,64
 d01bd4c:	d0194780 	call	d019478 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 d01bd50:	008341b4 	movhi	r2,3334
 d01bd54:	10825504 	addi	r2,r2,2388
 d01bd58:	10c00217 	ldw	r3,8(r2)
 d01bd5c:	e0bffc17 	ldw	r2,-16(fp)
 d01bd60:	10c0040e 	bge	r2,r3,d01bd74 <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 d01bd64:	00834174 	movhi	r2,3333
 d01bd68:	109b4804 	addi	r2,r2,27936
 d01bd6c:	11000017 	ldw	r4,0(r2)
 d01bd70:	d0139400 	call	d013940 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 d01bd74:	e037883a 	mov	sp,fp
 d01bd78:	dfc00117 	ldw	ra,4(sp)
 d01bd7c:	df000017 	ldw	fp,0(sp)
 d01bd80:	dec00204 	addi	sp,sp,8
 d01bd84:	f800283a 	ret

0d01bd88 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 d01bd88:	defff904 	addi	sp,sp,-28
 d01bd8c:	dfc00615 	stw	ra,24(sp)
 d01bd90:	df000515 	stw	fp,20(sp)
 d01bd94:	dc000415 	stw	r16,16(sp)
 d01bd98:	df000404 	addi	fp,sp,16
 d01bd9c:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 d01bda0:	e0bffe17 	ldw	r2,-8(fp)
 d01bda4:	10000e15 	stw	zero,56(r2)
 d01bda8:	00004406 	br	d01bebc <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 d01bdac:	e0bffe17 	ldw	r2,-8(fp)
 d01bdb0:	14000e17 	ldw	r16,56(r2)
 d01bdb4:	01017f04 	movi	r4,1532
 d01bdb8:	d024e0c0 	call	d024e0c <pk_alloc>
 d01bdbc:	1009883a 	mov	r4,r2
 d01bdc0:	e0fffe17 	ldw	r3,-8(fp)
 d01bdc4:	8405883a 	add	r2,r16,r16
 d01bdc8:	1085883a 	add	r2,r2,r2
 d01bdcc:	10c5883a 	add	r2,r2,r3
 d01bdd0:	10801104 	addi	r2,r2,68
 d01bdd4:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 d01bdd8:	e0bffe17 	ldw	r2,-8(fp)
 d01bddc:	10800e17 	ldw	r2,56(r2)
 d01bde0:	e0fffe17 	ldw	r3,-8(fp)
 d01bde4:	1085883a 	add	r2,r2,r2
 d01bde8:	1085883a 	add	r2,r2,r2
 d01bdec:	10c5883a 	add	r2,r2,r3
 d01bdf0:	10801104 	addi	r2,r2,68
 d01bdf4:	10800017 	ldw	r2,0(r2)
 d01bdf8:	1004c03a 	cmpne	r2,r2,zero
 d01bdfc:	10000c1e 	bne	r2,zero,d01be30 <tse_sgdma_read_init+0xa8>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 d01be00:	01034174 	movhi	r4,3333
 d01be04:	213a7c04 	addi	r4,r4,-5648
 d01be08:	d002bc80 	call	d002bc8 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 d01be0c:	e0bffe17 	ldw	r2,-8(fp)
 d01be10:	10800817 	ldw	r2,32(r2)
 d01be14:	10c02717 	ldw	r3,156(r2)
 d01be18:	18800c17 	ldw	r2,48(r3)
 d01be1c:	10800044 	addi	r2,r2,1
 d01be20:	18800c15 	stw	r2,48(r3)
      
      return ENP_NOBUFFER;
 d01be24:	00bffac4 	movi	r2,-21
 d01be28:	e0bfff15 	stw	r2,-4(fp)
 d01be2c:	00003906 	br	d01bf14 <tse_sgdma_read_init+0x18c>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 d01be30:	e0bffe17 	ldw	r2,-8(fp)
 d01be34:	10800e17 	ldw	r2,56(r2)
 d01be38:	e0fffe17 	ldw	r3,-8(fp)
 d01be3c:	1085883a 	add	r2,r2,r2
 d01be40:	1085883a 	add	r2,r2,r2
 d01be44:	10c5883a 	add	r2,r2,r3
 d01be48:	10801104 	addi	r2,r2,68
 d01be4c:	10800017 	ldw	r2,0(r2)
 d01be50:	11000117 	ldw	r4,4(r2)
 d01be54:	01400104 	movi	r5,4
 d01be58:	d035d4c0 	call	d035d4c <alt_remap_cached>
 d01be5c:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 d01be60:	e0bffe17 	ldw	r2,-8(fp)
 d01be64:	10c00f17 	ldw	r3,60(r2)
 d01be68:	e0bffe17 	ldw	r2,-8(fp)
 d01be6c:	10800e17 	ldw	r2,56(r2)
 d01be70:	1004917a 	slli	r2,r2,5
 d01be74:	1885883a 	add	r2,r3,r2
 d01be78:	11001004 	addi	r4,r2,64
 d01be7c:	e0bffe17 	ldw	r2,-8(fp)
 d01be80:	10c00f17 	ldw	r3,60(r2)
 d01be84:	e0bffe17 	ldw	r2,-8(fp)
 d01be88:	10800e17 	ldw	r2,56(r2)
 d01be8c:	1004917a 	slli	r2,r2,5
 d01be90:	1885883a 	add	r2,r3,r2
 d01be94:	11401804 	addi	r5,r2,96
 d01be98:	d8000015 	stw	zero,0(sp)
 d01be9c:	e1bffd17 	ldw	r6,-12(fp)
 d01bea0:	000f883a 	mov	r7,zero
 d01bea4:	d0197c80 	call	d0197c8 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 d01bea8:	e0bffe17 	ldw	r2,-8(fp)
 d01beac:	10800e17 	ldw	r2,56(r2)
 d01beb0:	10c00044 	addi	r3,r2,1
 d01beb4:	e0bffe17 	ldw	r2,-8(fp)
 d01beb8:	10c00e15 	stw	r3,56(r2)
 d01bebc:	e0bffe17 	ldw	r2,-8(fp)
 d01bec0:	10800e17 	ldw	r2,56(r2)
 d01bec4:	10800050 	cmplti	r2,r2,1
 d01bec8:	103fb81e 	bne	r2,zero,d01bdac <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 d01becc:	e0bffe17 	ldw	r2,-8(fp)
 d01bed0:	11400e17 	ldw	r5,56(r2)
 d01bed4:	01034174 	movhi	r4,3333
 d01bed8:	213a8d04 	addi	r4,r4,-5580
 d01bedc:	d0028a00 	call	d0028a0 <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 d01bee0:	e0bffe17 	ldw	r2,-8(fp)
 d01bee4:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 d01bee8:	e0bffe17 	ldw	r2,-8(fp)
 d01beec:	10800f17 	ldw	r2,60(r2)
 d01bef0:	10c01004 	addi	r3,r2,64
 d01bef4:	e0bffe17 	ldw	r2,-8(fp)
 d01bef8:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 d01befc:	e0bffe17 	ldw	r2,-8(fp)
 d01bf00:	11000104 	addi	r4,r2,4
 d01bf04:	e0bffe17 	ldw	r2,-8(fp)
 d01bf08:	11401017 	ldw	r5,64(r2)
 d01bf0c:	d0374040 	call	d037404 <tse_mac_aRxRead>
  
  return SUCCESS;
 d01bf10:	e03fff15 	stw	zero,-4(fp)
 d01bf14:	e0bfff17 	ldw	r2,-4(fp)
}
 d01bf18:	e037883a 	mov	sp,fp
 d01bf1c:	dfc00217 	ldw	ra,8(sp)
 d01bf20:	df000117 	ldw	fp,4(sp)
 d01bf24:	dc000017 	ldw	r16,0(sp)
 d01bf28:	dec00304 	addi	sp,sp,12
 d01bf2c:	f800283a 	ret

0d01bf30 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 d01bf30:	defff704 	addi	sp,sp,-36
 d01bf34:	dfc00815 	stw	ra,32(sp)
 d01bf38:	df000715 	stw	fp,28(sp)
 d01bf3c:	df000704 	addi	fp,sp,28
 d01bf40:	e13fff15 	stw	r4,-4(fp)
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 d01bf44:	e0bfff17 	ldw	r2,-4(fp)
 d01bf48:	10c00f17 	ldw	r3,60(r2)
 d01bf4c:	e0bfff17 	ldw	r2,-4(fp)
 d01bf50:	10800e17 	ldw	r2,56(r2)
 d01bf54:	1004917a 	slli	r2,r2,5
 d01bf58:	1885883a 	add	r2,r3,r2
 d01bf5c:	10c01004 	addi	r3,r2,64
 d01bf60:	e0bfff17 	ldw	r2,-4(fp)
 d01bf64:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 d01bf68:	e0bfff17 	ldw	r2,-4(fp)
 d01bf6c:	10801017 	ldw	r2,64(r2)
 d01bf70:	10800704 	addi	r2,r2,28
 d01bf74:	10800037 	ldwio	r2,0(r2)
 d01bf78:	1005d43a 	srai	r2,r2,16
 d01bf7c:	1007883a 	mov	r3,r2
 d01bf80:	00bfffc4 	movi	r2,-1
 d01bf84:	1884703a 	and	r2,r3,r2
 d01bf88:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 d01bf8c:	e0bfff17 	ldw	r2,-4(fp)
 d01bf90:	10801017 	ldw	r2,64(r2)
 d01bf94:	10800704 	addi	r2,r2,28
 d01bf98:	1080002b 	ldhuio	r2,0(r2)
 d01bf9c:	10bfff84 	addi	r2,r2,-2
 d01bfa0:	e0bffd15 	stw	r2,-12(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 d01bfa4:	e0bfff17 	ldw	r2,-4(fp)
 d01bfa8:	10800817 	ldw	r2,32(r2)
 d01bfac:	11002717 	ldw	r4,156(r2)
 d01bfb0:	e0bfff17 	ldw	r2,-4(fp)
 d01bfb4:	10800817 	ldw	r2,32(r2)
 d01bfb8:	10802717 	ldw	r2,156(r2)
 d01bfbc:	10c00917 	ldw	r3,36(r2)
 d01bfc0:	e0bffd17 	ldw	r2,-12(fp)
 d01bfc4:	1885883a 	add	r2,r3,r2
 d01bfc8:	20800915 	stw	r2,36(r4)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 d01bfcc:	e0bfff17 	ldw	r2,-4(fp)
 d01bfd0:	10800e17 	ldw	r2,56(r2)
 d01bfd4:	e0ffff17 	ldw	r3,-4(fp)
 d01bfd8:	1085883a 	add	r2,r2,r2
 d01bfdc:	1085883a 	add	r2,r2,r2
 d01bfe0:	10c5883a 	add	r2,r2,r3
 d01bfe4:	10801104 	addi	r2,r2,68
 d01bfe8:	10800017 	ldw	r2,0(r2)
 d01bfec:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 d01bff0:	e0bffb17 	ldw	r2,-20(fp)
 d01bff4:	10800117 	ldw	r2,4(r2)
 d01bff8:	10c00404 	addi	r3,r2,16
 d01bffc:	e0bffb17 	ldw	r2,-20(fp)
 d01c000:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 d01c004:	e0bffd17 	ldw	r2,-12(fp)
 d01c008:	10bffc84 	addi	r2,r2,-14
 d01c00c:	1007883a 	mov	r3,r2
 d01c010:	e0bffb17 	ldw	r2,-20(fp)
 d01c014:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 d01c018:	00834174 	movhi	r2,3333
 d01c01c:	109b4504 	addi	r2,r2,27924
 d01c020:	10800017 	ldw	r2,0(r2)
 d01c024:	1007883a 	mov	r3,r2
 d01c028:	e0bffb17 	ldw	r2,-20(fp)
 d01c02c:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 d01c030:	e0bfff17 	ldw	r2,-4(fp)
 d01c034:	10c00817 	ldw	r3,32(r2)
 d01c038:	e0bffb17 	ldw	r2,-20(fp)
 d01c03c:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 d01c040:	e0bffb17 	ldw	r2,-20(fp)
 d01c044:	10800117 	ldw	r2,4(r2)
 d01c048:	10800084 	addi	r2,r2,2
 d01c04c:	e0bffe15 	stw	r2,-8(fp)
    rx_packet->type = eth->e_type;
 d01c050:	e0bffe17 	ldw	r2,-8(fp)
 d01c054:	10c0030b 	ldhu	r3,12(r2)
 d01c058:	e0bffb17 	ldw	r2,-20(fp)
 d01c05c:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 d01c060:	e0bff903 	ldbu	r2,-28(fp)
 d01c064:	10801fcc 	andi	r2,r2,127
 d01c068:	1004c03a 	cmpne	r2,r2,zero
 d01c06c:	1000251e 	bne	r2,zero,d01c104 <tse_mac_rcv+0x1d4>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 d01c070:	01017f04 	movi	r4,1532
 d01c074:	d024e0c0 	call	d024e0c <pk_alloc>
 d01c078:	e0bffc15 	stw	r2,-16(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 d01c07c:	e0bffc17 	ldw	r2,-16(fp)
 d01c080:	1004c03a 	cmpne	r2,r2,zero
 d01c084:	10000a1e 	bne	r2,zero,d01c0b0 <tse_mac_rcv+0x180>
        dprintf("No free buffers for rx\n");
 d01c088:	01034174 	movhi	r4,3333
 d01c08c:	213a9e04 	addi	r4,r4,-5512
 d01c090:	d002bc80 	call	d002bc8 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 d01c094:	e0bfff17 	ldw	r2,-4(fp)
 d01c098:	10800817 	ldw	r2,32(r2)
 d01c09c:	10c02717 	ldw	r3,156(r2)
 d01c0a0:	18800c17 	ldw	r2,48(r3)
 d01c0a4:	10800044 	addi	r2,r2,1
 d01c0a8:	18800c15 	stw	r2,48(r3)
 d01c0ac:	00001806 	br	d01c110 <tse_mac_rcv+0x1e0>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 d01c0b0:	e0bfff17 	ldw	r2,-4(fp)
 d01c0b4:	10800e17 	ldw	r2,56(r2)
 d01c0b8:	e0ffff17 	ldw	r3,-4(fp)
 d01c0bc:	1085883a 	add	r2,r2,r2
 d01c0c0:	1085883a 	add	r2,r2,r2
 d01c0c4:	10c5883a 	add	r2,r2,r3
 d01c0c8:	10801104 	addi	r2,r2,68
 d01c0cc:	11400017 	ldw	r5,0(r2)
 d01c0d0:	010341b4 	movhi	r4,3334
 d01c0d4:	21025504 	addi	r4,r4,2388
 d01c0d8:	d0253e00 	call	d0253e0 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 d01c0dc:	e0bfff17 	ldw	r2,-4(fp)
 d01c0e0:	10800e17 	ldw	r2,56(r2)
 d01c0e4:	e0ffff17 	ldw	r3,-4(fp)
 d01c0e8:	1085883a 	add	r2,r2,r2
 d01c0ec:	1085883a 	add	r2,r2,r2
 d01c0f0:	10c5883a 	add	r2,r2,r3
 d01c0f4:	10c01104 	addi	r3,r2,68
 d01c0f8:	e0bffc17 	ldw	r2,-16(fp)
 d01c0fc:	18800015 	stw	r2,0(r3)
 d01c100:	00000306 	br	d01c110 <tse_mac_rcv+0x1e0>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 d01c104:	01034174 	movhi	r4,3333
 d01c108:	213aa404 	addi	r4,r4,-5488
 d01c10c:	d002bc80 	call	d002bc8 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 d01c110:	e0bfff17 	ldw	r2,-4(fp)
 d01c114:	10800e17 	ldw	r2,56(r2)
 d01c118:	e0ffff17 	ldw	r3,-4(fp)
 d01c11c:	1085883a 	add	r2,r2,r2
 d01c120:	1085883a 	add	r2,r2,r2
 d01c124:	10c5883a 	add	r2,r2,r3
 d01c128:	10801104 	addi	r2,r2,68
 d01c12c:	10800017 	ldw	r2,0(r2)
 d01c130:	11000117 	ldw	r4,4(r2)
 d01c134:	01400104 	movi	r5,4
 d01c138:	d035d4c0 	call	d035d4c <alt_remap_cached>
 d01c13c:	e0bffa15 	stw	r2,-24(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 d01c140:	e0bfff17 	ldw	r2,-4(fp)
 d01c144:	10801017 	ldw	r2,64(r2)
 d01c148:	10800204 	addi	r2,r2,8
 d01c14c:	e0fffa17 	ldw	r3,-24(fp)
 d01c150:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 d01c154:	e0bfff17 	ldw	r2,-4(fp)
 d01c158:	10801017 	ldw	r2,64(r2)
 d01c15c:	10800704 	addi	r2,r2,28
 d01c160:	1007883a 	mov	r3,r2
 d01c164:	00a04034 	movhi	r2,33024
 d01c168:	18800035 	stwio	r2,0(r3)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 d01c16c:	e037883a 	mov	sp,fp
 d01c170:	dfc00117 	ldw	ra,4(sp)
 d01c174:	df000017 	ldw	fp,0(sp)
 d01c178:	dec00204 	addi	sp,sp,8
 d01c17c:	f800283a 	ret

0d01c180 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 d01c180:	defffc04 	addi	sp,sp,-16
 d01c184:	dfc00315 	stw	ra,12(sp)
 d01c188:	df000215 	stw	fp,8(sp)
 d01c18c:	df000204 	addi	fp,sp,8
 d01c190:	e13ffe15 	stw	r4,-8(fp)
 d01c194:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 d01c198:	e13ffe17 	ldw	r4,-8(fp)
 d01c19c:	01434174 	movhi	r5,3333
 d01c1a0:	297ab004 	addi	r5,r5,-5440
 d01c1a4:	d020b640 	call	d020b64 <ns_printf>
   return SUCCESS;
 d01c1a8:	0005883a 	mov	r2,zero
}
 d01c1ac:	e037883a 	mov	sp,fp
 d01c1b0:	dfc00117 	ldw	ra,4(sp)
 d01c1b4:	df000017 	ldw	fp,0(sp)
 d01c1b8:	dec00204 	addi	sp,sp,8
 d01c1bc:	f800283a 	ret

0d01c1c0 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 d01c1c0:	defffb04 	addi	sp,sp,-20
 d01c1c4:	dfc00415 	stw	ra,16(sp)
 d01c1c8:	df000315 	stw	fp,12(sp)
 d01c1cc:	dc000215 	stw	r16,8(sp)
 d01c1d0:	df000204 	addi	fp,sp,8
 d01c1d4:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 d01c1d8:	e0bfff17 	ldw	r2,-4(fp)
 d01c1dc:	00c341b4 	movhi	r3,3334
 d01c1e0:	18c31a04 	addi	r3,r3,3176
 d01c1e4:	1085883a 	add	r2,r2,r2
 d01c1e8:	1085883a 	add	r2,r2,r2
 d01c1ec:	10c5883a 	add	r2,r2,r3
 d01c1f0:	10800017 	ldw	r2,0(r2)
 d01c1f4:	10c02717 	ldw	r3,156(r2)
 d01c1f8:	00800084 	movi	r2,2
 d01c1fc:	18800615 	stw	r2,24(r3)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 d01c200:	e13fff17 	ldw	r4,-4(fp)
 d01c204:	040341b4 	movhi	r16,3334
 d01c208:	84020904 	addi	r16,r16,2084
 d01c20c:	01401304 	movi	r5,76
 d01c210:	d00235c0 	call	d00235c <__mulsi3>
 d01c214:	1405883a 	add	r2,r2,r16
 d01c218:	10800304 	addi	r2,r2,12
 d01c21c:	11000017 	ldw	r4,0(r2)
 d01c220:	000b883a 	mov	r5,zero
 d01c224:	000d883a 	mov	r6,zero
 d01c228:	000f883a 	mov	r7,zero
 d01c22c:	d0199840 	call	d019984 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 d01c230:	e13fff17 	ldw	r4,-4(fp)
 d01c234:	040341b4 	movhi	r16,3334
 d01c238:	84020904 	addi	r16,r16,2084
 d01c23c:	01401304 	movi	r5,76
 d01c240:	d00235c0 	call	d00235c <__mulsi3>
 d01c244:	1405883a 	add	r2,r2,r16
 d01c248:	10800104 	addi	r2,r2,4
 d01c24c:	10800017 	ldw	r2,0(r2)
 d01c250:	10800204 	addi	r2,r2,8
 d01c254:	10800037 	ldwio	r2,0(r2)
 d01c258:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 d01c25c:	e13fff17 	ldw	r4,-4(fp)
 d01c260:	040341b4 	movhi	r16,3334
 d01c264:	84020904 	addi	r16,r16,2084
 d01c268:	01401304 	movi	r5,76
 d01c26c:	d00235c0 	call	d00235c <__mulsi3>
 d01c270:	1405883a 	add	r2,r2,r16
 d01c274:	10800104 	addi	r2,r2,4
 d01c278:	10800017 	ldw	r2,0(r2)
 d01c27c:	11000204 	addi	r4,r2,8
 d01c280:	e0fffe17 	ldw	r3,-8(fp)
 d01c284:	00bfff44 	movi	r2,-3
 d01c288:	1886703a 	and	r3,r3,r2
 d01c28c:	2005883a 	mov	r2,r4
 d01c290:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 d01c294:	e0bfff17 	ldw	r2,-4(fp)
 d01c298:	00c341b4 	movhi	r3,3334
 d01c29c:	18c31a04 	addi	r3,r3,3176
 d01c2a0:	1085883a 	add	r2,r2,r2
 d01c2a4:	1085883a 	add	r2,r2,r2
 d01c2a8:	10c5883a 	add	r2,r2,r3
 d01c2ac:	10800017 	ldw	r2,0(r2)
 d01c2b0:	10c02717 	ldw	r3,156(r2)
 d01c2b4:	00800084 	movi	r2,2
 d01c2b8:	18800715 	stw	r2,28(r3)

  return SUCCESS;
 d01c2bc:	0005883a 	mov	r2,zero
}
 d01c2c0:	e037883a 	mov	sp,fp
 d01c2c4:	dfc00217 	ldw	ra,8(sp)
 d01c2c8:	df000117 	ldw	fp,4(sp)
 d01c2cc:	dc000017 	ldw	r16,0(sp)
 d01c2d0:	dec00304 	addi	sp,sp,12
 d01c2d4:	f800283a 	ret

0d01c2d8 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(tristate_avalon_lcd_16207_state* sp,
  unsigned char command)
{
 d01c2d8:	defffa04 	addi	sp,sp,-24
 d01c2dc:	dfc00515 	stw	ra,20(sp)
 d01c2e0:	df000415 	stw	fp,16(sp)
 d01c2e4:	df000404 	addi	fp,sp,16
 d01c2e8:	e13ffe15 	stw	r4,-8(fp)
 d01c2ec:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 d01c2f0:	e0bffe17 	ldw	r2,-8(fp)
 d01c2f4:	10800017 	ldw	r2,0(r2)
 d01c2f8:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 d01c2fc:	008003f4 	movhi	r2,15
 d01c300:	10909004 	addi	r2,r2,16960
 d01c304:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 d01c308:	e0bffe17 	ldw	r2,-8(fp)
 d01c30c:	10800803 	ldbu	r2,32(r2)
 d01c310:	10803fcc 	andi	r2,r2,255
 d01c314:	1080201c 	xori	r2,r2,128
 d01c318:	10bfe004 	addi	r2,r2,-128
 d01c31c:	1004c03a 	cmpne	r2,r2,zero
 d01c320:	1000161e 	bne	r2,zero,d01c37c <lcd_write_command+0xa4>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_TRISTATE_AVALON_LCD_16207_STATUS(base) & TRISTATE_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d01c324:	00000a06 	br	d01c350 <lcd_write_command+0x78>
    if (--i == 0)
 d01c328:	e0bffc17 	ldw	r2,-16(fp)
 d01c32c:	10bfffc4 	addi	r2,r2,-1
 d01c330:	e0bffc15 	stw	r2,-16(fp)
 d01c334:	e0bffc17 	ldw	r2,-16(fp)
 d01c338:	1004c03a 	cmpne	r2,r2,zero
 d01c33c:	1000041e 	bne	r2,zero,d01c350 <lcd_write_command+0x78>
    {
      sp->broken = 1;
 d01c340:	e0fffe17 	ldw	r3,-8(fp)
 d01c344:	00800044 	movi	r2,1
 d01c348:	18800805 	stb	r2,32(r3)
      return;
 d01c34c:	00000b06 	br	d01c37c <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_TRISTATE_AVALON_LCD_16207_STATUS(base) & TRISTATE_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d01c350:	e0bffd17 	ldw	r2,-12(fp)
 d01c354:	10800104 	addi	r2,r2,4
 d01c358:	10800037 	ldwio	r2,0(r2)
 d01c35c:	1080200c 	andi	r2,r2,128
 d01c360:	1004c03a 	cmpne	r2,r2,zero
 d01c364:	103ff01e 	bne	r2,zero,d01c328 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 d01c368:	01001904 	movi	r4,100
 d01c36c:	d035fd00 	call	d035fd0 <usleep>

  IOWR_TRISTATE_AVALON_LCD_16207_COMMAND(base, command);
 d01c370:	e0bffd17 	ldw	r2,-12(fp)
 d01c374:	e0ffff03 	ldbu	r3,-4(fp)
 d01c378:	10c00035 	stwio	r3,0(r2)
}
 d01c37c:	e037883a 	mov	sp,fp
 d01c380:	dfc00117 	ldw	ra,4(sp)
 d01c384:	df000017 	ldw	fp,0(sp)
 d01c388:	dec00204 	addi	sp,sp,8
 d01c38c:	f800283a 	ret

0d01c390 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(tristate_avalon_lcd_16207_state* sp,
  unsigned char data)
{
 d01c390:	defffa04 	addi	sp,sp,-24
 d01c394:	dfc00515 	stw	ra,20(sp)
 d01c398:	df000415 	stw	fp,16(sp)
 d01c39c:	df000404 	addi	fp,sp,16
 d01c3a0:	e13ffe15 	stw	r4,-8(fp)
 d01c3a4:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 d01c3a8:	e0bffe17 	ldw	r2,-8(fp)
 d01c3ac:	10800017 	ldw	r2,0(r2)
 d01c3b0:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 d01c3b4:	008003f4 	movhi	r2,15
 d01c3b8:	10909004 	addi	r2,r2,16960
 d01c3bc:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 d01c3c0:	e0bffe17 	ldw	r2,-8(fp)
 d01c3c4:	10800803 	ldbu	r2,32(r2)
 d01c3c8:	10803fcc 	andi	r2,r2,255
 d01c3cc:	1080201c 	xori	r2,r2,128
 d01c3d0:	10bfe004 	addi	r2,r2,-128
 d01c3d4:	1004c03a 	cmpne	r2,r2,zero
 d01c3d8:	10001d1e 	bne	r2,zero,d01c450 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_TRISTATE_AVALON_LCD_16207_STATUS(base) & TRISTATE_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d01c3dc:	00000a06 	br	d01c408 <lcd_write_data+0x78>
    if (--i == 0)
 d01c3e0:	e0bffc17 	ldw	r2,-16(fp)
 d01c3e4:	10bfffc4 	addi	r2,r2,-1
 d01c3e8:	e0bffc15 	stw	r2,-16(fp)
 d01c3ec:	e0bffc17 	ldw	r2,-16(fp)
 d01c3f0:	1004c03a 	cmpne	r2,r2,zero
 d01c3f4:	1000041e 	bne	r2,zero,d01c408 <lcd_write_data+0x78>
    {
      sp->broken = 1;
 d01c3f8:	e0fffe17 	ldw	r3,-8(fp)
 d01c3fc:	00800044 	movi	r2,1
 d01c400:	18800805 	stb	r2,32(r3)
      return;
 d01c404:	00001206 	br	d01c450 <lcd_write_data+0xc0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_TRISTATE_AVALON_LCD_16207_STATUS(base) & TRISTATE_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d01c408:	e0bffd17 	ldw	r2,-12(fp)
 d01c40c:	10800104 	addi	r2,r2,4
 d01c410:	10800037 	ldwio	r2,0(r2)
 d01c414:	1080200c 	andi	r2,r2,128
 d01c418:	1004c03a 	cmpne	r2,r2,zero
 d01c41c:	103ff01e 	bne	r2,zero,d01c3e0 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 d01c420:	01001904 	movi	r4,100
 d01c424:	d035fd00 	call	d035fd0 <usleep>

  IOWR_TRISTATE_AVALON_LCD_16207_DATA(base, data);
 d01c428:	e0bffd17 	ldw	r2,-12(fp)
 d01c42c:	10800204 	addi	r2,r2,8
 d01c430:	e0ffff03 	ldbu	r3,-4(fp)
 d01c434:	10c00035 	stwio	r3,0(r2)

  sp->address++;
 d01c438:	e0bffe17 	ldw	r2,-8(fp)
 d01c43c:	108008c3 	ldbu	r2,35(r2)
 d01c440:	10800044 	addi	r2,r2,1
 d01c444:	1007883a 	mov	r3,r2
 d01c448:	e0bffe17 	ldw	r2,-8(fp)
 d01c44c:	10c008c5 	stb	r3,35(r2)
}
 d01c450:	e037883a 	mov	sp,fp
 d01c454:	dfc00117 	ldw	ra,4(sp)
 d01c458:	df000017 	ldw	fp,0(sp)
 d01c45c:	dec00204 	addi	sp,sp,8
 d01c460:	f800283a 	ret

0d01c464 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(tristate_avalon_lcd_16207_state* sp)
{
 d01c464:	defffb04 	addi	sp,sp,-20
 d01c468:	dfc00415 	stw	ra,16(sp)
 d01c46c:	df000315 	stw	fp,12(sp)
 d01c470:	dc000215 	stw	r16,8(sp)
 d01c474:	df000204 	addi	fp,sp,8
 d01c478:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 d01c47c:	e13fff17 	ldw	r4,-4(fp)
 d01c480:	01400044 	movi	r5,1
 d01c484:	d01c2d80 	call	d01c2d8 <lcd_write_command>

  sp->x = 0;
 d01c488:	e0bfff17 	ldw	r2,-4(fp)
 d01c48c:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 d01c490:	e0bfff17 	ldw	r2,-4(fp)
 d01c494:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 d01c498:	e0bfff17 	ldw	r2,-4(fp)
 d01c49c:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01c4a0:	e03ffe15 	stw	zero,-8(fp)
 d01c4a4:	00001c06 	br	d01c518 <lcd_clear_screen+0xb4>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 d01c4a8:	e13ffe17 	ldw	r4,-8(fp)
 d01c4ac:	014018c4 	movi	r5,99
 d01c4b0:	d00235c0 	call	d00235c <__mulsi3>
 d01c4b4:	10c01004 	addi	r3,r2,64
 d01c4b8:	e0bfff17 	ldw	r2,-4(fp)
 d01c4bc:	1889883a 	add	r4,r3,r2
 d01c4c0:	01400804 	movi	r5,32
 d01c4c4:	01801444 	movi	r6,81
 d01c4c8:	d0027880 	call	d002788 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 d01c4cc:	e13ffe17 	ldw	r4,-8(fp)
 d01c4d0:	014018c4 	movi	r5,99
 d01c4d4:	d00235c0 	call	d00235c <__mulsi3>
 d01c4d8:	10c00c04 	addi	r3,r2,48
 d01c4dc:	e0bfff17 	ldw	r2,-4(fp)
 d01c4e0:	1889883a 	add	r4,r3,r2
 d01c4e4:	01400804 	movi	r5,32
 d01c4e8:	01800404 	movi	r6,16
 d01c4ec:	d0027880 	call	d002788 <memset>
    sp->line[y].width = 0;
 d01c4f0:	e13ffe17 	ldw	r4,-8(fp)
 d01c4f4:	e43fff17 	ldw	r16,-4(fp)
 d01c4f8:	014018c4 	movi	r5,99
 d01c4fc:	d00235c0 	call	d00235c <__mulsi3>
 d01c500:	1405883a 	add	r2,r2,r16
 d01c504:	10802404 	addi	r2,r2,144
 d01c508:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01c50c:	e0bffe17 	ldw	r2,-8(fp)
 d01c510:	10800044 	addi	r2,r2,1
 d01c514:	e0bffe15 	stw	r2,-8(fp)
 d01c518:	e0bffe17 	ldw	r2,-8(fp)
 d01c51c:	10800090 	cmplti	r2,r2,2
 d01c520:	103fe11e 	bne	r2,zero,d01c4a8 <lcd_clear_screen+0x44>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 d01c524:	e037883a 	mov	sp,fp
 d01c528:	dfc00217 	ldw	ra,8(sp)
 d01c52c:	df000117 	ldw	fp,4(sp)
 d01c530:	dc000017 	ldw	r16,0(sp)
 d01c534:	dec00304 	addi	sp,sp,12
 d01c538:	f800283a 	ret

0d01c53c <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(tristate_avalon_lcd_16207_state* sp)
{
 d01c53c:	defff404 	addi	sp,sp,-48
 d01c540:	dfc00b15 	stw	ra,44(sp)
 d01c544:	df000a15 	stw	fp,40(sp)
 d01c548:	dc800915 	stw	r18,36(sp)
 d01c54c:	dc400815 	stw	r17,32(sp)
 d01c550:	dc000715 	stw	r16,28(sp)
 d01c554:	df000704 	addi	fp,sp,28
 d01c558:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 d01c55c:	e0bfff17 	ldw	r2,-4(fp)
 d01c560:	10800943 	ldbu	r2,37(r2)
 d01c564:	10803fcc 	andi	r2,r2,255
 d01c568:	1080201c 	xori	r2,r2,128
 d01c56c:	10bfe004 	addi	r2,r2,-128
 d01c570:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01c574:	e03ffe15 	stw	zero,-8(fp)
 d01c578:	00006a06 	br	d01c724 <lcd_repaint_screen+0x1e8>
  {
    int width  = sp->line[y].width;
 d01c57c:	e13ffe17 	ldw	r4,-8(fp)
 d01c580:	e43fff17 	ldw	r16,-4(fp)
 d01c584:	014018c4 	movi	r5,99
 d01c588:	d00235c0 	call	d00235c <__mulsi3>
 d01c58c:	1405883a 	add	r2,r2,r16
 d01c590:	10802404 	addi	r2,r2,144
 d01c594:	10800043 	ldbu	r2,1(r2)
 d01c598:	10803fcc 	andi	r2,r2,255
 d01c59c:	1080201c 	xori	r2,r2,128
 d01c5a0:	10bfe004 	addi	r2,r2,-128
 d01c5a4:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 d01c5a8:	e13ffe17 	ldw	r4,-8(fp)
 d01c5ac:	e43fff17 	ldw	r16,-4(fp)
 d01c5b0:	014018c4 	movi	r5,99
 d01c5b4:	d00235c0 	call	d00235c <__mulsi3>
 d01c5b8:	1405883a 	add	r2,r2,r16
 d01c5bc:	10802404 	addi	r2,r2,144
 d01c5c0:	10800083 	ldbu	r2,2(r2)
 d01c5c4:	11003fcc 	andi	r4,r2,255
 d01c5c8:	e17ffc17 	ldw	r5,-16(fp)
 d01c5cc:	d00235c0 	call	d00235c <__mulsi3>
 d01c5d0:	1005d23a 	srai	r2,r2,8
 d01c5d4:	e0bffa15 	stw	r2,-24(fp)
    if (offset >= width)
 d01c5d8:	e0fffa17 	ldw	r3,-24(fp)
 d01c5dc:	e0bffb17 	ldw	r2,-20(fp)
 d01c5e0:	18800116 	blt	r3,r2,d01c5e8 <lcd_repaint_screen+0xac>
      offset = 0;
 d01c5e4:	e03ffa15 	stw	zero,-24(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 d01c5e8:	e03ffd15 	stw	zero,-12(fp)
 d01c5ec:	00004706 	br	d01c70c <lcd_repaint_screen+0x1d0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 d01c5f0:	e47ffe17 	ldw	r17,-8(fp)
 d01c5f4:	e0fffd17 	ldw	r3,-12(fp)
 d01c5f8:	e0bffa17 	ldw	r2,-24(fp)
 d01c5fc:	1889883a 	add	r4,r3,r2
 d01c600:	e17ffb17 	ldw	r5,-20(fp)
 d01c604:	d00c8ac0 	call	d00c8ac <__modsi3>
 d01c608:	1025883a 	mov	r18,r2
 d01c60c:	e43fff17 	ldw	r16,-4(fp)
 d01c610:	8809883a 	mov	r4,r17
 d01c614:	014018c4 	movi	r5,99
 d01c618:	d00235c0 	call	d00235c <__mulsi3>
 d01c61c:	1405883a 	add	r2,r2,r16
 d01c620:	1485883a 	add	r2,r2,r18
 d01c624:	10801004 	addi	r2,r2,64
 d01c628:	10800003 	ldbu	r2,0(r2)
 d01c62c:	e0bff945 	stb	r2,-27(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 d01c630:	e13ffe17 	ldw	r4,-8(fp)
 d01c634:	e47ffd17 	ldw	r17,-12(fp)
 d01c638:	e43fff17 	ldw	r16,-4(fp)
 d01c63c:	014018c4 	movi	r5,99
 d01c640:	d00235c0 	call	d00235c <__mulsi3>
 d01c644:	1405883a 	add	r2,r2,r16
 d01c648:	1445883a 	add	r2,r2,r17
 d01c64c:	10800c04 	addi	r2,r2,48
 d01c650:	10800003 	ldbu	r2,0(r2)
 d01c654:	10c03fcc 	andi	r3,r2,255
 d01c658:	18c0201c 	xori	r3,r3,128
 d01c65c:	18ffe004 	addi	r3,r3,-128
 d01c660:	e0bff947 	ldb	r2,-27(fp)
 d01c664:	18802626 	beq	r3,r2,d01c700 <lcd_repaint_screen+0x1c4>
      {
        unsigned char address = x + colstart[y];
 d01c668:	e0fffe17 	ldw	r3,-8(fp)
 d01c66c:	d0a02c04 	addi	r2,gp,-32592
 d01c670:	1885883a 	add	r2,r3,r2
 d01c674:	10800003 	ldbu	r2,0(r2)
 d01c678:	1007883a 	mov	r3,r2
 d01c67c:	e0bffd17 	ldw	r2,-12(fp)
 d01c680:	1885883a 	add	r2,r3,r2
 d01c684:	e0bff905 	stb	r2,-28(fp)

        if (address != sp->address)
 d01c688:	e0fff903 	ldbu	r3,-28(fp)
 d01c68c:	e0bfff17 	ldw	r2,-4(fp)
 d01c690:	108008c3 	ldbu	r2,35(r2)
 d01c694:	10803fcc 	andi	r2,r2,255
 d01c698:	1080201c 	xori	r2,r2,128
 d01c69c:	10bfe004 	addi	r2,r2,-128
 d01c6a0:	18800926 	beq	r3,r2,d01c6c8 <lcd_repaint_screen+0x18c>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 d01c6a4:	e0fff903 	ldbu	r3,-28(fp)
 d01c6a8:	00bfe004 	movi	r2,-128
 d01c6ac:	1884b03a 	or	r2,r3,r2
 d01c6b0:	11403fcc 	andi	r5,r2,255
 d01c6b4:	e13fff17 	ldw	r4,-4(fp)
 d01c6b8:	d01c2d80 	call	d01c2d8 <lcd_write_command>
          sp->address = address;
 d01c6bc:	e0fff903 	ldbu	r3,-28(fp)
 d01c6c0:	e0bfff17 	ldw	r2,-4(fp)
 d01c6c4:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 d01c6c8:	e0bff943 	ldbu	r2,-27(fp)
 d01c6cc:	11403fcc 	andi	r5,r2,255
 d01c6d0:	e13fff17 	ldw	r4,-4(fp)
 d01c6d4:	d01c3900 	call	d01c390 <lcd_write_data>
        sp->line[y].visible[x] = c;
 d01c6d8:	e13ffe17 	ldw	r4,-8(fp)
 d01c6dc:	e47ffd17 	ldw	r17,-12(fp)
 d01c6e0:	e43fff17 	ldw	r16,-4(fp)
 d01c6e4:	014018c4 	movi	r5,99
 d01c6e8:	d00235c0 	call	d00235c <__mulsi3>
 d01c6ec:	1405883a 	add	r2,r2,r16
 d01c6f0:	1445883a 	add	r2,r2,r17
 d01c6f4:	10c00c04 	addi	r3,r2,48
 d01c6f8:	e0bff943 	ldbu	r2,-27(fp)
 d01c6fc:	18800005 	stb	r2,0(r3)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 d01c700:	e0bffd17 	ldw	r2,-12(fp)
 d01c704:	10800044 	addi	r2,r2,1
 d01c708:	e0bffd15 	stw	r2,-12(fp)
 d01c70c:	e0bffd17 	ldw	r2,-12(fp)
 d01c710:	10800410 	cmplti	r2,r2,16
 d01c714:	103fb61e 	bne	r2,zero,d01c5f0 <lcd_repaint_screen+0xb4>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01c718:	e0bffe17 	ldw	r2,-8(fp)
 d01c71c:	10800044 	addi	r2,r2,1
 d01c720:	e0bffe15 	stw	r2,-8(fp)
 d01c724:	e0bffe17 	ldw	r2,-8(fp)
 d01c728:	10800090 	cmplti	r2,r2,2
 d01c72c:	103f931e 	bne	r2,zero,d01c57c <lcd_repaint_screen+0x40>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 d01c730:	e037883a 	mov	sp,fp
 d01c734:	dfc00417 	ldw	ra,16(sp)
 d01c738:	df000317 	ldw	fp,12(sp)
 d01c73c:	dc800217 	ldw	r18,8(sp)
 d01c740:	dc400117 	ldw	r17,4(sp)
 d01c744:	dc000017 	ldw	r16,0(sp)
 d01c748:	dec00504 	addi	sp,sp,20
 d01c74c:	f800283a 	ret

0d01c750 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(tristate_avalon_lcd_16207_state* sp)
{
 d01c750:	defffb04 	addi	sp,sp,-20
 d01c754:	dfc00415 	stw	ra,16(sp)
 d01c758:	df000315 	stw	fp,12(sp)
 d01c75c:	dc000215 	stw	r16,8(sp)
 d01c760:	df000204 	addi	fp,sp,8
 d01c764:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01c768:	e03ffe15 	stw	zero,-8(fp)
 d01c76c:	00002106 	br	d01c7f4 <lcd_scroll_up+0xa4>
  {
    if (y < ALT_LCD_HEIGHT-1)
 d01c770:	e0bffe17 	ldw	r2,-8(fp)
 d01c774:	10800048 	cmpgei	r2,r2,1
 d01c778:	1000121e 	bne	r2,zero,d01c7c4 <lcd_scroll_up+0x74>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 d01c77c:	e13ffe17 	ldw	r4,-8(fp)
 d01c780:	014018c4 	movi	r5,99
 d01c784:	d00235c0 	call	d00235c <__mulsi3>
 d01c788:	10c01004 	addi	r3,r2,64
 d01c78c:	e0bfff17 	ldw	r2,-4(fp)
 d01c790:	18a1883a 	add	r16,r3,r2
 d01c794:	e0bffe17 	ldw	r2,-8(fp)
 d01c798:	11000044 	addi	r4,r2,1
 d01c79c:	014018c4 	movi	r5,99
 d01c7a0:	d00235c0 	call	d00235c <__mulsi3>
 d01c7a4:	10c01004 	addi	r3,r2,64
 d01c7a8:	e0bfff17 	ldw	r2,-4(fp)
 d01c7ac:	1885883a 	add	r2,r3,r2
 d01c7b0:	8009883a 	mov	r4,r16
 d01c7b4:	100b883a 	mov	r5,r2
 d01c7b8:	01801404 	movi	r6,80
 d01c7bc:	d0026080 	call	d002608 <memcpy>
 d01c7c0:	00000906 	br	d01c7e8 <lcd_scroll_up+0x98>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 d01c7c4:	e13ffe17 	ldw	r4,-8(fp)
 d01c7c8:	014018c4 	movi	r5,99
 d01c7cc:	d00235c0 	call	d00235c <__mulsi3>
 d01c7d0:	10c01004 	addi	r3,r2,64
 d01c7d4:	e0bfff17 	ldw	r2,-4(fp)
 d01c7d8:	1889883a 	add	r4,r3,r2
 d01c7dc:	01400804 	movi	r5,32
 d01c7e0:	01801404 	movi	r6,80
 d01c7e4:	d0027880 	call	d002788 <memset>

static void lcd_scroll_up(tristate_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01c7e8:	e0bffe17 	ldw	r2,-8(fp)
 d01c7ec:	10800044 	addi	r2,r2,1
 d01c7f0:	e0bffe15 	stw	r2,-8(fp)
 d01c7f4:	e0bffe17 	ldw	r2,-8(fp)
 d01c7f8:	10800090 	cmplti	r2,r2,2
 d01c7fc:	103fdc1e 	bne	r2,zero,d01c770 <lcd_scroll_up+0x20>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 d01c800:	e0bfff17 	ldw	r2,-4(fp)
 d01c804:	10800883 	ldbu	r2,34(r2)
 d01c808:	10bfffc4 	addi	r2,r2,-1
 d01c80c:	1007883a 	mov	r3,r2
 d01c810:	e0bfff17 	ldw	r2,-4(fp)
 d01c814:	10c00885 	stb	r3,34(r2)
}
 d01c818:	e037883a 	mov	sp,fp
 d01c81c:	dfc00217 	ldw	ra,8(sp)
 d01c820:	df000117 	ldw	fp,4(sp)
 d01c824:	dc000017 	ldw	r16,0(sp)
 d01c828:	dec00304 	addi	sp,sp,12
 d01c82c:	f800283a 	ret

0d01c830 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(tristate_avalon_lcd_16207_state* sp, char c)
{
 d01c830:	defff804 	addi	sp,sp,-32
 d01c834:	dfc00715 	stw	ra,28(sp)
 d01c838:	df000615 	stw	fp,24(sp)
 d01c83c:	df000604 	addi	fp,sp,24
 d01c840:	e13ffd15 	stw	r4,-12(fp)
 d01c844:	e17ffe05 	stb	r5,-8(fp)
  int parm1 = 0, parm2 = 0;
 d01c848:	e03ffc15 	stw	zero,-16(fp)
 d01c84c:	e03ffb15 	stw	zero,-20(fp)

  if (sp->escape[0] == '[')
 d01c850:	e0bffd17 	ldw	r2,-12(fp)
 d01c854:	10800a03 	ldbu	r2,40(r2)
 d01c858:	10803fcc 	andi	r2,r2,255
 d01c85c:	1080201c 	xori	r2,r2,128
 d01c860:	10bfe004 	addi	r2,r2,-128
 d01c864:	108016d8 	cmpnei	r2,r2,91
 d01c868:	10004d1e 	bne	r2,zero,d01c9a0 <lcd_handle_escape+0x170>
  {
    char * ptr = sp->escape+1;
 d01c86c:	e0bffd17 	ldw	r2,-12(fp)
 d01c870:	10800a04 	addi	r2,r2,40
 d01c874:	10800044 	addi	r2,r2,1
 d01c878:	e0bffa15 	stw	r2,-24(fp)
    while (isdigit(*ptr))
 d01c87c:	00000f06 	br	d01c8bc <lcd_handle_escape+0x8c>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 d01c880:	e13ffc17 	ldw	r4,-16(fp)
 d01c884:	01400284 	movi	r5,10
 d01c888:	d00235c0 	call	d00235c <__mulsi3>
 d01c88c:	1007883a 	mov	r3,r2
 d01c890:	e0bffa17 	ldw	r2,-24(fp)
 d01c894:	10800003 	ldbu	r2,0(r2)
 d01c898:	10803fcc 	andi	r2,r2,255
 d01c89c:	1080201c 	xori	r2,r2,128
 d01c8a0:	10bfe004 	addi	r2,r2,-128
 d01c8a4:	1885883a 	add	r2,r3,r2
 d01c8a8:	10bff404 	addi	r2,r2,-48
 d01c8ac:	e0bffc15 	stw	r2,-16(fp)
 d01c8b0:	e0bffa17 	ldw	r2,-24(fp)
 d01c8b4:	10800044 	addi	r2,r2,1
 d01c8b8:	e0bffa15 	stw	r2,-24(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 d01c8bc:	e0bffa17 	ldw	r2,-24(fp)
 d01c8c0:	10800003 	ldbu	r2,0(r2)
 d01c8c4:	10803fcc 	andi	r2,r2,255
 d01c8c8:	1080201c 	xori	r2,r2,128
 d01c8cc:	10bfe004 	addi	r2,r2,-128
 d01c8d0:	1007883a 	mov	r3,r2
 d01c8d4:	00834174 	movhi	r2,3333
 d01c8d8:	10921f04 	addi	r2,r2,18556
 d01c8dc:	10800017 	ldw	r2,0(r2)
 d01c8e0:	1885883a 	add	r2,r3,r2
 d01c8e4:	10800003 	ldbu	r2,0(r2)
 d01c8e8:	10803fcc 	andi	r2,r2,255
 d01c8ec:	1080010c 	andi	r2,r2,4
 d01c8f0:	1004c03a 	cmpne	r2,r2,zero
 d01c8f4:	103fe21e 	bne	r2,zero,d01c880 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 d01c8f8:	e0bffa17 	ldw	r2,-24(fp)
 d01c8fc:	10800003 	ldbu	r2,0(r2)
 d01c900:	10803fcc 	andi	r2,r2,255
 d01c904:	1080201c 	xori	r2,r2,128
 d01c908:	10bfe004 	addi	r2,r2,-128
 d01c90c:	10800ed8 	cmpnei	r2,r2,59
 d01c910:	1000251e 	bne	r2,zero,d01c9a8 <lcd_handle_escape+0x178>
    {
      ptr++;
 d01c914:	e0bffa17 	ldw	r2,-24(fp)
 d01c918:	10800044 	addi	r2,r2,1
 d01c91c:	e0bffa15 	stw	r2,-24(fp)
      while (isdigit(*ptr))
 d01c920:	00000f06 	br	d01c960 <lcd_handle_escape+0x130>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 d01c924:	e13ffb17 	ldw	r4,-20(fp)
 d01c928:	01400284 	movi	r5,10
 d01c92c:	d00235c0 	call	d00235c <__mulsi3>
 d01c930:	1007883a 	mov	r3,r2
 d01c934:	e0bffa17 	ldw	r2,-24(fp)
 d01c938:	10800003 	ldbu	r2,0(r2)
 d01c93c:	10803fcc 	andi	r2,r2,255
 d01c940:	1080201c 	xori	r2,r2,128
 d01c944:	10bfe004 	addi	r2,r2,-128
 d01c948:	1885883a 	add	r2,r3,r2
 d01c94c:	10bff404 	addi	r2,r2,-48
 d01c950:	e0bffb15 	stw	r2,-20(fp)
 d01c954:	e0bffa17 	ldw	r2,-24(fp)
 d01c958:	10800044 	addi	r2,r2,1
 d01c95c:	e0bffa15 	stw	r2,-24(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 d01c960:	e0bffa17 	ldw	r2,-24(fp)
 d01c964:	10800003 	ldbu	r2,0(r2)
 d01c968:	10803fcc 	andi	r2,r2,255
 d01c96c:	1080201c 	xori	r2,r2,128
 d01c970:	10bfe004 	addi	r2,r2,-128
 d01c974:	1007883a 	mov	r3,r2
 d01c978:	00834174 	movhi	r2,3333
 d01c97c:	10921f04 	addi	r2,r2,18556
 d01c980:	10800017 	ldw	r2,0(r2)
 d01c984:	1885883a 	add	r2,r3,r2
 d01c988:	10800003 	ldbu	r2,0(r2)
 d01c98c:	10803fcc 	andi	r2,r2,255
 d01c990:	1080010c 	andi	r2,r2,4
 d01c994:	1004c03a 	cmpne	r2,r2,zero
 d01c998:	103fe21e 	bne	r2,zero,d01c924 <lcd_handle_escape+0xf4>
 d01c99c:	00000206 	br	d01c9a8 <lcd_handle_escape+0x178>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 d01c9a0:	00bfffc4 	movi	r2,-1
 d01c9a4:	e0bffc15 	stw	r2,-16(fp)

  switch (c)
 d01c9a8:	e0bffe07 	ldb	r2,-8(fp)
 d01c9ac:	e0bfff15 	stw	r2,-4(fp)
 d01c9b0:	e0ffff17 	ldw	r3,-4(fp)
 d01c9b4:	188012a0 	cmpeqi	r2,r3,74
 d01c9b8:	10002f1e 	bne	r2,zero,d01ca78 <lcd_handle_escape+0x248>
 d01c9bc:	e0ffff17 	ldw	r3,-4(fp)
 d01c9c0:	188012c8 	cmpgei	r2,r3,75
 d01c9c4:	1000041e 	bne	r2,zero,d01c9d8 <lcd_handle_escape+0x1a8>
 d01c9c8:	e0ffff17 	ldw	r3,-4(fp)
 d01c9cc:	18801220 	cmpeqi	r2,r3,72
 d01c9d0:	1000081e 	bne	r2,zero,d01c9f4 <lcd_handle_escape+0x1c4>
 d01c9d4:	00004a06 	br	d01cb00 <lcd_handle_escape+0x2d0>
 d01c9d8:	e0ffff17 	ldw	r3,-4(fp)
 d01c9dc:	188012e0 	cmpeqi	r2,r3,75
 d01c9e0:	10002b1e 	bne	r2,zero,d01ca90 <lcd_handle_escape+0x260>
 d01c9e4:	e0ffff17 	ldw	r3,-4(fp)
 d01c9e8:	188019a0 	cmpeqi	r2,r3,102
 d01c9ec:	1000011e 	bne	r2,zero,d01c9f4 <lcd_handle_escape+0x1c4>
 d01c9f0:	00004306 	br	d01cb00 <lcd_handle_escape+0x2d0>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 d01c9f4:	e0bffb17 	ldw	r2,-20(fp)
 d01c9f8:	10800050 	cmplti	r2,r2,1
 d01c9fc:	1000051e 	bne	r2,zero,d01ca14 <lcd_handle_escape+0x1e4>
      sp->x = parm2 - 1;
 d01ca00:	e0bffb17 	ldw	r2,-20(fp)
 d01ca04:	10bfffc4 	addi	r2,r2,-1
 d01ca08:	1007883a 	mov	r3,r2
 d01ca0c:	e0bffd17 	ldw	r2,-12(fp)
 d01ca10:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 d01ca14:	e0bffc17 	ldw	r2,-16(fp)
 d01ca18:	10800050 	cmplti	r2,r2,1
 d01ca1c:	1000381e 	bne	r2,zero,d01cb00 <lcd_handle_escape+0x2d0>
    {
      sp->y = parm1 - 1;
 d01ca20:	e0bffc17 	ldw	r2,-16(fp)
 d01ca24:	10bfffc4 	addi	r2,r2,-1
 d01ca28:	1007883a 	mov	r3,r2
 d01ca2c:	e0bffd17 	ldw	r2,-12(fp)
 d01ca30:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 d01ca34:	e0bffd17 	ldw	r2,-12(fp)
 d01ca38:	10800883 	ldbu	r2,34(r2)
 d01ca3c:	10803fcc 	andi	r2,r2,255
 d01ca40:	10800170 	cmpltui	r2,r2,5
 d01ca44:	1000061e 	bne	r2,zero,d01ca60 <lcd_handle_escape+0x230>
        sp->y = ALT_LCD_HEIGHT * 2;
 d01ca48:	e0fffd17 	ldw	r3,-12(fp)
 d01ca4c:	00800104 	movi	r2,4
 d01ca50:	18800885 	stb	r2,34(r3)
      while (sp->y > ALT_LCD_HEIGHT)
 d01ca54:	00000206 	br	d01ca60 <lcd_handle_escape+0x230>
        lcd_scroll_up(sp);
 d01ca58:	e13ffd17 	ldw	r4,-12(fp)
 d01ca5c:	d01c7500 	call	d01c750 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 d01ca60:	e0bffd17 	ldw	r2,-12(fp)
 d01ca64:	10800883 	ldbu	r2,34(r2)
 d01ca68:	10803fcc 	andi	r2,r2,255
 d01ca6c:	108000e8 	cmpgeui	r2,r2,3
 d01ca70:	103ff91e 	bne	r2,zero,d01ca58 <lcd_handle_escape+0x228>
        lcd_scroll_up(sp);
    }
    break;
 d01ca74:	00002206 	br	d01cb00 <lcd_handle_escape+0x2d0>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 d01ca78:	e0bffc17 	ldw	r2,-16(fp)
 d01ca7c:	10800098 	cmpnei	r2,r2,2
 d01ca80:	10001f1e 	bne	r2,zero,d01cb00 <lcd_handle_escape+0x2d0>
      lcd_clear_screen(sp);
 d01ca84:	e13ffd17 	ldw	r4,-12(fp)
 d01ca88:	d01c4640 	call	d01c464 <lcd_clear_screen>
    break;
 d01ca8c:	00001c06 	br	d01cb00 <lcd_handle_escape+0x2d0>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 d01ca90:	e0bffc17 	ldw	r2,-16(fp)
 d01ca94:	10800048 	cmpgei	r2,r2,1
 d01ca98:	1000191e 	bne	r2,zero,d01cb00 <lcd_handle_escape+0x2d0>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 d01ca9c:	e0bffd17 	ldw	r2,-12(fp)
 d01caa0:	10800843 	ldbu	r2,33(r2)
 d01caa4:	10803fcc 	andi	r2,r2,255
 d01caa8:	10801428 	cmpgeui	r2,r2,80
 d01caac:	1000141e 	bne	r2,zero,d01cb00 <lcd_handle_escape+0x2d0>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 d01cab0:	e0bffd17 	ldw	r2,-12(fp)
 d01cab4:	10800883 	ldbu	r2,34(r2)
 d01cab8:	11003fcc 	andi	r4,r2,255
 d01cabc:	014018c4 	movi	r5,99
 d01cac0:	d00235c0 	call	d00235c <__mulsi3>
 d01cac4:	10c01004 	addi	r3,r2,64
 d01cac8:	e0bffd17 	ldw	r2,-12(fp)
 d01cacc:	1887883a 	add	r3,r3,r2
 d01cad0:	e0bffd17 	ldw	r2,-12(fp)
 d01cad4:	10800843 	ldbu	r2,33(r2)
 d01cad8:	10803fcc 	andi	r2,r2,255
 d01cadc:	1889883a 	add	r4,r3,r2
 d01cae0:	e0bffd17 	ldw	r2,-12(fp)
 d01cae4:	10800843 	ldbu	r2,33(r2)
 d01cae8:	10c03fcc 	andi	r3,r2,255
 d01caec:	00801404 	movi	r2,80
 d01caf0:	10c5c83a 	sub	r2,r2,r3
 d01caf4:	100d883a 	mov	r6,r2
 d01caf8:	01400804 	movi	r5,32
 d01cafc:	d0027880 	call	d002788 <memset>
    }
    break;
  }
}
 d01cb00:	e037883a 	mov	sp,fp
 d01cb04:	dfc00117 	ldw	ra,4(sp)
 d01cb08:	df000017 	ldw	fp,0(sp)
 d01cb0c:	dec00204 	addi	sp,sp,8
 d01cb10:	f800283a 	ret

0d01cb14 <tristate_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int tristate_avalon_lcd_16207_write(tristate_avalon_lcd_16207_state* sp,
  const char* ptr, int len, int flags)
{
 d01cb14:	deffed04 	addi	sp,sp,-76
 d01cb18:	dfc01215 	stw	ra,72(sp)
 d01cb1c:	df001115 	stw	fp,68(sp)
 d01cb20:	dc801015 	stw	r18,64(sp)
 d01cb24:	dc400f15 	stw	r17,60(sp)
 d01cb28:	dc000e15 	stw	r16,56(sp)
 d01cb2c:	df000e04 	addi	fp,sp,56
 d01cb30:	e13ffc15 	stw	r4,-16(fp)
 d01cb34:	e17ffd15 	stw	r5,-12(fp)
 d01cb38:	e1bffe15 	stw	r6,-8(fp)
 d01cb3c:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 d01cb40:	e0bffe17 	ldw	r2,-8(fp)
 d01cb44:	1007883a 	mov	r3,r2
 d01cb48:	e0bffd17 	ldw	r2,-12(fp)
 d01cb4c:	10c5883a 	add	r2,r2,r3
 d01cb50:	e0bffa15 	stw	r2,-24(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 d01cb54:	e0bffc17 	ldw	r2,-16(fp)
 d01cb58:	10803e17 	ldw	r2,248(r2)
 d01cb5c:	e0bff215 	stw	r2,-56(fp)
 d01cb60:	e03ff30d 	sth	zero,-52(fp)
 d01cb64:	e17ff30b 	ldhu	r5,-52(fp)
 d01cb68:	e1bffb04 	addi	r6,fp,-20
 d01cb6c:	e13ff217 	ldw	r4,-56(fp)
 d01cb70:	d0135480 	call	d013548 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 d01cb74:	e0fffc17 	ldw	r3,-16(fp)
 d01cb78:	00800044 	movi	r2,1
 d01cb7c:	188009c5 	stb	r2,39(r3)

  for ( ; ptr < end ; ptr++)
 d01cb80:	0000a306 	br	d01ce10 <tristate_avalon_lcd_16207_write+0x2fc>
  {
    char c = *ptr;
 d01cb84:	e0bffd17 	ldw	r2,-12(fp)
 d01cb88:	10800003 	ldbu	r2,0(r2)
 d01cb8c:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 d01cb90:	e0bffc17 	ldw	r2,-16(fp)
 d01cb94:	10800903 	ldbu	r2,36(r2)
 d01cb98:	10803fcc 	andi	r2,r2,255
 d01cb9c:	1080201c 	xori	r2,r2,128
 d01cba0:	10bfe004 	addi	r2,r2,-128
 d01cba4:	1004803a 	cmplt	r2,r2,zero
 d01cba8:	10003b1e 	bne	r2,zero,d01cc98 <tristate_avalon_lcd_16207_write+0x184>
    {
      unsigned int esccount = sp->esccount;
 d01cbac:	e0bffc17 	ldw	r2,-16(fp)
 d01cbb0:	10800903 	ldbu	r2,36(r2)
 d01cbb4:	10803fcc 	andi	r2,r2,255
 d01cbb8:	1080201c 	xori	r2,r2,128
 d01cbbc:	10bfe004 	addi	r2,r2,-128
 d01cbc0:	e0bff615 	stw	r2,-40(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 d01cbc4:	e0bff617 	ldw	r2,-40(fp)
 d01cbc8:	1004c03a 	cmpne	r2,r2,zero
 d01cbcc:	1000031e 	bne	r2,zero,d01cbdc <tristate_avalon_lcd_16207_write+0xc8>
 d01cbd0:	e0bff707 	ldb	r2,-36(fp)
 d01cbd4:	108016d8 	cmpnei	r2,r2,91
 d01cbd8:	1000111e 	bne	r2,zero,d01cc20 <tristate_avalon_lcd_16207_write+0x10c>
 d01cbdc:	e0bff617 	ldw	r2,-40(fp)
 d01cbe0:	1005003a 	cmpeq	r2,r2,zero
 d01cbe4:	10001a1e 	bne	r2,zero,d01cc50 <tristate_avalon_lcd_16207_write+0x13c>
 d01cbe8:	e0bff707 	ldb	r2,-36(fp)
 d01cbec:	1007883a 	mov	r3,r2
 d01cbf0:	00834174 	movhi	r2,3333
 d01cbf4:	10921f04 	addi	r2,r2,18556
 d01cbf8:	10800017 	ldw	r2,0(r2)
 d01cbfc:	1885883a 	add	r2,r3,r2
 d01cc00:	10800003 	ldbu	r2,0(r2)
 d01cc04:	10803fcc 	andi	r2,r2,255
 d01cc08:	1080010c 	andi	r2,r2,4
 d01cc0c:	1004c03a 	cmpne	r2,r2,zero
 d01cc10:	10000f1e 	bne	r2,zero,d01cc50 <tristate_avalon_lcd_16207_write+0x13c>
 d01cc14:	e0bff707 	ldb	r2,-36(fp)
 d01cc18:	10800ee0 	cmpeqi	r2,r2,59
 d01cc1c:	10000c1e 	bne	r2,zero,d01cc50 <tristate_avalon_lcd_16207_write+0x13c>
          (esccount > 0 && !isdigit(c) && c != ';'))
      {
        sp->escape[esccount] = 0;
 d01cc20:	e0fff617 	ldw	r3,-40(fp)
 d01cc24:	e0bffc17 	ldw	r2,-16(fp)
 d01cc28:	1885883a 	add	r2,r3,r2
 d01cc2c:	10800a04 	addi	r2,r2,40
 d01cc30:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 d01cc34:	e17ff707 	ldb	r5,-36(fp)
 d01cc38:	e13ffc17 	ldw	r4,-16(fp)
 d01cc3c:	d01c8300 	call	d01c830 <lcd_handle_escape>

        sp->esccount = -1;
 d01cc40:	e0fffc17 	ldw	r3,-16(fp)
 d01cc44:	00bfffc4 	movi	r2,-1
 d01cc48:	18800905 	stb	r2,36(r3)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 d01cc4c:	00006d06 	br	d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>

        lcd_handle_escape(sp, c);

        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 d01cc50:	e0bffc17 	ldw	r2,-16(fp)
 d01cc54:	10800903 	ldbu	r2,36(r2)
 d01cc58:	10803fcc 	andi	r2,r2,255
 d01cc5c:	108001e8 	cmpgeui	r2,r2,7
 d01cc60:	1000681e 	bne	r2,zero,d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
      {
        sp->escape[esccount] = c;
 d01cc64:	e0fff617 	ldw	r3,-40(fp)
 d01cc68:	e0bffc17 	ldw	r2,-16(fp)
 d01cc6c:	1885883a 	add	r2,r3,r2
 d01cc70:	10c00a04 	addi	r3,r2,40
 d01cc74:	e0bff703 	ldbu	r2,-36(fp)
 d01cc78:	18800005 	stb	r2,0(r3)
        sp->esccount++;
 d01cc7c:	e0bffc17 	ldw	r2,-16(fp)
 d01cc80:	10800903 	ldbu	r2,36(r2)
 d01cc84:	10800044 	addi	r2,r2,1
 d01cc88:	1007883a 	mov	r3,r2
 d01cc8c:	e0bffc17 	ldw	r2,-16(fp)
 d01cc90:	10c00905 	stb	r3,36(r2)
 d01cc94:	00005b06 	br	d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
      }
    }
    else if (c == 27) /* ESC */
 d01cc98:	e0bff707 	ldb	r2,-36(fp)
 d01cc9c:	108006d8 	cmpnei	r2,r2,27
 d01cca0:	1000031e 	bne	r2,zero,d01ccb0 <tristate_avalon_lcd_16207_write+0x19c>
    {
      sp->esccount = 0;
 d01cca4:	e0bffc17 	ldw	r2,-16(fp)
 d01cca8:	10000905 	stb	zero,36(r2)
 d01ccac:	00005506 	br	d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
    }
    else if (c == '\r')
 d01ccb0:	e0bff707 	ldb	r2,-36(fp)
 d01ccb4:	10800358 	cmpnei	r2,r2,13
 d01ccb8:	1000031e 	bne	r2,zero,d01ccc8 <tristate_avalon_lcd_16207_write+0x1b4>
    {
      sp->x = 0;
 d01ccbc:	e0bffc17 	ldw	r2,-16(fp)
 d01ccc0:	10000845 	stb	zero,33(r2)
 d01ccc4:	00004f06 	br	d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
    }
    else if (c == '\n')
 d01ccc8:	e0bff707 	ldb	r2,-36(fp)
 d01cccc:	10800298 	cmpnei	r2,r2,10
 d01ccd0:	1000101e 	bne	r2,zero,d01cd14 <tristate_avalon_lcd_16207_write+0x200>
    {
      sp->x = 0;
 d01ccd4:	e0bffc17 	ldw	r2,-16(fp)
 d01ccd8:	10000845 	stb	zero,33(r2)
      sp->y++;
 d01ccdc:	e0bffc17 	ldw	r2,-16(fp)
 d01cce0:	10800883 	ldbu	r2,34(r2)
 d01cce4:	10800044 	addi	r2,r2,1
 d01cce8:	1007883a 	mov	r3,r2
 d01ccec:	e0bffc17 	ldw	r2,-16(fp)
 d01ccf0:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 d01ccf4:	e0bffc17 	ldw	r2,-16(fp)
 d01ccf8:	10800883 	ldbu	r2,34(r2)
 d01ccfc:	10803fcc 	andi	r2,r2,255
 d01cd00:	108000f0 	cmpltui	r2,r2,3
 d01cd04:	10003f1e 	bne	r2,zero,d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
        lcd_scroll_up(sp);
 d01cd08:	e13ffc17 	ldw	r4,-16(fp)
 d01cd0c:	d01c7500 	call	d01c750 <lcd_scroll_up>
 d01cd10:	00003c06 	br	d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
    }
    else if (c == '\b')
 d01cd14:	e0bff707 	ldb	r2,-36(fp)
 d01cd18:	10800218 	cmpnei	r2,r2,8
 d01cd1c:	10000c1e 	bne	r2,zero,d01cd50 <tristate_avalon_lcd_16207_write+0x23c>
    {
      if (sp->x > 0)
 d01cd20:	e0bffc17 	ldw	r2,-16(fp)
 d01cd24:	10800843 	ldbu	r2,33(r2)
 d01cd28:	10803fcc 	andi	r2,r2,255
 d01cd2c:	1005003a 	cmpeq	r2,r2,zero
 d01cd30:	1000341e 	bne	r2,zero,d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
        sp->x--;
 d01cd34:	e0bffc17 	ldw	r2,-16(fp)
 d01cd38:	10800843 	ldbu	r2,33(r2)
 d01cd3c:	10bfffc4 	addi	r2,r2,-1
 d01cd40:	1007883a 	mov	r3,r2
 d01cd44:	e0bffc17 	ldw	r2,-16(fp)
 d01cd48:	10c00845 	stb	r3,33(r2)
 d01cd4c:	00002d06 	br	d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
    }
    else if (isprint(c))
 d01cd50:	e0bff707 	ldb	r2,-36(fp)
 d01cd54:	1007883a 	mov	r3,r2
 d01cd58:	00834174 	movhi	r2,3333
 d01cd5c:	10921f04 	addi	r2,r2,18556
 d01cd60:	10800017 	ldw	r2,0(r2)
 d01cd64:	1885883a 	add	r2,r3,r2
 d01cd68:	10800003 	ldbu	r2,0(r2)
 d01cd6c:	10803fcc 	andi	r2,r2,255
 d01cd70:	1080201c 	xori	r2,r2,128
 d01cd74:	10bfe004 	addi	r2,r2,-128
 d01cd78:	108025cc 	andi	r2,r2,151
 d01cd7c:	1005003a 	cmpeq	r2,r2,zero
 d01cd80:	1000201e 	bne	r2,zero,d01ce04 <tristate_avalon_lcd_16207_write+0x2f0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 d01cd84:	e0bffc17 	ldw	r2,-16(fp)
 d01cd88:	10800883 	ldbu	r2,34(r2)
 d01cd8c:	10803fcc 	andi	r2,r2,255
 d01cd90:	108000b0 	cmpltui	r2,r2,2
 d01cd94:	1000021e 	bne	r2,zero,d01cda0 <tristate_avalon_lcd_16207_write+0x28c>
        lcd_scroll_up(sp);
 d01cd98:	e13ffc17 	ldw	r4,-16(fp)
 d01cd9c:	d01c7500 	call	d01c750 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 d01cda0:	e0bffc17 	ldw	r2,-16(fp)
 d01cda4:	10800843 	ldbu	r2,33(r2)
 d01cda8:	10803fcc 	andi	r2,r2,255
 d01cdac:	10801428 	cmpgeui	r2,r2,80
 d01cdb0:	10000e1e 	bne	r2,zero,d01cdec <tristate_avalon_lcd_16207_write+0x2d8>
        sp->line[sp->y].data[sp->x] = c;
 d01cdb4:	e0bffc17 	ldw	r2,-16(fp)
 d01cdb8:	10800883 	ldbu	r2,34(r2)
 d01cdbc:	11003fcc 	andi	r4,r2,255
 d01cdc0:	e0bffc17 	ldw	r2,-16(fp)
 d01cdc4:	10800843 	ldbu	r2,33(r2)
 d01cdc8:	14403fcc 	andi	r17,r2,255
 d01cdcc:	e43ffc17 	ldw	r16,-16(fp)
 d01cdd0:	014018c4 	movi	r5,99
 d01cdd4:	d00235c0 	call	d00235c <__mulsi3>
 d01cdd8:	1405883a 	add	r2,r2,r16
 d01cddc:	1445883a 	add	r2,r2,r17
 d01cde0:	10c01004 	addi	r3,r2,64
 d01cde4:	e0bff703 	ldbu	r2,-36(fp)
 d01cde8:	18800005 	stb	r2,0(r3)

      sp->x++;
 d01cdec:	e0bffc17 	ldw	r2,-16(fp)
 d01cdf0:	10800843 	ldbu	r2,33(r2)
 d01cdf4:	10800044 	addi	r2,r2,1
 d01cdf8:	1007883a 	mov	r3,r2
 d01cdfc:	e0bffc17 	ldw	r2,-16(fp)
 d01ce00:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 d01ce04:	e0bffd17 	ldw	r2,-12(fp)
 d01ce08:	10800044 	addi	r2,r2,1
 d01ce0c:	e0bffd15 	stw	r2,-12(fp)
 d01ce10:	e0fffd17 	ldw	r3,-12(fp)
 d01ce14:	e0bffa17 	ldw	r2,-24(fp)
 d01ce18:	18bf5a36 	bltu	r3,r2,d01cb84 <tristate_avalon_lcd_16207_write+0x70>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 d01ce1c:	00800404 	movi	r2,16
 d01ce20:	e0bff815 	stw	r2,-32(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01ce24:	e03ff915 	stw	zero,-28(fp)
 d01ce28:	00003906 	br	d01cf10 <tristate_avalon_lcd_16207_write+0x3fc>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 d01ce2c:	00801404 	movi	r2,80
 d01ce30:	e0bff515 	stw	r2,-44(fp)
 d01ce34:	00001206 	br	d01ce80 <tristate_avalon_lcd_16207_write+0x36c>
      if (sp->line[y].data[width-1] != ' ')
 d01ce38:	e13ff917 	ldw	r4,-28(fp)
 d01ce3c:	e0bff517 	ldw	r2,-44(fp)
 d01ce40:	147fffc4 	addi	r17,r2,-1
 d01ce44:	e43ffc17 	ldw	r16,-16(fp)
 d01ce48:	014018c4 	movi	r5,99
 d01ce4c:	d00235c0 	call	d00235c <__mulsi3>
 d01ce50:	1405883a 	add	r2,r2,r16
 d01ce54:	1445883a 	add	r2,r2,r17
 d01ce58:	10801004 	addi	r2,r2,64
 d01ce5c:	10800003 	ldbu	r2,0(r2)
 d01ce60:	10803fcc 	andi	r2,r2,255
 d01ce64:	1080201c 	xori	r2,r2,128
 d01ce68:	10bfe004 	addi	r2,r2,-128
 d01ce6c:	10800818 	cmpnei	r2,r2,32
 d01ce70:	1000061e 	bne	r2,zero,d01ce8c <tristate_avalon_lcd_16207_write+0x378>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 d01ce74:	e0bff517 	ldw	r2,-44(fp)
 d01ce78:	10bfffc4 	addi	r2,r2,-1
 d01ce7c:	e0bff515 	stw	r2,-44(fp)
 d01ce80:	e0bff517 	ldw	r2,-44(fp)
 d01ce84:	10800048 	cmpgei	r2,r2,1
 d01ce88:	103feb1e 	bne	r2,zero,d01ce38 <tristate_avalon_lcd_16207_write+0x324>

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 d01ce8c:	e0bff517 	ldw	r2,-44(fp)
 d01ce90:	10800448 	cmpgei	r2,r2,17
 d01ce94:	1000031e 	bne	r2,zero,d01cea4 <tristate_avalon_lcd_16207_write+0x390>
      width = ALT_LCD_WIDTH;
 d01ce98:	00800404 	movi	r2,16
 d01ce9c:	e0bff515 	stw	r2,-44(fp)
 d01cea0:	00000306 	br	d01ceb0 <tristate_avalon_lcd_16207_write+0x39c>
    else
      width++;
 d01cea4:	e0bff517 	ldw	r2,-44(fp)
 d01cea8:	10800044 	addi	r2,r2,1
 d01ceac:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 d01ceb0:	e13ff917 	ldw	r4,-28(fp)
 d01ceb4:	e0bff517 	ldw	r2,-44(fp)
 d01ceb8:	1023883a 	mov	r17,r2
 d01cebc:	e43ffc17 	ldw	r16,-16(fp)
 d01cec0:	014018c4 	movi	r5,99
 d01cec4:	d00235c0 	call	d00235c <__mulsi3>
 d01cec8:	1405883a 	add	r2,r2,r16
 d01cecc:	10802404 	addi	r2,r2,144
 d01ced0:	14400045 	stb	r17,1(r2)
    if (widthmax < width)
 d01ced4:	e0fff817 	ldw	r3,-32(fp)
 d01ced8:	e0bff517 	ldw	r2,-44(fp)
 d01cedc:	1880020e 	bge	r3,r2,d01cee8 <tristate_avalon_lcd_16207_write+0x3d4>
      widthmax = width;
 d01cee0:	e0bff517 	ldw	r2,-44(fp)
 d01cee4:	e0bff815 	stw	r2,-32(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 d01cee8:	e13ff917 	ldw	r4,-28(fp)
 d01ceec:	e43ffc17 	ldw	r16,-16(fp)
 d01cef0:	014018c4 	movi	r5,99
 d01cef4:	d00235c0 	call	d00235c <__mulsi3>
 d01cef8:	1405883a 	add	r2,r2,r16
 d01cefc:	10802404 	addi	r2,r2,144
 d01cf00:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01cf04:	e0bff917 	ldw	r2,-28(fp)
 d01cf08:	10800044 	addi	r2,r2,1
 d01cf0c:	e0bff915 	stw	r2,-28(fp)
 d01cf10:	e0bff917 	ldw	r2,-28(fp)
 d01cf14:	10800090 	cmplti	r2,r2,2
 d01cf18:	103fc41e 	bne	r2,zero,d01ce2c <tristate_avalon_lcd_16207_write+0x318>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 d01cf1c:	e0bff817 	ldw	r2,-32(fp)
 d01cf20:	10800448 	cmpgei	r2,r2,17
 d01cf24:	1000031e 	bne	r2,zero,d01cf34 <tristate_avalon_lcd_16207_write+0x420>
    sp->scrollmax = 0;
 d01cf28:	e0bffc17 	ldw	r2,-16(fp)
 d01cf2c:	10000985 	stb	zero,38(r2)
 d01cf30:	00003106 	br	d01cff8 <tristate_avalon_lcd_16207_write+0x4e4>
  else
  {
    widthmax *= 2;
 d01cf34:	e0bff817 	ldw	r2,-32(fp)
 d01cf38:	1085883a 	add	r2,r2,r2
 d01cf3c:	e0bff815 	stw	r2,-32(fp)
    sp->scrollmax = widthmax;
 d01cf40:	e0bff817 	ldw	r2,-32(fp)
 d01cf44:	1007883a 	mov	r3,r2
 d01cf48:	e0bffc17 	ldw	r2,-16(fp)
 d01cf4c:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01cf50:	e03ff915 	stw	zero,-28(fp)
 d01cf54:	00002506 	br	d01cfec <tristate_avalon_lcd_16207_write+0x4d8>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 d01cf58:	e13ff917 	ldw	r4,-28(fp)
 d01cf5c:	e43ffc17 	ldw	r16,-16(fp)
 d01cf60:	014018c4 	movi	r5,99
 d01cf64:	d00235c0 	call	d00235c <__mulsi3>
 d01cf68:	1405883a 	add	r2,r2,r16
 d01cf6c:	10802404 	addi	r2,r2,144
 d01cf70:	10800043 	ldbu	r2,1(r2)
 d01cf74:	10803fcc 	andi	r2,r2,255
 d01cf78:	1080201c 	xori	r2,r2,128
 d01cf7c:	10bfe004 	addi	r2,r2,-128
 d01cf80:	10800450 	cmplti	r2,r2,17
 d01cf84:	1000161e 	bne	r2,zero,d01cfe0 <tristate_avalon_lcd_16207_write+0x4cc>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 d01cf88:	e4bff917 	ldw	r18,-28(fp)
 d01cf8c:	e13ff917 	ldw	r4,-28(fp)
 d01cf90:	e43ffc17 	ldw	r16,-16(fp)
 d01cf94:	014018c4 	movi	r5,99
 d01cf98:	d00235c0 	call	d00235c <__mulsi3>
 d01cf9c:	1405883a 	add	r2,r2,r16
 d01cfa0:	10802404 	addi	r2,r2,144
 d01cfa4:	10800043 	ldbu	r2,1(r2)
 d01cfa8:	10803fcc 	andi	r2,r2,255
 d01cfac:	1080201c 	xori	r2,r2,128
 d01cfb0:	10bfe004 	addi	r2,r2,-128
 d01cfb4:	1008923a 	slli	r4,r2,8
 d01cfb8:	e17ff817 	ldw	r5,-32(fp)
 d01cfbc:	d00c84c0 	call	d00c84c <__divsi3>
 d01cfc0:	1023883a 	mov	r17,r2
 d01cfc4:	e43ffc17 	ldw	r16,-16(fp)
 d01cfc8:	9009883a 	mov	r4,r18
 d01cfcc:	014018c4 	movi	r5,99
 d01cfd0:	d00235c0 	call	d00235c <__mulsi3>
 d01cfd4:	1405883a 	add	r2,r2,r16
 d01cfd8:	10802404 	addi	r2,r2,144
 d01cfdc:	14400085 	stb	r17,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01cfe0:	e0bff917 	ldw	r2,-28(fp)
 d01cfe4:	10800044 	addi	r2,r2,1
 d01cfe8:	e0bff915 	stw	r2,-28(fp)
 d01cfec:	e0bff917 	ldw	r2,-28(fp)
 d01cff0:	10800090 	cmplti	r2,r2,2
 d01cff4:	103fd81e 	bne	r2,zero,d01cf58 <tristate_avalon_lcd_16207_write+0x444>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 d01cff8:	e0bffc17 	ldw	r2,-16(fp)
 d01cffc:	10800943 	ldbu	r2,37(r2)
 d01d000:	10803fcc 	andi	r2,r2,255
 d01d004:	1080201c 	xori	r2,r2,128
 d01d008:	10bfe004 	addi	r2,r2,-128
 d01d00c:	e0bff415 	stw	r2,-48(fp)

    lcd_repaint_screen(sp);
 d01d010:	e13ffc17 	ldw	r4,-16(fp)
 d01d014:	d01c53c0 	call	d01c53c <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 d01d018:	e0bffc17 	ldw	r2,-16(fp)
 d01d01c:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 d01d020:	e0bffc17 	ldw	r2,-16(fp)
 d01d024:	10800943 	ldbu	r2,37(r2)
 d01d028:	10c03fcc 	andi	r3,r2,255
 d01d02c:	18c0201c 	xori	r3,r3,128
 d01d030:	18ffe004 	addi	r3,r3,-128
 d01d034:	e0bff417 	ldw	r2,-48(fp)
 d01d038:	18800426 	beq	r3,r2,d01d04c <tristate_avalon_lcd_16207_write+0x538>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 d01d03c:	e0fffc17 	ldw	r3,-16(fp)
 d01d040:	00800044 	movi	r2,1
 d01d044:	188009c5 	stb	r2,39(r3)
  }
 d01d048:	003feb06 	br	d01cff8 <tristate_avalon_lcd_16207_write+0x4e4>

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 d01d04c:	e0bffc17 	ldw	r2,-16(fp)
 d01d050:	11003e17 	ldw	r4,248(r2)
 d01d054:	d0139400 	call	d013940 <OSSemPost>

  return len;
 d01d058:	e0bffe17 	ldw	r2,-8(fp)
}
 d01d05c:	e037883a 	mov	sp,fp
 d01d060:	dfc00417 	ldw	ra,16(sp)
 d01d064:	df000317 	ldw	fp,12(sp)
 d01d068:	dc800217 	ldw	r18,8(sp)
 d01d06c:	dc400117 	ldw	r17,4(sp)
 d01d070:	dc000017 	ldw	r16,0(sp)
 d01d074:	dec00504 	addi	sp,sp,20
 d01d078:	f800283a 	ret

0d01d07c <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context)
{
 d01d07c:	defffc04 	addi	sp,sp,-16
 d01d080:	dfc00315 	stw	ra,12(sp)
 d01d084:	df000215 	stw	fp,8(sp)
 d01d088:	df000204 	addi	fp,sp,8
 d01d08c:	e13fff15 	stw	r4,-4(fp)
  tristate_avalon_lcd_16207_state* sp = (tristate_avalon_lcd_16207_state*)context;
 d01d090:	e0bfff17 	ldw	r2,-4(fp)
 d01d094:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 d01d098:	e0bffe17 	ldw	r2,-8(fp)
 d01d09c:	10800943 	ldbu	r2,37(r2)
 d01d0a0:	10803fcc 	andi	r2,r2,255
 d01d0a4:	1080201c 	xori	r2,r2,128
 d01d0a8:	10bfe004 	addi	r2,r2,-128
 d01d0ac:	10c00044 	addi	r3,r2,1
 d01d0b0:	e0bffe17 	ldw	r2,-8(fp)
 d01d0b4:	10800983 	ldbu	r2,38(r2)
 d01d0b8:	10803fcc 	andi	r2,r2,255
 d01d0bc:	1080201c 	xori	r2,r2,128
 d01d0c0:	10bfe004 	addi	r2,r2,-128
 d01d0c4:	18800316 	blt	r3,r2,d01d0d4 <alt_lcd_16207_timeout+0x58>
    sp->scrollpos = 0;
 d01d0c8:	e0bffe17 	ldw	r2,-8(fp)
 d01d0cc:	10000945 	stb	zero,37(r2)
 d01d0d0:	00000606 	br	d01d0ec <alt_lcd_16207_timeout+0x70>
  else
    sp->scrollpos = sp->scrollpos + 1;
 d01d0d4:	e0bffe17 	ldw	r2,-8(fp)
 d01d0d8:	10800943 	ldbu	r2,37(r2)
 d01d0dc:	10800044 	addi	r2,r2,1
 d01d0e0:	1007883a 	mov	r3,r2
 d01d0e4:	e0bffe17 	ldw	r2,-8(fp)
 d01d0e8:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 d01d0ec:	e0bffe17 	ldw	r2,-8(fp)
 d01d0f0:	10800983 	ldbu	r2,38(r2)
 d01d0f4:	10803fcc 	andi	r2,r2,255
 d01d0f8:	1080201c 	xori	r2,r2,128
 d01d0fc:	10bfe004 	addi	r2,r2,-128
 d01d100:	10800050 	cmplti	r2,r2,1
 d01d104:	1000091e 	bne	r2,zero,d01d12c <alt_lcd_16207_timeout+0xb0>
 d01d108:	e0bffe17 	ldw	r2,-8(fp)
 d01d10c:	108009c3 	ldbu	r2,39(r2)
 d01d110:	10803fcc 	andi	r2,r2,255
 d01d114:	1080201c 	xori	r2,r2,128
 d01d118:	10bfe004 	addi	r2,r2,-128
 d01d11c:	1004c03a 	cmpne	r2,r2,zero
 d01d120:	1000021e 	bne	r2,zero,d01d12c <alt_lcd_16207_timeout+0xb0>
    lcd_repaint_screen(sp);
 d01d124:	e13ffe17 	ldw	r4,-8(fp)
 d01d128:	d01c53c0 	call	d01c53c <lcd_repaint_screen>

  return sp->period;
 d01d12c:	e0bffe17 	ldw	r2,-8(fp)
 d01d130:	10800717 	ldw	r2,28(r2)
}
 d01d134:	e037883a 	mov	sp,fp
 d01d138:	dfc00117 	ldw	ra,4(sp)
 d01d13c:	df000017 	ldw	fp,0(sp)
 d01d140:	dec00204 	addi	sp,sp,8
 d01d144:	f800283a 	ret

0d01d148 <tristate_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void tristate_avalon_lcd_16207_init(tristate_avalon_lcd_16207_state* sp)
{
 d01d148:	defffa04 	addi	sp,sp,-24
 d01d14c:	dfc00515 	stw	ra,20(sp)
 d01d150:	df000415 	stw	fp,16(sp)
 d01d154:	df000404 	addi	fp,sp,16
 d01d158:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
 d01d15c:	e0bfff17 	ldw	r2,-4(fp)
 d01d160:	10800017 	ldw	r2,0(r2)
 d01d164:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 d01d168:	e0bfff17 	ldw	r2,-4(fp)
 d01d16c:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 d01d170:	e0bfff17 	ldw	r2,-4(fp)
 d01d174:	10803e04 	addi	r2,r2,248
 d01d178:	e0bffc15 	stw	r2,-16(fp)
 d01d17c:	00800044 	movi	r2,1
 d01d180:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 d01d184:	e13ffd0b 	ldhu	r4,-12(fp)
 d01d188:	d0131940 	call	d013194 <OSSemCreate>
 d01d18c:	1007883a 	mov	r3,r2
 d01d190:	e0bffc17 	ldw	r2,-16(fp)
 d01d194:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 d01d198:	010ea604 	movi	r4,15000
 d01d19c:	d035fd00 	call	d035fd0 <usleep>
  IOWR_TRISTATE_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 d01d1a0:	e0bffe17 	ldw	r2,-8(fp)
 d01d1a4:	1007883a 	mov	r3,r2
 d01d1a8:	00800c04 	movi	r2,48
 d01d1ac:	18800035 	stwio	r2,0(r3)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);
 d01d1b0:	01040104 	movi	r4,4100
 d01d1b4:	d035fd00 	call	d035fd0 <usleep>
  IOWR_TRISTATE_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 d01d1b8:	e0bffe17 	ldw	r2,-8(fp)
 d01d1bc:	1007883a 	mov	r3,r2
 d01d1c0:	00800c04 	movi	r2,48
 d01d1c4:	18800035 	stwio	r2,0(r3)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 d01d1c8:	0100fa04 	movi	r4,1000
 d01d1cc:	d035fd00 	call	d035fd0 <usleep>
  IOWR_TRISTATE_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 d01d1d0:	e0bffe17 	ldw	r2,-8(fp)
 d01d1d4:	1007883a 	mov	r3,r2
 d01d1d8:	00800c04 	movi	r2,48
 d01d1dc:	18800035 	stwio	r2,0(r3)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 d01d1e0:	e13fff17 	ldw	r4,-4(fp)
 d01d1e4:	01400e04 	movi	r5,56
 d01d1e8:	d01c2d80 	call	d01c2d8 <lcd_write_command>

  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 d01d1ec:	e13fff17 	ldw	r4,-4(fp)
 d01d1f0:	01400204 	movi	r5,8
 d01d1f4:	d01c2d80 	call	d01c2d8 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 d01d1f8:	e13fff17 	ldw	r4,-4(fp)
 d01d1fc:	d01c4640 	call	d01c464 <lcd_clear_screen>

  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 d01d200:	e13fff17 	ldw	r4,-4(fp)
 d01d204:	01400184 	movi	r5,6
 d01d208:	d01c2d80 	call	d01c2d8 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 d01d20c:	e13fff17 	ldw	r4,-4(fp)
 d01d210:	01400304 	movi	r5,12
 d01d214:	d01c2d80 	call	d01c2d8 <lcd_write_command>

  sp->esccount = -1;
 d01d218:	e0ffff17 	ldw	r3,-4(fp)
 d01d21c:	00bfffc4 	movi	r2,-1
 d01d220:	18800905 	stb	r2,36(r3)
  memset(sp->escape, 0, sizeof(sp->escape));
 d01d224:	e0bfff17 	ldw	r2,-4(fp)
 d01d228:	11000a04 	addi	r4,r2,40
 d01d22c:	000b883a 	mov	r5,zero
 d01d230:	01800204 	movi	r6,8
 d01d234:	d0027880 	call	d002788 <memset>

  sp->scrollpos = 0;
 d01d238:	e0bfff17 	ldw	r2,-4(fp)
 d01d23c:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 d01d240:	e0bfff17 	ldw	r2,-4(fp)
 d01d244:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 d01d248:	e0bfff17 	ldw	r2,-4(fp)
 d01d24c:	100009c5 	stb	zero,39(r2)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 d01d250:	00834174 	movhi	r2,3333
 d01d254:	109b5504 	addi	r2,r2,27988
 d01d258:	10800017 	ldw	r2,0(r2)
 d01d25c:	1009883a 	mov	r4,r2

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 d01d260:	01400284 	movi	r5,10
 d01d264:	d00c90c0 	call	d00c90c <__udivsi3>
 d01d268:	1007883a 	mov	r3,r2
 d01d26c:	e0bfff17 	ldw	r2,-4(fp)
 d01d270:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 d01d274:	e0bfff17 	ldw	r2,-4(fp)
 d01d278:	11000104 	addi	r4,r2,4
 d01d27c:	e0bfff17 	ldw	r2,-4(fp)
 d01d280:	10800717 	ldw	r2,28(r2)
 d01d284:	100b883a 	mov	r5,r2
 d01d288:	018340b4 	movhi	r6,3330
 d01d28c:	31b41f04 	addi	r6,r6,-12164
 d01d290:	e1ffff17 	ldw	r7,-4(fp)
 d01d294:	d034e900 	call	d034e90 <alt_alarm_start>
}
 d01d298:	e037883a 	mov	sp,fp
 d01d29c:	dfc00117 	ldw	ra,4(sp)
 d01d2a0:	df000017 	ldw	fp,0(sp)
 d01d2a4:	dec00204 	addi	sp,sp,8
 d01d2a8:	f800283a 	ret

0d01d2ac <tristate_avalon_lcd_16207_write_fd>:
extern int tristate_avalon_lcd_16207_write(tristate_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int
tristate_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 d01d2ac:	defffa04 	addi	sp,sp,-24
 d01d2b0:	dfc00515 	stw	ra,20(sp)
 d01d2b4:	df000415 	stw	fp,16(sp)
 d01d2b8:	df000404 	addi	fp,sp,16
 d01d2bc:	e13ffd15 	stw	r4,-12(fp)
 d01d2c0:	e17ffe15 	stw	r5,-8(fp)
 d01d2c4:	e1bfff15 	stw	r6,-4(fp)
    tristate_avalon_lcd_16207_dev* dev = (tristate_avalon_lcd_16207_dev*) fd->dev;
 d01d2c8:	e0bffd17 	ldw	r2,-12(fp)
 d01d2cc:	10800017 	ldw	r2,0(r2)
 d01d2d0:	e0bffc15 	stw	r2,-16(fp)

    return tristate_avalon_lcd_16207_write(&dev->state, buffer, space,
 d01d2d4:	e0bffc17 	ldw	r2,-16(fp)
 d01d2d8:	11000a04 	addi	r4,r2,40
 d01d2dc:	e0bffd17 	ldw	r2,-12(fp)
 d01d2e0:	11c00217 	ldw	r7,8(r2)
 d01d2e4:	e17ffe17 	ldw	r5,-8(fp)
 d01d2e8:	e1bfff17 	ldw	r6,-4(fp)
 d01d2ec:	d01cb140 	call	d01cb14 <tristate_avalon_lcd_16207_write>
      fd->fd_flags);
}
 d01d2f0:	e037883a 	mov	sp,fp
 d01d2f4:	dfc00117 	ldw	ra,4(sp)
 d01d2f8:	df000017 	ldw	fp,0(sp)
 d01d2fc:	dec00204 	addi	sp,sp,8
 d01d300:	f800283a 	ret

0d01d304 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 d01d304:	defffc04 	addi	sp,sp,-16
 d01d308:	dfc00315 	stw	ra,12(sp)
 d01d30c:	df000215 	stw	fp,8(sp)
 d01d310:	df000204 	addi	fp,sp,8
 d01d314:	e13ffe15 	stw	r4,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 d01d318:	e0bffe17 	ldw	r2,-8(fp)
 d01d31c:	10800808 	cmpgei	r2,r2,32
 d01d320:	1000041e 	bne	r2,zero,d01d334 <close+0x30>
 d01d324:	e13ffe17 	ldw	r4,-8(fp)
 d01d328:	d034fe40 	call	d034fe4 <alt_close>
 d01d32c:	e0bfff15 	stw	r2,-4(fp)
 d01d330:	00000306 	br	d01d340 <close+0x3c>
 d01d334:	e13ffe17 	ldw	r4,-8(fp)
 d01d338:	d02a0a40 	call	d02a0a4 <t_socketclose>
 d01d33c:	e0bfff15 	stw	r2,-4(fp)
 d01d340:	e0bfff17 	ldw	r2,-4(fp)
}
 d01d344:	e037883a 	mov	sp,fp
 d01d348:	dfc00117 	ldw	ra,4(sp)
 d01d34c:	df000017 	ldw	fp,0(sp)
 d01d350:	dec00204 	addi	sp,sp,8
 d01d354:	f800283a 	ret

0d01d358 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 d01d358:	defff504 	addi	sp,sp,-44
 d01d35c:	dfc00a15 	stw	ra,40(sp)
 d01d360:	df000915 	stw	fp,36(sp)
 d01d364:	df000904 	addi	fp,sp,36
 d01d368:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 d01d36c:	d0a02d17 	ldw	r2,-32588(gp)
 d01d370:	e0bffa15 	stw	r2,-24(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 d01d374:	d0a02d04 	addi	r2,gp,-32588
 d01d378:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 d01d37c:	00003e06 	br	d01d478 <iniche_devices_init+0x120>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 d01d380:	e0fffa17 	ldw	r3,-24(fp)
 d01d384:	e0bffa17 	ldw	r2,-24(fp)
 d01d388:	18800415 	stw	r2,16(r3)
        p_dev->if_num = if_count;
 d01d38c:	e0fffa17 	ldw	r3,-24(fp)
 d01d390:	e0bfff17 	ldw	r2,-4(fp)
 d01d394:	18800515 	stw	r2,20(r3)
        p_dev->p_net = nets[p_dev->if_num];
 d01d398:	e0bffa17 	ldw	r2,-24(fp)
 d01d39c:	10800517 	ldw	r2,20(r2)
 d01d3a0:	00c341b4 	movhi	r3,3334
 d01d3a4:	18c31a04 	addi	r3,r3,3176
 d01d3a8:	1085883a 	add	r2,r2,r2
 d01d3ac:	1085883a 	add	r2,r2,r2
 d01d3b0:	10c5883a 	add	r2,r2,r3
 d01d3b4:	10c00017 	ldw	r3,0(r2)
 d01d3b8:	e0bffa17 	ldw	r2,-24(fp)
 d01d3bc:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 d01d3c0:	e0bffa17 	ldw	r2,-24(fp)
 d01d3c4:	10800317 	ldw	r2,12(r2)
 d01d3c8:	e13ffa17 	ldw	r4,-24(fp)
 d01d3cc:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 d01d3d0:	e0bffa17 	ldw	r2,-24(fp)
 d01d3d4:	10800617 	ldw	r2,24(r2)
 d01d3d8:	e0bff815 	stw	r2,-32(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 d01d3dc:	e17ffb04 	addi	r5,fp,-20
 d01d3e0:	e1bffc04 	addi	r6,fp,-16
 d01d3e4:	e1fffd04 	addi	r7,fp,-12
 d01d3e8:	e0bffe04 	addi	r2,fp,-8
 d01d3ec:	d8800015 	stw	r2,0(sp)
 d01d3f0:	e13ffa17 	ldw	r4,-24(fp)
 d01d3f4:	d0012100 	call	d001210 <get_ip_addr>
 d01d3f8:	1005003a 	cmpeq	r2,r2,zero
 d01d3fc:	1000181e 	bne	r2,zero,d01d460 <iniche_devices_init+0x108>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 d01d400:	e0bffe17 	ldw	r2,-8(fp)
 d01d404:	1005003a 	cmpeq	r2,r2,zero
 d01d408:	1000051e 	bne	r2,zero,d01d420 <iniche_devices_init+0xc8>
                p_net->n_flags |= NF_DHCPC;
 d01d40c:	e0bff817 	ldw	r2,-32(fp)
 d01d410:	10802a17 	ldw	r2,168(r2)
 d01d414:	10c04014 	ori	r3,r2,256
 d01d418:	e0bff817 	ldw	r2,-32(fp)
 d01d41c:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 d01d420:	e0fffb17 	ldw	r3,-20(fp)
 d01d424:	e0bff817 	ldw	r2,-32(fp)
 d01d428:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 d01d42c:	e0fffc17 	ldw	r3,-16(fp)
 d01d430:	e0bff817 	ldw	r2,-32(fp)
 d01d434:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 d01d438:	e0fffd17 	ldw	r3,-12(fp)
 d01d43c:	e0bff817 	ldw	r2,-32(fp)
 d01d440:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 d01d444:	e0fff817 	ldw	r3,-32(fp)
 d01d448:	00834134 	movhi	r2,3332
 d01d44c:	10b28b04 	addi	r2,r2,-13780
 d01d450:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 d01d454:	e0fff817 	ldw	r3,-32(fp)
 d01d458:	00800084 	movi	r2,2
 d01d45c:	18802f05 	stb	r2,188(r3)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 d01d460:	e0bfff17 	ldw	r2,-4(fp)
 d01d464:	10800044 	addi	r2,r2,1
 d01d468:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 d01d46c:	e0bffa17 	ldw	r2,-24(fp)
 d01d470:	10800017 	ldw	r2,0(r2)
 d01d474:	e0bffa15 	stw	r2,-24(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 d01d478:	e0fffa17 	ldw	r3,-24(fp)
 d01d47c:	e0bff917 	ldw	r2,-28(fp)
 d01d480:	18bfbf1e 	bne	r3,r2,d01d380 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 d01d484:	e0bfff17 	ldw	r2,-4(fp)
}
 d01d488:	e037883a 	mov	sp,fp
 d01d48c:	dfc00117 	ldw	ra,4(sp)
 d01d490:	df000017 	ldw	fp,0(sp)
 d01d494:	dec00204 	addi	sp,sp,8
 d01d498:	f800283a 	ret

0d01d49c <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 d01d49c:	defff804 	addi	sp,sp,-32
 d01d4a0:	dfc00715 	stw	ra,28(sp)
 d01d4a4:	df000615 	stw	fp,24(sp)
 d01d4a8:	df000604 	addi	fp,sp,24
 d01d4ac:	e13ffc15 	stw	r4,-16(fp)
 d01d4b0:	e17ffd15 	stw	r5,-12(fp)
 d01d4b4:	e1bffe15 	stw	r6,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 d01d4b8:	e0bffc17 	ldw	r2,-16(fp)
 d01d4bc:	10800808 	cmpgei	r2,r2,32
 d01d4c0:	1000061e 	bne	r2,zero,d01d4dc <read+0x40>
 d01d4c4:	e13ffc17 	ldw	r4,-16(fp)
 d01d4c8:	e17ffd17 	ldw	r5,-12(fp)
 d01d4cc:	e1bffe17 	ldw	r6,-8(fp)
 d01d4d0:	d035b500 	call	d035b50 <alt_read>
 d01d4d4:	e0bfff15 	stw	r2,-4(fp)
 d01d4d8:	00000806 	br	d01d4fc <read+0x60>
 d01d4dc:	e1bffe17 	ldw	r6,-8(fp)
 d01d4e0:	d8000015 	stw	zero,0(sp)
 d01d4e4:	d8000115 	stw	zero,4(sp)
 d01d4e8:	e13ffc17 	ldw	r4,-16(fp)
 d01d4ec:	e17ffd17 	ldw	r5,-12(fp)
 d01d4f0:	000f883a 	mov	r7,zero
 d01d4f4:	d0200c40 	call	d0200c4 <bsd_recvfrom>
 d01d4f8:	e0bfff15 	stw	r2,-4(fp)
 d01d4fc:	e0bfff17 	ldw	r2,-4(fp)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
}
 d01d500:	e037883a 	mov	sp,fp
 d01d504:	dfc00117 	ldw	ra,4(sp)
 d01d508:	df000017 	ldw	fp,0(sp)
 d01d50c:	dec00204 	addi	sp,sp,8
 d01d510:	f800283a 	ret

0d01d514 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 d01d514:	defffa04 	addi	sp,sp,-24
 d01d518:	dfc00515 	stw	ra,20(sp)
 d01d51c:	df000415 	stw	fp,16(sp)
 d01d520:	df000404 	addi	fp,sp,16
 d01d524:	e13ffc15 	stw	r4,-16(fp)
 d01d528:	e17ffd15 	stw	r5,-12(fp)
 d01d52c:	e1bffe15 	stw	r6,-8(fp)
  if (fd < ALT_MAX_FD)
 d01d530:	e0bffc17 	ldw	r2,-16(fp)
 d01d534:	10800808 	cmpgei	r2,r2,32
 d01d538:	1000061e 	bne	r2,zero,d01d554 <write+0x40>
  {
    return alt_write (fd, ptr, len);
 d01d53c:	e13ffc17 	ldw	r4,-16(fp)
 d01d540:	e17ffd17 	ldw	r5,-12(fp)
 d01d544:	e1bffe17 	ldw	r6,-8(fp)
 d01d548:	d0360f00 	call	d0360f0 <alt_write>
 d01d54c:	e0bfff15 	stw	r2,-4(fp)
 d01d550:	00000606 	br	d01d56c <write+0x58>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 d01d554:	e17ffd17 	ldw	r5,-12(fp)
 d01d558:	e1bffe17 	ldw	r6,-8(fp)
 d01d55c:	e13ffc17 	ldw	r4,-16(fp)
 d01d560:	000f883a 	mov	r7,zero
 d01d564:	d029d980 	call	d029d98 <t_send>
 d01d568:	e0bfff15 	stw	r2,-4(fp)
 d01d56c:	e0bfff17 	ldw	r2,-4(fp)
  }  
}
 d01d570:	e037883a 	mov	sp,fp
 d01d574:	dfc00117 	ldw	ra,4(sp)
 d01d578:	df000017 	ldw	fp,0(sp)
 d01d57c:	dec00204 	addi	sp,sp,8
 d01d580:	f800283a 	ret

0d01d584 <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 d01d584:	defff704 	addi	sp,sp,-36
 d01d588:	dfc00815 	stw	ra,32(sp)
 d01d58c:	df000715 	stw	fp,28(sp)
 d01d590:	df000704 	addi	fp,sp,28
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 d01d594:	e03ffa15 	stw	zero,-24(fp)
 d01d598:	00005806 	br	d01d6fc <Netinit+0x178>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 d01d59c:	e0bffa17 	ldw	r2,-24(fp)
 d01d5a0:	00c341b4 	movhi	r3,3334
 d01d5a4:	18c31a04 	addi	r3,r3,3176
 d01d5a8:	1085883a 	add	r2,r2,r2
 d01d5ac:	1085883a 	add	r2,r2,r2
 d01d5b0:	10c5883a 	add	r2,r2,r3
 d01d5b4:	10800017 	ldw	r2,0(r2)
 d01d5b8:	10802717 	ldw	r2,156(r2)
 d01d5bc:	10800217 	ldw	r2,8(r2)
 d01d5c0:	10800198 	cmpnei	r2,r2,6
 d01d5c4:	1000261e 	bne	r2,zero,d01d660 <Netinit+0xdc>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 d01d5c8:	e0bffa17 	ldw	r2,-24(fp)
 d01d5cc:	00c341b4 	movhi	r3,3334
 d01d5d0:	18c31a04 	addi	r3,r3,3176
 d01d5d4:	1085883a 	add	r2,r2,r2
 d01d5d8:	1085883a 	add	r2,r2,r2
 d01d5dc:	10c5883a 	add	r2,r2,r3
 d01d5e0:	10800017 	ldw	r2,0(r2)
 d01d5e4:	10800917 	ldw	r2,36(r2)
 d01d5e8:	1004c03a 	cmpne	r2,r2,zero
 d01d5ec:	1000091e 	bne	r2,zero,d01d614 <Netinit+0x90>
            nets[i]->n_mtu = 1514;
 d01d5f0:	e0bffa17 	ldw	r2,-24(fp)
 d01d5f4:	00c341b4 	movhi	r3,3334
 d01d5f8:	18c31a04 	addi	r3,r3,3176
 d01d5fc:	1085883a 	add	r2,r2,r2
 d01d600:	1085883a 	add	r2,r2,r2
 d01d604:	10c5883a 	add	r2,r2,r3
 d01d608:	10c00017 	ldw	r3,0(r2)
 d01d60c:	00817a84 	movi	r2,1514
 d01d610:	18800915 	stw	r2,36(r3)

         if (nets[i]->n_lnh == 0)
 d01d614:	e0bffa17 	ldw	r2,-24(fp)
 d01d618:	00c341b4 	movhi	r3,3334
 d01d61c:	18c31a04 	addi	r3,r3,3176
 d01d620:	1085883a 	add	r2,r2,r2
 d01d624:	1085883a 	add	r2,r2,r2
 d01d628:	10c5883a 	add	r2,r2,r3
 d01d62c:	10800017 	ldw	r2,0(r2)
 d01d630:	10800817 	ldw	r2,32(r2)
 d01d634:	1004c03a 	cmpne	r2,r2,zero
 d01d638:	1000091e 	bne	r2,zero,d01d660 <Netinit+0xdc>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 d01d63c:	e0bffa17 	ldw	r2,-24(fp)
 d01d640:	00c341b4 	movhi	r3,3334
 d01d644:	18c31a04 	addi	r3,r3,3176
 d01d648:	1085883a 	add	r2,r2,r2
 d01d64c:	1085883a 	add	r2,r2,r2
 d01d650:	10c5883a 	add	r2,r2,r3
 d01d654:	10c00017 	ldw	r3,0(r2)
 d01d658:	00800404 	movi	r2,16
 d01d65c:	18800815 	stw	r2,32(r3)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 d01d660:	e0bffa17 	ldw	r2,-24(fp)
 d01d664:	00c341b4 	movhi	r3,3334
 d01d668:	18c31a04 	addi	r3,r3,3176
 d01d66c:	1085883a 	add	r2,r2,r2
 d01d670:	1085883a 	add	r2,r2,r2
 d01d674:	10c5883a 	add	r2,r2,r3
 d01d678:	10800017 	ldw	r2,0(r2)
 d01d67c:	10800817 	ldw	r2,32(r2)
 d01d680:	d0e8ff17 	ldw	r3,-23556(gp)
 d01d684:	e0ffff15 	stw	r3,-4(fp)
 d01d688:	e0bffe15 	stw	r2,-8(fp)
 d01d68c:	e0bffe17 	ldw	r2,-8(fp)
 d01d690:	e0ffff17 	ldw	r3,-4(fp)
 d01d694:	10c0020e 	bge	r2,r3,d01d6a0 <Netinit+0x11c>
 d01d698:	e0bfff17 	ldw	r2,-4(fp)
 d01d69c:	e0bffe15 	stw	r2,-8(fp)
 d01d6a0:	e0fffe17 	ldw	r3,-8(fp)
 d01d6a4:	d0e8ff15 	stw	r3,-23556(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 d01d6a8:	e0bffa17 	ldw	r2,-24(fp)
 d01d6ac:	00c341b4 	movhi	r3,3334
 d01d6b0:	18c31a04 	addi	r3,r3,3176
 d01d6b4:	1085883a 	add	r2,r2,r2
 d01d6b8:	1085883a 	add	r2,r2,r2
 d01d6bc:	10c5883a 	add	r2,r2,r3
 d01d6c0:	10800017 	ldw	r2,0(r2)
 d01d6c4:	10800917 	ldw	r2,36(r2)
 d01d6c8:	d0e90017 	ldw	r3,-23552(gp)
 d01d6cc:	e0fffd15 	stw	r3,-12(fp)
 d01d6d0:	e0bffc15 	stw	r2,-16(fp)
 d01d6d4:	e0bffc17 	ldw	r2,-16(fp)
 d01d6d8:	e0fffd17 	ldw	r3,-12(fp)
 d01d6dc:	10c0020e 	bge	r2,r3,d01d6e8 <Netinit+0x164>
 d01d6e0:	e0bffd17 	ldw	r2,-12(fp)
 d01d6e4:	e0bffc15 	stw	r2,-16(fp)
 d01d6e8:	e0fffc17 	ldw	r3,-16(fp)
 d01d6ec:	d0e90015 	stw	r3,-23552(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 d01d6f0:	e0bffa17 	ldw	r2,-24(fp)
 d01d6f4:	10800044 	addi	r2,r2,1
 d01d6f8:	e0bffa15 	stw	r2,-24(fp)
 d01d6fc:	00834174 	movhi	r2,3333
 d01d700:	109b2104 	addi	r2,r2,27780
 d01d704:	10800017 	ldw	r2,0(r2)
 d01d708:	1007883a 	mov	r3,r2
 d01d70c:	e0bffa17 	ldw	r2,-24(fp)
 d01d710:	10ffa216 	blt	r2,r3,d01d59c <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 d01d714:	008341b4 	movhi	r2,3334
 d01d718:	10825504 	addi	r2,r2,2388
 d01d71c:	10000115 	stw	zero,4(r2)
 d01d720:	008341b4 	movhi	r2,3334
 d01d724:	10825504 	addi	r2,r2,2388
 d01d728:	10c00117 	ldw	r3,4(r2)
 d01d72c:	008341b4 	movhi	r2,3334
 d01d730:	10825504 	addi	r2,r2,2388
 d01d734:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 d01d738:	008341b4 	movhi	r2,3334
 d01d73c:	10825504 	addi	r2,r2,2388
 d01d740:	10000215 	stw	zero,8(r2)
 d01d744:	008341b4 	movhi	r2,3334
 d01d748:	10825504 	addi	r2,r2,2388
 d01d74c:	10c00217 	ldw	r3,8(r2)
 d01d750:	008341b4 	movhi	r2,3334
 d01d754:	10825504 	addi	r2,r2,2388
 d01d758:	10c00415 	stw	r3,16(r2)
 d01d75c:	008341b4 	movhi	r2,3334
 d01d760:	10825504 	addi	r2,r2,2388
 d01d764:	10c00417 	ldw	r3,16(r2)
 d01d768:	008341b4 	movhi	r2,3334
 d01d76c:	10825504 	addi	r2,r2,2388
 d01d770:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d01d774:	01000084 	movi	r4,2
 d01d778:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   e = pk_init();
 d01d77c:	d024b7c0 	call	d024b7c <pk_init>
 d01d780:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01d784:	01000084 	movi	r4,2
 d01d788:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 d01d78c:	e0bff917 	ldw	r2,-28(fp)
 d01d790:	1005003a 	cmpeq	r2,r2,zero
 d01d794:	1000031e 	bne	r2,zero,d01d7a4 <Netinit+0x220>
      return e;
 d01d798:	e0bff917 	ldw	r2,-28(fp)
 d01d79c:	e0bffb15 	stw	r2,-20(fp)
 d01d7a0:	00010506 	br	d01dbb8 <Netinit+0x634>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 d01d7a4:	010340b4 	movhi	r4,3330
 d01d7a8:	21374c04 	addi	r4,r4,-8912
 d01d7ac:	d01e7500 	call	d01e750 <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 d01d7b0:	e03ffa15 	stw	zero,-24(fp)
 d01d7b4:	0000f906 	br	d01db9c <Netinit+0x618>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 d01d7b8:	e0bffa17 	ldw	r2,-24(fp)
 d01d7bc:	00c341b4 	movhi	r3,3334
 d01d7c0:	18c31a04 	addi	r3,r3,3176
 d01d7c4:	1085883a 	add	r2,r2,r2
 d01d7c8:	1085883a 	add	r2,r2,r2
 d01d7cc:	10c5883a 	add	r2,r2,r3
 d01d7d0:	10800017 	ldw	r2,0(r2)
 d01d7d4:	10800217 	ldw	r2,8(r2)
 d01d7d8:	1005003a 	cmpeq	r2,r2,zero
 d01d7dc:	1000931e 	bne	r2,zero,d01da2c <Netinit+0x4a8>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 d01d7e0:	e0bffa17 	ldw	r2,-24(fp)
 d01d7e4:	00c341b4 	movhi	r3,3334
 d01d7e8:	18c31a04 	addi	r3,r3,3176
 d01d7ec:	1085883a 	add	r2,r2,r2
 d01d7f0:	1085883a 	add	r2,r2,r2
 d01d7f4:	10c5883a 	add	r2,r2,r3
 d01d7f8:	10800017 	ldw	r2,0(r2)
 d01d7fc:	10800217 	ldw	r2,8(r2)
 d01d800:	e13ffa17 	ldw	r4,-24(fp)
 d01d804:	103ee83a 	callr	r2
 d01d808:	e0bff915 	stw	r2,-28(fp)
 d01d80c:	e0bff917 	ldw	r2,-28(fp)
 d01d810:	1005003a 	cmpeq	r2,r2,zero
 d01d814:	1000101e 	bne	r2,zero,d01d858 <Netinit+0x2d4>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 d01d818:	01034174 	movhi	r4,3333
 d01d81c:	213abc04 	addi	r4,r4,-5392
 d01d820:	e17ff917 	ldw	r5,-28(fp)
 d01d824:	e1bffa17 	ldw	r6,-24(fp)
 d01d828:	d0028a00 	call	d0028a0 <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 d01d82c:	e0bffa17 	ldw	r2,-24(fp)
 d01d830:	00c341b4 	movhi	r3,3334
 d01d834:	18c31a04 	addi	r3,r3,3176
 d01d838:	1085883a 	add	r2,r2,r2
 d01d83c:	1085883a 	add	r2,r2,r2
 d01d840:	10c5883a 	add	r2,r2,r3
 d01d844:	10800017 	ldw	r2,0(r2)
 d01d848:	10c02717 	ldw	r3,156(r2)
 d01d84c:	00800084 	movi	r2,2
 d01d850:	18800715 	stw	r2,28(r3)
            continue;   /* ignore ifaces which fail */
 d01d854:	0000ce06 	br	d01db90 <Netinit+0x60c>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 d01d858:	e0bffa17 	ldw	r2,-24(fp)
 d01d85c:	00c341b4 	movhi	r3,3334
 d01d860:	18c31a04 	addi	r3,r3,3176
 d01d864:	1085883a 	add	r2,r2,r2
 d01d868:	1085883a 	add	r2,r2,r2
 d01d86c:	10c5883a 	add	r2,r2,r3
 d01d870:	10800017 	ldw	r2,0(r2)
 d01d874:	10802717 	ldw	r2,156(r2)
 d01d878:	10800217 	ldw	r2,8(r2)
 d01d87c:	10800198 	cmpnei	r2,r2,6
 d01d880:	1000111e 	bne	r2,zero,d01d8c8 <Netinit+0x344>
            nets[i]->n_flags |= NF_BCAST;
 d01d884:	e0bffa17 	ldw	r2,-24(fp)
 d01d888:	00c341b4 	movhi	r3,3334
 d01d88c:	18c31a04 	addi	r3,r3,3176
 d01d890:	1085883a 	add	r2,r2,r2
 d01d894:	1085883a 	add	r2,r2,r2
 d01d898:	10c5883a 	add	r2,r2,r3
 d01d89c:	11000017 	ldw	r4,0(r2)
 d01d8a0:	e0bffa17 	ldw	r2,-24(fp)
 d01d8a4:	00c341b4 	movhi	r3,3334
 d01d8a8:	18c31a04 	addi	r3,r3,3176
 d01d8ac:	1085883a 	add	r2,r2,r2
 d01d8b0:	1085883a 	add	r2,r2,r2
 d01d8b4:	10c5883a 	add	r2,r2,r3
 d01d8b8:	10800017 	ldw	r2,0(r2)
 d01d8bc:	10802a17 	ldw	r2,168(r2)
 d01d8c0:	10800054 	ori	r2,r2,1
 d01d8c4:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 d01d8c8:	e0bffa17 	ldw	r2,-24(fp)
 d01d8cc:	00c341b4 	movhi	r3,3334
 d01d8d0:	18c31a04 	addi	r3,r3,3176
 d01d8d4:	1085883a 	add	r2,r2,r2
 d01d8d8:	1085883a 	add	r2,r2,r2
 d01d8dc:	10c5883a 	add	r2,r2,r3
 d01d8e0:	10800017 	ldw	r2,0(r2)
 d01d8e4:	10c02717 	ldw	r3,156(r2)
 d01d8e8:	00800044 	movi	r2,1
 d01d8ec:	18800615 	stw	r2,24(r3)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 d01d8f0:	e0bffa17 	ldw	r2,-24(fp)
 d01d8f4:	00c341b4 	movhi	r3,3334
 d01d8f8:	18c31a04 	addi	r3,r3,3176
 d01d8fc:	1085883a 	add	r2,r2,r2
 d01d900:	1085883a 	add	r2,r2,r2
 d01d904:	10c5883a 	add	r2,r2,r3
 d01d908:	10800017 	ldw	r2,0(r2)
 d01d90c:	10800103 	ldbu	r2,4(r2)
 d01d910:	10803fcc 	andi	r2,r2,255
 d01d914:	1080201c 	xori	r2,r2,128
 d01d918:	10bfe004 	addi	r2,r2,-128
 d01d91c:	1004c03a 	cmpne	r2,r2,zero
 d01d920:	1000421e 	bne	r2,zero,d01da2c <Netinit+0x4a8>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 d01d924:	e0bffa17 	ldw	r2,-24(fp)
 d01d928:	00c341b4 	movhi	r3,3334
 d01d92c:	18c31a04 	addi	r3,r3,3176
 d01d930:	1085883a 	add	r2,r2,r2
 d01d934:	1085883a 	add	r2,r2,r2
 d01d938:	10c5883a 	add	r2,r2,r3
 d01d93c:	10800017 	ldw	r2,0(r2)
 d01d940:	10802717 	ldw	r2,156(r2)
 d01d944:	10800217 	ldw	r2,8(r2)
 d01d948:	10800198 	cmpnei	r2,r2,6
 d01d94c:	1000131e 	bne	r2,zero,d01d99c <Netinit+0x418>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 d01d950:	e0bffa17 	ldw	r2,-24(fp)
 d01d954:	00c341b4 	movhi	r3,3334
 d01d958:	18c31a04 	addi	r3,r3,3176
 d01d95c:	1085883a 	add	r2,r2,r2
 d01d960:	1085883a 	add	r2,r2,r2
 d01d964:	10c5883a 	add	r2,r2,r3
 d01d968:	10c00017 	ldw	r3,0(r2)
 d01d96c:	00801944 	movi	r2,101
 d01d970:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 't';
 d01d974:	e0bffa17 	ldw	r2,-24(fp)
 d01d978:	00c341b4 	movhi	r3,3334
 d01d97c:	18c31a04 	addi	r3,r3,3176
 d01d980:	1085883a 	add	r2,r2,r2
 d01d984:	1085883a 	add	r2,r2,r2
 d01d988:	10c5883a 	add	r2,r2,r3
 d01d98c:	10c00017 	ldw	r3,0(r2)
 d01d990:	00801d04 	movi	r2,116
 d01d994:	18800145 	stb	r2,5(r3)
 d01d998:	00001206 	br	d01d9e4 <Netinit+0x460>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 d01d99c:	e0bffa17 	ldw	r2,-24(fp)
 d01d9a0:	00c341b4 	movhi	r3,3334
 d01d9a4:	18c31a04 	addi	r3,r3,3176
 d01d9a8:	1085883a 	add	r2,r2,r2
 d01d9ac:	1085883a 	add	r2,r2,r2
 d01d9b0:	10c5883a 	add	r2,r2,r3
 d01d9b4:	10c00017 	ldw	r3,0(r2)
 d01d9b8:	00801a44 	movi	r2,105
 d01d9bc:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 'f';
 d01d9c0:	e0bffa17 	ldw	r2,-24(fp)
 d01d9c4:	00c341b4 	movhi	r3,3334
 d01d9c8:	18c31a04 	addi	r3,r3,3176
 d01d9cc:	1085883a 	add	r2,r2,r2
 d01d9d0:	1085883a 	add	r2,r2,r2
 d01d9d4:	10c5883a 	add	r2,r2,r3
 d01d9d8:	10c00017 	ldw	r3,0(r2)
 d01d9dc:	00801984 	movi	r2,102
 d01d9e0:	18800145 	stb	r2,5(r3)
            }
            nets[i]->name[2] = (char)(i + '1');
 d01d9e4:	e0bffa17 	ldw	r2,-24(fp)
 d01d9e8:	00c341b4 	movhi	r3,3334
 d01d9ec:	18c31a04 	addi	r3,r3,3176
 d01d9f0:	1085883a 	add	r2,r2,r2
 d01d9f4:	1085883a 	add	r2,r2,r2
 d01d9f8:	10c5883a 	add	r2,r2,r3
 d01d9fc:	10c00017 	ldw	r3,0(r2)
 d01da00:	e0bffa17 	ldw	r2,-24(fp)
 d01da04:	10800c44 	addi	r2,r2,49
 d01da08:	18800185 	stb	r2,6(r3)
            nets[i]->name[3] = '\0';
 d01da0c:	e0bffa17 	ldw	r2,-24(fp)
 d01da10:	00c341b4 	movhi	r3,3334
 d01da14:	18c31a04 	addi	r3,r3,3176
 d01da18:	1085883a 	add	r2,r2,r2
 d01da1c:	1085883a 	add	r2,r2,r2
 d01da20:	10c5883a 	add	r2,r2,r3
 d01da24:	10800017 	ldw	r2,0(r2)
 d01da28:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 d01da2c:	e13ffa17 	ldw	r4,-24(fp)
 d01da30:	d01dbd00 	call	d01dbd0 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 d01da34:	e0bffa17 	ldw	r2,-24(fp)
 d01da38:	00c341b4 	movhi	r3,3334
 d01da3c:	18c31a04 	addi	r3,r3,3176
 d01da40:	1085883a 	add	r2,r2,r2
 d01da44:	1085883a 	add	r2,r2,r2
 d01da48:	10c5883a 	add	r2,r2,r3
 d01da4c:	10800017 	ldw	r2,0(r2)
 d01da50:	10800a17 	ldw	r2,40(r2)
 d01da54:	1005003a 	cmpeq	r2,r2,zero
 d01da58:	10004d1e 	bne	r2,zero,d01db90 <Netinit+0x60c>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 d01da5c:	e0bffa17 	ldw	r2,-24(fp)
 d01da60:	00c341b4 	movhi	r3,3334
 d01da64:	18c31a04 	addi	r3,r3,3176
 d01da68:	1085883a 	add	r2,r2,r2
 d01da6c:	1085883a 	add	r2,r2,r2
 d01da70:	10c5883a 	add	r2,r2,r3
 d01da74:	11400017 	ldw	r5,0(r2)
 d01da78:	e0bffa17 	ldw	r2,-24(fp)
 d01da7c:	00c341b4 	movhi	r3,3334
 d01da80:	18c31a04 	addi	r3,r3,3176
 d01da84:	1085883a 	add	r2,r2,r2
 d01da88:	1085883a 	add	r2,r2,r2
 d01da8c:	10c5883a 	add	r2,r2,r3
 d01da90:	10800017 	ldw	r2,0(r2)
 d01da94:	11000a17 	ldw	r4,40(r2)
 d01da98:	e0bffa17 	ldw	r2,-24(fp)
 d01da9c:	00c341b4 	movhi	r3,3334
 d01daa0:	18c31a04 	addi	r3,r3,3176
 d01daa4:	1085883a 	add	r2,r2,r2
 d01daa8:	1085883a 	add	r2,r2,r2
 d01daac:	10c5883a 	add	r2,r2,r3
 d01dab0:	10800017 	ldw	r2,0(r2)
 d01dab4:	10800c17 	ldw	r2,48(r2)
 d01dab8:	0084303a 	nor	r2,zero,r2
 d01dabc:	2084b03a 	or	r2,r4,r2
 d01dac0:	28800e15 	stw	r2,56(r5)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 d01dac4:	e0bffa17 	ldw	r2,-24(fp)
 d01dac8:	00c341b4 	movhi	r3,3334
 d01dacc:	18c31a04 	addi	r3,r3,3176
 d01dad0:	1085883a 	add	r2,r2,r2
 d01dad4:	1085883a 	add	r2,r2,r2
 d01dad8:	10c5883a 	add	r2,r2,r3
 d01dadc:	11400017 	ldw	r5,0(r2)
 d01dae0:	e0bffa17 	ldw	r2,-24(fp)
 d01dae4:	00c341b4 	movhi	r3,3334
 d01dae8:	18c31a04 	addi	r3,r3,3176
 d01daec:	1085883a 	add	r2,r2,r2
 d01daf0:	1085883a 	add	r2,r2,r2
 d01daf4:	10c5883a 	add	r2,r2,r3
 d01daf8:	10800017 	ldw	r2,0(r2)
 d01dafc:	11000a17 	ldw	r4,40(r2)
 d01db00:	e0bffa17 	ldw	r2,-24(fp)
 d01db04:	00c341b4 	movhi	r3,3334
 d01db08:	18c31a04 	addi	r3,r3,3176
 d01db0c:	1085883a 	add	r2,r2,r2
 d01db10:	1085883a 	add	r2,r2,r2
 d01db14:	10c5883a 	add	r2,r2,r3
 d01db18:	10800017 	ldw	r2,0(r2)
 d01db1c:	10800c17 	ldw	r2,48(r2)
 d01db20:	2084703a 	and	r2,r4,r2
 d01db24:	28800f15 	stw	r2,60(r5)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 d01db28:	e0bffa17 	ldw	r2,-24(fp)
 d01db2c:	00c341b4 	movhi	r3,3334
 d01db30:	18c31a04 	addi	r3,r3,3176
 d01db34:	1085883a 	add	r2,r2,r2
 d01db38:	1085883a 	add	r2,r2,r2
 d01db3c:	10c5883a 	add	r2,r2,r3
 d01db40:	11400017 	ldw	r5,0(r2)
 d01db44:	e0bffa17 	ldw	r2,-24(fp)
 d01db48:	00c341b4 	movhi	r3,3334
 d01db4c:	18c31a04 	addi	r3,r3,3176
 d01db50:	1085883a 	add	r2,r2,r2
 d01db54:	1085883a 	add	r2,r2,r2
 d01db58:	10c5883a 	add	r2,r2,r3
 d01db5c:	10800017 	ldw	r2,0(r2)
 d01db60:	11000a17 	ldw	r4,40(r2)
 d01db64:	e0bffa17 	ldw	r2,-24(fp)
 d01db68:	00c341b4 	movhi	r3,3334
 d01db6c:	18c31a04 	addi	r3,r3,3176
 d01db70:	1085883a 	add	r2,r2,r2
 d01db74:	1085883a 	add	r2,r2,r2
 d01db78:	10c5883a 	add	r2,r2,r3
 d01db7c:	10800017 	ldw	r2,0(r2)
 d01db80:	10800c17 	ldw	r2,48(r2)
 d01db84:	0084303a 	nor	r2,zero,r2
 d01db88:	2084b03a 	or	r2,r4,r2
 d01db8c:	28801015 	stw	r2,64(r5)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 d01db90:	e0bffa17 	ldw	r2,-24(fp)
 d01db94:	10800044 	addi	r2,r2,1
 d01db98:	e0bffa15 	stw	r2,-24(fp)
 d01db9c:	00834174 	movhi	r2,3333
 d01dba0:	109b2104 	addi	r2,r2,27780
 d01dba4:	10800017 	ldw	r2,0(r2)
 d01dba8:	1007883a 	mov	r3,r2
 d01dbac:	e0bffa17 	ldw	r2,-24(fp)
 d01dbb0:	10ff0116 	blt	r2,r3,d01d7b8 <Netinit+0x234>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 d01dbb4:	e03ffb15 	stw	zero,-20(fp)
 d01dbb8:	e0bffb17 	ldw	r2,-20(fp)
}
 d01dbbc:	e037883a 	mov	sp,fp
 d01dbc0:	dfc00117 	ldw	ra,4(sp)
 d01dbc4:	df000017 	ldw	fp,0(sp)
 d01dbc8:	dec00204 	addi	sp,sp,8
 d01dbcc:	f800283a 	ret

0d01dbd0 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 d01dbd0:	defffc04 	addi	sp,sp,-16
 d01dbd4:	dfc00315 	stw	ra,12(sp)
 d01dbd8:	df000215 	stw	fp,8(sp)
 d01dbdc:	df000204 	addi	fp,sp,8
 d01dbe0:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 d01dbe4:	e0bfff17 	ldw	r2,-4(fp)
 d01dbe8:	00c341b4 	movhi	r3,3334
 d01dbec:	18c31a04 	addi	r3,r3,3176
 d01dbf0:	1085883a 	add	r2,r2,r2
 d01dbf4:	1085883a 	add	r2,r2,r2
 d01dbf8:	10c5883a 	add	r2,r2,r3
 d01dbfc:	10800017 	ldw	r2,0(r2)
 d01dc00:	10800c17 	ldw	r2,48(r2)
 d01dc04:	1004c03a 	cmpne	r2,r2,zero
 d01dc08:	1000441e 	bne	r2,zero,d01dd1c <fixup_subnet_mask+0x14c>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 d01dc0c:	e0bfff17 	ldw	r2,-4(fp)
 d01dc10:	00c341b4 	movhi	r3,3334
 d01dc14:	18c31a04 	addi	r3,r3,3176
 d01dc18:	1085883a 	add	r2,r2,r2
 d01dc1c:	1085883a 	add	r2,r2,r2
 d01dc20:	10c5883a 	add	r2,r2,r3
 d01dc24:	10800017 	ldw	r2,0(r2)
 d01dc28:	10800a17 	ldw	r2,40(r2)
 d01dc2c:	1080200c 	andi	r2,r2,128
 d01dc30:	1004c03a 	cmpne	r2,r2,zero
 d01dc34:	1000031e 	bne	r2,zero,d01dc44 <fixup_subnet_mask+0x74>
      smask = 0xFF000000L;
 d01dc38:	00bfc034 	movhi	r2,65280
 d01dc3c:	e0bffe15 	stw	r2,-8(fp)
 d01dc40:	00001f06 	br	d01dcc0 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 d01dc44:	e0bfff17 	ldw	r2,-4(fp)
 d01dc48:	00c341b4 	movhi	r3,3334
 d01dc4c:	18c31a04 	addi	r3,r3,3176
 d01dc50:	1085883a 	add	r2,r2,r2
 d01dc54:	1085883a 	add	r2,r2,r2
 d01dc58:	10c5883a 	add	r2,r2,r3
 d01dc5c:	10800017 	ldw	r2,0(r2)
 d01dc60:	10800a17 	ldw	r2,40(r2)
 d01dc64:	1080300c 	andi	r2,r2,192
 d01dc68:	10802018 	cmpnei	r2,r2,128
 d01dc6c:	1000031e 	bne	r2,zero,d01dc7c <fixup_subnet_mask+0xac>
      smask = 0xFFFF0000L;
 d01dc70:	00bffff4 	movhi	r2,65535
 d01dc74:	e0bffe15 	stw	r2,-8(fp)
 d01dc78:	00001106 	br	d01dcc0 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 d01dc7c:	e0bfff17 	ldw	r2,-4(fp)
 d01dc80:	00c341b4 	movhi	r3,3334
 d01dc84:	18c31a04 	addi	r3,r3,3176
 d01dc88:	1085883a 	add	r2,r2,r2
 d01dc8c:	1085883a 	add	r2,r2,r2
 d01dc90:	10c5883a 	add	r2,r2,r3
 d01dc94:	10800017 	ldw	r2,0(r2)
 d01dc98:	10800a17 	ldw	r2,40(r2)
 d01dc9c:	1080380c 	andi	r2,r2,224
 d01dca0:	10803018 	cmpnei	r2,r2,192
 d01dca4:	1000031e 	bne	r2,zero,d01dcb4 <fixup_subnet_mask+0xe4>
      smask = 0xFFFFFF00L;
 d01dca8:	00bfc004 	movi	r2,-256
 d01dcac:	e0bffe15 	stw	r2,-8(fp)
 d01dcb0:	00000306 	br	d01dcc0 <fixup_subnet_mask+0xf0>
   else
   {
      dtrap();    /* bad logic or setup values */
 d01dcb4:	d025a500 	call	d025a50 <dtrap>
      smask = 0xFFFFFF00L;
 d01dcb8:	00bfc004 	movi	r2,-256
 d01dcbc:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 d01dcc0:	e0bfff17 	ldw	r2,-4(fp)
 d01dcc4:	00c341b4 	movhi	r3,3334
 d01dcc8:	18c31a04 	addi	r3,r3,3176
 d01dccc:	1085883a 	add	r2,r2,r2
 d01dcd0:	1085883a 	add	r2,r2,r2
 d01dcd4:	10c5883a 	add	r2,r2,r3
 d01dcd8:	11000017 	ldw	r4,0(r2)
 d01dcdc:	e0bffe17 	ldw	r2,-8(fp)
 d01dce0:	1004d63a 	srli	r2,r2,24
 d01dce4:	10c03fcc 	andi	r3,r2,255
 d01dce8:	e0bffe17 	ldw	r2,-8(fp)
 d01dcec:	1004d23a 	srli	r2,r2,8
 d01dcf0:	10bfc00c 	andi	r2,r2,65280
 d01dcf4:	1886b03a 	or	r3,r3,r2
 d01dcf8:	e0bffe17 	ldw	r2,-8(fp)
 d01dcfc:	10bfc00c 	andi	r2,r2,65280
 d01dd00:	1004923a 	slli	r2,r2,8
 d01dd04:	1886b03a 	or	r3,r3,r2
 d01dd08:	e0bffe17 	ldw	r2,-8(fp)
 d01dd0c:	10803fcc 	andi	r2,r2,255
 d01dd10:	1004963a 	slli	r2,r2,24
 d01dd14:	1884b03a 	or	r2,r3,r2
 d01dd18:	20800c15 	stw	r2,48(r4)
}
 d01dd1c:	e037883a 	mov	sp,fp
 d01dd20:	dfc00117 	ldw	ra,4(sp)
 d01dd24:	df000017 	ldw	fp,0(sp)
 d01dd28:	dec00204 	addi	sp,sp,8
 d01dd2c:	f800283a 	ret

0d01dd30 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 d01dd30:	defffc04 	addi	sp,sp,-16
 d01dd34:	dfc00315 	stw	ra,12(sp)
 d01dd38:	df000215 	stw	fp,8(sp)
 d01dd3c:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 d01dd40:	e03ffe15 	stw	zero,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 d01dd44:	d0a90117 	ldw	r2,-23548(gp)
 d01dd48:	1080010c 	andi	r2,r2,4
 d01dd4c:	1005003a 	cmpeq	r2,r2,zero
 d01dd50:	1000031e 	bne	r2,zero,d01dd60 <netclose+0x30>
 d01dd54:	01034174 	movhi	r4,3333
 d01dd58:	213ac304 	addi	r4,r4,-5364
 d01dd5c:	d002bc80 	call	d002bc8 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 d01dd60:	008341b4 	movhi	r2,3334
 d01dd64:	10856304 	addi	r2,r2,5516
 d01dd68:	10800017 	ldw	r2,0(r2)
 d01dd6c:	e0bfff15 	stw	r2,-4(fp)
 d01dd70:	00002106 	br	d01ddf8 <netclose+0xc8>
   {
      if (ifp->n_close)
 d01dd74:	e0bfff17 	ldw	r2,-4(fp)
 d01dd78:	10800517 	ldw	r2,20(r2)
 d01dd7c:	1005003a 	cmpeq	r2,r2,zero
 d01dd80:	10000e1e 	bne	r2,zero,d01ddbc <netclose+0x8c>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 d01dd84:	e0bfff17 	ldw	r2,-4(fp)
 d01dd88:	10802717 	ldw	r2,156(r2)
 d01dd8c:	11400117 	ldw	r5,4(r2)
 d01dd90:	01034174 	movhi	r4,3333
 d01dd94:	213ac804 	addi	r4,r4,-5344
 d01dd98:	d0028a00 	call	d0028a0 <printf>
         (*(ifp->n_close))(index++);
 d01dd9c:	e0bfff17 	ldw	r2,-4(fp)
 d01dda0:	10c00517 	ldw	r3,20(r2)
 d01dda4:	e13ffe17 	ldw	r4,-8(fp)
 d01dda8:	e0bffe17 	ldw	r2,-8(fp)
 d01ddac:	10800044 	addi	r2,r2,1
 d01ddb0:	e0bffe15 	stw	r2,-8(fp)
 d01ddb4:	183ee83a 	callr	r3
 d01ddb8:	00000c06 	br	d01ddec <netclose+0xbc>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 d01ddbc:	d0a90117 	ldw	r2,-23548(gp)
 d01ddc0:	1080010c 	andi	r2,r2,4
 d01ddc4:	1005003a 	cmpeq	r2,r2,zero
 d01ddc8:	1000051e 	bne	r2,zero,d01dde0 <netclose+0xb0>
 d01ddcc:	e0bfff17 	ldw	r2,-4(fp)
 d01ddd0:	11400104 	addi	r5,r2,4
 d01ddd4:	01034174 	movhi	r4,3333
 d01ddd8:	213acf04 	addi	r4,r4,-5316
 d01dddc:	d0028a00 	call	d0028a0 <printf>
#endif
         index++;
 d01dde0:	e0bffe17 	ldw	r2,-8(fp)
 d01dde4:	10800044 	addi	r2,r2,1
 d01dde8:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 d01ddec:	e0bfff17 	ldw	r2,-4(fp)
 d01ddf0:	10800017 	ldw	r2,0(r2)
 d01ddf4:	e0bfff15 	stw	r2,-4(fp)
 d01ddf8:	e0bfff17 	ldw	r2,-4(fp)
 d01ddfc:	1004c03a 	cmpne	r2,r2,zero
 d01de00:	103fdc1e 	bne	r2,zero,d01dd74 <netclose+0x44>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 d01de04:	e037883a 	mov	sp,fp
 d01de08:	dfc00117 	ldw	ra,4(sp)
 d01de0c:	df000017 	ldw	fp,0(sp)
 d01de10:	dec00204 	addi	sp,sp,8
 d01de14:	f800283a 	ret

0d01de18 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 d01de18:	defff804 	addi	sp,sp,-32
 d01de1c:	dfc00715 	stw	ra,28(sp)
 d01de20:	df000615 	stw	fp,24(sp)
 d01de24:	df000604 	addi	fp,sp,24
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 d01de28:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 d01de2c:	0000e506 	br	d01e1c4 <pktdemux+0x3ac>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 d01de30:	008341b4 	movhi	r2,3334
 d01de34:	1083c104 	addi	r2,r2,3844
 d01de38:	10c00217 	ldw	r3,8(r2)
 d01de3c:	e0bffb17 	ldw	r2,-20(fp)
 d01de40:	1884803a 	cmplt	r2,r3,r2
 d01de44:	1007883a 	mov	r3,r2
 d01de48:	e0bffb17 	ldw	r2,-20(fp)
 d01de4c:	10800044 	addi	r2,r2,1
 d01de50:	e0bffb15 	stw	r2,-20(fp)
 d01de54:	18803fcc 	andi	r2,r3,255
 d01de58:	1005003a 	cmpeq	r2,r2,zero
 d01de5c:	1000021e 	bne	r2,zero,d01de68 <pktdemux+0x50>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 d01de60:	d0216100 	call	d021610 <tk_yield>
         pkts = 0;   /* reset counter */
 d01de64:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 d01de68:	01000044 	movi	r4,1
 d01de6c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 d01de70:	010341b4 	movhi	r4,3334
 d01de74:	21025504 	addi	r4,r4,2388
 d01de78:	d0253180 	call	d025318 <getq>
 d01de7c:	e0bffe15 	stw	r2,-8(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 d01de80:	01000044 	movi	r4,1
 d01de84:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 d01de88:	e0bffe17 	ldw	r2,-8(fp)
 d01de8c:	1004c03a 	cmpne	r2,r2,zero
 d01de90:	1000031e 	bne	r2,zero,d01dea0 <pktdemux+0x88>
 d01de94:	01034174 	movhi	r4,3333
 d01de98:	213ad604 	addi	r4,r4,-5288
 d01de9c:	d02093c0 	call	d02093c <panic>
      ifc = pkt->net;
 d01dea0:	e0bffe17 	ldw	r2,-8(fp)
 d01dea4:	10800617 	ldw	r2,24(r2)
 d01dea8:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 d01deac:	e0bffd17 	ldw	r2,-12(fp)
 d01deb0:	10802717 	ldw	r2,156(r2)
 d01deb4:	e0bffc15 	stw	r2,-16(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 d01deb8:	e0bffe17 	ldw	r2,-8(fp)
 d01debc:	10800117 	ldw	r2,4(r2)
 d01dec0:	11400084 	addi	r5,r2,2
 d01dec4:	e13ffd17 	ldw	r4,-12(fp)
 d01dec8:	d03e6300 	call	d03e630 <isbcast>
 d01decc:	1005003a 	cmpeq	r2,r2,zero
 d01ded0:	1000061e 	bne	r2,zero,d01deec <pktdemux+0xd4>
         mib->ifInNUcastPkts++;
 d01ded4:	e0bffc17 	ldw	r2,-16(fp)
 d01ded8:	10800b17 	ldw	r2,44(r2)
 d01dedc:	10c00044 	addi	r3,r2,1
 d01dee0:	e0bffc17 	ldw	r2,-16(fp)
 d01dee4:	10c00b15 	stw	r3,44(r2)
 d01dee8:	00000506 	br	d01df00 <pktdemux+0xe8>
      else
         mib->ifInUcastPkts++;
 d01deec:	e0bffc17 	ldw	r2,-16(fp)
 d01def0:	10800a17 	ldw	r2,40(r2)
 d01def4:	10c00044 	addi	r3,r2,1
 d01def8:	e0bffc17 	ldw	r2,-16(fp)
 d01defc:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 d01df00:	e0bffc17 	ldw	r2,-16(fp)
 d01df04:	10800617 	ldw	r2,24(r2)
 d01df08:	10800098 	cmpnei	r2,r2,2
 d01df0c:	10000c1e 	bne	r2,zero,d01df40 <pktdemux+0x128>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d01df10:	01000084 	movi	r4,2
 d01df14:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 d01df18:	e13ffe17 	ldw	r4,-8(fp)
 d01df1c:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01df20:	01000084 	movi	r4,2
 d01df24:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 d01df28:	e0bffc17 	ldw	r2,-16(fp)
 d01df2c:	10800c17 	ldw	r2,48(r2)
 d01df30:	10c00044 	addi	r3,r2,1
 d01df34:	e0bffc17 	ldw	r2,-16(fp)
 d01df38:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 d01df3c:	0000a106 	br	d01e1c4 <pktdemux+0x3ac>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 d01df40:	e0bffe17 	ldw	r2,-8(fp)
 d01df44:	10800117 	ldw	r2,4(r2)
 d01df48:	10bfff04 	addi	r2,r2,-4
 d01df4c:	10800003 	ldbu	r2,0(r2)
 d01df50:	10803fcc 	andi	r2,r2,255
 d01df54:	1080201c 	xori	r2,r2,128
 d01df58:	10bfe004 	addi	r2,r2,-128
 d01df5c:	10801358 	cmpnei	r2,r2,77
 d01df60:	10000b1e 	bne	r2,zero,d01df90 <pktdemux+0x178>
 d01df64:	e0bffe17 	ldw	r2,-8(fp)
 d01df68:	10c00117 	ldw	r3,4(r2)
 d01df6c:	e0bffe17 	ldw	r2,-8(fp)
 d01df70:	10800217 	ldw	r2,8(r2)
 d01df74:	1885883a 	add	r2,r3,r2
 d01df78:	10800003 	ldbu	r2,0(r2)
 d01df7c:	10803fcc 	andi	r2,r2,255
 d01df80:	1080201c 	xori	r2,r2,128
 d01df84:	10bfe004 	addi	r2,r2,-128
 d01df88:	10801360 	cmpeqi	r2,r2,77
 d01df8c:	1000041e 	bne	r2,zero,d01dfa0 <pktdemux+0x188>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 d01df90:	d025a500 	call	d025a50 <dtrap>
         panic("pktdemux: corrupt pkt");
 d01df94:	01034174 	movhi	r4,3333
 d01df98:	213adc04 	addi	r4,r4,-5264
 d01df9c:	d02093c0 	call	d02093c <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 d01dfa0:	e0bffd17 	ldw	r2,-12(fp)
 d01dfa4:	10802a17 	ldw	r2,168(r2)
 d01dfa8:	1080020c 	andi	r2,r2,8
 d01dfac:	1004c03a 	cmpne	r2,r2,zero
 d01dfb0:	10004d1e 	bne	r2,zero,d01e0e8 <pktdemux+0x2d0>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 d01dfb4:	e0bffd17 	ldw	r2,-12(fp)
 d01dfb8:	10802717 	ldw	r2,156(r2)
 d01dfbc:	10800217 	ldw	r2,8(r2)
 d01dfc0:	108001a0 	cmpeqi	r2,r2,6
 d01dfc4:	1000011e 	bne	r2,zero,d01dfcc <pktdemux+0x1b4>
 d01dfc8:	00003a06 	br	d01e0b4 <pktdemux+0x29c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 d01dfcc:	e0bffe17 	ldw	r2,-8(fp)
 d01dfd0:	10800117 	ldw	r2,4(r2)
 d01dfd4:	10800084 	addi	r2,r2,2
 d01dfd8:	e0bffa15 	stw	r2,-24(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 d01dfdc:	e0bffa17 	ldw	r2,-24(fp)
 d01dfe0:	10800304 	addi	r2,r2,12
 d01dfe4:	10800003 	ldbu	r2,0(r2)
 d01dfe8:	10803fcc 	andi	r2,r2,255
 d01dfec:	1080201c 	xori	r2,r2,128
 d01dff0:	10bfe004 	addi	r2,r2,-128
 d01dff4:	1004923a 	slli	r2,r2,8
 d01dff8:	1007883a 	mov	r3,r2
 d01dffc:	e0bffa17 	ldw	r2,-24(fp)
 d01e000:	10800344 	addi	r2,r2,13
 d01e004:	10800003 	ldbu	r2,0(r2)
 d01e008:	10803fcc 	andi	r2,r2,255
 d01e00c:	1080201c 	xori	r2,r2,128
 d01e010:	10bfe004 	addi	r2,r2,-128
 d01e014:	10803fcc 	andi	r2,r2,255
 d01e018:	1885883a 	add	r2,r3,r2
 d01e01c:	10bfffcc 	andi	r2,r2,65535
 d01e020:	1004d23a 	srli	r2,r2,8
 d01e024:	10803fcc 	andi	r2,r2,255
 d01e028:	1009883a 	mov	r4,r2
 d01e02c:	e0bffa17 	ldw	r2,-24(fp)
 d01e030:	10800304 	addi	r2,r2,12
 d01e034:	10800003 	ldbu	r2,0(r2)
 d01e038:	10803fcc 	andi	r2,r2,255
 d01e03c:	1080201c 	xori	r2,r2,128
 d01e040:	10bfe004 	addi	r2,r2,-128
 d01e044:	1004923a 	slli	r2,r2,8
 d01e048:	1007883a 	mov	r3,r2
 d01e04c:	e0bffa17 	ldw	r2,-24(fp)
 d01e050:	10800344 	addi	r2,r2,13
 d01e054:	10800003 	ldbu	r2,0(r2)
 d01e058:	10803fcc 	andi	r2,r2,255
 d01e05c:	1080201c 	xori	r2,r2,128
 d01e060:	10bfe004 	addi	r2,r2,-128
 d01e064:	10803fcc 	andi	r2,r2,255
 d01e068:	1885883a 	add	r2,r3,r2
 d01e06c:	10bfffcc 	andi	r2,r2,65535
 d01e070:	1004923a 	slli	r2,r2,8
 d01e074:	1007883a 	mov	r3,r2
 d01e078:	00bfc004 	movi	r2,-256
 d01e07c:	1884703a 	and	r2,r3,r2
 d01e080:	2084b03a 	or	r2,r4,r2
 d01e084:	1007883a 	mov	r3,r2
 d01e088:	e0bffe17 	ldw	r2,-8(fp)
 d01e08c:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 d01e090:	e0bffe17 	ldw	r2,-8(fp)
 d01e094:	10c00117 	ldw	r3,4(r2)
 d01e098:	e0bffe17 	ldw	r2,-8(fp)
 d01e09c:	10800617 	ldw	r2,24(r2)
 d01e0a0:	10800817 	ldw	r2,32(r2)
 d01e0a4:	1887883a 	add	r3,r3,r2
 d01e0a8:	e0bffe17 	ldw	r2,-8(fp)
 d01e0ac:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 d01e0b0:	00000d06 	br	d01e0e8 <pktdemux+0x2d0>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 d01e0b4:	e0bffd17 	ldw	r2,-12(fp)
 d01e0b8:	10802717 	ldw	r2,156(r2)
 d01e0bc:	11400217 	ldw	r5,8(r2)
 d01e0c0:	01034174 	movhi	r4,3333
 d01e0c4:	213ae204 	addi	r4,r4,-5240
 d01e0c8:	d0028a00 	call	d0028a0 <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d01e0cc:	01000084 	movi	r4,2
 d01e0d0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 d01e0d4:	e13ffe17 	ldw	r4,-8(fp)
 d01e0d8:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01e0dc:	01000084 	movi	r4,2
 d01e0e0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            continue;
 d01e0e4:	00003706 	br	d01e1c4 <pktdemux+0x3ac>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 d01e0e8:	e0bffe17 	ldw	r2,-8(fp)
 d01e0ec:	1080080b 	ldhu	r2,32(r2)
 d01e0f0:	10bfffcc 	andi	r2,r2,65535
 d01e0f4:	e0bfff15 	stw	r2,-4(fp)
 d01e0f8:	e0ffff17 	ldw	r3,-4(fp)
 d01e0fc:	18800220 	cmpeqi	r2,r3,8
 d01e100:	1000041e 	bne	r2,zero,d01e114 <pktdemux+0x2fc>
 d01e104:	e0ffff17 	ldw	r3,-4(fp)
 d01e108:	18818220 	cmpeqi	r2,r3,1544
 d01e10c:	1000081e 	bne	r2,zero,d01e130 <pktdemux+0x318>
 d01e110:	00000e06 	br	d01e14c <pktdemux+0x334>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 d01e114:	0009883a 	mov	r4,zero
 d01e118:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 d01e11c:	e13ffe17 	ldw	r4,-8(fp)
 d01e120:	d0428a80 	call	d0428a8 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 d01e124:	0009883a 	mov	r4,zero
 d01e128:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         break;
 d01e12c:	00002506 	br	d01e1c4 <pktdemux+0x3ac>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 d01e130:	0009883a 	mov	r4,zero
 d01e134:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 d01e138:	e13ffe17 	ldw	r4,-8(fp)
 d01e13c:	d03ddc00 	call	d03ddc0 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 d01e140:	0009883a 	mov	r4,zero
 d01e144:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         break;
 d01e148:	00001e06 	br	d01e1c4 <pktdemux+0x3ac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 d01e14c:	d0a90117 	ldw	r2,-23548(gp)
 d01e150:	1081000c 	andi	r2,r2,1024
 d01e154:	1005003a 	cmpeq	r2,r2,zero
 d01e158:	10000f1e 	bne	r2,zero,d01e198 <pktdemux+0x380>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 d01e15c:	e0bffe17 	ldw	r2,-8(fp)
 d01e160:	1080080b 	ldhu	r2,32(r2)
 d01e164:	10bfffcc 	andi	r2,r2,65535
 d01e168:	1004d23a 	srli	r2,r2,8
 d01e16c:	10bfffcc 	andi	r2,r2,65535
 d01e170:	10c03fcc 	andi	r3,r2,255
 d01e174:	e0bffe17 	ldw	r2,-8(fp)
 d01e178:	1080080b 	ldhu	r2,32(r2)
 d01e17c:	10bfffcc 	andi	r2,r2,65535
 d01e180:	1004923a 	slli	r2,r2,8
 d01e184:	10bfc00c 	andi	r2,r2,65280
 d01e188:	188ab03a 	or	r5,r3,r2
 d01e18c:	01034174 	movhi	r4,3333
 d01e190:	213aea04 	addi	r4,r4,-5208
 d01e194:	d0028a00 	call	d0028a0 <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 d01e198:	e0bffd17 	ldw	r2,-12(fp)
 d01e19c:	10c02717 	ldw	r3,156(r2)
 d01e1a0:	18800e17 	ldw	r2,56(r3)
 d01e1a4:	10800044 	addi	r2,r2,1
 d01e1a8:	18800e15 	stw	r2,56(r3)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d01e1ac:	01000084 	movi	r4,2
 d01e1b0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 d01e1b4:	e13ffe17 	ldw	r4,-8(fp)
 d01e1b8:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01e1bc:	01000084 	movi	r4,2
 d01e1c0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 d01e1c4:	008341b4 	movhi	r2,3334
 d01e1c8:	10825504 	addi	r2,r2,2388
 d01e1cc:	10800217 	ldw	r2,8(r2)
 d01e1d0:	1004c03a 	cmpne	r2,r2,zero
 d01e1d4:	103f161e 	bne	r2,zero,d01de30 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 d01e1d8:	e037883a 	mov	sp,fp
 d01e1dc:	dfc00117 	ldw	ra,4(sp)
 d01e1e0:	df000017 	ldw	fp,0(sp)
 d01e1e4:	dec00204 	addi	sp,sp,8
 d01e1e8:	f800283a 	ret

0d01e1ec <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 d01e1ec:	defffc04 	addi	sp,sp,-16
 d01e1f0:	df000315 	stw	fp,12(sp)
 d01e1f4:	df000304 	addi	fp,sp,12
 d01e1f8:	e13ffd15 	stw	r4,-12(fp)
 d01e1fc:	e17ffe15 	stw	r5,-8(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 d01e200:	00834174 	movhi	r2,3333
 d01e204:	109b4504 	addi	r2,r2,27924
 d01e208:	10800017 	ldw	r2,0(r2)
 d01e20c:	1004403a 	cmpge	r2,r2,zero
 d01e210:	1000141e 	bne	r2,zero,d01e264 <c_older+0x78>
 d01e214:	00834174 	movhi	r2,3333
 d01e218:	109b4504 	addi	r2,r2,27924
 d01e21c:	10c00017 	ldw	r3,0(r2)
 d01e220:	e0bffd17 	ldw	r2,-12(fp)
 d01e224:	18800536 	bltu	r3,r2,d01e23c <c_older+0x50>
 d01e228:	00834174 	movhi	r2,3333
 d01e22c:	109b4504 	addi	r2,r2,27924
 d01e230:	10c00017 	ldw	r3,0(r2)
 d01e234:	e0bffe17 	ldw	r2,-8(fp)
 d01e238:	18800a2e 	bgeu	r3,r2,d01e264 <c_older+0x78>
 d01e23c:	00834174 	movhi	r2,3333
 d01e240:	109b4504 	addi	r2,r2,27924
 d01e244:	10c00017 	ldw	r3,0(r2)
 d01e248:	e0bffd17 	ldw	r2,-12(fp)
 d01e24c:	10c00e36 	bltu	r2,r3,d01e288 <c_older+0x9c>
 d01e250:	00834174 	movhi	r2,3333
 d01e254:	109b4504 	addi	r2,r2,27924
 d01e258:	10c00017 	ldw	r3,0(r2)
 d01e25c:	e0bffe17 	ldw	r2,-8(fp)
 d01e260:	10c00936 	bltu	r2,r3,d01e288 <c_older+0x9c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
   {
      if (ct1 < ct2)
 d01e264:	e0fffd17 	ldw	r3,-12(fp)
 d01e268:	e0bffe17 	ldw	r2,-8(fp)
 d01e26c:	1880032e 	bgeu	r3,r2,d01e27c <c_older+0x90>
         return(ct1);      /* then smaller is oldest */
 d01e270:	e0bffd17 	ldw	r2,-12(fp)
 d01e274:	e0bfff15 	stw	r2,-4(fp)
 d01e278:	00000b06 	br	d01e2a8 <c_older+0xbc>
      else 
         return(ct2);
 d01e27c:	e0bffe17 	ldw	r2,-8(fp)
 d01e280:	e0bfff15 	stw	r2,-4(fp)
 d01e284:	00000806 	br	d01e2a8 <c_older+0xbc>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 d01e288:	e0fffd17 	ldw	r3,-12(fp)
 d01e28c:	e0bffe17 	ldw	r2,-8(fp)
 d01e290:	18800336 	bltu	r3,r2,d01e2a0 <c_older+0xb4>
      return(ct1);
 d01e294:	e0bffd17 	ldw	r2,-12(fp)
 d01e298:	e0bfff15 	stw	r2,-4(fp)
 d01e29c:	00000206 	br	d01e2a8 <c_older+0xbc>
   else
      return(ct2);
 d01e2a0:	e0bffe17 	ldw	r2,-8(fp)
 d01e2a4:	e0bfff15 	stw	r2,-4(fp)
 d01e2a8:	e0bfff17 	ldw	r2,-4(fp)
}
 d01e2ac:	e037883a 	mov	sp,fp
 d01e2b0:	df000017 	ldw	fp,0(sp)
 d01e2b4:	dec00104 	addi	sp,sp,4
 d01e2b8:	f800283a 	ret

0d01e2bc <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 d01e2bc:	defffa04 	addi	sp,sp,-24
 d01e2c0:	dfc00515 	stw	ra,20(sp)
 d01e2c4:	df000415 	stw	fp,16(sp)
 d01e2c8:	df000404 	addi	fp,sp,16
 d01e2cc:	e13ffd15 	stw	r4,-12(fp)
 d01e2d0:	e17ffe15 	stw	r5,-8(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 d01e2d4:	e0bffd17 	ldw	r2,-12(fp)
 d01e2d8:	10800617 	ldw	r2,24(r2)
 d01e2dc:	10802717 	ldw	r2,156(r2)
 d01e2e0:	e0bffc15 	stw	r2,-16(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 d01e2e4:	e0bffc17 	ldw	r2,-16(fp)
 d01e2e8:	10800617 	ldw	r2,24(r2)
 d01e2ec:	10800098 	cmpnei	r2,r2,2
 d01e2f0:	1000091e 	bne	r2,zero,d01e318 <ip2mac+0x5c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d01e2f4:	01000084 	movi	r4,2
 d01e2f8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d01e2fc:	e13ffd17 	ldw	r4,-12(fp)
 d01e300:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01e304:	01000084 	movi	r4,2
 d01e308:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 d01e30c:	00bff7c4 	movi	r2,-33
 d01e310:	e0bfff15 	stw	r2,-4(fp)
 d01e314:	00004c06 	br	d01e448 <ip2mac+0x18c>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 d01e318:	e0bffd17 	ldw	r2,-12(fp)
 d01e31c:	10800617 	ldw	r2,24(r2)
 d01e320:	10800817 	ldw	r2,32(r2)
 d01e324:	1005003a 	cmpeq	r2,r2,zero
 d01e328:	1000081e 	bne	r2,zero,d01e34c <ip2mac+0x90>
 d01e32c:	e0bffc17 	ldw	r2,-16(fp)
 d01e330:	10800217 	ldw	r2,8(r2)
 d01e334:	108005e0 	cmpeqi	r2,r2,23
 d01e338:	1000041e 	bne	r2,zero,d01e34c <ip2mac+0x90>
 d01e33c:	e0bffc17 	ldw	r2,-16(fp)
 d01e340:	10800217 	ldw	r2,8(r2)
 d01e344:	10800718 	cmpnei	r2,r2,28
 d01e348:	1000291e 	bne	r2,zero,d01e3f0 <ip2mac+0x134>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 d01e34c:	e0bffc17 	ldw	r2,-16(fp)
 d01e350:	10801017 	ldw	r2,64(r2)
 d01e354:	10c00044 	addi	r3,r2,1
 d01e358:	e0bffc17 	ldw	r2,-16(fp)
 d01e35c:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 d01e360:	e0bffc17 	ldw	r2,-16(fp)
 d01e364:	10c00f17 	ldw	r3,60(r2)
 d01e368:	e0bffd17 	ldw	r2,-12(fp)
 d01e36c:	10800417 	ldw	r2,16(r2)
 d01e370:	1887883a 	add	r3,r3,r2
 d01e374:	e0bffc17 	ldw	r2,-16(fp)
 d01e378:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 d01e37c:	e0bffd17 	ldw	r2,-12(fp)
 d01e380:	10800617 	ldw	r2,24(r2)
 d01e384:	10800417 	ldw	r2,16(r2)
 d01e388:	1005003a 	cmpeq	r2,r2,zero
 d01e38c:	1000061e 	bne	r2,zero,d01e3a8 <ip2mac+0xec>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 d01e390:	e0bffd17 	ldw	r2,-12(fp)
 d01e394:	10800617 	ldw	r2,24(r2)
 d01e398:	10800417 	ldw	r2,16(r2)
 d01e39c:	e13ffd17 	ldw	r4,-12(fp)
 d01e3a0:	103ee83a 	callr	r2
 d01e3a4:	00001006 	br	d01e3e8 <ip2mac+0x12c>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 d01e3a8:	e0bffd17 	ldw	r2,-12(fp)
 d01e3ac:	10800617 	ldw	r2,24(r2)
 d01e3b0:	10c00317 	ldw	r3,12(r2)
 d01e3b4:	e0bffd17 	ldw	r2,-12(fp)
 d01e3b8:	11000617 	ldw	r4,24(r2)
 d01e3bc:	e0bffd17 	ldw	r2,-12(fp)
 d01e3c0:	11400317 	ldw	r5,12(r2)
 d01e3c4:	e0bffd17 	ldw	r2,-12(fp)
 d01e3c8:	11800417 	ldw	r6,16(r2)
 d01e3cc:	183ee83a 	callr	r3
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d01e3d0:	01000084 	movi	r4,2
 d01e3d4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d01e3d8:	e13ffd17 	ldw	r4,-12(fp)
 d01e3dc:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01e3e0:	01000084 	movi	r4,2
 d01e3e4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 d01e3e8:	e03fff15 	stw	zero,-4(fp)
 d01e3ec:	00001606 	br	d01e448 <ip2mac+0x18c>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 d01e3f0:	e0bffd17 	ldw	r2,-12(fp)
 d01e3f4:	10800617 	ldw	r2,24(r2)
 d01e3f8:	10800a17 	ldw	r2,40(r2)
 d01e3fc:	1004c03a 	cmpne	r2,r2,zero
 d01e400:	10000d1e 	bne	r2,zero,d01e438 <ip2mac+0x17c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 d01e404:	e0bffd17 	ldw	r2,-12(fp)
 d01e408:	10800717 	ldw	r2,28(r2)
 d01e40c:	10bfffe0 	cmpeqi	r2,r2,-1
 d01e410:	1000091e 	bne	r2,zero,d01e438 <ip2mac+0x17c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d01e414:	01000084 	movi	r4,2
 d01e418:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d01e41c:	e13ffd17 	ldw	r4,-12(fp)
 d01e420:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01e424:	01000084 	movi	r4,2
 d01e428:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 d01e42c:	00bff884 	movi	r2,-30
 d01e430:	e0bfff15 	stw	r2,-4(fp)
 d01e434:	00000406 	br	d01e448 <ip2mac+0x18c>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 d01e438:	e13ffd17 	ldw	r4,-12(fp)
 d01e43c:	e17ffe17 	ldw	r5,-8(fp)
 d01e440:	d03e0200 	call	d03e020 <send_via_arp>
 d01e444:	e0bfff15 	stw	r2,-4(fp)
 d01e448:	e0bfff17 	ldw	r2,-4(fp)
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 d01e44c:	e037883a 	mov	sp,fp
 d01e450:	dfc00117 	ldw	ra,4(sp)
 d01e454:	df000017 	ldw	fp,0(sp)
 d01e458:	dec00204 	addi	sp,sp,8
 d01e45c:	f800283a 	ret

0d01e460 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 d01e460:	defffa04 	addi	sp,sp,-24
 d01e464:	dfc00515 	stw	ra,20(sp)
 d01e468:	df000415 	stw	fp,16(sp)
 d01e46c:	dc000315 	stw	r16,12(sp)
 d01e470:	df000304 	addi	fp,sp,12
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 d01e474:	e03ffd15 	stw	zero,-12(fp)
 d01e478:	00002b06 	br	d01e528 <ip_startup+0xc8>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 d01e47c:	e43ffd17 	ldw	r16,-12(fp)
 d01e480:	e13ffd17 	ldw	r4,-12(fp)
 d01e484:	01403004 	movi	r5,192
 d01e488:	d00235c0 	call	d00235c <__mulsi3>
 d01e48c:	1007883a 	mov	r3,r2
 d01e490:	008341b4 	movhi	r2,3334
 d01e494:	10825a04 	addi	r2,r2,2408
 d01e498:	1889883a 	add	r4,r3,r2
 d01e49c:	00c341b4 	movhi	r3,3334
 d01e4a0:	18c31a04 	addi	r3,r3,3176
 d01e4a4:	8405883a 	add	r2,r16,r16
 d01e4a8:	1085883a 	add	r2,r2,r2
 d01e4ac:	10c5883a 	add	r2,r2,r3
 d01e4b0:	11000015 	stw	r4,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 d01e4b4:	e0bffd17 	ldw	r2,-12(fp)
 d01e4b8:	00c341b4 	movhi	r3,3334
 d01e4bc:	18c31a04 	addi	r3,r3,3176
 d01e4c0:	1085883a 	add	r2,r2,r2
 d01e4c4:	1085883a 	add	r2,r2,r2
 d01e4c8:	10c5883a 	add	r2,r2,r3
 d01e4cc:	11000017 	ldw	r4,0(r2)
 d01e4d0:	e0bffd17 	ldw	r2,-12(fp)
 d01e4d4:	00c341b4 	movhi	r3,3334
 d01e4d8:	18c31a04 	addi	r3,r3,3176
 d01e4dc:	1085883a 	add	r2,r2,r2
 d01e4e0:	1085883a 	add	r2,r2,r2
 d01e4e4:	10c5883a 	add	r2,r2,r3
 d01e4e8:	10800017 	ldw	r2,0(r2)
 d01e4ec:	10801204 	addi	r2,r2,72
 d01e4f0:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 d01e4f4:	e0bffd17 	ldw	r2,-12(fp)
 d01e4f8:	00c341b4 	movhi	r3,3334
 d01e4fc:	18c31a04 	addi	r3,r3,3176
 d01e500:	1085883a 	add	r2,r2,r2
 d01e504:	1085883a 	add	r2,r2,r2
 d01e508:	10c5883a 	add	r2,r2,r3
 d01e50c:	11400017 	ldw	r5,0(r2)
 d01e510:	010341b4 	movhi	r4,3334
 d01e514:	21056304 	addi	r4,r4,5516
 d01e518:	d0253e00 	call	d0253e0 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 d01e51c:	e0bffd17 	ldw	r2,-12(fp)
 d01e520:	10800044 	addi	r2,r2,1
 d01e524:	e0bffd15 	stw	r2,-12(fp)
 d01e528:	e0bffd17 	ldw	r2,-12(fp)
 d01e52c:	10800110 	cmplti	r2,r2,4
 d01e530:	103fd21e 	bne	r2,zero,d01e47c <ip_startup+0x1c>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 d01e534:	d0a90217 	ldw	r2,-23544(gp)
 d01e538:	1009883a 	mov	r4,r2
 d01e53c:	d0439d40 	call	d0439d4 <prep_ifaces>
 d01e540:	d0a90215 	stw	r2,-23544(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 d01e544:	d0a90217 	ldw	r2,-23544(gp)
 d01e548:	1004c03a 	cmpne	r2,r2,zero
 d01e54c:	1000041e 	bne	r2,zero,d01e560 <ip_startup+0x100>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 d01e550:	00834174 	movhi	r2,3333
 d01e554:	10bafb04 	addi	r2,r2,-5140
 d01e558:	e0bfff15 	stw	r2,-4(fp)
 d01e55c:	00007506 	br	d01e734 <ip_startup+0x2d4>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 d01e560:	d0a90217 	ldw	r2,-23544(gp)
 d01e564:	e0bffd15 	stw	r2,-12(fp)
 d01e568:	00001506 	br	d01e5c0 <ip_startup+0x160>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 d01e56c:	e0bffd17 	ldw	r2,-12(fp)
 d01e570:	00c341b4 	movhi	r3,3334
 d01e574:	18c31a04 	addi	r3,r3,3176
 d01e578:	1085883a 	add	r2,r2,r2
 d01e57c:	1085883a 	add	r2,r2,r2
 d01e580:	10c5883a 	add	r2,r2,r3
 d01e584:	10800017 	ldw	r2,0(r2)
 d01e588:	100b883a 	mov	r5,r2
 d01e58c:	010341b4 	movhi	r4,3334
 d01e590:	21056304 	addi	r4,r4,5516
 d01e594:	d0254900 	call	d025490 <qdel>
      nets[i] = NULL;               /* remove from array */
 d01e598:	e0bffd17 	ldw	r2,-12(fp)
 d01e59c:	00c341b4 	movhi	r3,3334
 d01e5a0:	18c31a04 	addi	r3,r3,3176
 d01e5a4:	1085883a 	add	r2,r2,r2
 d01e5a8:	1085883a 	add	r2,r2,r2
 d01e5ac:	10c5883a 	add	r2,r2,r3
 d01e5b0:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 d01e5b4:	e0bffd17 	ldw	r2,-12(fp)
 d01e5b8:	10800044 	addi	r2,r2,1
 d01e5bc:	e0bffd15 	stw	r2,-12(fp)
 d01e5c0:	e0bffd17 	ldw	r2,-12(fp)
 d01e5c4:	10800110 	cmplti	r2,r2,4
 d01e5c8:	103fe81e 	bne	r2,zero,d01e56c <ip_startup+0x10c>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 d01e5cc:	d025b8c0 	call	d025b8c <clock_init>
   exit_hook(clock_c);
 d01e5d0:	010340b4 	movhi	r4,3330
 d01e5d4:	2116f204 	addi	r4,r4,23496
 d01e5d8:	d01e7500 	call	d01e750 <exit_hook>

   e = Netinit();    /* start net interface(s) */
 d01e5dc:	d01d5840 	call	d01d584 <Netinit>
 d01e5e0:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d01e5e4:	e0bffe17 	ldw	r2,-8(fp)
 d01e5e8:	1005003a 	cmpeq	r2,r2,zero
 d01e5ec:	1000041e 	bne	r2,zero,d01e600 <ip_startup+0x1a0>
   {
      return("unable to initialize net");
 d01e5f0:	00834174 	movhi	r2,3333
 d01e5f4:	10bb0504 	addi	r2,r2,-5100
 d01e5f8:	e0bfff15 	stw	r2,-4(fp)
 d01e5fc:	00004d06 	br	d01e734 <ip_startup+0x2d4>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 d01e600:	d03d10c0 	call	d03d10c <etainit>
 d01e604:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d01e608:	e0bffe17 	ldw	r2,-8(fp)
 d01e60c:	1005003a 	cmpeq	r2,r2,zero
 d01e610:	1000051e 	bne	r2,zero,d01e628 <ip_startup+0x1c8>
   {
      ip_exit();
 d01e614:	d01e7bc0 	call	d01e7bc <ip_exit>
      return("unable to initialize arp");
 d01e618:	00834174 	movhi	r2,3333
 d01e61c:	10bb0c04 	addi	r2,r2,-5072
 d01e620:	e0bfff15 	stw	r2,-4(fp)
 d01e624:	00004306 	br	d01e734 <ip_startup+0x2d4>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 d01e628:	d03e8440 	call	d03e844 <ip_init>
 d01e62c:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d01e630:	e0bffe17 	ldw	r2,-8(fp)
 d01e634:	1005003a 	cmpeq	r2,r2,zero
 d01e638:	1000051e 	bne	r2,zero,d01e650 <ip_startup+0x1f0>
   {
      ip_exit();
 d01e63c:	d01e7bc0 	call	d01e7bc <ip_exit>
      return("unable to initialize IP");
 d01e640:	00834174 	movhi	r2,3333
 d01e644:	10bb1304 	addi	r2,r2,-5044
 d01e648:	e0bfff15 	stw	r2,-4(fp)
 d01e64c:	00003906 	br	d01e734 <ip_startup+0x2d4>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 d01e650:	d01e91c0 	call	d01e91c <igmp_init>
 d01e654:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d01e658:	e0bffe17 	ldw	r2,-8(fp)
 d01e65c:	1005003a 	cmpeq	r2,r2,zero
 d01e660:	1000041e 	bne	r2,zero,d01e674 <ip_startup+0x214>
   {
      ip_exit();
 d01e664:	d01e7bc0 	call	d01e7bc <ip_exit>
      return(ipmcfail_str);
 d01e668:	d0a02f17 	ldw	r2,-32580(gp)
 d01e66c:	e0bfff15 	stw	r2,-4(fp)
 d01e670:	00003006 	br	d01e734 <ip_startup+0x2d4>
   }

   for (i = 0; i < (int)ifNumber; i++)
 d01e674:	e03ffd15 	stw	zero,-12(fp)
 d01e678:	00001e06 	br	d01e6f4 <ip_startup+0x294>
   {
      if (nets[i]->n_mcastlist != NULL)
 d01e67c:	e0bffd17 	ldw	r2,-12(fp)
 d01e680:	00c341b4 	movhi	r3,3334
 d01e684:	18c31a04 	addi	r3,r3,3176
 d01e688:	1085883a 	add	r2,r2,r2
 d01e68c:	1085883a 	add	r2,r2,r2
 d01e690:	10c5883a 	add	r2,r2,r3
 d01e694:	10800017 	ldw	r2,0(r2)
 d01e698:	10802b17 	ldw	r2,172(r2)
 d01e69c:	1005003a 	cmpeq	r2,r2,zero
 d01e6a0:	1000111e 	bne	r2,zero,d01e6e8 <ip_startup+0x288>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 d01e6a4:	e0bffd17 	ldw	r2,-12(fp)
 d01e6a8:	00c341b4 	movhi	r3,3334
 d01e6ac:	18c31a04 	addi	r3,r3,3176
 d01e6b0:	1085883a 	add	r2,r2,r2
 d01e6b4:	1085883a 	add	r2,r2,r2
 d01e6b8:	10c5883a 	add	r2,r2,r3
 d01e6bc:	11400017 	ldw	r5,0(r2)
 d01e6c0:	01034174 	movhi	r4,3333
 d01e6c4:	211b2504 	addi	r4,r4,27796
 d01e6c8:	01800104 	movi	r6,4
 d01e6cc:	d0436e40 	call	d0436e4 <in_addmulti>
 d01e6d0:	1004c03a 	cmpne	r2,r2,zero
 d01e6d4:	1000041e 	bne	r2,zero,d01e6e8 <ip_startup+0x288>
      {
         ip_exit();
 d01e6d8:	d01e7bc0 	call	d01e7bc <ip_exit>
         return(ipmcfail_str);
 d01e6dc:	d0a02f17 	ldw	r2,-32580(gp)
 d01e6e0:	e0bfff15 	stw	r2,-4(fp)
 d01e6e4:	00001306 	br	d01e734 <ip_startup+0x2d4>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 d01e6e8:	e0bffd17 	ldw	r2,-12(fp)
 d01e6ec:	10800044 	addi	r2,r2,1
 d01e6f0:	e0bffd15 	stw	r2,-12(fp)
 d01e6f4:	d0a90217 	ldw	r2,-23544(gp)
 d01e6f8:	1007883a 	mov	r3,r2
 d01e6fc:	e0bffd17 	ldw	r2,-12(fp)
 d01e700:	10ffde16 	blt	r2,r3,d01e67c <ip_startup+0x21c>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 d01e704:	d0341240 	call	d034124 <tcpinit>
 d01e708:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d01e70c:	e0bffe17 	ldw	r2,-8(fp)
 d01e710:	1005003a 	cmpeq	r2,r2,zero
 d01e714:	1000051e 	bne	r2,zero,d01e72c <ip_startup+0x2cc>
   {
      ip_exit();
 d01e718:	d01e7bc0 	call	d01e7bc <ip_exit>
      return("unable to initialize TCP");
 d01e71c:	00834174 	movhi	r2,3333
 d01e720:	10bb1904 	addi	r2,r2,-5020
 d01e724:	e0bfff15 	stw	r2,-4(fp)
 d01e728:	00000206 	br	d01e734 <ip_startup+0x2d4>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 d01e72c:	d043a900 	call	d043a90 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 d01e730:	e03fff15 	stw	zero,-4(fp)
 d01e734:	e0bfff17 	ldw	r2,-4(fp)
}
 d01e738:	e037883a 	mov	sp,fp
 d01e73c:	dfc00217 	ldw	ra,8(sp)
 d01e740:	df000117 	ldw	fp,4(sp)
 d01e744:	dc000017 	ldw	r16,0(sp)
 d01e748:	dec00304 	addi	sp,sp,12
 d01e74c:	f800283a 	ret

0d01e750 <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 d01e750:	defffd04 	addi	sp,sp,-12
 d01e754:	dfc00215 	stw	ra,8(sp)
 d01e758:	df000115 	stw	fp,4(sp)
 d01e75c:	df000104 	addi	fp,sp,4
 d01e760:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 d01e764:	d0a90317 	ldw	r2,-23540(gp)
 d01e768:	10800390 	cmplti	r2,r2,14
 d01e76c:	1000031e 	bne	r2,zero,d01e77c <exit_hook+0x2c>
      panic("exit_hook");
 d01e770:	01034174 	movhi	r4,3333
 d01e774:	213b2004 	addi	r4,r4,-4992
 d01e778:	d02093c0 	call	d02093c <panic>

   closers[++nclosers] = func;
 d01e77c:	d0a90317 	ldw	r2,-23540(gp)
 d01e780:	10800044 	addi	r2,r2,1
 d01e784:	d0a90315 	stw	r2,-23540(gp)
 d01e788:	d0a90317 	ldw	r2,-23540(gp)
 d01e78c:	00c34174 	movhi	r3,3333
 d01e790:	18dd0104 	addi	r3,r3,29700
 d01e794:	1085883a 	add	r2,r2,r2
 d01e798:	1085883a 	add	r2,r2,r2
 d01e79c:	10c7883a 	add	r3,r2,r3
 d01e7a0:	e0bfff17 	ldw	r2,-4(fp)
 d01e7a4:	18800015 	stw	r2,0(r3)
}
 d01e7a8:	e037883a 	mov	sp,fp
 d01e7ac:	dfc00117 	ldw	ra,4(sp)
 d01e7b0:	df000017 	ldw	fp,0(sp)
 d01e7b4:	dec00204 	addi	sp,sp,8
 d01e7b8:	f800283a 	ret

0d01e7bc <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 d01e7bc:	defffd04 	addi	sp,sp,-12
 d01e7c0:	dfc00215 	stw	ra,8(sp)
 d01e7c4:	df000115 	stw	fp,4(sp)
 d01e7c8:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 d01e7cc:	d0a90317 	ldw	r2,-23540(gp)
 d01e7d0:	e0bfff15 	stw	r2,-4(fp)
 d01e7d4:	00002506 	br	d01e86c <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 d01e7d8:	e0bfff17 	ldw	r2,-4(fp)
 d01e7dc:	00c34174 	movhi	r3,3333
 d01e7e0:	18dd0104 	addi	r3,r3,29700
 d01e7e4:	1085883a 	add	r2,r2,r2
 d01e7e8:	1085883a 	add	r2,r2,r2
 d01e7ec:	10c5883a 	add	r2,r2,r3
 d01e7f0:	11400017 	ldw	r5,0(r2)
 d01e7f4:	01034174 	movhi	r4,3333
 d01e7f8:	213b2304 	addi	r4,r4,-4980
 d01e7fc:	d0028a00 	call	d0028a0 <printf>
#endif
      if(closers[n])
 d01e800:	e0bfff17 	ldw	r2,-4(fp)
 d01e804:	00c34174 	movhi	r3,3333
 d01e808:	18dd0104 	addi	r3,r3,29700
 d01e80c:	1085883a 	add	r2,r2,r2
 d01e810:	1085883a 	add	r2,r2,r2
 d01e814:	10c5883a 	add	r2,r2,r3
 d01e818:	10800017 	ldw	r2,0(r2)
 d01e81c:	1005003a 	cmpeq	r2,r2,zero
 d01e820:	10000f1e 	bne	r2,zero,d01e860 <ip_exit+0xa4>
      {
         (*closers[n])();
 d01e824:	e0bfff17 	ldw	r2,-4(fp)
 d01e828:	00c34174 	movhi	r3,3333
 d01e82c:	18dd0104 	addi	r3,r3,29700
 d01e830:	1085883a 	add	r2,r2,r2
 d01e834:	1085883a 	add	r2,r2,r2
 d01e838:	10c5883a 	add	r2,r2,r3
 d01e83c:	10800017 	ldw	r2,0(r2)
 d01e840:	103ee83a 	callr	r2
         closers[n] = NULL;
 d01e844:	e0bfff17 	ldw	r2,-4(fp)
 d01e848:	00c34174 	movhi	r3,3333
 d01e84c:	18dd0104 	addi	r3,r3,29700
 d01e850:	1085883a 	add	r2,r2,r2
 d01e854:	1085883a 	add	r2,r2,r2
 d01e858:	10c5883a 	add	r2,r2,r3
 d01e85c:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 d01e860:	e0bfff17 	ldw	r2,-4(fp)
 d01e864:	10bfffc4 	addi	r2,r2,-1
 d01e868:	e0bfff15 	stw	r2,-4(fp)
 d01e86c:	e0bfff17 	ldw	r2,-4(fp)
 d01e870:	1004c03a 	cmpne	r2,r2,zero
 d01e874:	103fd81e 	bne	r2,zero,d01e7d8 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 d01e878:	e037883a 	mov	sp,fp
 d01e87c:	dfc00117 	ldw	ra,4(sp)
 d01e880:	df000017 	ldw	fp,0(sp)
 d01e884:	dec00204 	addi	sp,sp,8
 d01e888:	f800283a 	ret

0d01e88c <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 d01e88c:	defffa04 	addi	sp,sp,-24
 d01e890:	dfc00515 	stw	ra,20(sp)
 d01e894:	df000415 	stw	fp,16(sp)
 d01e898:	df000404 	addi	fp,sp,16
 d01e89c:	e13ffe15 	stw	r4,-8(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 d01e8a0:	008341b4 	movhi	r2,3334
 d01e8a4:	10856304 	addi	r2,r2,5516
 d01e8a8:	10800017 	ldw	r2,0(r2)
 d01e8ac:	e0bffc15 	stw	r2,-16(fp)
 d01e8b0:	e03ffd15 	stw	zero,-12(fp)
 d01e8b4:	00000c06 	br	d01e8e8 <if_netnumber+0x5c>
   {
      if(ifp == nptr)
 d01e8b8:	e0fffc17 	ldw	r3,-16(fp)
 d01e8bc:	e0bffe17 	ldw	r2,-8(fp)
 d01e8c0:	1880031e 	bne	r3,r2,d01e8d0 <if_netnumber+0x44>
        return (int)i;
 d01e8c4:	e0bffd17 	ldw	r2,-12(fp)
 d01e8c8:	e0bfff15 	stw	r2,-4(fp)
 d01e8cc:	00000d06 	br	d01e904 <if_netnumber+0x78>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 d01e8d0:	e0bffc17 	ldw	r2,-16(fp)
 d01e8d4:	10800017 	ldw	r2,0(r2)
 d01e8d8:	e0bffc15 	stw	r2,-16(fp)
 d01e8dc:	e0bffd17 	ldw	r2,-12(fp)
 d01e8e0:	10800044 	addi	r2,r2,1
 d01e8e4:	e0bffd15 	stw	r2,-12(fp)
 d01e8e8:	e0bffc17 	ldw	r2,-16(fp)
 d01e8ec:	1004c03a 	cmpne	r2,r2,zero
 d01e8f0:	103ff11e 	bne	r2,zero,d01e8b8 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 d01e8f4:	01034174 	movhi	r4,3333
 d01e8f8:	213b2a04 	addi	r4,r4,-4952
 d01e8fc:	d02093c0 	call	d02093c <panic>
   return 0;
 d01e900:	e03fff15 	stw	zero,-4(fp)
 d01e904:	e0bfff17 	ldw	r2,-4(fp)
}
 d01e908:	e037883a 	mov	sp,fp
 d01e90c:	dfc00117 	ldw	ra,4(sp)
 d01e910:	df000017 	ldw	fp,0(sp)
 d01e914:	dec00204 	addi	sp,sp,8
 d01e918:	f800283a 	ret

0d01e91c <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 d01e91c:	defffe04 	addi	sp,sp,-8
 d01e920:	df000115 	stw	fp,4(sp)
 d01e924:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 d01e928:	00804034 	movhi	r2,256
 d01e92c:	10803804 	addi	r2,r2,224
 d01e930:	d0a90615 	stw	r2,-23528(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 d01e934:	00808034 	movhi	r2,512
 d01e938:	10803804 	addi	r2,r2,224
 d01e93c:	d0a90715 	stw	r2,-23524(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 d01e940:	008341b4 	movhi	r2,3334
 d01e944:	10856304 	addi	r2,r2,5516
 d01e948:	10800017 	ldw	r2,0(r2)
 d01e94c:	e0bfff15 	stw	r2,-4(fp)
 d01e950:	00001006 	br	d01e994 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 d01e954:	e0bfff17 	ldw	r2,-4(fp)
 d01e958:	10802f03 	ldbu	r2,188(r2)
 d01e95c:	10803fcc 	andi	r2,r2,255
 d01e960:	10800058 	cmpnei	r2,r2,1
 d01e964:	1000041e 	bne	r2,zero,d01e978 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 d01e968:	e0ffff17 	ldw	r3,-4(fp)
 d01e96c:	00800044 	movi	r2,1
 d01e970:	18802d05 	stb	r2,180(r3)
 d01e974:	00000406 	br	d01e988 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 d01e978:	e0bfff17 	ldw	r2,-4(fp)
 d01e97c:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 d01e980:	e0bfff17 	ldw	r2,-4(fp)
 d01e984:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 d01e988:	e0bfff17 	ldw	r2,-4(fp)
 d01e98c:	10800017 	ldw	r2,0(r2)
 d01e990:	e0bfff15 	stw	r2,-4(fp)
 d01e994:	e0bfff17 	ldw	r2,-4(fp)
 d01e998:	1004c03a 	cmpne	r2,r2,zero
 d01e99c:	103fed1e 	bne	r2,zero,d01e954 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 d01e9a0:	00834174 	movhi	r2,3333
 d01e9a4:	109b4504 	addi	r2,r2,27924
 d01e9a8:	10800017 	ldw	r2,0(r2)
 d01e9ac:	10800504 	addi	r2,r2,20
 d01e9b0:	d0a90515 	stw	r2,-23532(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 d01e9b4:	d0290415 	stw	zero,-23536(gp)

   return IGMP_OK;
 d01e9b8:	0005883a 	mov	r2,zero
}
 d01e9bc:	e037883a 	mov	sp,fp
 d01e9c0:	df000017 	ldw	fp,0(sp)
 d01e9c4:	dec00104 	addi	sp,sp,4
 d01e9c8:	f800283a 	ret

0d01e9cc <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 d01e9cc:	defff904 	addi	sp,sp,-28
 d01e9d0:	dfc00615 	stw	ra,24(sp)
 d01e9d4:	df000515 	stw	fp,20(sp)
 d01e9d8:	df000504 	addi	fp,sp,20
 d01e9dc:	e13ffd15 	stw	r4,-12(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 d01e9e0:	008341b4 	movhi	r2,3334
 d01e9e4:	10831e04 	addi	r2,r2,3192
 d01e9e8:	10800017 	ldw	r2,0(r2)
 d01e9ec:	10c00044 	addi	r3,r2,1
 d01e9f0:	008341b4 	movhi	r2,3334
 d01e9f4:	10831e04 	addi	r2,r2,3192
 d01e9f8:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 d01e9fc:	e13ffd17 	ldw	r4,-12(fp)
 d01ea00:	d01f1ec0 	call	d01f1ec <igmp_validate>
 d01ea04:	e0bffb15 	stw	r2,-20(fp)
 d01ea08:	e0bffb17 	ldw	r2,-20(fp)
 d01ea0c:	1004c03a 	cmpne	r2,r2,zero
 d01ea10:	10001e1e 	bne	r2,zero,d01ea8c <igmp_input+0xc0>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 d01ea14:	e0bffd17 	ldw	r2,-12(fp)
 d01ea18:	10800617 	ldw	r2,24(r2)
 d01ea1c:	10802f03 	ldbu	r2,188(r2)
 d01ea20:	e0bffc05 	stb	r2,-16(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 d01ea24:	e0bffc03 	ldbu	r2,-16(fp)
 d01ea28:	e0bfff15 	stw	r2,-4(fp)
 d01ea2c:	e0ffff17 	ldw	r3,-4(fp)
 d01ea30:	18800060 	cmpeqi	r2,r3,1
 d01ea34:	1000041e 	bne	r2,zero,d01ea48 <igmp_input+0x7c>
 d01ea38:	e0ffff17 	ldw	r3,-4(fp)
 d01ea3c:	188000a0 	cmpeqi	r2,r3,2
 d01ea40:	1000051e 	bne	r2,zero,d01ea58 <igmp_input+0x8c>
 d01ea44:	00000806 	br	d01ea68 <igmp_input+0x9c>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 d01ea48:	e13ffd17 	ldw	r4,-12(fp)
 d01ea4c:	d0455480 	call	d045548 <igmpv1_input>
 d01ea50:	e0bffe15 	stw	r2,-8(fp)
 d01ea54:	00001506 	br	d01eaac <igmp_input+0xe0>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 d01ea58:	e13ffd17 	ldw	r4,-12(fp)
 d01ea5c:	d0458300 	call	d045830 <igmpv2_input>
 d01ea60:	e0bffe15 	stw	r2,-8(fp)
 d01ea64:	00001106 	br	d01eaac <igmp_input+0xe0>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 d01ea68:	008341b4 	movhi	r2,3334
 d01ea6c:	10831e04 	addi	r2,r2,3192
 d01ea70:	10800d17 	ldw	r2,52(r2)
 d01ea74:	10c00044 	addi	r3,r2,1
 d01ea78:	008341b4 	movhi	r2,3334
 d01ea7c:	10831e04 	addi	r2,r2,3192
 d01ea80:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 d01ea84:	00bfffc4 	movi	r2,-1
 d01ea88:	e0bffb15 	stw	r2,-20(fp)
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d01ea8c:	01000084 	movi	r4,2
 d01ea90:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p);
 d01ea94:	e13ffd17 	ldw	r4,-12(fp)
 d01ea98:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d01ea9c:	01000084 	movi	r4,2
 d01eaa0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      
   return rc;
 d01eaa4:	e0bffb17 	ldw	r2,-20(fp)
 d01eaa8:	e0bffe15 	stw	r2,-8(fp)
 d01eaac:	e0bffe17 	ldw	r2,-8(fp)
}
 d01eab0:	e037883a 	mov	sp,fp
 d01eab4:	dfc00117 	ldw	ra,4(sp)
 d01eab8:	df000017 	ldw	fp,0(sp)
 d01eabc:	dec00204 	addi	sp,sp,8
 d01eac0:	f800283a 	ret

0d01eac4 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 d01eac4:	defffc04 	addi	sp,sp,-16
 d01eac8:	dfc00315 	stw	ra,12(sp)
 d01eacc:	df000215 	stw	fp,8(sp)
 d01ead0:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 d01ead4:	0009883a 	mov	r4,zero
 d01ead8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 d01eadc:	d0a90417 	ldw	r2,-23536(gp)
 d01eae0:	1004c03a 	cmpne	r2,r2,zero
 d01eae4:	1000031e 	bne	r2,zero,d01eaf4 <igmp_fasttimo+0x30>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 d01eae8:	0009883a 	mov	r4,zero
 d01eaec:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return;
 d01eaf0:	00005506 	br	d01ec48 <igmp_fasttimo+0x184>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d01eaf4:	008341b4 	movhi	r2,3334
 d01eaf8:	10856304 	addi	r2,r2,5516
 d01eafc:	10800017 	ldw	r2,0(r2)
 d01eb00:	e0bffe15 	stw	r2,-8(fp)
 d01eb04:	00004606 	br	d01ec20 <igmp_fasttimo+0x15c>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 d01eb08:	e0bffe17 	ldw	r2,-8(fp)
 d01eb0c:	10802c17 	ldw	r2,176(r2)
 d01eb10:	e0bfff15 	stw	r2,-4(fp)
 d01eb14:	00003c06 	br	d01ec08 <igmp_fasttimo+0x144>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 d01eb18:	e0bfff17 	ldw	r2,-4(fp)
 d01eb1c:	10800017 	ldw	r2,0(r2)
 d01eb20:	1005003a 	cmpeq	r2,r2,zero
 d01eb24:	1000351e 	bne	r2,zero,d01ebfc <igmp_fasttimo+0x138>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 d01eb28:	e0bfff17 	ldw	r2,-4(fp)
 d01eb2c:	10800317 	ldw	r2,12(r2)
 d01eb30:	1005003a 	cmpeq	r2,r2,zero
 d01eb34:	1000311e 	bne	r2,zero,d01ebfc <igmp_fasttimo+0x138>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 d01eb38:	e0bfff17 	ldw	r2,-4(fp)
 d01eb3c:	10800317 	ldw	r2,12(r2)
 d01eb40:	10ffffc4 	addi	r3,r2,-1
 d01eb44:	e0bfff17 	ldw	r2,-4(fp)
 d01eb48:	10c00315 	stw	r3,12(r2)
 d01eb4c:	e0bfff17 	ldw	r2,-4(fp)
 d01eb50:	10800317 	ldw	r2,12(r2)
 d01eb54:	1004c03a 	cmpne	r2,r2,zero
 d01eb58:	1000281e 	bne	r2,zero,d01ebfc <igmp_fasttimo+0x138>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 d01eb5c:	e0bffe17 	ldw	r2,-8(fp)
 d01eb60:	10802d03 	ldbu	r2,180(r2)
 d01eb64:	10803fcc 	andi	r2,r2,255
 d01eb68:	1005003a 	cmpeq	r2,r2,zero
 d01eb6c:	1000041e 	bne	r2,zero,d01eb80 <igmp_fasttimo+0xbc>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 d01eb70:	01000484 	movi	r4,18
 d01eb74:	e17fff17 	ldw	r5,-4(fp)
 d01eb78:	d01ec5c0 	call	d01ec5c <igmp_send>
 d01eb7c:	00000306 	br	d01eb8c <igmp_fasttimo+0xc8>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 d01eb80:	01000584 	movi	r4,22
 d01eb84:	e17fff17 	ldw	r5,-4(fp)
 d01eb88:	d01ec5c0 	call	d01ec5c <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 d01eb8c:	e0bffe17 	ldw	r2,-8(fp)
 d01eb90:	10802f03 	ldbu	r2,188(r2)
 d01eb94:	10803fcc 	andi	r2,r2,255
 d01eb98:	10800098 	cmpnei	r2,r2,2
 d01eb9c:	1000141e 	bne	r2,zero,d01ebf0 <igmp_fasttimo+0x12c>
            {
               inm->last2send_report = IGMP_TRUE;
 d01eba0:	e0ffff17 	ldw	r3,-4(fp)
 d01eba4:	00800044 	movi	r2,1
 d01eba8:	18800405 	stb	r2,16(r3)
               
               if (ifp->igmpv1_rtr_present)
 d01ebac:	e0bffe17 	ldw	r2,-8(fp)
 d01ebb0:	10802d03 	ldbu	r2,180(r2)
 d01ebb4:	10803fcc 	andi	r2,r2,255
 d01ebb8:	1005003a 	cmpeq	r2,r2,zero
 d01ebbc:	10000c1e 	bne	r2,zero,d01ebf0 <igmp_fasttimo+0x12c>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 d01ebc0:	e0bffe17 	ldw	r2,-8(fp)
 d01ebc4:	10c02e17 	ldw	r3,184(r2)
 d01ebc8:	00a71014 	movui	r2,40000
 d01ebcc:	1887883a 	add	r3,r3,r2
 d01ebd0:	00834174 	movhi	r2,3333
 d01ebd4:	109b4504 	addi	r2,r2,27924
 d01ebd8:	10800017 	ldw	r2,0(r2)
 d01ebdc:	1880042e 	bgeu	r3,r2,d01ebf0 <igmp_fasttimo+0x12c>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 d01ebe0:	e0bffe17 	ldw	r2,-8(fp)
 d01ebe4:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 d01ebe8:	e0bffe17 	ldw	r2,-8(fp)
 d01ebec:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 d01ebf0:	d0a90417 	ldw	r2,-23536(gp)
 d01ebf4:	10bfffc4 	addi	r2,r2,-1
 d01ebf8:	d0a90415 	stw	r2,-23536(gp)
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 d01ebfc:	e0bfff17 	ldw	r2,-4(fp)
 d01ec00:	10800517 	ldw	r2,20(r2)
 d01ec04:	e0bfff15 	stw	r2,-4(fp)
 d01ec08:	e0bfff17 	ldw	r2,-4(fp)
 d01ec0c:	1004c03a 	cmpne	r2,r2,zero
 d01ec10:	103fc11e 	bne	r2,zero,d01eb18 <igmp_fasttimo+0x54>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d01ec14:	e0bffe17 	ldw	r2,-8(fp)
 d01ec18:	10800017 	ldw	r2,0(r2)
 d01ec1c:	e0bffe15 	stw	r2,-8(fp)
 d01ec20:	e0bffe17 	ldw	r2,-8(fp)
 d01ec24:	1004c03a 	cmpne	r2,r2,zero
 d01ec28:	103fb71e 	bne	r2,zero,d01eb08 <igmp_fasttimo+0x44>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 d01ec2c:	00834174 	movhi	r2,3333
 d01ec30:	109b4504 	addi	r2,r2,27924
 d01ec34:	10800017 	ldw	r2,0(r2)
 d01ec38:	10800504 	addi	r2,r2,20
 d01ec3c:	d0a90515 	stw	r2,-23532(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 d01ec40:	0009883a 	mov	r4,zero
 d01ec44:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   
   return;
}
 d01ec48:	e037883a 	mov	sp,fp
 d01ec4c:	dfc00117 	ldw	ra,4(sp)
 d01ec50:	df000017 	ldw	fp,0(sp)
 d01ec54:	dec00204 	addi	sp,sp,8
 d01ec58:	f800283a 	ret

0d01ec5c <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 d01ec5c:	deffdd04 	addi	sp,sp,-140
 d01ec60:	dfc02215 	stw	ra,136(sp)
 d01ec64:	df002115 	stw	fp,132(sp)
 d01ec68:	df002104 	addi	fp,sp,132
 d01ec6c:	e17fff15 	stw	r5,-4(fp)
 d01ec70:	e13ffe05 	stb	r4,-8(fp)
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   int i;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 d01ec74:	00800504 	movi	r2,20
 d01ec78:	e0bffd05 	stb	r2,-12(fp)
 d01ec7c:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 d01ec80:	00834174 	movhi	r2,3333
 d01ec84:	109b1e04 	addi	r2,r2,27768
 d01ec88:	10800017 	ldw	r2,0(r2)
 d01ec8c:	10800704 	addi	r2,r2,28
 d01ec90:	e0bfdf05 	stb	r2,-132(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d01ec94:	e0bffe03 	ldbu	r2,-8(fp)
 d01ec98:	108005e0 	cmpeqi	r2,r2,23
 d01ec9c:	1000031e 	bne	r2,zero,d01ecac <igmp_send+0x50>
 d01eca0:	e0bffe03 	ldbu	r2,-8(fp)
 d01eca4:	10800598 	cmpnei	r2,r2,22
 d01eca8:	1000031e 	bne	r2,zero,d01ecb8 <igmp_send+0x5c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 d01ecac:	e0bfdf03 	ldbu	r2,-132(fp)
 d01ecb0:	10800104 	addi	r2,r2,4
 d01ecb4:	e0bfdf05 	stb	r2,-132(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 d01ecb8:	01000084 	movi	r4,2
 d01ecbc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 d01ecc0:	e13fdf03 	ldbu	r4,-132(fp)
 d01ecc4:	d024e0c0 	call	d024e0c <pk_alloc>
 d01ecc8:	e0bfe615 	stw	r2,-104(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d01eccc:	01000084 	movi	r4,2
 d01ecd0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 d01ecd4:	e0bfe617 	ldw	r2,-104(fp)
 d01ecd8:	1004c03a 	cmpne	r2,r2,zero
 d01ecdc:	1000081e 	bne	r2,zero,d01ed00 <igmp_send+0xa4>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 d01ece0:	008341b4 	movhi	r2,3334
 d01ece4:	10831e04 	addi	r2,r2,3192
 d01ece8:	10800c17 	ldw	r2,48(r2)
 d01ecec:	10c00044 	addi	r3,r2,1
 d01ecf0:	008341b4 	movhi	r2,3334
 d01ecf4:	10831e04 	addi	r2,r2,3192
 d01ecf8:	10c00c15 	stw	r3,48(r2)
      return;
 d01ecfc:	00007c06 	br	d01eef0 <igmp_send+0x294>
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 d01ed00:	e0bfe617 	ldw	r2,-104(fp)
 d01ed04:	10800317 	ldw	r2,12(r2)
 d01ed08:	e0bfe315 	stw	r2,-116(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 d01ed0c:	e0bfff17 	ldw	r2,-4(fp)
 d01ed10:	10800117 	ldw	r2,4(r2)
 d01ed14:	10c00a17 	ldw	r3,40(r2)
 d01ed18:	e0bfe317 	ldw	r2,-116(fp)
 d01ed1c:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 d01ed20:	e0bffe03 	ldbu	r2,-8(fp)
 d01ed24:	108005d8 	cmpnei	r2,r2,23
 d01ed28:	1000041e 	bne	r2,zero,d01ed3c <igmp_send+0xe0>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 d01ed2c:	d0e90717 	ldw	r3,-23524(gp)
 d01ed30:	e0bfe317 	ldw	r2,-116(fp)
 d01ed34:	10c00415 	stw	r3,16(r2)
 d01ed38:	00000406 	br	d01ed4c <igmp_send+0xf0>
   }
   else
      pip->ip_dest = inm->inm_addr;
 d01ed3c:	e0bfff17 	ldw	r2,-4(fp)
 d01ed40:	10c00017 	ldw	r3,0(r2)
 d01ed44:	e0bfe317 	ldw	r2,-116(fp)
 d01ed48:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 d01ed4c:	e0bfe317 	ldw	r2,-116(fp)
 d01ed50:	10c00417 	ldw	r3,16(r2)
 d01ed54:	e0bfe617 	ldw	r2,-104(fp)
 d01ed58:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 d01ed5c:	e0bfe617 	ldw	r2,-104(fp)
 d01ed60:	10800317 	ldw	r2,12(r2)
 d01ed64:	10800504 	addi	r2,r2,20
 d01ed68:	e0bfe115 	stw	r2,-124(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d01ed6c:	e0bffe03 	ldbu	r2,-8(fp)
 d01ed70:	108005e0 	cmpeqi	r2,r2,23
 d01ed74:	1000031e 	bne	r2,zero,d01ed84 <igmp_send+0x128>
 d01ed78:	e0bffe03 	ldbu	r2,-8(fp)
 d01ed7c:	10800598 	cmpnei	r2,r2,22
 d01ed80:	1000061e 	bne	r2,zero,d01ed9c <igmp_send+0x140>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 d01ed84:	e0bfe117 	ldw	r2,-124(fp)
 d01ed88:	10800104 	addi	r2,r2,4
 d01ed8c:	e0bfe115 	stw	r2,-124(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 d01ed90:	e0bffd04 	addi	r2,fp,-12
 d01ed94:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d01ed98:	00000306 	br	d01eda8 <igmp_send+0x14c>
      tmpp += IP_RTR_ALERT_OPT_SIZE;
      optp = &(opts [0]); /* one option (IP Router Alert) */
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 d01ed9c:	e0bffd04 	addi	r2,fp,-12
 d01eda0:	10800044 	addi	r2,r2,1
 d01eda4:	e0bfe015 	stw	r2,-128(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 d01eda8:	e0bfe117 	ldw	r2,-124(fp)
 d01edac:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 d01edb0:	e0ffe517 	ldw	r3,-108(fp)
 d01edb4:	e0bffe03 	ldbu	r2,-8(fp)
 d01edb8:	18800005 	stb	r2,0(r3)
   igmp->igmp_code = 0;
 d01edbc:	e0bfe517 	ldw	r2,-108(fp)
 d01edc0:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 d01edc4:	e0bfff17 	ldw	r2,-4(fp)
 d01edc8:	10c00017 	ldw	r3,0(r2)
 d01edcc:	e0bfe517 	ldw	r2,-108(fp)
 d01edd0:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 d01edd4:	e0bfe517 	ldw	r2,-108(fp)
 d01edd8:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 d01eddc:	e13fe517 	ldw	r4,-108(fp)
 d01ede0:	01400104 	movi	r5,4
 d01ede4:	d0205440 	call	d020544 <cksum>
 d01ede8:	0084303a 	nor	r2,zero,r2
 d01edec:	1007883a 	mov	r3,r2
 d01edf0:	e0bfe517 	ldw	r2,-108(fp)
 d01edf4:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 d01edf8:	e0bfe704 	addi	r2,fp,-100
 d01edfc:	e0bfe415 	stw	r2,-112(fp)
   MEMSET(imop, 0, sizeof(simo));
 d01ee00:	e0bfe417 	ldw	r2,-112(fp)
 d01ee04:	1009883a 	mov	r4,r2
 d01ee08:	01801604 	movi	r6,88
 d01ee0c:	000b883a 	mov	r5,zero
 d01ee10:	d0027880 	call	d002788 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 d01ee14:	e0bfff17 	ldw	r2,-4(fp)
 d01ee18:	10c00117 	ldw	r3,4(r2)
 d01ee1c:	e0bfe417 	ldw	r2,-112(fp)
 d01ee20:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 d01ee24:	e0ffe417 	ldw	r3,-112(fp)
 d01ee28:	00800044 	movi	r2,1
 d01ee2c:	18800105 	stb	r2,4(r3)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 d01ee30:	e0bfe417 	ldw	r2,-112(fp)
 d01ee34:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 d01ee38:	e0ffe117 	ldw	r3,-124(fp)
 d01ee3c:	e0bfe617 	ldw	r2,-104(fp)
 d01ee40:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 d01ee44:	e0ffe617 	ldw	r3,-104(fp)
 d01ee48:	00800204 	movi	r2,8
 d01ee4c:	18800415 	stw	r2,16(r3)
   p->imo = imop;
 d01ee50:	e0ffe617 	ldw	r3,-104(fp)
 d01ee54:	e0bfe417 	ldw	r2,-112(fp)
 d01ee58:	18800b15 	stw	r2,44(r3)
   
   i = ip_write2 (IGMP_PROT, p, optp);
 d01ee5c:	01000084 	movi	r4,2
 d01ee60:	e17fe617 	ldw	r5,-104(fp)
 d01ee64:	e1bfe017 	ldw	r6,-128(fp)
 d01ee68:	d03f4c00 	call	d03f4c0 <ip_write2>
 d01ee6c:	e0bfe215 	stw	r2,-120(fp)

   if (type == IGMPv2_LEAVE_GROUP)
 d01ee70:	e0bffe03 	ldbu	r2,-8(fp)
 d01ee74:	108005d8 	cmpnei	r2,r2,23
 d01ee78:	1000081e 	bne	r2,zero,d01ee9c <igmp_send+0x240>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 d01ee7c:	008341b4 	movhi	r2,3334
 d01ee80:	10831e04 	addi	r2,r2,3192
 d01ee84:	10801717 	ldw	r2,92(r2)
 d01ee88:	10c00044 	addi	r3,r2,1
 d01ee8c:	008341b4 	movhi	r2,3334
 d01ee90:	10831e04 	addi	r2,r2,3192
 d01ee94:	10c01715 	stw	r3,92(r2)
 d01ee98:	00001506 	br	d01eef0 <igmp_send+0x294>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 d01ee9c:	e0bffe03 	ldbu	r2,-8(fp)
 d01eea0:	10800598 	cmpnei	r2,r2,22
 d01eea4:	1000081e 	bne	r2,zero,d01eec8 <igmp_send+0x26c>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 d01eea8:	008341b4 	movhi	r2,3334
 d01eeac:	10831e04 	addi	r2,r2,3192
 d01eeb0:	10801817 	ldw	r2,96(r2)
 d01eeb4:	10c00044 	addi	r3,r2,1
 d01eeb8:	008341b4 	movhi	r2,3334
 d01eebc:	10831e04 	addi	r2,r2,3192
 d01eec0:	10c01815 	stw	r3,96(r2)
 d01eec4:	00000a06 	br	d01eef0 <igmp_send+0x294>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 d01eec8:	e0bffe03 	ldbu	r2,-8(fp)
 d01eecc:	10800498 	cmpnei	r2,r2,18
 d01eed0:	1000071e 	bne	r2,zero,d01eef0 <igmp_send+0x294>
      ++igmpstats.igmp_v1_reports_sent;
 d01eed4:	008341b4 	movhi	r2,3334
 d01eed8:	10831e04 	addi	r2,r2,3192
 d01eedc:	10801617 	ldw	r2,88(r2)
 d01eee0:	10c00044 	addi	r3,r2,1
 d01eee4:	008341b4 	movhi	r2,3334
 d01eee8:	10831e04 	addi	r2,r2,3192
 d01eeec:	10c01615 	stw	r3,88(r2)
}
 d01eef0:	e037883a 	mov	sp,fp
 d01eef4:	dfc00117 	ldw	ra,4(sp)
 d01eef8:	df000017 	ldw	fp,0(sp)
 d01eefc:	dec00204 	addi	sp,sp,8
 d01ef00:	f800283a 	ret

0d01ef04 <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 d01ef04:	defffc04 	addi	sp,sp,-16
 d01ef08:	dfc00315 	stw	ra,12(sp)
 d01ef0c:	df000215 	stw	fp,8(sp)
 d01ef10:	df000204 	addi	fp,sp,8
 d01ef14:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 d01ef18:	e0bfff17 	ldw	r2,-4(fp)
 d01ef1c:	10800117 	ldw	r2,4(r2)
 d01ef20:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 d01ef24:	e0bfff17 	ldw	r2,-4(fp)
 d01ef28:	10c00017 	ldw	r3,0(r2)
 d01ef2c:	d0a90617 	ldw	r2,-23528(gp)
 d01ef30:	1880031e 	bne	r3,r2,d01ef40 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 d01ef34:	e0bfff17 	ldw	r2,-4(fp)
 d01ef38:	10000315 	stw	zero,12(r2)
 d01ef3c:	00008706 	br	d01f15c <igmp_joingroup+0x258>
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 d01ef40:	e0bffe17 	ldw	r2,-8(fp)
 d01ef44:	10802d03 	ldbu	r2,180(r2)
 d01ef48:	10803fcc 	andi	r2,r2,255
 d01ef4c:	1005003a 	cmpeq	r2,r2,zero
 d01ef50:	10003c1e 	bne	r2,zero,d01f044 <igmp_joingroup+0x140>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 d01ef54:	01000484 	movi	r4,18
 d01ef58:	e17fff17 	ldw	r5,-4(fp)
 d01ef5c:	d01ec5c0 	call	d01ec5c <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 d01ef60:	008341b4 	movhi	r2,3334
 d01ef64:	10856804 	addi	r2,r2,5536
 d01ef68:	11000217 	ldw	r4,8(r2)
 d01ef6c:	008341b4 	movhi	r2,3334
 d01ef70:	10831a04 	addi	r2,r2,3176
 d01ef74:	10800017 	ldw	r2,0(r2)
 d01ef78:	10800a17 	ldw	r2,40(r2)
 d01ef7c:	1004d63a 	srli	r2,r2,24
 d01ef80:	10c03fcc 	andi	r3,r2,255
 d01ef84:	008341b4 	movhi	r2,3334
 d01ef88:	10831a04 	addi	r2,r2,3176
 d01ef8c:	10800017 	ldw	r2,0(r2)
 d01ef90:	10800a17 	ldw	r2,40(r2)
 d01ef94:	1004d23a 	srli	r2,r2,8
 d01ef98:	10bfc00c 	andi	r2,r2,65280
 d01ef9c:	1886b03a 	or	r3,r3,r2
 d01efa0:	008341b4 	movhi	r2,3334
 d01efa4:	10831a04 	addi	r2,r2,3176
 d01efa8:	10800017 	ldw	r2,0(r2)
 d01efac:	10800a17 	ldw	r2,40(r2)
 d01efb0:	10bfc00c 	andi	r2,r2,65280
 d01efb4:	1004923a 	slli	r2,r2,8
 d01efb8:	1886b03a 	or	r3,r3,r2
 d01efbc:	008341b4 	movhi	r2,3334
 d01efc0:	10831a04 	addi	r2,r2,3176
 d01efc4:	10800017 	ldw	r2,0(r2)
 d01efc8:	10800a17 	ldw	r2,40(r2)
 d01efcc:	10803fcc 	andi	r2,r2,255
 d01efd0:	1004963a 	slli	r2,r2,24
 d01efd4:	1884b03a 	or	r2,r3,r2
 d01efd8:	2089883a 	add	r4,r4,r2
 d01efdc:	e0bfff17 	ldw	r2,-4(fp)
 d01efe0:	10800017 	ldw	r2,0(r2)
 d01efe4:	1004d63a 	srli	r2,r2,24
 d01efe8:	10c03fcc 	andi	r3,r2,255
 d01efec:	e0bfff17 	ldw	r2,-4(fp)
 d01eff0:	10800017 	ldw	r2,0(r2)
 d01eff4:	1004d23a 	srli	r2,r2,8
 d01eff8:	10bfc00c 	andi	r2,r2,65280
 d01effc:	1886b03a 	or	r3,r3,r2
 d01f000:	e0bfff17 	ldw	r2,-4(fp)
 d01f004:	10800017 	ldw	r2,0(r2)
 d01f008:	10bfc00c 	andi	r2,r2,65280
 d01f00c:	1004923a 	slli	r2,r2,8
 d01f010:	1886b03a 	or	r3,r3,r2
 d01f014:	e0bfff17 	ldw	r2,-4(fp)
 d01f018:	10800017 	ldw	r2,0(r2)
 d01f01c:	10803fcc 	andi	r2,r2,255
 d01f020:	1004963a 	slli	r2,r2,24
 d01f024:	1884b03a 	or	r2,r3,r2
 d01f028:	2089883a 	add	r4,r4,r2
 d01f02c:	01400c84 	movi	r5,50
 d01f030:	d00c9140 	call	d00c914 <__umodsi3>
 d01f034:	10c00044 	addi	r3,r2,1
 d01f038:	e0bfff17 	ldw	r2,-4(fp)
 d01f03c:	10c00315 	stw	r3,12(r2)
 d01f040:	00003b06 	br	d01f130 <igmp_joingroup+0x22c>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 d01f044:	01000584 	movi	r4,22
 d01f048:	e17fff17 	ldw	r5,-4(fp)
 d01f04c:	d01ec5c0 	call	d01ec5c <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 d01f050:	008341b4 	movhi	r2,3334
 d01f054:	10856804 	addi	r2,r2,5536
 d01f058:	11000217 	ldw	r4,8(r2)
 d01f05c:	008341b4 	movhi	r2,3334
 d01f060:	10831a04 	addi	r2,r2,3176
 d01f064:	10800017 	ldw	r2,0(r2)
 d01f068:	10800a17 	ldw	r2,40(r2)
 d01f06c:	1004d63a 	srli	r2,r2,24
 d01f070:	10c03fcc 	andi	r3,r2,255
 d01f074:	008341b4 	movhi	r2,3334
 d01f078:	10831a04 	addi	r2,r2,3176
 d01f07c:	10800017 	ldw	r2,0(r2)
 d01f080:	10800a17 	ldw	r2,40(r2)
 d01f084:	1004d23a 	srli	r2,r2,8
 d01f088:	10bfc00c 	andi	r2,r2,65280
 d01f08c:	1886b03a 	or	r3,r3,r2
 d01f090:	008341b4 	movhi	r2,3334
 d01f094:	10831a04 	addi	r2,r2,3176
 d01f098:	10800017 	ldw	r2,0(r2)
 d01f09c:	10800a17 	ldw	r2,40(r2)
 d01f0a0:	10bfc00c 	andi	r2,r2,65280
 d01f0a4:	1004923a 	slli	r2,r2,8
 d01f0a8:	1886b03a 	or	r3,r3,r2
 d01f0ac:	008341b4 	movhi	r2,3334
 d01f0b0:	10831a04 	addi	r2,r2,3176
 d01f0b4:	10800017 	ldw	r2,0(r2)
 d01f0b8:	10800a17 	ldw	r2,40(r2)
 d01f0bc:	10803fcc 	andi	r2,r2,255
 d01f0c0:	1004963a 	slli	r2,r2,24
 d01f0c4:	1884b03a 	or	r2,r3,r2
 d01f0c8:	2089883a 	add	r4,r4,r2
 d01f0cc:	e0bfff17 	ldw	r2,-4(fp)
 d01f0d0:	10800017 	ldw	r2,0(r2)
 d01f0d4:	1004d63a 	srli	r2,r2,24
 d01f0d8:	10c03fcc 	andi	r3,r2,255
 d01f0dc:	e0bfff17 	ldw	r2,-4(fp)
 d01f0e0:	10800017 	ldw	r2,0(r2)
 d01f0e4:	1004d23a 	srli	r2,r2,8
 d01f0e8:	10bfc00c 	andi	r2,r2,65280
 d01f0ec:	1886b03a 	or	r3,r3,r2
 d01f0f0:	e0bfff17 	ldw	r2,-4(fp)
 d01f0f4:	10800017 	ldw	r2,0(r2)
 d01f0f8:	10bfc00c 	andi	r2,r2,65280
 d01f0fc:	1004923a 	slli	r2,r2,8
 d01f100:	1886b03a 	or	r3,r3,r2
 d01f104:	e0bfff17 	ldw	r2,-4(fp)
 d01f108:	10800017 	ldw	r2,0(r2)
 d01f10c:	10803fcc 	andi	r2,r2,255
 d01f110:	1004963a 	slli	r2,r2,24
 d01f114:	1884b03a 	or	r2,r3,r2
 d01f118:	2089883a 	add	r4,r4,r2
 d01f11c:	01400c84 	movi	r5,50
 d01f120:	d00c9140 	call	d00c914 <__umodsi3>
 d01f124:	10c00044 	addi	r3,r2,1
 d01f128:	e0bfff17 	ldw	r2,-4(fp)
 d01f12c:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 d01f130:	e0bffe17 	ldw	r2,-8(fp)
 d01f134:	10802f03 	ldbu	r2,188(r2)
 d01f138:	10803fcc 	andi	r2,r2,255
 d01f13c:	10800098 	cmpnei	r2,r2,2
 d01f140:	1000031e 	bne	r2,zero,d01f150 <igmp_joingroup+0x24c>
      {
         inm->last2send_report = IGMP_TRUE;
 d01f144:	e0ffff17 	ldw	r3,-4(fp)
 d01f148:	00800044 	movi	r2,1
 d01f14c:	18800405 	stb	r2,16(r3)
      }

      ++igmp_timers_are_running;
 d01f150:	d0a90417 	ldw	r2,-23536(gp)
 d01f154:	10800044 	addi	r2,r2,1
 d01f158:	d0a90415 	stw	r2,-23536(gp)
   }
   
   return;
}     
 d01f15c:	e037883a 	mov	sp,fp
 d01f160:	dfc00117 	ldw	ra,4(sp)
 d01f164:	df000017 	ldw	fp,0(sp)
 d01f168:	dec00204 	addi	sp,sp,8
 d01f16c:	f800283a 	ret

0d01f170 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 d01f170:	defffc04 	addi	sp,sp,-16
 d01f174:	dfc00315 	stw	ra,12(sp)
 d01f178:	df000215 	stw	fp,8(sp)
 d01f17c:	df000204 	addi	fp,sp,8
 d01f180:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 d01f184:	e0bfff17 	ldw	r2,-4(fp)
 d01f188:	10800117 	ldw	r2,4(r2)
 d01f18c:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 d01f190:	e0bffe17 	ldw	r2,-8(fp)
 d01f194:	10802f03 	ldbu	r2,188(r2)
 d01f198:	10803fcc 	andi	r2,r2,255
 d01f19c:	10800098 	cmpnei	r2,r2,2
 d01f1a0:	10000d1e 	bne	r2,zero,d01f1d8 <igmp_leavegroup+0x68>
 d01f1a4:	e0bffe17 	ldw	r2,-8(fp)
 d01f1a8:	10802d03 	ldbu	r2,180(r2)
 d01f1ac:	10803fcc 	andi	r2,r2,255
 d01f1b0:	1004c03a 	cmpne	r2,r2,zero
 d01f1b4:	1000081e 	bne	r2,zero,d01f1d8 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 d01f1b8:	e0bfff17 	ldw	r2,-4(fp)
 d01f1bc:	10800403 	ldbu	r2,16(r2)
 d01f1c0:	10803fcc 	andi	r2,r2,255
 d01f1c4:	10800058 	cmpnei	r2,r2,1
 d01f1c8:	1000031e 	bne	r2,zero,d01f1d8 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 d01f1cc:	010005c4 	movi	r4,23
 d01f1d0:	e17fff17 	ldw	r5,-4(fp)
 d01f1d4:	d01ec5c0 	call	d01ec5c <igmp_send>
   }
   
   return;
}
 d01f1d8:	e037883a 	mov	sp,fp
 d01f1dc:	dfc00117 	ldw	ra,4(sp)
 d01f1e0:	df000017 	ldw	fp,0(sp)
 d01f1e4:	dec00204 	addi	sp,sp,8
 d01f1e8:	f800283a 	ret

0d01f1ec <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 d01f1ec:	defff504 	addi	sp,sp,-44
 d01f1f0:	dfc00a15 	stw	ra,40(sp)
 d01f1f4:	df000915 	stw	fp,36(sp)
 d01f1f8:	df000904 	addi	fp,sp,36
 d01f1fc:	e13ffe15 	stw	r4,-8(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 d01f200:	e0bffe17 	ldw	r2,-8(fp)
 d01f204:	10800317 	ldw	r2,12(r2)
 d01f208:	e0bffd15 	stw	r2,-12(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 d01f20c:	e0bffe17 	ldw	r2,-8(fp)
 d01f210:	10c00417 	ldw	r3,16(r2)
 d01f214:	e0bffd17 	ldw	r2,-12(fp)
 d01f218:	10800003 	ldbu	r2,0(r2)
 d01f21c:	10803fcc 	andi	r2,r2,255
 d01f220:	108003cc 	andi	r2,r2,15
 d01f224:	1085883a 	add	r2,r2,r2
 d01f228:	1085883a 	add	r2,r2,r2
 d01f22c:	1885c83a 	sub	r2,r3,r2
 d01f230:	e0bffc15 	stw	r2,-16(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 d01f234:	e0bffc17 	ldw	r2,-16(fp)
 d01f238:	10800220 	cmpeqi	r2,r2,8
 d01f23c:	10000a1e 	bne	r2,zero,d01f268 <igmp_validate+0x7c>
   {
      ++igmpstats.igmp_badlen_rcvd;
 d01f240:	008341b4 	movhi	r2,3334
 d01f244:	10831e04 	addi	r2,r2,3192
 d01f248:	10800a17 	ldw	r2,40(r2)
 d01f24c:	10c00044 	addi	r3,r2,1
 d01f250:	008341b4 	movhi	r2,3334
 d01f254:	10831e04 	addi	r2,r2,3192
 d01f258:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 d01f25c:	00bff804 	movi	r2,-32
 d01f260:	e0bfff15 	stw	r2,-4(fp)
 d01f264:	0000b206 	br	d01f530 <igmp_validate+0x344>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 d01f268:	e0bffd17 	ldw	r2,-12(fp)
 d01f26c:	10800003 	ldbu	r2,0(r2)
 d01f270:	10803fcc 	andi	r2,r2,255
 d01f274:	108003cc 	andi	r2,r2,15
 d01f278:	1085883a 	add	r2,r2,r2
 d01f27c:	1085883a 	add	r2,r2,r2
 d01f280:	1007883a 	mov	r3,r2
 d01f284:	e0bffd17 	ldw	r2,-12(fp)
 d01f288:	1885883a 	add	r2,r3,r2
 d01f28c:	e0bffb15 	stw	r2,-20(fp)
   osum = igmp->igmp_cksum;
 d01f290:	e0bffb17 	ldw	r2,-20(fp)
 d01f294:	1080008b 	ldhu	r2,2(r2)
 d01f298:	e0bffa0d 	sth	r2,-24(fp)
   igmp->igmp_cksum = 0;
 d01f29c:	e0bffb17 	ldw	r2,-20(fp)
 d01f2a0:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 d01f2a4:	e0bffc17 	ldw	r2,-16(fp)
 d01f2a8:	1005d07a 	srai	r2,r2,1
 d01f2ac:	100b883a 	mov	r5,r2
 d01f2b0:	e13ffb17 	ldw	r4,-20(fp)
 d01f2b4:	d0205440 	call	d020544 <cksum>
 d01f2b8:	0084303a 	nor	r2,zero,r2
 d01f2bc:	e0bff98d 	sth	r2,-26(fp)
   if (xsum != osum)
 d01f2c0:	e0fff98b 	ldhu	r3,-26(fp)
 d01f2c4:	e0bffa0b 	ldhu	r2,-24(fp)
 d01f2c8:	18800d26 	beq	r3,r2,d01f300 <igmp_validate+0x114>
   {
      igmp->igmp_cksum = osum;
 d01f2cc:	e0fffb17 	ldw	r3,-20(fp)
 d01f2d0:	e0bffa0b 	ldhu	r2,-24(fp)
 d01f2d4:	1880008d 	sth	r2,2(r3)
      ++igmpstats.igmp_badsum_rcvd;
 d01f2d8:	008341b4 	movhi	r2,3334
 d01f2dc:	10831e04 	addi	r2,r2,3192
 d01f2e0:	10800b17 	ldw	r2,44(r2)
 d01f2e4:	10c00044 	addi	r3,r2,1
 d01f2e8:	008341b4 	movhi	r2,3334
 d01f2ec:	10831e04 	addi	r2,r2,3192
 d01f2f0:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 d01f2f4:	00bff804 	movi	r2,-32
 d01f2f8:	e0bfff15 	stw	r2,-4(fp)
 d01f2fc:	00008c06 	br	d01f530 <igmp_validate+0x344>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 d01f300:	e0bffb17 	ldw	r2,-20(fp)
 d01f304:	10800003 	ldbu	r2,0(r2)
 d01f308:	e0bff905 	stb	r2,-28(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 d01f30c:	e0bffb17 	ldw	r2,-20(fp)
 d01f310:	10800117 	ldw	r2,4(r2)
 d01f314:	1004d63a 	srli	r2,r2,24
 d01f318:	10c03fcc 	andi	r3,r2,255
 d01f31c:	e0bffb17 	ldw	r2,-20(fp)
 d01f320:	10800117 	ldw	r2,4(r2)
 d01f324:	1004d23a 	srli	r2,r2,8
 d01f328:	10bfc00c 	andi	r2,r2,65280
 d01f32c:	1886b03a 	or	r3,r3,r2
 d01f330:	e0bffb17 	ldw	r2,-20(fp)
 d01f334:	10800117 	ldw	r2,4(r2)
 d01f338:	10bfc00c 	andi	r2,r2,65280
 d01f33c:	1004923a 	slli	r2,r2,8
 d01f340:	1886b03a 	or	r3,r3,r2
 d01f344:	e0bffb17 	ldw	r2,-20(fp)
 d01f348:	10800117 	ldw	r2,4(r2)
 d01f34c:	10803fcc 	andi	r2,r2,255
 d01f350:	1004963a 	slli	r2,r2,24
 d01f354:	1884b03a 	or	r2,r3,r2
 d01f358:	e0bff815 	stw	r2,-32(fp)
   resp_time = igmp->igmp_code;
 d01f35c:	e0bffb17 	ldw	r2,-20(fp)
 d01f360:	10800043 	ldbu	r2,1(r2)
 d01f364:	e0bff705 	stb	r2,-36(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 d01f368:	e0bff903 	ldbu	r2,-28(fp)
 d01f36c:	10800458 	cmpnei	r2,r2,17
 d01f370:	1000381e 	bne	r2,zero,d01f454 <igmp_validate+0x268>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 d01f374:	e0bff703 	ldbu	r2,-36(fp)
 d01f378:	1005003a 	cmpeq	r2,r2,zero
 d01f37c:	1000061e 	bne	r2,zero,d01f398 <igmp_validate+0x1ac>
 d01f380:	e0bff703 	ldbu	r2,-36(fp)
 d01f384:	1005003a 	cmpeq	r2,r2,zero
 d01f388:	1000111e 	bne	r2,zero,d01f3d0 <igmp_validate+0x1e4>
 d01f38c:	e0bff817 	ldw	r2,-32(fp)
 d01f390:	1004c03a 	cmpne	r2,r2,zero
 d01f394:	10000e1e 	bne	r2,zero,d01f3d0 <igmp_validate+0x1e4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 d01f398:	e0bffd17 	ldw	r2,-12(fp)
 d01f39c:	10c00417 	ldw	r3,16(r2)
 d01f3a0:	d0a90617 	ldw	r2,-23528(gp)
 d01f3a4:	18800a26 	beq	r3,r2,d01f3d0 <igmp_validate+0x1e4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 d01f3a8:	008341b4 	movhi	r2,3334
 d01f3ac:	10831e04 	addi	r2,r2,3192
 d01f3b0:	10800e17 	ldw	r2,56(r2)
 d01f3b4:	10c00044 	addi	r3,r2,1
 d01f3b8:	008341b4 	movhi	r2,3334
 d01f3bc:	10831e04 	addi	r2,r2,3192
 d01f3c0:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 d01f3c4:	00bff804 	movi	r2,-32
 d01f3c8:	e0bfff15 	stw	r2,-4(fp)
 d01f3cc:	00005806 	br	d01f530 <igmp_validate+0x344>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 d01f3d0:	e0bff703 	ldbu	r2,-36(fp)
 d01f3d4:	1005003a 	cmpeq	r2,r2,zero
 d01f3d8:	10001e1e 	bne	r2,zero,d01f454 <igmp_validate+0x268>
 d01f3dc:	e0bff817 	ldw	r2,-32(fp)
 d01f3e0:	1005003a 	cmpeq	r2,r2,zero
 d01f3e4:	10001b1e 	bne	r2,zero,d01f454 <igmp_validate+0x268>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 d01f3e8:	e0bffe17 	ldw	r2,-8(fp)
 d01f3ec:	10800617 	ldw	r2,24(r2)
 d01f3f0:	10802f03 	ldbu	r2,188(r2)
 d01f3f4:	10803fcc 	andi	r2,r2,255
 d01f3f8:	10800058 	cmpnei	r2,r2,1
 d01f3fc:	1000031e 	bne	r2,zero,d01f40c <igmp_validate+0x220>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 d01f400:	00bff804 	movi	r2,-32
 d01f404:	e0bfff15 	stw	r2,-4(fp)
 d01f408:	00004906 	br	d01f530 <igmp_validate+0x344>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 d01f40c:	e0bff817 	ldw	r2,-32(fp)
 d01f410:	10fc002c 	andhi	r3,r2,61440
 d01f414:	00b80034 	movhi	r2,57344
 d01f418:	1880041e 	bne	r3,r2,d01f42c <igmp_validate+0x240>
 d01f41c:	e0bffb17 	ldw	r2,-20(fp)
 d01f420:	10c00117 	ldw	r3,4(r2)
 d01f424:	d0a90617 	ldw	r2,-23528(gp)
 d01f428:	18800a1e 	bne	r3,r2,d01f454 <igmp_validate+0x268>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 d01f42c:	008341b4 	movhi	r2,3334
 d01f430:	10831e04 	addi	r2,r2,3192
 d01f434:	10801117 	ldw	r2,68(r2)
 d01f438:	10c00044 	addi	r3,r2,1
 d01f43c:	008341b4 	movhi	r2,3334
 d01f440:	10831e04 	addi	r2,r2,3192
 d01f444:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 d01f448:	00bff804 	movi	r2,-32
 d01f44c:	e0bfff15 	stw	r2,-4(fp)
 d01f450:	00003706 	br	d01f530 <igmp_validate+0x344>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 d01f454:	e0bff903 	ldbu	r2,-28(fp)
 d01f458:	108004a0 	cmpeqi	r2,r2,18
 d01f45c:	1000031e 	bne	r2,zero,d01f46c <igmp_validate+0x280>
 d01f460:	e0bff903 	ldbu	r2,-28(fp)
 d01f464:	10800598 	cmpnei	r2,r2,22
 d01f468:	1000131e 	bne	r2,zero,d01f4b8 <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 d01f46c:	e0bffb17 	ldw	r2,-20(fp)
 d01f470:	10c00117 	ldw	r3,4(r2)
 d01f474:	e0bffd17 	ldw	r2,-12(fp)
 d01f478:	10800417 	ldw	r2,16(r2)
 d01f47c:	1880041e 	bne	r3,r2,d01f490 <igmp_validate+0x2a4>
 d01f480:	e0bff817 	ldw	r2,-32(fp)
 d01f484:	10fc002c 	andhi	r3,r2,61440
 d01f488:	00b80034 	movhi	r2,57344
 d01f48c:	18800a26 	beq	r3,r2,d01f4b8 <igmp_validate+0x2cc>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 d01f490:	008341b4 	movhi	r2,3334
 d01f494:	10831e04 	addi	r2,r2,3192
 d01f498:	10800f17 	ldw	r2,60(r2)
 d01f49c:	10c00044 	addi	r3,r2,1
 d01f4a0:	008341b4 	movhi	r2,3334
 d01f4a4:	10831e04 	addi	r2,r2,3192
 d01f4a8:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 d01f4ac:	00bff804 	movi	r2,-32
 d01f4b0:	e0bfff15 	stw	r2,-4(fp)
 d01f4b4:	00001e06 	br	d01f530 <igmp_validate+0x344>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d01f4b8:	e0bff903 	ldbu	r2,-28(fp)
 d01f4bc:	108005e0 	cmpeqi	r2,r2,23
 d01f4c0:	10000b1e 	bne	r2,zero,d01f4f0 <igmp_validate+0x304>
 d01f4c4:	e0bff903 	ldbu	r2,-28(fp)
 d01f4c8:	108005a0 	cmpeqi	r2,r2,22
 d01f4cc:	1000081e 	bne	r2,zero,d01f4f0 <igmp_validate+0x304>
 d01f4d0:	e0bff903 	ldbu	r2,-28(fp)
 d01f4d4:	10800458 	cmpnei	r2,r2,17
 d01f4d8:	1000141e 	bne	r2,zero,d01f52c <igmp_validate+0x340>
 d01f4dc:	e0bffb17 	ldw	r2,-20(fp)
 d01f4e0:	10800043 	ldbu	r2,1(r2)
 d01f4e4:	10803fcc 	andi	r2,r2,255
 d01f4e8:	1005003a 	cmpeq	r2,r2,zero
 d01f4ec:	10000f1e 	bne	r2,zero,d01f52c <igmp_validate+0x340>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 d01f4f0:	e13ffd17 	ldw	r4,-12(fp)
 d01f4f4:	d045e800 	call	d045e80 <igmpv2_chk4_rtr_alert_opt>
 d01f4f8:	10803fcc 	andi	r2,r2,255
 d01f4fc:	1004c03a 	cmpne	r2,r2,zero
 d01f500:	10000a1e 	bne	r2,zero,d01f52c <igmp_validate+0x340>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 d01f504:	008341b4 	movhi	r2,3334
 d01f508:	10831e04 	addi	r2,r2,3192
 d01f50c:	10801417 	ldw	r2,80(r2)
 d01f510:	10c00044 	addi	r3,r2,1
 d01f514:	008341b4 	movhi	r2,3334
 d01f518:	10831e04 	addi	r2,r2,3192
 d01f51c:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 d01f520:	00bff804 	movi	r2,-32
 d01f524:	e0bfff15 	stw	r2,-4(fp)
 d01f528:	00000106 	br	d01f530 <igmp_validate+0x344>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 d01f52c:	e03fff15 	stw	zero,-4(fp)
 d01f530:	e0bfff17 	ldw	r2,-4(fp)
}
 d01f534:	e037883a 	mov	sp,fp
 d01f538:	dfc00117 	ldw	ra,4(sp)
 d01f53c:	df000017 	ldw	fp,0(sp)
 d01f540:	dec00204 	addi	sp,sp,8
 d01f544:	f800283a 	ret

0d01f548 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 d01f548:	defff504 	addi	sp,sp,-44
 d01f54c:	dfc00a15 	stw	ra,40(sp)
 d01f550:	df000915 	stw	fp,36(sp)
 d01f554:	df000904 	addi	fp,sp,36
 d01f558:	e13ffa15 	stw	r4,-24(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d01f55c:	008341b4 	movhi	r2,3334
 d01f560:	10856304 	addi	r2,r2,5516
 d01f564:	10800017 	ldw	r2,0(r2)
 d01f568:	e0bff915 	stw	r2,-28(fp)
 d01f56c:	00004506 	br	d01f684 <igmp_print_stats+0x13c>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 d01f570:	e0bff917 	ldw	r2,-28(fp)
 d01f574:	10800104 	addi	r2,r2,4
 d01f578:	e0bfff15 	stw	r2,-4(fp)
 d01f57c:	e0bff917 	ldw	r2,-28(fp)
 d01f580:	10802f03 	ldbu	r2,188(r2)
 d01f584:	10803fcc 	andi	r2,r2,255
 d01f588:	e0bffe15 	stw	r2,-8(fp)
 d01f58c:	e0bff917 	ldw	r2,-28(fp)
 d01f590:	10802f03 	ldbu	r2,188(r2)
 d01f594:	10803fcc 	andi	r2,r2,255
 d01f598:	10800058 	cmpnei	r2,r2,1
 d01f59c:	1000041e 	bne	r2,zero,d01f5b0 <igmp_print_stats+0x68>
 d01f5a0:	00834174 	movhi	r2,3333
 d01f5a4:	10bb2d04 	addi	r2,r2,-4940
 d01f5a8:	e0bffd15 	stw	r2,-12(fp)
 d01f5ac:	00000306 	br	d01f5bc <igmp_print_stats+0x74>
 d01f5b0:	00834174 	movhi	r2,3333
 d01f5b4:	10bb2e04 	addi	r2,r2,-4936
 d01f5b8:	e0bffd15 	stw	r2,-12(fp)
 d01f5bc:	e0bffd17 	ldw	r2,-12(fp)
 d01f5c0:	d8800015 	stw	r2,0(sp)
 d01f5c4:	e13ffa17 	ldw	r4,-24(fp)
 d01f5c8:	01434174 	movhi	r5,3333
 d01f5cc:	297b2f04 	addi	r5,r5,-4932
 d01f5d0:	e1bfff17 	ldw	r6,-4(fp)
 d01f5d4:	e1fffe17 	ldw	r7,-8(fp)
 d01f5d8:	d020b640 	call	d020b64 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 d01f5dc:	e0bff917 	ldw	r2,-28(fp)
 d01f5e0:	10802f03 	ldbu	r2,188(r2)
 d01f5e4:	10803fcc 	andi	r2,r2,255
 d01f5e8:	10800098 	cmpnei	r2,r2,2
 d01f5ec:	10001e1e 	bne	r2,zero,d01f668 <igmp_print_stats+0x120>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 d01f5f0:	e0bff917 	ldw	r2,-28(fp)
 d01f5f4:	10802d03 	ldbu	r2,180(r2)
 d01f5f8:	10803fcc 	andi	r2,r2,255
 d01f5fc:	e0bffc15 	stw	r2,-16(fp)
 d01f600:	e0bff917 	ldw	r2,-28(fp)
 d01f604:	10802d03 	ldbu	r2,180(r2)
 d01f608:	10803fcc 	andi	r2,r2,255
 d01f60c:	10800058 	cmpnei	r2,r2,1
 d01f610:	1000041e 	bne	r2,zero,d01f624 <igmp_print_stats+0xdc>
 d01f614:	00834174 	movhi	r2,3333
 d01f618:	10bb3404 	addi	r2,r2,-4912
 d01f61c:	e0bffb15 	stw	r2,-20(fp)
 d01f620:	00000306 	br	d01f630 <igmp_print_stats+0xe8>
 d01f624:	00834174 	movhi	r2,3333
 d01f628:	10bb3604 	addi	r2,r2,-4904
 d01f62c:	e0bffb15 	stw	r2,-20(fp)
 d01f630:	e0bff917 	ldw	r2,-28(fp)
 d01f634:	10c02e17 	ldw	r3,184(r2)
 d01f638:	00834174 	movhi	r2,3333
 d01f63c:	109b4504 	addi	r2,r2,27924
 d01f640:	10800017 	ldw	r2,0(r2)
 d01f644:	d8c00015 	stw	r3,0(sp)
 d01f648:	d8800115 	stw	r2,4(sp)
 d01f64c:	e13ffa17 	ldw	r4,-24(fp)
 d01f650:	01434174 	movhi	r5,3333
 d01f654:	297b3804 	addi	r5,r5,-4896
 d01f658:	e1bffc17 	ldw	r6,-16(fp)
 d01f65c:	e1fffb17 	ldw	r7,-20(fp)
 d01f660:	d020b640 	call	d020b64 <ns_printf>
 d01f664:	00000406 	br	d01f678 <igmp_print_stats+0x130>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 d01f668:	e13ffa17 	ldw	r4,-24(fp)
 d01f66c:	01434174 	movhi	r5,3333
 d01f670:	297b4304 	addi	r5,r5,-4852
 d01f674:	d020b640 	call	d020b64 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d01f678:	e0bff917 	ldw	r2,-28(fp)
 d01f67c:	10800017 	ldw	r2,0(r2)
 d01f680:	e0bff915 	stw	r2,-28(fp)
 d01f684:	e0bff917 	ldw	r2,-28(fp)
 d01f688:	1004c03a 	cmpne	r2,r2,zero
 d01f68c:	103fb81e 	bne	r2,zero,d01f570 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 d01f690:	008341b4 	movhi	r2,3334
 d01f694:	10831e04 	addi	r2,r2,3192
 d01f698:	11800017 	ldw	r6,0(r2)
 d01f69c:	d1e90417 	ldw	r7,-23536(gp)
 d01f6a0:	e13ffa17 	ldw	r4,-24(fp)
 d01f6a4:	01434174 	movhi	r5,3333
 d01f6a8:	297b4404 	addi	r5,r5,-4848
 d01f6ac:	d020b640 	call	d020b64 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 d01f6b0:	008341b4 	movhi	r2,3334
 d01f6b4:	10831e04 	addi	r2,r2,3192
 d01f6b8:	11800117 	ldw	r6,4(r2)
 d01f6bc:	e13ffa17 	ldw	r4,-24(fp)
 d01f6c0:	01434174 	movhi	r5,3333
 d01f6c4:	297b5104 	addi	r5,r5,-4796
 d01f6c8:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 d01f6cc:	008341b4 	movhi	r2,3334
 d01f6d0:	10831e04 	addi	r2,r2,3192
 d01f6d4:	11800217 	ldw	r6,8(r2)
 d01f6d8:	e13ffa17 	ldw	r4,-24(fp)
 d01f6dc:	01434174 	movhi	r5,3333
 d01f6e0:	297b6204 	addi	r5,r5,-4728
 d01f6e4:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 d01f6e8:	008341b4 	movhi	r2,3334
 d01f6ec:	10831e04 	addi	r2,r2,3192
 d01f6f0:	11800317 	ldw	r6,12(r2)
 d01f6f4:	e13ffa17 	ldw	r4,-24(fp)
 d01f6f8:	01434174 	movhi	r5,3333
 d01f6fc:	297b6e04 	addi	r5,r5,-4680
 d01f700:	d020b640 	call	d020b64 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 d01f704:	008341b4 	movhi	r2,3334
 d01f708:	10831e04 	addi	r2,r2,3192
 d01f70c:	11800417 	ldw	r6,16(r2)
 d01f710:	e13ffa17 	ldw	r4,-24(fp)
 d01f714:	01434174 	movhi	r5,3333
 d01f718:	297b8104 	addi	r5,r5,-4604
 d01f71c:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 d01f720:	008341b4 	movhi	r2,3334
 d01f724:	10831e04 	addi	r2,r2,3192
 d01f728:	11800517 	ldw	r6,20(r2)
 d01f72c:	008341b4 	movhi	r2,3334
 d01f730:	10831e04 	addi	r2,r2,3192
 d01f734:	11c00617 	ldw	r7,24(r2)
 d01f738:	e13ffa17 	ldw	r4,-24(fp)
 d01f73c:	01434174 	movhi	r5,3333
 d01f740:	297b9204 	addi	r5,r5,-4536
 d01f744:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 d01f748:	008341b4 	movhi	r2,3334
 d01f74c:	10831e04 	addi	r2,r2,3192
 d01f750:	11800717 	ldw	r6,28(r2)
 d01f754:	e13ffa17 	ldw	r4,-24(fp)
 d01f758:	01434174 	movhi	r5,3333
 d01f75c:	297b6e04 	addi	r5,r5,-4680
 d01f760:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 d01f764:	008341b4 	movhi	r2,3334
 d01f768:	10831e04 	addi	r2,r2,3192
 d01f76c:	11800817 	ldw	r6,32(r2)
 d01f770:	e13ffa17 	ldw	r4,-24(fp)
 d01f774:	01434174 	movhi	r5,3333
 d01f778:	297ba504 	addi	r5,r5,-4460
 d01f77c:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 d01f780:	008341b4 	movhi	r2,3334
 d01f784:	10831e04 	addi	r2,r2,3192
 d01f788:	11800917 	ldw	r6,36(r2)
 d01f78c:	e13ffa17 	ldw	r4,-24(fp)
 d01f790:	01434174 	movhi	r5,3333
 d01f794:	297bb604 	addi	r5,r5,-4392
 d01f798:	d020b640 	call	d020b64 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 d01f79c:	008341b4 	movhi	r2,3334
 d01f7a0:	10831e04 	addi	r2,r2,3192
 d01f7a4:	11801717 	ldw	r6,92(r2)
 d01f7a8:	008341b4 	movhi	r2,3334
 d01f7ac:	10831e04 	addi	r2,r2,3192
 d01f7b0:	11c01817 	ldw	r7,96(r2)
 d01f7b4:	e13ffa17 	ldw	r4,-24(fp)
 d01f7b8:	01434174 	movhi	r5,3333
 d01f7bc:	297bc204 	addi	r5,r5,-4344
 d01f7c0:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 d01f7c4:	008341b4 	movhi	r2,3334
 d01f7c8:	10831e04 	addi	r2,r2,3192
 d01f7cc:	11801617 	ldw	r6,88(r2)
 d01f7d0:	e13ffa17 	ldw	r4,-24(fp)
 d01f7d4:	01434174 	movhi	r5,3333
 d01f7d8:	297bd504 	addi	r5,r5,-4268
 d01f7dc:	d020b640 	call	d020b64 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 d01f7e0:	008341b4 	movhi	r2,3334
 d01f7e4:	10831e04 	addi	r2,r2,3192
 d01f7e8:	11800a17 	ldw	r6,40(r2)
 d01f7ec:	e13ffa17 	ldw	r4,-24(fp)
 d01f7f0:	01434174 	movhi	r5,3333
 d01f7f4:	297be104 	addi	r5,r5,-4220
 d01f7f8:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 d01f7fc:	008341b4 	movhi	r2,3334
 d01f800:	10831e04 	addi	r2,r2,3192
 d01f804:	11800b17 	ldw	r6,44(r2)
 d01f808:	e13ffa17 	ldw	r4,-24(fp)
 d01f80c:	01434174 	movhi	r5,3333
 d01f810:	297bed04 	addi	r5,r5,-4172
 d01f814:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 d01f818:	008341b4 	movhi	r2,3334
 d01f81c:	10831e04 	addi	r2,r2,3192
 d01f820:	11800c17 	ldw	r6,48(r2)
 d01f824:	008341b4 	movhi	r2,3334
 d01f828:	10831e04 	addi	r2,r2,3192
 d01f82c:	11c00d17 	ldw	r7,52(r2)
 d01f830:	e13ffa17 	ldw	r4,-24(fp)
 d01f834:	01434174 	movhi	r5,3333
 d01f838:	297bf904 	addi	r5,r5,-4124
 d01f83c:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 d01f840:	008341b4 	movhi	r2,3334
 d01f844:	10831e04 	addi	r2,r2,3192
 d01f848:	11800e17 	ldw	r6,56(r2)
 d01f84c:	008341b4 	movhi	r2,3334
 d01f850:	10831e04 	addi	r2,r2,3192
 d01f854:	11c00f17 	ldw	r7,60(r2)
 d01f858:	e13ffa17 	ldw	r4,-24(fp)
 d01f85c:	01434174 	movhi	r5,3333
 d01f860:	297c0d04 	addi	r5,r5,-4044
 d01f864:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 d01f868:	008341b4 	movhi	r2,3334
 d01f86c:	10831e04 	addi	r2,r2,3192
 d01f870:	11801117 	ldw	r6,68(r2)
 d01f874:	e13ffa17 	ldw	r4,-24(fp)
 d01f878:	01434174 	movhi	r5,3333
 d01f87c:	297c1d04 	addi	r5,r5,-3980
 d01f880:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 d01f884:	008341b4 	movhi	r2,3334
 d01f888:	10831e04 	addi	r2,r2,3192
 d01f88c:	11801217 	ldw	r6,72(r2)
 d01f890:	e13ffa17 	ldw	r4,-24(fp)
 d01f894:	01434174 	movhi	r5,3333
 d01f898:	297c2a04 	addi	r5,r5,-3928
 d01f89c:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 d01f8a0:	008341b4 	movhi	r2,3334
 d01f8a4:	10831e04 	addi	r2,r2,3192
 d01f8a8:	11801317 	ldw	r6,76(r2)
 d01f8ac:	e13ffa17 	ldw	r4,-24(fp)
 d01f8b0:	01434174 	movhi	r5,3333
 d01f8b4:	297c3d04 	addi	r5,r5,-3852
 d01f8b8:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 d01f8bc:	008341b4 	movhi	r2,3334
 d01f8c0:	10831e04 	addi	r2,r2,3192
 d01f8c4:	11801417 	ldw	r6,80(r2)
 d01f8c8:	e13ffa17 	ldw	r4,-24(fp)
 d01f8cc:	01434174 	movhi	r5,3333
 d01f8d0:	297c4e04 	addi	r5,r5,-3784
 d01f8d4:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 d01f8d8:	008341b4 	movhi	r2,3334
 d01f8dc:	10831e04 	addi	r2,r2,3192
 d01f8e0:	11801017 	ldw	r6,64(r2)
 d01f8e4:	e13ffa17 	ldw	r4,-24(fp)
 d01f8e8:	01434174 	movhi	r5,3333
 d01f8ec:	297c6004 	addi	r5,r5,-3712
 d01f8f0:	d020b640 	call	d020b64 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 d01f8f4:	008341b4 	movhi	r2,3334
 d01f8f8:	10831e04 	addi	r2,r2,3192
 d01f8fc:	11801517 	ldw	r6,84(r2)
 d01f900:	e13ffa17 	ldw	r4,-24(fp)
 d01f904:	01434174 	movhi	r5,3333
 d01f908:	297c7004 	addi	r5,r5,-3648
 d01f90c:	d020b640 	call	d020b64 <ns_printf>
   
   return IGMP_OK;
 d01f910:	0005883a 	mov	r2,zero
}
 d01f914:	e037883a 	mov	sp,fp
 d01f918:	dfc00117 	ldw	ra,4(sp)
 d01f91c:	df000017 	ldw	fp,0(sp)
 d01f920:	dec00204 	addi	sp,sp,8
 d01f924:	f800283a 	ret

0d01f928 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 d01f928:	defff304 	addi	sp,sp,-52
 d01f92c:	dfc00c15 	stw	ra,48(sp)
 d01f930:	df000b15 	stw	fp,44(sp)
 d01f934:	df000b04 	addi	fp,sp,44
 d01f938:	e13ffc15 	stw	r4,-16(fp)
 d01f93c:	e17ffd15 	stw	r5,-12(fp)
 d01f940:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 d01f944:	e0bffc17 	ldw	r2,-16(fp)
 d01f948:	10bff804 	addi	r2,r2,-32
 d01f94c:	1085883a 	add	r2,r2,r2
 d01f950:	1085883a 	add	r2,r2,r2
 d01f954:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 d01f958:	008341b4 	movhi	r2,3334
 d01f95c:	10845704 	addi	r2,r2,4444
 d01f960:	e0bff515 	stw	r2,-44(fp)
 d01f964:	00000606 	br	d01f980 <bsd_accept+0x58>
 d01f968:	e0fff517 	ldw	r3,-44(fp)
 d01f96c:	e0bff717 	ldw	r2,-36(fp)
 d01f970:	18800626 	beq	r3,r2,d01f98c <bsd_accept+0x64>
 d01f974:	e0bff517 	ldw	r2,-44(fp)
 d01f978:	10800017 	ldw	r2,0(r2)
 d01f97c:	e0bff515 	stw	r2,-44(fp)
 d01f980:	e0bff517 	ldw	r2,-44(fp)
 d01f984:	1004c03a 	cmpne	r2,r2,zero
 d01f988:	103ff71e 	bne	r2,zero,d01f968 <bsd_accept+0x40>
 d01f98c:	e0fff517 	ldw	r3,-44(fp)
 d01f990:	e0bff717 	ldw	r2,-36(fp)
 d01f994:	18800426 	beq	r3,r2,d01f9a8 <bsd_accept+0x80>
 d01f998:	d025a500 	call	d025a50 <dtrap>
 d01f99c:	00bfffc4 	movi	r2,-1
 d01f9a0:	e0bfff15 	stw	r2,-4(fp)
 d01f9a4:	00002806 	br	d01fa48 <bsd_accept+0x120>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 d01f9a8:	e0bffd17 	ldw	r2,-12(fp)
 d01f9ac:	1005003a 	cmpeq	r2,r2,zero
 d01f9b0:	1000091e 	bne	r2,zero,d01f9d8 <bsd_accept+0xb0>
   {
      if (addrlen == 0)
 d01f9b4:	e0bffe17 	ldw	r2,-8(fp)
 d01f9b8:	1004c03a 	cmpne	r2,r2,zero
 d01f9bc:	1000061e 	bne	r2,zero,d01f9d8 <bsd_accept+0xb0>
      {
         so->so_error = EFAULT;
 d01f9c0:	e0fff717 	ldw	r3,-36(fp)
 d01f9c4:	00800384 	movi	r2,14
 d01f9c8:	18800615 	stw	r2,24(r3)
         return -1;
 d01f9cc:	00bfffc4 	movi	r2,-1
 d01f9d0:	e0bfff15 	stw	r2,-4(fp)
 d01f9d4:	00001c06 	br	d01fa48 <bsd_accept+0x120>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 d01f9d8:	e17ff804 	addi	r5,fp,-32
 d01f9dc:	e13ffc17 	ldw	r4,-16(fp)
 d01f9e0:	e1bffe17 	ldw	r6,-8(fp)
 d01f9e4:	d028de80 	call	d028de8 <t_accept>
 d01f9e8:	e0bff615 	stw	r2,-40(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 d01f9ec:	e0bff617 	ldw	r2,-40(fp)
 d01f9f0:	10bfffe0 	cmpeqi	r2,r2,-1
 d01f9f4:	1000121e 	bne	r2,zero,d01fa40 <bsd_accept+0x118>
 d01f9f8:	e0bffd17 	ldw	r2,-12(fp)
 d01f9fc:	1005003a 	cmpeq	r2,r2,zero
 d01fa00:	10000f1e 	bne	r2,zero,d01fa40 <bsd_accept+0x118>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 d01fa04:	e0bffe17 	ldw	r2,-8(fp)
 d01fa08:	10800017 	ldw	r2,0(r2)
 d01fa0c:	10800470 	cmpltui	r2,r2,17
 d01fa10:	1000031e 	bne	r2,zero,d01fa20 <bsd_accept+0xf8>
         *addrlen = sizeof(struct sockaddr_in);
 d01fa14:	e0fffe17 	ldw	r3,-8(fp)
 d01fa18:	00800404 	movi	r2,16
 d01fa1c:	18800015 	stw	r2,0(r3)
      MEMCPY(addr, &laddr, *addrlen);
 d01fa20:	e0bffe17 	ldw	r2,-8(fp)
 d01fa24:	10800017 	ldw	r2,0(r2)
 d01fa28:	100d883a 	mov	r6,r2
 d01fa2c:	e0bffd17 	ldw	r2,-12(fp)
 d01fa30:	e0fff804 	addi	r3,fp,-32
 d01fa34:	1009883a 	mov	r4,r2
 d01fa38:	180b883a 	mov	r5,r3
 d01fa3c:	d0026080 	call	d002608 <memcpy>
   }

   return lret;
 d01fa40:	e0bff617 	ldw	r2,-40(fp)
 d01fa44:	e0bfff15 	stw	r2,-4(fp)
 d01fa48:	e0bfff17 	ldw	r2,-4(fp)
}
 d01fa4c:	e037883a 	mov	sp,fp
 d01fa50:	dfc00117 	ldw	ra,4(sp)
 d01fa54:	df000017 	ldw	fp,0(sp)
 d01fa58:	dec00204 	addi	sp,sp,8
 d01fa5c:	f800283a 	ret

0d01fa60 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 d01fa60:	defff204 	addi	sp,sp,-56
 d01fa64:	dfc00d15 	stw	ra,52(sp)
 d01fa68:	df000c15 	stw	fp,48(sp)
 d01fa6c:	df000c04 	addi	fp,sp,48
 d01fa70:	e13ffc15 	stw	r4,-16(fp)
 d01fa74:	e17ffd15 	stw	r5,-12(fp)
 d01fa78:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 d01fa7c:	e0bffc17 	ldw	r2,-16(fp)
 d01fa80:	10bff804 	addi	r2,r2,-32
 d01fa84:	1085883a 	add	r2,r2,r2
 d01fa88:	1085883a 	add	r2,r2,r2
 d01fa8c:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 d01fa90:	008341b4 	movhi	r2,3334
 d01fa94:	10845704 	addi	r2,r2,4444
 d01fa98:	e0bff415 	stw	r2,-48(fp)
 d01fa9c:	00000606 	br	d01fab8 <bsd_getpeername+0x58>
 d01faa0:	e0fff417 	ldw	r3,-48(fp)
 d01faa4:	e0bff617 	ldw	r2,-40(fp)
 d01faa8:	18800626 	beq	r3,r2,d01fac4 <bsd_getpeername+0x64>
 d01faac:	e0bff417 	ldw	r2,-48(fp)
 d01fab0:	10800017 	ldw	r2,0(r2)
 d01fab4:	e0bff415 	stw	r2,-48(fp)
 d01fab8:	e0bff417 	ldw	r2,-48(fp)
 d01fabc:	1004c03a 	cmpne	r2,r2,zero
 d01fac0:	103ff71e 	bne	r2,zero,d01faa0 <bsd_getpeername+0x40>
 d01fac4:	e0fff417 	ldw	r3,-48(fp)
 d01fac8:	e0bff617 	ldw	r2,-40(fp)
 d01facc:	18800426 	beq	r3,r2,d01fae0 <bsd_getpeername+0x80>
 d01fad0:	d025a500 	call	d025a50 <dtrap>
 d01fad4:	00bfffc4 	movi	r2,-1
 d01fad8:	e0bfff15 	stw	r2,-4(fp)
 d01fadc:	00002506 	br	d01fb74 <bsd_getpeername+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 d01fae0:	e0bffe17 	ldw	r2,-8(fp)
 d01fae4:	1004c03a 	cmpne	r2,r2,zero
 d01fae8:	1000061e 	bne	r2,zero,d01fb04 <bsd_getpeername+0xa4>
   {
      so->so_error = EFAULT;
 d01faec:	e0fff617 	ldw	r3,-40(fp)
 d01faf0:	00800384 	movi	r2,14
 d01faf4:	18800615 	stw	r2,24(r3)
      return -1;
 d01faf8:	00bfffc4 	movi	r2,-1
 d01fafc:	e0bfff15 	stw	r2,-4(fp)
 d01fb00:	00001c06 	br	d01fb74 <bsd_getpeername+0x114>
   }
   lnamelen = *namelen;
 d01fb04:	e0bffe17 	ldw	r2,-8(fp)
 d01fb08:	10800017 	ldw	r2,0(r2)
 d01fb0c:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 d01fb10:	e17ff704 	addi	r5,fp,-36
 d01fb14:	e1bffb04 	addi	r6,fp,-20
 d01fb18:	e13ffc17 	ldw	r4,-16(fp)
 d01fb1c:	d0293280 	call	d029328 <t_getpeername>
 d01fb20:	e0bff515 	stw	r2,-44(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 d01fb24:	e0bff517 	ldw	r2,-44(fp)
 d01fb28:	10bfffe0 	cmpeqi	r2,r2,-1
 d01fb2c:	10000f1e 	bne	r2,zero,d01fb6c <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 d01fb30:	e0bffb17 	ldw	r2,-20(fp)
 d01fb34:	10800470 	cmpltui	r2,r2,17
 d01fb38:	1000021e 	bne	r2,zero,d01fb44 <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 d01fb3c:	00800404 	movi	r2,16
 d01fb40:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 d01fb44:	e0bffb17 	ldw	r2,-20(fp)
 d01fb48:	100d883a 	mov	r6,r2
 d01fb4c:	e0bffd17 	ldw	r2,-12(fp)
 d01fb50:	e0fff704 	addi	r3,fp,-36
 d01fb54:	1009883a 	mov	r4,r2
 d01fb58:	180b883a 	mov	r5,r3
 d01fb5c:	d0026080 	call	d002608 <memcpy>
      *namelen = lnamelen;
 d01fb60:	e0fffb17 	ldw	r3,-20(fp)
 d01fb64:	e0bffe17 	ldw	r2,-8(fp)
 d01fb68:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 d01fb6c:	e0bff517 	ldw	r2,-44(fp)
 d01fb70:	e0bfff15 	stw	r2,-4(fp)
 d01fb74:	e0bfff17 	ldw	r2,-4(fp)
}
 d01fb78:	e037883a 	mov	sp,fp
 d01fb7c:	dfc00117 	ldw	ra,4(sp)
 d01fb80:	df000017 	ldw	fp,0(sp)
 d01fb84:	dec00204 	addi	sp,sp,8
 d01fb88:	f800283a 	ret

0d01fb8c <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 d01fb8c:	defff204 	addi	sp,sp,-56
 d01fb90:	dfc00d15 	stw	ra,52(sp)
 d01fb94:	df000c15 	stw	fp,48(sp)
 d01fb98:	df000c04 	addi	fp,sp,48
 d01fb9c:	e13ffc15 	stw	r4,-16(fp)
 d01fba0:	e17ffd15 	stw	r5,-12(fp)
 d01fba4:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 d01fba8:	e0bffc17 	ldw	r2,-16(fp)
 d01fbac:	10bff804 	addi	r2,r2,-32
 d01fbb0:	1085883a 	add	r2,r2,r2
 d01fbb4:	1085883a 	add	r2,r2,r2
 d01fbb8:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 d01fbbc:	008341b4 	movhi	r2,3334
 d01fbc0:	10845704 	addi	r2,r2,4444
 d01fbc4:	e0bff415 	stw	r2,-48(fp)
 d01fbc8:	00000606 	br	d01fbe4 <bsd_getsockname+0x58>
 d01fbcc:	e0fff417 	ldw	r3,-48(fp)
 d01fbd0:	e0bff617 	ldw	r2,-40(fp)
 d01fbd4:	18800626 	beq	r3,r2,d01fbf0 <bsd_getsockname+0x64>
 d01fbd8:	e0bff417 	ldw	r2,-48(fp)
 d01fbdc:	10800017 	ldw	r2,0(r2)
 d01fbe0:	e0bff415 	stw	r2,-48(fp)
 d01fbe4:	e0bff417 	ldw	r2,-48(fp)
 d01fbe8:	1004c03a 	cmpne	r2,r2,zero
 d01fbec:	103ff71e 	bne	r2,zero,d01fbcc <bsd_getsockname+0x40>
 d01fbf0:	e0fff417 	ldw	r3,-48(fp)
 d01fbf4:	e0bff617 	ldw	r2,-40(fp)
 d01fbf8:	18800426 	beq	r3,r2,d01fc0c <bsd_getsockname+0x80>
 d01fbfc:	d025a500 	call	d025a50 <dtrap>
 d01fc00:	00bfffc4 	movi	r2,-1
 d01fc04:	e0bfff15 	stw	r2,-4(fp)
 d01fc08:	00002506 	br	d01fca0 <bsd_getsockname+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 d01fc0c:	e0bffe17 	ldw	r2,-8(fp)
 d01fc10:	1004c03a 	cmpne	r2,r2,zero
 d01fc14:	1000061e 	bne	r2,zero,d01fc30 <bsd_getsockname+0xa4>
   {
      so->so_error = EFAULT;
 d01fc18:	e0fff617 	ldw	r3,-40(fp)
 d01fc1c:	00800384 	movi	r2,14
 d01fc20:	18800615 	stw	r2,24(r3)
      return -1;
 d01fc24:	00bfffc4 	movi	r2,-1
 d01fc28:	e0bfff15 	stw	r2,-4(fp)
 d01fc2c:	00001c06 	br	d01fca0 <bsd_getsockname+0x114>
   }
   lnamelen = *namelen;
 d01fc30:	e0bffe17 	ldw	r2,-8(fp)
 d01fc34:	10800017 	ldw	r2,0(r2)
 d01fc38:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 d01fc3c:	e17ff704 	addi	r5,fp,-36
 d01fc40:	e1bffb04 	addi	r6,fp,-20
 d01fc44:	e13ffc17 	ldw	r4,-16(fp)
 d01fc48:	d02936c0 	call	d02936c <t_getsockname>
 d01fc4c:	e0bff515 	stw	r2,-44(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 d01fc50:	e0bff517 	ldw	r2,-44(fp)
 d01fc54:	10bfffe0 	cmpeqi	r2,r2,-1
 d01fc58:	10000f1e 	bne	r2,zero,d01fc98 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 d01fc5c:	e0bffb17 	ldw	r2,-20(fp)
 d01fc60:	10800470 	cmpltui	r2,r2,17
 d01fc64:	1000021e 	bne	r2,zero,d01fc70 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 d01fc68:	00800404 	movi	r2,16
 d01fc6c:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 d01fc70:	e0bffb17 	ldw	r2,-20(fp)
 d01fc74:	100d883a 	mov	r6,r2
 d01fc78:	e0bffd17 	ldw	r2,-12(fp)
 d01fc7c:	e0fff704 	addi	r3,fp,-36
 d01fc80:	1009883a 	mov	r4,r2
 d01fc84:	180b883a 	mov	r5,r3
 d01fc88:	d0026080 	call	d002608 <memcpy>
      *namelen = lnamelen;
 d01fc8c:	e0fffb17 	ldw	r3,-20(fp)
 d01fc90:	e0bffe17 	ldw	r2,-8(fp)
 d01fc94:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 d01fc98:	e0bff517 	ldw	r2,-44(fp)
 d01fc9c:	e0bfff15 	stw	r2,-4(fp)
 d01fca0:	e0bfff17 	ldw	r2,-4(fp)
}
 d01fca4:	e037883a 	mov	sp,fp
 d01fca8:	dfc00117 	ldw	ra,4(sp)
 d01fcac:	df000017 	ldw	fp,0(sp)
 d01fcb0:	dec00204 	addi	sp,sp,8
 d01fcb4:	f800283a 	ret

0d01fcb8 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 d01fcb8:	defffb04 	addi	sp,sp,-20
 d01fcbc:	df000415 	stw	fp,16(sp)
 d01fcc0:	df000404 	addi	fp,sp,16
 d01fcc4:	e13ffc15 	stw	r4,-16(fp)
 d01fcc8:	e17ffd15 	stw	r5,-12(fp)
   USE_ARG(level);

   switch (name)
 d01fccc:	e0bffd17 	ldw	r2,-12(fp)
 d01fcd0:	e0bfff15 	stw	r2,-4(fp)
 d01fcd4:	e0ffff17 	ldw	r3,-4(fp)
 d01fcd8:	18802020 	cmpeqi	r2,r3,128
 d01fcdc:	1000491e 	bne	r2,zero,d01fe04 <bsd_i_sockoptlen+0x14c>
 d01fce0:	e0ffff17 	ldw	r3,-4(fp)
 d01fce4:	18802048 	cmpgei	r2,r3,129
 d01fce8:	1000251e 	bne	r2,zero,d01fd80 <bsd_i_sockoptlen+0xc8>
 d01fcec:	e0ffff17 	ldw	r3,-4(fp)
 d01fcf0:	18800308 	cmpgei	r2,r3,12
 d01fcf4:	1000141e 	bne	r2,zero,d01fd48 <bsd_i_sockoptlen+0x90>
 d01fcf8:	e0ffff17 	ldw	r3,-4(fp)
 d01fcfc:	18800288 	cmpgei	r2,r3,10
 d01fd00:	10004c1e 	bne	r2,zero,d01fe34 <bsd_i_sockoptlen+0x17c>
 d01fd04:	e0ffff17 	ldw	r3,-4(fp)
 d01fd08:	18800120 	cmpeqi	r2,r3,4
 d01fd0c:	1000431e 	bne	r2,zero,d01fe1c <bsd_i_sockoptlen+0x164>
 d01fd10:	e0ffff17 	ldw	r3,-4(fp)
 d01fd14:	18800148 	cmpgei	r2,r3,5
 d01fd18:	1000041e 	bne	r2,zero,d01fd2c <bsd_i_sockoptlen+0x74>
 d01fd1c:	e0ffff17 	ldw	r3,-4(fp)
 d01fd20:	188000e0 	cmpeqi	r2,r3,3
 d01fd24:	1000491e 	bne	r2,zero,d01fe4c <bsd_i_sockoptlen+0x194>
 d01fd28:	00004b06 	br	d01fe58 <bsd_i_sockoptlen+0x1a0>
 d01fd2c:	e0ffff17 	ldw	r3,-4(fp)
 d01fd30:	18800220 	cmpeqi	r2,r3,8
 d01fd34:	1000391e 	bne	r2,zero,d01fe1c <bsd_i_sockoptlen+0x164>
 d01fd38:	e0ffff17 	ldw	r3,-4(fp)
 d01fd3c:	18800260 	cmpeqi	r2,r3,9
 d01fd40:	1000391e 	bne	r2,zero,d01fe28 <bsd_i_sockoptlen+0x170>
 d01fd44:	00004406 	br	d01fe58 <bsd_i_sockoptlen+0x1a0>
 d01fd48:	e0ffff17 	ldw	r3,-4(fp)
 d01fd4c:	18800420 	cmpeqi	r2,r3,16
 d01fd50:	1000321e 	bne	r2,zero,d01fe1c <bsd_i_sockoptlen+0x164>
 d01fd54:	e0ffff17 	ldw	r3,-4(fp)
 d01fd58:	18800448 	cmpgei	r2,r3,17
 d01fd5c:	1000041e 	bne	r2,zero,d01fd70 <bsd_i_sockoptlen+0xb8>
 d01fd60:	e0ffff17 	ldw	r3,-4(fp)
 d01fd64:	18800388 	cmpgei	r2,r3,14
 d01fd68:	10003b1e 	bne	r2,zero,d01fe58 <bsd_i_sockoptlen+0x1a0>
 d01fd6c:	00003406 	br	d01fe40 <bsd_i_sockoptlen+0x188>
 d01fd70:	e0ffff17 	ldw	r3,-4(fp)
 d01fd74:	18800820 	cmpeqi	r2,r3,32
 d01fd78:	1000281e 	bne	r2,zero,d01fe1c <bsd_i_sockoptlen+0x164>
 d01fd7c:	00003606 	br	d01fe58 <bsd_i_sockoptlen+0x1a0>
 d01fd80:	e0ffff17 	ldw	r3,-4(fp)
 d01fd84:	188401c8 	cmpgei	r2,r3,4103
 d01fd88:	10000e1e 	bne	r2,zero,d01fdc4 <bsd_i_sockoptlen+0x10c>
 d01fd8c:	e0ffff17 	ldw	r3,-4(fp)
 d01fd90:	18840148 	cmpgei	r2,r3,4101
 d01fd94:	10001e1e 	bne	r2,zero,d01fe10 <bsd_i_sockoptlen+0x158>
 d01fd98:	e0ffff17 	ldw	r3,-4(fp)
 d01fd9c:	18804020 	cmpeqi	r2,r3,256
 d01fda0:	10001e1e 	bne	r2,zero,d01fe1c <bsd_i_sockoptlen+0x164>
 d01fda4:	e0ffff17 	ldw	r3,-4(fp)
 d01fda8:	18804010 	cmplti	r2,r3,256
 d01fdac:	10002a1e 	bne	r2,zero,d01fe58 <bsd_i_sockoptlen+0x1a0>
 d01fdb0:	e0ffff17 	ldw	r3,-4(fp)
 d01fdb4:	18bbffc4 	addi	r2,r3,-4097
 d01fdb8:	108000a8 	cmpgeui	r2,r2,2
 d01fdbc:	1000261e 	bne	r2,zero,d01fe58 <bsd_i_sockoptlen+0x1a0>
 d01fdc0:	00001606 	br	d01fe1c <bsd_i_sockoptlen+0x164>
 d01fdc4:	e0ffff17 	ldw	r3,-4(fp)
 d01fdc8:	18840588 	cmpgei	r2,r3,4118
 d01fdcc:	1000071e 	bne	r2,zero,d01fdec <bsd_i_sockoptlen+0x134>
 d01fdd0:	e0ffff17 	ldw	r3,-4(fp)
 d01fdd4:	18840508 	cmpgei	r2,r3,4116
 d01fdd8:	1000081e 	bne	r2,zero,d01fdfc <bsd_i_sockoptlen+0x144>
 d01fddc:	e0ffff17 	ldw	r3,-4(fp)
 d01fde0:	18840248 	cmpgei	r2,r3,4105
 d01fde4:	10001c1e 	bne	r2,zero,d01fe58 <bsd_i_sockoptlen+0x1a0>
 d01fde8:	00000c06 	br	d01fe1c <bsd_i_sockoptlen+0x164>
 d01fdec:	e0ffff17 	ldw	r3,-4(fp)
 d01fdf0:	188405a0 	cmpeqi	r2,r3,4118
 d01fdf4:	1000091e 	bne	r2,zero,d01fe1c <bsd_i_sockoptlen+0x164>
 d01fdf8:	00001706 	br	d01fe58 <bsd_i_sockoptlen+0x1a0>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 d01fdfc:	e03ffe15 	stw	zero,-8(fp)
 d01fe00:	00001606 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 d01fe04:	00800204 	movi	r2,8
 d01fe08:	e0bffe15 	stw	r2,-8(fp)
 d01fe0c:	00001306 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 d01fe10:	00c00084 	movi	r3,2
 d01fe14:	e0fffe15 	stw	r3,-8(fp)
 d01fe18:	00001006 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 d01fe1c:	00800104 	movi	r2,4
 d01fe20:	e0bffe15 	stw	r2,-8(fp)
 d01fe24:	00000d06 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 d01fe28:	00c00104 	movi	r3,4
 d01fe2c:	e0fffe15 	stw	r3,-8(fp)
 d01fe30:	00000a06 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 d01fe34:	00800044 	movi	r2,1
 d01fe38:	e0bffe15 	stw	r2,-8(fp)
 d01fe3c:	00000706 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 d01fe40:	00c00204 	movi	r3,8
 d01fe44:	e0fffe15 	stw	r3,-8(fp)
 d01fe48:	00000406 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 d01fe4c:	00800104 	movi	r2,4
 d01fe50:	e0bffe15 	stw	r2,-8(fp)
 d01fe54:	00000106 	br	d01fe5c <bsd_i_sockoptlen+0x1a4>
   default:
      /* we don't know what type these options are */
      return 0;
 d01fe58:	e03ffe15 	stw	zero,-8(fp)
 d01fe5c:	e0bffe17 	ldw	r2,-8(fp)
   }
   
}
 d01fe60:	e037883a 	mov	sp,fp
 d01fe64:	df000017 	ldw	fp,0(sp)
 d01fe68:	dec00104 	addi	sp,sp,4
 d01fe6c:	f800283a 	ret

0d01fe70 <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 d01fe70:	defff404 	addi	sp,sp,-48
 d01fe74:	dfc00b15 	stw	ra,44(sp)
 d01fe78:	df000a15 	stw	fp,40(sp)
 d01fe7c:	df000a04 	addi	fp,sp,40
 d01fe80:	e13ffb15 	stw	r4,-20(fp)
 d01fe84:	e17ffc15 	stw	r5,-16(fp)
 d01fe88:	e1bffd15 	stw	r6,-12(fp)
 d01fe8c:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 d01fe90:	e0bffb17 	ldw	r2,-20(fp)
 d01fe94:	10bff804 	addi	r2,r2,-32
 d01fe98:	1085883a 	add	r2,r2,r2
 d01fe9c:	1085883a 	add	r2,r2,r2
 d01fea0:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d01fea4:	008341b4 	movhi	r2,3334
 d01fea8:	10845704 	addi	r2,r2,4444
 d01feac:	e0bff715 	stw	r2,-36(fp)
 d01feb0:	00000606 	br	d01fecc <bsd_getsockopt+0x5c>
 d01feb4:	e0fff717 	ldw	r3,-36(fp)
 d01feb8:	e0bffa17 	ldw	r2,-24(fp)
 d01febc:	18800626 	beq	r3,r2,d01fed8 <bsd_getsockopt+0x68>
 d01fec0:	e0bff717 	ldw	r2,-36(fp)
 d01fec4:	10800017 	ldw	r2,0(r2)
 d01fec8:	e0bff715 	stw	r2,-36(fp)
 d01fecc:	e0bff717 	ldw	r2,-36(fp)
 d01fed0:	1004c03a 	cmpne	r2,r2,zero
 d01fed4:	103ff71e 	bne	r2,zero,d01feb4 <bsd_getsockopt+0x44>
 d01fed8:	e0fff717 	ldw	r3,-36(fp)
 d01fedc:	e0bffa17 	ldw	r2,-24(fp)
 d01fee0:	18800426 	beq	r3,r2,d01fef4 <bsd_getsockopt+0x84>
 d01fee4:	d025a500 	call	d025a50 <dtrap>
 d01fee8:	00bfffc4 	movi	r2,-1
 d01feec:	e0bfff15 	stw	r2,-4(fp)
 d01fef0:	00002106 	br	d01ff78 <bsd_getsockopt+0x108>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 d01fef4:	e13ffc17 	ldw	r4,-16(fp)
 d01fef8:	e17ffd17 	ldw	r5,-12(fp)
 d01fefc:	d01fcb80 	call	d01fcb8 <bsd_i_sockoptlen>
 d01ff00:	e0bff915 	stw	r2,-28(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 d01ff04:	e0800217 	ldw	r2,8(fp)
 d01ff08:	1005003a 	cmpeq	r2,r2,zero
 d01ff0c:	1000041e 	bne	r2,zero,d01ff20 <bsd_getsockopt+0xb0>
 d01ff10:	e0800217 	ldw	r2,8(fp)
 d01ff14:	10c00017 	ldw	r3,0(r2)
 d01ff18:	e0bff917 	ldw	r2,-28(fp)
 d01ff1c:	1880060e 	bge	r3,r2,d01ff38 <bsd_getsockopt+0xc8>
   {
      so->so_error = EFAULT;
 d01ff20:	e0fffa17 	ldw	r3,-24(fp)
 d01ff24:	00800384 	movi	r2,14
 d01ff28:	18800615 	stw	r2,24(r3)
      return -1;
 d01ff2c:	00bfffc4 	movi	r2,-1
 d01ff30:	e0bfff15 	stw	r2,-4(fp)
 d01ff34:	00001006 	br	d01ff78 <bsd_getsockopt+0x108>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 d01ff38:	e0bff917 	ldw	r2,-28(fp)
 d01ff3c:	d8800015 	stw	r2,0(sp)
 d01ff40:	e13ffb17 	ldw	r4,-20(fp)
 d01ff44:	e17ffc17 	ldw	r5,-16(fp)
 d01ff48:	e1bffd17 	ldw	r6,-12(fp)
 d01ff4c:	e1fffe17 	ldw	r7,-8(fp)
 d01ff50:	d0297880 	call	d029788 <t_getsockopt>
 d01ff54:	e0bff815 	stw	r2,-32(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 d01ff58:	e0bff817 	ldw	r2,-32(fp)
 d01ff5c:	1004c03a 	cmpne	r2,r2,zero
 d01ff60:	1000031e 	bne	r2,zero,d01ff70 <bsd_getsockopt+0x100>
   {
      *optlen = loptlen;
 d01ff64:	e0c00217 	ldw	r3,8(fp)
 d01ff68:	e0bff917 	ldw	r2,-28(fp)
 d01ff6c:	18800015 	stw	r2,0(r3)
   }

   return e;
 d01ff70:	e0bff817 	ldw	r2,-32(fp)
 d01ff74:	e0bfff15 	stw	r2,-4(fp)
 d01ff78:	e0bfff17 	ldw	r2,-4(fp)
   
}
 d01ff7c:	e037883a 	mov	sp,fp
 d01ff80:	dfc00117 	ldw	ra,4(sp)
 d01ff84:	df000017 	ldw	fp,0(sp)
 d01ff88:	dec00204 	addi	sp,sp,8
 d01ff8c:	f800283a 	ret

0d01ff90 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 d01ff90:	defff404 	addi	sp,sp,-48
 d01ff94:	dfc00915 	stw	ra,36(sp)
 d01ff98:	df000815 	stw	fp,32(sp)
 d01ff9c:	df000804 	addi	fp,sp,32
 d01ffa0:	e13ffd15 	stw	r4,-12(fp)
 d01ffa4:	e1800215 	stw	r6,8(fp)
 d01ffa8:	e1c00315 	stw	r7,12(fp)
 d01ffac:	e17ffe15 	stw	r5,-8(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 d01ffb0:	e0bffd17 	ldw	r2,-12(fp)
 d01ffb4:	10bff804 	addi	r2,r2,-32
 d01ffb8:	1085883a 	add	r2,r2,r2
 d01ffbc:	1085883a 	add	r2,r2,r2
 d01ffc0:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d01ffc4:	008341b4 	movhi	r2,3334
 d01ffc8:	10845704 	addi	r2,r2,4444
 d01ffcc:	e0bff915 	stw	r2,-28(fp)
 d01ffd0:	00000606 	br	d01ffec <bsd_ioctl+0x5c>
 d01ffd4:	e0fff917 	ldw	r3,-28(fp)
 d01ffd8:	e0bffa17 	ldw	r2,-24(fp)
 d01ffdc:	18800626 	beq	r3,r2,d01fff8 <bsd_ioctl+0x68>
 d01ffe0:	e0bff917 	ldw	r2,-28(fp)
 d01ffe4:	10800017 	ldw	r2,0(r2)
 d01ffe8:	e0bff915 	stw	r2,-28(fp)
 d01ffec:	e0bff917 	ldw	r2,-28(fp)
 d01fff0:	1004c03a 	cmpne	r2,r2,zero
 d01fff4:	103ff71e 	bne	r2,zero,d01ffd4 <bsd_ioctl+0x44>
 d01fff8:	e0fff917 	ldw	r3,-28(fp)
 d01fffc:	e0bffa17 	ldw	r2,-24(fp)
 d020000:	18800426 	beq	r3,r2,d020014 <bsd_ioctl+0x84>
 d020004:	d025a500 	call	d025a50 <dtrap>
 d020008:	00bfffc4 	movi	r2,-1
 d02000c:	e0bfff15 	stw	r2,-4(fp)
 d020010:	00001a06 	br	d02007c <bsd_ioctl+0xec>

   va_start(argptr, request);
 d020014:	e0800204 	addi	r2,fp,8
 d020018:	e0bffb15 	stw	r2,-20(fp)

   switch (request)
 d02001c:	e0bffe17 	ldw	r2,-8(fp)
 d020020:	108405a0 	cmpeqi	r2,r2,4118
 d020024:	1000011e 	bne	r2,zero,d02002c <bsd_ioctl+0x9c>
 d020028:	00000f06 	br	d020068 <bsd_ioctl+0xd8>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 d02002c:	e0fffb17 	ldw	r3,-20(fp)
 d020030:	18800104 	addi	r2,r3,4
 d020034:	e0bffb15 	stw	r2,-20(fp)
 d020038:	1805883a 	mov	r2,r3
 d02003c:	10800017 	ldw	r2,0(r2)
 d020040:	e0bffc15 	stw	r2,-16(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 d020044:	e1fffc04 	addi	r7,fp,-16
 d020048:	00800104 	movi	r2,4
 d02004c:	d8800015 	stw	r2,0(sp)
 d020050:	e13ffd17 	ldw	r4,-12(fp)
 d020054:	017fffc4 	movi	r5,-1
 d020058:	01840584 	movi	r6,4118
 d02005c:	d0295ac0 	call	d0295ac <t_setsockopt>
 d020060:	e0bfff15 	stw	r2,-4(fp)
 d020064:	00000506 	br	d02007c <bsd_ioctl+0xec>
   default:
      so->so_error = EINVAL;
 d020068:	e0fffa17 	ldw	r3,-24(fp)
 d02006c:	00800584 	movi	r2,22
 d020070:	18800615 	stw	r2,24(r3)
      return -1;
 d020074:	00bfffc4 	movi	r2,-1
 d020078:	e0bfff15 	stw	r2,-4(fp)
 d02007c:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d020080:	e037883a 	mov	sp,fp
 d020084:	dfc00117 	ldw	ra,4(sp)
 d020088:	df000017 	ldw	fp,0(sp)
 d02008c:	dec00404 	addi	sp,sp,16
 d020090:	f800283a 	ret

0d020094 <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 d020094:	defffd04 	addi	sp,sp,-12
 d020098:	dfc00215 	stw	ra,8(sp)
 d02009c:	df000115 	stw	fp,4(sp)
 d0200a0:	df000104 	addi	fp,sp,4
 d0200a4:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 d0200a8:	e13fff17 	ldw	r4,-4(fp)
 d0200ac:	d02079c0 	call	d02079c <print_ipad>
}
 d0200b0:	e037883a 	mov	sp,fp
 d0200b4:	dfc00117 	ldw	ra,4(sp)
 d0200b8:	df000017 	ldw	fp,0(sp)
 d0200bc:	dec00204 	addi	sp,sp,8
 d0200c0:	f800283a 	ret

0d0200c4 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 d0200c4:	deffef04 	addi	sp,sp,-68
 d0200c8:	dfc01015 	stw	ra,64(sp)
 d0200cc:	df000f15 	stw	fp,60(sp)
 d0200d0:	df000f04 	addi	fp,sp,60
 d0200d4:	e13ffb15 	stw	r4,-20(fp)
 d0200d8:	e17ffc15 	stw	r5,-16(fp)
 d0200dc:	e1bffd15 	stw	r6,-12(fp)
 d0200e0:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 d0200e4:	e03ffa15 	stw	zero,-24(fp)
   int lret;

   so = LONG2SO(s);
 d0200e8:	e0bffb17 	ldw	r2,-20(fp)
 d0200ec:	10bff804 	addi	r2,r2,-32
 d0200f0:	1085883a 	add	r2,r2,r2
 d0200f4:	1085883a 	add	r2,r2,r2
 d0200f8:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 d0200fc:	008341b4 	movhi	r2,3334
 d020100:	10845704 	addi	r2,r2,4444
 d020104:	e0bff315 	stw	r2,-52(fp)
 d020108:	00000606 	br	d020124 <bsd_recvfrom+0x60>
 d02010c:	e0fff317 	ldw	r3,-52(fp)
 d020110:	e0bff517 	ldw	r2,-44(fp)
 d020114:	18800626 	beq	r3,r2,d020130 <bsd_recvfrom+0x6c>
 d020118:	e0bff317 	ldw	r2,-52(fp)
 d02011c:	10800017 	ldw	r2,0(r2)
 d020120:	e0bff315 	stw	r2,-52(fp)
 d020124:	e0bff317 	ldw	r2,-52(fp)
 d020128:	1004c03a 	cmpne	r2,r2,zero
 d02012c:	103ff71e 	bne	r2,zero,d02010c <bsd_recvfrom+0x48>
 d020130:	e0fff317 	ldw	r3,-52(fp)
 d020134:	e0bff517 	ldw	r2,-44(fp)
 d020138:	18800426 	beq	r3,r2,d02014c <bsd_recvfrom+0x88>
 d02013c:	d025a500 	call	d025a50 <dtrap>
 d020140:	00bfffc4 	movi	r2,-1
 d020144:	e0bfff15 	stw	r2,-4(fp)
 d020148:	00003006 	br	d02020c <bsd_recvfrom+0x148>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 d02014c:	e0800217 	ldw	r2,8(fp)
 d020150:	1005003a 	cmpeq	r2,r2,zero
 d020154:	10000c1e 	bne	r2,zero,d020188 <bsd_recvfrom+0xc4>
   {
      if (fromlen == NULL)
 d020158:	e0800317 	ldw	r2,12(fp)
 d02015c:	1004c03a 	cmpne	r2,r2,zero
 d020160:	1000061e 	bne	r2,zero,d02017c <bsd_recvfrom+0xb8>
      {
         so->so_error = EFAULT;
 d020164:	e0fff517 	ldw	r3,-44(fp)
 d020168:	00800384 	movi	r2,14
 d02016c:	18800615 	stw	r2,24(r3)
         return -1;
 d020170:	00bfffc4 	movi	r2,-1
 d020174:	e0bfff15 	stw	r2,-4(fp)
 d020178:	00002406 	br	d02020c <bsd_recvfrom+0x148>
      }
      lfromlen = *fromlen;
 d02017c:	e0800317 	ldw	r2,12(fp)
 d020180:	10800017 	ldw	r2,0(r2)
 d020184:	e0bffa15 	stw	r2,-24(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 d020188:	e17ffc17 	ldw	r5,-16(fp)
 d02018c:	e0bff604 	addi	r2,fp,-40
 d020190:	d8800015 	stw	r2,0(sp)
 d020194:	e0bffa04 	addi	r2,fp,-24
 d020198:	d8800115 	stw	r2,4(sp)
 d02019c:	e13ffb17 	ldw	r4,-20(fp)
 d0201a0:	e1bffd17 	ldw	r6,-12(fp)
 d0201a4:	e1fffe17 	ldw	r7,-8(fp)
 d0201a8:	d029a1c0 	call	d029a1c <t_recvfrom>
 d0201ac:	e0bff415 	stw	r2,-48(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 d0201b0:	e0bff417 	ldw	r2,-48(fp)
 d0201b4:	10bfffe0 	cmpeqi	r2,r2,-1
 d0201b8:	1000121e 	bne	r2,zero,d020204 <bsd_recvfrom+0x140>
 d0201bc:	e0800217 	ldw	r2,8(fp)
 d0201c0:	1005003a 	cmpeq	r2,r2,zero
 d0201c4:	10000f1e 	bne	r2,zero,d020204 <bsd_recvfrom+0x140>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 d0201c8:	e0bffa17 	ldw	r2,-24(fp)
 d0201cc:	10800470 	cmpltui	r2,r2,17
 d0201d0:	1000021e 	bne	r2,zero,d0201dc <bsd_recvfrom+0x118>
         lfromlen = sizeof(struct sockaddr_in);
 d0201d4:	00800404 	movi	r2,16
 d0201d8:	e0bffa15 	stw	r2,-24(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 d0201dc:	e0bffa17 	ldw	r2,-24(fp)
 d0201e0:	100d883a 	mov	r6,r2
 d0201e4:	e0800217 	ldw	r2,8(fp)
 d0201e8:	e0fff604 	addi	r3,fp,-40
 d0201ec:	1009883a 	mov	r4,r2
 d0201f0:	180b883a 	mov	r5,r3
 d0201f4:	d0026080 	call	d002608 <memcpy>
      *fromlen = lfromlen;
 d0201f8:	e0fffa17 	ldw	r3,-24(fp)
 d0201fc:	e0800317 	ldw	r2,12(fp)
 d020200:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 d020204:	e0bff417 	ldw	r2,-48(fp)
 d020208:	e0bfff15 	stw	r2,-4(fp)
 d02020c:	e0bfff17 	ldw	r2,-4(fp)
}
 d020210:	e037883a 	mov	sp,fp
 d020214:	dfc00117 	ldw	ra,4(sp)
 d020218:	df000017 	ldw	fp,0(sp)
 d02021c:	dec00204 	addi	sp,sp,8
 d020220:	f800283a 	ret

0d020224 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 d020224:	defff804 	addi	sp,sp,-32
 d020228:	dfc00715 	stw	ra,28(sp)
 d02022c:	df000615 	stw	fp,24(sp)
 d020230:	df000604 	addi	fp,sp,24
 d020234:	e13ffc15 	stw	r4,-16(fp)
 d020238:	e17ffd15 	stw	r5,-12(fp)
 d02023c:	e1bffe15 	stw	r6,-8(fp)
 d020240:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 d020244:	e0800217 	ldw	r2,8(fp)
 d020248:	1005003a 	cmpeq	r2,r2,zero
 d02024c:	10004a1e 	bne	r2,zero,d020378 <bsd_select+0x154>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 d020250:	00801904 	movi	r2,100
 d020254:	e0bffa15 	stw	r2,-24(fp)
      if (tps >= 1000)
 d020258:	e0bffa17 	ldw	r2,-24(fp)
 d02025c:	1080fa10 	cmplti	r2,r2,1000
 d020260:	10000d1e 	bne	r2,zero,d020298 <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 d020264:	e0800217 	ldw	r2,8(fp)
 d020268:	10800117 	ldw	r2,4(r2)
 d02026c:	11000c84 	addi	r4,r2,50
 d020270:	01401904 	movi	r5,100
 d020274:	d00c84c0 	call	d00c84c <__divsi3>
 d020278:	1009883a 	mov	r4,r2
 d02027c:	e17ffa17 	ldw	r5,-24(fp)
 d020280:	d00235c0 	call	d00235c <__mulsi3>
 d020284:	1009883a 	mov	r4,r2
 d020288:	0149c404 	movi	r5,10000
 d02028c:	d00c84c0 	call	d00c84c <__divsi3>
 d020290:	e0bffb15 	stw	r2,-20(fp)
 d020294:	00002e06 	br	d020350 <bsd_select+0x12c>
      }
      else if (tps >= 100)
 d020298:	e0bffa17 	ldw	r2,-24(fp)
 d02029c:	10801910 	cmplti	r2,r2,100
 d0202a0:	10000d1e 	bne	r2,zero,d0202d8 <bsd_select+0xb4>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 d0202a4:	e0800217 	ldw	r2,8(fp)
 d0202a8:	10800117 	ldw	r2,4(r2)
 d0202ac:	11007d04 	addi	r4,r2,500
 d0202b0:	0140fa04 	movi	r5,1000
 d0202b4:	d00c84c0 	call	d00c84c <__divsi3>
 d0202b8:	1009883a 	mov	r4,r2
 d0202bc:	e17ffa17 	ldw	r5,-24(fp)
 d0202c0:	d00235c0 	call	d00235c <__mulsi3>
 d0202c4:	1009883a 	mov	r4,r2
 d0202c8:	0140fa04 	movi	r5,1000
 d0202cc:	d00c84c0 	call	d00c84c <__divsi3>
 d0202d0:	e0bffb15 	stw	r2,-20(fp)
 d0202d4:	00001e06 	br	d020350 <bsd_select+0x12c>
      }
      else if (tps >= 10)
 d0202d8:	e0bffa17 	ldw	r2,-24(fp)
 d0202dc:	10800290 	cmplti	r2,r2,10
 d0202e0:	10000d1e 	bne	r2,zero,d020318 <bsd_select+0xf4>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 d0202e4:	e0800217 	ldw	r2,8(fp)
 d0202e8:	10800117 	ldw	r2,4(r2)
 d0202ec:	1104e204 	addi	r4,r2,5000
 d0202f0:	0149c404 	movi	r5,10000
 d0202f4:	d00c84c0 	call	d00c84c <__divsi3>
 d0202f8:	1009883a 	mov	r4,r2
 d0202fc:	e17ffa17 	ldw	r5,-24(fp)
 d020300:	d00235c0 	call	d00235c <__mulsi3>
 d020304:	1009883a 	mov	r4,r2
 d020308:	01401904 	movi	r5,100
 d02030c:	d00c84c0 	call	d00c84c <__divsi3>
 d020310:	e0bffb15 	stw	r2,-20(fp)
 d020314:	00000e06 	br	d020350 <bsd_select+0x12c>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 d020318:	e0800217 	ldw	r2,8(fp)
 d02031c:	10c00117 	ldw	r3,4(r2)
 d020320:	00b0d414 	movui	r2,50000
 d020324:	1889883a 	add	r4,r3,r2
 d020328:	014000b4 	movhi	r5,2
 d02032c:	2961a804 	addi	r5,r5,-31072
 d020330:	d00c84c0 	call	d00c84c <__divsi3>
 d020334:	1009883a 	mov	r4,r2
 d020338:	e17ffa17 	ldw	r5,-24(fp)
 d02033c:	d00235c0 	call	d00235c <__mulsi3>
 d020340:	1009883a 	mov	r4,r2
 d020344:	01400284 	movi	r5,10
 d020348:	d00c84c0 	call	d00c84c <__divsi3>
 d02034c:	e0bffb15 	stw	r2,-20(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 d020350:	e0800217 	ldw	r2,8(fp)
 d020354:	10800017 	ldw	r2,0(r2)
 d020358:	1009883a 	mov	r4,r2
 d02035c:	01401904 	movi	r5,100
 d020360:	d00235c0 	call	d00235c <__mulsi3>
 d020364:	1007883a 	mov	r3,r2
 d020368:	e0bffb17 	ldw	r2,-20(fp)
 d02036c:	1885883a 	add	r2,r3,r2
 d020370:	e0bffb15 	stw	r2,-20(fp)
 d020374:	00000206 	br	d020380 <bsd_select+0x15c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 d020378:	00bfffc4 	movi	r2,-1
 d02037c:	e0bffb15 	stw	r2,-20(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 d020380:	e13ffd17 	ldw	r4,-12(fp)
 d020384:	e17ffe17 	ldw	r5,-8(fp)
 d020388:	e1bfff17 	ldw	r6,-4(fp)
 d02038c:	e1fffb17 	ldw	r7,-20(fp)
 d020390:	d02d93c0 	call	d02d93c <t_select>
}
 d020394:	e037883a 	mov	sp,fp
 d020398:	dfc00117 	ldw	ra,4(sp)
 d02039c:	df000017 	ldw	fp,0(sp)
 d0203a0:	dec00204 	addi	sp,sp,8
 d0203a4:	f800283a 	ret

0d0203a8 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 d0203a8:	defff604 	addi	sp,sp,-40
 d0203ac:	dfc00915 	stw	ra,36(sp)
 d0203b0:	df000815 	stw	fp,32(sp)
 d0203b4:	df000804 	addi	fp,sp,32
 d0203b8:	e13ffb15 	stw	r4,-20(fp)
 d0203bc:	e17ffc15 	stw	r5,-16(fp)
 d0203c0:	e1bffd15 	stw	r6,-12(fp)
 d0203c4:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;

   so = LONG2SO(s);
 d0203c8:	e0bffb17 	ldw	r2,-20(fp)
 d0203cc:	10bff804 	addi	r2,r2,-32
 d0203d0:	1085883a 	add	r2,r2,r2
 d0203d4:	1085883a 	add	r2,r2,r2
 d0203d8:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d0203dc:	008341b4 	movhi	r2,3334
 d0203e0:	10845704 	addi	r2,r2,4444
 d0203e4:	e0bff915 	stw	r2,-28(fp)
 d0203e8:	00000606 	br	d020404 <bsd_setsockopt+0x5c>
 d0203ec:	e0fff917 	ldw	r3,-28(fp)
 d0203f0:	e0bffa17 	ldw	r2,-24(fp)
 d0203f4:	18800626 	beq	r3,r2,d020410 <bsd_setsockopt+0x68>
 d0203f8:	e0bff917 	ldw	r2,-28(fp)
 d0203fc:	10800017 	ldw	r2,0(r2)
 d020400:	e0bff915 	stw	r2,-28(fp)
 d020404:	e0bff917 	ldw	r2,-28(fp)
 d020408:	1004c03a 	cmpne	r2,r2,zero
 d02040c:	103ff71e 	bne	r2,zero,d0203ec <bsd_setsockopt+0x44>
 d020410:	e0fff917 	ldw	r3,-28(fp)
 d020414:	e0bffa17 	ldw	r2,-24(fp)
 d020418:	18800426 	beq	r3,r2,d02042c <bsd_setsockopt+0x84>
 d02041c:	d025a500 	call	d025a50 <dtrap>
 d020420:	00bfffc4 	movi	r2,-1
 d020424:	e0bfff15 	stw	r2,-4(fp)
 d020428:	00001406 	br	d02047c <bsd_setsockopt+0xd4>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 d02042c:	e13ffc17 	ldw	r4,-16(fp)
 d020430:	e17ffd17 	ldw	r5,-12(fp)
 d020434:	d01fcb80 	call	d01fcb8 <bsd_i_sockoptlen>
 d020438:	1007883a 	mov	r3,r2
 d02043c:	e0800217 	ldw	r2,8(fp)
 d020440:	10c0060e 	bge	r2,r3,d02045c <bsd_setsockopt+0xb4>
   {
      so->so_error = EFAULT;
 d020444:	e0fffa17 	ldw	r3,-24(fp)
 d020448:	00800384 	movi	r2,14
 d02044c:	18800615 	stw	r2,24(r3)
      return -1;
 d020450:	00bfffc4 	movi	r2,-1
 d020454:	e0bfff15 	stw	r2,-4(fp)
 d020458:	00000806 	br	d02047c <bsd_setsockopt+0xd4>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 d02045c:	e0800217 	ldw	r2,8(fp)
 d020460:	d8800015 	stw	r2,0(sp)
 d020464:	e13ffb17 	ldw	r4,-20(fp)
 d020468:	e17ffc17 	ldw	r5,-16(fp)
 d02046c:	e1bffd17 	ldw	r6,-12(fp)
 d020470:	e1fffe17 	ldw	r7,-8(fp)
 d020474:	d0295ac0 	call	d0295ac <t_setsockopt>
 d020478:	e0bfff15 	stw	r2,-4(fp)
 d02047c:	e0bfff17 	ldw	r2,-4(fp)
}
 d020480:	e037883a 	mov	sp,fp
 d020484:	dfc00117 	ldw	ra,4(sp)
 d020488:	df000017 	ldw	fp,0(sp)
 d02048c:	dec00204 	addi	sp,sp,8
 d020490:	f800283a 	ret

0d020494 <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 d020494:	defffa04 	addi	sp,sp,-24
 d020498:	df000515 	stw	fp,20(sp)
 d02049c:	df000504 	addi	fp,sp,20
 d0204a0:	e13ffe15 	stw	r4,-8(fp)
 d0204a4:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 d0204a8:	e0bffe17 	ldw	r2,-8(fp)
 d0204ac:	e0bffd15 	stw	r2,-12(fp)
   unsigned long sum = 0;
 d0204b0:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 d0204b4:	e0bfff17 	ldw	r2,-4(fp)
 d0204b8:	e0bffb15 	stw	r2,-20(fp)

   while (--count >= 0)
 d0204bc:	00000906 	br	d0204e4 <ccksum+0x50>
   {
      /*  This is the inner loop */
      sum += *addr++;
 d0204c0:	e0bffd17 	ldw	r2,-12(fp)
 d0204c4:	1080000b 	ldhu	r2,0(r2)
 d0204c8:	10ffffcc 	andi	r3,r2,65535
 d0204cc:	e0bffc17 	ldw	r2,-16(fp)
 d0204d0:	10c5883a 	add	r2,r2,r3
 d0204d4:	e0bffc15 	stw	r2,-16(fp)
 d0204d8:	e0bffd17 	ldw	r2,-12(fp)
 d0204dc:	10800084 	addi	r2,r2,2
 d0204e0:	e0bffd15 	stw	r2,-12(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 d0204e4:	e0bffb17 	ldw	r2,-20(fp)
 d0204e8:	10bfffc4 	addi	r2,r2,-1
 d0204ec:	e0bffb15 	stw	r2,-20(fp)
 d0204f0:	e0bffb17 	ldw	r2,-20(fp)
 d0204f4:	1004403a 	cmpge	r2,r2,zero
 d0204f8:	103ff11e 	bne	r2,zero,d0204c0 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 d0204fc:	e0bffc17 	ldw	r2,-16(fp)
 d020500:	10ffffcc 	andi	r3,r2,65535
 d020504:	e0bffc17 	ldw	r2,-16(fp)
 d020508:	1004d43a 	srli	r2,r2,16
 d02050c:	1885883a 	add	r2,r3,r2
 d020510:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 d020514:	e0bffc17 	ldw	r2,-16(fp)
 d020518:	10ffffcc 	andi	r3,r2,65535
 d02051c:	e0bffc17 	ldw	r2,-16(fp)
 d020520:	1004d43a 	srli	r2,r2,16
 d020524:	1885883a 	add	r2,r3,r2
 d020528:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 d02052c:	e0bffc17 	ldw	r2,-16(fp)
 d020530:	10bfffcc 	andi	r2,r2,65535
}
 d020534:	e037883a 	mov	sp,fp
 d020538:	df000017 	ldw	fp,0(sp)
 d02053c:	dec00104 	addi	sp,sp,4
 d020540:	f800283a 	ret

0d020544 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 d020544:	defffb04 	addi	sp,sp,-20
 d020548:	dfc00415 	stw	ra,16(sp)
 d02054c:	df000315 	stw	fp,12(sp)
 d020550:	df000304 	addi	fp,sp,12
 d020554:	e13ffd15 	stw	r4,-12(fp)
 d020558:	e17ffe15 	stw	r5,-8(fp)
   switch (cksum_select)
 d02055c:	d0a03017 	ldw	r2,-32576(gp)
 d020560:	108000a0 	cmpeqi	r2,r2,2
 d020564:	1000061e 	bne	r2,zero,d020580 <cksum+0x3c>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 d020568:	e13ffd17 	ldw	r4,-12(fp)
 d02056c:	e17ffe17 	ldw	r5,-8(fp)
 d020570:	d0204940 	call	d020494 <ccksum>
 d020574:	10bfffcc 	andi	r2,r2,65535
 d020578:	e0bfff15 	stw	r2,-4(fp)
 d02057c:	00000506 	br	d020594 <cksum+0x50>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 d020580:	e13ffd17 	ldw	r4,-12(fp)
 d020584:	e17ffe17 	ldw	r5,-8(fp)
 d020588:	d0258bc0 	call	d0258bc <asm_cksum>
 d02058c:	10bfffcc 	andi	r2,r2,65535
 d020590:	e0bfff15 	stw	r2,-4(fp)
 d020594:	e0bfff17 	ldw	r2,-4(fp)
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 d020598:	e037883a 	mov	sp,fp
 d02059c:	dfc00117 	ldw	ra,4(sp)
 d0205a0:	df000017 	ldw	fp,0(sp)
 d0205a4:	dec00204 	addi	sp,sp,8
 d0205a8:	f800283a 	ret

0d0205ac <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 d0205ac:	defffe04 	addi	sp,sp,-8
 d0205b0:	dfc00115 	stw	ra,4(sp)
 d0205b4:	df000015 	stw	fp,0(sp)
 d0205b8:	d839883a 	mov	fp,sp
   dtrap();
 d0205bc:	d025a500 	call	d025a50 <dtrap>
   return 0;
 d0205c0:	0005883a 	mov	r2,zero
}
 d0205c4:	e037883a 	mov	sp,fp
 d0205c8:	dfc00117 	ldw	ra,4(sp)
 d0205cc:	df000017 	ldw	fp,0(sp)
 d0205d0:	dec00204 	addi	sp,sp,8
 d0205d4:	f800283a 	ret

0d0205d8 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 d0205d8:	defffe04 	addi	sp,sp,-8
 d0205dc:	df000115 	stw	fp,4(sp)
 d0205e0:	df000104 	addi	fp,sp,4
 d0205e4:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 d0205e8:	00000306 	br	d0205f8 <nextarg+0x20>
 d0205ec:	e0bfff17 	ldw	r2,-4(fp)
 d0205f0:	10800044 	addi	r2,r2,1
 d0205f4:	e0bfff15 	stw	r2,-4(fp)
 d0205f8:	e0bfff17 	ldw	r2,-4(fp)
 d0205fc:	10800003 	ldbu	r2,0(r2)
 d020600:	10803fcc 	andi	r2,r2,255
 d020604:	1080201c 	xori	r2,r2,128
 d020608:	10bfe004 	addi	r2,r2,-128
 d02060c:	10800848 	cmpgei	r2,r2,33
 d020610:	103ff61e 	bne	r2,zero,d0205ec <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 d020614:	00000306 	br	d020624 <nextarg+0x4c>
 d020618:	e0bfff17 	ldw	r2,-4(fp)
 d02061c:	10800044 	addi	r2,r2,1
 d020620:	e0bfff15 	stw	r2,-4(fp)
 d020624:	e0bfff17 	ldw	r2,-4(fp)
 d020628:	10800003 	ldbu	r2,0(r2)
 d02062c:	10803fcc 	andi	r2,r2,255
 d020630:	1080201c 	xori	r2,r2,128
 d020634:	10bfe004 	addi	r2,r2,-128
 d020638:	10800820 	cmpeqi	r2,r2,32
 d02063c:	103ff61e 	bne	r2,zero,d020618 <nextarg+0x40>
      return (argp);
 d020640:	e0bfff17 	ldw	r2,-4(fp)
}
 d020644:	e037883a 	mov	sp,fp
 d020648:	df000017 	ldw	fp,0(sp)
 d02064c:	dec00104 	addi	sp,sp,4
 d020650:	f800283a 	ret

0d020654 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 d020654:	defff704 	addi	sp,sp,-36
 d020658:	dfc00815 	stw	ra,32(sp)
 d02065c:	df000715 	stw	fp,28(sp)
 d020660:	df000704 	addi	fp,sp,28
 d020664:	e13ffc15 	stw	r4,-16(fp)
 d020668:	e17ffd15 	stw	r5,-12(fp)
 d02066c:	e1bffe15 	stw	r6,-8(fp)
   u_char * data  =  (u_char *)buffer;
 d020670:	e0bffd17 	ldw	r2,-12(fp)
 d020674:	e0bffb15 	stw	r2,-20(fp)
   unsigned int count;
   char  c;

   while (len)
 d020678:	00004006 	br	d02077c <hexdump+0x128>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d02067c:	e03ffa15 	stw	zero,-24(fp)
 d020680:	00000c06 	br	d0206b4 <hexdump+0x60>
         ns_printf(pio, "%02x ", *(data + count));
 d020684:	e0fffa17 	ldw	r3,-24(fp)
 d020688:	e0bffb17 	ldw	r2,-20(fp)
 d02068c:	1885883a 	add	r2,r3,r2
 d020690:	10800003 	ldbu	r2,0(r2)
 d020694:	11803fcc 	andi	r6,r2,255
 d020698:	e13ffc17 	ldw	r4,-16(fp)
 d02069c:	01434174 	movhi	r5,3333
 d0206a0:	297c8004 	addi	r5,r5,-3584
 d0206a4:	d020b640 	call	d020b64 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d0206a8:	e0bffa17 	ldw	r2,-24(fp)
 d0206ac:	10800044 	addi	r2,r2,1
 d0206b0:	e0bffa15 	stw	r2,-24(fp)
 d0206b4:	e0bffa17 	ldw	r2,-24(fp)
 d0206b8:	10800428 	cmpgeui	r2,r2,16
 d0206bc:	1000031e 	bne	r2,zero,d0206cc <hexdump+0x78>
 d0206c0:	e0fffa17 	ldw	r3,-24(fp)
 d0206c4:	e0bffe17 	ldw	r2,-8(fp)
 d0206c8:	18bfee36 	bltu	r3,r2,d020684 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d0206cc:	e03ffa15 	stw	zero,-24(fp)
 d0206d0:	00001806 	br	d020734 <hexdump+0xe0>
      {
         c = *(data + count);
 d0206d4:	e0fffa17 	ldw	r3,-24(fp)
 d0206d8:	e0bffb17 	ldw	r2,-20(fp)
 d0206dc:	1885883a 	add	r2,r3,r2
 d0206e0:	10800003 	ldbu	r2,0(r2)
 d0206e4:	e0bff905 	stb	r2,-28(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 d0206e8:	e0bff907 	ldb	r2,-28(fp)
 d0206ec:	10800810 	cmplti	r2,r2,32
 d0206f0:	1000061e 	bne	r2,zero,d02070c <hexdump+0xb8>
 d0206f4:	e0bff907 	ldb	r2,-28(fp)
 d0206f8:	10801fe0 	cmpeqi	r2,r2,127
 d0206fc:	1000031e 	bne	r2,zero,d02070c <hexdump+0xb8>
 d020700:	e0bff907 	ldb	r2,-28(fp)
 d020704:	e0bfff15 	stw	r2,-4(fp)
 d020708:	00000206 	br	d020714 <hexdump+0xc0>
 d02070c:	00800b84 	movi	r2,46
 d020710:	e0bfff15 	stw	r2,-4(fp)
 d020714:	e13ffc17 	ldw	r4,-16(fp)
 d020718:	01434174 	movhi	r5,3333
 d02071c:	297c8204 	addi	r5,r5,-3576
 d020720:	e1bfff17 	ldw	r6,-4(fp)
 d020724:	d020b640 	call	d020b64 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d020728:	e0bffa17 	ldw	r2,-24(fp)
 d02072c:	10800044 	addi	r2,r2,1
 d020730:	e0bffa15 	stw	r2,-24(fp)
 d020734:	e0bffa17 	ldw	r2,-24(fp)
 d020738:	10800428 	cmpgeui	r2,r2,16
 d02073c:	1000031e 	bne	r2,zero,d02074c <hexdump+0xf8>
 d020740:	e0fffa17 	ldw	r3,-24(fp)
 d020744:	e0bffe17 	ldw	r2,-8(fp)
 d020748:	18bfe236 	bltu	r3,r2,d0206d4 <hexdump+0x80>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 d02074c:	e13ffc17 	ldw	r4,-16(fp)
 d020750:	01434174 	movhi	r5,3333
 d020754:	297c8304 	addi	r5,r5,-3572
 d020758:	d020b640 	call	d020b64 <ns_printf>
      len -= count;
 d02075c:	e0fffe17 	ldw	r3,-8(fp)
 d020760:	e0bffa17 	ldw	r2,-24(fp)
 d020764:	1885c83a 	sub	r2,r3,r2
 d020768:	e0bffe15 	stw	r2,-8(fp)
      data += count;
 d02076c:	e0fffa17 	ldw	r3,-24(fp)
 d020770:	e0bffb17 	ldw	r2,-20(fp)
 d020774:	10c5883a 	add	r2,r2,r3
 d020778:	e0bffb15 	stw	r2,-20(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 d02077c:	e0bffe17 	ldw	r2,-8(fp)
 d020780:	1004c03a 	cmpne	r2,r2,zero
 d020784:	103fbd1e 	bne	r2,zero,d02067c <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 d020788:	e037883a 	mov	sp,fp
 d02078c:	dfc00117 	ldw	ra,4(sp)
 d020790:	df000017 	ldw	fp,0(sp)
 d020794:	dec00204 	addi	sp,sp,8
 d020798:	f800283a 	ret

0d02079c <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 d02079c:	defffa04 	addi	sp,sp,-24
 d0207a0:	dfc00515 	stw	ra,20(sp)
 d0207a4:	df000415 	stw	fp,16(sp)
 d0207a8:	df000404 	addi	fp,sp,16
 d0207ac:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 d0207b0:	e0bfff17 	ldw	r2,-4(fp)
 d0207b4:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
 d0207b8:	e0bffe03 	ldbu	r2,-8(fp)
 d0207bc:	11803fcc 	andi	r6,r2,255
 d0207c0:	e0bffe43 	ldbu	r2,-7(fp)
 d0207c4:	11c03fcc 	andi	r7,r2,255
 d0207c8:	e0bffe83 	ldbu	r2,-6(fp)
 d0207cc:	10c03fcc 	andi	r3,r2,255
 d0207d0:	e0bffec3 	ldbu	r2,-5(fp)
 d0207d4:	10803fcc 	andi	r2,r2,255
 d0207d8:	d8c00015 	stw	r3,0(sp)
 d0207dc:	d8800115 	stw	r2,4(sp)
 d0207e0:	010341b4 	movhi	r4,3334
 d0207e4:	21033b84 	addi	r4,r4,3310
 d0207e8:	01434174 	movhi	r5,3333
 d0207ec:	297c8404 	addi	r5,r5,-3568
 d0207f0:	d002c3c0 	call	d002c3c <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 d0207f4:	008341b4 	movhi	r2,3334
 d0207f8:	10833b84 	addi	r2,r2,3310
}
 d0207fc:	e037883a 	mov	sp,fp
 d020800:	dfc00117 	ldw	ra,4(sp)
 d020804:	df000017 	ldw	fp,0(sp)
 d020808:	dec00204 	addi	sp,sp,8
 d02080c:	f800283a 	ret

0d020810 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 d020810:	defff804 	addi	sp,sp,-32
 d020814:	dfc00715 	stw	ra,28(sp)
 d020818:	df000615 	stw	fp,24(sp)
 d02081c:	df000604 	addi	fp,sp,24
 d020820:	e13fff15 	stw	r4,-4(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 d020824:	e13fff17 	ldw	r4,-4(fp)
 d020828:	01401904 	movi	r5,100
 d02082c:	d00c90c0 	call	d00c90c <__udivsi3>
 d020830:	e0bfff15 	stw	r2,-4(fp)
   seconds = (unsigned)(timetick%60);
 d020834:	e13fff17 	ldw	r4,-4(fp)
 d020838:	01400f04 	movi	r5,60
 d02083c:	d00c9140 	call	d00c914 <__umodsi3>
 d020840:	e0bffe15 	stw	r2,-8(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 d020844:	e13fff17 	ldw	r4,-4(fp)
 d020848:	01400f04 	movi	r5,60
 d02084c:	d00c90c0 	call	d00c90c <__udivsi3>
 d020850:	e0bfff15 	stw	r2,-4(fp)
   minutes = (unsigned)(timetick%60);
 d020854:	e13fff17 	ldw	r4,-4(fp)
 d020858:	01400f04 	movi	r5,60
 d02085c:	d00c9140 	call	d00c914 <__umodsi3>
 d020860:	e0bffd15 	stw	r2,-12(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 d020864:	e13fff17 	ldw	r4,-4(fp)
 d020868:	01400f04 	movi	r5,60
 d02086c:	d00c90c0 	call	d00c90c <__udivsi3>
 d020870:	e0bfff15 	stw	r2,-4(fp)
   hours = (unsigned)(timetick%24);
 d020874:	e13fff17 	ldw	r4,-4(fp)
 d020878:	01400604 	movi	r5,24
 d02087c:	d00c9140 	call	d00c914 <__umodsi3>
 d020880:	e0bffc15 	stw	r2,-16(fp)
   timetick = timetick/24;    /* turn timetick into days */
 d020884:	e13fff17 	ldw	r4,-4(fp)
 d020888:	01400604 	movi	r5,24
 d02088c:	d00c90c0 	call	d00c90c <__udivsi3>
 d020890:	e0bfff15 	stw	r2,-4(fp)

   if (timetick)  /* Is there a whole number of days? */
 d020894:	e0bfff17 	ldw	r2,-4(fp)
 d020898:	1005003a 	cmpeq	r2,r2,zero
 d02089c:	10000c1e 	bne	r2,zero,d0208d0 <print_uptime+0xc0>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 d0208a0:	e0bffd17 	ldw	r2,-12(fp)
 d0208a4:	d8800015 	stw	r2,0(sp)
 d0208a8:	e0bffe17 	ldw	r2,-8(fp)
 d0208ac:	d8800115 	stw	r2,4(sp)
 d0208b0:	01034174 	movhi	r4,3333
 d0208b4:	211d1004 	addi	r4,r4,29760
 d0208b8:	01434174 	movhi	r5,3333
 d0208bc:	297c8704 	addi	r5,r5,-3556
 d0208c0:	e1bfff17 	ldw	r6,-4(fp)
 d0208c4:	e1fffc17 	ldw	r7,-16(fp)
 d0208c8:	d002c3c0 	call	d002c3c <sprintf>
 d0208cc:	00001406 	br	d020920 <print_uptime+0x110>
    timetick, hours, minutes, seconds);
   else if (hours)
 d0208d0:	e0bffc17 	ldw	r2,-16(fp)
 d0208d4:	1005003a 	cmpeq	r2,r2,zero
 d0208d8:	10000a1e 	bne	r2,zero,d020904 <print_uptime+0xf4>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 d0208dc:	e0bffe17 	ldw	r2,-8(fp)
 d0208e0:	d8800015 	stw	r2,0(sp)
 d0208e4:	01034174 	movhi	r4,3333
 d0208e8:	211d1004 	addi	r4,r4,29760
 d0208ec:	01434174 	movhi	r5,3333
 d0208f0:	297c8d04 	addi	r5,r5,-3532
 d0208f4:	e1bffc17 	ldw	r6,-16(fp)
 d0208f8:	e1fffd17 	ldw	r7,-12(fp)
 d0208fc:	d002c3c0 	call	d002c3c <sprintf>
 d020900:	00000706 	br	d020920 <print_uptime+0x110>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 d020904:	01034174 	movhi	r4,3333
 d020908:	211d1004 	addi	r4,r4,29760
 d02090c:	01434174 	movhi	r5,3333
 d020910:	297c9204 	addi	r5,r5,-3512
 d020914:	e1bffd17 	ldw	r6,-12(fp)
 d020918:	e1fffe17 	ldw	r7,-8(fp)
 d02091c:	d002c3c0 	call	d002c3c <sprintf>
   return tistring;
 d020920:	00834174 	movhi	r2,3333
 d020924:	109d1004 	addi	r2,r2,29760
}
 d020928:	e037883a 	mov	sp,fp
 d02092c:	dfc00117 	ldw	ra,4(sp)
 d020930:	df000017 	ldw	fp,0(sp)
 d020934:	dec00204 	addi	sp,sp,8
 d020938:	f800283a 	ret

0d02093c <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 d02093c:	defffd04 	addi	sp,sp,-12
 d020940:	dfc00215 	stw	ra,8(sp)
 d020944:	df000115 	stw	fp,4(sp)
 d020948:	df000104 	addi	fp,sp,4
 d02094c:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 d020950:	01034174 	movhi	r4,3333
 d020954:	213c9704 	addi	r4,r4,-3492
 d020958:	e17fff17 	ldw	r5,-4(fp)
 d02095c:	d0028a00 	call	d0028a0 <printf>
   dtrap();                   /* try to hook debugger */
 d020960:	d025a500 	call	d025a50 <dtrap>
   netexit(1);                /* try to clean up */
 d020964:	01000044 	movi	r4,1
 d020968:	d043a680 	call	d043a68 <netexit>
}
 d02096c:	e037883a 	mov	sp,fp
 d020970:	dfc00117 	ldw	ra,4(sp)
 d020974:	df000017 	ldw	fp,0(sp)
 d020978:	dec00204 	addi	sp,sp,8
 d02097c:	f800283a 	ret

0d020980 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 d020980:	defffb04 	addi	sp,sp,-20
 d020984:	df000415 	stw	fp,16(sp)
 d020988:	df000404 	addi	fp,sp,16
 d02098c:	e13ffe15 	stw	r4,-8(fp)
 d020990:	e17fff05 	stb	r5,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 d020994:	008341b4 	movhi	r2,3334
 d020998:	10833704 	addi	r2,r2,3292
 d02099c:	e0bffc15 	stw	r2,-16(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 d0209a0:	e03ffd15 	stw	zero,-12(fp)
 d0209a4:	00004406 	br	d020ab8 <print_eth+0x138>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 d0209a8:	e0bffe17 	ldw	r2,-8(fp)
 d0209ac:	10800003 	ldbu	r2,0(r2)
 d0209b0:	10803fcc 	andi	r2,r2,255
 d0209b4:	1080201c 	xori	r2,r2,128
 d0209b8:	10bfe004 	addi	r2,r2,-128
 d0209bc:	1005d13a 	srai	r2,r2,4
 d0209c0:	108003cc 	andi	r2,r2,15
 d0209c4:	10800c04 	addi	r2,r2,48
 d0209c8:	1007883a 	mov	r3,r2
 d0209cc:	e0bffc17 	ldw	r2,-16(fp)
 d0209d0:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 d0209d4:	e0bffc17 	ldw	r2,-16(fp)
 d0209d8:	10800003 	ldbu	r2,0(r2)
 d0209dc:	10803fcc 	andi	r2,r2,255
 d0209e0:	1080201c 	xori	r2,r2,128
 d0209e4:	10bfe004 	addi	r2,r2,-128
 d0209e8:	10800e90 	cmplti	r2,r2,58
 d0209ec:	1000061e 	bne	r2,zero,d020a08 <print_eth+0x88>
         (*out) += 7;
 d0209f0:	e0bffc17 	ldw	r2,-16(fp)
 d0209f4:	10800003 	ldbu	r2,0(r2)
 d0209f8:	108001c4 	addi	r2,r2,7
 d0209fc:	1007883a 	mov	r3,r2
 d020a00:	e0bffc17 	ldw	r2,-16(fp)
 d020a04:	10c00005 	stb	r3,0(r2)
      out++;
 d020a08:	e0bffc17 	ldw	r2,-16(fp)
 d020a0c:	10800044 	addi	r2,r2,1
 d020a10:	e0bffc15 	stw	r2,-16(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 d020a14:	e0bffe17 	ldw	r2,-8(fp)
 d020a18:	10800003 	ldbu	r2,0(r2)
 d020a1c:	108003cc 	andi	r2,r2,15
 d020a20:	10800c04 	addi	r2,r2,48
 d020a24:	1007883a 	mov	r3,r2
 d020a28:	e0bffc17 	ldw	r2,-16(fp)
 d020a2c:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 d020a30:	e0bffc17 	ldw	r2,-16(fp)
 d020a34:	10800003 	ldbu	r2,0(r2)
 d020a38:	10803fcc 	andi	r2,r2,255
 d020a3c:	1080201c 	xori	r2,r2,128
 d020a40:	10bfe004 	addi	r2,r2,-128
 d020a44:	10800e90 	cmplti	r2,r2,58
 d020a48:	1000061e 	bne	r2,zero,d020a64 <print_eth+0xe4>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 d020a4c:	e0bffc17 	ldw	r2,-16(fp)
 d020a50:	10800003 	ldbu	r2,0(r2)
 d020a54:	108001c4 	addi	r2,r2,7
 d020a58:	1007883a 	mov	r3,r2
 d020a5c:	e0bffc17 	ldw	r2,-16(fp)
 d020a60:	10c00005 	stb	r3,0(r2)
      out++;
 d020a64:	e0bffc17 	ldw	r2,-16(fp)
 d020a68:	10800044 	addi	r2,r2,1
 d020a6c:	e0bffc15 	stw	r2,-16(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 d020a70:	e0bfff07 	ldb	r2,-4(fp)
 d020a74:	1005003a 	cmpeq	r2,r2,zero
 d020a78:	1000091e 	bne	r2,zero,d020aa0 <print_eth+0x120>
 d020a7c:	e0bffd17 	ldw	r2,-12(fp)
 d020a80:	10800148 	cmpgei	r2,r2,5
 d020a84:	1000061e 	bne	r2,zero,d020aa0 <print_eth+0x120>
         *out++ = spacer;
 d020a88:	e0fffc17 	ldw	r3,-16(fp)
 d020a8c:	e0bfff03 	ldbu	r2,-4(fp)
 d020a90:	18800005 	stb	r2,0(r3)
 d020a94:	e0bffc17 	ldw	r2,-16(fp)
 d020a98:	10800044 	addi	r2,r2,1
 d020a9c:	e0bffc15 	stw	r2,-16(fp)
      addr++;
 d020aa0:	e0bffe17 	ldw	r2,-8(fp)
 d020aa4:	10800044 	addi	r2,r2,1
 d020aa8:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 d020aac:	e0bffd17 	ldw	r2,-12(fp)
 d020ab0:	10800044 	addi	r2,r2,1
 d020ab4:	e0bffd15 	stw	r2,-12(fp)
 d020ab8:	e0bffd17 	ldw	r2,-12(fp)
 d020abc:	10800190 	cmplti	r2,r2,6
 d020ac0:	103fb91e 	bne	r2,zero,d0209a8 <print_eth+0x28>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 d020ac4:	e0bffc17 	ldw	r2,-16(fp)
 d020ac8:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 d020acc:	008341b4 	movhi	r2,3334
 d020ad0:	10833704 	addi	r2,r2,3292
}
 d020ad4:	e037883a 	mov	sp,fp
 d020ad8:	df000017 	ldw	fp,0(sp)
 d020adc:	dec00104 	addi	sp,sp,4
 d020ae0:	f800283a 	ret

0d020ae4 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 d020ae4:	defffd04 	addi	sp,sp,-12
 d020ae8:	df000215 	stw	fp,8(sp)
 d020aec:	df000204 	addi	fp,sp,8
 d020af0:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 d020af4:	e0bfff17 	ldw	r2,-4(fp)
 d020af8:	e0bffe15 	stw	r2,-8(fp)
 d020afc:	00000d06 	br	d020b34 <uslash+0x50>
      if (*cp == '\\')
 d020b00:	e0bffe17 	ldw	r2,-8(fp)
 d020b04:	10800003 	ldbu	r2,0(r2)
 d020b08:	10803fcc 	andi	r2,r2,255
 d020b0c:	1080201c 	xori	r2,r2,128
 d020b10:	10bfe004 	addi	r2,r2,-128
 d020b14:	10801718 	cmpnei	r2,r2,92
 d020b18:	1000031e 	bne	r2,zero,d020b28 <uslash+0x44>
      *cp = '/';
 d020b1c:	e0fffe17 	ldw	r3,-8(fp)
 d020b20:	00800bc4 	movi	r2,47
 d020b24:	18800005 	stb	r2,0(r3)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 d020b28:	e0bffe17 	ldw	r2,-8(fp)
 d020b2c:	10800044 	addi	r2,r2,1
 d020b30:	e0bffe15 	stw	r2,-8(fp)
 d020b34:	e0bffe17 	ldw	r2,-8(fp)
 d020b38:	10800003 	ldbu	r2,0(r2)
 d020b3c:	10803fcc 	andi	r2,r2,255
 d020b40:	1080201c 	xori	r2,r2,128
 d020b44:	10bfe004 	addi	r2,r2,-128
 d020b48:	1004c03a 	cmpne	r2,r2,zero
 d020b4c:	103fec1e 	bne	r2,zero,d020b00 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 d020b50:	e0bfff17 	ldw	r2,-4(fp)
}
 d020b54:	e037883a 	mov	sp,fp
 d020b58:	df000017 	ldw	fp,0(sp)
 d020b5c:	dec00104 	addi	sp,sp,4
 d020b60:	f800283a 	ret

0d020b64 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 d020b64:	defff204 	addi	sp,sp,-56
 d020b68:	dfc00b15 	stw	ra,44(sp)
 d020b6c:	df000a15 	stw	fp,40(sp)
 d020b70:	dc400915 	stw	r17,36(sp)
 d020b74:	dc000815 	stw	r16,32(sp)
 d020b78:	df000804 	addi	fp,sp,32
 d020b7c:	e13ffd15 	stw	r4,-12(fp)
 d020b80:	e1800415 	stw	r6,16(fp)
 d020b84:	e1c00515 	stw	r7,20(fp)
 d020b88:	e17ffe15 	stw	r5,-8(fp)
   char *   outbuf=NULL;
 d020b8c:	e03ffb15 	stw	zero,-20(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 d020b90:	00802704 	movi	r2,156
 d020b94:	e0bff915 	stw	r2,-28(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 d020b98:	e0bffd17 	ldw	r2,-12(fp)
 d020b9c:	e0bff815 	stw	r2,-32(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 d020ba0:	e0bff817 	ldw	r2,-32(fp)
 d020ba4:	1004c03a 	cmpne	r2,r2,zero
 d020ba8:	1000091e 	bne	r2,zero,d020bd0 <ns_printf+0x6c>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 d020bac:	e0800404 	addi	r2,fp,16
 d020bb0:	e0bffc15 	stw	r2,-16(fp)
      ret_value = vprintf(format,argList);
 d020bb4:	e17ffc17 	ldw	r5,-16(fp)
 d020bb8:	e13ffe17 	ldw	r4,-8(fp)
 d020bbc:	d04c3780 	call	d04c378 <vprintf>
 d020bc0:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 d020bc4:	e0bffa17 	ldw	r2,-24(fp)
 d020bc8:	e0bfff15 	stw	r2,-4(fp)
 d020bcc:	00003e06 	br	d020cc8 <ns_printf+0x164>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 d020bd0:	e0bff817 	ldw	r2,-32(fp)
 d020bd4:	10800117 	ldw	r2,4(r2)
 d020bd8:	1004c03a 	cmpne	r2,r2,zero
 d020bdc:	1000031e 	bne	r2,zero,d020bec <ns_printf+0x88>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 d020be0:	00bfffc4 	movi	r2,-1
 d020be4:	e0bfff15 	stw	r2,-4(fp)
 d020be8:	00003706 	br	d020cc8 <ns_printf+0x164>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 d020bec:	e13ffe17 	ldw	r4,-8(fp)
 d020bf0:	d0034640 	call	d003464 <strlen>
 d020bf4:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 d020bf8:	e0bffa17 	ldw	r2,-24(fp)
 d020bfc:	10802710 	cmplti	r2,r2,156
 d020c00:	1000041e 	bne	r2,zero,d020c14 <ns_printf+0xb0>
   {
      buf_size += ret_value ;
 d020c04:	e0bff917 	ldw	r2,-28(fp)
 d020c08:	e0fffa17 	ldw	r3,-24(fp)
 d020c0c:	10c5883a 	add	r2,r2,r3
 d020c10:	e0bff915 	stw	r2,-28(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 d020c14:	e13ff917 	ldw	r4,-28(fp)
 d020c18:	d0264b80 	call	d0264b8 <npalloc>
 d020c1c:	e0bffb15 	stw	r2,-20(fp)

   if (outbuf == NULL)
 d020c20:	e0bffb17 	ldw	r2,-20(fp)
 d020c24:	1004c03a 	cmpne	r2,r2,zero
 d020c28:	1000031e 	bne	r2,zero,d020c38 <ns_printf+0xd4>
   {
      return -2;
 d020c2c:	00bfff84 	movi	r2,-2
 d020c30:	e0bfff15 	stw	r2,-4(fp)
 d020c34:	00002406 	br	d020cc8 <ns_printf+0x164>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 d020c38:	e0800404 	addi	r2,fp,16
 d020c3c:	e0bffc15 	stw	r2,-16(fp)
   ret_value = vsprintf(outbuf,format,argList);
 d020c40:	e1bffc17 	ldw	r6,-16(fp)
 d020c44:	e13ffb17 	ldw	r4,-20(fp)
 d020c48:	e17ffe17 	ldw	r5,-8(fp)
 d020c4c:	d04c3e80 	call	d04c3e8 <vsprintf>
 d020c50:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 d020c54:	e13ffb17 	ldw	r4,-20(fp)
 d020c58:	d0034640 	call	d003464 <strlen>
 d020c5c:	1007883a 	mov	r3,r2
 d020c60:	e0bff917 	ldw	r2,-28(fp)
 d020c64:	10c0080e 	bge	r2,r3,d020c88 <ns_printf+0x124>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 d020c68:	01034174 	movhi	r4,3333
 d020c6c:	213c9a04 	addi	r4,r4,-3480
 d020c70:	d02093c0 	call	d02093c <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 d020c74:	e0fff917 	ldw	r3,-28(fp)
 d020c78:	e0bffb17 	ldw	r2,-20(fp)
 d020c7c:	1885883a 	add	r2,r3,r2
 d020c80:	10bfffc4 	addi	r2,r2,-1
 d020c84:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 d020c88:	e0bff817 	ldw	r2,-32(fp)
 d020c8c:	14400117 	ldw	r17,4(r2)
 d020c90:	e0bff817 	ldw	r2,-32(fp)
 d020c94:	14000217 	ldw	r16,8(r2)
 d020c98:	e13ffb17 	ldw	r4,-20(fp)
 d020c9c:	d0034640 	call	d003464 <strlen>
 d020ca0:	100d883a 	mov	r6,r2
 d020ca4:	8009883a 	mov	r4,r16
 d020ca8:	e17ffb17 	ldw	r5,-20(fp)
 d020cac:	883ee83a 	callr	r17
 d020cb0:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 d020cb4:	e13ffb17 	ldw	r4,-20(fp)
 d020cb8:	d0265ac0 	call	d0265ac <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 d020cbc:	d0216100 	call	d021610 <tk_yield>

   return ret_value ;
 d020cc0:	e0bffa17 	ldw	r2,-24(fp)
 d020cc4:	e0bfff15 	stw	r2,-4(fp)
 d020cc8:	e0bfff17 	ldw	r2,-4(fp)
}
 d020ccc:	e037883a 	mov	sp,fp
 d020cd0:	dfc00317 	ldw	ra,12(sp)
 d020cd4:	df000217 	ldw	fp,8(sp)
 d020cd8:	dc400117 	ldw	r17,4(sp)
 d020cdc:	dc000017 	ldw	r16,0(sp)
 d020ce0:	dec00604 	addi	sp,sp,24
 d020ce4:	f800283a 	ret

0d020ce8 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 d020ce8:	defffb04 	addi	sp,sp,-20
 d020cec:	dfc00415 	stw	ra,16(sp)
 d020cf0:	df000315 	stw	fp,12(sp)
 d020cf4:	df000304 	addi	fp,sp,12
 d020cf8:	e13ffd15 	stw	r4,-12(fp)
 d020cfc:	e17ffe15 	stw	r5,-8(fp)
 d020d00:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 d020d04:	01034174 	movhi	r4,3333
 d020d08:	213ca104 	addi	r4,r4,-3452
 d020d0c:	e17ffe17 	ldw	r5,-8(fp)
 d020d10:	d0028a00 	call	d0028a0 <printf>
   USE_ARG(s);
   return len;
 d020d14:	e0bfff17 	ldw	r2,-4(fp)
}
 d020d18:	e037883a 	mov	sp,fp
 d020d1c:	dfc00117 	ldw	ra,4(sp)
 d020d20:	df000017 	ldw	fp,0(sp)
 d020d24:	dec00204 	addi	sp,sp,8
 d020d28:	f800283a 	ret

0d020d2c <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 d020d2c:	defff904 	addi	sp,sp,-28
 d020d30:	dfc00615 	stw	ra,24(sp)
 d020d34:	df000515 	stw	fp,20(sp)
 d020d38:	df000504 	addi	fp,sp,20
 d020d3c:	e13ffd15 	stw	r4,-12(fp)
 d020d40:	e17ffe15 	stw	r5,-8(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 d020d44:	e0bffd17 	ldw	r2,-12(fp)
 d020d48:	e0bffb15 	stw	r2,-20(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 d020d4c:	e13ffe17 	ldw	r4,-8(fp)
 d020d50:	01400504 	movi	r5,20
 d020d54:	d00c8ac0 	call	d00c8ac <__modsi3>
 d020d58:	1004c03a 	cmpne	r2,r2,zero
 d020d5c:	1000281e 	bne	r2,zero,d020e00 <con_page+0xd4>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 d020d60:	e0bffb17 	ldw	r2,-20(fp)
 d020d64:	1005003a 	cmpeq	r2,r2,zero
 d020d68:	1000251e 	bne	r2,zero,d020e00 <con_page+0xd4>
 d020d6c:	e0bffb17 	ldw	r2,-20(fp)
 d020d70:	10800317 	ldw	r2,12(r2)
 d020d74:	1005003a 	cmpeq	r2,r2,zero
 d020d78:	1000211e 	bne	r2,zero,d020e00 <con_page+0xd4>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 d020d7c:	e13ffb17 	ldw	r4,-20(fp)
 d020d80:	01434174 	movhi	r5,3333
 d020d84:	297ca204 	addi	r5,r5,-3448
 d020d88:	d020b640 	call	d020b64 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 d020d8c:	e0bffb17 	ldw	r2,-20(fp)
 d020d90:	10c00317 	ldw	r3,12(r2)
 d020d94:	e0bffb17 	ldw	r2,-20(fp)
 d020d98:	11000217 	ldw	r4,8(r2)
 d020d9c:	183ee83a 	callr	r3
 d020da0:	e0bffc15 	stw	r2,-16(fp)
            if (ch == 0)
 d020da4:	e0bffc17 	ldw	r2,-16(fp)
 d020da8:	1004c03a 	cmpne	r2,r2,zero
 d020dac:	1000011e 	bne	r2,zero,d020db4 <con_page+0x88>
               tk_yield();    /* Give timeslice to other processes */
 d020db0:	d0216100 	call	d021610 <tk_yield>
         } while (ch == 0) ;
 d020db4:	e0bffc17 	ldw	r2,-16(fp)
 d020db8:	1005003a 	cmpeq	r2,r2,zero
 d020dbc:	103ff31e 	bne	r2,zero,d020d8c <con_page+0x60>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 d020dc0:	e0bffc17 	ldw	r2,-16(fp)
 d020dc4:	10bfffd8 	cmpnei	r2,r2,-1
 d020dc8:	1000031e 	bne	r2,zero,d020dd8 <con_page+0xac>
            return 1 ;
 d020dcc:	00800044 	movi	r2,1
 d020dd0:	e0bfff15 	stw	r2,-4(fp)
 d020dd4:	00000b06 	br	d020e04 <con_page+0xd8>

         ns_printf(pio,"\n");
 d020dd8:	e13ffb17 	ldw	r4,-20(fp)
 d020ddc:	01434174 	movhi	r5,3333
 d020de0:	297c8304 	addi	r5,r5,-3572
 d020de4:	d020b640 	call	d020b64 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 d020de8:	e0bffc17 	ldw	r2,-16(fp)
 d020dec:	108006d8 	cmpnei	r2,r2,27
 d020df0:	1000031e 	bne	r2,zero,d020e00 <con_page+0xd4>
            return 1 ;
 d020df4:	00800044 	movi	r2,1
 d020df8:	e0bfff15 	stw	r2,-4(fp)
 d020dfc:	00000106 	br	d020e04 <con_page+0xd8>
      }
   }
   return  0;
 d020e00:	e03fff15 	stw	zero,-4(fp)
 d020e04:	e0bfff17 	ldw	r2,-4(fp)
}
 d020e08:	e037883a 	mov	sp,fp
 d020e0c:	dfc00117 	ldw	ra,4(sp)
 d020e10:	df000017 	ldw	fp,0(sp)
 d020e14:	dec00204 	addi	sp,sp,8
 d020e18:	f800283a 	ret

0d020e1c <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 d020e1c:	defff604 	addi	sp,sp,-40
 d020e20:	dfc00915 	stw	ra,36(sp)
 d020e24:	df000815 	stw	fp,32(sp)
 d020e28:	df000804 	addi	fp,sp,32
 d020e2c:	e13ffc15 	stw	r4,-16(fp)
 d020e30:	e17ffd15 	stw	r5,-12(fp)
 d020e34:	e1bffe15 	stw	r6,-8(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 d020e38:	e0bffc17 	ldw	r2,-16(fp)
 d020e3c:	e0bff915 	stw	r2,-28(fp)
   char **pargv = NULL;
 d020e40:	e03ff815 	stw	zero,-32(fp)
   *pargc_index = 0;
 d020e44:	e0bffe17 	ldw	r2,-8(fp)
 d020e48:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 d020e4c:	e0bffc17 	ldw	r2,-16(fp)
 d020e50:	1004c03a 	cmpne	r2,r2,zero
 d020e54:	1000021e 	bne	r2,zero,d020e60 <parse_args+0x44>
   {
      return (NULL);
 d020e58:	e03fff15 	stw	zero,-4(fp)
 d020e5c:	00007406 	br	d021030 <parse_args+0x214>
   }
   len = strlen(buf);
 d020e60:	e13ffc17 	ldw	r4,-16(fp)
 d020e64:	d0034640 	call	d003464 <strlen>
 d020e68:	e0bffa15 	stw	r2,-24(fp)
   if (len <= 0)
 d020e6c:	e0bffa17 	ldw	r2,-24(fp)
 d020e70:	10800048 	cmpgei	r2,r2,1
 d020e74:	1000021e 	bne	r2,zero,d020e80 <parse_args+0x64>
   {
      return (NULL);
 d020e78:	e03fff15 	stw	zero,-4(fp)
 d020e7c:	00006c06 	br	d021030 <parse_args+0x214>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 d020e80:	e0bffd17 	ldw	r2,-12(fp)
 d020e84:	1085883a 	add	r2,r2,r2
 d020e88:	1085883a 	add	r2,r2,r2
 d020e8c:	1009883a 	mov	r4,r2
 d020e90:	d0264b80 	call	d0264b8 <npalloc>
 d020e94:	e0bff815 	stw	r2,-32(fp)
   if (pargv == NULL)
 d020e98:	e0bff817 	ldw	r2,-32(fp)
 d020e9c:	1004c03a 	cmpne	r2,r2,zero
 d020ea0:	1000051e 	bne	r2,zero,d020eb8 <parse_args+0x9c>
   {
      return (NULL);
 d020ea4:	e03fff15 	stw	zero,-4(fp)
 d020ea8:	00006106 	br	d021030 <parse_args+0x214>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 d020eac:	e0bff917 	ldw	r2,-28(fp)
 d020eb0:	10800044 	addi	r2,r2,1
 d020eb4:	e0bff915 	stw	r2,-28(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 d020eb8:	e0bff917 	ldw	r2,-28(fp)
 d020ebc:	10800003 	ldbu	r2,0(r2)
 d020ec0:	10803fcc 	andi	r2,r2,255
 d020ec4:	1080201c 	xori	r2,r2,128
 d020ec8:	10bfe004 	addi	r2,r2,-128
 d020ecc:	10800820 	cmpeqi	r2,r2,32
 d020ed0:	103ff61e 	bne	r2,zero,d020eac <parse_args+0x90>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 d020ed4:	00003206 	br	d020fa0 <parse_args+0x184>
   {
      pargv[(*pargc_index)] = bp;
 d020ed8:	e0bffe17 	ldw	r2,-8(fp)
 d020edc:	10800017 	ldw	r2,0(r2)
 d020ee0:	1085883a 	add	r2,r2,r2
 d020ee4:	1085883a 	add	r2,r2,r2
 d020ee8:	1007883a 	mov	r3,r2
 d020eec:	e0bff817 	ldw	r2,-32(fp)
 d020ef0:	1887883a 	add	r3,r3,r2
 d020ef4:	e0bff917 	ldw	r2,-28(fp)
 d020ef8:	18800015 	stw	r2,0(r3)
      (*pargc_index)++;
 d020efc:	e0bffe17 	ldw	r2,-8(fp)
 d020f00:	10800017 	ldw	r2,0(r2)
 d020f04:	10c00044 	addi	r3,r2,1
 d020f08:	e0bffe17 	ldw	r2,-8(fp)
 d020f0c:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 d020f10:	00000306 	br	d020f20 <parse_args+0x104>
      {
         bp++; 
 d020f14:	e0bff917 	ldw	r2,-28(fp)
 d020f18:	10800044 	addi	r2,r2,1
 d020f1c:	e0bff915 	stw	r2,-28(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 d020f20:	e0bff917 	ldw	r2,-28(fp)
 d020f24:	10800003 	ldbu	r2,0(r2)
 d020f28:	10803fcc 	andi	r2,r2,255
 d020f2c:	1080201c 	xori	r2,r2,128
 d020f30:	10bfe004 	addi	r2,r2,-128
 d020f34:	10800820 	cmpeqi	r2,r2,32
 d020f38:	10000b1e 	bne	r2,zero,d020f68 <parse_args+0x14c>
 d020f3c:	e0bff917 	ldw	r2,-28(fp)
 d020f40:	10800003 	ldbu	r2,0(r2)
 d020f44:	10803fcc 	andi	r2,r2,255
 d020f48:	1080201c 	xori	r2,r2,128
 d020f4c:	10bfe004 	addi	r2,r2,-128
 d020f50:	1004c03a 	cmpne	r2,r2,zero
 d020f54:	103fef1e 	bne	r2,zero,d020f14 <parse_args+0xf8>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 d020f58:	00000306 	br	d020f68 <parse_args+0x14c>
      {
         bp++; 
 d020f5c:	e0bff917 	ldw	r2,-28(fp)
 d020f60:	10800044 	addi	r2,r2,1
 d020f64:	e0bff915 	stw	r2,-28(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 d020f68:	e0bff917 	ldw	r2,-28(fp)
 d020f6c:	10800003 	ldbu	r2,0(r2)
 d020f70:	10803fcc 	andi	r2,r2,255
 d020f74:	1080201c 	xori	r2,r2,128
 d020f78:	10bfe004 	addi	r2,r2,-128
 d020f7c:	10800818 	cmpnei	r2,r2,32
 d020f80:	1000071e 	bne	r2,zero,d020fa0 <parse_args+0x184>
 d020f84:	e0bff917 	ldw	r2,-28(fp)
 d020f88:	10800003 	ldbu	r2,0(r2)
 d020f8c:	10803fcc 	andi	r2,r2,255
 d020f90:	1080201c 	xori	r2,r2,128
 d020f94:	10bfe004 	addi	r2,r2,-128
 d020f98:	1004c03a 	cmpne	r2,r2,zero
 d020f9c:	103fef1e 	bne	r2,zero,d020f5c <parse_args+0x140>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 d020fa0:	e0bff917 	ldw	r2,-28(fp)
 d020fa4:	10800003 	ldbu	r2,0(r2)
 d020fa8:	10803fcc 	andi	r2,r2,255
 d020fac:	1080201c 	xori	r2,r2,128
 d020fb0:	10bfe004 	addi	r2,r2,-128
 d020fb4:	1005003a 	cmpeq	r2,r2,zero
 d020fb8:	1000041e 	bne	r2,zero,d020fcc <parse_args+0x1b0>
 d020fbc:	e0bffe17 	ldw	r2,-8(fp)
 d020fc0:	10c00017 	ldw	r3,0(r2)
 d020fc4:	e0bffd17 	ldw	r2,-12(fp)
 d020fc8:	18bfc316 	blt	r3,r2,d020ed8 <parse_args+0xbc>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 d020fcc:	e03ffb15 	stw	zero,-20(fp)
 d020fd0:	00001206 	br	d02101c <parse_args+0x200>
   {
      if (buf[i] == ' ')
 d020fd4:	e0bffb17 	ldw	r2,-20(fp)
 d020fd8:	1007883a 	mov	r3,r2
 d020fdc:	e0bffc17 	ldw	r2,-16(fp)
 d020fe0:	1885883a 	add	r2,r3,r2
 d020fe4:	10800003 	ldbu	r2,0(r2)
 d020fe8:	10803fcc 	andi	r2,r2,255
 d020fec:	1080201c 	xori	r2,r2,128
 d020ff0:	10bfe004 	addi	r2,r2,-128
 d020ff4:	10800818 	cmpnei	r2,r2,32
 d020ff8:	1000051e 	bne	r2,zero,d021010 <parse_args+0x1f4>
         buf[i] = '\0';
 d020ffc:	e0bffb17 	ldw	r2,-20(fp)
 d021000:	1007883a 	mov	r3,r2
 d021004:	e0bffc17 	ldw	r2,-16(fp)
 d021008:	1885883a 	add	r2,r3,r2
 d02100c:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 d021010:	e0bffb17 	ldw	r2,-20(fp)
 d021014:	10800044 	addi	r2,r2,1
 d021018:	e0bffb15 	stw	r2,-20(fp)
 d02101c:	e0fffb17 	ldw	r3,-20(fp)
 d021020:	e0bffa17 	ldw	r2,-24(fp)
 d021024:	18bfeb16 	blt	r3,r2,d020fd4 <parse_args+0x1b8>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 d021028:	e0bff817 	ldw	r2,-32(fp)
 d02102c:	e0bfff15 	stw	r2,-4(fp)
 d021030:	e0bfff17 	ldw	r2,-4(fp)
}
 d021034:	e037883a 	mov	sp,fp
 d021038:	dfc00117 	ldw	ra,4(sp)
 d02103c:	df000017 	ldw	fp,0(sp)
 d021040:	dec00204 	addi	sp,sp,8
 d021044:	f800283a 	ret

0d021048 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 d021048:	defffb04 	addi	sp,sp,-20
 d02104c:	dfc00415 	stw	ra,16(sp)
 d021050:	df000315 	stw	fp,12(sp)
 d021054:	df000304 	addi	fp,sp,12
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 d021058:	d0290a15 	stw	zero,-23512(gp)

   e = prep_modules();
 d02105c:	d03ca500 	call	d03ca50 <prep_modules>
 d021060:	e0bffd15 	stw	r2,-12(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 d021064:	e03ffe15 	stw	zero,-8(fp)
 d021068:	00001e06 	br	d0210e4 <netmain+0x9c>
   {
      e = TK_NEWTASK(&nettasks[i]);
 d02106c:	e13ffe17 	ldw	r4,-8(fp)
 d021070:	01400604 	movi	r5,24
 d021074:	d00235c0 	call	d00235c <__mulsi3>
 d021078:	1007883a 	mov	r3,r2
 d02107c:	00834174 	movhi	r2,3333
 d021080:	10912d04 	addi	r2,r2,17588
 d021084:	1889883a 	add	r4,r3,r2
 d021088:	d025e380 	call	d025e38 <TK_NEWTASK>
 d02108c:	e0bffd15 	stw	r2,-12(fp)
      if (e != 0)
 d021090:	e0bffd17 	ldw	r2,-12(fp)
 d021094:	1005003a 	cmpeq	r2,r2,zero
 d021098:	10000f1e 	bne	r2,zero,d0210d8 <netmain+0x90>
      {
         dprintf("task create error\n");
 d02109c:	01034174 	movhi	r4,3333
 d0210a0:	213cb404 	addi	r4,r4,-3376
 d0210a4:	d002bc80 	call	d002bc8 <puts>
         panic((char *)&nettasks[i].name);
 d0210a8:	e13ffe17 	ldw	r4,-8(fp)
 d0210ac:	01400604 	movi	r5,24
 d0210b0:	d00235c0 	call	d00235c <__mulsi3>
 d0210b4:	10c00104 	addi	r3,r2,4
 d0210b8:	00834174 	movhi	r2,3333
 d0210bc:	10912d04 	addi	r2,r2,17588
 d0210c0:	1885883a 	add	r2,r3,r2
 d0210c4:	1009883a 	mov	r4,r2
 d0210c8:	d02093c0 	call	d02093c <panic>
         return -1;  /* compiler warnings */
 d0210cc:	00bfffc4 	movi	r2,-1
 d0210d0:	e0bfff15 	stw	r2,-4(fp)
 d0210d4:	00001506 	br	d02112c <netmain+0xe4>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 d0210d8:	e0bffe17 	ldw	r2,-8(fp)
 d0210dc:	10800044 	addi	r2,r2,1
 d0210e0:	e0bffe15 	stw	r2,-8(fp)
 d0210e4:	d0e03117 	ldw	r3,-32572(gp)
 d0210e8:	e0bffe17 	ldw	r2,-8(fp)
 d0210ec:	10ffdf16 	blt	r2,r3,d02106c <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 d0210f0:	d03cfb80 	call	d03cfb8 <create_apptasks>
 d0210f4:	e0bffd15 	stw	r2,-12(fp)
   if (e != 0) 
 d0210f8:	e0bffd17 	ldw	r2,-12(fp)
 d0210fc:	1005003a 	cmpeq	r2,r2,zero
 d021100:	1000091e 	bne	r2,zero,d021128 <netmain+0xe0>
   {
      dprintf("task create error\n");
 d021104:	01034174 	movhi	r4,3333
 d021108:	213cb404 	addi	r4,r4,-3376
 d02110c:	d002bc80 	call	d002bc8 <puts>
      panic("netmain");
 d021110:	01034174 	movhi	r4,3333
 d021114:	213cb904 	addi	r4,r4,-3356
 d021118:	d02093c0 	call	d02093c <panic>
      return -1;  /* compiler warnings */
 d02111c:	00bfffc4 	movi	r2,-1
 d021120:	e0bfff15 	stw	r2,-4(fp)
 d021124:	00000106 	br	d02112c <netmain+0xe4>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 d021128:	e03fff15 	stw	zero,-4(fp)
 d02112c:	e0bfff17 	ldw	r2,-4(fp)
#endif
#endif   /* NO_INET_STACK */
}
 d021130:	e037883a 	mov	sp,fp
 d021134:	dfc00117 	ldw	ra,4(sp)
 d021138:	df000017 	ldw	fp,0(sp)
 d02113c:	dec00204 	addi	sp,sp,8
 d021140:	f800283a 	ret

0d021144 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 d021144:	defffc04 	addi	sp,sp,-16
 d021148:	dfc00315 	stw	ra,12(sp)
 d02114c:	df000215 	stw	fp,8(sp)
 d021150:	df000204 	addi	fp,sp,8
 d021154:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 d021158:	d03c6bc0 	call	d03c6bc <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 d02115c:	00800044 	movi	r2,1
 d021160:	d0a90a15 	stw	r2,-23512(gp)
 d021164:	00000006 	br	d021168 <tk_netmain+0x24>

   for (;;)
   {
      TK_NETRX_BLOCK();
 d021168:	00834174 	movhi	r2,3333
 d02116c:	109b4804 	addi	r2,r2,27936
 d021170:	11000017 	ldw	r4,0(r2)
 d021174:	01401904 	movi	r5,100
 d021178:	e1bffe04 	addi	r6,fp,-8
 d02117c:	d0135480 	call	d013548 <OSSemPend>
 d021180:	e0bffe03 	ldbu	r2,-8(fp)
 d021184:	10803fcc 	andi	r2,r2,255
 d021188:	1005003a 	cmpeq	r2,r2,zero
 d02118c:	1000051e 	bne	r2,zero,d0211a4 <tk_netmain+0x60>
 d021190:	e0bffe03 	ldbu	r2,-8(fp)
 d021194:	10803fcc 	andi	r2,r2,255
 d021198:	108002a0 	cmpeqi	r2,r2,10
 d02119c:	1000011e 	bne	r2,zero,d0211a4 <tk_netmain+0x60>
 d0211a0:	d025a500 	call	d025a50 <dtrap>
      netmain_wakes++;  /* count wakeups */
 d0211a4:	d0a90817 	ldw	r2,-23520(gp)
 d0211a8:	10800044 	addi	r2,r2,1
 d0211ac:	d0a90815 	stw	r2,-23520(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 d0211b0:	008341b4 	movhi	r2,3334
 d0211b4:	10825504 	addi	r2,r2,2388
 d0211b8:	10800217 	ldw	r2,8(r2)
 d0211bc:	1005003a 	cmpeq	r2,r2,zero
 d0211c0:	103fe91e 	bne	r2,zero,d021168 <tk_netmain+0x24>
         pktdemux();
 d0211c4:	d01de180 	call	d01de18 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 d0211c8:	003fe706 	br	d021168 <tk_netmain+0x24>

0d0211cc <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 d0211cc:	defffd04 	addi	sp,sp,-12
 d0211d0:	dfc00215 	stw	ra,8(sp)
 d0211d4:	df000115 	stw	fp,4(sp)
 d0211d8:	df000104 	addi	fp,sp,4
 d0211dc:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 d0211e0:	00000306 	br	d0211f0 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 d0211e4:	d023f980 	call	d023f98 <dhc_second>
#endif
      TK_SLEEP(1);
 d0211e8:	01000084 	movi	r4,2
 d0211ec:	d0156dc0 	call	d0156dc <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 d0211f0:	d0a90a17 	ldw	r2,-23512(gp)
 d0211f4:	1005003a 	cmpeq	r2,r2,zero
 d0211f8:	103ffa1e 	bne	r2,zero,d0211e4 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 d0211fc:	01000084 	movi	r4,2
 d021200:	d0156dc0 	call	d0156dc <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 d021204:	d0a90917 	ldw	r2,-23516(gp)
 d021208:	10800044 	addi	r2,r2,1
 d02120c:	d0a90915 	stw	r2,-23516(gp)
      inet_timer();  /* let various timeouts occur */
 d021210:	d03caa80 	call	d03caa8 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 d021214:	003ff906 	br	d0211fc <tk_nettick+0x30>

0d021218 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 d021218:	defffe04 	addi	sp,sp,-8
 d02121c:	dfc00115 	stw	ra,4(sp)
 d021220:	df000015 	stw	fp,0(sp)
 d021224:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 d021228:	01000084 	movi	r4,2
 d02122c:	d0156dc0 	call	d0156dc <OSTimeDly>
}
 d021230:	e037883a 	mov	sp,fp
 d021234:	dfc00117 	ldw	ra,4(sp)
 d021238:	df000017 	ldw	fp,0(sp)
 d02123c:	dec00204 	addi	sp,sp,8
 d021240:	f800283a 	ret

0d021244 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 d021244:	defffc04 	addi	sp,sp,-16
 d021248:	dfc00315 	stw	ra,12(sp)
 d02124c:	df000215 	stw	fp,8(sp)
 d021250:	df000204 	addi	fp,sp,8
 d021254:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 d021258:	e0bfff17 	ldw	r2,-4(fp)
 d02125c:	10800003 	ldbu	r2,0(r2)
 d021260:	11003fcc 	andi	r4,r2,255
 d021264:	d014edc0 	call	d014edc <OSTaskResume>
 d021268:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 d02126c:	e0bffe03 	ldbu	r2,-8(fp)
 d021270:	1005003a 	cmpeq	r2,r2,zero
 d021274:	10000a1e 	bne	r2,zero,d0212a0 <TK_OSTaskResume+0x5c>
 d021278:	e0bffe03 	ldbu	r2,-8(fp)
 d02127c:	10801120 	cmpeqi	r2,r2,68
 d021280:	1000071e 	bne	r2,zero,d0212a0 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 d021284:	01034174 	movhi	r4,3333
 d021288:	213cbb04 	addi	r4,r4,-3348
 d02128c:	d002bc80 	call	d002bc8 <puts>
      dtrap();
 d021290:	d025a500 	call	d025a50 <dtrap>
      panic("TK_OSTaskResume");      
 d021294:	01034174 	movhi	r4,3333
 d021298:	213cc804 	addi	r4,r4,-3296
 d02129c:	d02093c0 	call	d02093c <panic>
   }
#endif
}
 d0212a0:	e037883a 	mov	sp,fp
 d0212a4:	dfc00117 	ldw	ra,4(sp)
 d0212a8:	df000017 	ldw	fp,0(sp)
 d0212ac:	dec00204 	addi	sp,sp,8
 d0212b0:	f800283a 	ret

0d0212b4 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 d0212b4:	defff904 	addi	sp,sp,-28
 d0212b8:	dfc00615 	stw	ra,24(sp)
 d0212bc:	df000515 	stw	fp,20(sp)
 d0212c0:	dc400415 	stw	r17,16(sp)
 d0212c4:	dc000315 	stw	r16,12(sp)
 d0212c8:	df000304 	addi	fp,sp,12
 d0212cc:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d0212d0:	e03ffd15 	stw	zero,-12(fp)
 d0212d4:	00005606 	br	d021430 <tcp_sleep+0x17c>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 d0212d8:	e13ffd17 	ldw	r4,-12(fp)
 d0212dc:	040341b4 	movhi	r16,3334
 d0212e0:	84040504 	addi	r16,r16,4116
 d0212e4:	01400304 	movi	r5,12
 d0212e8:	d00235c0 	call	d00235c <__mulsi3>
 d0212ec:	1405883a 	add	r2,r2,r16
 d0212f0:	10800104 	addi	r2,r2,4
 d0212f4:	10800017 	ldw	r2,0(r2)
 d0212f8:	1004c03a 	cmpne	r2,r2,zero
 d0212fc:	1000491e 	bne	r2,zero,d021424 <tcp_sleep+0x170>
      {
         global_TCPwakeup_set[i].soc_event = event;
 d021300:	e13ffd17 	ldw	r4,-12(fp)
 d021304:	040341b4 	movhi	r16,3334
 d021308:	84040504 	addi	r16,r16,4116
 d02130c:	01400304 	movi	r5,12
 d021310:	d00235c0 	call	d00235c <__mulsi3>
 d021314:	1405883a 	add	r2,r2,r16
 d021318:	10c00104 	addi	r3,r2,4
 d02131c:	e0bfff17 	ldw	r2,-4(fp)
 d021320:	18800015 	stw	r2,0(r3)
         global_TCPwakeup_set[i].ctick = cticks;
 d021324:	e13ffd17 	ldw	r4,-12(fp)
 d021328:	00834174 	movhi	r2,3333
 d02132c:	109b4504 	addi	r2,r2,27924
 d021330:	14400017 	ldw	r17,0(r2)
 d021334:	040341b4 	movhi	r16,3334
 d021338:	84040504 	addi	r16,r16,4116
 d02133c:	01400304 	movi	r5,12
 d021340:	d00235c0 	call	d00235c <__mulsi3>
 d021344:	1405883a 	add	r2,r2,r16
 d021348:	14400015 	stw	r17,0(r2)
         if (i > global_TCPwakeup_setIndx)
 d02134c:	00834174 	movhi	r2,3333
 d021350:	109b4404 	addi	r2,r2,27920
 d021354:	10c00017 	ldw	r3,0(r2)
 d021358:	e0bffd17 	ldw	r2,-12(fp)
 d02135c:	1880040e 	bge	r3,r2,d021370 <tcp_sleep+0xbc>
            global_TCPwakeup_setIndx = i;
 d021360:	00c34174 	movhi	r3,3333
 d021364:	18db4404 	addi	r3,r3,27920
 d021368:	e0bffd17 	ldw	r2,-12(fp)
 d02136c:	18800015 	stw	r2,0(r3)

         tcp_sleep_count++;
 d021370:	00834174 	movhi	r2,3333
 d021374:	109b4004 	addi	r2,r2,27904
 d021378:	10800017 	ldw	r2,0(r2)
 d02137c:	10c00044 	addi	r3,r2,1
 d021380:	00834174 	movhi	r2,3333
 d021384:	109b4004 	addi	r2,r2,27904
 d021388:	10c00015 	stw	r3,0(r2)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 d02138c:	0009883a 	mov	r4,zero
 d021390:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 d021394:	e13ffd17 	ldw	r4,-12(fp)
 d021398:	040341b4 	movhi	r16,3334
 d02139c:	84040504 	addi	r16,r16,4116
 d0213a0:	01400304 	movi	r5,12
 d0213a4:	d00235c0 	call	d00235c <__mulsi3>
 d0213a8:	1405883a 	add	r2,r2,r16
 d0213ac:	10800204 	addi	r2,r2,8
 d0213b0:	11000017 	ldw	r4,0(r2)
 d0213b4:	e1bffe04 	addi	r6,fp,-8
 d0213b8:	01401904 	movi	r5,100
 d0213bc:	d0135480 	call	d013548 <OSSemPend>
         if (err == 10)
 d0213c0:	e0bffe03 	ldbu	r2,-8(fp)
 d0213c4:	10803fcc 	andi	r2,r2,255
 d0213c8:	10800298 	cmpnei	r2,r2,10
 d0213cc:	1000121e 	bne	r2,zero,d021418 <tcp_sleep+0x164>
         {
            ++tcp_sleep_timeout;
 d0213d0:	d0a90c17 	ldw	r2,-23504(gp)
 d0213d4:	10800044 	addi	r2,r2,1
 d0213d8:	d0a90c15 	stw	r2,-23504(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 d0213dc:	e13ffd17 	ldw	r4,-12(fp)
 d0213e0:	040341b4 	movhi	r16,3334
 d0213e4:	84040504 	addi	r16,r16,4116
 d0213e8:	01400304 	movi	r5,12
 d0213ec:	d00235c0 	call	d00235c <__mulsi3>
 d0213f0:	1405883a 	add	r2,r2,r16
 d0213f4:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 d0213f8:	e13ffd17 	ldw	r4,-12(fp)
 d0213fc:	040341b4 	movhi	r16,3334
 d021400:	84040504 	addi	r16,r16,4116
 d021404:	01400304 	movi	r5,12
 d021408:	d00235c0 	call	d00235c <__mulsi3>
 d02140c:	1405883a 	add	r2,r2,r16
 d021410:	10800104 	addi	r2,r2,4
 d021414:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 d021418:	0009883a 	mov	r4,zero
 d02141c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         return;
 d021420:	00000f06 	br	d021460 <tcp_sleep+0x1ac>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d021424:	e0bffd17 	ldw	r2,-12(fp)
 d021428:	10800044 	addi	r2,r2,1
 d02142c:	e0bffd15 	stw	r2,-12(fp)
 d021430:	e0bffd17 	ldw	r2,-12(fp)
 d021434:	10800510 	cmplti	r2,r2,20
 d021438:	103fa71e 	bne	r2,zero,d0212d8 <tcp_sleep+0x24>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 d02143c:	00c34174 	movhi	r3,3333
 d021440:	18db4404 	addi	r3,r3,27920
 d021444:	e0bffd17 	ldw	r2,-12(fp)
 d021448:	18800015 	stw	r2,0(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02144c:	0009883a 	mov	r4,zero
 d021450:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 d021454:	d0216100 	call	d021610 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 d021458:	0009883a 	mov	r4,zero
 d02145c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
}
 d021460:	e037883a 	mov	sp,fp
 d021464:	dfc00317 	ldw	ra,12(sp)
 d021468:	df000217 	ldw	fp,8(sp)
 d02146c:	dc400117 	ldw	r17,4(sp)
 d021470:	dc000017 	ldw	r16,0(sp)
 d021474:	dec00404 	addi	sp,sp,16
 d021478:	f800283a 	ret

0d02147c <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 d02147c:	defffb04 	addi	sp,sp,-20
 d021480:	dfc00415 	stw	ra,16(sp)
 d021484:	df000315 	stw	fp,12(sp)
 d021488:	dc000215 	stw	r16,8(sp)
 d02148c:	df000204 	addi	fp,sp,8
 d021490:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 d021494:	d00e49c0 	call	d00e49c <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d021498:	e03ffe15 	stw	zero,-8(fp)
 d02149c:	00003506 	br	d021574 <tcp_wakeup+0xf8>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 d0214a0:	e13ffe17 	ldw	r4,-8(fp)
 d0214a4:	040341b4 	movhi	r16,3334
 d0214a8:	84040504 	addi	r16,r16,4116
 d0214ac:	01400304 	movi	r5,12
 d0214b0:	d00235c0 	call	d00235c <__mulsi3>
 d0214b4:	1405883a 	add	r2,r2,r16
 d0214b8:	10800017 	ldw	r2,0(r2)
 d0214bc:	1005003a 	cmpeq	r2,r2,zero
 d0214c0:	1000291e 	bne	r2,zero,d021568 <tcp_wakeup+0xec>
 d0214c4:	e13ffe17 	ldw	r4,-8(fp)
 d0214c8:	040341b4 	movhi	r16,3334
 d0214cc:	84040504 	addi	r16,r16,4116
 d0214d0:	01400304 	movi	r5,12
 d0214d4:	d00235c0 	call	d00235c <__mulsi3>
 d0214d8:	1405883a 	add	r2,r2,r16
 d0214dc:	10800104 	addi	r2,r2,4
 d0214e0:	10c00017 	ldw	r3,0(r2)
 d0214e4:	e0bfff17 	ldw	r2,-4(fp)
 d0214e8:	18801f1e 	bne	r3,r2,d021568 <tcp_wakeup+0xec>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 d0214ec:	e13ffe17 	ldw	r4,-8(fp)
 d0214f0:	040341b4 	movhi	r16,3334
 d0214f4:	84040504 	addi	r16,r16,4116
 d0214f8:	01400304 	movi	r5,12
 d0214fc:	d00235c0 	call	d00235c <__mulsi3>
 d021500:	1405883a 	add	r2,r2,r16
 d021504:	10800204 	addi	r2,r2,8
 d021508:	11000017 	ldw	r4,0(r2)
 d02150c:	d0139400 	call	d013940 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 d021510:	e13ffe17 	ldw	r4,-8(fp)
 d021514:	040341b4 	movhi	r16,3334
 d021518:	84040504 	addi	r16,r16,4116
 d02151c:	01400304 	movi	r5,12
 d021520:	d00235c0 	call	d00235c <__mulsi3>
 d021524:	1405883a 	add	r2,r2,r16
 d021528:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 d02152c:	e13ffe17 	ldw	r4,-8(fp)
 d021530:	040341b4 	movhi	r16,3334
 d021534:	84040504 	addi	r16,r16,4116
 d021538:	01400304 	movi	r5,12
 d02153c:	d00235c0 	call	d00235c <__mulsi3>
 d021540:	1405883a 	add	r2,r2,r16
 d021544:	10800104 	addi	r2,r2,4
 d021548:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 d02154c:	00834174 	movhi	r2,3333
 d021550:	109b4104 	addi	r2,r2,27908
 d021554:	10800017 	ldw	r2,0(r2)
 d021558:	10c00044 	addi	r3,r2,1
 d02155c:	00834174 	movhi	r2,3333
 d021560:	109b4104 	addi	r2,r2,27908
 d021564:	10c00015 	stw	r3,0(r2)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d021568:	e0bffe17 	ldw	r2,-8(fp)
 d02156c:	10800044 	addi	r2,r2,1
 d021570:	e0bffe15 	stw	r2,-8(fp)
 d021574:	e0bffe17 	ldw	r2,-8(fp)
 d021578:	10800510 	cmplti	r2,r2,20
 d02157c:	103fc81e 	bne	r2,zero,d0214a0 <tcp_wakeup+0x24>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 d021580:	d00e5280 	call	d00e528 <OSSchedUnlock>
}
 d021584:	e037883a 	mov	sp,fp
 d021588:	dfc00217 	ldw	ra,8(sp)
 d02158c:	df000117 	ldw	fp,4(sp)
 d021590:	dc000017 	ldw	r16,0(sp)
 d021594:	dec00304 	addi	sp,sp,12
 d021598:	f800283a 	ret

0d02159c <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 d02159c:	deffe104 	addi	sp,sp,-124
 d0215a0:	dfc01e15 	stw	ra,120(sp)
 d0215a4:	df001d15 	stw	fp,116(sp)
 d0215a8:	df001d04 	addi	fp,sp,116
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 d0215ac:	e17fe404 	addi	r5,fp,-112
 d0215b0:	01003fc4 	movi	r4,255
 d0215b4:	d01551c0 	call	d01551c <OSTaskQuery>
 d0215b8:	e0bfe345 	stb	r2,-115(fp)

   if (err == OS_NO_ERR)
 d0215bc:	e0bfe343 	ldbu	r2,-115(fp)
 d0215c0:	1004c03a 	cmpne	r2,r2,zero
 d0215c4:	1000051e 	bne	r2,zero,d0215dc <TK_OSTaskQuery+0x40>
   {
      task_prio = task_data.OSTCBPrio;
 d0215c8:	e0bff083 	ldbu	r2,-62(fp)
 d0215cc:	e0bfe305 	stb	r2,-116(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 d0215d0:	e0bfe303 	ldbu	r2,-116(fp)
 d0215d4:	e0bfff15 	stw	r2,-4(fp)
 d0215d8:	00000706 	br	d0215f8 <TK_OSTaskQuery+0x5c>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 d0215dc:	01034174 	movhi	r4,3333
 d0215e0:	213ccc04 	addi	r4,r4,-3280
 d0215e4:	d0028a00 	call	d0028a0 <printf>
      panic("TK_OSTaskQuery");
 d0215e8:	01034174 	movhi	r4,3333
 d0215ec:	213cd904 	addi	r4,r4,-3228
 d0215f0:	d02093c0 	call	d02093c <panic>
      return 0;
 d0215f4:	e03fff15 	stw	zero,-4(fp)
 d0215f8:	e0bfff17 	ldw	r2,-4(fp)
   }
   
   return task_prio;
}
 d0215fc:	e037883a 	mov	sp,fp
 d021600:	dfc00117 	ldw	ra,4(sp)
 d021604:	df000017 	ldw	fp,0(sp)
 d021608:	dec00204 	addi	sp,sp,8
 d02160c:	f800283a 	ret

0d021610 <tk_yield>:



void
tk_yield(void)
{
 d021610:	defffe04 	addi	sp,sp,-8
 d021614:	dfc00115 	stw	ra,4(sp)
 d021618:	df000015 	stw	fp,0(sp)
 d02161c:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 d021620:	01000044 	movi	r4,1
 d021624:	d0156dc0 	call	d0156dc <OSTimeDly>
}
 d021628:	e037883a 	mov	sp,fp
 d02162c:	dfc00117 	ldw	ra,4(sp)
 d021630:	df000017 	ldw	fp,0(sp)
 d021634:	dec00204 	addi	sp,sp,8
 d021638:	f800283a 	ret

0d02163c <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 d02163c:	deffef04 	addi	sp,sp,-68
 d021640:	dfc01015 	stw	ra,64(sp)
 d021644:	df000f15 	stw	fp,60(sp)
 d021648:	df000f04 	addi	fp,sp,60
 d02164c:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 d021650:	e13fff17 	ldw	r4,-4(fp)
 d021654:	01434174 	movhi	r5,3333
 d021658:	297cdd04 	addi	r5,r5,-3212
 d02165c:	d020b640 	call	d020b64 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 d021660:	00834174 	movhi	r2,3333
 d021664:	109b0e04 	addi	r2,r2,27704
 d021668:	11800017 	ldw	r6,0(r2)
 d02166c:	e13fff17 	ldw	r4,-4(fp)
 d021670:	01434174 	movhi	r5,3333
 d021674:	297ce304 	addi	r5,r5,-3188
 d021678:	d020b640 	call	d020b64 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 d02167c:	e13fff17 	ldw	r4,-4(fp)
 d021680:	01434174 	movhi	r5,3333
 d021684:	297ceb04 	addi	r5,r5,-3156
 d021688:	d020b640 	call	d020b64 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 d02168c:	e03ff515 	stw	zero,-44(fp)
 d021690:	00005106 	br	d0217d8 <tk_stats+0x19c>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 d021694:	e0bff517 	ldw	r2,-44(fp)
 d021698:	00c341b4 	movhi	r3,3334
 d02169c:	18c1b004 	addi	r3,r3,1728
 d0216a0:	1085883a 	add	r2,r2,r2
 d0216a4:	1085883a 	add	r2,r2,r2
 d0216a8:	10c5883a 	add	r2,r2,r3
 d0216ac:	10800017 	ldw	r2,0(r2)
 d0216b0:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 d0216b4:	e0bff417 	ldw	r2,-48(fp)
 d0216b8:	1005003a 	cmpeq	r2,r2,zero
 d0216bc:	1000431e 	bne	r2,zero,d0217cc <tk_stats+0x190>
 d0216c0:	e0bff417 	ldw	r2,-48(fp)
 d0216c4:	10800060 	cmpeqi	r2,r2,1
 d0216c8:	1000401e 	bne	r2,zero,d0217cc <tk_stats+0x190>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 d0216cc:	e0bff417 	ldw	r2,-48(fp)
 d0216d0:	10800c83 	ldbu	r2,50(r2)
 d0216d4:	11003fcc 	andi	r4,r2,255
 d0216d8:	e17ff604 	addi	r5,fp,-40
 d0216dc:	e1bffe44 	addi	r6,fp,-7
 d0216e0:	d014b600 	call	d014b60 <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 d0216e4:	e0bff417 	ldw	r2,-48(fp)
 d0216e8:	10800c83 	ldbu	r2,50(r2)
 d0216ec:	11c03fcc 	andi	r7,r2,255
 d0216f0:	e0bff417 	ldw	r2,-48(fp)
 d0216f4:	10800c03 	ldbu	r2,48(r2)
 d0216f8:	10803fcc 	andi	r2,r2,255
 d0216fc:	e1bff604 	addi	r6,fp,-40
 d021700:	d8800015 	stw	r2,0(sp)
 d021704:	e13fff17 	ldw	r4,-4(fp)
 d021708:	01434174 	movhi	r5,3333
 d02170c:	297cfb04 	addi	r5,r5,-3092
 d021710:	d020b640 	call	d020b64 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 d021714:	e0bff417 	ldw	r2,-48(fp)
 d021718:	10800217 	ldw	r2,8(r2)
 d02171c:	1005003a 	cmpeq	r2,r2,zero
 d021720:	1000261e 	bne	r2,zero,d0217bc <tk_stats+0x180>
 d021724:	e0bff417 	ldw	r2,-48(fp)
 d021728:	10800317 	ldw	r2,12(r2)
 d02172c:	1005003a 	cmpeq	r2,r2,zero
 d021730:	1000221e 	bne	r2,zero,d0217bc <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 d021734:	e0bff417 	ldw	r2,-48(fp)
 d021738:	10800217 	ldw	r2,8(r2)
 d02173c:	10800104 	addi	r2,r2,4
 d021740:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 d021744:	00000306 	br	d021754 <tk_stats+0x118>
            sp++;
 d021748:	e0bff317 	ldw	r2,-52(fp)
 d02174c:	10800104 	addi	r2,r2,4
 d021750:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 d021754:	e0bff317 	ldw	r2,-52(fp)
 d021758:	10800017 	ldw	r2,0(r2)
 d02175c:	1005003a 	cmpeq	r2,r2,zero
 d021760:	103ff91e 	bne	r2,zero,d021748 <tk_stats+0x10c>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 d021764:	e0bff417 	ldw	r2,-48(fp)
 d021768:	11000317 	ldw	r4,12(r2)
 d02176c:	e0fff317 	ldw	r3,-52(fp)
 d021770:	e0bff417 	ldw	r2,-48(fp)
 d021774:	10800217 	ldw	r2,8(r2)
 d021778:	1885c83a 	sub	r2,r3,r2
 d02177c:	1005d0ba 	srai	r2,r2,2
 d021780:	2085c83a 	sub	r2,r4,r2
 d021784:	1085883a 	add	r2,r2,r2
 d021788:	1085883a 	add	r2,r2,r2
 d02178c:	e0bff215 	stw	r2,-56(fp)
         ns_printf(pio, "%6d,      %6d\n",
 d021790:	e0bff417 	ldw	r2,-48(fp)
 d021794:	10800317 	ldw	r2,12(r2)
 d021798:	1085883a 	add	r2,r2,r2
 d02179c:	1085883a 	add	r2,r2,r2
 d0217a0:	100d883a 	mov	r6,r2
 d0217a4:	e13fff17 	ldw	r4,-4(fp)
 d0217a8:	01434174 	movhi	r5,3333
 d0217ac:	297d0304 	addi	r5,r5,-3060
 d0217b0:	e1fff217 	ldw	r7,-56(fp)
 d0217b4:	d020b640 	call	d020b64 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 d0217b8:	00000406 	br	d0217cc <tk_stats+0x190>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 d0217bc:	e13fff17 	ldw	r4,-4(fp)
 d0217c0:	01434174 	movhi	r5,3333
 d0217c4:	297d0704 	addi	r5,r5,-3044
 d0217c8:	d020b640 	call	d020b64 <ns_printf>
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 d0217cc:	e0bff517 	ldw	r2,-44(fp)
 d0217d0:	10800044 	addi	r2,r2,1
 d0217d4:	e0bff515 	stw	r2,-44(fp)
 d0217d8:	e0bff517 	ldw	r2,-44(fp)
 d0217dc:	10800550 	cmplti	r2,r2,21
 d0217e0:	103fac1e 	bne	r2,zero,d021694 <tk_stats+0x58>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 d0217e4:	00834174 	movhi	r2,3333
 d0217e8:	109b4004 	addi	r2,r2,27904
 d0217ec:	11800017 	ldw	r6,0(r2)
 d0217f0:	00834174 	movhi	r2,3333
 d0217f4:	109b4104 	addi	r2,r2,27908
 d0217f8:	11c00017 	ldw	r7,0(r2)
 d0217fc:	e13fff17 	ldw	r4,-4(fp)
 d021800:	01434174 	movhi	r5,3333
 d021804:	297d0b04 	addi	r5,r5,-3028
 d021808:	d020b640 	call	d020b64 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 d02180c:	00834174 	movhi	r2,3333
 d021810:	109b4404 	addi	r2,r2,27920
 d021814:	11800017 	ldw	r6,0(r2)
 d021818:	d1e90c17 	ldw	r7,-23504(gp)
 d02181c:	e13fff17 	ldw	r4,-4(fp)
 d021820:	01434174 	movhi	r5,3333
 d021824:	297d1704 	addi	r5,r5,-2980
 d021828:	d020b640 	call	d020b64 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 d02182c:	0005883a 	mov	r2,zero
}
 d021830:	e037883a 	mov	sp,fp
 d021834:	dfc00117 	ldw	ra,4(sp)
 d021838:	df000017 	ldw	fp,0(sp)
 d02183c:	dec00204 	addi	sp,sp,8
 d021840:	f800283a 	ret

0d021844 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 d021844:	defffa04 	addi	sp,sp,-24
 d021848:	dfc00515 	stw	ra,20(sp)
 d02184c:	df000415 	stw	fp,16(sp)
 d021850:	df000404 	addi	fp,sp,16
 d021854:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 d021858:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 d02185c:	01000d84 	movi	r4,54
 d021860:	e17fff17 	ldw	r5,-4(fp)
 d021864:	d024ab00 	call	d024ab0 <find_opt>
 d021868:	e0bffe15 	stw	r2,-8(fp)
 d02186c:	e0bffe17 	ldw	r2,-8(fp)
 d021870:	1005003a 	cmpeq	r2,r2,zero
 d021874:	1000111e 	bne	r2,zero,d0218bc <dhc_get_srv_ipaddr+0x78>
   {
      opts++;
 d021878:	e0bffe17 	ldw	r2,-8(fp)
 d02187c:	10800044 	addi	r2,r2,1
 d021880:	e0bffe15 	stw	r2,-8(fp)
      optlen = *opts;
 d021884:	e0bffe17 	ldw	r2,-8(fp)
 d021888:	10800003 	ldbu	r2,0(r2)
 d02188c:	e0bffd05 	stb	r2,-12(fp)
      opts++;
 d021890:	e0bffe17 	ldw	r2,-8(fp)
 d021894:	10800044 	addi	r2,r2,1
 d021898:	e0bffe15 	stw	r2,-8(fp)
      srv_ipaddr = dh_getlong(opts);
 d02189c:	e13ffe17 	ldw	r4,-8(fp)
 d0218a0:	d023be40 	call	d023be4 <dh_getlong>
 d0218a4:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 d0218a8:	e0bffd03 	ldbu	r2,-12(fp)
 d0218ac:	1007883a 	mov	r3,r2
 d0218b0:	e0bffe17 	ldw	r2,-8(fp)
 d0218b4:	10c5883a 	add	r2,r2,r3
 d0218b8:	e0bffe15 	stw	r2,-8(fp)
   }

   return (srv_ipaddr);
 d0218bc:	e0bffc17 	ldw	r2,-16(fp)
} 
 d0218c0:	e037883a 	mov	sp,fp
 d0218c4:	dfc00117 	ldw	ra,4(sp)
 d0218c8:	df000017 	ldw	fp,0(sp)
 d0218cc:	dec00204 	addi	sp,sp,8
 d0218d0:	f800283a 	ret

0d0218d4 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 d0218d4:	defffa04 	addi	sp,sp,-24
 d0218d8:	dfc00515 	stw	ra,20(sp)
 d0218dc:	df000415 	stw	fp,16(sp)
 d0218e0:	dc000315 	stw	r16,12(sp)
 d0218e4:	df000304 	addi	fp,sp,12
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 d0218e8:	00bfff44 	movi	r2,-3
 d0218ec:	d8800015 	stw	r2,0(sp)
 d0218f0:	0009883a 	mov	r4,zero
 d0218f4:	014010c4 	movi	r5,67
 d0218f8:	01801104 	movi	r6,68
 d0218fc:	01c340b4 	movhi	r7,3330
 d021900:	39c67e04 	addi	r7,r7,6648
 d021904:	d0255a00 	call	d0255a0 <udp_open>
 d021908:	d0a90d15 	stw	r2,-23500(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 d02190c:	d0a90d17 	ldw	r2,-23500(gp)
 d021910:	1004c03a 	cmpne	r2,r2,zero
 d021914:	1000031e 	bne	r2,zero,d021924 <dhc_init+0x50>
      return ENP_RESOURCE;
 d021918:	00bffa84 	movi	r2,-22
 d02191c:	e0bfff15 	stw	r2,-4(fp)
 d021920:	00001806 	br	d021984 <dhc_init+0xb0>

   for (i = 0; i < MAXNETS; i++)
 d021924:	e03ffe15 	stw	zero,-8(fp)
 d021928:	00001206 	br	d021974 <dhc_init+0xa0>
   {
      dhc_states[i].state = DHCS_UNUSED;
 d02192c:	e13ffe17 	ldw	r4,-8(fp)
 d021930:	040341b4 	movhi	r16,3334
 d021934:	84034004 	addi	r16,r16,3328
 d021938:	01400f04 	movi	r5,60
 d02193c:	d00235c0 	call	d00235c <__mulsi3>
 d021940:	1405883a 	add	r2,r2,r16
 d021944:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 d021948:	e13ffe17 	ldw	r4,-8(fp)
 d02194c:	040341b4 	movhi	r16,3334
 d021950:	84034004 	addi	r16,r16,3328
 d021954:	01400f04 	movi	r5,60
 d021958:	d00235c0 	call	d00235c <__mulsi3>
 d02195c:	1405883a 	add	r2,r2,r16
 d021960:	10800104 	addi	r2,r2,4
 d021964:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 d021968:	e0bffe17 	ldw	r2,-8(fp)
 d02196c:	10800044 	addi	r2,r2,1
 d021970:	e0bffe15 	stw	r2,-8(fp)
 d021974:	e0bffe17 	ldw	r2,-8(fp)
 d021978:	10800110 	cmplti	r2,r2,4
 d02197c:	103feb1e 	bne	r2,zero,d02192c <dhc_init+0x58>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 d021980:	e03fff15 	stw	zero,-4(fp)
 d021984:	e0bfff17 	ldw	r2,-4(fp)
}
 d021988:	e037883a 	mov	sp,fp
 d02198c:	dfc00217 	ldw	ra,8(sp)
 d021990:	df000117 	ldw	fp,4(sp)
 d021994:	dc000017 	ldw	r16,0(sp)
 d021998:	dec00304 	addi	sp,sp,12
 d02199c:	f800283a 	ret

0d0219a0 <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 d0219a0:	defffb04 	addi	sp,sp,-20
 d0219a4:	dfc00415 	stw	ra,16(sp)
 d0219a8:	df000315 	stw	fp,12(sp)
 d0219ac:	dc000215 	stw	r16,8(sp)
 d0219b0:	df000204 	addi	fp,sp,8
 d0219b4:	e13ffe15 	stw	r4,-8(fp)
 d0219b8:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 d0219bc:	e13ffe17 	ldw	r4,-8(fp)
 d0219c0:	040341b4 	movhi	r16,3334
 d0219c4:	84034004 	addi	r16,r16,3328
 d0219c8:	01400f04 	movi	r5,60
 d0219cc:	d00235c0 	call	d00235c <__mulsi3>
 d0219d0:	1405883a 	add	r2,r2,r16
 d0219d4:	10c00e04 	addi	r3,r2,56
 d0219d8:	e0bfff17 	ldw	r2,-4(fp)
 d0219dc:	18800015 	stw	r2,0(r3)
}
 d0219e0:	e037883a 	mov	sp,fp
 d0219e4:	dfc00217 	ldw	ra,8(sp)
 d0219e8:	df000117 	ldw	fp,4(sp)
 d0219ec:	dc000017 	ldw	r16,0(sp)
 d0219f0:	dec00304 	addi	sp,sp,12
 d0219f4:	f800283a 	ret

0d0219f8 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 d0219f8:	defff004 	addi	sp,sp,-64
 d0219fc:	dfc00f15 	stw	ra,60(sp)
 d021a00:	df000e15 	stw	fp,56(sp)
 d021a04:	dc800d15 	stw	r18,52(sp)
 d021a08:	dc400c15 	stw	r17,48(sp)
 d021a0c:	dc000b15 	stw	r16,44(sp)
 d021a10:	df000b04 	addi	fp,sp,44
 d021a14:	e13ffb15 	stw	r4,-20(fp)
 d021a18:	e17ffc15 	stw	r5,-16(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 d021a1c:	e0bffb17 	ldw	r2,-20(fp)
 d021a20:	10800417 	ldw	r2,16(r2)
 d021a24:	e0bff915 	stw	r2,-28(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 d021a28:	e03ff815 	stw	zero,-32(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 d021a2c:	e0bffc17 	ldw	r2,-16(fp)
 d021a30:	10bfff60 	cmpeqi	r2,r2,-3
 d021a34:	1000041e 	bne	r2,zero,d021a48 <dhc_upcall+0x50>
   {
      dtrap();
 d021a38:	d025a500 	call	d025a50 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 d021a3c:	00bffd44 	movi	r2,-11
 d021a40:	e0bffe15 	stw	r2,-8(fp)
 d021a44:	00021306 	br	d022294 <dhc_upcall+0x89c>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 d021a48:	e0bffb17 	ldw	r2,-20(fp)
 d021a4c:	11000617 	ldw	r4,24(r2)
 d021a50:	d01e88c0 	call	d01e88c <if_netnumber>
 d021a54:	e0bff615 	stw	r2,-40(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 d021a58:	e13ff617 	ldw	r4,-40(fp)
 d021a5c:	040341b4 	movhi	r16,3334
 d021a60:	84034004 	addi	r16,r16,3328
 d021a64:	01400f04 	movi	r5,60
 d021a68:	d00235c0 	call	d00235c <__mulsi3>
 d021a6c:	1405883a 	add	r2,r2,r16
 d021a70:	10800017 	ldw	r2,0(r2)
 d021a74:	1004c03a 	cmpne	r2,r2,zero
 d021a78:	1000031e 	bne	r2,zero,d021a88 <dhc_upcall+0x90>
      return ENP_NOT_MINE;
 d021a7c:	00c00084 	movi	r3,2
 d021a80:	e0fffe15 	stw	r3,-8(fp)
 d021a84:	00020306 	br	d022294 <dhc_upcall+0x89c>

   bp = (struct bootp *)pkt->nb_prot;
 d021a88:	e0bffb17 	ldw	r2,-20(fp)
 d021a8c:	10800317 	ldw	r2,12(r2)
 d021a90:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 d021a94:	e0bff917 	ldw	r2,-28(fp)
 d021a98:	10803b30 	cmpltui	r2,r2,236
 d021a9c:	10000b1e 	bne	r2,zero,d021acc <dhc_upcall+0xd4>
 d021aa0:	e0bffa17 	ldw	r2,-24(fp)
 d021aa4:	10800003 	ldbu	r2,0(r2)
 d021aa8:	10803fcc 	andi	r2,r2,255
 d021aac:	10800098 	cmpnei	r2,r2,2
 d021ab0:	1000061e 	bne	r2,zero,d021acc <dhc_upcall+0xd4>
 d021ab4:	e0bffa17 	ldw	r2,-24(fp)
 d021ab8:	10803b04 	addi	r2,r2,236
 d021abc:	10c00017 	ldw	r3,0(r2)
 d021ac0:	0098d534 	movhi	r2,25428
 d021ac4:	10a098c4 	addi	r2,r2,-32157
 d021ac8:	18800726 	beq	r3,r2,d021ae8 <dhc_upcall+0xf0>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 d021acc:	d025a500 	call	d025a50 <dtrap>
      dsc_errors++;
 d021ad0:	d0a90e17 	ldw	r2,-23496(gp)
 d021ad4:	10800044 	addi	r2,r2,1
 d021ad8:	d0a90e15 	stw	r2,-23496(gp)
      return ENP_NOT_MINE;
 d021adc:	01000084 	movi	r4,2
 d021ae0:	e13ffe15 	stw	r4,-8(fp)
 d021ae4:	0001eb06 	br	d022294 <dhc_upcall+0x89c>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 d021ae8:	e0bffa17 	ldw	r2,-24(fp)
 d021aec:	11000704 	addi	r4,r2,28
 d021af0:	e0bffb17 	ldw	r2,-20(fp)
 d021af4:	10800617 	ldw	r2,24(r2)
 d021af8:	11401717 	ldw	r5,92(r2)
 d021afc:	e0bffb17 	ldw	r2,-20(fp)
 d021b00:	10800617 	ldw	r2,24(r2)
 d021b04:	11801117 	ldw	r6,68(r2)
 d021b08:	d04be440 	call	d04be44 <memcmp>
 d021b0c:	1005003a 	cmpeq	r2,r2,zero
 d021b10:	1000031e 	bne	r2,zero,d021b20 <dhc_upcall+0x128>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 d021b14:	00800084 	movi	r2,2
 d021b18:	e0bffe15 	stw	r2,-8(fp)
 d021b1c:	0001dd06 	br	d022294 <dhc_upcall+0x89c>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 d021b20:	e0bffa17 	ldw	r2,-24(fp)
 d021b24:	10803b04 	addi	r2,r2,236
 d021b28:	11400104 	addi	r5,r2,4
 d021b2c:	01000d44 	movi	r4,53
 d021b30:	d024ab00 	call	d024ab0 <find_opt>
 d021b34:	e0bff515 	stw	r2,-44(fp)
   if (opts && *opts == DHOP_TYPE)
 d021b38:	e0bff517 	ldw	r2,-44(fp)
 d021b3c:	1005003a 	cmpeq	r2,r2,zero
 d021b40:	1000101e 	bne	r2,zero,d021b84 <dhc_upcall+0x18c>
 d021b44:	e0bff517 	ldw	r2,-44(fp)
 d021b48:	10800003 	ldbu	r2,0(r2)
 d021b4c:	10803fcc 	andi	r2,r2,255
 d021b50:	10800d58 	cmpnei	r2,r2,53
 d021b54:	10000b1e 	bne	r2,zero,d021b84 <dhc_upcall+0x18c>
   {
      dhcptype = *(opts+2);
 d021b58:	e0bff517 	ldw	r2,-44(fp)
 d021b5c:	10800084 	addi	r2,r2,2
 d021b60:	10800003 	ldbu	r2,0(r2)
 d021b64:	10803fcc 	andi	r2,r2,255
 d021b68:	e0bff815 	stw	r2,-32(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 d021b6c:	e0bffa17 	ldw	r2,-24(fp)
 d021b70:	10800003 	ldbu	r2,0(r2)
 d021b74:	10800114 	ori	r2,r2,4
 d021b78:	1007883a 	mov	r3,r2
 d021b7c:	e0bffa17 	ldw	r2,-24(fp)
 d021b80:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 d021b84:	e0bffa17 	ldw	r2,-24(fp)
 d021b88:	10800003 	ldbu	r2,0(r2)
 d021b8c:	10803fcc 	andi	r2,r2,255
 d021b90:	1080010c 	andi	r2,r2,4
 d021b94:	1005003a 	cmpeq	r2,r2,zero
 d021b98:	10019b1e 	bne	r2,zero,d022208 <dhc_upcall+0x810>
   {
      switch (dhcptype)
 d021b9c:	e0fff817 	ldw	r3,-32(fp)
 d021ba0:	e0ffff15 	stw	r3,-4(fp)
 d021ba4:	e13fff17 	ldw	r4,-4(fp)
 d021ba8:	20800148 	cmpgei	r2,r4,5
 d021bac:	1000071e 	bne	r2,zero,d021bcc <dhc_upcall+0x1d4>
 d021bb0:	e0ffff17 	ldw	r3,-4(fp)
 d021bb4:	188000c8 	cmpgei	r2,r3,3
 d021bb8:	1000081e 	bne	r2,zero,d021bdc <dhc_upcall+0x1e4>
 d021bbc:	e13fff17 	ldw	r4,-4(fp)
 d021bc0:	20800060 	cmpeqi	r2,r4,1
 d021bc4:	1000051e 	bne	r2,zero,d021bdc <dhc_upcall+0x1e4>
 d021bc8:	00000a06 	br	d021bf4 <dhc_upcall+0x1fc>
 d021bcc:	e0ffff17 	ldw	r3,-4(fp)
 d021bd0:	188001e0 	cmpeqi	r2,r3,7
 d021bd4:	1000011e 	bne	r2,zero,d021bdc <dhc_upcall+0x1e4>
 d021bd8:	00000606 	br	d021bf4 <dhc_upcall+0x1fc>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 d021bdc:	d0a90e17 	ldw	r2,-23496(gp)
 d021be0:	10800044 	addi	r2,r2,1
 d021be4:	d0a90e15 	stw	r2,-23496(gp)
         return ENP_NOT_MINE;
 d021be8:	01000084 	movi	r4,2
 d021bec:	e13ffe15 	stw	r4,-8(fp)
 d021bf0:	0001a806 	br	d022294 <dhc_upcall+0x89c>
      }

      switch (dhc_states[iface].state)
 d021bf4:	e13ff617 	ldw	r4,-40(fp)
 d021bf8:	040341b4 	movhi	r16,3334
 d021bfc:	84034004 	addi	r16,r16,3328
 d021c00:	01400f04 	movi	r5,60
 d021c04:	d00235c0 	call	d00235c <__mulsi3>
 d021c08:	1405883a 	add	r2,r2,r16
 d021c0c:	10800017 	ldw	r2,0(r2)
 d021c10:	e0bffd15 	stw	r2,-12(fp)
 d021c14:	e0fffd17 	ldw	r3,-12(fp)
 d021c18:	18800268 	cmpgeui	r2,r3,9
 d021c1c:	1001701e 	bne	r2,zero,d0221e0 <dhc_upcall+0x7e8>
 d021c20:	e13ffd17 	ldw	r4,-12(fp)
 d021c24:	e13ffd17 	ldw	r4,-12(fp)
 d021c28:	2105883a 	add	r2,r4,r4
 d021c2c:	1087883a 	add	r3,r2,r2
 d021c30:	008340b4 	movhi	r2,3330
 d021c34:	10871104 	addi	r2,r2,7236
 d021c38:	1885883a 	add	r2,r3,r2
 d021c3c:	10800017 	ldw	r2,0(r2)
 d021c40:	1000683a 	jmp	r2
 d021c44:	0d0221e0 	cmpeqi	r20,at,2183
 d021c48:	0d021c68 	cmpgeui	r20,at,2161
 d021c4c:	0d021c68 	cmpgeui	r20,at,2161
 d021c50:	0d021ee0 	cmpeqi	r20,at,2171
 d021c54:	0d021c80 	call	d021c8 <__ram_exceptions_end+0xc81fcc>
 d021c58:	0d021e1c 	xori	r20,at,2168
 d021c5c:	0d021c68 	cmpgeui	r20,at,2161
 d021c60:	0d021e1c 	xori	r20,at,2168
 d021c64:	0d021e1c 	xori	r20,at,2168
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 d021c68:	d0a90e17 	ldw	r2,-23496(gp)
 d021c6c:	10800044 	addi	r2,r2,1
 d021c70:	d0a90e15 	stw	r2,-23496(gp)
         return ENP_NOT_MINE;
 d021c74:	00800084 	movi	r2,2
 d021c78:	e0bffe15 	stw	r2,-8(fp)
 d021c7c:	00018506 	br	d022294 <dhc_upcall+0x89c>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 d021c80:	e0bff817 	ldw	r2,-32(fp)
 d021c84:	10800098 	cmpnei	r2,r2,2
 d021c88:	1000581e 	bne	r2,zero,d021dec <dhc_upcall+0x3f4>
         {
            dsc_offers++;
 d021c8c:	d0a91017 	ldw	r2,-23488(gp)
 d021c90:	10800044 	addi	r2,r2,1
 d021c94:	d0a91015 	stw	r2,-23488(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 d021c98:	e47ff617 	ldw	r17,-40(fp)
 d021c9c:	e0bffa17 	ldw	r2,-24(fp)
 d021ca0:	10803b04 	addi	r2,r2,236
 d021ca4:	11000104 	addi	r4,r2,4
 d021ca8:	d0218440 	call	d021844 <dhc_get_srv_ipaddr>
 d021cac:	1025883a 	mov	r18,r2
 d021cb0:	040341b4 	movhi	r16,3334
 d021cb4:	84034004 	addi	r16,r16,3328
 d021cb8:	8809883a 	mov	r4,r17
 d021cbc:	01400f04 	movi	r5,60
 d021cc0:	d00235c0 	call	d00235c <__mulsi3>
 d021cc4:	1405883a 	add	r2,r2,r16
 d021cc8:	10800d04 	addi	r2,r2,52
 d021ccc:	14800015 	stw	r18,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 d021cd0:	e13ff617 	ldw	r4,-40(fp)
 d021cd4:	040341b4 	movhi	r16,3334
 d021cd8:	84034004 	addi	r16,r16,3328
 d021cdc:	01400f04 	movi	r5,60
 d021ce0:	d00235c0 	call	d00235c <__mulsi3>
 d021ce4:	1405883a 	add	r2,r2,r16
 d021ce8:	10800d04 	addi	r2,r2,52
 d021cec:	10800017 	ldw	r2,0(r2)
 d021cf0:	1004c03a 	cmpne	r2,r2,zero
 d021cf4:	10000e1e 	bne	r2,zero,d021d30 <dhc_upcall+0x338>
            {
               dtrap(); /* didn't receive server-identifier option */
 d021cf8:	d025a500 	call	d025a50 <dtrap>
               dsc_errors++;
 d021cfc:	d0a90e17 	ldw	r2,-23496(gp)
 d021d00:	10800044 	addi	r2,r2,1
 d021d04:	d0a90e15 	stw	r2,-23496(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 d021d08:	e13ff617 	ldw	r4,-40(fp)
 d021d0c:	e0bffb17 	ldw	r2,-20(fp)
 d021d10:	14400717 	ldw	r17,28(r2)
 d021d14:	040341b4 	movhi	r16,3334
 d021d18:	84034004 	addi	r16,r16,3328
 d021d1c:	01400f04 	movi	r5,60
 d021d20:	d00235c0 	call	d00235c <__mulsi3>
 d021d24:	1405883a 	add	r2,r2,r16
 d021d28:	10800d04 	addi	r2,r2,52
 d021d2c:	14400015 	stw	r17,0(r2)
            }

            if (bp->hops)
 d021d30:	e0bffa17 	ldw	r2,-24(fp)
 d021d34:	108000c3 	ldbu	r2,3(r2)
 d021d38:	10803fcc 	andi	r2,r2,255
 d021d3c:	1005003a 	cmpeq	r2,r2,zero
 d021d40:	10000b1e 	bne	r2,zero,d021d70 <dhc_upcall+0x378>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 d021d44:	e13ff617 	ldw	r4,-40(fp)
 d021d48:	e0bffb17 	ldw	r2,-20(fp)
 d021d4c:	14400717 	ldw	r17,28(r2)
 d021d50:	040341b4 	movhi	r16,3334
 d021d54:	84034004 	addi	r16,r16,3328
 d021d58:	01400f04 	movi	r5,60
 d021d5c:	d00235c0 	call	d00235c <__mulsi3>
 d021d60:	1405883a 	add	r2,r2,r16
 d021d64:	10800c04 	addi	r2,r2,48
 d021d68:	14400015 	stw	r17,0(r2)
 d021d6c:	00000806 	br	d021d90 <dhc_upcall+0x398>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 d021d70:	e13ff617 	ldw	r4,-40(fp)
 d021d74:	040341b4 	movhi	r16,3334
 d021d78:	84034004 	addi	r16,r16,3328
 d021d7c:	01400f04 	movi	r5,60
 d021d80:	d00235c0 	call	d00235c <__mulsi3>
 d021d84:	1405883a 	add	r2,r2,r16
 d021d88:	10800c04 	addi	r2,r2,48
 d021d8c:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 d021d90:	e0bffb17 	ldw	r2,-20(fp)
 d021d94:	11800417 	ldw	r6,16(r2)
 d021d98:	e13ff617 	ldw	r4,-40(fp)
 d021d9c:	e17ffa17 	ldw	r5,-24(fp)
 d021da0:	d022a380 	call	d022a38 <dhc_rx_offer>
 d021da4:	e0bff715 	stw	r2,-36(fp)
            if (e)
 d021da8:	e0bff717 	ldw	r2,-36(fp)
 d021dac:	1005003a 	cmpeq	r2,r2,zero
 d021db0:	10000a1e 	bne	r2,zero,d021ddc <dhc_upcall+0x3e4>
            {
               dsc_errors++;
 d021db4:	d0a90e17 	ldw	r2,-23496(gp)
 d021db8:	10800044 	addi	r2,r2,1
 d021dbc:	d0a90e15 	stw	r2,-23496(gp)
               dhc_set_state(iface,DHCS_INIT);
 d021dc0:	e13ff617 	ldw	r4,-40(fp)
 d021dc4:	01400044 	movi	r5,1
 d021dc8:	d0249e00 	call	d0249e0 <dhc_set_state>
               dtrap();
 d021dcc:	d025a500 	call	d025a50 <dtrap>
               return ENP_NOT_MINE;
 d021dd0:	00c00084 	movi	r3,2
 d021dd4:	e0fffe15 	stw	r3,-8(fp)
 d021dd8:	00012e06 	br	d022294 <dhc_upcall+0x89c>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 d021ddc:	e13ff617 	ldw	r4,-40(fp)
 d021de0:	01400144 	movi	r5,5
 d021de4:	d0249e00 	call	d0249e0 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 d021de8:	00012706 	br	d022288 <dhc_upcall+0x890>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 d021dec:	d0a90e17 	ldw	r2,-23496(gp)
 d021df0:	10800044 	addi	r2,r2,1
 d021df4:	d0a90e15 	stw	r2,-23496(gp)
            if ( dhcptype == DHCP_NAK ) 
 d021df8:	e0bff817 	ldw	r2,-32(fp)
 d021dfc:	10800198 	cmpnei	r2,r2,6
 d021e00:	1000031e 	bne	r2,zero,d021e10 <dhc_upcall+0x418>
               dsc_naks++;
 d021e04:	d0a91617 	ldw	r2,-23464(gp)
 d021e08:	10800044 	addi	r2,r2,1
 d021e0c:	d0a91615 	stw	r2,-23464(gp)
            return ENP_NOT_MINE;
 d021e10:	01000084 	movi	r4,2
 d021e14:	e13ffe15 	stw	r4,-8(fp)
 d021e18:	00011e06 	br	d022294 <dhc_upcall+0x89c>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 d021e1c:	e13ff617 	ldw	r4,-40(fp)
 d021e20:	040341b4 	movhi	r16,3334
 d021e24:	84034004 	addi	r16,r16,3328
 d021e28:	01400f04 	movi	r5,60
 d021e2c:	d00235c0 	call	d00235c <__mulsi3>
 d021e30:	1405883a 	add	r2,r2,r16
 d021e34:	10800d04 	addi	r2,r2,52
 d021e38:	14000017 	ldw	r16,0(r2)
 d021e3c:	e0bffa17 	ldw	r2,-24(fp)
 d021e40:	10803b04 	addi	r2,r2,236
 d021e44:	11000104 	addi	r4,r2,4
 d021e48:	d0218440 	call	d021844 <dhc_get_srv_ipaddr>
 d021e4c:	80800626 	beq	r16,r2,d021e68 <dhc_upcall+0x470>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 d021e50:	d0a90e17 	ldw	r2,-23496(gp)
 d021e54:	10800044 	addi	r2,r2,1
 d021e58:	d0a90e15 	stw	r2,-23496(gp)
            return ENP_NOT_MINE;
 d021e5c:	00800084 	movi	r2,2
 d021e60:	e0bffe15 	stw	r2,-8(fp)
 d021e64:	00010b06 	br	d022294 <dhc_upcall+0x89c>
         }
         if (dhc_states[iface].rly_ipaddr &&
 d021e68:	e13ff617 	ldw	r4,-40(fp)
 d021e6c:	040341b4 	movhi	r16,3334
 d021e70:	84034004 	addi	r16,r16,3328
 d021e74:	01400f04 	movi	r5,60
 d021e78:	d00235c0 	call	d00235c <__mulsi3>
 d021e7c:	1405883a 	add	r2,r2,r16
 d021e80:	10800c04 	addi	r2,r2,48
 d021e84:	10800017 	ldw	r2,0(r2)
 d021e88:	1005003a 	cmpeq	r2,r2,zero
 d021e8c:	1000141e 	bne	r2,zero,d021ee0 <dhc_upcall+0x4e8>
 d021e90:	e13ff617 	ldw	r4,-40(fp)
 d021e94:	040341b4 	movhi	r16,3334
 d021e98:	84034004 	addi	r16,r16,3328
 d021e9c:	01400f04 	movi	r5,60
 d021ea0:	d00235c0 	call	d00235c <__mulsi3>
 d021ea4:	1405883a 	add	r2,r2,r16
 d021ea8:	10800c04 	addi	r2,r2,48
 d021eac:	10c00017 	ldw	r3,0(r2)
 d021eb0:	e0bffb17 	ldw	r2,-20(fp)
 d021eb4:	10800717 	ldw	r2,28(r2)
 d021eb8:	18800926 	beq	r3,r2,d021ee0 <dhc_upcall+0x4e8>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 d021ebc:	d0a91917 	ldw	r2,-23452(gp)
 d021ec0:	10800044 	addi	r2,r2,1
 d021ec4:	d0a91915 	stw	r2,-23452(gp)
            dsc_errors++;
 d021ec8:	d0a90e17 	ldw	r2,-23496(gp)
 d021ecc:	10800044 	addi	r2,r2,1
 d021ed0:	d0a90e15 	stw	r2,-23496(gp)
            return ENP_NOT_MINE;
 d021ed4:	00c00084 	movi	r3,2
 d021ed8:	e0fffe15 	stw	r3,-8(fp)
 d021edc:	0000ed06 	br	d022294 <dhc_upcall+0x89c>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 d021ee0:	e0bff817 	ldw	r2,-32(fp)
 d021ee4:	10800158 	cmpnei	r2,r2,5
 d021ee8:	10009b1e 	bne	r2,zero,d022158 <dhc_upcall+0x760>
         {
            dsc_acks++;
 d021eec:	d0a91217 	ldw	r2,-23480(gp)
 d021ef0:	10800044 	addi	r2,r2,1
 d021ef4:	d0a91215 	stw	r2,-23480(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 d021ef8:	e0bffa17 	ldw	r2,-24(fp)
 d021efc:	10803b04 	addi	r2,r2,236
 d021f00:	11400104 	addi	r5,r2,4
 d021f04:	e13ff617 	ldw	r4,-40(fp)
 d021f08:	d023cb00 	call	d023cb0 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 d021f0c:	e13ff617 	ldw	r4,-40(fp)
 d021f10:	040341b4 	movhi	r16,3334
 d021f14:	84034004 	addi	r16,r16,3328
 d021f18:	01400f04 	movi	r5,60
 d021f1c:	d00235c0 	call	d00235c <__mulsi3>
 d021f20:	1405883a 	add	r2,r2,r16
 d021f24:	10800504 	addi	r2,r2,20
 d021f28:	10800017 	ldw	r2,0(r2)
 d021f2c:	10bfffd8 	cmpnei	r2,r2,-1
 d021f30:	1000131e 	bne	r2,zero,d021f80 <dhc_upcall+0x588>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 d021f34:	e13ff617 	ldw	r4,-40(fp)
 d021f38:	040341b4 	movhi	r16,3334
 d021f3c:	84034004 	addi	r16,r16,3328
 d021f40:	01400f04 	movi	r5,60
 d021f44:	d00235c0 	call	d00235c <__mulsi3>
 d021f48:	1405883a 	add	r2,r2,r16
 d021f4c:	10c00604 	addi	r3,r2,24
 d021f50:	00bfffc4 	movi	r2,-1
 d021f54:	18800015 	stw	r2,0(r3)
               dhc_states[iface].t2 = DHC_INFINITY ;
 d021f58:	e13ff617 	ldw	r4,-40(fp)
 d021f5c:	040341b4 	movhi	r16,3334
 d021f60:	84034004 	addi	r16,r16,3328
 d021f64:	01400f04 	movi	r5,60
 d021f68:	d00235c0 	call	d00235c <__mulsi3>
 d021f6c:	1405883a 	add	r2,r2,r16
 d021f70:	10c00704 	addi	r3,r2,28
 d021f74:	00bfffc4 	movi	r2,-1
 d021f78:	18800015 	stw	r2,0(r3)
 d021f7c:	00002706 	br	d02201c <dhc_upcall+0x624>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 d021f80:	e4bff617 	ldw	r18,-40(fp)
 d021f84:	e13ff617 	ldw	r4,-40(fp)
 d021f88:	040341b4 	movhi	r16,3334
 d021f8c:	84034004 	addi	r16,r16,3328
 d021f90:	01400f04 	movi	r5,60
 d021f94:	d00235c0 	call	d00235c <__mulsi3>
 d021f98:	1405883a 	add	r2,r2,r16
 d021f9c:	10800504 	addi	r2,r2,20
 d021fa0:	10800017 	ldw	r2,0(r2)
 d021fa4:	1022d07a 	srli	r17,r2,1
 d021fa8:	040341b4 	movhi	r16,3334
 d021fac:	84034004 	addi	r16,r16,3328
 d021fb0:	9009883a 	mov	r4,r18
 d021fb4:	01400f04 	movi	r5,60
 d021fb8:	d00235c0 	call	d00235c <__mulsi3>
 d021fbc:	1405883a 	add	r2,r2,r16
 d021fc0:	10800604 	addi	r2,r2,24
 d021fc4:	14400015 	stw	r17,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 d021fc8:	e4bff617 	ldw	r18,-40(fp)
 d021fcc:	e13ff617 	ldw	r4,-40(fp)
 d021fd0:	040341b4 	movhi	r16,3334
 d021fd4:	84034004 	addi	r16,r16,3328
 d021fd8:	01400f04 	movi	r5,60
 d021fdc:	d00235c0 	call	d00235c <__mulsi3>
 d021fe0:	1405883a 	add	r2,r2,r16
 d021fe4:	10800504 	addi	r2,r2,20
 d021fe8:	10800017 	ldw	r2,0(r2)
 d021fec:	1008d0fa 	srli	r4,r2,3
 d021ff0:	014001c4 	movi	r5,7
 d021ff4:	d00235c0 	call	d00235c <__mulsi3>
 d021ff8:	1023883a 	mov	r17,r2
 d021ffc:	040341b4 	movhi	r16,3334
 d022000:	84034004 	addi	r16,r16,3328
 d022004:	9009883a 	mov	r4,r18
 d022008:	01400f04 	movi	r5,60
 d02200c:	d00235c0 	call	d00235c <__mulsi3>
 d022010:	1405883a 	add	r2,r2,r16
 d022014:	10800704 	addi	r2,r2,28
 d022018:	14400015 	stw	r17,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 d02201c:	e13ff617 	ldw	r4,-40(fp)
 d022020:	00834174 	movhi	r2,3333
 d022024:	109b4504 	addi	r2,r2,27924
 d022028:	14400017 	ldw	r17,0(r2)
 d02202c:	040341b4 	movhi	r16,3334
 d022030:	84034004 	addi	r16,r16,3328
 d022034:	01400f04 	movi	r5,60
 d022038:	d00235c0 	call	d00235c <__mulsi3>
 d02203c:	1405883a 	add	r2,r2,r16
 d022040:	10800804 	addi	r2,r2,32
 d022044:	14400015 	stw	r17,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 d022048:	e47ff617 	ldw	r17,-40(fp)
 d02204c:	e0bffa17 	ldw	r2,-24(fp)
 d022050:	10803b04 	addi	r2,r2,236
 d022054:	11000104 	addi	r4,r2,4
 d022058:	d0218440 	call	d021844 <dhc_get_srv_ipaddr>
 d02205c:	1025883a 	mov	r18,r2
 d022060:	040341b4 	movhi	r16,3334
 d022064:	84034004 	addi	r16,r16,3328
 d022068:	8809883a 	mov	r4,r17
 d02206c:	01400f04 	movi	r5,60
 d022070:	d00235c0 	call	d00235c <__mulsi3>
 d022074:	1405883a 	add	r2,r2,r16
 d022078:	10800d04 	addi	r2,r2,52
 d02207c:	14800015 	stw	r18,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 d022080:	e13ff617 	ldw	r4,-40(fp)
 d022084:	040341b4 	movhi	r16,3334
 d022088:	84034004 	addi	r16,r16,3328
 d02208c:	01400f04 	movi	r5,60
 d022090:	d00235c0 	call	d00235c <__mulsi3>
 d022094:	1405883a 	add	r2,r2,r16
 d022098:	10800d04 	addi	r2,r2,52
 d02209c:	10800017 	ldw	r2,0(r2)
 d0220a0:	1004c03a 	cmpne	r2,r2,zero
 d0220a4:	10000e1e 	bne	r2,zero,d0220e0 <dhc_upcall+0x6e8>
            {
               dtrap(); /* didn't receive server-identifier option */
 d0220a8:	d025a500 	call	d025a50 <dtrap>
               dsc_errors++;
 d0220ac:	d0a90e17 	ldw	r2,-23496(gp)
 d0220b0:	10800044 	addi	r2,r2,1
 d0220b4:	d0a90e15 	stw	r2,-23496(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 d0220b8:	e13ff617 	ldw	r4,-40(fp)
 d0220bc:	e0bffb17 	ldw	r2,-20(fp)
 d0220c0:	14400717 	ldw	r17,28(r2)
 d0220c4:	040341b4 	movhi	r16,3334
 d0220c8:	84034004 	addi	r16,r16,3328
 d0220cc:	01400f04 	movi	r5,60
 d0220d0:	d00235c0 	call	d00235c <__mulsi3>
 d0220d4:	1405883a 	add	r2,r2,r16
 d0220d8:	10800d04 	addi	r2,r2,52
 d0220dc:	14400015 	stw	r17,0(r2)
            }
            if (bp->hops)
 d0220e0:	e0bffa17 	ldw	r2,-24(fp)
 d0220e4:	108000c3 	ldbu	r2,3(r2)
 d0220e8:	10803fcc 	andi	r2,r2,255
 d0220ec:	1005003a 	cmpeq	r2,r2,zero
 d0220f0:	10000b1e 	bne	r2,zero,d022120 <dhc_upcall+0x728>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 d0220f4:	e13ff617 	ldw	r4,-40(fp)
 d0220f8:	e0bffb17 	ldw	r2,-20(fp)
 d0220fc:	14400717 	ldw	r17,28(r2)
 d022100:	040341b4 	movhi	r16,3334
 d022104:	84034004 	addi	r16,r16,3328
 d022108:	01400f04 	movi	r5,60
 d02210c:	d00235c0 	call	d00235c <__mulsi3>
 d022110:	1405883a 	add	r2,r2,r16
 d022114:	10800c04 	addi	r2,r2,48
 d022118:	14400015 	stw	r17,0(r2)
 d02211c:	00000806 	br	d022140 <dhc_upcall+0x748>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 d022120:	e13ff617 	ldw	r4,-40(fp)
 d022124:	040341b4 	movhi	r16,3334
 d022128:	84034004 	addi	r16,r16,3328
 d02212c:	01400f04 	movi	r5,60
 d022130:	d00235c0 	call	d00235c <__mulsi3>
 d022134:	1405883a 	add	r2,r2,r16
 d022138:	10800c04 	addi	r2,r2,48
 d02213c:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 d022140:	e13ff617 	ldw	r4,-40(fp)
 d022144:	d0237480 	call	d023748 <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 d022148:	e13ff617 	ldw	r4,-40(fp)
 d02214c:	01400184 	movi	r5,6
 d022150:	d0249e00 	call	d0249e0 <dhc_set_state>
 d022154:	00004c06 	br	d022288 <dhc_upcall+0x890>
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 d022158:	e0bff817 	ldw	r2,-32(fp)
 d02215c:	10800198 	cmpnei	r2,r2,6
 d022160:	1000071e 	bne	r2,zero,d022180 <dhc_upcall+0x788>
         {
            dhc_set_state(iface,DHCS_INIT);
 d022164:	e13ff617 	ldw	r4,-40(fp)
 d022168:	01400044 	movi	r5,1
 d02216c:	d0249e00 	call	d0249e0 <dhc_set_state>
            dsc_naks++;
 d022170:	d0a91617 	ldw	r2,-23464(gp)
 d022174:	10800044 	addi	r2,r2,1
 d022178:	d0a91615 	stw	r2,-23464(gp)
 d02217c:	00004206 	br	d022288 <dhc_upcall+0x890>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 d022180:	e13ff617 	ldw	r4,-40(fp)
 d022184:	040341b4 	movhi	r16,3334
 d022188:	84034004 	addi	r16,r16,3328
 d02218c:	01400f04 	movi	r5,60
 d022190:	d00235c0 	call	d00235c <__mulsi3>
 d022194:	1405883a 	add	r2,r2,r16
 d022198:	10800017 	ldw	r2,0(r2)
 d02219c:	10800158 	cmpnei	r2,r2,5
 d0221a0:	1000091e 	bne	r2,zero,d0221c8 <dhc_upcall+0x7d0>
 d0221a4:	e0bff817 	ldw	r2,-32(fp)
 d0221a8:	10800098 	cmpnei	r2,r2,2
 d0221ac:	1000061e 	bne	r2,zero,d0221c8 <dhc_upcall+0x7d0>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 d0221b0:	d0a91017 	ldw	r2,-23488(gp)
 d0221b4:	10800044 	addi	r2,r2,1
 d0221b8:	d0a91015 	stw	r2,-23488(gp)
               return ENP_NOT_MINE;
 d0221bc:	01000084 	movi	r4,2
 d0221c0:	e13ffe15 	stw	r4,-8(fp)
 d0221c4:	00003306 	br	d022294 <dhc_upcall+0x89c>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 d0221c8:	d0a90e17 	ldw	r2,-23496(gp)
 d0221cc:	10800044 	addi	r2,r2,1
 d0221d0:	d0a90e15 	stw	r2,-23496(gp)
            return ENP_NOT_MINE;
 d0221d4:	00800084 	movi	r2,2
 d0221d8:	e0bffe15 	stw	r2,-8(fp)
 d0221dc:	00002d06 	br	d022294 <dhc_upcall+0x89c>
         }
         break;
      default:    /* bad state */
         dtrap();
 d0221e0:	d025a500 	call	d025a50 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 d0221e4:	e13ff617 	ldw	r4,-40(fp)
 d0221e8:	01400044 	movi	r5,1
 d0221ec:	d0249e00 	call	d0249e0 <dhc_set_state>
         dsc_errors++;
 d0221f0:	d0a90e17 	ldw	r2,-23496(gp)
 d0221f4:	10800044 	addi	r2,r2,1
 d0221f8:	d0a90e15 	stw	r2,-23496(gp)
         return -1;
 d0221fc:	00ffffc4 	movi	r3,-1
 d022200:	e0fffe15 	stw	r3,-8(fp)
 d022204:	00002306 	br	d022294 <dhc_upcall+0x89c>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 d022208:	d0a91317 	ldw	r2,-23476(gp)
 d02220c:	10800044 	addi	r2,r2,1
 d022210:	d0a91315 	stw	r2,-23476(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 d022214:	e0bffa17 	ldw	r2,-24(fp)
 d022218:	10803b04 	addi	r2,r2,236
 d02221c:	11400104 	addi	r5,r2,4
 d022220:	e13ff617 	ldw	r4,-40(fp)
 d022224:	d023cb00 	call	d023cb0 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 d022228:	e13ff617 	ldw	r4,-40(fp)
 d02222c:	e0bffa17 	ldw	r2,-24(fp)
 d022230:	14400417 	ldw	r17,16(r2)
 d022234:	040341b4 	movhi	r16,3334
 d022238:	84034004 	addi	r16,r16,3328
 d02223c:	01400f04 	movi	r5,60
 d022240:	d00235c0 	call	d00235c <__mulsi3>
 d022244:	1405883a 	add	r2,r2,r16
 d022248:	10800904 	addi	r2,r2,36
 d02224c:	14400015 	stw	r17,0(r2)
      dhc_setip(iface);
 d022250:	e13ff617 	ldw	r4,-40(fp)
 d022254:	d0237480 	call	d023748 <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 d022258:	e13ff617 	ldw	r4,-40(fp)
 d02225c:	01400184 	movi	r5,6
 d022260:	d0249e00 	call	d0249e0 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 d022264:	e13ff617 	ldw	r4,-40(fp)
 d022268:	040341b4 	movhi	r16,3334
 d02226c:	84034004 	addi	r16,r16,3328
 d022270:	01400f04 	movi	r5,60
 d022274:	d00235c0 	call	d00235c <__mulsi3>
 d022278:	1405883a 	add	r2,r2,r16
 d02227c:	10c00604 	addi	r3,r2,24
 d022280:	00bfffc4 	movi	r2,-1
 d022284:	18800015 	stw	r2,0(r3)
   }

   udp_free(pkt);
 d022288:	e13ffb17 	ldw	r4,-20(fp)
 d02228c:	d0455080 	call	d045508 <udp_free>
   return 0;
 d022290:	e03ffe15 	stw	zero,-8(fp)
 d022294:	e0bffe17 	ldw	r2,-8(fp)
}
 d022298:	e037883a 	mov	sp,fp
 d02229c:	dfc00417 	ldw	ra,16(sp)
 d0222a0:	df000317 	ldw	fp,12(sp)
 d0222a4:	dc800217 	ldw	r18,8(sp)
 d0222a8:	dc400117 	ldw	r17,4(sp)
 d0222ac:	dc000017 	ldw	r16,0(sp)
 d0222b0:	dec00504 	addi	sp,sp,20
 d0222b4:	f800283a 	ret

0d0222b8 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 d0222b8:	defff704 	addi	sp,sp,-36
 d0222bc:	dfc00815 	stw	ra,32(sp)
 d0222c0:	df000715 	stw	fp,28(sp)
 d0222c4:	dc000615 	stw	r16,24(sp)
 d0222c8:	df000604 	addi	fp,sp,24
 d0222cc:	e13ffb15 	stw	r4,-20(fp)
 d0222d0:	e17ffc15 	stw	r5,-16(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 d0222d4:	e0bffc17 	ldw	r2,-16(fp)
 d0222d8:	1009883a 	mov	r4,r2
 d0222dc:	01804b04 	movi	r6,300
 d0222e0:	000b883a 	mov	r5,zero
 d0222e4:	d0027880 	call	d002788 <memset>
   outbp->op = BOOTREQUEST;
 d0222e8:	e0fffc17 	ldw	r3,-16(fp)
 d0222ec:	00800044 	movi	r2,1
 d0222f0:	18800005 	stb	r2,0(r3)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 d0222f4:	e0bffb17 	ldw	r2,-20(fp)
 d0222f8:	00c341b4 	movhi	r3,3334
 d0222fc:	18c31a04 	addi	r3,r3,3176
 d022300:	1085883a 	add	r2,r2,r2
 d022304:	1085883a 	add	r2,r2,r2
 d022308:	10c5883a 	add	r2,r2,r3
 d02230c:	10800017 	ldw	r2,0(r2)
 d022310:	10802717 	ldw	r2,156(r2)
 d022314:	10800217 	ldw	r2,8(r2)
 d022318:	e0bfff15 	stw	r2,-4(fp)
 d02231c:	e0ffff17 	ldw	r3,-4(fp)
 d022320:	188005e0 	cmpeqi	r2,r3,23
 d022324:	10000b1e 	bne	r2,zero,d022354 <dhc_buildheader+0x9c>
 d022328:	e0ffff17 	ldw	r3,-4(fp)
 d02232c:	18800720 	cmpeqi	r2,r3,28
 d022330:	1000081e 	bne	r2,zero,d022354 <dhc_buildheader+0x9c>
 d022334:	e0ffff17 	ldw	r3,-4(fp)
 d022338:	188001a0 	cmpeqi	r2,r3,6
 d02233c:	1000011e 	bne	r2,zero,d022344 <dhc_buildheader+0x8c>
 d022340:	00000806 	br	d022364 <dhc_buildheader+0xac>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 d022344:	e0fffc17 	ldw	r3,-16(fp)
 d022348:	00800044 	movi	r2,1
 d02234c:	18800045 	stb	r2,1(r3)
   break;
 d022350:	00000806 	br	d022374 <dhc_buildheader+0xbc>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 d022354:	e0fffc17 	ldw	r3,-16(fp)
 d022358:	00800504 	movi	r2,20
 d02235c:	18800045 	stb	r2,1(r3)
   break;
 d022360:	00000406 	br	d022374 <dhc_buildheader+0xbc>
      default:
      dtrap();
 d022364:	d025a500 	call	d025a50 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 d022368:	00bffd44 	movi	r2,-11
 d02236c:	e0bffe15 	stw	r2,-8(fp)
 d022370:	00005606 	br	d0224cc <dhc_buildheader+0x214>
   }

   addrlen = min(16, nets[iface]->n_hal);
 d022374:	e0bffb17 	ldw	r2,-20(fp)
 d022378:	00c341b4 	movhi	r3,3334
 d02237c:	18c31a04 	addi	r3,r3,3176
 d022380:	1085883a 	add	r2,r2,r2
 d022384:	1085883a 	add	r2,r2,r2
 d022388:	10c5883a 	add	r2,r2,r3
 d02238c:	10800017 	ldw	r2,0(r2)
 d022390:	10801117 	ldw	r2,68(r2)
 d022394:	e0bffd15 	stw	r2,-12(fp)
 d022398:	e0fffd17 	ldw	r3,-12(fp)
 d02239c:	18800470 	cmpltui	r2,r3,17
 d0223a0:	1000021e 	bne	r2,zero,d0223ac <dhc_buildheader+0xf4>
 d0223a4:	00800404 	movi	r2,16
 d0223a8:	e0bffd15 	stw	r2,-12(fp)
 d0223ac:	e0fffd17 	ldw	r3,-12(fp)
 d0223b0:	e0fffa15 	stw	r3,-24(fp)
   outbp->hlen = (u_char)addrlen;
 d0223b4:	e0bffa17 	ldw	r2,-24(fp)
 d0223b8:	1007883a 	mov	r3,r2
 d0223bc:	e0bffc17 	ldw	r2,-16(fp)
 d0223c0:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 d0223c4:	e0bffc17 	ldw	r2,-16(fp)
 d0223c8:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 d0223cc:	e13ffb17 	ldw	r4,-20(fp)
 d0223d0:	040341b4 	movhi	r16,3334
 d0223d4:	84034004 	addi	r16,r16,3328
 d0223d8:	01400f04 	movi	r5,60
 d0223dc:	d00235c0 	call	d00235c <__mulsi3>
 d0223e0:	1405883a 	add	r2,r2,r16
 d0223e4:	10800017 	ldw	r2,0(r2)
 d0223e8:	108001d8 	cmpnei	r2,r2,7
 d0223ec:	1000031e 	bne	r2,zero,d0223fc <dhc_buildheader+0x144>
      outbp->flags = 0; /* Renewing needs unicast */
 d0223f0:	e0bffc17 	ldw	r2,-16(fp)
 d0223f4:	1000028d 	sth	zero,10(r2)
 d0223f8:	00000306 	br	d022408 <dhc_buildheader+0x150>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 d0223fc:	e0fffc17 	ldw	r3,-16(fp)
 d022400:	00802004 	movi	r2,128
 d022404:	1880028d 	sth	r2,10(r3)
   outbp->xid = dhc_states[iface].xid;
 d022408:	e13ffb17 	ldw	r4,-20(fp)
 d02240c:	040341b4 	movhi	r16,3334
 d022410:	84034004 	addi	r16,r16,3328
 d022414:	01400f04 	movi	r5,60
 d022418:	d00235c0 	call	d00235c <__mulsi3>
 d02241c:	1405883a 	add	r2,r2,r16
 d022420:	10800204 	addi	r2,r2,8
 d022424:	10c00017 	ldw	r3,0(r2)
 d022428:	e0bffc17 	ldw	r2,-16(fp)
 d02242c:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 d022430:	e13ffb17 	ldw	r4,-20(fp)
 d022434:	040341b4 	movhi	r16,3334
 d022438:	84034004 	addi	r16,r16,3328
 d02243c:	01400f04 	movi	r5,60
 d022440:	d00235c0 	call	d00235c <__mulsi3>
 d022444:	1405883a 	add	r2,r2,r16
 d022448:	10800304 	addi	r2,r2,12
 d02244c:	10c0000b 	ldhu	r3,0(r2)
 d022450:	e0bffc17 	ldw	r2,-16(fp)
 d022454:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 d022458:	e0bffb17 	ldw	r2,-20(fp)
 d02245c:	00c341b4 	movhi	r3,3334
 d022460:	18c31a04 	addi	r3,r3,3176
 d022464:	1085883a 	add	r2,r2,r2
 d022468:	1085883a 	add	r2,r2,r2
 d02246c:	10c5883a 	add	r2,r2,r3
 d022470:	10800017 	ldw	r2,0(r2)
 d022474:	10801717 	ldw	r2,92(r2)
 d022478:	1004c03a 	cmpne	r2,r2,zero
 d02247c:	1000041e 	bne	r2,zero,d022490 <dhc_buildheader+0x1d8>
   {
      dtrap();
 d022480:	d025a500 	call	d025a50 <dtrap>
      return ENP_LOGIC;
 d022484:	00bffd44 	movi	r2,-11
 d022488:	e0bffe15 	stw	r2,-8(fp)
 d02248c:	00000f06 	br	d0224cc <dhc_buildheader+0x214>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 d022490:	e0bffc17 	ldw	r2,-16(fp)
 d022494:	11000704 	addi	r4,r2,28
 d022498:	e0bffb17 	ldw	r2,-20(fp)
 d02249c:	00c341b4 	movhi	r3,3334
 d0224a0:	18c31a04 	addi	r3,r3,3176
 d0224a4:	1085883a 	add	r2,r2,r2
 d0224a8:	1085883a 	add	r2,r2,r2
 d0224ac:	10c5883a 	add	r2,r2,r3
 d0224b0:	10800017 	ldw	r2,0(r2)
 d0224b4:	10801717 	ldw	r2,92(r2)
 d0224b8:	e0fffa17 	ldw	r3,-24(fp)
 d0224bc:	100b883a 	mov	r5,r2
 d0224c0:	180d883a 	mov	r6,r3
 d0224c4:	d0026080 	call	d002608 <memcpy>

   /* return success */
   return 0;
 d0224c8:	e03ffe15 	stw	zero,-8(fp)
 d0224cc:	e0bffe17 	ldw	r2,-8(fp)
}
 d0224d0:	e037883a 	mov	sp,fp
 d0224d4:	dfc00217 	ldw	ra,8(sp)
 d0224d8:	df000117 	ldw	fp,4(sp)
 d0224dc:	dc000017 	ldw	r16,0(sp)
 d0224e0:	dec00304 	addi	sp,sp,12
 d0224e4:	f800283a 	ret

0d0224e8 <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 d0224e8:	defff204 	addi	sp,sp,-56
 d0224ec:	dfc00d15 	stw	ra,52(sp)
 d0224f0:	df000c15 	stw	fp,48(sp)
 d0224f4:	dc800b15 	stw	r18,44(sp)
 d0224f8:	dc400a15 	stw	r17,40(sp)
 d0224fc:	dc000915 	stw	r16,36(sp)
 d022500:	df000904 	addi	fp,sp,36
 d022504:	e13ffe15 	stw	r4,-8(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 d022508:	01004b04 	movi	r4,300
 d02250c:	000b883a 	mov	r5,zero
 d022510:	d04541c0 	call	d04541c <udp_alloc>
 d022514:	e0bffb15 	stw	r2,-20(fp)
   if (!pkt) 
 d022518:	e0bffb17 	ldw	r2,-20(fp)
 d02251c:	1004c03a 	cmpne	r2,r2,zero
 d022520:	1000031e 	bne	r2,zero,d022530 <dhc_discover+0x48>
      return ENP_NOMEM;
 d022524:	00bffb04 	movi	r2,-20
 d022528:	e0bfff15 	stw	r2,-4(fp)
 d02252c:	00013906 	br	d022a14 <dhc_discover+0x52c>
   pkt->nb_plen = sizeof(struct bootp);
 d022530:	e0fffb17 	ldw	r3,-20(fp)
 d022534:	00804b04 	movi	r2,300
 d022538:	18800415 	stw	r2,16(r3)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 d02253c:	e13ffe17 	ldw	r4,-8(fp)
 d022540:	d4603217 	ldw	r17,-32568(gp)
 d022544:	8825883a 	mov	r18,r17
 d022548:	040341b4 	movhi	r16,3334
 d02254c:	84034004 	addi	r16,r16,3328
 d022550:	01400f04 	movi	r5,60
 d022554:	d00235c0 	call	d00235c <__mulsi3>
 d022558:	1405883a 	add	r2,r2,r16
 d02255c:	10800204 	addi	r2,r2,8
 d022560:	14800015 	stw	r18,0(r2)
 d022564:	88800044 	addi	r2,r17,1
 d022568:	d0a03215 	stw	r2,-32568(gp)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 d02256c:	e47ffe17 	ldw	r17,-8(fp)
 d022570:	d03c99c0 	call	d03c99c <sysuptime>
 d022574:	1009883a 	mov	r4,r2
 d022578:	01401904 	movi	r5,100
 d02257c:	d00c90c0 	call	d00c90c <__udivsi3>
 d022580:	1025883a 	mov	r18,r2
 d022584:	040341b4 	movhi	r16,3334
 d022588:	84034004 	addi	r16,r16,3328
 d02258c:	8809883a 	mov	r4,r17
 d022590:	01400f04 	movi	r5,60
 d022594:	d00235c0 	call	d00235c <__mulsi3>
 d022598:	1405883a 	add	r2,r2,r16
 d02259c:	10800304 	addi	r2,r2,12
 d0225a0:	1480000d 	sth	r18,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 d0225a4:	e0bffb17 	ldw	r2,-20(fp)
 d0225a8:	10800317 	ldw	r2,12(r2)
 d0225ac:	e0bffa15 	stw	r2,-24(fp)
   e = dhc_buildheader(iface,outbp);
 d0225b0:	e13ffe17 	ldw	r4,-8(fp)
 d0225b4:	e17ffa17 	ldw	r5,-24(fp)
 d0225b8:	d0222b80 	call	d0222b8 <dhc_buildheader>
 d0225bc:	e0bff815 	stw	r2,-32(fp)
   if (e)
 d0225c0:	e0bff817 	ldw	r2,-32(fp)
 d0225c4:	1005003a 	cmpeq	r2,r2,zero
 d0225c8:	1000031e 	bne	r2,zero,d0225d8 <dhc_discover+0xf0>
      return e;
 d0225cc:	e0bff817 	ldw	r2,-32(fp)
 d0225d0:	e0bfff15 	stw	r2,-4(fp)
 d0225d4:	00010f06 	br	d022a14 <dhc_discover+0x52c>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 d0225d8:	e0bffa17 	ldw	r2,-24(fp)
 d0225dc:	10803b04 	addi	r2,r2,236
 d0225e0:	1007883a 	mov	r3,r2
 d0225e4:	0098d534 	movhi	r2,25428
 d0225e8:	10a098c4 	addi	r2,r2,-32157
 d0225ec:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 d0225f0:	e0bffa17 	ldw	r2,-24(fp)
 d0225f4:	10803b04 	addi	r2,r2,236
 d0225f8:	10800104 	addi	r2,r2,4
 d0225fc:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 d022600:	e0fff917 	ldw	r3,-28(fp)
 d022604:	00800d44 	movi	r2,53
 d022608:	18800005 	stb	r2,0(r3)
 d02260c:	e0bff917 	ldw	r2,-28(fp)
 d022610:	10800044 	addi	r2,r2,1
 d022614:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 d022618:	e0fff917 	ldw	r3,-28(fp)
 d02261c:	00800044 	movi	r2,1
 d022620:	18800005 	stb	r2,0(r3)
 d022624:	e0bff917 	ldw	r2,-28(fp)
 d022628:	10800044 	addi	r2,r2,1
 d02262c:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_DISCOVER;
 d022630:	e0fff917 	ldw	r3,-28(fp)
 d022634:	00800044 	movi	r2,1
 d022638:	18800005 	stb	r2,0(r3)
 d02263c:	e0bff917 	ldw	r2,-28(fp)
 d022640:	10800044 	addi	r2,r2,1
 d022644:	e0bff915 	stw	r2,-28(fp)
   leasetime = -1L ;    /* ask for infinite lease */
 d022648:	00bfffc4 	movi	r2,-1
 d02264c:	e0bffc15 	stw	r2,-16(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 d022650:	e0fff917 	ldw	r3,-28(fp)
 d022654:	00800cc4 	movi	r2,51
 d022658:	18800005 	stb	r2,0(r3)
 d02265c:	e0bff917 	ldw	r2,-28(fp)
 d022660:	10800044 	addi	r2,r2,1
 d022664:	e0bff915 	stw	r2,-28(fp)
 d022668:	e0fff917 	ldw	r3,-28(fp)
 d02266c:	00800104 	movi	r2,4
 d022670:	18800005 	stb	r2,0(r3)
 d022674:	e0bff917 	ldw	r2,-28(fp)
 d022678:	10800044 	addi	r2,r2,1
 d02267c:	e0bff915 	stw	r2,-28(fp)
 d022680:	e0bff917 	ldw	r2,-28(fp)
 d022684:	10c000c4 	addi	r3,r2,3
 d022688:	e0bffc04 	addi	r2,fp,-16
 d02268c:	10800003 	ldbu	r2,0(r2)
 d022690:	18800005 	stb	r2,0(r3)
 d022694:	e0bff917 	ldw	r2,-28(fp)
 d022698:	10c00084 	addi	r3,r2,2
 d02269c:	e0bffc04 	addi	r2,fp,-16
 d0226a0:	10800044 	addi	r2,r2,1
 d0226a4:	10800003 	ldbu	r2,0(r2)
 d0226a8:	18800005 	stb	r2,0(r3)
 d0226ac:	e0bff917 	ldw	r2,-28(fp)
 d0226b0:	10c00044 	addi	r3,r2,1
 d0226b4:	e0bffc04 	addi	r2,fp,-16
 d0226b8:	10800084 	addi	r2,r2,2
 d0226bc:	10800003 	ldbu	r2,0(r2)
 d0226c0:	18800005 	stb	r2,0(r3)
 d0226c4:	e0bffc04 	addi	r2,fp,-16
 d0226c8:	108000c4 	addi	r2,r2,3
 d0226cc:	10800003 	ldbu	r2,0(r2)
 d0226d0:	1007883a 	mov	r3,r2
 d0226d4:	e0bff917 	ldw	r2,-28(fp)
 d0226d8:	10c00005 	stb	r3,0(r2)
 d0226dc:	e0bff917 	ldw	r2,-28(fp)
 d0226e0:	10800104 	addi	r2,r2,4
 d0226e4:	e0bff915 	stw	r2,-28(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 d0226e8:	e0bffe17 	ldw	r2,-8(fp)
 d0226ec:	00c341b4 	movhi	r3,3334
 d0226f0:	18c31a04 	addi	r3,r3,3176
 d0226f4:	1085883a 	add	r2,r2,r2
 d0226f8:	1085883a 	add	r2,r2,r2
 d0226fc:	10c5883a 	add	r2,r2,r3
 d022700:	10800017 	ldw	r2,0(r2)
 d022704:	10800a17 	ldw	r2,40(r2)
 d022708:	1005003a 	cmpeq	r2,r2,zero
 d02270c:	1000521e 	bne	r2,zero,d022858 <dhc_discover+0x370>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 d022710:	e0bffe17 	ldw	r2,-8(fp)
 d022714:	00c341b4 	movhi	r3,3334
 d022718:	18c31a04 	addi	r3,r3,3176
 d02271c:	1085883a 	add	r2,r2,r2
 d022720:	1085883a 	add	r2,r2,r2
 d022724:	10c5883a 	add	r2,r2,r3
 d022728:	10800017 	ldw	r2,0(r2)
 d02272c:	10800a17 	ldw	r2,40(r2)
 d022730:	1004d63a 	srli	r2,r2,24
 d022734:	11003fcc 	andi	r4,r2,255
 d022738:	e0bffe17 	ldw	r2,-8(fp)
 d02273c:	00c341b4 	movhi	r3,3334
 d022740:	18c31a04 	addi	r3,r3,3176
 d022744:	1085883a 	add	r2,r2,r2
 d022748:	1085883a 	add	r2,r2,r2
 d02274c:	10c5883a 	add	r2,r2,r3
 d022750:	10800017 	ldw	r2,0(r2)
 d022754:	10800a17 	ldw	r2,40(r2)
 d022758:	1004d23a 	srli	r2,r2,8
 d02275c:	10bfc00c 	andi	r2,r2,65280
 d022760:	2088b03a 	or	r4,r4,r2
 d022764:	e0bffe17 	ldw	r2,-8(fp)
 d022768:	00c341b4 	movhi	r3,3334
 d02276c:	18c31a04 	addi	r3,r3,3176
 d022770:	1085883a 	add	r2,r2,r2
 d022774:	1085883a 	add	r2,r2,r2
 d022778:	10c5883a 	add	r2,r2,r3
 d02277c:	10800017 	ldw	r2,0(r2)
 d022780:	10800a17 	ldw	r2,40(r2)
 d022784:	10bfc00c 	andi	r2,r2,65280
 d022788:	1004923a 	slli	r2,r2,8
 d02278c:	2088b03a 	or	r4,r4,r2
 d022790:	e0bffe17 	ldw	r2,-8(fp)
 d022794:	00c341b4 	movhi	r3,3334
 d022798:	18c31a04 	addi	r3,r3,3176
 d02279c:	1085883a 	add	r2,r2,r2
 d0227a0:	1085883a 	add	r2,r2,r2
 d0227a4:	10c5883a 	add	r2,r2,r3
 d0227a8:	10800017 	ldw	r2,0(r2)
 d0227ac:	10800a17 	ldw	r2,40(r2)
 d0227b0:	10803fcc 	andi	r2,r2,255
 d0227b4:	1004963a 	slli	r2,r2,24
 d0227b8:	2084b03a 	or	r2,r4,r2
 d0227bc:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 d0227c0:	e0fff917 	ldw	r3,-28(fp)
 d0227c4:	00800c84 	movi	r2,50
 d0227c8:	18800005 	stb	r2,0(r3)
 d0227cc:	e0bff917 	ldw	r2,-28(fp)
 d0227d0:	10800044 	addi	r2,r2,1
 d0227d4:	e0bff915 	stw	r2,-28(fp)
 d0227d8:	e0fff917 	ldw	r3,-28(fp)
 d0227dc:	00800104 	movi	r2,4
 d0227e0:	18800005 	stb	r2,0(r3)
 d0227e4:	e0bff917 	ldw	r2,-28(fp)
 d0227e8:	10800044 	addi	r2,r2,1
 d0227ec:	e0bff915 	stw	r2,-28(fp)
 d0227f0:	e0bff917 	ldw	r2,-28(fp)
 d0227f4:	10c000c4 	addi	r3,r2,3
 d0227f8:	e0bffd04 	addi	r2,fp,-12
 d0227fc:	10800003 	ldbu	r2,0(r2)
 d022800:	18800005 	stb	r2,0(r3)
 d022804:	e0bff917 	ldw	r2,-28(fp)
 d022808:	10c00084 	addi	r3,r2,2
 d02280c:	e0bffd04 	addi	r2,fp,-12
 d022810:	10800044 	addi	r2,r2,1
 d022814:	10800003 	ldbu	r2,0(r2)
 d022818:	18800005 	stb	r2,0(r3)
 d02281c:	e0bff917 	ldw	r2,-28(fp)
 d022820:	10c00044 	addi	r3,r2,1
 d022824:	e0bffd04 	addi	r2,fp,-12
 d022828:	10800084 	addi	r2,r2,2
 d02282c:	10800003 	ldbu	r2,0(r2)
 d022830:	18800005 	stb	r2,0(r3)
 d022834:	e0bffd04 	addi	r2,fp,-12
 d022838:	108000c4 	addi	r2,r2,3
 d02283c:	10800003 	ldbu	r2,0(r2)
 d022840:	1007883a 	mov	r3,r2
 d022844:	e0bff917 	ldw	r2,-28(fp)
 d022848:	10c00005 	stb	r3,0(r2)
 d02284c:	e0bff917 	ldw	r2,-28(fp)
 d022850:	10800104 	addi	r2,r2,4
 d022854:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 d022858:	d0a03417 	ldw	r2,-32560(gp)
 d02285c:	10800050 	cmplti	r2,r2,1
 d022860:	10001e1e 	bne	r2,zero,d0228dc <dhc_discover+0x3f4>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 d022864:	e0fff917 	ldw	r3,-28(fp)
 d022868:	00800dc4 	movi	r2,55
 d02286c:	18800005 	stb	r2,0(r3)
 d022870:	e0bff917 	ldw	r2,-28(fp)
 d022874:	10800044 	addi	r2,r2,1
 d022878:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 d02287c:	d0a03417 	ldw	r2,-32560(gp)
 d022880:	1007883a 	mov	r3,r2
 d022884:	e0bff917 	ldw	r2,-28(fp)
 d022888:	10c00005 	stb	r3,0(r2)
 d02288c:	e0bff917 	ldw	r2,-28(fp)
 d022890:	10800044 	addi	r2,r2,1
 d022894:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 d022898:	e03ff715 	stw	zero,-36(fp)
 d02289c:	00000c06 	br	d0228d0 <dhc_discover+0x3e8>
         *opts++ = reqlist[i];
 d0228a0:	e0fff717 	ldw	r3,-36(fp)
 d0228a4:	d0a03304 	addi	r2,gp,-32564
 d0228a8:	1885883a 	add	r2,r3,r2
 d0228ac:	10c00003 	ldbu	r3,0(r2)
 d0228b0:	e0bff917 	ldw	r2,-28(fp)
 d0228b4:	10c00005 	stb	r3,0(r2)
 d0228b8:	e0bff917 	ldw	r2,-28(fp)
 d0228bc:	10800044 	addi	r2,r2,1
 d0228c0:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 d0228c4:	e0bff717 	ldw	r2,-36(fp)
 d0228c8:	10800044 	addi	r2,r2,1
 d0228cc:	e0bff715 	stw	r2,-36(fp)
 d0228d0:	d0e03417 	ldw	r3,-32560(gp)
 d0228d4:	e0bff717 	ldw	r2,-36(fp)
 d0228d8:	10fff116 	blt	r2,r3,d0228a0 <dhc_discover+0x3b8>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 d0228dc:	e0fff917 	ldw	r3,-28(fp)
 d0228e0:	00bfffc4 	movi	r2,-1
 d0228e4:	18800005 	stb	r2,0(r3)
 d0228e8:	e0bff917 	ldw	r2,-28(fp)
 d0228ec:	10800044 	addi	r2,r2,1
 d0228f0:	e0bff915 	stw	r2,-28(fp)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 d0228f4:	e13ffe17 	ldw	r4,-8(fp)
 d0228f8:	00834174 	movhi	r2,3333
 d0228fc:	109b4504 	addi	r2,r2,27924
 d022900:	14400017 	ldw	r17,0(r2)
 d022904:	040341b4 	movhi	r16,3334
 d022908:	84034004 	addi	r16,r16,3328
 d02290c:	01400f04 	movi	r5,60
 d022910:	d00235c0 	call	d00235c <__mulsi3>
 d022914:	1405883a 	add	r2,r2,r16
 d022918:	10800404 	addi	r2,r2,16
 d02291c:	14400015 	stw	r17,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 d022920:	e0fffb17 	ldw	r3,-20(fp)
 d022924:	00bfffc4 	movi	r2,-1
 d022928:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 d02292c:	e0bffe17 	ldw	r2,-8(fp)
 d022930:	00c341b4 	movhi	r3,3334
 d022934:	18c31a04 	addi	r3,r3,3176
 d022938:	1085883a 	add	r2,r2,r2
 d02293c:	1085883a 	add	r2,r2,r2
 d022940:	10c5883a 	add	r2,r2,r3
 d022944:	10c00017 	ldw	r3,0(r2)
 d022948:	e0bffb17 	ldw	r2,-20(fp)
 d02294c:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 d022950:	e13ffe17 	ldw	r4,-8(fp)
 d022954:	040341b4 	movhi	r16,3334
 d022958:	84034004 	addi	r16,r16,3328
 d02295c:	01400f04 	movi	r5,60
 d022960:	d00235c0 	call	d00235c <__mulsi3>
 d022964:	1405883a 	add	r2,r2,r16
 d022968:	10800017 	ldw	r2,0(r2)
 d02296c:	10800120 	cmpeqi	r2,r2,4
 d022970:	1000031e 	bne	r2,zero,d022980 <dhc_discover+0x498>
      dhc_set_state(iface, DHCS_SELECTING);
 d022974:	e13ffe17 	ldw	r4,-8(fp)
 d022978:	01400104 	movi	r5,4
 d02297c:	d0249e00 	call	d0249e0 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 d022980:	010010c4 	movi	r4,67
 d022984:	01401104 	movi	r5,68
 d022988:	e1bffb17 	ldw	r6,-20(fp)
 d02298c:	d044f640 	call	d044f64 <udp_send>
   dsc_discovers++;
 d022990:	d0a90f17 	ldw	r2,-23492(gp)
 d022994:	10800044 	addi	r2,r2,1
 d022998:	d0a90f15 	stw	r2,-23492(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 d02299c:	e13ffe17 	ldw	r4,-8(fp)
 d0229a0:	00834174 	movhi	r2,3333
 d0229a4:	109b4504 	addi	r2,r2,27924
 d0229a8:	14400017 	ldw	r17,0(r2)
 d0229ac:	040341b4 	movhi	r16,3334
 d0229b0:	84034004 	addi	r16,r16,3328
 d0229b4:	01400f04 	movi	r5,60
 d0229b8:	d00235c0 	call	d00235c <__mulsi3>
 d0229bc:	1405883a 	add	r2,r2,r16
 d0229c0:	10800404 	addi	r2,r2,16
 d0229c4:	14400015 	stw	r17,0(r2)
   dhc_states[iface].tries++;
 d0229c8:	e47ffe17 	ldw	r17,-8(fp)
 d0229cc:	040341b4 	movhi	r16,3334
 d0229d0:	84034004 	addi	r16,r16,3328
 d0229d4:	8809883a 	mov	r4,r17
 d0229d8:	01400f04 	movi	r5,60
 d0229dc:	d00235c0 	call	d00235c <__mulsi3>
 d0229e0:	1405883a 	add	r2,r2,r16
 d0229e4:	10800104 	addi	r2,r2,4
 d0229e8:	10800017 	ldw	r2,0(r2)
 d0229ec:	14800044 	addi	r18,r2,1
 d0229f0:	040341b4 	movhi	r16,3334
 d0229f4:	84034004 	addi	r16,r16,3328
 d0229f8:	8809883a 	mov	r4,r17
 d0229fc:	01400f04 	movi	r5,60
 d022a00:	d00235c0 	call	d00235c <__mulsi3>
 d022a04:	1405883a 	add	r2,r2,r16
 d022a08:	10800104 	addi	r2,r2,4
 d022a0c:	14800015 	stw	r18,0(r2)

   return 0;
 d022a10:	e03fff15 	stw	zero,-4(fp)
 d022a14:	e0bfff17 	ldw	r2,-4(fp)
}
 d022a18:	e037883a 	mov	sp,fp
 d022a1c:	dfc00417 	ldw	ra,16(sp)
 d022a20:	df000317 	ldw	fp,12(sp)
 d022a24:	dc800217 	ldw	r18,8(sp)
 d022a28:	dc400117 	ldw	r17,4(sp)
 d022a2c:	dc000017 	ldw	r16,0(sp)
 d022a30:	dec00504 	addi	sp,sp,20
 d022a34:	f800283a 	ret

0d022a38 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 d022a38:	defff604 	addi	sp,sp,-40
 d022a3c:	dfc00915 	stw	ra,36(sp)
 d022a40:	df000815 	stw	fp,32(sp)
 d022a44:	dc400715 	stw	r17,28(sp)
 d022a48:	dc000615 	stw	r16,24(sp)
 d022a4c:	df000604 	addi	fp,sp,24
 d022a50:	e13ffc15 	stw	r4,-16(fp)
 d022a54:	e17ffd15 	stw	r5,-12(fp)
 d022a58:	e1bffe15 	stw	r6,-8(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 d022a5c:	e13ffc17 	ldw	r4,-16(fp)
 d022a60:	040341b4 	movhi	r16,3334
 d022a64:	84034004 	addi	r16,r16,3328
 d022a68:	01400f04 	movi	r5,60
 d022a6c:	d00235c0 	call	d00235c <__mulsi3>
 d022a70:	1405883a 	add	r2,r2,r16
 d022a74:	10800204 	addi	r2,r2,8
 d022a78:	10c00017 	ldw	r3,0(r2)
 d022a7c:	e0bffd17 	ldw	r2,-12(fp)
 d022a80:	10800117 	ldw	r2,4(r2)
 d022a84:	18800326 	beq	r3,r2,d022a94 <dhc_rx_offer+0x5c>
      return ENP_NOT_MINE;
 d022a88:	00800084 	movi	r2,2
 d022a8c:	e0bfff15 	stw	r2,-4(fp)
 d022a90:	00002806 	br	d022b34 <dhc_rx_offer+0xfc>

   opts = &bp->options[4];    /* examine options after cookie */
 d022a94:	e0bffd17 	ldw	r2,-12(fp)
 d022a98:	10803b04 	addi	r2,r2,236
 d022a9c:	10800104 	addi	r2,r2,4
 d022aa0:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 d022aa4:	e13ffc17 	ldw	r4,-16(fp)
 d022aa8:	e17ffb17 	ldw	r5,-20(fp)
 d022aac:	d023cb00 	call	d023cb0 <dhc_extract_opts>
 d022ab0:	e0bffa15 	stw	r2,-24(fp)
   if (e)   /* parse error? */
 d022ab4:	e0bffa17 	ldw	r2,-24(fp)
 d022ab8:	1005003a 	cmpeq	r2,r2,zero
 d022abc:	1000041e 	bne	r2,zero,d022ad0 <dhc_rx_offer+0x98>
   {
      dtrap();
 d022ac0:	d025a500 	call	d025a50 <dtrap>
      return e;
 d022ac4:	e0bffa17 	ldw	r2,-24(fp)
 d022ac8:	e0bfff15 	stw	r2,-4(fp)
 d022acc:	00001906 	br	d022b34 <dhc_rx_offer+0xfc>
   }
   if (!bp->yiaddr)  /* require an IP address */
 d022ad0:	e0bffd17 	ldw	r2,-12(fp)
 d022ad4:	10800417 	ldw	r2,16(r2)
 d022ad8:	1004c03a 	cmpne	r2,r2,zero
 d022adc:	1000071e 	bne	r2,zero,d022afc <dhc_rx_offer+0xc4>
   {
      dhc_decline(iface,bp, bplen);
 d022ae0:	e13ffc17 	ldw	r4,-16(fp)
 d022ae4:	e17ffd17 	ldw	r5,-12(fp)
 d022ae8:	e1bffe17 	ldw	r6,-8(fp)
 d022aec:	d023acc0 	call	d023acc <dhc_decline>
      return ENP_NOT_MINE;
 d022af0:	00800084 	movi	r2,2
 d022af4:	e0bfff15 	stw	r2,-4(fp)
 d022af8:	00000e06 	br	d022b34 <dhc_rx_offer+0xfc>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 d022afc:	e13ffc17 	ldw	r4,-16(fp)
 d022b00:	e0bffd17 	ldw	r2,-12(fp)
 d022b04:	14400417 	ldw	r17,16(r2)
 d022b08:	040341b4 	movhi	r16,3334
 d022b0c:	84034004 	addi	r16,r16,3328
 d022b10:	01400f04 	movi	r5,60
 d022b14:	d00235c0 	call	d00235c <__mulsi3>
 d022b18:	1405883a 	add	r2,r2,r16
 d022b1c:	10800904 	addi	r2,r2,36
 d022b20:	14400015 	stw	r17,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 d022b24:	e13ffc17 	ldw	r4,-16(fp)
 d022b28:	000b883a 	mov	r5,zero
 d022b2c:	d022b540 	call	d022b54 <dhc_request>
 d022b30:	e0bfff15 	stw	r2,-4(fp)
 d022b34:	e0bfff17 	ldw	r2,-4(fp)
}
 d022b38:	e037883a 	mov	sp,fp
 d022b3c:	dfc00317 	ldw	ra,12(sp)
 d022b40:	df000217 	ldw	fp,8(sp)
 d022b44:	dc400117 	ldw	r17,4(sp)
 d022b48:	dc000017 	ldw	r16,0(sp)
 d022b4c:	dec00404 	addi	sp,sp,16
 d022b50:	f800283a 	ret

0d022b54 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 d022b54:	defff004 	addi	sp,sp,-64
 d022b58:	dfc00f15 	stw	ra,60(sp)
 d022b5c:	df000e15 	stw	fp,56(sp)
 d022b60:	dc800d15 	stw	r18,52(sp)
 d022b64:	dc400c15 	stw	r17,48(sp)
 d022b68:	dc000b15 	stw	r16,44(sp)
 d022b6c:	df000b04 	addi	fp,sp,44
 d022b70:	e13ffd15 	stw	r4,-12(fp)
 d022b74:	e17ffe15 	stw	r5,-8(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 d022b78:	01008904 	movi	r4,548
 d022b7c:	000b883a 	mov	r5,zero
 d022b80:	d04541c0 	call	d04541c <udp_alloc>
 d022b84:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 d022b88:	e0bffa17 	ldw	r2,-24(fp)
 d022b8c:	1004c03a 	cmpne	r2,r2,zero
 d022b90:	1000031e 	bne	r2,zero,d022ba0 <dhc_request+0x4c>
      return ENP_NOMEM;
 d022b94:	00bffb04 	movi	r2,-20
 d022b98:	e0bfff15 	stw	r2,-4(fp)
 d022b9c:	0002e106 	br	d023724 <dhc_request+0xbd0>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 d022ba0:	e0fffa17 	ldw	r3,-24(fp)
 d022ba4:	00803b04 	movi	r2,236
 d022ba8:	18800415 	stw	r2,16(r3)

   if ( xid_flag == TRUE )
 d022bac:	e0bffe17 	ldw	r2,-8(fp)
 d022bb0:	10800058 	cmpnei	r2,r2,1
 d022bb4:	1000141e 	bne	r2,zero,d022c08 <dhc_request+0xb4>
   {
      dhc_states[iface].xid  = xids++;
 d022bb8:	e13ffd17 	ldw	r4,-12(fp)
 d022bbc:	d4603217 	ldw	r17,-32568(gp)
 d022bc0:	8825883a 	mov	r18,r17
 d022bc4:	040341b4 	movhi	r16,3334
 d022bc8:	84034004 	addi	r16,r16,3328
 d022bcc:	01400f04 	movi	r5,60
 d022bd0:	d00235c0 	call	d00235c <__mulsi3>
 d022bd4:	1405883a 	add	r2,r2,r16
 d022bd8:	10800204 	addi	r2,r2,8
 d022bdc:	14800015 	stw	r18,0(r2)
 d022be0:	88800044 	addi	r2,r17,1
 d022be4:	d0a03215 	stw	r2,-32568(gp)
      dhc_states[iface].secs = 0;
 d022be8:	e13ffd17 	ldw	r4,-12(fp)
 d022bec:	040341b4 	movhi	r16,3334
 d022bf0:	84034004 	addi	r16,r16,3328
 d022bf4:	01400f04 	movi	r5,60
 d022bf8:	d00235c0 	call	d00235c <__mulsi3>
 d022bfc:	1405883a 	add	r2,r2,r16
 d022c00:	10800304 	addi	r2,r2,12
 d022c04:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 d022c08:	e0bffa17 	ldw	r2,-24(fp)
 d022c0c:	10800317 	ldw	r2,12(r2)
 d022c10:	e0bffb15 	stw	r2,-20(fp)
   e     = dhc_buildheader(iface,outbp);
 d022c14:	e13ffd17 	ldw	r4,-12(fp)
 d022c18:	e17ffb17 	ldw	r5,-20(fp)
 d022c1c:	d0222b80 	call	d0222b8 <dhc_buildheader>
 d022c20:	e0bff815 	stw	r2,-32(fp)
   if (e)
 d022c24:	e0bff817 	ldw	r2,-32(fp)
 d022c28:	1005003a 	cmpeq	r2,r2,zero
 d022c2c:	1000031e 	bne	r2,zero,d022c3c <dhc_request+0xe8>
      return e;
 d022c30:	e0bff817 	ldw	r2,-32(fp)
 d022c34:	e0bfff15 	stw	r2,-4(fp)
 d022c38:	0002ba06 	br	d023724 <dhc_request+0xbd0>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 d022c3c:	e0bffb17 	ldw	r2,-20(fp)
 d022c40:	10803b04 	addi	r2,r2,236
 d022c44:	1007883a 	mov	r3,r2
 d022c48:	0098d534 	movhi	r2,25428
 d022c4c:	10a098c4 	addi	r2,r2,-32157
 d022c50:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 d022c54:	e0bffb17 	ldw	r2,-20(fp)
 d022c58:	10803b04 	addi	r2,r2,236
 d022c5c:	10800104 	addi	r2,r2,4
 d022c60:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 d022c64:	e0fff917 	ldw	r3,-28(fp)
 d022c68:	00800d44 	movi	r2,53
 d022c6c:	18800005 	stb	r2,0(r3)
 d022c70:	e0bff917 	ldw	r2,-28(fp)
 d022c74:	10800044 	addi	r2,r2,1
 d022c78:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 d022c7c:	e0fff917 	ldw	r3,-28(fp)
 d022c80:	00800044 	movi	r2,1
 d022c84:	18800005 	stb	r2,0(r3)
 d022c88:	e0bff917 	ldw	r2,-28(fp)
 d022c8c:	10800044 	addi	r2,r2,1
 d022c90:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_REQUEST;
 d022c94:	e0fff917 	ldw	r3,-28(fp)
 d022c98:	008000c4 	movi	r2,3
 d022c9c:	18800005 	stb	r2,0(r3)
 d022ca0:	e0bff917 	ldw	r2,-28(fp)
 d022ca4:	10800044 	addi	r2,r2,1
 d022ca8:	e0bff915 	stw	r2,-28(fp)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 d022cac:	e13ffd17 	ldw	r4,-12(fp)
 d022cb0:	040341b4 	movhi	r16,3334
 d022cb4:	84034004 	addi	r16,r16,3328
 d022cb8:	01400f04 	movi	r5,60
 d022cbc:	d00235c0 	call	d00235c <__mulsi3>
 d022cc0:	1405883a 	add	r2,r2,r16
 d022cc4:	10800017 	ldw	r2,0(r2)
 d022cc8:	10800120 	cmpeqi	r2,r2,4
 d022ccc:	10001b1e 	bne	r2,zero,d022d3c <dhc_request+0x1e8>
 d022cd0:	e13ffd17 	ldw	r4,-12(fp)
 d022cd4:	040341b4 	movhi	r16,3334
 d022cd8:	84034004 	addi	r16,r16,3328
 d022cdc:	01400f04 	movi	r5,60
 d022ce0:	d00235c0 	call	d00235c <__mulsi3>
 d022ce4:	1405883a 	add	r2,r2,r16
 d022ce8:	10800017 	ldw	r2,0(r2)
 d022cec:	10800160 	cmpeqi	r2,r2,5
 d022cf0:	1000121e 	bne	r2,zero,d022d3c <dhc_request+0x1e8>
 d022cf4:	e13ffd17 	ldw	r4,-12(fp)
 d022cf8:	040341b4 	movhi	r16,3334
 d022cfc:	84034004 	addi	r16,r16,3328
 d022d00:	01400f04 	movi	r5,60
 d022d04:	d00235c0 	call	d00235c <__mulsi3>
 d022d08:	1405883a 	add	r2,r2,r16
 d022d0c:	10800017 	ldw	r2,0(r2)
 d022d10:	108000e0 	cmpeqi	r2,r2,3
 d022d14:	1000091e 	bne	r2,zero,d022d3c <dhc_request+0x1e8>
 d022d18:	e13ffd17 	ldw	r4,-12(fp)
 d022d1c:	040341b4 	movhi	r16,3334
 d022d20:	84034004 	addi	r16,r16,3328
 d022d24:	01400f04 	movi	r5,60
 d022d28:	d00235c0 	call	d00235c <__mulsi3>
 d022d2c:	1405883a 	add	r2,r2,r16
 d022d30:	10800017 	ldw	r2,0(r2)
 d022d34:	10800098 	cmpnei	r2,r2,2
 d022d38:	1000521e 	bne	r2,zero,d022e84 <dhc_request+0x330>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 d022d3c:	e13ffd17 	ldw	r4,-12(fp)
 d022d40:	040341b4 	movhi	r16,3334
 d022d44:	84034004 	addi	r16,r16,3328
 d022d48:	01400f04 	movi	r5,60
 d022d4c:	d00235c0 	call	d00235c <__mulsi3>
 d022d50:	1405883a 	add	r2,r2,r16
 d022d54:	10800904 	addi	r2,r2,36
 d022d58:	10800017 	ldw	r2,0(r2)
 d022d5c:	1004d63a 	srli	r2,r2,24
 d022d60:	14403fcc 	andi	r17,r2,255
 d022d64:	e13ffd17 	ldw	r4,-12(fp)
 d022d68:	040341b4 	movhi	r16,3334
 d022d6c:	84034004 	addi	r16,r16,3328
 d022d70:	01400f04 	movi	r5,60
 d022d74:	d00235c0 	call	d00235c <__mulsi3>
 d022d78:	1405883a 	add	r2,r2,r16
 d022d7c:	10800904 	addi	r2,r2,36
 d022d80:	10800017 	ldw	r2,0(r2)
 d022d84:	1004d23a 	srli	r2,r2,8
 d022d88:	10bfc00c 	andi	r2,r2,65280
 d022d8c:	88a2b03a 	or	r17,r17,r2
 d022d90:	e13ffd17 	ldw	r4,-12(fp)
 d022d94:	040341b4 	movhi	r16,3334
 d022d98:	84034004 	addi	r16,r16,3328
 d022d9c:	01400f04 	movi	r5,60
 d022da0:	d00235c0 	call	d00235c <__mulsi3>
 d022da4:	1405883a 	add	r2,r2,r16
 d022da8:	10800904 	addi	r2,r2,36
 d022dac:	10800017 	ldw	r2,0(r2)
 d022db0:	10bfc00c 	andi	r2,r2,65280
 d022db4:	1004923a 	slli	r2,r2,8
 d022db8:	88a2b03a 	or	r17,r17,r2
 d022dbc:	e13ffd17 	ldw	r4,-12(fp)
 d022dc0:	040341b4 	movhi	r16,3334
 d022dc4:	84034004 	addi	r16,r16,3328
 d022dc8:	01400f04 	movi	r5,60
 d022dcc:	d00235c0 	call	d00235c <__mulsi3>
 d022dd0:	1405883a 	add	r2,r2,r16
 d022dd4:	10800904 	addi	r2,r2,36
 d022dd8:	10800017 	ldw	r2,0(r2)
 d022ddc:	10803fcc 	andi	r2,r2,255
 d022de0:	1004963a 	slli	r2,r2,24
 d022de4:	8884b03a 	or	r2,r17,r2
 d022de8:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 d022dec:	e0fff917 	ldw	r3,-28(fp)
 d022df0:	00800c84 	movi	r2,50
 d022df4:	18800005 	stb	r2,0(r3)
 d022df8:	e0bff917 	ldw	r2,-28(fp)
 d022dfc:	10800044 	addi	r2,r2,1
 d022e00:	e0bff915 	stw	r2,-28(fp)
 d022e04:	e0fff917 	ldw	r3,-28(fp)
 d022e08:	00800104 	movi	r2,4
 d022e0c:	18800005 	stb	r2,0(r3)
 d022e10:	e0bff917 	ldw	r2,-28(fp)
 d022e14:	10800044 	addi	r2,r2,1
 d022e18:	e0bff915 	stw	r2,-28(fp)
 d022e1c:	e0bff917 	ldw	r2,-28(fp)
 d022e20:	10c000c4 	addi	r3,r2,3
 d022e24:	e0bffc04 	addi	r2,fp,-16
 d022e28:	10800003 	ldbu	r2,0(r2)
 d022e2c:	18800005 	stb	r2,0(r3)
 d022e30:	e0bff917 	ldw	r2,-28(fp)
 d022e34:	10c00084 	addi	r3,r2,2
 d022e38:	e0bffc04 	addi	r2,fp,-16
 d022e3c:	10800044 	addi	r2,r2,1
 d022e40:	10800003 	ldbu	r2,0(r2)
 d022e44:	18800005 	stb	r2,0(r3)
 d022e48:	e0bff917 	ldw	r2,-28(fp)
 d022e4c:	10c00044 	addi	r3,r2,1
 d022e50:	e0bffc04 	addi	r2,fp,-16
 d022e54:	10800084 	addi	r2,r2,2
 d022e58:	10800003 	ldbu	r2,0(r2)
 d022e5c:	18800005 	stb	r2,0(r3)
 d022e60:	e0bffc04 	addi	r2,fp,-16
 d022e64:	108000c4 	addi	r2,r2,3
 d022e68:	10800003 	ldbu	r2,0(r2)
 d022e6c:	1007883a 	mov	r3,r2
 d022e70:	e0bff917 	ldw	r2,-28(fp)
 d022e74:	10c00005 	stb	r3,0(r2)
 d022e78:	e0bff917 	ldw	r2,-28(fp)
 d022e7c:	10800104 	addi	r2,r2,4
 d022e80:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].snmask)
 d022e84:	e13ffd17 	ldw	r4,-12(fp)
 d022e88:	040341b4 	movhi	r16,3334
 d022e8c:	84034004 	addi	r16,r16,3328
 d022e90:	01400f04 	movi	r5,60
 d022e94:	d00235c0 	call	d00235c <__mulsi3>
 d022e98:	1405883a 	add	r2,r2,r16
 d022e9c:	10800a04 	addi	r2,r2,40
 d022ea0:	10800017 	ldw	r2,0(r2)
 d022ea4:	1005003a 	cmpeq	r2,r2,zero
 d022ea8:	1000521e 	bne	r2,zero,d022ff4 <dhc_request+0x4a0>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 d022eac:	e13ffd17 	ldw	r4,-12(fp)
 d022eb0:	040341b4 	movhi	r16,3334
 d022eb4:	84034004 	addi	r16,r16,3328
 d022eb8:	01400f04 	movi	r5,60
 d022ebc:	d00235c0 	call	d00235c <__mulsi3>
 d022ec0:	1405883a 	add	r2,r2,r16
 d022ec4:	10800a04 	addi	r2,r2,40
 d022ec8:	10800017 	ldw	r2,0(r2)
 d022ecc:	1004d63a 	srli	r2,r2,24
 d022ed0:	14403fcc 	andi	r17,r2,255
 d022ed4:	e13ffd17 	ldw	r4,-12(fp)
 d022ed8:	040341b4 	movhi	r16,3334
 d022edc:	84034004 	addi	r16,r16,3328
 d022ee0:	01400f04 	movi	r5,60
 d022ee4:	d00235c0 	call	d00235c <__mulsi3>
 d022ee8:	1405883a 	add	r2,r2,r16
 d022eec:	10800a04 	addi	r2,r2,40
 d022ef0:	10800017 	ldw	r2,0(r2)
 d022ef4:	1004d23a 	srli	r2,r2,8
 d022ef8:	10bfc00c 	andi	r2,r2,65280
 d022efc:	88a2b03a 	or	r17,r17,r2
 d022f00:	e13ffd17 	ldw	r4,-12(fp)
 d022f04:	040341b4 	movhi	r16,3334
 d022f08:	84034004 	addi	r16,r16,3328
 d022f0c:	01400f04 	movi	r5,60
 d022f10:	d00235c0 	call	d00235c <__mulsi3>
 d022f14:	1405883a 	add	r2,r2,r16
 d022f18:	10800a04 	addi	r2,r2,40
 d022f1c:	10800017 	ldw	r2,0(r2)
 d022f20:	10bfc00c 	andi	r2,r2,65280
 d022f24:	1004923a 	slli	r2,r2,8
 d022f28:	88a2b03a 	or	r17,r17,r2
 d022f2c:	e13ffd17 	ldw	r4,-12(fp)
 d022f30:	040341b4 	movhi	r16,3334
 d022f34:	84034004 	addi	r16,r16,3328
 d022f38:	01400f04 	movi	r5,60
 d022f3c:	d00235c0 	call	d00235c <__mulsi3>
 d022f40:	1405883a 	add	r2,r2,r16
 d022f44:	10800a04 	addi	r2,r2,40
 d022f48:	10800017 	ldw	r2,0(r2)
 d022f4c:	10803fcc 	andi	r2,r2,255
 d022f50:	1004963a 	slli	r2,r2,24
 d022f54:	8884b03a 	or	r2,r17,r2
 d022f58:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 d022f5c:	e0fff917 	ldw	r3,-28(fp)
 d022f60:	00800044 	movi	r2,1
 d022f64:	18800005 	stb	r2,0(r3)
 d022f68:	e0bff917 	ldw	r2,-28(fp)
 d022f6c:	10800044 	addi	r2,r2,1
 d022f70:	e0bff915 	stw	r2,-28(fp)
 d022f74:	e0fff917 	ldw	r3,-28(fp)
 d022f78:	00800104 	movi	r2,4
 d022f7c:	18800005 	stb	r2,0(r3)
 d022f80:	e0bff917 	ldw	r2,-28(fp)
 d022f84:	10800044 	addi	r2,r2,1
 d022f88:	e0bff915 	stw	r2,-28(fp)
 d022f8c:	e0bff917 	ldw	r2,-28(fp)
 d022f90:	10c000c4 	addi	r3,r2,3
 d022f94:	e0bffc04 	addi	r2,fp,-16
 d022f98:	10800003 	ldbu	r2,0(r2)
 d022f9c:	18800005 	stb	r2,0(r3)
 d022fa0:	e0bff917 	ldw	r2,-28(fp)
 d022fa4:	10c00084 	addi	r3,r2,2
 d022fa8:	e0bffc04 	addi	r2,fp,-16
 d022fac:	10800044 	addi	r2,r2,1
 d022fb0:	10800003 	ldbu	r2,0(r2)
 d022fb4:	18800005 	stb	r2,0(r3)
 d022fb8:	e0bff917 	ldw	r2,-28(fp)
 d022fbc:	10c00044 	addi	r3,r2,1
 d022fc0:	e0bffc04 	addi	r2,fp,-16
 d022fc4:	10800084 	addi	r2,r2,2
 d022fc8:	10800003 	ldbu	r2,0(r2)
 d022fcc:	18800005 	stb	r2,0(r3)
 d022fd0:	e0bffc04 	addi	r2,fp,-16
 d022fd4:	108000c4 	addi	r2,r2,3
 d022fd8:	10800003 	ldbu	r2,0(r2)
 d022fdc:	1007883a 	mov	r3,r2
 d022fe0:	e0bff917 	ldw	r2,-28(fp)
 d022fe4:	10c00005 	stb	r3,0(r2)
 d022fe8:	e0bff917 	ldw	r2,-28(fp)
 d022fec:	10800104 	addi	r2,r2,4
 d022ff0:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].defgw)
 d022ff4:	e13ffd17 	ldw	r4,-12(fp)
 d022ff8:	040341b4 	movhi	r16,3334
 d022ffc:	84034004 	addi	r16,r16,3328
 d023000:	01400f04 	movi	r5,60
 d023004:	d00235c0 	call	d00235c <__mulsi3>
 d023008:	1405883a 	add	r2,r2,r16
 d02300c:	10800b04 	addi	r2,r2,44
 d023010:	10800017 	ldw	r2,0(r2)
 d023014:	1005003a 	cmpeq	r2,r2,zero
 d023018:	1000521e 	bne	r2,zero,d023164 <dhc_request+0x610>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 d02301c:	e13ffd17 	ldw	r4,-12(fp)
 d023020:	040341b4 	movhi	r16,3334
 d023024:	84034004 	addi	r16,r16,3328
 d023028:	01400f04 	movi	r5,60
 d02302c:	d00235c0 	call	d00235c <__mulsi3>
 d023030:	1405883a 	add	r2,r2,r16
 d023034:	10800b04 	addi	r2,r2,44
 d023038:	10800017 	ldw	r2,0(r2)
 d02303c:	1004d63a 	srli	r2,r2,24
 d023040:	14403fcc 	andi	r17,r2,255
 d023044:	e13ffd17 	ldw	r4,-12(fp)
 d023048:	040341b4 	movhi	r16,3334
 d02304c:	84034004 	addi	r16,r16,3328
 d023050:	01400f04 	movi	r5,60
 d023054:	d00235c0 	call	d00235c <__mulsi3>
 d023058:	1405883a 	add	r2,r2,r16
 d02305c:	10800b04 	addi	r2,r2,44
 d023060:	10800017 	ldw	r2,0(r2)
 d023064:	1004d23a 	srli	r2,r2,8
 d023068:	10bfc00c 	andi	r2,r2,65280
 d02306c:	88a2b03a 	or	r17,r17,r2
 d023070:	e13ffd17 	ldw	r4,-12(fp)
 d023074:	040341b4 	movhi	r16,3334
 d023078:	84034004 	addi	r16,r16,3328
 d02307c:	01400f04 	movi	r5,60
 d023080:	d00235c0 	call	d00235c <__mulsi3>
 d023084:	1405883a 	add	r2,r2,r16
 d023088:	10800b04 	addi	r2,r2,44
 d02308c:	10800017 	ldw	r2,0(r2)
 d023090:	10bfc00c 	andi	r2,r2,65280
 d023094:	1004923a 	slli	r2,r2,8
 d023098:	88a2b03a 	or	r17,r17,r2
 d02309c:	e13ffd17 	ldw	r4,-12(fp)
 d0230a0:	040341b4 	movhi	r16,3334
 d0230a4:	84034004 	addi	r16,r16,3328
 d0230a8:	01400f04 	movi	r5,60
 d0230ac:	d00235c0 	call	d00235c <__mulsi3>
 d0230b0:	1405883a 	add	r2,r2,r16
 d0230b4:	10800b04 	addi	r2,r2,44
 d0230b8:	10800017 	ldw	r2,0(r2)
 d0230bc:	10803fcc 	andi	r2,r2,255
 d0230c0:	1004963a 	slli	r2,r2,24
 d0230c4:	8884b03a 	or	r2,r17,r2
 d0230c8:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 d0230cc:	e0fff917 	ldw	r3,-28(fp)
 d0230d0:	008000c4 	movi	r2,3
 d0230d4:	18800005 	stb	r2,0(r3)
 d0230d8:	e0bff917 	ldw	r2,-28(fp)
 d0230dc:	10800044 	addi	r2,r2,1
 d0230e0:	e0bff915 	stw	r2,-28(fp)
 d0230e4:	e0fff917 	ldw	r3,-28(fp)
 d0230e8:	00800104 	movi	r2,4
 d0230ec:	18800005 	stb	r2,0(r3)
 d0230f0:	e0bff917 	ldw	r2,-28(fp)
 d0230f4:	10800044 	addi	r2,r2,1
 d0230f8:	e0bff915 	stw	r2,-28(fp)
 d0230fc:	e0bff917 	ldw	r2,-28(fp)
 d023100:	10c000c4 	addi	r3,r2,3
 d023104:	e0bffc04 	addi	r2,fp,-16
 d023108:	10800003 	ldbu	r2,0(r2)
 d02310c:	18800005 	stb	r2,0(r3)
 d023110:	e0bff917 	ldw	r2,-28(fp)
 d023114:	10c00084 	addi	r3,r2,2
 d023118:	e0bffc04 	addi	r2,fp,-16
 d02311c:	10800044 	addi	r2,r2,1
 d023120:	10800003 	ldbu	r2,0(r2)
 d023124:	18800005 	stb	r2,0(r3)
 d023128:	e0bff917 	ldw	r2,-28(fp)
 d02312c:	10c00044 	addi	r3,r2,1
 d023130:	e0bffc04 	addi	r2,fp,-16
 d023134:	10800084 	addi	r2,r2,2
 d023138:	10800003 	ldbu	r2,0(r2)
 d02313c:	18800005 	stb	r2,0(r3)
 d023140:	e0bffc04 	addi	r2,fp,-16
 d023144:	108000c4 	addi	r2,r2,3
 d023148:	10800003 	ldbu	r2,0(r2)
 d02314c:	1007883a 	mov	r3,r2
 d023150:	e0bff917 	ldw	r2,-28(fp)
 d023154:	10c00005 	stb	r3,0(r2)
 d023158:	e0bff917 	ldw	r2,-28(fp)
 d02315c:	10800104 	addi	r2,r2,4
 d023160:	e0bff915 	stw	r2,-28(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 d023164:	e13ffd17 	ldw	r4,-12(fp)
 d023168:	040341b4 	movhi	r16,3334
 d02316c:	84034004 	addi	r16,r16,3328
 d023170:	01400f04 	movi	r5,60
 d023174:	d00235c0 	call	d00235c <__mulsi3>
 d023178:	1405883a 	add	r2,r2,r16
 d02317c:	10800504 	addi	r2,r2,20
 d023180:	10800017 	ldw	r2,0(r2)
 d023184:	1005003a 	cmpeq	r2,r2,zero
 d023188:	10003e1e 	bne	r2,zero,d023284 <dhc_request+0x730>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 d02318c:	e0fff917 	ldw	r3,-28(fp)
 d023190:	00800cc4 	movi	r2,51
 d023194:	18800005 	stb	r2,0(r3)
 d023198:	e0bff917 	ldw	r2,-28(fp)
 d02319c:	10800044 	addi	r2,r2,1
 d0231a0:	e0bff915 	stw	r2,-28(fp)
 d0231a4:	e0fff917 	ldw	r3,-28(fp)
 d0231a8:	00800104 	movi	r2,4
 d0231ac:	18800005 	stb	r2,0(r3)
 d0231b0:	e0bff917 	ldw	r2,-28(fp)
 d0231b4:	10800044 	addi	r2,r2,1
 d0231b8:	e0bff915 	stw	r2,-28(fp)
 d0231bc:	e0bff917 	ldw	r2,-28(fp)
 d0231c0:	140000c4 	addi	r16,r2,3
 d0231c4:	e13ffd17 	ldw	r4,-12(fp)
 d0231c8:	01400f04 	movi	r5,60
 d0231cc:	d00235c0 	call	d00235c <__mulsi3>
 d0231d0:	10c00504 	addi	r3,r2,20
 d0231d4:	008341b4 	movhi	r2,3334
 d0231d8:	10834004 	addi	r2,r2,3328
 d0231dc:	1885883a 	add	r2,r3,r2
 d0231e0:	10800003 	ldbu	r2,0(r2)
 d0231e4:	80800005 	stb	r2,0(r16)
 d0231e8:	e0bff917 	ldw	r2,-28(fp)
 d0231ec:	14000084 	addi	r16,r2,2
 d0231f0:	e13ffd17 	ldw	r4,-12(fp)
 d0231f4:	01400f04 	movi	r5,60
 d0231f8:	d00235c0 	call	d00235c <__mulsi3>
 d0231fc:	10c00504 	addi	r3,r2,20
 d023200:	008341b4 	movhi	r2,3334
 d023204:	10834004 	addi	r2,r2,3328
 d023208:	1885883a 	add	r2,r3,r2
 d02320c:	10800044 	addi	r2,r2,1
 d023210:	10800003 	ldbu	r2,0(r2)
 d023214:	80800005 	stb	r2,0(r16)
 d023218:	e0bff917 	ldw	r2,-28(fp)
 d02321c:	14000044 	addi	r16,r2,1
 d023220:	e13ffd17 	ldw	r4,-12(fp)
 d023224:	01400f04 	movi	r5,60
 d023228:	d00235c0 	call	d00235c <__mulsi3>
 d02322c:	10c00504 	addi	r3,r2,20
 d023230:	008341b4 	movhi	r2,3334
 d023234:	10834004 	addi	r2,r2,3328
 d023238:	1885883a 	add	r2,r3,r2
 d02323c:	10800084 	addi	r2,r2,2
 d023240:	10800003 	ldbu	r2,0(r2)
 d023244:	80800005 	stb	r2,0(r16)
 d023248:	e13ffd17 	ldw	r4,-12(fp)
 d02324c:	01400f04 	movi	r5,60
 d023250:	d00235c0 	call	d00235c <__mulsi3>
 d023254:	10c00504 	addi	r3,r2,20
 d023258:	008341b4 	movhi	r2,3334
 d02325c:	10834004 	addi	r2,r2,3328
 d023260:	1885883a 	add	r2,r3,r2
 d023264:	108000c4 	addi	r2,r2,3
 d023268:	10800003 	ldbu	r2,0(r2)
 d02326c:	1007883a 	mov	r3,r2
 d023270:	e0bff917 	ldw	r2,-28(fp)
 d023274:	10c00005 	stb	r3,0(r2)
 d023278:	e0bff917 	ldw	r2,-28(fp)
 d02327c:	10800104 	addi	r2,r2,4
 d023280:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 d023284:	d0a03417 	ldw	r2,-32560(gp)
 d023288:	10800050 	cmplti	r2,r2,1
 d02328c:	10001e1e 	bne	r2,zero,d023308 <dhc_request+0x7b4>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 d023290:	e0fff917 	ldw	r3,-28(fp)
 d023294:	00800dc4 	movi	r2,55
 d023298:	18800005 	stb	r2,0(r3)
 d02329c:	e0bff917 	ldw	r2,-28(fp)
 d0232a0:	10800044 	addi	r2,r2,1
 d0232a4:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 d0232a8:	d0a03417 	ldw	r2,-32560(gp)
 d0232ac:	1007883a 	mov	r3,r2
 d0232b0:	e0bff917 	ldw	r2,-28(fp)
 d0232b4:	10c00005 	stb	r3,0(r2)
 d0232b8:	e0bff917 	ldw	r2,-28(fp)
 d0232bc:	10800044 	addi	r2,r2,1
 d0232c0:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 d0232c4:	e03ff715 	stw	zero,-36(fp)
 d0232c8:	00000c06 	br	d0232fc <dhc_request+0x7a8>
         *opts++ = reqlist[i];
 d0232cc:	e0fff717 	ldw	r3,-36(fp)
 d0232d0:	d0a03304 	addi	r2,gp,-32564
 d0232d4:	1885883a 	add	r2,r3,r2
 d0232d8:	10c00003 	ldbu	r3,0(r2)
 d0232dc:	e0bff917 	ldw	r2,-28(fp)
 d0232e0:	10c00005 	stb	r3,0(r2)
 d0232e4:	e0bff917 	ldw	r2,-28(fp)
 d0232e8:	10800044 	addi	r2,r2,1
 d0232ec:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 d0232f0:	e0bff717 	ldw	r2,-36(fp)
 d0232f4:	10800044 	addi	r2,r2,1
 d0232f8:	e0bff715 	stw	r2,-36(fp)
 d0232fc:	d0e03417 	ldw	r3,-32560(gp)
 d023300:	e0bff717 	ldw	r2,-36(fp)
 d023304:	10fff116 	blt	r2,r3,d0232cc <dhc_request+0x778>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 d023308:	e13ffd17 	ldw	r4,-12(fp)
 d02330c:	040341b4 	movhi	r16,3334
 d023310:	84034004 	addi	r16,r16,3328
 d023314:	01400f04 	movi	r5,60
 d023318:	d00235c0 	call	d00235c <__mulsi3>
 d02331c:	1405883a 	add	r2,r2,r16
 d023320:	10800017 	ldw	r2,0(r2)
 d023324:	108001e0 	cmpeqi	r2,r2,7
 d023328:	1000091e 	bne	r2,zero,d023350 <dhc_request+0x7fc>
 d02332c:	e13ffd17 	ldw	r4,-12(fp)
 d023330:	040341b4 	movhi	r16,3334
 d023334:	84034004 	addi	r16,r16,3328
 d023338:	01400f04 	movi	r5,60
 d02333c:	d00235c0 	call	d00235c <__mulsi3>
 d023340:	1405883a 	add	r2,r2,r16
 d023344:	10800017 	ldw	r2,0(r2)
 d023348:	10800218 	cmpnei	r2,r2,8
 d02334c:	10000a1e 	bne	r2,zero,d023378 <dhc_request+0x824>
       || (dhc_states[iface].state == DHCS_REBINDING))
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 d023350:	e0bffd17 	ldw	r2,-12(fp)
 d023354:	00c341b4 	movhi	r3,3334
 d023358:	18c31a04 	addi	r3,r3,3176
 d02335c:	1085883a 	add	r2,r2,r2
 d023360:	1085883a 	add	r2,r2,r2
 d023364:	10c5883a 	add	r2,r2,r3
 d023368:	10800017 	ldw	r2,0(r2)
 d02336c:	10c00a17 	ldw	r3,40(r2)
 d023370:	e0bffb17 	ldw	r2,-20(fp)
 d023374:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 d023378:	e13ffd17 	ldw	r4,-12(fp)
 d02337c:	040341b4 	movhi	r16,3334
 d023380:	84034004 	addi	r16,r16,3328
 d023384:	01400f04 	movi	r5,60
 d023388:	d00235c0 	call	d00235c <__mulsi3>
 d02338c:	1405883a 	add	r2,r2,r16
 d023390:	10800017 	ldw	r2,0(r2)
 d023394:	10800120 	cmpeqi	r2,r2,4
 d023398:	1000091e 	bne	r2,zero,d0233c0 <dhc_request+0x86c>
 d02339c:	e13ffd17 	ldw	r4,-12(fp)
 d0233a0:	040341b4 	movhi	r16,3334
 d0233a4:	84034004 	addi	r16,r16,3328
 d0233a8:	01400f04 	movi	r5,60
 d0233ac:	d00235c0 	call	d00235c <__mulsi3>
 d0233b0:	1405883a 	add	r2,r2,r16
 d0233b4:	10800017 	ldw	r2,0(r2)
 d0233b8:	10800158 	cmpnei	r2,r2,5
 d0233bc:	1000521e 	bne	r2,zero,d023508 <dhc_request+0x9b4>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 d0233c0:	e13ffd17 	ldw	r4,-12(fp)
 d0233c4:	040341b4 	movhi	r16,3334
 d0233c8:	84034004 	addi	r16,r16,3328
 d0233cc:	01400f04 	movi	r5,60
 d0233d0:	d00235c0 	call	d00235c <__mulsi3>
 d0233d4:	1405883a 	add	r2,r2,r16
 d0233d8:	10800d04 	addi	r2,r2,52
 d0233dc:	10800017 	ldw	r2,0(r2)
 d0233e0:	1004d63a 	srli	r2,r2,24
 d0233e4:	14403fcc 	andi	r17,r2,255
 d0233e8:	e13ffd17 	ldw	r4,-12(fp)
 d0233ec:	040341b4 	movhi	r16,3334
 d0233f0:	84034004 	addi	r16,r16,3328
 d0233f4:	01400f04 	movi	r5,60
 d0233f8:	d00235c0 	call	d00235c <__mulsi3>
 d0233fc:	1405883a 	add	r2,r2,r16
 d023400:	10800d04 	addi	r2,r2,52
 d023404:	10800017 	ldw	r2,0(r2)
 d023408:	1004d23a 	srli	r2,r2,8
 d02340c:	10bfc00c 	andi	r2,r2,65280
 d023410:	88a2b03a 	or	r17,r17,r2
 d023414:	e13ffd17 	ldw	r4,-12(fp)
 d023418:	040341b4 	movhi	r16,3334
 d02341c:	84034004 	addi	r16,r16,3328
 d023420:	01400f04 	movi	r5,60
 d023424:	d00235c0 	call	d00235c <__mulsi3>
 d023428:	1405883a 	add	r2,r2,r16
 d02342c:	10800d04 	addi	r2,r2,52
 d023430:	10800017 	ldw	r2,0(r2)
 d023434:	10bfc00c 	andi	r2,r2,65280
 d023438:	1004923a 	slli	r2,r2,8
 d02343c:	88a2b03a 	or	r17,r17,r2
 d023440:	e13ffd17 	ldw	r4,-12(fp)
 d023444:	040341b4 	movhi	r16,3334
 d023448:	84034004 	addi	r16,r16,3328
 d02344c:	01400f04 	movi	r5,60
 d023450:	d00235c0 	call	d00235c <__mulsi3>
 d023454:	1405883a 	add	r2,r2,r16
 d023458:	10800d04 	addi	r2,r2,52
 d02345c:	10800017 	ldw	r2,0(r2)
 d023460:	10803fcc 	andi	r2,r2,255
 d023464:	1004963a 	slli	r2,r2,24
 d023468:	8884b03a 	or	r2,r17,r2
 d02346c:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 d023470:	e0fff917 	ldw	r3,-28(fp)
 d023474:	00800d84 	movi	r2,54
 d023478:	18800005 	stb	r2,0(r3)
 d02347c:	e0bff917 	ldw	r2,-28(fp)
 d023480:	10800044 	addi	r2,r2,1
 d023484:	e0bff915 	stw	r2,-28(fp)
 d023488:	e0fff917 	ldw	r3,-28(fp)
 d02348c:	00800104 	movi	r2,4
 d023490:	18800005 	stb	r2,0(r3)
 d023494:	e0bff917 	ldw	r2,-28(fp)
 d023498:	10800044 	addi	r2,r2,1
 d02349c:	e0bff915 	stw	r2,-28(fp)
 d0234a0:	e0bff917 	ldw	r2,-28(fp)
 d0234a4:	10c000c4 	addi	r3,r2,3
 d0234a8:	e0bffc04 	addi	r2,fp,-16
 d0234ac:	10800003 	ldbu	r2,0(r2)
 d0234b0:	18800005 	stb	r2,0(r3)
 d0234b4:	e0bff917 	ldw	r2,-28(fp)
 d0234b8:	10c00084 	addi	r3,r2,2
 d0234bc:	e0bffc04 	addi	r2,fp,-16
 d0234c0:	10800044 	addi	r2,r2,1
 d0234c4:	10800003 	ldbu	r2,0(r2)
 d0234c8:	18800005 	stb	r2,0(r3)
 d0234cc:	e0bff917 	ldw	r2,-28(fp)
 d0234d0:	10c00044 	addi	r3,r2,1
 d0234d4:	e0bffc04 	addi	r2,fp,-16
 d0234d8:	10800084 	addi	r2,r2,2
 d0234dc:	10800003 	ldbu	r2,0(r2)
 d0234e0:	18800005 	stb	r2,0(r3)
 d0234e4:	e0bffc04 	addi	r2,fp,-16
 d0234e8:	108000c4 	addi	r2,r2,3
 d0234ec:	10800003 	ldbu	r2,0(r2)
 d0234f0:	1007883a 	mov	r3,r2
 d0234f4:	e0bff917 	ldw	r2,-28(fp)
 d0234f8:	10c00005 	stb	r3,0(r2)
 d0234fc:	e0bff917 	ldw	r2,-28(fp)
 d023500:	10800104 	addi	r2,r2,4
 d023504:	e0bff915 	stw	r2,-28(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 d023508:	e0fff917 	ldw	r3,-28(fp)
 d02350c:	00801444 	movi	r2,81
 d023510:	18800005 	stb	r2,0(r3)
 d023514:	e0bff917 	ldw	r2,-28(fp)
 d023518:	10800044 	addi	r2,r2,1
 d02351c:	e0bff915 	stw	r2,-28(fp)
 d023520:	00800184 	movi	r2,6
 d023524:	e0bff615 	stw	r2,-40(fp)
 d023528:	e0bff617 	ldw	r2,-40(fp)
 d02352c:	1007883a 	mov	r3,r2
 d023530:	e0bff917 	ldw	r2,-28(fp)
 d023534:	10c00005 	stb	r3,0(r2)
 d023538:	e0bff917 	ldw	r2,-28(fp)
 d02353c:	10800044 	addi	r2,r2,1
 d023540:	e0bff915 	stw	r2,-28(fp)
 d023544:	e13ff917 	ldw	r4,-28(fp)
 d023548:	e1bff617 	ldw	r6,-40(fp)
 d02354c:	01434174 	movhi	r5,3333
 d023550:	297d2504 	addi	r5,r5,-2924
 d023554:	d04c0340 	call	d04c034 <strncpy>
 d023558:	e0bff617 	ldw	r2,-40(fp)
 d02355c:	1007883a 	mov	r3,r2
 d023560:	e0bff917 	ldw	r2,-28(fp)
 d023564:	10c5883a 	add	r2,r2,r3
 d023568:	e0bff915 	stw	r2,-28(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 d02356c:	e0fff917 	ldw	r3,-28(fp)
 d023570:	00800f04 	movi	r2,60
 d023574:	18800005 	stb	r2,0(r3)
 d023578:	e0bff917 	ldw	r2,-28(fp)
 d02357c:	10800044 	addi	r2,r2,1
 d023580:	e0bff915 	stw	r2,-28(fp)
 d023584:	00834174 	movhi	r2,3333
 d023588:	10926a04 	addi	r2,r2,18856
 d02358c:	11000017 	ldw	r4,0(r2)
 d023590:	d0034640 	call	d003464 <strlen>
 d023594:	e0bff515 	stw	r2,-44(fp)
 d023598:	e0bff517 	ldw	r2,-44(fp)
 d02359c:	1007883a 	mov	r3,r2
 d0235a0:	e0bff917 	ldw	r2,-28(fp)
 d0235a4:	10c00005 	stb	r3,0(r2)
 d0235a8:	e0bff917 	ldw	r2,-28(fp)
 d0235ac:	10800044 	addi	r2,r2,1
 d0235b0:	e0bff915 	stw	r2,-28(fp)
 d0235b4:	e13ff917 	ldw	r4,-28(fp)
 d0235b8:	00834174 	movhi	r2,3333
 d0235bc:	10926a04 	addi	r2,r2,18856
 d0235c0:	11400017 	ldw	r5,0(r2)
 d0235c4:	e1bff517 	ldw	r6,-44(fp)
 d0235c8:	d04c0340 	call	d04c034 <strncpy>
 d0235cc:	e0bff517 	ldw	r2,-44(fp)
 d0235d0:	1007883a 	mov	r3,r2
 d0235d4:	e0bff917 	ldw	r2,-28(fp)
 d0235d8:	10c5883a 	add	r2,r2,r3
 d0235dc:	e0bff915 	stw	r2,-28(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 d0235e0:	e0fff917 	ldw	r3,-28(fp)
 d0235e4:	00bfffc4 	movi	r2,-1
 d0235e8:	18800005 	stb	r2,0(r3)
 d0235ec:	e0bff917 	ldw	r2,-28(fp)
 d0235f0:	10800044 	addi	r2,r2,1
 d0235f4:	e0bff915 	stw	r2,-28(fp)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 d0235f8:	e13ffd17 	ldw	r4,-12(fp)
 d0235fc:	040341b4 	movhi	r16,3334
 d023600:	84034004 	addi	r16,r16,3328
 d023604:	01400f04 	movi	r5,60
 d023608:	d00235c0 	call	d00235c <__mulsi3>
 d02360c:	1405883a 	add	r2,r2,r16
 d023610:	10800017 	ldw	r2,0(r2)
 d023614:	108001d8 	cmpnei	r2,r2,7
 d023618:	10000b1e 	bne	r2,zero,d023648 <dhc_request+0xaf4>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 d02361c:	e13ffd17 	ldw	r4,-12(fp)
 d023620:	040341b4 	movhi	r16,3334
 d023624:	84034004 	addi	r16,r16,3328
 d023628:	01400f04 	movi	r5,60
 d02362c:	d00235c0 	call	d00235c <__mulsi3>
 d023630:	1405883a 	add	r2,r2,r16
 d023634:	10800d04 	addi	r2,r2,52
 d023638:	10c00017 	ldw	r3,0(r2)
 d02363c:	e0bffa17 	ldw	r2,-24(fp)
 d023640:	10c00715 	stw	r3,28(r2)
 d023644:	00000306 	br	d023654 <dhc_request+0xb00>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 d023648:	e0fffa17 	ldw	r3,-24(fp)
 d02364c:	00bfffc4 	movi	r2,-1
 d023650:	18800715 	stw	r2,28(r3)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 d023654:	e0bffd17 	ldw	r2,-12(fp)
 d023658:	00c341b4 	movhi	r3,3334
 d02365c:	18c31a04 	addi	r3,r3,3176
 d023660:	1085883a 	add	r2,r2,r2
 d023664:	1085883a 	add	r2,r2,r2
 d023668:	10c5883a 	add	r2,r2,r3
 d02366c:	10c00017 	ldw	r3,0(r2)
 d023670:	e0bffa17 	ldw	r2,-24(fp)
 d023674:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 d023678:	e0fff917 	ldw	r3,-28(fp)
 d02367c:	e0bffb17 	ldw	r2,-20(fp)
 d023680:	1885c83a 	sub	r2,r3,r2
 d023684:	1007883a 	mov	r3,r2
 d023688:	e0bffa17 	ldw	r2,-24(fp)
 d02368c:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 d023690:	010010c4 	movi	r4,67
 d023694:	01401104 	movi	r5,68
 d023698:	e1bffa17 	ldw	r6,-24(fp)
 d02369c:	d044f640 	call	d044f64 <udp_send>
   dsc_requests++;
 d0236a0:	d0a91117 	ldw	r2,-23484(gp)
 d0236a4:	10800044 	addi	r2,r2,1
 d0236a8:	d0a91115 	stw	r2,-23484(gp)

   dhc_states[iface].last_tick = cticks;
 d0236ac:	e13ffd17 	ldw	r4,-12(fp)
 d0236b0:	00834174 	movhi	r2,3333
 d0236b4:	109b4504 	addi	r2,r2,27924
 d0236b8:	14400017 	ldw	r17,0(r2)
 d0236bc:	040341b4 	movhi	r16,3334
 d0236c0:	84034004 	addi	r16,r16,3328
 d0236c4:	01400f04 	movi	r5,60
 d0236c8:	d00235c0 	call	d00235c <__mulsi3>
 d0236cc:	1405883a 	add	r2,r2,r16
 d0236d0:	10800404 	addi	r2,r2,16
 d0236d4:	14400015 	stw	r17,0(r2)
   dhc_states[iface].tries++;
 d0236d8:	e47ffd17 	ldw	r17,-12(fp)
 d0236dc:	040341b4 	movhi	r16,3334
 d0236e0:	84034004 	addi	r16,r16,3328
 d0236e4:	8809883a 	mov	r4,r17
 d0236e8:	01400f04 	movi	r5,60
 d0236ec:	d00235c0 	call	d00235c <__mulsi3>
 d0236f0:	1405883a 	add	r2,r2,r16
 d0236f4:	10800104 	addi	r2,r2,4
 d0236f8:	10800017 	ldw	r2,0(r2)
 d0236fc:	14800044 	addi	r18,r2,1
 d023700:	040341b4 	movhi	r16,3334
 d023704:	84034004 	addi	r16,r16,3328
 d023708:	8809883a 	mov	r4,r17
 d02370c:	01400f04 	movi	r5,60
 d023710:	d00235c0 	call	d00235c <__mulsi3>
 d023714:	1405883a 	add	r2,r2,r16
 d023718:	10800104 	addi	r2,r2,4
 d02371c:	14800015 	stw	r18,0(r2)

   return 0;   /* return OK code */
 d023720:	e03fff15 	stw	zero,-4(fp)
 d023724:	e0bfff17 	ldw	r2,-4(fp)
}
 d023728:	e037883a 	mov	sp,fp
 d02372c:	dfc00417 	ldw	ra,16(sp)
 d023730:	df000317 	ldw	fp,12(sp)
 d023734:	dc800217 	ldw	r18,8(sp)
 d023738:	dc400117 	ldw	r17,4(sp)
 d02373c:	dc000017 	ldw	r16,0(sp)
 d023740:	dec00504 	addi	sp,sp,20
 d023744:	f800283a 	ret

0d023748 <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 d023748:	defffb04 	addi	sp,sp,-20
 d02374c:	dfc00415 	stw	ra,16(sp)
 d023750:	df000315 	stw	fp,12(sp)
 d023754:	dc400215 	stw	r17,8(sp)
 d023758:	dc000115 	stw	r16,4(sp)
 d02375c:	df000104 	addi	fp,sp,4
 d023760:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 d023764:	e0bfff17 	ldw	r2,-4(fp)
 d023768:	00c341b4 	movhi	r3,3334
 d02376c:	18c31a04 	addi	r3,r3,3176
 d023770:	1085883a 	add	r2,r2,r2
 d023774:	1085883a 	add	r2,r2,r2
 d023778:	10c5883a 	add	r2,r2,r3
 d02377c:	14400017 	ldw	r17,0(r2)
 d023780:	e13fff17 	ldw	r4,-4(fp)
 d023784:	040341b4 	movhi	r16,3334
 d023788:	84034004 	addi	r16,r16,3328
 d02378c:	01400f04 	movi	r5,60
 d023790:	d00235c0 	call	d00235c <__mulsi3>
 d023794:	1405883a 	add	r2,r2,r16
 d023798:	10800904 	addi	r2,r2,36
 d02379c:	10800017 	ldw	r2,0(r2)
 d0237a0:	88800a15 	stw	r2,40(r17)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 d0237a4:	e0bfff17 	ldw	r2,-4(fp)
 d0237a8:	00c341b4 	movhi	r3,3334
 d0237ac:	18c31a04 	addi	r3,r3,3176
 d0237b0:	1085883a 	add	r2,r2,r2
 d0237b4:	1085883a 	add	r2,r2,r2
 d0237b8:	10c5883a 	add	r2,r2,r3
 d0237bc:	14400017 	ldw	r17,0(r2)
 d0237c0:	e13fff17 	ldw	r4,-4(fp)
 d0237c4:	040341b4 	movhi	r16,3334
 d0237c8:	84034004 	addi	r16,r16,3328
 d0237cc:	01400f04 	movi	r5,60
 d0237d0:	d00235c0 	call	d00235c <__mulsi3>
 d0237d4:	1405883a 	add	r2,r2,r16
 d0237d8:	10800a04 	addi	r2,r2,40
 d0237dc:	10800017 	ldw	r2,0(r2)
 d0237e0:	88800c15 	stw	r2,48(r17)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 d0237e4:	e0bfff17 	ldw	r2,-4(fp)
 d0237e8:	00c341b4 	movhi	r3,3334
 d0237ec:	18c31a04 	addi	r3,r3,3176
 d0237f0:	1085883a 	add	r2,r2,r2
 d0237f4:	1085883a 	add	r2,r2,r2
 d0237f8:	10c5883a 	add	r2,r2,r3
 d0237fc:	14400017 	ldw	r17,0(r2)
 d023800:	e13fff17 	ldw	r4,-4(fp)
 d023804:	040341b4 	movhi	r16,3334
 d023808:	84034004 	addi	r16,r16,3328
 d02380c:	01400f04 	movi	r5,60
 d023810:	d00235c0 	call	d00235c <__mulsi3>
 d023814:	1405883a 	add	r2,r2,r16
 d023818:	10800b04 	addi	r2,r2,44
 d02381c:	10800017 	ldw	r2,0(r2)
 d023820:	88800d15 	stw	r2,52(r17)

   if ( nets[iface]->snmask == 0 )
 d023824:	e0bfff17 	ldw	r2,-4(fp)
 d023828:	00c341b4 	movhi	r3,3334
 d02382c:	18c31a04 	addi	r3,r3,3176
 d023830:	1085883a 	add	r2,r2,r2
 d023834:	1085883a 	add	r2,r2,r2
 d023838:	10c5883a 	add	r2,r2,r3
 d02383c:	10800017 	ldw	r2,0(r2)
 d023840:	10800c17 	ldw	r2,48(r2)
 d023844:	1004c03a 	cmpne	r2,r2,zero
 d023848:	1000121e 	bne	r2,zero,d023894 <dhc_setip+0x14c>
   {
      fixup_subnet_mask(iface);
 d02384c:	e13fff17 	ldw	r4,-4(fp)
 d023850:	d01dbd00 	call	d01dbd0 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 d023854:	e13fff17 	ldw	r4,-4(fp)
 d023858:	e0bfff17 	ldw	r2,-4(fp)
 d02385c:	00c341b4 	movhi	r3,3334
 d023860:	18c31a04 	addi	r3,r3,3176
 d023864:	1085883a 	add	r2,r2,r2
 d023868:	1085883a 	add	r2,r2,r2
 d02386c:	10c5883a 	add	r2,r2,r3
 d023870:	10800017 	ldw	r2,0(r2)
 d023874:	14400c17 	ldw	r17,48(r2)
 d023878:	040341b4 	movhi	r16,3334
 d02387c:	84034004 	addi	r16,r16,3328
 d023880:	01400f04 	movi	r5,60
 d023884:	d00235c0 	call	d00235c <__mulsi3>
 d023888:	1405883a 	add	r2,r2,r16
 d02388c:	10800a04 	addi	r2,r2,40
 d023890:	14400015 	stw	r17,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 d023894:	e0bfff17 	ldw	r2,-4(fp)
 d023898:	00c341b4 	movhi	r3,3334
 d02389c:	18c31a04 	addi	r3,r3,3176
 d0238a0:	1085883a 	add	r2,r2,r2
 d0238a4:	1085883a 	add	r2,r2,r2
 d0238a8:	10c5883a 	add	r2,r2,r3
 d0238ac:	11400017 	ldw	r5,0(r2)
 d0238b0:	e0bfff17 	ldw	r2,-4(fp)
 d0238b4:	00c341b4 	movhi	r3,3334
 d0238b8:	18c31a04 	addi	r3,r3,3176
 d0238bc:	1085883a 	add	r2,r2,r2
 d0238c0:	1085883a 	add	r2,r2,r2
 d0238c4:	10c5883a 	add	r2,r2,r3
 d0238c8:	10800017 	ldw	r2,0(r2)
 d0238cc:	11000a17 	ldw	r4,40(r2)
 d0238d0:	e0bfff17 	ldw	r2,-4(fp)
 d0238d4:	00c341b4 	movhi	r3,3334
 d0238d8:	18c31a04 	addi	r3,r3,3176
 d0238dc:	1085883a 	add	r2,r2,r2
 d0238e0:	1085883a 	add	r2,r2,r2
 d0238e4:	10c5883a 	add	r2,r2,r3
 d0238e8:	10800017 	ldw	r2,0(r2)
 d0238ec:	10800c17 	ldw	r2,48(r2)
 d0238f0:	0084303a 	nor	r2,zero,r2
 d0238f4:	2084b03a 	or	r2,r4,r2
 d0238f8:	28800e15 	stw	r2,56(r5)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 d0238fc:	e0bfff17 	ldw	r2,-4(fp)
 d023900:	00c341b4 	movhi	r3,3334
 d023904:	18c31a04 	addi	r3,r3,3176
 d023908:	1085883a 	add	r2,r2,r2
 d02390c:	1085883a 	add	r2,r2,r2
 d023910:	10c5883a 	add	r2,r2,r3
 d023914:	11400017 	ldw	r5,0(r2)
 d023918:	e0bfff17 	ldw	r2,-4(fp)
 d02391c:	00c341b4 	movhi	r3,3334
 d023920:	18c31a04 	addi	r3,r3,3176
 d023924:	1085883a 	add	r2,r2,r2
 d023928:	1085883a 	add	r2,r2,r2
 d02392c:	10c5883a 	add	r2,r2,r3
 d023930:	10800017 	ldw	r2,0(r2)
 d023934:	11000a17 	ldw	r4,40(r2)
 d023938:	e0bfff17 	ldw	r2,-4(fp)
 d02393c:	00c341b4 	movhi	r3,3334
 d023940:	18c31a04 	addi	r3,r3,3176
 d023944:	1085883a 	add	r2,r2,r2
 d023948:	1085883a 	add	r2,r2,r2
 d02394c:	10c5883a 	add	r2,r2,r3
 d023950:	10800017 	ldw	r2,0(r2)
 d023954:	10800c17 	ldw	r2,48(r2)
 d023958:	2084703a 	and	r2,r4,r2
 d02395c:	28800f15 	stw	r2,60(r5)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 d023960:	e0bfff17 	ldw	r2,-4(fp)
 d023964:	00c341b4 	movhi	r3,3334
 d023968:	18c31a04 	addi	r3,r3,3176
 d02396c:	1085883a 	add	r2,r2,r2
 d023970:	1085883a 	add	r2,r2,r2
 d023974:	10c5883a 	add	r2,r2,r3
 d023978:	11400017 	ldw	r5,0(r2)
 d02397c:	e0bfff17 	ldw	r2,-4(fp)
 d023980:	00c341b4 	movhi	r3,3334
 d023984:	18c31a04 	addi	r3,r3,3176
 d023988:	1085883a 	add	r2,r2,r2
 d02398c:	1085883a 	add	r2,r2,r2
 d023990:	10c5883a 	add	r2,r2,r3
 d023994:	10800017 	ldw	r2,0(r2)
 d023998:	11000a17 	ldw	r4,40(r2)
 d02399c:	e0bfff17 	ldw	r2,-4(fp)
 d0239a0:	00c341b4 	movhi	r3,3334
 d0239a4:	18c31a04 	addi	r3,r3,3176
 d0239a8:	1085883a 	add	r2,r2,r2
 d0239ac:	1085883a 	add	r2,r2,r2
 d0239b0:	10c5883a 	add	r2,r2,r3
 d0239b4:	10800017 	ldw	r2,0(r2)
 d0239b8:	10800c17 	ldw	r2,48(r2)
 d0239bc:	0084303a 	nor	r2,zero,r2
 d0239c0:	2084b03a 	or	r2,r4,r2
 d0239c4:	28801015 	stw	r2,64(r5)

   return 0;   /* return OK code */
 d0239c8:	0005883a 	mov	r2,zero
}
 d0239cc:	e037883a 	mov	sp,fp
 d0239d0:	dfc00317 	ldw	ra,12(sp)
 d0239d4:	df000217 	ldw	fp,8(sp)
 d0239d8:	dc400117 	ldw	r17,4(sp)
 d0239dc:	dc000017 	ldw	r16,0(sp)
 d0239e0:	dec00404 	addi	sp,sp,16
 d0239e4:	f800283a 	ret

0d0239e8 <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 d0239e8:	defffe04 	addi	sp,sp,-8
 d0239ec:	df000115 	stw	fp,4(sp)
 d0239f0:	df000104 	addi	fp,sp,4
 d0239f4:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 d0239f8:	e0bfff17 	ldw	r2,-4(fp)
 d0239fc:	00c341b4 	movhi	r3,3334
 d023a00:	18c31a04 	addi	r3,r3,3176
 d023a04:	1085883a 	add	r2,r2,r2
 d023a08:	1085883a 	add	r2,r2,r2
 d023a0c:	10c5883a 	add	r2,r2,r3
 d023a10:	10800017 	ldw	r2,0(r2)
 d023a14:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 d023a18:	e0bfff17 	ldw	r2,-4(fp)
 d023a1c:	00c341b4 	movhi	r3,3334
 d023a20:	18c31a04 	addi	r3,r3,3176
 d023a24:	1085883a 	add	r2,r2,r2
 d023a28:	1085883a 	add	r2,r2,r2
 d023a2c:	10c5883a 	add	r2,r2,r3
 d023a30:	10800017 	ldw	r2,0(r2)
 d023a34:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 d023a38:	e0bfff17 	ldw	r2,-4(fp)
 d023a3c:	00c341b4 	movhi	r3,3334
 d023a40:	18c31a04 	addi	r3,r3,3176
 d023a44:	1085883a 	add	r2,r2,r2
 d023a48:	1085883a 	add	r2,r2,r2
 d023a4c:	10c5883a 	add	r2,r2,r3
 d023a50:	10800017 	ldw	r2,0(r2)
 d023a54:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 d023a58:	e0bfff17 	ldw	r2,-4(fp)
 d023a5c:	00c341b4 	movhi	r3,3334
 d023a60:	18c31a04 	addi	r3,r3,3176
 d023a64:	1085883a 	add	r2,r2,r2
 d023a68:	1085883a 	add	r2,r2,r2
 d023a6c:	10c5883a 	add	r2,r2,r3
 d023a70:	10800017 	ldw	r2,0(r2)
 d023a74:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 d023a78:	e0bfff17 	ldw	r2,-4(fp)
 d023a7c:	00c341b4 	movhi	r3,3334
 d023a80:	18c31a04 	addi	r3,r3,3176
 d023a84:	1085883a 	add	r2,r2,r2
 d023a88:	1085883a 	add	r2,r2,r2
 d023a8c:	10c5883a 	add	r2,r2,r3
 d023a90:	10800017 	ldw	r2,0(r2)
 d023a94:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 d023a98:	e0bfff17 	ldw	r2,-4(fp)
 d023a9c:	00c341b4 	movhi	r3,3334
 d023aa0:	18c31a04 	addi	r3,r3,3176
 d023aa4:	1085883a 	add	r2,r2,r2
 d023aa8:	1085883a 	add	r2,r2,r2
 d023aac:	10c5883a 	add	r2,r2,r3
 d023ab0:	10800017 	ldw	r2,0(r2)
 d023ab4:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 d023ab8:	0005883a 	mov	r2,zero
}
 d023abc:	e037883a 	mov	sp,fp
 d023ac0:	df000017 	ldw	fp,0(sp)
 d023ac4:	dec00104 	addi	sp,sp,4
 d023ac8:	f800283a 	ret

0d023acc <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 d023acc:	defff704 	addi	sp,sp,-36
 d023ad0:	dfc00815 	stw	ra,32(sp)
 d023ad4:	df000715 	stw	fp,28(sp)
 d023ad8:	df000704 	addi	fp,sp,28
 d023adc:	e13ffc15 	stw	r4,-16(fp)
 d023ae0:	e17ffd15 	stw	r5,-12(fp)
 d023ae4:	e1bffe15 	stw	r6,-8(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 d023ae8:	e13ffe17 	ldw	r4,-8(fp)
 d023aec:	000b883a 	mov	r5,zero
 d023af0:	d04541c0 	call	d04541c <udp_alloc>
 d023af4:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 d023af8:	e0bffa17 	ldw	r2,-24(fp)
 d023afc:	1004c03a 	cmpne	r2,r2,zero
 d023b00:	1000031e 	bne	r2,zero,d023b10 <dhc_decline+0x44>
      return ENP_NOMEM;
 d023b04:	00bffb04 	movi	r2,-20
 d023b08:	e0bfff15 	stw	r2,-4(fp)
 d023b0c:	00002f06 	br	d023bcc <dhc_decline+0x100>
   pkt->nb_plen = bplen;
 d023b10:	e0fffa17 	ldw	r3,-24(fp)
 d023b14:	e0bffe17 	ldw	r2,-8(fp)
 d023b18:	18800415 	stw	r2,16(r3)

   outbp = (struct bootp *)pkt->nb_prot;
 d023b1c:	e0bffa17 	ldw	r2,-24(fp)
 d023b20:	10800317 	ldw	r2,12(r2)
 d023b24:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 d023b28:	e0bffb17 	ldw	r2,-20(fp)
 d023b2c:	e0fffd17 	ldw	r3,-12(fp)
 d023b30:	1009883a 	mov	r4,r2
 d023b34:	180b883a 	mov	r5,r3
 d023b38:	e1bffe17 	ldw	r6,-8(fp)
 d023b3c:	d0026080 	call	d002608 <memcpy>
   outbp->op = BOOTREQUEST;
 d023b40:	e0fffb17 	ldw	r3,-20(fp)
 d023b44:	00800044 	movi	r2,1
 d023b48:	18800005 	stb	r2,0(r3)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 d023b4c:	e0bffb17 	ldw	r2,-20(fp)
 d023b50:	10803b04 	addi	r2,r2,236
 d023b54:	11400104 	addi	r5,r2,4
 d023b58:	01000d44 	movi	r4,53
 d023b5c:	d024ab00 	call	d024ab0 <find_opt>
 d023b60:	e0bff915 	stw	r2,-28(fp)
   opts += 2;     /* point to actual op code */
 d023b64:	e0bff917 	ldw	r2,-28(fp)
 d023b68:	10800084 	addi	r2,r2,2
 d023b6c:	e0bff915 	stw	r2,-28(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 d023b70:	e0fff917 	ldw	r3,-28(fp)
 d023b74:	00800104 	movi	r2,4
 d023b78:	18800005 	stb	r2,0(r3)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 d023b7c:	e0fffa17 	ldw	r3,-24(fp)
 d023b80:	00bfffc4 	movi	r2,-1
 d023b84:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller speced net */
 d023b88:	e0bffc17 	ldw	r2,-16(fp)
 d023b8c:	00c341b4 	movhi	r3,3334
 d023b90:	18c31a04 	addi	r3,r3,3176
 d023b94:	1085883a 	add	r2,r2,r2
 d023b98:	1085883a 	add	r2,r2,r2
 d023b9c:	10c5883a 	add	r2,r2,r3
 d023ba0:	10c00017 	ldw	r3,0(r2)
 d023ba4:	e0bffa17 	ldw	r2,-24(fp)
 d023ba8:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 d023bac:	010010c4 	movi	r4,67
 d023bb0:	01401104 	movi	r5,68
 d023bb4:	e1bffa17 	ldw	r6,-24(fp)
 d023bb8:	d044f640 	call	d044f64 <udp_send>
   dsc_declines++;   /* count declines sent */
 d023bbc:	d0a91417 	ldw	r2,-23472(gp)
 d023bc0:	10800044 	addi	r2,r2,1
 d023bc4:	d0a91415 	stw	r2,-23472(gp)
   return 0;
 d023bc8:	e03fff15 	stw	zero,-4(fp)
 d023bcc:	e0bfff17 	ldw	r2,-4(fp)
}
 d023bd0:	e037883a 	mov	sp,fp
 d023bd4:	dfc00117 	ldw	ra,4(sp)
 d023bd8:	df000017 	ldw	fp,0(sp)
 d023bdc:	dec00204 	addi	sp,sp,8
 d023be0:	f800283a 	ret

0d023be4 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 d023be4:	defffc04 	addi	sp,sp,-16
 d023be8:	df000315 	stw	fp,12(sp)
 d023bec:	df000304 	addi	fp,sp,12
 d023bf0:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 d023bf4:	e0bffe04 	addi	r2,fp,-8
 d023bf8:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 d023bfc:	e0bfff17 	ldw	r2,-4(fp)
 d023c00:	10c00003 	ldbu	r3,0(r2)
 d023c04:	e0bffd17 	ldw	r2,-12(fp)
 d023c08:	10c00005 	stb	r3,0(r2)
 d023c0c:	e0bffd17 	ldw	r2,-12(fp)
 d023c10:	10800044 	addi	r2,r2,1
 d023c14:	e0bffd15 	stw	r2,-12(fp)
 d023c18:	e0bfff17 	ldw	r2,-4(fp)
 d023c1c:	10800044 	addi	r2,r2,1
 d023c20:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 d023c24:	e0bfff17 	ldw	r2,-4(fp)
 d023c28:	10c00003 	ldbu	r3,0(r2)
 d023c2c:	e0bffd17 	ldw	r2,-12(fp)
 d023c30:	10c00005 	stb	r3,0(r2)
 d023c34:	e0bffd17 	ldw	r2,-12(fp)
 d023c38:	10800044 	addi	r2,r2,1
 d023c3c:	e0bffd15 	stw	r2,-12(fp)
 d023c40:	e0bfff17 	ldw	r2,-4(fp)
 d023c44:	10800044 	addi	r2,r2,1
 d023c48:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 d023c4c:	e0bfff17 	ldw	r2,-4(fp)
 d023c50:	10c00003 	ldbu	r3,0(r2)
 d023c54:	e0bffd17 	ldw	r2,-12(fp)
 d023c58:	10c00005 	stb	r3,0(r2)
 d023c5c:	e0bffd17 	ldw	r2,-12(fp)
 d023c60:	10800044 	addi	r2,r2,1
 d023c64:	e0bffd15 	stw	r2,-12(fp)
 d023c68:	e0bfff17 	ldw	r2,-4(fp)
 d023c6c:	10800044 	addi	r2,r2,1
 d023c70:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 d023c74:	e0bfff17 	ldw	r2,-4(fp)
 d023c78:	10c00003 	ldbu	r3,0(r2)
 d023c7c:	e0bffd17 	ldw	r2,-12(fp)
 d023c80:	10c00005 	stb	r3,0(r2)
 d023c84:	e0bffd17 	ldw	r2,-12(fp)
 d023c88:	10800044 	addi	r2,r2,1
 d023c8c:	e0bffd15 	stw	r2,-12(fp)
 d023c90:	e0bfff17 	ldw	r2,-4(fp)
 d023c94:	10800044 	addi	r2,r2,1
 d023c98:	e0bfff15 	stw	r2,-4(fp)

   return v;
 d023c9c:	e0bffe17 	ldw	r2,-8(fp)
}
 d023ca0:	e037883a 	mov	sp,fp
 d023ca4:	df000017 	ldw	fp,0(sp)
 d023ca8:	dec00104 	addi	sp,sp,4
 d023cac:	f800283a 	ret

0d023cb0 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 d023cb0:	defff504 	addi	sp,sp,-44
 d023cb4:	dfc00a15 	stw	ra,40(sp)
 d023cb8:	df000915 	stw	fp,36(sp)
 d023cbc:	dc800815 	stw	r18,32(sp)
 d023cc0:	dc400715 	stw	r17,28(sp)
 d023cc4:	dc000615 	stw	r16,24(sp)
 d023cc8:	df000604 	addi	fp,sp,24
 d023ccc:	e13ffc15 	stw	r4,-16(fp)
 d023cd0:	e17ffd15 	stw	r5,-12(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 d023cd4:	e0bffd17 	ldw	r2,-12(fp)
 d023cd8:	10804e04 	addi	r2,r2,312
 d023cdc:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 d023ce0:	e13ffc17 	ldw	r4,-16(fp)
 d023ce4:	040341b4 	movhi	r16,3334
 d023ce8:	84034004 	addi	r16,r16,3328
 d023cec:	01400f04 	movi	r5,60
 d023cf0:	d00235c0 	call	d00235c <__mulsi3>
 d023cf4:	1405883a 	add	r2,r2,r16
 d023cf8:	10800a04 	addi	r2,r2,40
 d023cfc:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 d023d00:	e13ffc17 	ldw	r4,-16(fp)
 d023d04:	040341b4 	movhi	r16,3334
 d023d08:	84034004 	addi	r16,r16,3328
 d023d0c:	01400f04 	movi	r5,60
 d023d10:	d00235c0 	call	d00235c <__mulsi3>
 d023d14:	1405883a 	add	r2,r2,r16
 d023d18:	10800b04 	addi	r2,r2,44
 d023d1c:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 d023d20:	e13ffc17 	ldw	r4,-16(fp)
 d023d24:	040341b4 	movhi	r16,3334
 d023d28:	84034004 	addi	r16,r16,3328
 d023d2c:	01400f04 	movi	r5,60
 d023d30:	d00235c0 	call	d00235c <__mulsi3>
 d023d34:	1405883a 	add	r2,r2,r16
 d023d38:	10800504 	addi	r2,r2,20
 d023d3c:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 d023d40:	00008606 	br	d023f5c <dhc_extract_opts+0x2ac>
   {
      switch (*opts++)
 d023d44:	e0bffd17 	ldw	r2,-12(fp)
 d023d48:	10800003 	ldbu	r2,0(r2)
 d023d4c:	10803fcc 	andi	r2,r2,255
 d023d50:	e0bfff15 	stw	r2,-4(fp)
 d023d54:	e0bffd17 	ldw	r2,-12(fp)
 d023d58:	10800044 	addi	r2,r2,1
 d023d5c:	e0bffd15 	stw	r2,-12(fp)
 d023d60:	e0ffff17 	ldw	r3,-4(fp)
 d023d64:	188000e0 	cmpeqi	r2,r3,3
 d023d68:	1000291e 	bne	r2,zero,d023e10 <dhc_extract_opts+0x160>
 d023d6c:	e0ffff17 	ldw	r3,-4(fp)
 d023d70:	18800108 	cmpgei	r2,r3,4
 d023d74:	1000071e 	bne	r2,zero,d023d94 <dhc_extract_opts+0xe4>
 d023d78:	e0ffff17 	ldw	r3,-4(fp)
 d023d7c:	1805003a 	cmpeq	r2,r3,zero
 d023d80:	1000761e 	bne	r2,zero,d023f5c <dhc_extract_opts+0x2ac>
 d023d84:	e0ffff17 	ldw	r3,-4(fp)
 d023d88:	18800060 	cmpeqi	r2,r3,1
 d023d8c:	10000d1e 	bne	r2,zero,d023dc4 <dhc_extract_opts+0x114>
 d023d90:	00006a06 	br	d023f3c <dhc_extract_opts+0x28c>
 d023d94:	e0ffff17 	ldw	r3,-4(fp)
 d023d98:	18800ce0 	cmpeqi	r2,r3,51
 d023d9c:	1000371e 	bne	r2,zero,d023e7c <dhc_extract_opts+0x1cc>
 d023da0:	e0ffff17 	ldw	r3,-4(fp)
 d023da4:	18803fe0 	cmpeqi	r2,r3,255
 d023da8:	1000041e 	bne	r2,zero,d023dbc <dhc_extract_opts+0x10c>
 d023dac:	e0ffff17 	ldw	r3,-4(fp)
 d023db0:	188001a0 	cmpeqi	r2,r3,6
 d023db4:	1000551e 	bne	r2,zero,d023f0c <dhc_extract_opts+0x25c>
 d023db8:	00006006 	br	d023f3c <dhc_extract_opts+0x28c>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 d023dbc:	e03ffe15 	stw	zero,-8(fp)
 d023dc0:	00006c06 	br	d023f74 <dhc_extract_opts+0x2c4>
      case DHOP_SNMASK:
         opts++;
 d023dc4:	e0bffd17 	ldw	r2,-12(fp)
 d023dc8:	10800044 	addi	r2,r2,1
 d023dcc:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 d023dd0:	e47ffc17 	ldw	r17,-16(fp)
 d023dd4:	e13ffd17 	ldw	r4,-12(fp)
 d023dd8:	d023be40 	call	d023be4 <dh_getlong>
 d023ddc:	1025883a 	mov	r18,r2
 d023de0:	040341b4 	movhi	r16,3334
 d023de4:	84034004 	addi	r16,r16,3328
 d023de8:	8809883a 	mov	r4,r17
 d023dec:	01400f04 	movi	r5,60
 d023df0:	d00235c0 	call	d00235c <__mulsi3>
 d023df4:	1405883a 	add	r2,r2,r16
 d023df8:	10800a04 	addi	r2,r2,40
 d023dfc:	14800015 	stw	r18,0(r2)
         opts += 4;
 d023e00:	e0bffd17 	ldw	r2,-12(fp)
 d023e04:	10800104 	addi	r2,r2,4
 d023e08:	e0bffd15 	stw	r2,-12(fp)
         break;
 d023e0c:	00005306 	br	d023f5c <dhc_extract_opts+0x2ac>
      case DHOP_ROUTER:
         optlen = *opts++;
 d023e10:	e0bffd17 	ldw	r2,-12(fp)
 d023e14:	10800003 	ldbu	r2,0(r2)
 d023e18:	e0bffa05 	stb	r2,-24(fp)
 d023e1c:	e0bffd17 	ldw	r2,-12(fp)
 d023e20:	10800044 	addi	r2,r2,1
 d023e24:	e0bffd15 	stw	r2,-12(fp)
         if (optlen >= 4)
 d023e28:	e0bffa03 	ldbu	r2,-24(fp)
 d023e2c:	10800130 	cmpltui	r2,r2,4
 d023e30:	10000c1e 	bne	r2,zero,d023e64 <dhc_extract_opts+0x1b4>
            dhc_states[iface].defgw = dh_getlong(opts);
 d023e34:	e47ffc17 	ldw	r17,-16(fp)
 d023e38:	e13ffd17 	ldw	r4,-12(fp)
 d023e3c:	d023be40 	call	d023be4 <dh_getlong>
 d023e40:	1025883a 	mov	r18,r2
 d023e44:	040341b4 	movhi	r16,3334
 d023e48:	84034004 	addi	r16,r16,3328
 d023e4c:	8809883a 	mov	r4,r17
 d023e50:	01400f04 	movi	r5,60
 d023e54:	d00235c0 	call	d00235c <__mulsi3>
 d023e58:	1405883a 	add	r2,r2,r16
 d023e5c:	10800b04 	addi	r2,r2,44
 d023e60:	14800015 	stw	r18,0(r2)
         opts += optlen;
 d023e64:	e0bffa03 	ldbu	r2,-24(fp)
 d023e68:	1007883a 	mov	r3,r2
 d023e6c:	e0bffd17 	ldw	r2,-12(fp)
 d023e70:	10c5883a 	add	r2,r2,r3
 d023e74:	e0bffd15 	stw	r2,-12(fp)
         break;
 d023e78:	00003806 	br	d023f5c <dhc_extract_opts+0x2ac>
      case DHOP_LEASE:
         opts++;
 d023e7c:	e0bffd17 	ldw	r2,-12(fp)
 d023e80:	10800044 	addi	r2,r2,1
 d023e84:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 d023e88:	e4bffc17 	ldw	r18,-16(fp)
 d023e8c:	e13ffd17 	ldw	r4,-12(fp)
 d023e90:	d023be40 	call	d023be4 <dh_getlong>
 d023e94:	1005d63a 	srai	r2,r2,24
 d023e98:	14003fcc 	andi	r16,r2,255
 d023e9c:	e13ffd17 	ldw	r4,-12(fp)
 d023ea0:	d023be40 	call	d023be4 <dh_getlong>
 d023ea4:	1005d23a 	srai	r2,r2,8
 d023ea8:	10bfc00c 	andi	r2,r2,65280
 d023eac:	80a0b03a 	or	r16,r16,r2
 d023eb0:	e13ffd17 	ldw	r4,-12(fp)
 d023eb4:	d023be40 	call	d023be4 <dh_getlong>
 d023eb8:	10bfc00c 	andi	r2,r2,65280
 d023ebc:	1004923a 	slli	r2,r2,8
 d023ec0:	80a0b03a 	or	r16,r16,r2
 d023ec4:	e13ffd17 	ldw	r4,-12(fp)
 d023ec8:	d023be40 	call	d023be4 <dh_getlong>
 d023ecc:	10803fcc 	andi	r2,r2,255
 d023ed0:	1004963a 	slli	r2,r2,24
 d023ed4:	8084b03a 	or	r2,r16,r2
 d023ed8:	1023883a 	mov	r17,r2
 d023edc:	040341b4 	movhi	r16,3334
 d023ee0:	84034004 	addi	r16,r16,3328
 d023ee4:	9009883a 	mov	r4,r18
 d023ee8:	01400f04 	movi	r5,60
 d023eec:	d00235c0 	call	d00235c <__mulsi3>
 d023ef0:	1405883a 	add	r2,r2,r16
 d023ef4:	10800504 	addi	r2,r2,20
 d023ef8:	14400015 	stw	r17,0(r2)
         opts += 4;
 d023efc:	e0bffd17 	ldw	r2,-12(fp)
 d023f00:	10800104 	addi	r2,r2,4
 d023f04:	e0bffd15 	stw	r2,-12(fp)
         break;
 d023f08:	00001406 	br	d023f5c <dhc_extract_opts+0x2ac>
      case DHOP_DNSRV:
         optlen = *opts++;
 d023f0c:	e0bffd17 	ldw	r2,-12(fp)
 d023f10:	10800003 	ldbu	r2,0(r2)
 d023f14:	e0bffa05 	stb	r2,-24(fp)
 d023f18:	e0bffd17 	ldw	r2,-12(fp)
 d023f1c:	10800044 	addi	r2,r2,1
 d023f20:	e0bffd15 	stw	r2,-12(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 d023f24:	e0bffa03 	ldbu	r2,-24(fp)
 d023f28:	1007883a 	mov	r3,r2
 d023f2c:	e0bffd17 	ldw	r2,-12(fp)
 d023f30:	10c5883a 	add	r2,r2,r3
 d023f34:	e0bffd15 	stw	r2,-12(fp)
         break;
 d023f38:	00000806 	br	d023f5c <dhc_extract_opts+0x2ac>
      default:
         opts += ((*opts) + 1);
 d023f3c:	e0bffd17 	ldw	r2,-12(fp)
 d023f40:	10800003 	ldbu	r2,0(r2)
 d023f44:	10803fcc 	andi	r2,r2,255
 d023f48:	1007883a 	mov	r3,r2
 d023f4c:	e0bffd17 	ldw	r2,-12(fp)
 d023f50:	1885883a 	add	r2,r3,r2
 d023f54:	10800044 	addi	r2,r2,1
 d023f58:	e0bffd15 	stw	r2,-12(fp)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 d023f5c:	e0fffd17 	ldw	r3,-12(fp)
 d023f60:	e0bffb17 	ldw	r2,-20(fp)
 d023f64:	10ff772e 	bgeu	r2,r3,d023d44 <dhc_extract_opts+0x94>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 d023f68:	d025a500 	call	d025a50 <dtrap>
   return -1;
 d023f6c:	00bfffc4 	movi	r2,-1
 d023f70:	e0bffe15 	stw	r2,-8(fp)
 d023f74:	e0bffe17 	ldw	r2,-8(fp)
}
 d023f78:	e037883a 	mov	sp,fp
 d023f7c:	dfc00417 	ldw	ra,16(sp)
 d023f80:	df000317 	ldw	fp,12(sp)
 d023f84:	dc800217 	ldw	r18,8(sp)
 d023f88:	dc400117 	ldw	r17,4(sp)
 d023f8c:	dc000017 	ldw	r16,0(sp)
 d023f90:	dec00504 	addi	sp,sp,20
 d023f94:	f800283a 	ret

0d023f98 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 d023f98:	defff504 	addi	sp,sp,-44
 d023f9c:	dfc00a15 	stw	ra,40(sp)
 d023fa0:	df000915 	stw	fp,36(sp)
 d023fa4:	dc400815 	stw	r17,32(sp)
 d023fa8:	dc000715 	stw	r16,28(sp)
 d023fac:	df000704 	addi	fp,sp,28
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 d023fb0:	e03ffc15 	stw	zero,-16(fp)
 d023fb4:	00017306 	br	d024584 <dhc_second+0x5ec>
   {
      switch (dhc_states[iface].state)
 d023fb8:	e13ffc17 	ldw	r4,-16(fp)
 d023fbc:	040341b4 	movhi	r16,3334
 d023fc0:	84034004 	addi	r16,r16,3328
 d023fc4:	01400f04 	movi	r5,60
 d023fc8:	d00235c0 	call	d00235c <__mulsi3>
 d023fcc:	1405883a 	add	r2,r2,r16
 d023fd0:	10800017 	ldw	r2,0(r2)
 d023fd4:	e0bfff15 	stw	r2,-4(fp)
 d023fd8:	e0ffff17 	ldw	r3,-4(fp)
 d023fdc:	18800268 	cmpgeui	r2,r3,9
 d023fe0:	1001651e 	bne	r2,zero,d024578 <dhc_second+0x5e0>
 d023fe4:	e13fff17 	ldw	r4,-4(fp)
 d023fe8:	e13fff17 	ldw	r4,-4(fp)
 d023fec:	2105883a 	add	r2,r4,r4
 d023ff0:	1087883a 	add	r3,r2,r2
 d023ff4:	008340b4 	movhi	r2,3330
 d023ff8:	10900204 	addi	r2,r2,16392
 d023ffc:	1885883a 	add	r2,r3,r2
 d024000:	10800017 	ldw	r2,0(r2)
 d024004:	1000683a 	jmp	r2
 d024008:	0d024578 	rdprs	r20,at,2325
 d02400c:	0d02402c 	andhi	r20,at,2304
 d024010:	0d024064 	muli	r20,at,2305
 d024014:	0d02409c 	xori	r20,at,2306
 d024018:	0d02409c 	xori	r20,at,2306
 d02401c:	0d02409c 	xori	r20,at,2306
 d024020:	0d024334 	orhi	r20,at,2316
 d024024:	0d024400 	call	d02440 <__ram_exceptions_end+0xc82244>
 d024028:	0d0241dc 	xori	r20,at,2311
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 d02402c:	e13ffc17 	ldw	r4,-16(fp)
 d024030:	d0224e80 	call	d0224e8 <dhc_discover>
 d024034:	e0bffa15 	stw	r2,-24(fp)
         /* Error while sending a discover packet */
         if (e)
 d024038:	e0bffa17 	ldw	r2,-24(fp)
 d02403c:	1005003a 	cmpeq	r2,r2,zero
 d024040:	1000041e 	bne	r2,zero,d024054 <dhc_second+0xbc>
         {
            dtrap();
 d024044:	d025a500 	call	d025a50 <dtrap>
            return e;
 d024048:	e0bffa17 	ldw	r2,-24(fp)
 d02404c:	e0bffe15 	stw	r2,-8(fp)
 d024050:	00015006 	br	d024594 <dhc_second+0x5fc>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 d024054:	e13ffc17 	ldw	r4,-16(fp)
 d024058:	01400104 	movi	r5,4
 d02405c:	d0249e00 	call	d0249e0 <dhc_set_state>
         break;
 d024060:	00014506 	br	d024578 <dhc_second+0x5e0>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 d024064:	e13ffc17 	ldw	r4,-16(fp)
 d024068:	d02464c0 	call	d02464c <dhc_reclaim>
 d02406c:	e0bffa15 	stw	r2,-24(fp)
         if (e)
 d024070:	e0bffa17 	ldw	r2,-24(fp)
 d024074:	1005003a 	cmpeq	r2,r2,zero
 d024078:	1000041e 	bne	r2,zero,d02408c <dhc_second+0xf4>
         {
            dtrap();
 d02407c:	d025a500 	call	d025a50 <dtrap>
            return e;
 d024080:	e0fffa17 	ldw	r3,-24(fp)
 d024084:	e0fffe15 	stw	r3,-8(fp)
 d024088:	00014206 	br	d024594 <dhc_second+0x5fc>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 d02408c:	e13ffc17 	ldw	r4,-16(fp)
 d024090:	014000c4 	movi	r5,3
 d024094:	d0249e00 	call	d0249e0 <dhc_set_state>
         break;
 d024098:	00013706 	br	d024578 <dhc_second+0x5e0>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 d02409c:	e13ffc17 	ldw	r4,-16(fp)
 d0240a0:	040341b4 	movhi	r16,3334
 d0240a4:	84034004 	addi	r16,r16,3328
 d0240a8:	01400f04 	movi	r5,60
 d0240ac:	d00235c0 	call	d00235c <__mulsi3>
 d0240b0:	1405883a 	add	r2,r2,r16
 d0240b4:	10800104 	addi	r2,r2,4
 d0240b8:	10800017 	ldw	r2,0(r2)
 d0240bc:	e0bffb15 	stw	r2,-20(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 d0240c0:	e0bffb17 	ldw	r2,-20(fp)
 d0240c4:	10800110 	cmplti	r2,r2,4
 d0240c8:	1000021e 	bne	r2,zero,d0240d4 <dhc_second+0x13c>
            tries= DHC_MAX_TRIES;
 d0240cc:	00800104 	movi	r2,4
 d0240d0:	e0bffb15 	stw	r2,-20(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 d0240d4:	e13ffc17 	ldw	r4,-16(fp)
 d0240d8:	040341b4 	movhi	r16,3334
 d0240dc:	84034004 	addi	r16,r16,3328
 d0240e0:	01400f04 	movi	r5,60
 d0240e4:	d00235c0 	call	d00235c <__mulsi3>
 d0240e8:	1405883a 	add	r2,r2,r16
 d0240ec:	10800404 	addi	r2,r2,16
 d0240f0:	11000017 	ldw	r4,0(r2)
 d0240f4:	00c06404 	movi	r3,400
 d0240f8:	e0bffb17 	ldw	r2,-20(fp)
 d0240fc:	1884983a 	sll	r2,r3,r2
 d024100:	2087883a 	add	r3,r4,r2
 d024104:	00834174 	movhi	r2,3333
 d024108:	109b4504 	addi	r2,r2,27924
 d02410c:	10800017 	ldw	r2,0(r2)
 d024110:	18801d2e 	bgeu	r3,r2,d024188 <dhc_second+0x1f0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 d024114:	e13ffc17 	ldw	r4,-16(fp)
 d024118:	040341b4 	movhi	r16,3334
 d02411c:	84034004 	addi	r16,r16,3328
 d024120:	01400f04 	movi	r5,60
 d024124:	d00235c0 	call	d00235c <__mulsi3>
 d024128:	1405883a 	add	r2,r2,r16
 d02412c:	10800017 	ldw	r2,0(r2)
 d024130:	e0bffd15 	stw	r2,-12(fp)
 d024134:	e13ffd17 	ldw	r4,-12(fp)
 d024138:	20800120 	cmpeqi	r2,r4,4
 d02413c:	1000071e 	bne	r2,zero,d02415c <dhc_second+0x1c4>
 d024140:	e0fffd17 	ldw	r3,-12(fp)
 d024144:	18800160 	cmpeqi	r2,r3,5
 d024148:	1000071e 	bne	r2,zero,d024168 <dhc_second+0x1d0>
 d02414c:	e13ffd17 	ldw	r4,-12(fp)
 d024150:	208000e0 	cmpeqi	r2,r4,3
 d024154:	1000081e 	bne	r2,zero,d024178 <dhc_second+0x1e0>
 d024158:	00000a06 	br	d024184 <dhc_second+0x1ec>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 d02415c:	e13ffc17 	ldw	r4,-16(fp)
 d024160:	d0224e80 	call	d0224e8 <dhc_discover>
               break;
 d024164:	00000806 	br	d024188 <dhc_second+0x1f0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 d024168:	e13ffc17 	ldw	r4,-16(fp)
 d02416c:	000b883a 	mov	r5,zero
 d024170:	d022b540 	call	d022b54 <dhc_request>
               break;
 d024174:	00000406 	br	d024188 <dhc_second+0x1f0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 d024178:	e13ffc17 	ldw	r4,-16(fp)
 d02417c:	d02464c0 	call	d02464c <dhc_reclaim>
               break;
 d024180:	00000106 	br	d024188 <dhc_second+0x1f0>
            default:
               dtrap(); /* bogus state */
 d024184:	d025a500 	call	d025a50 <dtrap>
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 d024188:	e0bffb17 	ldw	r2,-20(fp)
 d02418c:	10800118 	cmpnei	r2,r2,4
 d024190:	1000f91e 	bne	r2,zero,d024578 <dhc_second+0x5e0>
 d024194:	e13ffc17 	ldw	r4,-16(fp)
 d024198:	040341b4 	movhi	r16,3334
 d02419c:	84034004 	addi	r16,r16,3328
 d0241a0:	01400f04 	movi	r5,60
 d0241a4:	d00235c0 	call	d00235c <__mulsi3>
 d0241a8:	1405883a 	add	r2,r2,r16
 d0241ac:	10800017 	ldw	r2,0(r2)
 d0241b0:	10800120 	cmpeqi	r2,r2,4
 d0241b4:	1000f01e 	bne	r2,zero,d024578 <dhc_second+0x5e0>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 d0241b8:	e13ffc17 	ldw	r4,-16(fp)
 d0241bc:	01400244 	movi	r5,9
 d0241c0:	d0249e00 	call	d0249e0 <dhc_set_state>
            dhc_resetip(iface);
 d0241c4:	e13ffc17 	ldw	r4,-16(fp)
 d0241c8:	d0239e80 	call	d0239e8 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 d0241cc:	e13ffc17 	ldw	r4,-16(fp)
 d0241d0:	01400044 	movi	r5,1
 d0241d4:	d0249e00 	call	d0249e0 <dhc_set_state>
         }
         break;
 d0241d8:	0000e706 	br	d024578 <dhc_second+0x5e0>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 d0241dc:	e13ffc17 	ldw	r4,-16(fp)
 d0241e0:	040341b4 	movhi	r16,3334
 d0241e4:	84034004 	addi	r16,r16,3328
 d0241e8:	01400f04 	movi	r5,60
 d0241ec:	d00235c0 	call	d00235c <__mulsi3>
 d0241f0:	1405883a 	add	r2,r2,r16
 d0241f4:	10800504 	addi	r2,r2,20
 d0241f8:	11000017 	ldw	r4,0(r2)
 d0241fc:	01401904 	movi	r5,100
 d024200:	d00235c0 	call	d00235c <__mulsi3>
 d024204:	1023883a 	mov	r17,r2
 d024208:	e13ffc17 	ldw	r4,-16(fp)
 d02420c:	040341b4 	movhi	r16,3334
 d024210:	84034004 	addi	r16,r16,3328
 d024214:	01400f04 	movi	r5,60
 d024218:	d00235c0 	call	d00235c <__mulsi3>
 d02421c:	1405883a 	add	r2,r2,r16
 d024220:	10800804 	addi	r2,r2,32
 d024224:	10800017 	ldw	r2,0(r2)
 d024228:	8887883a 	add	r3,r17,r2
 d02422c:	00834174 	movhi	r2,3333
 d024230:	109b4504 	addi	r2,r2,27924
 d024234:	10800017 	ldw	r2,0(r2)
 d024238:	10c0352e 	bgeu	r2,r3,d024310 <dhc_second+0x378>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 d02423c:	e13ffc17 	ldw	r4,-16(fp)
 d024240:	040341b4 	movhi	r16,3334
 d024244:	84034004 	addi	r16,r16,3328
 d024248:	01400f04 	movi	r5,60
 d02424c:	d00235c0 	call	d00235c <__mulsi3>
 d024250:	1405883a 	add	r2,r2,r16
 d024254:	10800804 	addi	r2,r2,32
 d024258:	14400017 	ldw	r17,0(r2)
 d02425c:	e13ffc17 	ldw	r4,-16(fp)
 d024260:	040341b4 	movhi	r16,3334
 d024264:	84034004 	addi	r16,r16,3328
 d024268:	01400f04 	movi	r5,60
 d02426c:	d00235c0 	call	d00235c <__mulsi3>
 d024270:	1405883a 	add	r2,r2,r16
 d024274:	10800504 	addi	r2,r2,20
 d024278:	11000017 	ldw	r4,0(r2)
 d02427c:	01401904 	movi	r5,100
 d024280:	d00235c0 	call	d00235c <__mulsi3>
 d024284:	88a3883a 	add	r17,r17,r2
 d024288:	e13ffc17 	ldw	r4,-16(fp)
 d02428c:	040341b4 	movhi	r16,3334
 d024290:	84034004 	addi	r16,r16,3328
 d024294:	01400f04 	movi	r5,60
 d024298:	d00235c0 	call	d00235c <__mulsi3>
 d02429c:	1405883a 	add	r2,r2,r16
 d0242a0:	10800404 	addi	r2,r2,16
 d0242a4:	10800017 	ldw	r2,0(r2)
 d0242a8:	8885c83a 	sub	r2,r17,r2
 d0242ac:	1004d07a 	srli	r2,r2,1
 d0242b0:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 d0242b4:	e0bff917 	ldw	r2,-28(fp)
 d0242b8:	1085dc28 	cmpgeui	r2,r2,6000
 d0242bc:	1000021e 	bne	r2,zero,d0242c8 <dhc_second+0x330>
               half_time = 60*TPS;
 d0242c0:	0085dc04 	movi	r2,6000
 d0242c4:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 d0242c8:	e13ffc17 	ldw	r4,-16(fp)
 d0242cc:	040341b4 	movhi	r16,3334
 d0242d0:	84034004 	addi	r16,r16,3328
 d0242d4:	01400f04 	movi	r5,60
 d0242d8:	d00235c0 	call	d00235c <__mulsi3>
 d0242dc:	1405883a 	add	r2,r2,r16
 d0242e0:	10800404 	addi	r2,r2,16
 d0242e4:	10c00017 	ldw	r3,0(r2)
 d0242e8:	e0bff917 	ldw	r2,-28(fp)
 d0242ec:	1887883a 	add	r3,r3,r2
 d0242f0:	00834174 	movhi	r2,3333
 d0242f4:	109b4504 	addi	r2,r2,27924
 d0242f8:	10800017 	ldw	r2,0(r2)
 d0242fc:	18809e2e 	bgeu	r3,r2,d024578 <dhc_second+0x5e0>
            {
               dhc_request(iface,FALSE);
 d024300:	e13ffc17 	ldw	r4,-16(fp)
 d024304:	000b883a 	mov	r5,zero
 d024308:	d022b540 	call	d022b54 <dhc_request>
 d02430c:	00009a06 	br	d024578 <dhc_second+0x5e0>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 d024310:	e13ffc17 	ldw	r4,-16(fp)
 d024314:	01400244 	movi	r5,9
 d024318:	d0249e00 	call	d0249e0 <dhc_set_state>
            dhc_resetip(iface);
 d02431c:	e13ffc17 	ldw	r4,-16(fp)
 d024320:	d0239e80 	call	d0239e8 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 d024324:	e13ffc17 	ldw	r4,-16(fp)
 d024328:	01400044 	movi	r5,1
 d02432c:	d0249e00 	call	d0249e0 <dhc_set_state>
         }
         break;
 d024330:	00009106 	br	d024578 <dhc_second+0x5e0>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 d024334:	e13ffc17 	ldw	r4,-16(fp)
 d024338:	040341b4 	movhi	r16,3334
 d02433c:	84034004 	addi	r16,r16,3328
 d024340:	01400f04 	movi	r5,60
 d024344:	d00235c0 	call	d00235c <__mulsi3>
 d024348:	1405883a 	add	r2,r2,r16
 d02434c:	10800604 	addi	r2,r2,24
 d024350:	10800017 	ldw	r2,0(r2)
 d024354:	10bfffe0 	cmpeqi	r2,r2,-1
 d024358:	1000871e 	bne	r2,zero,d024578 <dhc_second+0x5e0>
 d02435c:	e13ffc17 	ldw	r4,-16(fp)
 d024360:	040341b4 	movhi	r16,3334
 d024364:	84034004 	addi	r16,r16,3328
 d024368:	01400f04 	movi	r5,60
 d02436c:	d00235c0 	call	d00235c <__mulsi3>
 d024370:	1405883a 	add	r2,r2,r16
 d024374:	10800604 	addi	r2,r2,24
 d024378:	11000017 	ldw	r4,0(r2)
 d02437c:	01401904 	movi	r5,100
 d024380:	d00235c0 	call	d00235c <__mulsi3>
 d024384:	1023883a 	mov	r17,r2
 d024388:	e13ffc17 	ldw	r4,-16(fp)
 d02438c:	040341b4 	movhi	r16,3334
 d024390:	84034004 	addi	r16,r16,3328
 d024394:	01400f04 	movi	r5,60
 d024398:	d00235c0 	call	d00235c <__mulsi3>
 d02439c:	1405883a 	add	r2,r2,r16
 d0243a0:	10800804 	addi	r2,r2,32
 d0243a4:	10800017 	ldw	r2,0(r2)
 d0243a8:	8887883a 	add	r3,r17,r2
 d0243ac:	00834174 	movhi	r2,3333
 d0243b0:	109b4504 	addi	r2,r2,27924
 d0243b4:	10800017 	ldw	r2,0(r2)
 d0243b8:	18806f2e 	bgeu	r3,r2,d024578 <dhc_second+0x5e0>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 d0243bc:	e13ffc17 	ldw	r4,-16(fp)
 d0243c0:	014001c4 	movi	r5,7
 d0243c4:	d0249e00 	call	d0249e0 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 d0243c8:	e13ffc17 	ldw	r4,-16(fp)
 d0243cc:	d02464c0 	call	d02464c <dhc_reclaim>
 d0243d0:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 d0243d4:	e0bffa17 	ldw	r2,-24(fp)
 d0243d8:	1005003a 	cmpeq	r2,r2,zero
 d0243dc:	1000041e 	bne	r2,zero,d0243f0 <dhc_second+0x458>
            {
               dtrap();
 d0243e0:	d025a500 	call	d025a50 <dtrap>
               return e;
 d0243e4:	e0bffa17 	ldw	r2,-24(fp)
 d0243e8:	e0bffe15 	stw	r2,-8(fp)
 d0243ec:	00006906 	br	d024594 <dhc_second+0x5fc>
            }
            dsc_renew++;
 d0243f0:	d0a91717 	ldw	r2,-23460(gp)
 d0243f4:	10800044 	addi	r2,r2,1
 d0243f8:	d0a91715 	stw	r2,-23460(gp)
         }
         break;
 d0243fc:	00005e06 	br	d024578 <dhc_second+0x5e0>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 d024400:	e13ffc17 	ldw	r4,-16(fp)
 d024404:	040341b4 	movhi	r16,3334
 d024408:	84034004 	addi	r16,r16,3328
 d02440c:	01400f04 	movi	r5,60
 d024410:	d00235c0 	call	d00235c <__mulsi3>
 d024414:	1405883a 	add	r2,r2,r16
 d024418:	10800704 	addi	r2,r2,28
 d02441c:	11000017 	ldw	r4,0(r2)
 d024420:	01401904 	movi	r5,100
 d024424:	d00235c0 	call	d00235c <__mulsi3>
 d024428:	1023883a 	mov	r17,r2
 d02442c:	e13ffc17 	ldw	r4,-16(fp)
 d024430:	040341b4 	movhi	r16,3334
 d024434:	84034004 	addi	r16,r16,3328
 d024438:	01400f04 	movi	r5,60
 d02443c:	d00235c0 	call	d00235c <__mulsi3>
 d024440:	1405883a 	add	r2,r2,r16
 d024444:	10800804 	addi	r2,r2,32
 d024448:	10800017 	ldw	r2,0(r2)
 d02444c:	8887883a 	add	r3,r17,r2
 d024450:	00834174 	movhi	r2,3333
 d024454:	109b4504 	addi	r2,r2,27924
 d024458:	10800017 	ldw	r2,0(r2)
 d02445c:	10c0352e 	bgeu	r2,r3,d024534 <dhc_second+0x59c>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 d024460:	e13ffc17 	ldw	r4,-16(fp)
 d024464:	040341b4 	movhi	r16,3334
 d024468:	84034004 	addi	r16,r16,3328
 d02446c:	01400f04 	movi	r5,60
 d024470:	d00235c0 	call	d00235c <__mulsi3>
 d024474:	1405883a 	add	r2,r2,r16
 d024478:	10800804 	addi	r2,r2,32
 d02447c:	14400017 	ldw	r17,0(r2)
 d024480:	e13ffc17 	ldw	r4,-16(fp)
 d024484:	040341b4 	movhi	r16,3334
 d024488:	84034004 	addi	r16,r16,3328
 d02448c:	01400f04 	movi	r5,60
 d024490:	d00235c0 	call	d00235c <__mulsi3>
 d024494:	1405883a 	add	r2,r2,r16
 d024498:	10800704 	addi	r2,r2,28
 d02449c:	11000017 	ldw	r4,0(r2)
 d0244a0:	01401904 	movi	r5,100
 d0244a4:	d00235c0 	call	d00235c <__mulsi3>
 d0244a8:	88a3883a 	add	r17,r17,r2
 d0244ac:	e13ffc17 	ldw	r4,-16(fp)
 d0244b0:	040341b4 	movhi	r16,3334
 d0244b4:	84034004 	addi	r16,r16,3328
 d0244b8:	01400f04 	movi	r5,60
 d0244bc:	d00235c0 	call	d00235c <__mulsi3>
 d0244c0:	1405883a 	add	r2,r2,r16
 d0244c4:	10800404 	addi	r2,r2,16
 d0244c8:	10800017 	ldw	r2,0(r2)
 d0244cc:	8885c83a 	sub	r2,r17,r2
 d0244d0:	1004d07a 	srli	r2,r2,1
 d0244d4:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 d0244d8:	e0bff917 	ldw	r2,-28(fp)
 d0244dc:	1085dc28 	cmpgeui	r2,r2,6000
 d0244e0:	1000021e 	bne	r2,zero,d0244ec <dhc_second+0x554>
               half_time = 60*TPS;
 d0244e4:	0085dc04 	movi	r2,6000
 d0244e8:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 d0244ec:	e13ffc17 	ldw	r4,-16(fp)
 d0244f0:	040341b4 	movhi	r16,3334
 d0244f4:	84034004 	addi	r16,r16,3328
 d0244f8:	01400f04 	movi	r5,60
 d0244fc:	d00235c0 	call	d00235c <__mulsi3>
 d024500:	1405883a 	add	r2,r2,r16
 d024504:	10800404 	addi	r2,r2,16
 d024508:	10c00017 	ldw	r3,0(r2)
 d02450c:	e0bff917 	ldw	r2,-28(fp)
 d024510:	1887883a 	add	r3,r3,r2
 d024514:	00834174 	movhi	r2,3333
 d024518:	109b4504 	addi	r2,r2,27924
 d02451c:	10800017 	ldw	r2,0(r2)
 d024520:	1880152e 	bgeu	r3,r2,d024578 <dhc_second+0x5e0>
            {
               dhc_request(iface,FALSE);
 d024524:	e13ffc17 	ldw	r4,-16(fp)
 d024528:	000b883a 	mov	r5,zero
 d02452c:	d022b540 	call	d022b54 <dhc_request>
 d024530:	00001106 	br	d024578 <dhc_second+0x5e0>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 d024534:	e13ffc17 	ldw	r4,-16(fp)
 d024538:	01400204 	movi	r5,8
 d02453c:	d0249e00 	call	d0249e0 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 d024540:	e13ffc17 	ldw	r4,-16(fp)
 d024544:	01400044 	movi	r5,1
 d024548:	d022b540 	call	d022b54 <dhc_request>
 d02454c:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 d024550:	e0bffa17 	ldw	r2,-24(fp)
 d024554:	1005003a 	cmpeq	r2,r2,zero
 d024558:	1000041e 	bne	r2,zero,d02456c <dhc_second+0x5d4>
            {
               dtrap();
 d02455c:	d025a500 	call	d025a50 <dtrap>
               return e;
 d024560:	e0fffa17 	ldw	r3,-24(fp)
 d024564:	e0fffe15 	stw	r3,-8(fp)
 d024568:	00000a06 	br	d024594 <dhc_second+0x5fc>
            }
            dsc_rebind++;
 d02456c:	d0a91817 	ldw	r2,-23456(gp)
 d024570:	10800044 	addi	r2,r2,1
 d024574:	d0a91815 	stw	r2,-23456(gp)
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 d024578:	e0bffc17 	ldw	r2,-16(fp)
 d02457c:	10800044 	addi	r2,r2,1
 d024580:	e0bffc15 	stw	r2,-16(fp)
 d024584:	e0bffc17 	ldw	r2,-16(fp)
 d024588:	10800110 	cmplti	r2,r2,4
 d02458c:	103e8a1e 	bne	r2,zero,d023fb8 <dhc_second+0x20>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 d024590:	e03ffe15 	stw	zero,-8(fp)
 d024594:	e0bffe17 	ldw	r2,-8(fp)
}
 d024598:	e037883a 	mov	sp,fp
 d02459c:	dfc00317 	ldw	ra,12(sp)
 d0245a0:	df000217 	ldw	fp,8(sp)
 d0245a4:	dc400117 	ldw	r17,4(sp)
 d0245a8:	dc000017 	ldw	r16,0(sp)
 d0245ac:	dec00404 	addi	sp,sp,16
 d0245b0:	f800283a 	ret

0d0245b4 <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 d0245b4:	defffc04 	addi	sp,sp,-16
 d0245b8:	dfc00315 	stw	ra,12(sp)
 d0245bc:	df000215 	stw	fp,8(sp)
 d0245c0:	dc000115 	stw	r16,4(sp)
 d0245c4:	df000104 	addi	fp,sp,4
 d0245c8:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 d0245cc:	e0bfff17 	ldw	r2,-4(fp)
 d0245d0:	1004803a 	cmplt	r2,r2,zero
 d0245d4:	1000031e 	bne	r2,zero,d0245e4 <dhc_halt+0x30>
 d0245d8:	e0bfff17 	ldw	r2,-4(fp)
 d0245dc:	10800150 	cmplti	r2,r2,5
 d0245e0:	1000021e 	bne	r2,zero,d0245ec <dhc_halt+0x38>
   {
      dtrap();
 d0245e4:	d025a500 	call	d025a50 <dtrap>
      return;
 d0245e8:	00001206 	br	d024634 <dhc_halt+0x80>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 d0245ec:	e13fff17 	ldw	r4,-4(fp)
 d0245f0:	01400f04 	movi	r5,60
 d0245f4:	d00235c0 	call	d00235c <__mulsi3>
 d0245f8:	1007883a 	mov	r3,r2
 d0245fc:	008341b4 	movhi	r2,3334
 d024600:	10834004 	addi	r2,r2,3328
 d024604:	1885883a 	add	r2,r3,r2
 d024608:	1009883a 	mov	r4,r2
 d02460c:	01800f04 	movi	r6,60
 d024610:	000b883a 	mov	r5,zero
 d024614:	d0027880 	call	d002788 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 d024618:	e13fff17 	ldw	r4,-4(fp)
 d02461c:	040341b4 	movhi	r16,3334
 d024620:	84034004 	addi	r16,r16,3328
 d024624:	01400f04 	movi	r5,60
 d024628:	d00235c0 	call	d00235c <__mulsi3>
 d02462c:	1405883a 	add	r2,r2,r16
 d024630:	10000015 	stw	zero,0(r2)
}
 d024634:	e037883a 	mov	sp,fp
 d024638:	dfc00217 	ldw	ra,8(sp)
 d02463c:	df000117 	ldw	fp,4(sp)
 d024640:	dc000017 	ldw	r16,0(sp)
 d024644:	dec00304 	addi	sp,sp,12
 d024648:	f800283a 	ret

0d02464c <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 d02464c:	defff904 	addi	sp,sp,-28
 d024650:	dfc00615 	stw	ra,24(sp)
 d024654:	df000515 	stw	fp,20(sp)
 d024658:	dc400415 	stw	r17,16(sp)
 d02465c:	dc000315 	stw	r16,12(sp)
 d024660:	df000304 	addi	fp,sp,12
 d024664:	e13ffe15 	stw	r4,-8(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 d024668:	e0bffe17 	ldw	r2,-8(fp)
 d02466c:	00c341b4 	movhi	r3,3334
 d024670:	18c31a04 	addi	r3,r3,3176
 d024674:	1085883a 	add	r2,r2,r2
 d024678:	1085883a 	add	r2,r2,r2
 d02467c:	10c5883a 	add	r2,r2,r3
 d024680:	10800017 	ldw	r2,0(r2)
 d024684:	10800a17 	ldw	r2,40(r2)
 d024688:	1004c03a 	cmpne	r2,r2,zero
 d02468c:	1000041e 	bne	r2,zero,d0246a0 <dhc_reclaim+0x54>
   {
      dtrap();    /* programming bug? */
 d024690:	d025a500 	call	d025a50 <dtrap>
      return ENP_LOGIC;
 d024694:	00bffd44 	movi	r2,-11
 d024698:	e0bfff15 	stw	r2,-4(fp)
 d02469c:	00006306 	br	d02482c <dhc_reclaim+0x1e0>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 d0246a0:	e13ffe17 	ldw	r4,-8(fp)
 d0246a4:	e0bffe17 	ldw	r2,-8(fp)
 d0246a8:	00c341b4 	movhi	r3,3334
 d0246ac:	18c31a04 	addi	r3,r3,3176
 d0246b0:	1085883a 	add	r2,r2,r2
 d0246b4:	1085883a 	add	r2,r2,r2
 d0246b8:	10c5883a 	add	r2,r2,r3
 d0246bc:	10800017 	ldw	r2,0(r2)
 d0246c0:	14400a17 	ldw	r17,40(r2)
 d0246c4:	040341b4 	movhi	r16,3334
 d0246c8:	84034004 	addi	r16,r16,3328
 d0246cc:	01400f04 	movi	r5,60
 d0246d0:	d00235c0 	call	d00235c <__mulsi3>
 d0246d4:	1405883a 	add	r2,r2,r16
 d0246d8:	10800904 	addi	r2,r2,36
 d0246dc:	14400015 	stw	r17,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 d0246e0:	e13ffe17 	ldw	r4,-8(fp)
 d0246e4:	e0bffe17 	ldw	r2,-8(fp)
 d0246e8:	00c341b4 	movhi	r3,3334
 d0246ec:	18c31a04 	addi	r3,r3,3176
 d0246f0:	1085883a 	add	r2,r2,r2
 d0246f4:	1085883a 	add	r2,r2,r2
 d0246f8:	10c5883a 	add	r2,r2,r3
 d0246fc:	10800017 	ldw	r2,0(r2)
 d024700:	14400c17 	ldw	r17,48(r2)
 d024704:	040341b4 	movhi	r16,3334
 d024708:	84034004 	addi	r16,r16,3328
 d02470c:	01400f04 	movi	r5,60
 d024710:	d00235c0 	call	d00235c <__mulsi3>
 d024714:	1405883a 	add	r2,r2,r16
 d024718:	10800a04 	addi	r2,r2,40
 d02471c:	14400015 	stw	r17,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 d024720:	e13ffe17 	ldw	r4,-8(fp)
 d024724:	e0bffe17 	ldw	r2,-8(fp)
 d024728:	00c341b4 	movhi	r3,3334
 d02472c:	18c31a04 	addi	r3,r3,3176
 d024730:	1085883a 	add	r2,r2,r2
 d024734:	1085883a 	add	r2,r2,r2
 d024738:	10c5883a 	add	r2,r2,r3
 d02473c:	10800017 	ldw	r2,0(r2)
 d024740:	14400d17 	ldw	r17,52(r2)
 d024744:	040341b4 	movhi	r16,3334
 d024748:	84034004 	addi	r16,r16,3328
 d02474c:	01400f04 	movi	r5,60
 d024750:	d00235c0 	call	d00235c <__mulsi3>
 d024754:	1405883a 	add	r2,r2,r16
 d024758:	10800b04 	addi	r2,r2,44
 d02475c:	14400015 	stw	r17,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 d024760:	e13ffe17 	ldw	r4,-8(fp)
 d024764:	040341b4 	movhi	r16,3334
 d024768:	84034004 	addi	r16,r16,3328
 d02476c:	01400f04 	movi	r5,60
 d024770:	d00235c0 	call	d00235c <__mulsi3>
 d024774:	1405883a 	add	r2,r2,r16
 d024778:	10800c04 	addi	r2,r2,48
 d02477c:	10800017 	ldw	r2,0(r2)
 d024780:	1005003a 	cmpeq	r2,r2,zero
 d024784:	1000251e 	bne	r2,zero,d02481c <dhc_reclaim+0x1d0>
   {
      if (dhc_states[iface].srv_ipaddr)
 d024788:	e13ffe17 	ldw	r4,-8(fp)
 d02478c:	040341b4 	movhi	r16,3334
 d024790:	84034004 	addi	r16,r16,3328
 d024794:	01400f04 	movi	r5,60
 d024798:	d00235c0 	call	d00235c <__mulsi3>
 d02479c:	1405883a 	add	r2,r2,r16
 d0247a0:	10800d04 	addi	r2,r2,52
 d0247a4:	10800017 	ldw	r2,0(r2)
 d0247a8:	1005003a 	cmpeq	r2,r2,zero
 d0247ac:	10001a1e 	bne	r2,zero,d024818 <dhc_reclaim+0x1cc>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 d0247b0:	e13ffe17 	ldw	r4,-8(fp)
 d0247b4:	040341b4 	movhi	r16,3334
 d0247b8:	84034004 	addi	r16,r16,3328
 d0247bc:	01400f04 	movi	r5,60
 d0247c0:	d00235c0 	call	d00235c <__mulsi3>
 d0247c4:	1405883a 	add	r2,r2,r16
 d0247c8:	10800d04 	addi	r2,r2,52
 d0247cc:	14400017 	ldw	r17,0(r2)
 d0247d0:	e13ffe17 	ldw	r4,-8(fp)
 d0247d4:	040341b4 	movhi	r16,3334
 d0247d8:	84034004 	addi	r16,r16,3328
 d0247dc:	01400f04 	movi	r5,60
 d0247e0:	d00235c0 	call	d00235c <__mulsi3>
 d0247e4:	1405883a 	add	r2,r2,r16
 d0247e8:	10800c04 	addi	r2,r2,48
 d0247ec:	11800017 	ldw	r6,0(r2)
 d0247f0:	00800084 	movi	r2,2
 d0247f4:	d8800015 	stw	r2,0(sp)
 d0247f8:	8809883a 	mov	r4,r17
 d0247fc:	017fffc4 	movi	r5,-1
 d024800:	e1fffe17 	ldw	r7,-8(fp)
 d024804:	d0441980 	call	d044198 <add_route>
 d024808:	1004c03a 	cmpne	r2,r2,zero
 d02480c:	1000031e 	bne	r2,zero,d02481c <dhc_reclaim+0x1d0>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 d024810:	d025a500 	call	d025a50 <dtrap>
 d024814:	00000106 	br	d02481c <dhc_reclaim+0x1d0>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 d024818:	d025a500 	call	d025a50 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 d02481c:	e13ffe17 	ldw	r4,-8(fp)
 d024820:	01400044 	movi	r5,1
 d024824:	d022b540 	call	d022b54 <dhc_request>
 d024828:	e0bfff15 	stw	r2,-4(fp)
 d02482c:	e0bfff17 	ldw	r2,-4(fp)
}
 d024830:	e037883a 	mov	sp,fp
 d024834:	dfc00317 	ldw	ra,12(sp)
 d024838:	df000217 	ldw	fp,8(sp)
 d02483c:	dc400117 	ldw	r17,4(sp)
 d024840:	dc000017 	ldw	r16,0(sp)
 d024844:	dec00404 	addi	sp,sp,16
 d024848:	f800283a 	ret

0d02484c <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 d02484c:	defffa04 	addi	sp,sp,-24
 d024850:	dfc00515 	stw	ra,20(sp)
 d024854:	df000415 	stw	fp,16(sp)
 d024858:	df000404 	addi	fp,sp,16
 d02485c:	e13ffd15 	stw	r4,-12(fp)
 d024860:	e17ffe15 	stw	r5,-8(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 d024864:	e0bffe17 	ldw	r2,-8(fp)
 d024868:	10800058 	cmpnei	r2,r2,1
 d02486c:	1000031e 	bne	r2,zero,d02487c <dhc_state_init+0x30>
 d024870:	00800044 	movi	r2,1
 d024874:	e0bfff15 	stw	r2,-4(fp)
 d024878:	00000206 	br	d024884 <dhc_state_init+0x38>
 d02487c:	00800084 	movi	r2,2
 d024880:	e0bfff15 	stw	r2,-4(fp)
 d024884:	e0bfff17 	ldw	r2,-4(fp)
 d024888:	e0bffc15 	stw	r2,-16(fp)
   
   dhc_set_state(iface, state);
 d02488c:	e13ffd17 	ldw	r4,-12(fp)
 d024890:	e17ffc17 	ldw	r5,-16(fp)
 d024894:	d0249e00 	call	d0249e0 <dhc_set_state>
}
 d024898:	e037883a 	mov	sp,fp
 d02489c:	dfc00117 	ldw	ra,4(sp)
 d0248a0:	df000017 	ldw	fp,0(sp)
 d0248a4:	dec00204 	addi	sp,sp,8
 d0248a8:	f800283a 	ret

0d0248ac <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 d0248ac:	defffb04 	addi	sp,sp,-20
 d0248b0:	dfc00415 	stw	ra,16(sp)
 d0248b4:	df000315 	stw	fp,12(sp)
 d0248b8:	dc000215 	stw	r16,8(sp)
 d0248bc:	df000204 	addi	fp,sp,8
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 d0248c0:	e03ffe15 	stw	zero,-8(fp)
 d0248c4:	00001706 	br	d024924 <dhc_alldone+0x78>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 d0248c8:	e13ffe17 	ldw	r4,-8(fp)
 d0248cc:	040341b4 	movhi	r16,3334
 d0248d0:	84034004 	addi	r16,r16,3328
 d0248d4:	01400f04 	movi	r5,60
 d0248d8:	d00235c0 	call	d00235c <__mulsi3>
 d0248dc:	1405883a 	add	r2,r2,r16
 d0248e0:	10800017 	ldw	r2,0(r2)
 d0248e4:	1005003a 	cmpeq	r2,r2,zero
 d0248e8:	10000b1e 	bne	r2,zero,d024918 <dhc_alldone+0x6c>
 d0248ec:	e13ffe17 	ldw	r4,-8(fp)
 d0248f0:	040341b4 	movhi	r16,3334
 d0248f4:	84034004 	addi	r16,r16,3328
 d0248f8:	01400f04 	movi	r5,60
 d0248fc:	d00235c0 	call	d00235c <__mulsi3>
 d024900:	1405883a 	add	r2,r2,r16
 d024904:	10800017 	ldw	r2,0(r2)
 d024908:	108001a0 	cmpeqi	r2,r2,6
 d02490c:	1000021e 	bne	r2,zero,d024918 <dhc_alldone+0x6c>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 d024910:	e03fff15 	stw	zero,-4(fp)
 d024914:	00000806 	br	d024938 <dhc_alldone+0x8c>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 d024918:	e0bffe17 	ldw	r2,-8(fp)
 d02491c:	10800044 	addi	r2,r2,1
 d024920:	e0bffe15 	stw	r2,-8(fp)
 d024924:	e0bffe17 	ldw	r2,-8(fp)
 d024928:	10800110 	cmplti	r2,r2,4
 d02492c:	103fe61e 	bne	r2,zero,d0248c8 <dhc_alldone+0x1c>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 d024930:	00800044 	movi	r2,1
 d024934:	e0bfff15 	stw	r2,-4(fp)
 d024938:	e0bfff17 	ldw	r2,-4(fp)
}
 d02493c:	e037883a 	mov	sp,fp
 d024940:	dfc00217 	ldw	ra,8(sp)
 d024944:	df000117 	ldw	fp,4(sp)
 d024948:	dc000017 	ldw	r16,0(sp)
 d02494c:	dec00304 	addi	sp,sp,12
 d024950:	f800283a 	ret

0d024954 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 d024954:	defffb04 	addi	sp,sp,-20
 d024958:	dfc00415 	stw	ra,16(sp)
 d02495c:	df000315 	stw	fp,12(sp)
 d024960:	dc000215 	stw	r16,8(sp)
 d024964:	df000204 	addi	fp,sp,8
 d024968:	e13ffe15 	stw	r4,-8(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 d02496c:	e13ffe17 	ldw	r4,-8(fp)
 d024970:	040341b4 	movhi	r16,3334
 d024974:	84034004 	addi	r16,r16,3328
 d024978:	01400f04 	movi	r5,60
 d02497c:	d00235c0 	call	d00235c <__mulsi3>
 d024980:	1405883a 	add	r2,r2,r16
 d024984:	10800017 	ldw	r2,0(r2)
 d024988:	1005003a 	cmpeq	r2,r2,zero
 d02498c:	1000091e 	bne	r2,zero,d0249b4 <dhc_ifacedone+0x60>
 d024990:	e13ffe17 	ldw	r4,-8(fp)
 d024994:	040341b4 	movhi	r16,3334
 d024998:	84034004 	addi	r16,r16,3328
 d02499c:	01400f04 	movi	r5,60
 d0249a0:	d00235c0 	call	d00235c <__mulsi3>
 d0249a4:	1405883a 	add	r2,r2,r16
 d0249a8:	10800017 	ldw	r2,0(r2)
 d0249ac:	10800198 	cmpnei	r2,r2,6
 d0249b0:	1000031e 	bne	r2,zero,d0249c0 <dhc_ifacedone+0x6c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 d0249b4:	00800044 	movi	r2,1
 d0249b8:	e0bfff15 	stw	r2,-4(fp)
 d0249bc:	00000106 	br	d0249c4 <dhc_ifacedone+0x70>
   }
   else
   {
      return FALSE ;
 d0249c0:	e03fff15 	stw	zero,-4(fp)
 d0249c4:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d0249c8:	e037883a 	mov	sp,fp
 d0249cc:	dfc00217 	ldw	ra,8(sp)
 d0249d0:	df000117 	ldw	fp,4(sp)
 d0249d4:	dc000017 	ldw	r16,0(sp)
 d0249d8:	dec00304 	addi	sp,sp,12
 d0249dc:	f800283a 	ret

0d0249e0 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 d0249e0:	defffa04 	addi	sp,sp,-24
 d0249e4:	dfc00515 	stw	ra,20(sp)
 d0249e8:	df000415 	stw	fp,16(sp)
 d0249ec:	dc400315 	stw	r17,12(sp)
 d0249f0:	dc000215 	stw	r16,8(sp)
 d0249f4:	df000204 	addi	fp,sp,8
 d0249f8:	e13ffe15 	stw	r4,-8(fp)
 d0249fc:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 d024a00:	e13ffe17 	ldw	r4,-8(fp)
 d024a04:	e47fff17 	ldw	r17,-4(fp)
 d024a08:	040341b4 	movhi	r16,3334
 d024a0c:	84034004 	addi	r16,r16,3328
 d024a10:	01400f04 	movi	r5,60
 d024a14:	d00235c0 	call	d00235c <__mulsi3>
 d024a18:	1405883a 	add	r2,r2,r16
 d024a1c:	14400015 	stw	r17,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 d024a20:	e13ffe17 	ldw	r4,-8(fp)
 d024a24:	040341b4 	movhi	r16,3334
 d024a28:	84034004 	addi	r16,r16,3328
 d024a2c:	01400f04 	movi	r5,60
 d024a30:	d00235c0 	call	d00235c <__mulsi3>
 d024a34:	1405883a 	add	r2,r2,r16
 d024a38:	10800104 	addi	r2,r2,4
 d024a3c:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 d024a40:	e13ffe17 	ldw	r4,-8(fp)
 d024a44:	040341b4 	movhi	r16,3334
 d024a48:	84034004 	addi	r16,r16,3328
 d024a4c:	01400f04 	movi	r5,60
 d024a50:	d00235c0 	call	d00235c <__mulsi3>
 d024a54:	1405883a 	add	r2,r2,r16
 d024a58:	10800e04 	addi	r2,r2,56
 d024a5c:	10800017 	ldw	r2,0(r2)
 d024a60:	1005003a 	cmpeq	r2,r2,zero
 d024a64:	10000b1e 	bne	r2,zero,d024a94 <dhc_set_state+0xb4>
      dhc_states[iface].callback(iface,state);
 d024a68:	e13ffe17 	ldw	r4,-8(fp)
 d024a6c:	040341b4 	movhi	r16,3334
 d024a70:	84034004 	addi	r16,r16,3328
 d024a74:	01400f04 	movi	r5,60
 d024a78:	d00235c0 	call	d00235c <__mulsi3>
 d024a7c:	1405883a 	add	r2,r2,r16
 d024a80:	10800e04 	addi	r2,r2,56
 d024a84:	10800017 	ldw	r2,0(r2)
 d024a88:	e13ffe17 	ldw	r4,-8(fp)
 d024a8c:	e17fff17 	ldw	r5,-4(fp)
 d024a90:	103ee83a 	callr	r2
}
 d024a94:	e037883a 	mov	sp,fp
 d024a98:	dfc00317 	ldw	ra,12(sp)
 d024a9c:	df000217 	ldw	fp,8(sp)
 d024aa0:	dc400117 	ldw	r17,4(sp)
 d024aa4:	dc000017 	ldw	r16,0(sp)
 d024aa8:	dec00404 	addi	sp,sp,16
 d024aac:	f800283a 	ret

0d024ab0 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 d024ab0:	defffb04 	addi	sp,sp,-20
 d024ab4:	df000415 	stw	fp,16(sp)
 d024ab8:	df000404 	addi	fp,sp,16
 d024abc:	e17ffe15 	stw	r5,-8(fp)
 d024ac0:	e13ffd05 	stb	r4,-12(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 d024ac4:	e0bffe17 	ldw	r2,-8(fp)
 d024ac8:	10804e04 	addi	r2,r2,312
 d024acc:	e0bffc15 	stw	r2,-16(fp)

   while (opts < end)
 d024ad0:	00002106 	br	d024b58 <find_opt+0xa8>
   {
      if (*opts == opcode) /* found it */
 d024ad4:	e0bffe17 	ldw	r2,-8(fp)
 d024ad8:	10800003 	ldbu	r2,0(r2)
 d024adc:	10c03fcc 	andi	r3,r2,255
 d024ae0:	e0bffd03 	ldbu	r2,-12(fp)
 d024ae4:	1880031e 	bne	r3,r2,d024af4 <find_opt+0x44>
         return opts;
 d024ae8:	e0bffe17 	ldw	r2,-8(fp)
 d024aec:	e0bfff15 	stw	r2,-4(fp)
 d024af0:	00001d06 	br	d024b68 <find_opt+0xb8>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 d024af4:	e0bffe17 	ldw	r2,-8(fp)
 d024af8:	10800003 	ldbu	r2,0(r2)
 d024afc:	10803fcc 	andi	r2,r2,255
 d024b00:	10803fd8 	cmpnei	r2,r2,255
 d024b04:	1000021e 	bne	r2,zero,d024b10 <find_opt+0x60>
         return NULL;
 d024b08:	e03fff15 	stw	zero,-4(fp)
 d024b0c:	00001606 	br	d024b68 <find_opt+0xb8>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 d024b10:	e0bffe17 	ldw	r2,-8(fp)
 d024b14:	10800003 	ldbu	r2,0(r2)
 d024b18:	10803fcc 	andi	r2,r2,255
 d024b1c:	1004c03a 	cmpne	r2,r2,zero
 d024b20:	1000041e 	bne	r2,zero,d024b34 <find_opt+0x84>
         opts++;
 d024b24:	e0bffe17 	ldw	r2,-8(fp)
 d024b28:	10800044 	addi	r2,r2,1
 d024b2c:	e0bffe15 	stw	r2,-8(fp)
 d024b30:	00000906 	br	d024b58 <find_opt+0xa8>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 d024b34:	e0bffe17 	ldw	r2,-8(fp)
 d024b38:	10800044 	addi	r2,r2,1
 d024b3c:	10800003 	ldbu	r2,0(r2)
 d024b40:	10803fcc 	andi	r2,r2,255
 d024b44:	1007883a 	mov	r3,r2
 d024b48:	e0bffe17 	ldw	r2,-8(fp)
 d024b4c:	1885883a 	add	r2,r3,r2
 d024b50:	10800084 	addi	r2,r2,2
 d024b54:	e0bffe15 	stw	r2,-8(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 d024b58:	e0fffe17 	ldw	r3,-8(fp)
 d024b5c:	e0bffc17 	ldw	r2,-16(fp)
 d024b60:	18bfdc36 	bltu	r3,r2,d024ad4 <find_opt+0x24>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 d024b64:	e03fff15 	stw	zero,-4(fp)
 d024b68:	e0bfff17 	ldw	r2,-4(fp)
}
 d024b6c:	e037883a 	mov	sp,fp
 d024b70:	df000017 	ldw	fp,0(sp)
 d024b74:	dec00104 	addi	sp,sp,4
 d024b78:	f800283a 	ret

0d024b7c <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 d024b7c:	defff704 	addi	sp,sp,-36
 d024b80:	dfc00815 	stw	ra,32(sp)
 d024b84:	df000715 	stw	fp,28(sp)
 d024b88:	df000704 	addi	fp,sp,28
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 d024b8c:	d0a03717 	ldw	r2,-32548(gp)
 d024b90:	d0e03517 	ldw	r3,-32556(gp)
 d024b94:	10c5883a 	add	r2,r2,r3
 d024b98:	e0bffc15 	stw	r2,-16(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 d024b9c:	e03ffb05 	stb	zero,-20(fp)
#endif

   for (i = 0; i < numpkts; i++)
 d024ba0:	e03ffd15 	stw	zero,-12(fp)
 d024ba4:	00007e06 	br	d024da0 <pk_init+0x224>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 d024ba8:	01000d04 	movi	r4,52
 d024bac:	d0264b80 	call	d0264b8 <npalloc>
 d024bb0:	e0bffe15 	stw	r2,-8(fp)
      if (packet == NULL)
 d024bb4:	e0bffe17 	ldw	r2,-8(fp)
 d024bb8:	1005003a 	cmpeq	r2,r2,zero
 d024bbc:	1000871e 	bne	r2,zero,d024ddc <pk_init+0x260>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 d024bc0:	e0bffd17 	ldw	r2,-12(fp)
 d024bc4:	10800f30 	cmpltui	r2,r2,60
 d024bc8:	1000061e 	bne	r2,zero,d024be4 <pk_init+0x68>
      {
         dprintf("pk_init: bad define\n");
 d024bcc:	01034174 	movhi	r4,3333
 d024bd0:	213d2704 	addi	r4,r4,-2916
 d024bd4:	d002bc80 	call	d002bc8 <puts>
         return -1;
 d024bd8:	00bfffc4 	movi	r2,-1
 d024bdc:	e0bfff15 	stw	r2,-4(fp)
 d024be0:	00008406 	br	d024df4 <pk_init+0x278>
      }
      pktlog[i] = packet;     /* save for debugging */
 d024be4:	e0bffd17 	ldw	r2,-12(fp)
 d024be8:	00c341b4 	movhi	r3,3334
 d024bec:	18c38504 	addi	r3,r3,3604
 d024bf0:	1085883a 	add	r2,r2,r2
 d024bf4:	1085883a 	add	r2,r2,r2
 d024bf8:	10c7883a 	add	r3,r2,r3
 d024bfc:	e0bffe17 	ldw	r2,-8(fp)
 d024c00:	18800015 	stw	r2,0(r3)
#endif

      packet->nb_tstamp = 0L;
 d024c04:	e0bffe17 	ldw	r2,-8(fp)
 d024c08:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 d024c0c:	d0e03717 	ldw	r3,-32548(gp)
 d024c10:	e0bffd17 	ldw	r2,-12(fp)
 d024c14:	10c0302e 	bgeu	r2,r3,d024cd8 <pk_init+0x15c>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 d024c18:	d0a03817 	ldw	r2,-32544(gp)
 d024c1c:	11000144 	addi	r4,r2,5
 d024c20:	d0266640 	call	d026664 <ncpalloc>
 d024c24:	1007883a 	mov	r3,r2
 d024c28:	e0bffe17 	ldw	r2,-8(fp)
 d024c2c:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 d024c30:	e0bffe17 	ldw	r2,-8(fp)
 d024c34:	10800117 	ldw	r2,4(r2)
 d024c38:	1005003a 	cmpeq	r2,r2,zero
 d024c3c:	1000671e 	bne	r2,zero,d024ddc <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d024c40:	e03ffa15 	stw	zero,-24(fp)
 d024c44:	00000906 	br	d024c6c <pk_init+0xf0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 d024c48:	e0bffe17 	ldw	r2,-8(fp)
 d024c4c:	10c00117 	ldw	r3,4(r2)
 d024c50:	e0bffa17 	ldw	r2,-24(fp)
 d024c54:	1887883a 	add	r3,r3,r2
 d024c58:	00801344 	movi	r2,77
 d024c5c:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d024c60:	e0bffa17 	ldw	r2,-24(fp)
 d024c64:	10800044 	addi	r2,r2,1
 d024c68:	e0bffa15 	stw	r2,-24(fp)
 d024c6c:	e0bffa17 	ldw	r2,-24(fp)
 d024c70:	10800110 	cmplti	r2,r2,4
 d024c74:	103ff41e 	bne	r2,zero,d024c48 <pk_init+0xcc>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 d024c78:	e0bffe17 	ldw	r2,-8(fp)
 d024c7c:	10c00117 	ldw	r3,4(r2)
 d024c80:	d0a03817 	ldw	r2,-32544(gp)
 d024c84:	1885883a 	add	r2,r3,r2
 d024c88:	10c00104 	addi	r3,r2,4
 d024c8c:	00801344 	movi	r2,77
 d024c90:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 d024c94:	e0bffe17 	ldw	r2,-8(fp)
 d024c98:	10800117 	ldw	r2,4(r2)
 d024c9c:	10c00104 	addi	r3,r2,4
 d024ca0:	e0bffe17 	ldw	r2,-8(fp)
 d024ca4:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 d024ca8:	e0bffe17 	ldw	r2,-8(fp)
 d024cac:	10800117 	ldw	r2,4(r2)
 d024cb0:	1005003a 	cmpeq	r2,r2,zero
 d024cb4:	1000491e 	bne	r2,zero,d024ddc <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 d024cb8:	d0e03817 	ldw	r3,-32544(gp)
 d024cbc:	e0bffe17 	ldw	r2,-8(fp)
 d024cc0:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 d024cc4:	010341b4 	movhi	r4,3334
 d024cc8:	2103c104 	addi	r4,r4,3844
 d024ccc:	e17ffe17 	ldw	r5,-8(fp)
 d024cd0:	d0253e00 	call	d0253e0 <putq>
 d024cd4:	00002f06 	br	d024d94 <pk_init+0x218>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 d024cd8:	d0a03617 	ldw	r2,-32552(gp)
 d024cdc:	11000144 	addi	r4,r2,5
 d024ce0:	d0266640 	call	d026664 <ncpalloc>
 d024ce4:	1007883a 	mov	r3,r2
 d024ce8:	e0bffe17 	ldw	r2,-8(fp)
 d024cec:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 d024cf0:	e0bffe17 	ldw	r2,-8(fp)
 d024cf4:	10800117 	ldw	r2,4(r2)
 d024cf8:	1005003a 	cmpeq	r2,r2,zero
 d024cfc:	1000371e 	bne	r2,zero,d024ddc <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d024d00:	e03ff915 	stw	zero,-28(fp)
 d024d04:	00000906 	br	d024d2c <pk_init+0x1b0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 d024d08:	e0bffe17 	ldw	r2,-8(fp)
 d024d0c:	10c00117 	ldw	r3,4(r2)
 d024d10:	e0bff917 	ldw	r2,-28(fp)
 d024d14:	1887883a 	add	r3,r3,r2
 d024d18:	00801344 	movi	r2,77
 d024d1c:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d024d20:	e0bff917 	ldw	r2,-28(fp)
 d024d24:	10800044 	addi	r2,r2,1
 d024d28:	e0bff915 	stw	r2,-28(fp)
 d024d2c:	e0bff917 	ldw	r2,-28(fp)
 d024d30:	10800110 	cmplti	r2,r2,4
 d024d34:	103ff41e 	bne	r2,zero,d024d08 <pk_init+0x18c>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 d024d38:	e0bffe17 	ldw	r2,-8(fp)
 d024d3c:	10c00117 	ldw	r3,4(r2)
 d024d40:	d0a03617 	ldw	r2,-32552(gp)
 d024d44:	1885883a 	add	r2,r3,r2
 d024d48:	10c00104 	addi	r3,r2,4
 d024d4c:	00801344 	movi	r2,77
 d024d50:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;
 d024d54:	e0bffe17 	ldw	r2,-8(fp)
 d024d58:	10800117 	ldw	r2,4(r2)
 d024d5c:	10c00104 	addi	r3,r2,4
 d024d60:	e0bffe17 	ldw	r2,-8(fp)
 d024d64:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 d024d68:	e0bffe17 	ldw	r2,-8(fp)
 d024d6c:	10800117 	ldw	r2,4(r2)
 d024d70:	1005003a 	cmpeq	r2,r2,zero
 d024d74:	1000191e 	bne	r2,zero,d024ddc <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 d024d78:	d0e03617 	ldw	r3,-32552(gp)
 d024d7c:	e0bffe17 	ldw	r2,-8(fp)
 d024d80:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 d024d84:	010341b4 	movhi	r4,3334
 d024d88:	21037c04 	addi	r4,r4,3568
 d024d8c:	e17ffe17 	ldw	r5,-8(fp)
 d024d90:	d0253e00 	call	d0253e0 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 d024d94:	e0bffd17 	ldw	r2,-12(fp)
 d024d98:	10800044 	addi	r2,r2,1
 d024d9c:	e0bffd15 	stw	r2,-12(fp)
 d024da0:	e0fffd17 	ldw	r3,-12(fp)
 d024da4:	e0bffc17 	ldw	r2,-16(fp)
 d024da8:	18bf7f36 	bltu	r3,r2,d024ba8 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 d024dac:	d0a03717 	ldw	r2,-32548(gp)
 d024db0:	1007883a 	mov	r3,r2
 d024db4:	008341b4 	movhi	r2,3334
 d024db8:	1083c104 	addi	r2,r2,3844
 d024dbc:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 d024dc0:	d0a03517 	ldw	r2,-32556(gp)
 d024dc4:	1007883a 	mov	r3,r2
 d024dc8:	008341b4 	movhi	r2,3334
 d024dcc:	10837c04 	addi	r2,r2,3568
 d024dd0:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 d024dd4:	e03fff15 	stw	zero,-4(fp)
 d024dd8:	00000606 	br	d024df4 <pk_init+0x278>

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 d024ddc:	01034174 	movhi	r4,3333
 d024de0:	213d2c04 	addi	r4,r4,-2896
 d024de4:	e17ffd17 	ldw	r5,-12(fp)
 d024de8:	d0028a00 	call	d0028a0 <printf>
#endif
   return(-1);
 d024dec:	00bfffc4 	movi	r2,-1
 d024df0:	e0bfff15 	stw	r2,-4(fp)
 d024df4:	e0bfff17 	ldw	r2,-4(fp)
}
 d024df8:	e037883a 	mov	sp,fp
 d024dfc:	dfc00117 	ldw	ra,4(sp)
 d024e00:	df000017 	ldw	fp,0(sp)
 d024e04:	dec00204 	addi	sp,sp,8
 d024e08:	f800283a 	ret

0d024e0c <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 d024e0c:	defffb04 	addi	sp,sp,-20
 d024e10:	dfc00415 	stw	ra,16(sp)
 d024e14:	df000315 	stw	fp,12(sp)
 d024e18:	df000304 	addi	fp,sp,12
 d024e1c:	e13ffe15 	stw	r4,-8(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 d024e20:	d0e03817 	ldw	r3,-32544(gp)
 d024e24:	e0bffe17 	ldw	r2,-8(fp)
 d024e28:	1880022e 	bgeu	r3,r2,d024e34 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 d024e2c:	e03fff15 	stw	zero,-4(fp)
 d024e30:	00002706 	br	d024ed0 <pk_alloc+0xc4>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 d024e34:	d0e03617 	ldw	r3,-32552(gp)
 d024e38:	e0bffe17 	ldw	r2,-8(fp)
 d024e3c:	18800536 	bltu	r3,r2,d024e54 <pk_alloc+0x48>
 d024e40:	008341b4 	movhi	r2,3334
 d024e44:	10837c04 	addi	r2,r2,3568
 d024e48:	10800217 	ldw	r2,8(r2)
 d024e4c:	1004c03a 	cmpne	r2,r2,zero
 d024e50:	1000051e 	bne	r2,zero,d024e68 <pk_alloc+0x5c>
         p = (PACKET)getq(&bigfreeq);
 d024e54:	010341b4 	movhi	r4,3334
 d024e58:	2103c104 	addi	r4,r4,3844
 d024e5c:	d0253180 	call	d025318 <getq>
 d024e60:	e0bffd15 	stw	r2,-12(fp)
      return(NULL);
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 d024e64:	00000406 	br	d024e78 <pk_alloc+0x6c>
         p = (PACKET)getq(&bigfreeq);
      else
         p = (PACKET)getq(&lilfreeq);
 d024e68:	010341b4 	movhi	r4,3334
 d024e6c:	21037c04 	addi	r4,r4,3568
 d024e70:	d0253180 	call	d025318 <getq>
 d024e74:	e0bffd15 	stw	r2,-12(fp)

      if (!p)
 d024e78:	e0bffd17 	ldw	r2,-12(fp)
 d024e7c:	1004c03a 	cmpne	r2,r2,zero
 d024e80:	1000021e 	bne	r2,zero,d024e8c <pk_alloc+0x80>
         return NULL;
 d024e84:	e03fff15 	stw	zero,-4(fp)
 d024e88:	00001106 	br	d024ed0 <pk_alloc+0xc4>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 d024e8c:	e0bffd17 	ldw	r2,-12(fp)
 d024e90:	10c00117 	ldw	r3,4(r2)
 d024e94:	00834174 	movhi	r2,3333
 d024e98:	109b1e04 	addi	r2,r2,27768
 d024e9c:	10800017 	ldw	r2,0(r2)
 d024ea0:	1887883a 	add	r3,r3,r2
 d024ea4:	e0bffd17 	ldw	r2,-12(fp)
 d024ea8:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 d024eac:	e0bffd17 	ldw	r2,-12(fp)
 d024eb0:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 d024eb4:	e0bffd17 	ldw	r2,-12(fp)
 d024eb8:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 d024ebc:	e0fffd17 	ldw	r3,-12(fp)
 d024ec0:	00800044 	movi	r2,1
 d024ec4:	18800915 	stw	r2,36(r3)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 d024ec8:	e0bffd17 	ldw	r2,-12(fp)
 d024ecc:	e0bfff15 	stw	r2,-4(fp)
 d024ed0:	e0bfff17 	ldw	r2,-4(fp)
}
 d024ed4:	e037883a 	mov	sp,fp
 d024ed8:	dfc00117 	ldw	ra,4(sp)
 d024edc:	df000017 	ldw	fp,0(sp)
 d024ee0:	dec00204 	addi	sp,sp,8
 d024ee4:	f800283a 	ret

0d024ee8 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 d024ee8:	defffa04 	addi	sp,sp,-24
 d024eec:	dfc00515 	stw	ra,20(sp)
 d024ef0:	df000415 	stw	fp,16(sp)
 d024ef4:	df000404 	addi	fp,sp,16
 d024ef8:	e13ffe15 	stw	r4,-8(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 d024efc:	e0bffe17 	ldw	r2,-8(fp)
 d024f00:	10800017 	ldw	r2,0(r2)
 d024f04:	1005003a 	cmpeq	r2,r2,zero
 d024f08:	1000101e 	bne	r2,zero,d024f4c <pk_validate+0x64>
 d024f0c:	e0bffe17 	ldw	r2,-8(fp)
 d024f10:	10800917 	ldw	r2,36(r2)
 d024f14:	1005003a 	cmpeq	r2,r2,zero
 d024f18:	10000c1e 	bne	r2,zero,d024f4c <pk_validate+0x64>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 d024f1c:	d025c500 	call	d025c50 <irq_Mask>
 d024f20:	008341b4 	movhi	r2,3334
 d024f24:	10838104 	addi	r2,r2,3588
 d024f28:	10800317 	ldw	r2,12(r2)
 d024f2c:	10c00044 	addi	r3,r2,1
 d024f30:	008341b4 	movhi	r2,3334
 d024f34:	10838104 	addi	r2,r2,3588
 d024f38:	10c00315 	stw	r3,12(r2)
 d024f3c:	d025cac0 	call	d025cac <irq_Unmask>
      return -1;
 d024f40:	00bfffc4 	movi	r2,-1
 d024f44:	e0bfff15 	stw	r2,-4(fp)
 d024f48:	00008f06 	br	d025188 <pk_validate+0x2a0>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 d024f4c:	e0bffe17 	ldw	r2,-8(fp)
 d024f50:	10c00217 	ldw	r3,8(r2)
 d024f54:	d0a03817 	ldw	r2,-32544(gp)
 d024f58:	1880221e 	bne	r3,r2,d024fe4 <pk_validate+0xfc>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 d024f5c:	d025c500 	call	d025c50 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 d024f60:	008341b4 	movhi	r2,3334
 d024f64:	1083c104 	addi	r2,r2,3844
 d024f68:	10800017 	ldw	r2,0(r2)
 d024f6c:	e0bffd15 	stw	r2,-12(fp)
 d024f70:	00001706 	br	d024fd0 <pk_validate+0xe8>
            if (p == pkt)
 d024f74:	e0fffd17 	ldw	r3,-12(fp)
 d024f78:	e0bffe17 	ldw	r2,-8(fp)
 d024f7c:	1880111e 	bne	r3,r2,d024fc4 <pk_validate+0xdc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 d024f80:	01034174 	movhi	r4,3333
 d024f84:	213d3704 	addi	r4,r4,-2852
 d024f88:	e17ffe17 	ldw	r5,-8(fp)
 d024f8c:	d0028a00 	call	d0028a0 <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 d024f90:	d025cac0 	call	d025cac <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 d024f94:	d025c500 	call	d025c50 <irq_Mask>
 d024f98:	008341b4 	movhi	r2,3334
 d024f9c:	10838104 	addi	r2,r2,3588
 d024fa0:	10800217 	ldw	r2,8(r2)
 d024fa4:	10c00044 	addi	r3,r2,1
 d024fa8:	008341b4 	movhi	r2,3334
 d024fac:	10838104 	addi	r2,r2,3588
 d024fb0:	10c00215 	stw	r3,8(r2)
 d024fb4:	d025cac0 	call	d025cac <irq_Unmask>
               return -1;
 d024fb8:	00bfffc4 	movi	r2,-1
 d024fbc:	e0bfff15 	stw	r2,-4(fp)
 d024fc0:	00007106 	br	d025188 <pk_validate+0x2a0>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 d024fc4:	e0bffd17 	ldw	r2,-12(fp)
 d024fc8:	10800017 	ldw	r2,0(r2)
 d024fcc:	e0bffd15 	stw	r2,-12(fp)
 d024fd0:	e0bffd17 	ldw	r2,-12(fp)
 d024fd4:	1004c03a 	cmpne	r2,r2,zero
 d024fd8:	103fe61e 	bne	r2,zero,d024f74 <pk_validate+0x8c>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 d024fdc:	d025cac0 	call	d025cac <irq_Unmask>
 d024fe0:	00003206 	br	d0250ac <pk_validate+0x1c4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 d024fe4:	e0bffe17 	ldw	r2,-8(fp)
 d024fe8:	10c00217 	ldw	r3,8(r2)
 d024fec:	d0a03617 	ldw	r2,-32552(gp)
 d024ff0:	1880221e 	bne	r3,r2,d02507c <pk_validate+0x194>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 d024ff4:	d025c500 	call	d025c50 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 d024ff8:	008341b4 	movhi	r2,3334
 d024ffc:	10837c04 	addi	r2,r2,3568
 d025000:	10800017 	ldw	r2,0(r2)
 d025004:	e0bffd15 	stw	r2,-12(fp)
 d025008:	00001706 	br	d025068 <pk_validate+0x180>
            if (p == pkt)
 d02500c:	e0fffd17 	ldw	r3,-12(fp)
 d025010:	e0bffe17 	ldw	r2,-8(fp)
 d025014:	1880111e 	bne	r3,r2,d02505c <pk_validate+0x174>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 d025018:	01034174 	movhi	r4,3333
 d02501c:	213d4104 	addi	r4,r4,-2812
 d025020:	e17ffe17 	ldw	r5,-8(fp)
 d025024:	d0028a00 	call	d0028a0 <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 d025028:	d025cac0 	call	d025cac <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 d02502c:	d025c500 	call	d025c50 <irq_Mask>
 d025030:	008341b4 	movhi	r2,3334
 d025034:	10838104 	addi	r2,r2,3588
 d025038:	10800217 	ldw	r2,8(r2)
 d02503c:	10c00044 	addi	r3,r2,1
 d025040:	008341b4 	movhi	r2,3334
 d025044:	10838104 	addi	r2,r2,3588
 d025048:	10c00215 	stw	r3,8(r2)
 d02504c:	d025cac0 	call	d025cac <irq_Unmask>
            return -1;
 d025050:	00bfffc4 	movi	r2,-1
 d025054:	e0bfff15 	stw	r2,-4(fp)
 d025058:	00004b06 	br	d025188 <pk_validate+0x2a0>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 d02505c:	e0bffd17 	ldw	r2,-12(fp)
 d025060:	10800017 	ldw	r2,0(r2)
 d025064:	e0bffd15 	stw	r2,-12(fp)
 d025068:	e0bffd17 	ldw	r2,-12(fp)
 d02506c:	1004c03a 	cmpne	r2,r2,zero
 d025070:	103fe61e 	bne	r2,zero,d02500c <pk_validate+0x124>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 d025074:	d025cac0 	call	d025cac <irq_Unmask>
 d025078:	00000c06 	br	d0250ac <pk_validate+0x1c4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 d02507c:	d025c500 	call	d025c50 <irq_Mask>
 d025080:	008341b4 	movhi	r2,3334
 d025084:	10838104 	addi	r2,r2,3588
 d025088:	10800017 	ldw	r2,0(r2)
 d02508c:	10c00044 	addi	r3,r2,1
 d025090:	008341b4 	movhi	r2,3334
 d025094:	10838104 	addi	r2,r2,3588
 d025098:	10c00015 	stw	r3,0(r2)
 d02509c:	d025cac0 	call	d025cac <irq_Unmask>
         return -1;
 d0250a0:	00bfffc4 	movi	r2,-1
 d0250a4:	e0bfff15 	stw	r2,-4(fp)
 d0250a8:	00003706 	br	d025188 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 d0250ac:	00800104 	movi	r2,4
 d0250b0:	e0bffc15 	stw	r2,-16(fp)
 d0250b4:	00001906 	br	d02511c <pk_validate+0x234>
   {
      if (*(pkt->nb_buff - j) != 'M')
 d0250b8:	e0bffe17 	ldw	r2,-8(fp)
 d0250bc:	10c00117 	ldw	r3,4(r2)
 d0250c0:	e0bffc17 	ldw	r2,-16(fp)
 d0250c4:	1885c83a 	sub	r2,r3,r2
 d0250c8:	10800003 	ldbu	r2,0(r2)
 d0250cc:	10803fcc 	andi	r2,r2,255
 d0250d0:	1080201c 	xori	r2,r2,128
 d0250d4:	10bfe004 	addi	r2,r2,-128
 d0250d8:	10801360 	cmpeqi	r2,r2,77
 d0250dc:	10000c1e 	bne	r2,zero,d025110 <pk_validate+0x228>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 d0250e0:	d025c500 	call	d025c50 <irq_Mask>
 d0250e4:	008341b4 	movhi	r2,3334
 d0250e8:	10838104 	addi	r2,r2,3588
 d0250ec:	10800117 	ldw	r2,4(r2)
 d0250f0:	10c00044 	addi	r3,r2,1
 d0250f4:	008341b4 	movhi	r2,3334
 d0250f8:	10838104 	addi	r2,r2,3588
 d0250fc:	10c00115 	stw	r3,4(r2)
 d025100:	d025cac0 	call	d025cac <irq_Unmask>
         return -1;
 d025104:	00bfffc4 	movi	r2,-1
 d025108:	e0bfff15 	stw	r2,-4(fp)
 d02510c:	00001e06 	br	d025188 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 d025110:	e0bffc17 	ldw	r2,-16(fp)
 d025114:	10bfffc4 	addi	r2,r2,-1
 d025118:	e0bffc15 	stw	r2,-16(fp)
 d02511c:	e0bffc17 	ldw	r2,-16(fp)
 d025120:	10800048 	cmpgei	r2,r2,1
 d025124:	103fe41e 	bne	r2,zero,d0250b8 <pk_validate+0x1d0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 d025128:	e0bffe17 	ldw	r2,-8(fp)
 d02512c:	10c00117 	ldw	r3,4(r2)
 d025130:	e0bffe17 	ldw	r2,-8(fp)
 d025134:	10800217 	ldw	r2,8(r2)
 d025138:	1885883a 	add	r2,r3,r2
 d02513c:	10800003 	ldbu	r2,0(r2)
 d025140:	10803fcc 	andi	r2,r2,255
 d025144:	1080201c 	xori	r2,r2,128
 d025148:	10bfe004 	addi	r2,r2,-128
 d02514c:	10801360 	cmpeqi	r2,r2,77
 d025150:	10000c1e 	bne	r2,zero,d025184 <pk_validate+0x29c>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 d025154:	d025c500 	call	d025c50 <irq_Mask>
 d025158:	008341b4 	movhi	r2,3334
 d02515c:	10838104 	addi	r2,r2,3588
 d025160:	10800117 	ldw	r2,4(r2)
 d025164:	10c00044 	addi	r3,r2,1
 d025168:	008341b4 	movhi	r2,3334
 d02516c:	10838104 	addi	r2,r2,3588
 d025170:	10c00115 	stw	r3,4(r2)
 d025174:	d025cac0 	call	d025cac <irq_Unmask>
      return -1;
 d025178:	00bfffc4 	movi	r2,-1
 d02517c:	e0bfff15 	stw	r2,-4(fp)
 d025180:	00000106 	br	d025188 <pk_validate+0x2a0>
   }
#endif /* NPDEBUG */

   return 0;
 d025184:	e03fff15 	stw	zero,-4(fp)
 d025188:	e0bfff17 	ldw	r2,-4(fp)
}
 d02518c:	e037883a 	mov	sp,fp
 d025190:	dfc00117 	ldw	ra,4(sp)
 d025194:	df000017 	ldw	fp,0(sp)
 d025198:	dec00204 	addi	sp,sp,8
 d02519c:	f800283a 	ret

0d0251a0 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 d0251a0:	defffc04 	addi	sp,sp,-16
 d0251a4:	dfc00315 	stw	ra,12(sp)
 d0251a8:	df000215 	stw	fp,8(sp)
 d0251ac:	df000204 	addi	fp,sp,8
 d0251b0:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 d0251b4:	e13fff17 	ldw	r4,-4(fp)
 d0251b8:	d024ee80 	call	d024ee8 <pk_validate>
 d0251bc:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 d0251c0:	e0bffe17 	ldw	r2,-8(fp)
 d0251c4:	1004c03a 	cmpne	r2,r2,zero
 d0251c8:	10001b1e 	bne	r2,zero,d025238 <pk_free+0x98>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 d0251cc:	e0bfff17 	ldw	r2,-4(fp)
 d0251d0:	10c00917 	ldw	r3,36(r2)
 d0251d4:	188000a8 	cmpgeui	r2,r3,2
 d0251d8:	1009883a 	mov	r4,r2
 d0251dc:	18ffffc4 	addi	r3,r3,-1
 d0251e0:	e0bfff17 	ldw	r2,-4(fp)
 d0251e4:	10c00915 	stw	r3,36(r2)
 d0251e8:	20803fcc 	andi	r2,r4,255
 d0251ec:	1004c03a 	cmpne	r2,r2,zero
 d0251f0:	1000111e 	bne	r2,zero,d025238 <pk_free+0x98>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 d0251f4:	e0bfff17 	ldw	r2,-4(fp)
 d0251f8:	10c00217 	ldw	r3,8(r2)
 d0251fc:	d0a03817 	ldw	r2,-32544(gp)
 d025200:	1880051e 	bne	r3,r2,d025218 <pk_free+0x78>
            q_add(&bigfreeq, (qp)pkt);
 d025204:	e17fff17 	ldw	r5,-4(fp)
 d025208:	010341b4 	movhi	r4,3334
 d02520c:	2103c104 	addi	r4,r4,3844
 d025210:	d0253e00 	call	d0253e0 <putq>
 d025214:	00000806 	br	d025238 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 d025218:	e0bfff17 	ldw	r2,-4(fp)
 d02521c:	10c00217 	ldw	r3,8(r2)
 d025220:	d0a03617 	ldw	r2,-32552(gp)
 d025224:	1880041e 	bne	r3,r2,d025238 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 d025228:	e17fff17 	ldw	r5,-4(fp)
 d02522c:	010341b4 	movhi	r4,3334
 d025230:	21037c04 	addi	r4,r4,3568
 d025234:	d0253e00 	call	d0253e0 <putq>
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 d025238:	e037883a 	mov	sp,fp
 d02523c:	dfc00117 	ldw	ra,4(sp)
 d025240:	df000017 	ldw	fp,0(sp)
 d025244:	dec00204 	addi	sp,sp,8
 d025248:	f800283a 	ret

0d02524c <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 d02524c:	deffff04 	addi	sp,sp,-4
 d025250:	df000015 	stw	fp,0(sp)
 d025254:	d839883a 	mov	fp,sp
   return bigbufsiz;
 d025258:	d0a03817 	ldw	r2,-32544(gp)
}
 d02525c:	e037883a 	mov	sp,fp
 d025260:	df000017 	ldw	fp,0(sp)
 d025264:	dec00104 	addi	sp,sp,4
 d025268:	f800283a 	ret

0d02526c <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 d02526c:	defff904 	addi	sp,sp,-28
 d025270:	dfc00615 	stw	ra,24(sp)
 d025274:	df000515 	stw	fp,20(sp)
 d025278:	df000504 	addi	fp,sp,20
 d02527c:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d025280:	01000084 	movi	r4,2
 d025284:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 d025288:	d025c500 	call	d025c50 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 d02528c:	00c341b4 	movhi	r3,3334
 d025290:	18c38104 	addi	r3,r3,3588
 d025294:	18800017 	ldw	r2,0(r3)
 d025298:	e0bffb15 	stw	r2,-20(fp)
 d02529c:	18800117 	ldw	r2,4(r3)
 d0252a0:	e0bffc15 	stw	r2,-16(fp)
 d0252a4:	18800217 	ldw	r2,8(r3)
 d0252a8:	e0bffd15 	stw	r2,-12(fp)
 d0252ac:	18800317 	ldw	r2,12(r3)
 d0252b0:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 d0252b4:	d025cac0 	call	d025cac <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0252b8:	01000084 	movi	r4,2
 d0252bc:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 d0252c0:	e13fff17 	ldw	r4,-4(fp)
 d0252c4:	01434174 	movhi	r5,3333
 d0252c8:	297d4b04 	addi	r5,r5,-2772
 d0252cc:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 d0252d0:	e1bffb17 	ldw	r6,-20(fp)
 d0252d4:	e1fffc17 	ldw	r7,-16(fp)
 d0252d8:	e13fff17 	ldw	r4,-4(fp)
 d0252dc:	01434174 	movhi	r5,3333
 d0252e0:	297d5404 	addi	r5,r5,-2736
 d0252e4:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 d0252e8:	e1bffd17 	ldw	r6,-12(fp)
 d0252ec:	e1fffe17 	ldw	r7,-8(fp)
 d0252f0:	e13fff17 	ldw	r4,-4(fp)
 d0252f4:	01434174 	movhi	r5,3333
 d0252f8:	297d6104 	addi	r5,r5,-2684
 d0252fc:	d020b640 	call	d020b64 <ns_printf>

   return 0;
 d025300:	0005883a 	mov	r2,zero
}
 d025304:	e037883a 	mov	sp,fp
 d025308:	dfc00117 	ldw	ra,4(sp)
 d02530c:	df000017 	ldw	fp,0(sp)
 d025310:	dec00204 	addi	sp,sp,8
 d025314:	f800283a 	ret

0d025318 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 d025318:	defffb04 	addi	sp,sp,-20
 d02531c:	dfc00415 	stw	ra,16(sp)
 d025320:	df000315 	stw	fp,12(sp)
 d025324:	df000304 	addi	fp,sp,12
 d025328:	e13ffe15 	stw	r4,-8(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 d02532c:	d025c500 	call	d025c50 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 d025330:	e0bffe17 	ldw	r2,-8(fp)
 d025334:	10800017 	ldw	r2,0(r2)
 d025338:	e0bffd15 	stw	r2,-12(fp)
 d02533c:	e0bffd17 	ldw	r2,-12(fp)
 d025340:	1004c03a 	cmpne	r2,r2,zero
 d025344:	1000031e 	bne	r2,zero,d025354 <getq+0x3c>
   {
      EXIT_CRIT_SECTION(q);
 d025348:	d025cac0 	call	d025cac <irq_Unmask>
      return (0);             /* yes, show none */
 d02534c:	e03fff15 	stw	zero,-4(fp)
 d025350:	00001d06 	br	d0253c8 <getq+0xb0>
   }

   q->q_head = temp->qe_next; /* else unlink */
 d025354:	e0bffd17 	ldw	r2,-12(fp)
 d025358:	10c00017 	ldw	r3,0(r2)
 d02535c:	e0bffe17 	ldw	r2,-8(fp)
 d025360:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 d025364:	e0bffd17 	ldw	r2,-12(fp)
 d025368:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 d02536c:	e0bffe17 	ldw	r2,-8(fp)
 d025370:	10800017 	ldw	r2,0(r2)
 d025374:	1004c03a 	cmpne	r2,r2,zero
 d025378:	1000021e 	bne	r2,zero,d025384 <getq+0x6c>
      q->q_tail = 0;          /* yes, update tail pointer too */
 d02537c:	e0bffe17 	ldw	r2,-8(fp)
 d025380:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 d025384:	e0bffe17 	ldw	r2,-8(fp)
 d025388:	10800217 	ldw	r2,8(r2)
 d02538c:	10ffffc4 	addi	r3,r2,-1
 d025390:	e0bffe17 	ldw	r2,-8(fp)
 d025394:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 d025398:	e0bffe17 	ldw	r2,-8(fp)
 d02539c:	10c00217 	ldw	r3,8(r2)
 d0253a0:	e0bffe17 	ldw	r2,-8(fp)
 d0253a4:	10800417 	ldw	r2,16(r2)
 d0253a8:	1880040e 	bge	r3,r2,d0253bc <getq+0xa4>
      q->q_min = q->q_len;
 d0253ac:	e0bffe17 	ldw	r2,-8(fp)
 d0253b0:	10c00217 	ldw	r3,8(r2)
 d0253b4:	e0bffe17 	ldw	r2,-8(fp)
 d0253b8:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 d0253bc:	d025cac0 	call	d025cac <irq_Unmask>

   return ((void*)temp);
 d0253c0:	e0bffd17 	ldw	r2,-12(fp)
 d0253c4:	e0bfff15 	stw	r2,-4(fp)
 d0253c8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0253cc:	e037883a 	mov	sp,fp
 d0253d0:	dfc00117 	ldw	ra,4(sp)
 d0253d4:	df000017 	ldw	fp,0(sp)
 d0253d8:	dec00204 	addi	sp,sp,8
 d0253dc:	f800283a 	ret

0d0253e0 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 d0253e0:	defffc04 	addi	sp,sp,-16
 d0253e4:	dfc00315 	stw	ra,12(sp)
 d0253e8:	df000215 	stw	fp,8(sp)
 d0253ec:	df000204 	addi	fp,sp,8
 d0253f0:	e13ffe15 	stw	r4,-8(fp)
 d0253f4:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 d0253f8:	d025c500 	call	d025c50 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 d0253fc:	e0bfff17 	ldw	r2,-4(fp)
 d025400:	10000015 	stw	zero,0(r2)
 d025404:	e0bffe17 	ldw	r2,-8(fp)
 d025408:	10800017 	ldw	r2,0(r2)
 d02540c:	1004c03a 	cmpne	r2,r2,zero
 d025410:	1000041e 	bne	r2,zero,d025424 <putq+0x44>
 d025414:	e0ffff17 	ldw	r3,-4(fp)
 d025418:	e0bffe17 	ldw	r2,-8(fp)
 d02541c:	10c00015 	stw	r3,0(r2)
 d025420:	00000406 	br	d025434 <putq+0x54>
 d025424:	e0bffe17 	ldw	r2,-8(fp)
 d025428:	10c00117 	ldw	r3,4(r2)
 d02542c:	e0bfff17 	ldw	r2,-4(fp)
 d025430:	18800015 	stw	r2,0(r3)
 d025434:	e0ffff17 	ldw	r3,-4(fp)
 d025438:	e0bffe17 	ldw	r2,-8(fp)
 d02543c:	10c00115 	stw	r3,4(r2)
 d025440:	e0bffe17 	ldw	r2,-8(fp)
 d025444:	10800217 	ldw	r2,8(r2)
 d025448:	10c00044 	addi	r3,r2,1
 d02544c:	e0bffe17 	ldw	r2,-8(fp)
 d025450:	10c00215 	stw	r3,8(r2)
 d025454:	e0bffe17 	ldw	r2,-8(fp)
 d025458:	10c00217 	ldw	r3,8(r2)
 d02545c:	e0bffe17 	ldw	r2,-8(fp)
 d025460:	10800317 	ldw	r2,12(r2)
 d025464:	10c0040e 	bge	r2,r3,d025478 <putq+0x98>
 d025468:	e0bffe17 	ldw	r2,-8(fp)
 d02546c:	10c00217 	ldw	r3,8(r2)
 d025470:	e0bffe17 	ldw	r2,-8(fp)
 d025474:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 d025478:	d025cac0 	call	d025cac <irq_Unmask>
}
 d02547c:	e037883a 	mov	sp,fp
 d025480:	dfc00117 	ldw	ra,4(sp)
 d025484:	df000017 	ldw	fp,0(sp)
 d025488:	dec00204 	addi	sp,sp,8
 d02548c:	f800283a 	ret

0d025490 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 d025490:	defff904 	addi	sp,sp,-28
 d025494:	dfc00615 	stw	ra,24(sp)
 d025498:	df000515 	stw	fp,20(sp)
 d02549c:	df000504 	addi	fp,sp,20
 d0254a0:	e13ffd15 	stw	r4,-12(fp)
 d0254a4:	e17ffe15 	stw	r5,-8(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 d0254a8:	d025c500 	call	d025c50 <irq_Mask>
   qptr = q->q_head;
 d0254ac:	e0bffd17 	ldw	r2,-12(fp)
 d0254b0:	10800017 	ldw	r2,0(r2)
 d0254b4:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 d0254b8:	e03ffb15 	stw	zero,-20(fp)
   while (qptr)
 d0254bc:	00002d06 	br	d025574 <qdel+0xe4>
   {
      if (qptr == (qp)elt)
 d0254c0:	e0fffe17 	ldw	r3,-8(fp)
 d0254c4:	e0bffc17 	ldw	r2,-16(fp)
 d0254c8:	10c0251e 	bne	r2,r3,d025560 <qdel+0xd0>
      {
         /* found our item; dequeue it */
         if (qlast)
 d0254cc:	e0bffb17 	ldw	r2,-20(fp)
 d0254d0:	1005003a 	cmpeq	r2,r2,zero
 d0254d4:	1000051e 	bne	r2,zero,d0254ec <qdel+0x5c>
            qlast->qe_next = qptr->qe_next;
 d0254d8:	e0bffc17 	ldw	r2,-16(fp)
 d0254dc:	10c00017 	ldw	r3,0(r2)
 d0254e0:	e0bffb17 	ldw	r2,-20(fp)
 d0254e4:	10c00015 	stw	r3,0(r2)
 d0254e8:	00000406 	br	d0254fc <qdel+0x6c>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 d0254ec:	e0bffc17 	ldw	r2,-16(fp)
 d0254f0:	10c00017 	ldw	r3,0(r2)
 d0254f4:	e0bffd17 	ldw	r2,-12(fp)
 d0254f8:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 d0254fc:	e0bffd17 	ldw	r2,-12(fp)
 d025500:	10c00117 	ldw	r3,4(r2)
 d025504:	e0bffe17 	ldw	r2,-8(fp)
 d025508:	1880031e 	bne	r3,r2,d025518 <qdel+0x88>
            q->q_tail = qlast;
 d02550c:	e0fffd17 	ldw	r3,-12(fp)
 d025510:	e0bffb17 	ldw	r2,-20(fp)
 d025514:	18800115 	stw	r2,4(r3)

         /* fix queue counters */
         q->q_len--;
 d025518:	e0bffd17 	ldw	r2,-12(fp)
 d02551c:	10800217 	ldw	r2,8(r2)
 d025520:	10ffffc4 	addi	r3,r2,-1
 d025524:	e0bffd17 	ldw	r2,-12(fp)
 d025528:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 d02552c:	e0bffd17 	ldw	r2,-12(fp)
 d025530:	10c00217 	ldw	r3,8(r2)
 d025534:	e0bffd17 	ldw	r2,-12(fp)
 d025538:	10800417 	ldw	r2,16(r2)
 d02553c:	1880040e 	bge	r3,r2,d025550 <qdel+0xc0>
            q->q_min = q->q_len;
 d025540:	e0bffd17 	ldw	r2,-12(fp)
 d025544:	10c00217 	ldw	r3,8(r2)
 d025548:	e0bffd17 	ldw	r2,-12(fp)
 d02554c:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 d025550:	d025cac0 	call	d025cac <irq_Unmask>
         return (qp)elt;   /* success exit point */
 d025554:	e0bffe17 	ldw	r2,-8(fp)
 d025558:	e0bfff15 	stw	r2,-4(fp)
 d02555c:	00000a06 	br	d025588 <qdel+0xf8>
      }
      qlast = qptr;
 d025560:	e0bffc17 	ldw	r2,-16(fp)
 d025564:	e0bffb15 	stw	r2,-20(fp)
      qptr = qptr->qe_next;
 d025568:	e0bffc17 	ldw	r2,-16(fp)
 d02556c:	10800017 	ldw	r2,0(r2)
 d025570:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 d025574:	e0bffc17 	ldw	r2,-16(fp)
 d025578:	1004c03a 	cmpne	r2,r2,zero
 d02557c:	103fd01e 	bne	r2,zero,d0254c0 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 d025580:	d025cac0 	call	d025cac <irq_Unmask>
   return NULL;   /* item not found in queue */
 d025584:	e03fff15 	stw	zero,-4(fp)
 d025588:	e0bfff17 	ldw	r2,-4(fp)
}
 d02558c:	e037883a 	mov	sp,fp
 d025590:	dfc00117 	ldw	ra,4(sp)
 d025594:	df000017 	ldw	fp,0(sp)
 d025598:	dec00204 	addi	sp,sp,8
 d02559c:	f800283a 	ret

0d0255a0 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 d0255a0:	defff304 	addi	sp,sp,-52
 d0255a4:	dfc00c15 	stw	ra,48(sp)
 d0255a8:	df000b15 	stw	fp,44(sp)
 d0255ac:	df000b04 	addi	fp,sp,44
 d0255b0:	e13ffb15 	stw	r4,-20(fp)
 d0255b4:	e1fffe15 	stw	r7,-8(fp)
 d0255b8:	e17ffc0d 	sth	r5,-16(fp)
 d0255bc:	e1bffd0d 	sth	r6,-12(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 d0255c0:	00834174 	movhi	r2,3333
 d0255c4:	109b2004 	addi	r2,r2,27776
 d0255c8:	10800017 	ldw	r2,0(r2)
 d0255cc:	1080010c 	andi	r2,r2,4
 d0255d0:	1005003a 	cmpeq	r2,r2,zero
 d0255d4:	1000171e 	bne	r2,zero,d025634 <udp_open+0x94>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 d0255d8:	e0bffb17 	ldw	r2,-20(fp)
 d0255dc:	11803fcc 	andi	r6,r2,255
 d0255e0:	e0bffb17 	ldw	r2,-20(fp)
 d0255e4:	1004d23a 	srli	r2,r2,8
 d0255e8:	11c03fcc 	andi	r7,r2,255
 d0255ec:	e0bffb17 	ldw	r2,-20(fp)
 d0255f0:	1004d43a 	srli	r2,r2,16
 d0255f4:	12003fcc 	andi	r8,r2,255
 d0255f8:	e0bffb17 	ldw	r2,-20(fp)
 d0255fc:	1006d63a 	srli	r3,r2,24
 d025600:	e13ffd0b 	ldhu	r4,-12(fp)
 d025604:	e17ffc0b 	ldhu	r5,-16(fp)
 d025608:	e0800217 	ldw	r2,8(fp)
 d02560c:	d8c00015 	stw	r3,0(sp)
 d025610:	d9000115 	stw	r4,4(sp)
 d025614:	d9400215 	stw	r5,8(sp)
 d025618:	d8800315 	stw	r2,12(sp)
 d02561c:	01034174 	movhi	r4,3333
 d025620:	213d6d04 	addi	r4,r4,-2636
 d025624:	300b883a 	mov	r5,r6
 d025628:	380d883a 	mov	r6,r7
 d02562c:	400f883a 	mov	r7,r8
 d025630:	d0028a00 	call	d0028a0 <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 d025634:	0009883a 	mov	r4,zero
 d025638:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   ocon = NULL;
 d02563c:	e03ff915 	stw	zero,-28(fp)
   for (con = firstudp; con; con = con->u_next)
 d025640:	d0a91a17 	ldw	r2,-23448(gp)
 d025644:	e0bffa15 	stw	r2,-24(fp)
 d025648:	00002406 	br	d0256dc <udp_open+0x13c>
   {
      ocon = con;       /* remember last con in list */
 d02564c:	e0bffa17 	ldw	r2,-24(fp)
 d025650:	e0bff915 	stw	r2,-28(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 d025654:	e0bffa17 	ldw	r2,-24(fp)
 d025658:	1080018b 	ldhu	r2,6(r2)
 d02565c:	10ffffcc 	andi	r3,r2,65535
 d025660:	e0bffd0b 	ldhu	r2,-12(fp)
 d025664:	18801a1e 	bne	r3,r2,d0256d0 <udp_open+0x130>
 d025668:	e0bffa17 	ldw	r2,-24(fp)
 d02566c:	1080020b 	ldhu	r2,8(r2)
 d025670:	10ffffcc 	andi	r3,r2,65535
 d025674:	e0bffc0b 	ldhu	r2,-16(fp)
 d025678:	1880151e 	bne	r3,r2,d0256d0 <udp_open+0x130>
 d02567c:	e0bffa17 	ldw	r2,-24(fp)
 d025680:	10800317 	ldw	r2,12(r2)
 d025684:	1004c03a 	cmpne	r2,r2,zero
 d025688:	1000111e 	bne	r2,zero,d0256d0 <udp_open+0x130>
 d02568c:	e0bffa17 	ldw	r2,-24(fp)
 d025690:	10c00417 	ldw	r3,16(r2)
 d025694:	e0bffb17 	ldw	r2,-20(fp)
 d025698:	18800d1e 	bne	r3,r2,d0256d0 <udp_open+0x130>
          con->u_lhost == 0 && con->u_fhost == fhost)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 d02569c:	00834174 	movhi	r2,3333
 d0256a0:	109b2004 	addi	r2,r2,27776
 d0256a4:	10800017 	ldw	r2,0(r2)
 d0256a8:	1080050c 	andi	r2,r2,20
 d0256ac:	1005003a 	cmpeq	r2,r2,zero
 d0256b0:	1000031e 	bne	r2,zero,d0256c0 <udp_open+0x120>
            dprintf("UDP: Connection already exists.\n");
 d0256b4:	01034174 	movhi	r4,3333
 d0256b8:	213d7c04 	addi	r4,r4,-2576
 d0256bc:	d002bc80 	call	d002bc8 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 d0256c0:	0009883a 	mov	r4,zero
 d0256c4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return(NULL);
 d0256c8:	e03fff15 	stw	zero,-4(fp)
 d0256cc:	00003c06 	br	d0257c0 <udp_open+0x220>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 d0256d0:	e0bffa17 	ldw	r2,-24(fp)
 d0256d4:	10800017 	ldw	r2,0(r2)
 d0256d8:	e0bffa15 	stw	r2,-24(fp)
 d0256dc:	e0bffa17 	ldw	r2,-24(fp)
 d0256e0:	1004c03a 	cmpne	r2,r2,zero
 d0256e4:	103fd91e 	bne	r2,zero,d02564c <udp_open+0xac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 d0256e8:	01000804 	movi	r4,32
 d0256ec:	d0264b80 	call	d0264b8 <npalloc>
 d0256f0:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 d0256f4:	e0bffa17 	ldw	r2,-24(fp)
 d0256f8:	1004c03a 	cmpne	r2,r2,zero
 d0256fc:	10000d1e 	bne	r2,zero,d025734 <udp_open+0x194>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 d025700:	00834174 	movhi	r2,3333
 d025704:	109b2004 	addi	r2,r2,27776
 d025708:	10800017 	ldw	r2,0(r2)
 d02570c:	1080010c 	andi	r2,r2,4
 d025710:	1005003a 	cmpeq	r2,r2,zero
 d025714:	1000031e 	bne	r2,zero,d025724 <udp_open+0x184>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 d025718:	01034174 	movhi	r4,3333
 d02571c:	213d8404 	addi	r4,r4,-2544
 d025720:	d002bc80 	call	d002bc8 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 d025724:	0009883a 	mov	r4,zero
 d025728:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return(NULL);
 d02572c:	e03fff15 	stw	zero,-4(fp)
 d025730:	00002306 	br	d0257c0 <udp_open+0x220>
   }

   if (ocon)   /* ocon is end of list */
 d025734:	e0bff917 	ldw	r2,-28(fp)
 d025738:	1005003a 	cmpeq	r2,r2,zero
 d02573c:	1000041e 	bne	r2,zero,d025750 <udp_open+0x1b0>
      ocon->u_next = con;  /* add new connection to end */
 d025740:	e0fff917 	ldw	r3,-28(fp)
 d025744:	e0bffa17 	ldw	r2,-24(fp)
 d025748:	18800015 	stw	r2,0(r3)
 d02574c:	00000206 	br	d025758 <udp_open+0x1b8>
   else  /* no list, start one */
      firstudp = con;
 d025750:	e0bffa17 	ldw	r2,-24(fp)
 d025754:	d0a91a15 	stw	r2,-23448(gp)

   con->u_next = 0;
 d025758:	e0bffa17 	ldw	r2,-24(fp)
 d02575c:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 d025760:	e0fffa17 	ldw	r3,-24(fp)
 d025764:	e0bffd0b 	ldhu	r2,-12(fp)
 d025768:	1880018d 	sth	r2,6(r3)
   con->u_fport = fsock;
 d02576c:	e0fffa17 	ldw	r3,-24(fp)
 d025770:	e0bffc0b 	ldhu	r2,-16(fp)
 d025774:	1880020d 	sth	r2,8(r3)
   con->u_lhost = 0;
 d025778:	e0bffa17 	ldw	r2,-24(fp)
 d02577c:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 d025780:	e0fffa17 	ldw	r3,-24(fp)
 d025784:	e0bffb17 	ldw	r2,-20(fp)
 d025788:	18800415 	stw	r2,16(r3)
   con->u_rcv   = handler;
 d02578c:	e0fffa17 	ldw	r3,-24(fp)
 d025790:	e0bffe17 	ldw	r2,-8(fp)
 d025794:	18800515 	stw	r2,20(r3)
   con->u_data  = data;
 d025798:	e0fffa17 	ldw	r3,-24(fp)
 d02579c:	e0800217 	ldw	r2,8(fp)
 d0257a0:	18800615 	stw	r2,24(r3)
   con->u_flags = UDPCF_V4;
 d0257a4:	e0fffa17 	ldw	r3,-24(fp)
 d0257a8:	00800044 	movi	r2,1
 d0257ac:	1880010d 	sth	r2,4(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 d0257b0:	0009883a 	mov	r4,zero
 d0257b4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return(con);
 d0257b8:	e0bffa17 	ldw	r2,-24(fp)
 d0257bc:	e0bfff15 	stw	r2,-4(fp)
 d0257c0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0257c4:	e037883a 	mov	sp,fp
 d0257c8:	dfc00117 	ldw	ra,4(sp)
 d0257cc:	df000017 	ldw	fp,0(sp)
 d0257d0:	dec00204 	addi	sp,sp,8
 d0257d4:	f800283a 	ret

0d0257d8 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 d0257d8:	defffb04 	addi	sp,sp,-20
 d0257dc:	dfc00415 	stw	ra,16(sp)
 d0257e0:	df000315 	stw	fp,12(sp)
 d0257e4:	df000304 	addi	fp,sp,12
 d0257e8:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 d0257ec:	e0bfff17 	ldw	r2,-4(fp)
 d0257f0:	1005003a 	cmpeq	r2,r2,zero
 d0257f4:	1000031e 	bne	r2,zero,d025804 <udp_close+0x2c>
 d0257f8:	d0a91a17 	ldw	r2,-23448(gp)
 d0257fc:	1004c03a 	cmpne	r2,r2,zero
 d025800:	1000021e 	bne	r2,zero,d02580c <udp_close+0x34>
   {
      dtrap(); /* bad programming! */
 d025804:	d025a500 	call	d025a50 <dtrap>
      return;
 d025808:	00002706 	br	d0258a8 <udp_close+0xd0>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 d02580c:	0009883a 	mov	r4,zero
 d025810:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 d025814:	e03ffd15 	stw	zero,-12(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 d025818:	d0a91a17 	ldw	r2,-23448(gp)
 d02581c:	e0bffe15 	stw	r2,-8(fp)
 d025820:	00000806 	br	d025844 <udp_close+0x6c>
   {
      if (pcon == con)  /* found connection to delete */
 d025824:	e0fffe17 	ldw	r3,-8(fp)
 d025828:	e0bfff17 	ldw	r2,-4(fp)
 d02582c:	18800826 	beq	r3,r2,d025850 <udp_close+0x78>
      break;
      lcon = pcon;   /* remember last connection */
 d025830:	e0bffe17 	ldw	r2,-8(fp)
 d025834:	e0bffd15 	stw	r2,-12(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 d025838:	e0bffe17 	ldw	r2,-8(fp)
 d02583c:	10800017 	ldw	r2,0(r2)
 d025840:	e0bffe15 	stw	r2,-8(fp)
 d025844:	e0bffe17 	ldw	r2,-8(fp)
 d025848:	1004c03a 	cmpne	r2,r2,zero
 d02584c:	103ff51e 	bne	r2,zero,d025824 <udp_close+0x4c>
      if (pcon == con)  /* found connection to delete */
      break;
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 d025850:	e0bffe17 	ldw	r2,-8(fp)
 d025854:	1004c03a 	cmpne	r2,r2,zero
 d025858:	1000041e 	bne	r2,zero,d02586c <udp_close+0x94>
   {
      dtrap(); /* prog error - connenction not in list */
 d02585c:	d025a500 	call	d025a50 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 d025860:	0009883a 	mov	r4,zero
 d025864:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return;
 d025868:	00000f06 	br	d0258a8 <udp_close+0xd0>
   }

   if (lcon)   /* in con is not head of list */
 d02586c:	e0bffd17 	ldw	r2,-12(fp)
 d025870:	1005003a 	cmpeq	r2,r2,zero
 d025874:	1000051e 	bne	r2,zero,d02588c <udp_close+0xb4>
      lcon->u_next = con->u_next;   /* unlink */
 d025878:	e0bfff17 	ldw	r2,-4(fp)
 d02587c:	10c00017 	ldw	r3,0(r2)
 d025880:	e0bffd17 	ldw	r2,-12(fp)
 d025884:	10c00015 	stw	r3,0(r2)
 d025888:	00000306 	br	d025898 <udp_close+0xc0>
   else
      firstudp = con->u_next; /* remove from head */
 d02588c:	e0bfff17 	ldw	r2,-4(fp)
 d025890:	10800017 	ldw	r2,0(r2)
 d025894:	d0a91a15 	stw	r2,-23448(gp)

   UC_FREE(con);  /* free memory for structure */
 d025898:	e13fff17 	ldw	r4,-4(fp)
 d02589c:	d0265ac0 	call	d0265ac <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d0258a0:	0009883a 	mov	r4,zero
 d0258a4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
}
 d0258a8:	e037883a 	mov	sp,fp
 d0258ac:	dfc00117 	ldw	ra,4(sp)
 d0258b0:	df000017 	ldw	fp,0(sp)
 d0258b4:	dec00204 	addi	sp,sp,8
 d0258b8:	f800283a 	ret

0d0258bc <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 d0258bc:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 d0258c0:	0140620e 	bge	zero,r5,d025a4c <done>

      mov   r6, zero		       /* carry accumulator */
 d0258c4:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 d0258c8:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 d0258cc:	18000326 	beq	r3,zero,d0258dc <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 d0258d0:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 d0258d4:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 d0258d8:	297fffc4 	addi	r5,r5,-1

0d0258dc <asm1>:
 d0258dc:	02c340b4 	movhi	r11,3330
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 d0258e0:	5ad68204 	addi	r11,r11,23048
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 d0258e4:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 d0258e8:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 d0258ec:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 d0258f0:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 d0258f4:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 d0258f8:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 d0258fc:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 d025900:	5800683a 	jmp	r11

0d025904 <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 d025904:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 d025908:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 d02590c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025910:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025914:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 d025918:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 d02591c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025920:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025924:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 d025928:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 d02592c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025930:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025934:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 d025938:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 d02593c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025940:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025944:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 d025948:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 d02594c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025950:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025954:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 d025958:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 d02595c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025960:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025964:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 d025968:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 d02596c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025970:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025974:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 d025978:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 d02597c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025980:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025984:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 d025988:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 d02598c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025990:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025994:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 d025998:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 d02599c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0259a0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0259a4:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 d0259a8:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 d0259ac:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0259b0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0259b4:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 d0259b8:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 d0259bc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0259c0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0259c4:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 d0259c8:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 d0259cc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0259d0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0259d4:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 d0259d8:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 d0259dc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0259e0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0259e4:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 d0259e8:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 d0259ec:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0259f0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0259f4:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 d0259f8:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 d0259fc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025a00:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025a04:	418d883a 	add	r6,r8,r6

0d025a08 <loop0>:
loop0:
      subi  r5, r5, 16
 d025a08:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 d025a0c:	283fbd0e 	bge	r5,zero,d025904 <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 d025a10:	48000426 	beq	r9,zero,d025a24 <fold>
      ldhu  r7, 0(r4)
 d025a14:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 d025a18:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d025a1c:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d025a20:	418d883a 	add	r6,r8,r6

0d025a24 <fold>:
      
fold:
      srli  r7, r2, 16
 d025a24:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 d025a28:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 d025a2c:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 d025a30:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 d025a34:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 d025a38:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 d025a3c:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 d025a40:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 d025a44:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 d025a48:	3885883a 	add	r2,r7,r2

0d025a4c <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 d025a4c:	f800283a 	ret

0d025a50 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 d025a50:	defffe04 	addi	sp,sp,-8
 d025a54:	dfc00115 	stw	ra,4(sp)
 d025a58:	df000015 	stw	fp,0(sp)
 d025a5c:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 d025a60:	01034174 	movhi	r4,3333
 d025a64:	213d8e04 	addi	r4,r4,-2504
 d025a68:	d002bc80 	call	d002bc8 <puts>
}
 d025a6c:	e037883a 	mov	sp,fp
 d025a70:	dfc00117 	ldw	ra,4(sp)
 d025a74:	df000017 	ldw	fp,0(sp)
 d025a78:	dec00204 	addi	sp,sp,8
 d025a7c:	f800283a 	ret

0d025a80 <kbhit>:

int
kbhit()
{
 d025a80:	defffc04 	addi	sp,sp,-16
 d025a84:	dfc00315 	stw	ra,12(sp)
 d025a88:	df000215 	stw	fp,8(sp)
 d025a8c:	df000204 	addi	fp,sp,8
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 d025a90:	d0a91b17 	ldw	r2,-23444(gp)
 d025a94:	1004c03a 	cmpne	r2,r2,zero
 d025a98:	10000c1e 	bne	r2,zero,d025acc <kbhit+0x4c>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 d025a9c:	0009883a 	mov	r4,zero
 d025aa0:	01400104 	movi	r5,4
 d025aa4:	01900004 	movi	r6,16384
 d025aa8:	d03d05c0 	call	d03d05c <fcntl>
 d025aac:	1005003a 	cmpeq	r2,r2,zero
 d025ab0:	1000041e 	bne	r2,zero,d025ac4 <kbhit+0x44>
      {
         printf("F_SETFL failed.\n");
 d025ab4:	01034174 	movhi	r4,3333
 d025ab8:	213d9504 	addi	r4,r4,-2476
 d025abc:	d002bc80 	call	d002bc8 <puts>
         dtrap();
 d025ac0:	d025a500 	call	d025a50 <dtrap>
      }
      kbd_init = 1; 
 d025ac4:	00800044 	movi	r2,1
 d025ac8:	d0a91b15 	stw	r2,-23444(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 d025acc:	d0a03917 	ldw	r2,-32540(gp)
 d025ad0:	10bfffd8 	cmpnei	r2,r2,-1
 d025ad4:	10000d1e 	bne	r2,zero,d025b0c <kbhit+0x8c>
   {
      kb = getchar();
 d025ad8:	00834174 	movhi	r2,3333
 d025adc:	10922004 	addi	r2,r2,18560
 d025ae0:	10800017 	ldw	r2,0(r2)
 d025ae4:	11000117 	ldw	r4,4(r2)
 d025ae8:	d0024e00 	call	d0024e0 <getc>
 d025aec:	e0bffe15 	stw	r2,-8(fp)
      if (kb < 0)       /* any error means no character present */
 d025af0:	e0bffe17 	ldw	r2,-8(fp)
 d025af4:	1004403a 	cmpge	r2,r2,zero
 d025af8:	1000021e 	bne	r2,zero,d025b04 <kbhit+0x84>
         return (FALSE);
 d025afc:	e03fff15 	stw	zero,-4(fp)
 d025b00:	00000406 	br	d025b14 <kbhit+0x94>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 d025b04:	e0bffe17 	ldw	r2,-8(fp)
 d025b08:	d0a03915 	stw	r2,-32540(gp)
   }

   return (TRUE);
 d025b0c:	00800044 	movi	r2,1
 d025b10:	e0bfff15 	stw	r2,-4(fp)
 d025b14:	e0bfff17 	ldw	r2,-4(fp)
}
 d025b18:	e037883a 	mov	sp,fp
 d025b1c:	dfc00117 	ldw	ra,4(sp)
 d025b20:	df000017 	ldw	fp,0(sp)
 d025b24:	dec00204 	addi	sp,sp,8
 d025b28:	f800283a 	ret

0d025b2c <getch>:

int 
getch()
{
 d025b2c:	defffd04 	addi	sp,sp,-12
 d025b30:	dfc00215 	stw	ra,8(sp)
 d025b34:	df000115 	stw	fp,4(sp)
 d025b38:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 d025b3c:	d0a03917 	ldw	r2,-32540(gp)
 d025b40:	10bfffe0 	cmpeqi	r2,r2,-1
 d025b44:	1000051e 	bne	r2,zero,d025b5c <getch+0x30>
   {
      chr = kb_last;
 d025b48:	d0a03917 	ldw	r2,-32540(gp)
 d025b4c:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 d025b50:	00bfffc4 	movi	r2,-1
 d025b54:	d0a03915 	stw	r2,-32540(gp)
 d025b58:	00000606 	br	d025b74 <getch+0x48>
   }
   else
      chr = getchar();
 d025b5c:	00834174 	movhi	r2,3333
 d025b60:	10922004 	addi	r2,r2,18560
 d025b64:	10800017 	ldw	r2,0(r2)
 d025b68:	11000117 	ldw	r4,4(r2)
 d025b6c:	d0024e00 	call	d0024e0 <getc>
 d025b70:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 d025b74:	e0bfff17 	ldw	r2,-4(fp)
}
 d025b78:	e037883a 	mov	sp,fp
 d025b7c:	dfc00117 	ldw	ra,4(sp)
 d025b80:	df000017 	ldw	fp,0(sp)
 d025b84:	dec00204 	addi	sp,sp,8
 d025b88:	f800283a 	ret

0d025b8c <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 d025b8c:	deffff04 	addi	sp,sp,-4
 d025b90:	df000015 	stw	fp,0(sp)
 d025b94:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 d025b98:	00801904 	movi	r2,100
 d025b9c:	d0a92015 	stw	r2,-23424(gp)
   cticks_factor = 0;
 d025ba0:	d0291f15 	stw	zero,-23428(gp)
   cticks = 0;
 d025ba4:	00834174 	movhi	r2,3333
 d025ba8:	109b4504 	addi	r2,r2,27924
 d025bac:	10000015 	stw	zero,0(r2)
   cticks_initialized = 1;
 d025bb0:	00800044 	movi	r2,1
 d025bb4:	d0a91c15 	stw	r2,-23440(gp)
}
 d025bb8:	e037883a 	mov	sp,fp
 d025bbc:	df000017 	ldw	fp,0(sp)
 d025bc0:	dec00104 	addi	sp,sp,4
 d025bc4:	f800283a 	ret

0d025bc8 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 d025bc8:	deffff04 	addi	sp,sp,-4
 d025bcc:	df000015 	stw	fp,0(sp)
 d025bd0:	d839883a 	mov	fp,sp
   /* null */ ;
}
 d025bd4:	e037883a 	mov	sp,fp
 d025bd8:	df000017 	ldw	fp,0(sp)
 d025bdc:	dec00104 	addi	sp,sp,4
 d025be0:	f800283a 	ret

0d025be4 <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 d025be4:	deffff04 	addi	sp,sp,-4
 d025be8:	df000015 	stw	fp,0(sp)
 d025bec:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 d025bf0:	d0a91c17 	ldw	r2,-23440(gp)
 d025bf4:	1005003a 	cmpeq	r2,r2,zero
 d025bf8:	1000111e 	bne	r2,zero,d025c40 <cticks_hook+0x5c>
   {
      cticks_factor += TPS;
 d025bfc:	d0a91f17 	ldw	r2,-23428(gp)
 d025c00:	10801904 	addi	r2,r2,100
 d025c04:	d0a91f15 	stw	r2,-23428(gp)
      if (cticks_factor >= OS_TPS)
 d025c08:	d0e91f17 	ldw	r3,-23428(gp)
 d025c0c:	d0a92017 	ldw	r2,-23424(gp)
 d025c10:	18800b16 	blt	r3,r2,d025c40 <cticks_hook+0x5c>
      {
         cticks++;
 d025c14:	00834174 	movhi	r2,3333
 d025c18:	109b4504 	addi	r2,r2,27924
 d025c1c:	10800017 	ldw	r2,0(r2)
 d025c20:	10c00044 	addi	r3,r2,1
 d025c24:	00834174 	movhi	r2,3333
 d025c28:	109b4504 	addi	r2,r2,27924
 d025c2c:	10c00015 	stw	r3,0(r2)
         cticks_factor -= OS_TPS;
 d025c30:	d0e91f17 	ldw	r3,-23428(gp)
 d025c34:	d0a92017 	ldw	r2,-23424(gp)
 d025c38:	1885c83a 	sub	r2,r3,r2
 d025c3c:	d0a91f15 	stw	r2,-23428(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 d025c40:	e037883a 	mov	sp,fp
 d025c44:	df000017 	ldw	fp,0(sp)
 d025c48:	dec00104 	addi	sp,sp,4
 d025c4c:	f800283a 	ret

0d025c50 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 d025c50:	defffd04 	addi	sp,sp,-12
 d025c54:	df000215 	stw	fp,8(sp)
 d025c58:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d025c5c:	0005303a 	rdctl	r2,status
 d025c60:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d025c64:	e0fffe17 	ldw	r3,-8(fp)
 d025c68:	00bfff84 	movi	r2,-2
 d025c6c:	1884703a 	and	r2,r3,r2
 d025c70:	1001703a 	wrctl	status,r2
  
  return context;
 d025c74:	e0bffe17 	ldw	r2,-8(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 d025c78:	e0bfff15 	stw	r2,-4(fp)
	
   if (++irq_level == 1)
 d025c7c:	d0a91d17 	ldw	r2,-23436(gp)
 d025c80:	10800044 	addi	r2,r2,1
 d025c84:	d0a91d15 	stw	r2,-23436(gp)
 d025c88:	d0a91d17 	ldw	r2,-23436(gp)
 d025c8c:	10800058 	cmpnei	r2,r2,1
 d025c90:	1000021e 	bne	r2,zero,d025c9c <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 d025c94:	e0bfff17 	ldw	r2,-4(fp)
 d025c98:	d0a91e15 	stw	r2,-23432(gp)
   }
}
 d025c9c:	e037883a 	mov	sp,fp
 d025ca0:	df000017 	ldw	fp,0(sp)
 d025ca4:	dec00104 	addi	sp,sp,4
 d025ca8:	f800283a 	ret

0d025cac <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 d025cac:	defffe04 	addi	sp,sp,-8
 d025cb0:	df000115 	stw	fp,4(sp)
 d025cb4:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 d025cb8:	d0a91d17 	ldw	r2,-23436(gp)
 d025cbc:	10bfffc4 	addi	r2,r2,-1
 d025cc0:	d0a91d15 	stw	r2,-23436(gp)
 d025cc4:	d0a91d17 	ldw	r2,-23436(gp)
 d025cc8:	1004c03a 	cmpne	r2,r2,zero
 d025ccc:	1000041e 	bne	r2,zero,d025ce0 <irq_Unmask+0x34>
   {
      alt_irq_enable_all(cpu_statusreg);
 d025cd0:	d0a91e17 	ldw	r2,-23432(gp)
 d025cd4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d025cd8:	e0bfff17 	ldw	r2,-4(fp)
 d025cdc:	1001703a 	wrctl	status,r2
   }
}
 d025ce0:	e037883a 	mov	sp,fp
 d025ce4:	df000017 	ldw	fp,0(sp)
 d025ce8:	dec00104 	addi	sp,sp,4
 d025cec:	f800283a 	ret

0d025cf0 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 d025cf0:	defffb04 	addi	sp,sp,-20
 d025cf4:	dfc00415 	stw	ra,16(sp)
 d025cf8:	df000315 	stw	fp,12(sp)
 d025cfc:	df000304 	addi	fp,sp,12
 d025d00:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 d025d04:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 d025d08:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 d025d0c:	e0bfff17 	ldw	r2,-4(fp)
 d025d10:	1004803a 	cmplt	r2,r2,zero
 d025d14:	1000201e 	bne	r2,zero,d025d98 <LOCK_NET_RESOURCE+0xa8>
 d025d18:	e0bfff17 	ldw	r2,-4(fp)
 d025d1c:	10800408 	cmpgei	r2,r2,16
 d025d20:	10001d1e 	bne	r2,zero,d025d98 <LOCK_NET_RESOURCE+0xa8>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 d025d24:	e0bfff17 	ldw	r2,-4(fp)
 d025d28:	00c341b4 	movhi	r3,3334
 d025d2c:	18c44104 	addi	r3,r3,4356
 d025d30:	1085883a 	add	r2,r2,r2
 d025d34:	1085883a 	add	r2,r2,r2
 d025d38:	10c5883a 	add	r2,r2,r3
 d025d3c:	11000017 	ldw	r4,0(r2)
 d025d40:	e1bffe04 	addi	r6,fp,-8
 d025d44:	000b883a 	mov	r5,zero
 d025d48:	d0135480 	call	d013548 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 d025d4c:	e0bffe03 	ldbu	r2,-8(fp)
 d025d50:	10803fcc 	andi	r2,r2,255
 d025d54:	10800298 	cmpnei	r2,r2,10
 d025d58:	10000a1e 	bne	r2,zero,d025d84 <LOCK_NET_RESOURCE+0x94>
 d025d5c:	e0bffd17 	ldw	r2,-12(fp)
 d025d60:	10800044 	addi	r2,r2,1
 d025d64:	e0bffd15 	stw	r2,-12(fp)
 d025d68:	e0bffd17 	ldw	r2,-12(fp)
 d025d6c:	1080fa50 	cmplti	r2,r2,1001
 d025d70:	1000041e 	bne	r2,zero,d025d84 <LOCK_NET_RESOURCE+0x94>
         {
            panic("lock NET");   /* fatal */
 d025d74:	01034174 	movhi	r4,3333
 d025d78:	213d9904 	addi	r4,r4,-2460
 d025d7c:	d02093c0 	call	d02093c <panic>
            return;
 d025d80:	00000606 	br	d025d9c <LOCK_NET_RESOURCE+0xac>
         }
      } while (error == 10);
 d025d84:	e0bffe03 	ldbu	r2,-8(fp)
 d025d88:	10803fcc 	andi	r2,r2,255
 d025d8c:	108002a0 	cmpeqi	r2,r2,10
 d025d90:	103fe41e 	bne	r2,zero,d025d24 <LOCK_NET_RESOURCE+0x34>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 d025d94:	00000106 	br	d025d9c <LOCK_NET_RESOURCE+0xac>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 d025d98:	d025a500 	call	d025a50 <dtrap>
}
 d025d9c:	e037883a 	mov	sp,fp
 d025da0:	dfc00117 	ldw	ra,4(sp)
 d025da4:	df000017 	ldw	fp,0(sp)
 d025da8:	dec00204 	addi	sp,sp,8
 d025dac:	f800283a 	ret

0d025db0 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 d025db0:	defffc04 	addi	sp,sp,-16
 d025db4:	dfc00315 	stw	ra,12(sp)
 d025db8:	df000215 	stw	fp,8(sp)
 d025dbc:	df000204 	addi	fp,sp,8
 d025dc0:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 d025dc4:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 d025dc8:	e0bfff17 	ldw	r2,-4(fp)
 d025dcc:	1004803a 	cmplt	r2,r2,zero
 d025dd0:	1000131e 	bne	r2,zero,d025e20 <UNLOCK_NET_RESOURCE+0x70>
 d025dd4:	e0bfff17 	ldw	r2,-4(fp)
 d025dd8:	10800408 	cmpgei	r2,r2,16
 d025ddc:	1000101e 	bne	r2,zero,d025e20 <UNLOCK_NET_RESOURCE+0x70>
   {
      error = OSSemPost(resid_semaphore[resid]);
 d025de0:	e0bfff17 	ldw	r2,-4(fp)
 d025de4:	00c341b4 	movhi	r3,3334
 d025de8:	18c44104 	addi	r3,r3,4356
 d025dec:	1085883a 	add	r2,r2,r2
 d025df0:	1085883a 	add	r2,r2,r2
 d025df4:	10c5883a 	add	r2,r2,r3
 d025df8:	11000017 	ldw	r4,0(r2)
 d025dfc:	d0139400 	call	d013940 <OSSemPost>
 d025e00:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 d025e04:	e0bffe03 	ldbu	r2,-8(fp)
 d025e08:	1005003a 	cmpeq	r2,r2,zero
 d025e0c:	1000051e 	bne	r2,zero,d025e24 <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
 d025e10:	01034174 	movhi	r4,3333
 d025e14:	213d9c04 	addi	r4,r4,-2448
 d025e18:	d02093c0 	call	d02093c <panic>
void
UNLOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 d025e1c:	00000106 	br	d025e24 <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 d025e20:	d025a500 	call	d025a50 <dtrap>
}
 d025e24:	e037883a 	mov	sp,fp
 d025e28:	dfc00117 	ldw	ra,4(sp)
 d025e2c:	df000017 	ldw	fp,0(sp)
 d025e30:	dec00204 	addi	sp,sp,8
 d025e34:	f800283a 	ret

0d025e38 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 d025e38:	deffed04 	addi	sp,sp,-76
 d025e3c:	dfc01215 	stw	ra,72(sp)
 d025e40:	df001115 	stw	fp,68(sp)
 d025e44:	df001104 	addi	fp,sp,68
 d025e48:	e13ffe15 	stw	r4,-8(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 d025e4c:	e0bffe17 	ldw	r2,-8(fp)
 d025e50:	10800417 	ldw	r2,16(r2)
 d025e54:	1009883a 	mov	r4,r2
 d025e58:	d0264b80 	call	d0264b8 <npalloc>
 d025e5c:	e0bff415 	stw	r2,-48(fp)
   if(!stack)
 d025e60:	e0bff417 	ldw	r2,-48(fp)
 d025e64:	1004c03a 	cmpne	r2,r2,zero
 d025e68:	1000031e 	bne	r2,zero,d025e78 <TK_NEWTASK+0x40>
      panic("stack alloc");
 d025e6c:	01034174 	movhi	r4,3333
 d025e70:	213d9f04 	addi	r4,r4,-2436
 d025e74:	d02093c0 	call	d02093c <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 d025e78:	e0bffe17 	ldw	r2,-8(fp)
 d025e7c:	11400217 	ldw	r5,8(r2)
 d025e80:	e0bffe17 	ldw	r2,-8(fp)
 d025e84:	10800417 	ldw	r2,16(r2)
 d025e88:	1004d0ba 	srli	r2,r2,2
 d025e8c:	1085883a 	add	r2,r2,r2
 d025e90:	1085883a 	add	r2,r2,r2
 d025e94:	1007883a 	mov	r3,r2
 d025e98:	e0bff417 	ldw	r2,-48(fp)
 d025e9c:	1885883a 	add	r2,r3,r2
 d025ea0:	11bfff04 	addi	r6,r2,-4
 d025ea4:	e0bffe17 	ldw	r2,-8(fp)
 d025ea8:	10800317 	ldw	r2,12(r2)
 d025eac:	11c03fcc 	andi	r7,r2,255
 d025eb0:	e0bffe17 	ldw	r2,-8(fp)
 d025eb4:	10800317 	ldw	r2,12(r2)
 d025eb8:	10ffffcc 	andi	r3,r2,65535
 d025ebc:	e0bffe17 	ldw	r2,-8(fp)
 d025ec0:	10800417 	ldw	r2,16(r2)
 d025ec4:	1008d0ba 	srli	r4,r2,2
 d025ec8:	d8c00015 	stw	r3,0(sp)
 d025ecc:	e0bff417 	ldw	r2,-48(fp)
 d025ed0:	d8800115 	stw	r2,4(sp)
 d025ed4:	d9000215 	stw	r4,8(sp)
 d025ed8:	d8000315 	stw	zero,12(sp)
 d025edc:	008000c4 	movi	r2,3
 d025ee0:	d8800415 	stw	r2,16(sp)
 d025ee4:	2809883a 	mov	r4,r5
 d025ee8:	000b883a 	mov	r5,zero
 d025eec:	d0143e40 	call	d0143e4 <OSTaskCreateExt>
 d025ef0:	e0bff505 	stb	r2,-44(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 d025ef4:	e0bff503 	ldbu	r2,-44(fp)
 d025ef8:	10803fcc 	andi	r2,r2,255
 d025efc:	10800a18 	cmpnei	r2,r2,40
 d025f00:	1000161e 	bne	r2,zero,d025f5c <TK_NEWTASK+0x124>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
 d025f04:	e0bffe17 	ldw	r2,-8(fp)
 d025f08:	10800317 	ldw	r2,12(r2)
 d025f0c:	11003fcc 	andi	r4,r2,255
 d025f10:	e17ff584 	addi	r5,fp,-42
 d025f14:	e1bff544 	addi	r6,fp,-43
 d025f18:	d014b600 	call	d014b60 <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 d025f1c:	e03ffd45 	stb	zero,-11(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 d025f20:	e0bffe17 	ldw	r2,-8(fp)
 d025f24:	11400117 	ldw	r5,4(r2)
 d025f28:	e0bffe17 	ldw	r2,-8(fp)
 d025f2c:	11800317 	ldw	r6,12(r2)
 d025f30:	e0bffe17 	ldw	r2,-8(fp)
 d025f34:	10800317 	ldw	r2,12(r2)
 d025f38:	e1fff584 	addi	r7,fp,-42
 d025f3c:	d8800015 	stw	r2,0(sp)
 d025f40:	01034174 	movhi	r4,3333
 d025f44:	213da204 	addi	r4,r4,-2424
 d025f48:	d0028a00 	call	d0028a0 <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 d025f4c:	01034174 	movhi	r4,3333
 d025f50:	213dba04 	addi	r4,r4,-2328
 d025f54:	d002bc80 	call	d002bc8 <puts>
 d025f58:	00001e06 	br	d025fd4 <TK_NEWTASK+0x19c>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 d025f5c:	e0bff503 	ldbu	r2,-44(fp)
 d025f60:	10803fcc 	andi	r2,r2,255
 d025f64:	10800a98 	cmpnei	r2,r2,42
 d025f68:	10000c1e 	bne	r2,zero,d025f9c <TK_NEWTASK+0x164>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 d025f6c:	e0bffe17 	ldw	r2,-8(fp)
 d025f70:	11400117 	ldw	r5,4(r2)
 d025f74:	e0bffe17 	ldw	r2,-8(fp)
 d025f78:	11800317 	ldw	r6,12(r2)
 d025f7c:	01034174 	movhi	r4,3333
 d025f80:	213de204 	addi	r4,r4,-2168
 d025f84:	01c00504 	movi	r7,20
 d025f88:	d0028a00 	call	d0028a0 <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 d025f8c:	01034174 	movhi	r4,3333
 d025f90:	213dff04 	addi	r4,r4,-2052
 d025f94:	d002bc80 	call	d002bc8 <puts>
 d025f98:	00000e06 	br	d025fd4 <TK_NEWTASK+0x19c>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 d025f9c:	e0bff503 	ldbu	r2,-44(fp)
 d025fa0:	10803fcc 	andi	r2,r2,255
 d025fa4:	1005003a 	cmpeq	r2,r2,zero
 d025fa8:	10000a1e 	bne	r2,zero,d025fd4 <TK_NEWTASK+0x19c>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 d025fac:	e0bff503 	ldbu	r2,-44(fp)
 d025fb0:	11403fcc 	andi	r5,r2,255
 d025fb4:	e0bffe17 	ldw	r2,-8(fp)
 d025fb8:	11800117 	ldw	r6,4(r2)
 d025fbc:	01034174 	movhi	r4,3333
 d025fc0:	213e1e04 	addi	r4,r4,-1928
 d025fc4:	d0028a00 	call	d0028a0 <printf>
             error, nettask->name);
      return (-1);
 d025fc8:	00bfffc4 	movi	r2,-1
 d025fcc:	e0bfff15 	stw	r2,-4(fp)
 d025fd0:	00001806 	br	d026034 <TK_NEWTASK+0x1fc>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);
 d025fd4:	e0bffe17 	ldw	r2,-8(fp)
 d025fd8:	10800317 	ldw	r2,12(r2)
 d025fdc:	11003fcc 	andi	r4,r2,255
 d025fe0:	e0bffe17 	ldw	r2,-8(fp)
 d025fe4:	10800117 	ldw	r2,4(r2)
 d025fe8:	100b883a 	mov	r5,r2
 d025fec:	e1bff504 	addi	r6,fp,-44
 d025ff0:	d014d180 	call	d014d18 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 d025ff4:	e0fff417 	ldw	r3,-48(fp)
 d025ff8:	e0bffe17 	ldw	r2,-8(fp)
 d025ffc:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 d026000:	e0bffe17 	ldw	r2,-8(fp)
 d026004:	10c00017 	ldw	r3,0(r2)
 d026008:	e0bffe17 	ldw	r2,-8(fp)
 d02600c:	10800317 	ldw	r2,12(r2)
 d026010:	18800005 	stb	r2,0(r3)

   printf("Created \"%s\" task (Prio: %d)\n",
 d026014:	e0bffe17 	ldw	r2,-8(fp)
 d026018:	11400117 	ldw	r5,4(r2)
 d02601c:	e0bffe17 	ldw	r2,-8(fp)
 d026020:	11800317 	ldw	r6,12(r2)
 d026024:	01034174 	movhi	r4,3333
 d026028:	213e2c04 	addi	r4,r4,-1872
 d02602c:	d0028a00 	call	d0028a0 <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 d026030:	e03fff15 	stw	zero,-4(fp)
 d026034:	e0bfff17 	ldw	r2,-4(fp)
}
 d026038:	e037883a 	mov	sp,fp
 d02603c:	dfc00117 	ldw	ra,4(sp)
 d026040:	df000017 	ldw	fp,0(sp)
 d026044:	dec00204 	addi	sp,sp,8
 d026048:	f800283a 	ret

0d02604c <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 d02604c:	defffb04 	addi	sp,sp,-20
 d026050:	dfc00415 	stw	ra,16(sp)
 d026054:	df000315 	stw	fp,12(sp)
 d026058:	df000304 	addi	fp,sp,12
 d02605c:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 d026060:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 d026064:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 d026068:	e0bfff17 	ldw	r2,-4(fp)
 d02606c:	108001a8 	cmpgeui	r2,r2,6
 d026070:	10001d1e 	bne	r2,zero,d0260e8 <wait_app_sem+0x9c>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 d026074:	e0bfff17 	ldw	r2,-4(fp)
 d026078:	00c341b4 	movhi	r3,3334
 d02607c:	18c45104 	addi	r3,r3,4420
 d026080:	1085883a 	add	r2,r2,r2
 d026084:	1085883a 	add	r2,r2,r2
 d026088:	10c5883a 	add	r2,r2,r3
 d02608c:	11000017 	ldw	r4,0(r2)
 d026090:	e1bffe04 	addi	r6,fp,-8
 d026094:	000b883a 	mov	r5,zero
 d026098:	d0135480 	call	d013548 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 d02609c:	e0bffe03 	ldbu	r2,-8(fp)
 d0260a0:	10803fcc 	andi	r2,r2,255
 d0260a4:	10800298 	cmpnei	r2,r2,10
 d0260a8:	10000a1e 	bne	r2,zero,d0260d4 <wait_app_sem+0x88>
 d0260ac:	e0bffd17 	ldw	r2,-12(fp)
 d0260b0:	10800044 	addi	r2,r2,1
 d0260b4:	e0bffd15 	stw	r2,-12(fp)
 d0260b8:	e0bffd17 	ldw	r2,-12(fp)
 d0260bc:	1080fa50 	cmplti	r2,r2,1001
 d0260c0:	1000041e 	bne	r2,zero,d0260d4 <wait_app_sem+0x88>
         {
            panic("lock NET");   /* fatal */
 d0260c4:	01034174 	movhi	r4,3333
 d0260c8:	213d9904 	addi	r4,r4,-2460
 d0260cc:	d02093c0 	call	d02093c <panic>
            return;
 d0260d0:	00000606 	br	d0260ec <wait_app_sem+0xa0>
         }
      } while (error == 10);
 d0260d4:	e0bffe03 	ldbu	r2,-8(fp)
 d0260d8:	10803fcc 	andi	r2,r2,255
 d0260dc:	108002a0 	cmpeqi	r2,r2,10
 d0260e0:	103fe41e 	bne	r2,zero,d026074 <wait_app_sem+0x28>
 d0260e4:	00000106 	br	d0260ec <wait_app_sem+0xa0>
   }
   else
      dtrap();
 d0260e8:	d025a500 	call	d025a50 <dtrap>
}
 d0260ec:	e037883a 	mov	sp,fp
 d0260f0:	dfc00117 	ldw	ra,4(sp)
 d0260f4:	df000017 	ldw	fp,0(sp)
 d0260f8:	dec00204 	addi	sp,sp,8
 d0260fc:	f800283a 	ret

0d026100 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 d026100:	defffc04 	addi	sp,sp,-16
 d026104:	dfc00315 	stw	ra,12(sp)
 d026108:	df000215 	stw	fp,8(sp)
 d02610c:	df000204 	addi	fp,sp,8
 d026110:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 d026114:	e0bfff17 	ldw	r2,-4(fp)
 d026118:	108001a8 	cmpgeui	r2,r2,6
 d02611c:	1000101e 	bne	r2,zero,d026160 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 d026120:	e0bfff17 	ldw	r2,-4(fp)
 d026124:	00c341b4 	movhi	r3,3334
 d026128:	18c45104 	addi	r3,r3,4420
 d02612c:	1085883a 	add	r2,r2,r2
 d026130:	1085883a 	add	r2,r2,r2
 d026134:	10c5883a 	add	r2,r2,r3
 d026138:	11000017 	ldw	r4,0(r2)
 d02613c:	d0139400 	call	d013940 <OSSemPost>
 d026140:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 d026144:	e0bffe03 	ldbu	r2,-8(fp)
 d026148:	1005003a 	cmpeq	r2,r2,zero
 d02614c:	1000051e 	bne	r2,zero,d026164 <post_app_sem+0x64>
      {
         panic("unlock NET");
 d026150:	01034174 	movhi	r4,3333
 d026154:	213d9c04 	addi	r4,r4,-2448
 d026158:	d02093c0 	call	d02093c <panic>
 d02615c:	00000106 	br	d026164 <post_app_sem+0x64>
      }
   }
   else
      dtrap();
 d026160:	d025a500 	call	d025a50 <dtrap>
}
 d026164:	e037883a 	mov	sp,fp
 d026168:	dfc00117 	ldw	ra,4(sp)
 d02616c:	df000017 	ldw	fp,0(sp)
 d026170:	dec00204 	addi	sp,sp,8
 d026174:	f800283a 	ret

0d026178 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 d026178:	defffa04 	addi	sp,sp,-24
 d02617c:	dfc00515 	stw	ra,20(sp)
 d026180:	df000415 	stw	fp,16(sp)
 d026184:	dc800315 	stw	r18,12(sp)
 d026188:	dc400215 	stw	r17,8(sp)
 d02618c:	dc000115 	stw	r16,4(sp)
 d026190:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 d026194:	01000044 	movi	r4,1
 d026198:	d0131940 	call	d013194 <OSSemCreate>
 d02619c:	d0a92815 	stw	r2,-23392(gp)
   if (!mheap_sem_ptr)
 d0261a0:	d0a92817 	ldw	r2,-23392(gp)
 d0261a4:	1004c03a 	cmpne	r2,r2,zero
 d0261a8:	1000031e 	bne	r2,zero,d0261b8 <alt_iniche_init+0x40>
      panic("mheap_sem_ptr create err"); 
 d0261ac:	01034174 	movhi	r4,3333
 d0261b0:	213e3404 	addi	r4,r4,-1840
 d0261b4:	d02093c0 	call	d02093c <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 d0261b8:	0009883a 	mov	r4,zero
 d0261bc:	d0131940 	call	d013194 <OSSemCreate>
 d0261c0:	d0a92915 	stw	r2,-23388(gp)
   if (!rcvdq_sem_ptr)
 d0261c4:	d0a92917 	ldw	r2,-23388(gp)
 d0261c8:	1004c03a 	cmpne	r2,r2,zero
 d0261cc:	1000031e 	bne	r2,zero,d0261dc <alt_iniche_init+0x64>
      panic("rcvdq_sem_ptr create err"); 
 d0261d0:	01034174 	movhi	r4,3333
 d0261d4:	213e3b04 	addi	r4,r4,-1812
 d0261d8:	d02093c0 	call	d02093c <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 d0261dc:	e03fff15 	stw	zero,-4(fp)
 d0261e0:	00001906 	br	d026248 <alt_iniche_init+0xd0>
   {
      resid_semaphore[i] = OSSemCreate(1);
 d0261e4:	e43fff17 	ldw	r16,-4(fp)
 d0261e8:	01000044 	movi	r4,1
 d0261ec:	d0131940 	call	d013194 <OSSemCreate>
 d0261f0:	1009883a 	mov	r4,r2
 d0261f4:	00c341b4 	movhi	r3,3334
 d0261f8:	18c44104 	addi	r3,r3,4356
 d0261fc:	8405883a 	add	r2,r16,r16
 d026200:	1085883a 	add	r2,r2,r2
 d026204:	10c5883a 	add	r2,r2,r3
 d026208:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 d02620c:	e0bfff17 	ldw	r2,-4(fp)
 d026210:	00c341b4 	movhi	r3,3334
 d026214:	18c44104 	addi	r3,r3,4356
 d026218:	1085883a 	add	r2,r2,r2
 d02621c:	1085883a 	add	r2,r2,r2
 d026220:	10c5883a 	add	r2,r2,r3
 d026224:	10800017 	ldw	r2,0(r2)
 d026228:	1004c03a 	cmpne	r2,r2,zero
 d02622c:	1000031e 	bne	r2,zero,d02623c <alt_iniche_init+0xc4>
         panic("resid_semaphore create err");  
 d026230:	01034174 	movhi	r4,3333
 d026234:	213e4204 	addi	r4,r4,-1784
 d026238:	d02093c0 	call	d02093c <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 d02623c:	e0bfff17 	ldw	r2,-4(fp)
 d026240:	10800044 	addi	r2,r2,1
 d026244:	e0bfff15 	stw	r2,-4(fp)
 d026248:	e0bfff17 	ldw	r2,-4(fp)
 d02624c:	10800410 	cmplti	r2,r2,16
 d026250:	103fe41e 	bne	r2,zero,d0261e4 <alt_iniche_init+0x6c>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 d026254:	e03fff15 	stw	zero,-4(fp)
 d026258:	00001906 	br	d0262c0 <alt_iniche_init+0x148>
   {
      app_semaphore[i] = OSSemCreate(1);
 d02625c:	e43fff17 	ldw	r16,-4(fp)
 d026260:	01000044 	movi	r4,1
 d026264:	d0131940 	call	d013194 <OSSemCreate>
 d026268:	1009883a 	mov	r4,r2
 d02626c:	00c341b4 	movhi	r3,3334
 d026270:	18c45104 	addi	r3,r3,4420
 d026274:	8405883a 	add	r2,r16,r16
 d026278:	1085883a 	add	r2,r2,r2
 d02627c:	10c5883a 	add	r2,r2,r3
 d026280:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 d026284:	e0bfff17 	ldw	r2,-4(fp)
 d026288:	00c341b4 	movhi	r3,3334
 d02628c:	18c45104 	addi	r3,r3,4420
 d026290:	1085883a 	add	r2,r2,r2
 d026294:	1085883a 	add	r2,r2,r2
 d026298:	10c5883a 	add	r2,r2,r3
 d02629c:	10800017 	ldw	r2,0(r2)
 d0262a0:	1004c03a 	cmpne	r2,r2,zero
 d0262a4:	1000031e 	bne	r2,zero,d0262b4 <alt_iniche_init+0x13c>
         panic("app_semaphore create err");  
 d0262a8:	01034174 	movhi	r4,3333
 d0262ac:	213e4904 	addi	r4,r4,-1756
 d0262b0:	d02093c0 	call	d02093c <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 d0262b4:	e0bfff17 	ldw	r2,-4(fp)
 d0262b8:	10800044 	addi	r2,r2,1
 d0262bc:	e0bfff15 	stw	r2,-4(fp)
 d0262c0:	e0bfff17 	ldw	r2,-4(fp)
 d0262c4:	10800190 	cmplti	r2,r2,6
 d0262c8:	103fe41e 	bne	r2,zero,d02625c <alt_iniche_init+0xe4>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 d0262cc:	e03fff15 	stw	zero,-4(fp)
 d0262d0:	00002b06 	br	d026380 <alt_iniche_init+0x208>
   {
      global_TCPwakeup_set[i].ctick = 0;
 d0262d4:	e13fff17 	ldw	r4,-4(fp)
 d0262d8:	040341b4 	movhi	r16,3334
 d0262dc:	84040504 	addi	r16,r16,4116
 d0262e0:	01400304 	movi	r5,12
 d0262e4:	d00235c0 	call	d00235c <__mulsi3>
 d0262e8:	1405883a 	add	r2,r2,r16
 d0262ec:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 d0262f0:	e13fff17 	ldw	r4,-4(fp)
 d0262f4:	040341b4 	movhi	r16,3334
 d0262f8:	84040504 	addi	r16,r16,4116
 d0262fc:	01400304 	movi	r5,12
 d026300:	d00235c0 	call	d00235c <__mulsi3>
 d026304:	1405883a 	add	r2,r2,r16
 d026308:	10800104 	addi	r2,r2,4
 d02630c:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 d026310:	e43fff17 	ldw	r16,-4(fp)
 d026314:	0009883a 	mov	r4,zero
 d026318:	d0131940 	call	d013194 <OSSemCreate>
 d02631c:	1025883a 	mov	r18,r2
 d026320:	044341b4 	movhi	r17,3334
 d026324:	8c440504 	addi	r17,r17,4116
 d026328:	8009883a 	mov	r4,r16
 d02632c:	01400304 	movi	r5,12
 d026330:	d00235c0 	call	d00235c <__mulsi3>
 d026334:	1445883a 	add	r2,r2,r17
 d026338:	10800204 	addi	r2,r2,8
 d02633c:	14800015 	stw	r18,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 d026340:	e13fff17 	ldw	r4,-4(fp)
 d026344:	040341b4 	movhi	r16,3334
 d026348:	84040504 	addi	r16,r16,4116
 d02634c:	01400304 	movi	r5,12
 d026350:	d00235c0 	call	d00235c <__mulsi3>
 d026354:	1405883a 	add	r2,r2,r16
 d026358:	10800204 	addi	r2,r2,8
 d02635c:	10800017 	ldw	r2,0(r2)
 d026360:	1004c03a 	cmpne	r2,r2,zero
 d026364:	1000031e 	bne	r2,zero,d026374 <alt_iniche_init+0x1fc>
         panic("globwake_semaphore create err");  
 d026368:	01034174 	movhi	r4,3333
 d02636c:	213e5004 	addi	r4,r4,-1728
 d026370:	d02093c0 	call	d02093c <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 d026374:	e0bfff17 	ldw	r2,-4(fp)
 d026378:	10800044 	addi	r2,r2,1
 d02637c:	e0bfff15 	stw	r2,-4(fp)
 d026380:	e0bfff17 	ldw	r2,-4(fp)
 d026384:	10800510 	cmplti	r2,r2,20
 d026388:	103fd21e 	bne	r2,zero,d0262d4 <alt_iniche_init+0x15c>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 d02638c:	00834174 	movhi	r2,3333
 d026390:	109b4404 	addi	r2,r2,27920
 d026394:	10000015 	stw	zero,0(r2)
#endif  /* TCPWAKE_RTOS */
}
 d026398:	e037883a 	mov	sp,fp
 d02639c:	dfc00417 	ldw	ra,16(sp)
 d0263a0:	df000317 	ldw	fp,12(sp)
 d0263a4:	dc800217 	ldw	r18,8(sp)
 d0263a8:	dc400117 	ldw	r17,4(sp)
 d0263ac:	dc000017 	ldw	r16,0(sp)
 d0263b0:	dec00504 	addi	sp,sp,20
 d0263b4:	f800283a 	ret

0d0263b8 <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 d0263b8:	deffff04 	addi	sp,sp,-4
 d0263bc:	df000015 	stw	fp,0(sp)
 d0263c0:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 d0263c4:	00c34174 	movhi	r3,3333
 d0263c8:	18d25604 	addi	r3,r3,18776
 d0263cc:	00800784 	movi	r2,30
 d0263d0:	18800015 	stw	r2,0(r3)
   lilbufs = MAXLILPKTS;
 d0263d4:	00c34174 	movhi	r3,3333
 d0263d8:	18d25404 	addi	r3,r3,18768
 d0263dc:	00800784 	movi	r2,30
 d0263e0:	18800015 	stw	r2,0(r3)
   bigbufsiz = BIGBUFSIZE;
 d0263e4:	00c34174 	movhi	r3,3333
 d0263e8:	18d25704 	addi	r3,r3,18780
 d0263ec:	00818004 	movi	r2,1536
 d0263f0:	18800015 	stw	r2,0(r3)
   lilbufsiz = LILBUFSIZE;
 d0263f4:	00c34174 	movhi	r3,3333
 d0263f8:	18d25504 	addi	r3,r3,18772
 d0263fc:	00802004 	movi	r2,128
 d026400:	18800015 	stw	r2,0(r3)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 d026404:	00c34174 	movhi	r3,3333
 d026408:	18db6804 	addi	r3,r3,28064
 d02640c:	008340b4 	movhi	r2,3330
 d026410:	10991304 	addi	r2,r2,25676
 d026414:	18800015 	stw	r2,0(r3)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 d026418:	0005883a 	mov	r2,zero
}
 d02641c:	e037883a 	mov	sp,fp
 d026420:	df000017 	ldw	fp,0(sp)
 d026424:	dec00104 	addi	sp,sp,4
 d026428:	f800283a 	ret

0d02642c <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 d02642c:	deffff04 	addi	sp,sp,-4
 d026430:	df000015 	stw	fp,0(sp)
 d026434:	d839883a 	mov	fp,sp
   return NULL;
 d026438:	0005883a 	mov	r2,zero
}
 d02643c:	e037883a 	mov	sp,fp
 d026440:	df000017 	ldw	fp,0(sp)
 d026444:	dec00104 	addi	sp,sp,4
 d026448:	f800283a 	ret

0d02644c <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 d02644c:	defffd04 	addi	sp,sp,-12
 d026450:	dfc00215 	stw	ra,8(sp)
 d026454:	df000115 	stw	fp,4(sp)
 d026458:	df000104 	addi	fp,sp,4
 d02645c:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 d026460:	e13fff17 	ldw	r4,-4(fp)
 d026464:	d01d3580 	call	d01d358 <iniche_devices_init>
 d026468:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 d02646c:	e0bfff17 	ldw	r2,-4(fp)
}
 d026470:	e037883a 	mov	sp,fp
 d026474:	dfc00117 	ldw	ra,4(sp)
 d026478:	df000017 	ldw	fp,0(sp)
 d02647c:	dec00204 	addi	sp,sp,8
 d026480:	f800283a 	ret

0d026484 <calloc2>:
 * There is already a function called calloc1() in memio.c,
 * hence use a different function name.
 */
char * 
calloc2(unsigned size)
{
 d026484:	defffd04 	addi	sp,sp,-12
 d026488:	dfc00215 	stw	ra,8(sp)
 d02648c:	df000115 	stw	fp,4(sp)
 d026490:	df000104 	addi	fp,sp,4
 d026494:	e13fff15 	stw	r4,-4(fp)
   return (calloc(1,size));
 d026498:	01000044 	movi	r4,1
 d02649c:	e17fff17 	ldw	r5,-4(fp)
 d0264a0:	d04bdc80 	call	d04bdc8 <calloc>
}
 d0264a4:	e037883a 	mov	sp,fp
 d0264a8:	dfc00117 	ldw	ra,4(sp)
 d0264ac:	df000017 	ldw	fp,0(sp)
 d0264b0:	dec00204 	addi	sp,sp,8
 d0264b4:	f800283a 	ret

0d0264b8 <npalloc>:


char *
npalloc(unsigned size)
{
 d0264b8:	defff904 	addi	sp,sp,-28
 d0264bc:	dfc00615 	stw	ra,24(sp)
 d0264c0:	df000515 	stw	fp,20(sp)
 d0264c4:	df000504 	addi	fp,sp,20
 d0264c8:	e13ffe15 	stw	r4,-8(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 d0264cc:	d1292817 	ldw	r4,-23392(gp)
 d0264d0:	e1bffd04 	addi	r6,fp,-12
 d0264d4:	000b883a 	mov	r5,zero
 d0264d8:	d0135480 	call	d013548 <OSSemPend>
   if(err)
 d0264dc:	e0bffd03 	ldbu	r2,-12(fp)
 d0264e0:	10803fcc 	andi	r2,r2,255
 d0264e4:	1005003a 	cmpeq	r2,r2,zero
 d0264e8:	1000181e 	bne	r2,zero,d02654c <npalloc+0x94>
   {
      int errct = 0;
 d0264ec:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 d0264f0:	00001206 	br	d02653c <npalloc+0x84>
      {
         if(errct++ > 1000)
 d0264f4:	e0bffb17 	ldw	r2,-20(fp)
 d0264f8:	1080fa48 	cmpgei	r2,r2,1001
 d0264fc:	1007883a 	mov	r3,r2
 d026500:	e0bffb17 	ldw	r2,-20(fp)
 d026504:	10800044 	addi	r2,r2,1
 d026508:	e0bffb15 	stw	r2,-20(fp)
 d02650c:	18803fcc 	andi	r2,r3,255
 d026510:	1005003a 	cmpeq	r2,r2,zero
 d026514:	1000051e 	bne	r2,zero,d02652c <npalloc+0x74>
         {
            panic("npalloc");    /* fatal? */
 d026518:	01034174 	movhi	r4,3333
 d02651c:	213e5804 	addi	r4,r4,-1696
 d026520:	d02093c0 	call	d02093c <panic>
            return NULL;
 d026524:	e03fff15 	stw	zero,-4(fp)
 d026528:	00001a06 	br	d026594 <npalloc+0xdc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 d02652c:	d1292817 	ldw	r4,-23392(gp)
 d026530:	e1bffd04 	addi	r6,fp,-12
 d026534:	000b883a 	mov	r5,zero
 d026538:	d0135480 	call	d013548 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 d02653c:	e0bffd03 	ldbu	r2,-12(fp)
 d026540:	10803fcc 	andi	r2,r2,255
 d026544:	108002a0 	cmpeqi	r2,r2,10
 d026548:	103fea1e 	bne	r2,zero,d0264f4 <npalloc+0x3c>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, calloc2);
#else
   ptr = calloc2(size);
 d02654c:	e13ffe17 	ldw	r4,-8(fp)
 d026550:	d0264840 	call	d026484 <calloc2>
 d026554:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 d026558:	d1292817 	ldw	r4,-23392(gp)
 d02655c:	d0139400 	call	d013940 <OSSemPost>
 d026560:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 d026564:	e0bffc17 	ldw	r2,-16(fp)
 d026568:	1004c03a 	cmpne	r2,r2,zero
 d02656c:	1000021e 	bne	r2,zero,d026578 <npalloc+0xc0>
      return NULL;
 d026570:	e03fff15 	stw	zero,-4(fp)
 d026574:	00000706 	br	d026594 <npalloc+0xdc>

   MEMSET(ptr, 0, size);
 d026578:	e0bffc17 	ldw	r2,-16(fp)
 d02657c:	1009883a 	mov	r4,r2
 d026580:	e1bffe17 	ldw	r6,-8(fp)
 d026584:	000b883a 	mov	r5,zero
 d026588:	d0027880 	call	d002788 <memset>
   return ptr;      
 d02658c:	e0bffc17 	ldw	r2,-16(fp)
 d026590:	e0bfff15 	stw	r2,-4(fp)
 d026594:	e0bfff17 	ldw	r2,-4(fp)
}
 d026598:	e037883a 	mov	sp,fp
 d02659c:	dfc00117 	ldw	ra,4(sp)
 d0265a0:	df000017 	ldw	fp,0(sp)
 d0265a4:	dec00204 	addi	sp,sp,8
 d0265a8:	f800283a 	ret

0d0265ac <npfree>:

void
npfree(void * ptr)
{
 d0265ac:	defffb04 	addi	sp,sp,-20
 d0265b0:	dfc00415 	stw	ra,16(sp)
 d0265b4:	df000315 	stw	fp,12(sp)
 d0265b8:	df000304 	addi	fp,sp,12
 d0265bc:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 d0265c0:	d1292817 	ldw	r4,-23392(gp)
 d0265c4:	e1bffe04 	addi	r6,fp,-8
 d0265c8:	000b883a 	mov	r5,zero
 d0265cc:	d0135480 	call	d013548 <OSSemPend>
   if (err)
 d0265d0:	e0bffe03 	ldbu	r2,-8(fp)
 d0265d4:	10803fcc 	andi	r2,r2,255
 d0265d8:	1005003a 	cmpeq	r2,r2,zero
 d0265dc:	1000171e 	bne	r2,zero,d02663c <npfree+0x90>
   {
      int errct = 0;
 d0265e0:	e03ffd15 	stw	zero,-12(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 d0265e4:	00001106 	br	d02662c <npfree+0x80>
      {
         if (errct++ > 1000)
 d0265e8:	e0bffd17 	ldw	r2,-12(fp)
 d0265ec:	1080fa48 	cmpgei	r2,r2,1001
 d0265f0:	1007883a 	mov	r3,r2
 d0265f4:	e0bffd17 	ldw	r2,-12(fp)
 d0265f8:	10800044 	addi	r2,r2,1
 d0265fc:	e0bffd15 	stw	r2,-12(fp)
 d026600:	18803fcc 	andi	r2,r3,255
 d026604:	1005003a 	cmpeq	r2,r2,zero
 d026608:	1000041e 	bne	r2,zero,d02661c <npfree+0x70>
         {
            panic("npfree");    /* fatal? */
 d02660c:	01034174 	movhi	r4,3333
 d026610:	213e5a04 	addi	r4,r4,-1688
 d026614:	d02093c0 	call	d02093c <panic>
            return;
 d026618:	00000d06 	br	d026650 <npfree+0xa4>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 d02661c:	d1292817 	ldw	r4,-23392(gp)
 d026620:	e1bffe04 	addi	r6,fp,-8
 d026624:	000b883a 	mov	r5,zero
 d026628:	d0135480 	call	d013548 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 d02662c:	e0bffe03 	ldbu	r2,-8(fp)
 d026630:	10803fcc 	andi	r2,r2,255
 d026634:	108002a0 	cmpeqi	r2,r2,10
 d026638:	103feb1e 	bne	r2,zero,d0265e8 <npfree+0x3c>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free);
#else
   free(ptr);
 d02663c:	e13fff17 	ldw	r4,-4(fp)
 d026640:	d04be1c0 	call	d04be1c <free>
#endif

   err = OSSemPost(mheap_sem_ptr);
 d026644:	d1292817 	ldw	r4,-23392(gp)
 d026648:	d0139400 	call	d013940 <OSSemPost>
 d02664c:	e0bffe05 	stb	r2,-8(fp)
 */
   free(ptr);
#endif
#endif

}
 d026650:	e037883a 	mov	sp,fp
 d026654:	dfc00117 	ldw	ra,4(sp)
 d026658:	df000017 	ldw	fp,0(sp)
 d02665c:	dec00204 	addi	sp,sp,8
 d026660:	f800283a 	ret

0d026664 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 d026664:	defffc04 	addi	sp,sp,-16
 d026668:	dfc00315 	stw	ra,12(sp)
 d02666c:	df000215 	stw	fp,8(sp)
 d026670:	df000204 	addi	fp,sp,8
 d026674:	e13fff15 	stw	r4,-4(fp)
   char *ptr = npalloc(size);
 d026678:	e13fff17 	ldw	r4,-4(fp)
 d02667c:	d0264b80 	call	d0264b8 <npalloc>
 d026680:	e0bffe15 	stw	r2,-8(fp)

   if(ptr) {
 d026684:	e0bffe17 	ldw	r2,-8(fp)
 d026688:	1005003a 	cmpeq	r2,r2,zero
 d02668c:	1000041e 	bne	r2,zero,d0266a0 <ncpalloc+0x3c>
      ptr = (char *) alt_remap_uncached(ptr, size);
 d026690:	e13ffe17 	ldw	r4,-8(fp)
 d026694:	e17fff17 	ldw	r5,-4(fp)
 d026698:	d035d840 	call	d035d84 <alt_remap_uncached>
 d02669c:	e0bffe15 	stw	r2,-8(fp)
   }

   return ptr;
 d0266a0:	e0bffe17 	ldw	r2,-8(fp)
}
 d0266a4:	e037883a 	mov	sp,fp
 d0266a8:	dfc00117 	ldw	ra,4(sp)
 d0266ac:	df000017 	ldw	fp,0(sp)
 d0266b0:	dec00204 	addi	sp,sp,8
 d0266b4:	f800283a 	ret

0d0266b8 <ncpfree>:

void ncpfree(void *ptr)
{
 d0266b8:	defffd04 	addi	sp,sp,-12
 d0266bc:	dfc00215 	stw	ra,8(sp)
 d0266c0:	df000115 	stw	fp,4(sp)
 d0266c4:	df000104 	addi	fp,sp,4
 d0266c8:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 d0266cc:	e0bfff17 	ldw	r2,-4(fp)
 d0266d0:	1005003a 	cmpeq	r2,r2,zero
 d0266d4:	1000061e 	bne	r2,zero,d0266f0 <ncpfree+0x38>
      ptr = alt_remap_cached(ptr, sizeof(ptr));
 d0266d8:	e13fff17 	ldw	r4,-4(fp)
 d0266dc:	01400104 	movi	r5,4
 d0266e0:	d035d4c0 	call	d035d4c <alt_remap_cached>
 d0266e4:	e0bfff15 	stw	r2,-4(fp)
      npfree(ptr);
 d0266e8:	e13fff17 	ldw	r4,-4(fp)
 d0266ec:	d0265ac0 	call	d0265ac <npfree>
   }
}
 d0266f0:	e037883a 	mov	sp,fp
 d0266f4:	dfc00117 	ldw	ra,4(sp)
 d0266f8:	df000017 	ldw	fp,0(sp)
 d0266fc:	dec00204 	addi	sp,sp,8
 d026700:	f800283a 	ret

0d026704 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 d026704:	defffb04 	addi	sp,sp,-20
 d026708:	dfc00415 	stw	ra,16(sp)
 d02670c:	df000315 	stw	fp,12(sp)
 d026710:	df000304 	addi	fp,sp,12
 d026714:	e13ffd15 	stw	r4,-12(fp)
 d026718:	e17ffe15 	stw	r5,-8(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 d02671c:	e0bffd17 	ldw	r2,-12(fp)
 d026720:	108000a0 	cmpeqi	r2,r2,2
 d026724:	1000031e 	bne	r2,zero,d026734 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 d026728:	d025a500 	call	d025a50 <dtrap>
         return NULL;
 d02672c:	e03fff15 	stw	zero,-4(fp)
 d026730:	00001606 	br	d02678c <pffindtype+0x88>
      }
   }

   if (type == SOCK_STREAM)
 d026734:	e0bffe17 	ldw	r2,-8(fp)
 d026738:	10800058 	cmpnei	r2,r2,1
 d02673c:	1000041e 	bne	r2,zero,d026750 <pffindtype+0x4c>
      return &tcp_protosw;
 d026740:	00834174 	movhi	r2,3333
 d026744:	10913904 	addi	r2,r2,17636
 d026748:	e0bfff15 	stw	r2,-4(fp)
 d02674c:	00000f06 	br	d02678c <pffindtype+0x88>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 d026750:	e0bffe17 	ldw	r2,-8(fp)
 d026754:	10800098 	cmpnei	r2,r2,2
 d026758:	1000041e 	bne	r2,zero,d02676c <pffindtype+0x68>
      return &udp_protosw;
 d02675c:	00834174 	movhi	r2,3333
 d026760:	10913f04 	addi	r2,r2,17660
 d026764:	e0bfff15 	stw	r2,-4(fp)
 d026768:	00000806 	br	d02678c <pffindtype+0x88>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 d02676c:	e0bffe17 	ldw	r2,-8(fp)
 d026770:	108000d8 	cmpnei	r2,r2,3
 d026774:	1000041e 	bne	r2,zero,d026788 <pffindtype+0x84>
      return &rawip_protosw;
 d026778:	00834174 	movhi	r2,3333
 d02677c:	10914504 	addi	r2,r2,17684
 d026780:	e0bfff15 	stw	r2,-4(fp)
 d026784:	00000106 	br	d02678c <pffindtype+0x88>
#endif  /* IP_RAW */
   else
      return NULL;
 d026788:	e03fff15 	stw	zero,-4(fp)
 d02678c:	e0bfff17 	ldw	r2,-4(fp)
}
 d026790:	e037883a 	mov	sp,fp
 d026794:	dfc00117 	ldw	ra,4(sp)
 d026798:	df000017 	ldw	fp,0(sp)
 d02679c:	dec00204 	addi	sp,sp,8
 d0267a0:	f800283a 	ret

0d0267a4 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 d0267a4:	defff904 	addi	sp,sp,-28
 d0267a8:	dfc00615 	stw	ra,24(sp)
 d0267ac:	df000515 	stw	fp,20(sp)
 d0267b0:	df000504 	addi	fp,sp,20
 d0267b4:	e13ffb15 	stw	r4,-20(fp)
 d0267b8:	e17ffc15 	stw	r5,-16(fp)
 d0267bc:	e1bffd15 	stw	r6,-12(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 d0267c0:	e0bffd17 	ldw	r2,-12(fp)
 d0267c4:	108000d8 	cmpnei	r2,r2,3
 d0267c8:	1000051e 	bne	r2,zero,d0267e0 <pffindproto+0x3c>
      return(pffindtype(domain, type));
 d0267cc:	e13ffb17 	ldw	r4,-20(fp)
 d0267d0:	e17ffd17 	ldw	r5,-12(fp)
 d0267d4:	d0267040 	call	d026704 <pffindtype>
 d0267d8:	e0bffe15 	stw	r2,-8(fp)
 d0267dc:	00001f06 	br	d02685c <pffindproto+0xb8>
#endif

   switch (protocol)
 d0267e0:	e0bffc17 	ldw	r2,-16(fp)
 d0267e4:	e0bfff15 	stw	r2,-4(fp)
 d0267e8:	e0ffff17 	ldw	r3,-4(fp)
 d0267ec:	188001a0 	cmpeqi	r2,r3,6
 d0267f0:	1000071e 	bne	r2,zero,d026810 <pffindproto+0x6c>
 d0267f4:	e0ffff17 	ldw	r3,-4(fp)
 d0267f8:	18800460 	cmpeqi	r2,r3,17
 d0267fc:	10000a1e 	bne	r2,zero,d026828 <pffindproto+0x84>
 d026800:	e0ffff17 	ldw	r3,-4(fp)
 d026804:	1805003a 	cmpeq	r2,r3,zero
 d026808:	1000101e 	bne	r2,zero,d02684c <pffindproto+0xa8>
 d02680c:	00000c06 	br	d026840 <pffindproto+0x9c>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 d026810:	e0bffd17 	ldw	r2,-12(fp)
 d026814:	10800060 	cmpeqi	r2,r2,1
 d026818:	10000c1e 	bne	r2,zero,d02684c <pffindproto+0xa8>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 d02681c:	d025a500 	call	d025a50 <dtrap>
      return NULL;
 d026820:	e03ffe15 	stw	zero,-8(fp)
 d026824:	00000d06 	br	d02685c <pffindproto+0xb8>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 d026828:	e0bffd17 	ldw	r2,-12(fp)
 d02682c:	108000a0 	cmpeqi	r2,r2,2
 d026830:	1000061e 	bne	r2,zero,d02684c <pffindproto+0xa8>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 d026834:	d025a500 	call	d025a50 <dtrap>
      return NULL;
 d026838:	e03ffe15 	stw	zero,-8(fp)
 d02683c:	00000706 	br	d02685c <pffindproto+0xb8>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 d026840:	d025a500 	call	d025a50 <dtrap>
      return NULL;
 d026844:	e03ffe15 	stw	zero,-8(fp)
 d026848:	00000406 	br	d02685c <pffindproto+0xb8>
   }
   return(pffindtype(domain, type));   /* map to findtype */
 d02684c:	e13ffb17 	ldw	r4,-20(fp)
 d026850:	e17ffd17 	ldw	r5,-12(fp)
 d026854:	d0267040 	call	d026704 <pffindtype>
 d026858:	e0bffe15 	stw	r2,-8(fp)
 d02685c:	e0bffe17 	ldw	r2,-8(fp)
}
 d026860:	e037883a 	mov	sp,fp
 d026864:	dfc00117 	ldw	ra,4(sp)
 d026868:	df000017 	ldw	fp,0(sp)
 d02686c:	dec00204 	addi	sp,sp,8
 d026870:	f800283a 	ret

0d026874 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 d026874:	defff904 	addi	sp,sp,-28
 d026878:	dfc00615 	stw	ra,24(sp)
 d02687c:	df000515 	stw	fp,20(sp)
 d026880:	df000504 	addi	fp,sp,20
 d026884:	e13ffd15 	stw	r4,-12(fp)
 d026888:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 d02688c:	e03ffb15 	stw	zero,-20(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 d026890:	e0bffd17 	ldw	r2,-12(fp)
 d026894:	10800050 	cmplti	r2,r2,1
 d026898:	1000031e 	bne	r2,zero,d0268a8 <m_getnbuf+0x34>
 d02689c:	e0bffd17 	ldw	r2,-12(fp)
 d0268a0:	10800390 	cmplti	r2,r2,14
 d0268a4:	1000011e 	bne	r2,zero,d0268ac <m_getnbuf+0x38>
   {
      dtrap(); /* is this OK? */
 d0268a8:	d025a500 	call	d025a50 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 d0268ac:	e0bffe17 	ldw	r2,-8(fp)
 d0268b0:	1005003a 	cmpeq	r2,r2,zero
 d0268b4:	10000e1e 	bne	r2,zero,d0268f0 <m_getnbuf+0x7c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d0268b8:	01000084 	movi	r4,2
 d0268bc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 d0268c0:	e0bffe17 	ldw	r2,-8(fp)
 d0268c4:	10800e04 	addi	r2,r2,56
 d0268c8:	1009883a 	mov	r4,r2
 d0268cc:	d024e0c0 	call	d024e0c <pk_alloc>
 d0268d0:	e0bffb15 	stw	r2,-20(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0268d4:	01000084 	movi	r4,2
 d0268d8:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 d0268dc:	e0bffb17 	ldw	r2,-20(fp)
 d0268e0:	1004c03a 	cmpne	r2,r2,zero
 d0268e4:	1000021e 	bne	r2,zero,d0268f0 <m_getnbuf+0x7c>
         return NULL;
 d0268e8:	e03fff15 	stw	zero,-4(fp)
 d0268ec:	00004506 	br	d026a04 <m_getnbuf+0x190>
   }

   m = (struct mbuf *)getq(&mfreeq);
 d0268f0:	010341b4 	movhi	r4,3334
 d0268f4:	21047004 	addi	r4,r4,4544
 d0268f8:	d0253180 	call	d025318 <getq>
 d0268fc:	e0bffc15 	stw	r2,-16(fp)
   if (!m)
 d026900:	e0bffc17 	ldw	r2,-16(fp)
 d026904:	1004c03a 	cmpne	r2,r2,zero
 d026908:	10000b1e 	bne	r2,zero,d026938 <m_getnbuf+0xc4>
   {
      if (pkt) 
 d02690c:	e0bffb17 	ldw	r2,-20(fp)
 d026910:	1005003a 	cmpeq	r2,r2,zero
 d026914:	1000061e 	bne	r2,zero,d026930 <m_getnbuf+0xbc>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d026918:	01000084 	movi	r4,2
 d02691c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d026920:	e13ffb17 	ldw	r4,-20(fp)
 d026924:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d026928:	01000084 	movi	r4,2
 d02692c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 d026930:	e03fff15 	stw	zero,-4(fp)
 d026934:	00003306 	br	d026a04 <m_getnbuf+0x190>
   }
   m->m_type = type;
 d026938:	e0fffc17 	ldw	r3,-16(fp)
 d02693c:	e0bffd17 	ldw	r2,-12(fp)
 d026940:	18800815 	stw	r2,32(r3)
   if (len == 0)
 d026944:	e0bffe17 	ldw	r2,-8(fp)
 d026948:	1004c03a 	cmpne	r2,r2,zero
 d02694c:	1000071e 	bne	r2,zero,d02696c <m_getnbuf+0xf8>
   {
      m->pkt = NULL;
 d026950:	e0bffc17 	ldw	r2,-16(fp)
 d026954:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 d026958:	e0bffc17 	ldw	r2,-16(fp)
 d02695c:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 d026960:	e0bffc17 	ldw	r2,-16(fp)
 d026964:	10000515 	stw	zero,20(r2)
 d026968:	00001506 	br	d0269c0 <m_getnbuf+0x14c>
   }
   else
   {
      m->pkt = pkt;
 d02696c:	e0fffc17 	ldw	r3,-16(fp)
 d026970:	e0bffb17 	ldw	r2,-20(fp)
 d026974:	18800115 	stw	r2,4(r3)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 d026978:	e0bffb17 	ldw	r2,-20(fp)
 d02697c:	10800117 	ldw	r2,4(r2)
 d026980:	10c00e04 	addi	r3,r2,56
 d026984:	e0bffb17 	ldw	r2,-20(fp)
 d026988:	10c00315 	stw	r3,12(r2)
 d02698c:	e0bffb17 	ldw	r2,-20(fp)
 d026990:	10c00317 	ldw	r3,12(r2)
 d026994:	e0bffc17 	ldw	r2,-16(fp)
 d026998:	10c00315 	stw	r3,12(r2)
 d02699c:	e0bffc17 	ldw	r2,-16(fp)
 d0269a0:	10c00317 	ldw	r3,12(r2)
 d0269a4:	e0bffc17 	ldw	r2,-16(fp)
 d0269a8:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 d0269ac:	e0bffb17 	ldw	r2,-20(fp)
 d0269b0:	10800217 	ldw	r2,8(r2)
 d0269b4:	10fff204 	addi	r3,r2,-56
 d0269b8:	e0bffc17 	ldw	r2,-16(fp)
 d0269bc:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 d0269c0:	e0bffc17 	ldw	r2,-16(fp)
 d0269c4:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 d0269c8:	e0bffc17 	ldw	r2,-16(fp)
 d0269cc:	10000715 	stw	zero,28(r2)
 d0269d0:	e0bffc17 	ldw	r2,-16(fp)
 d0269d4:	10c00717 	ldw	r3,28(r2)
 d0269d8:	e0bffc17 	ldw	r2,-16(fp)
 d0269dc:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 d0269e0:	d0a92c17 	ldw	r2,-23376(gp)
 d0269e4:	10800044 	addi	r2,r2,1
 d0269e8:	d0a92c15 	stw	r2,-23376(gp)
   putq(&mbufq, (qp)m);
 d0269ec:	e17ffc17 	ldw	r5,-16(fp)
 d0269f0:	010341b4 	movhi	r4,3334
 d0269f4:	21046b04 	addi	r4,r4,4524
 d0269f8:	d0253e00 	call	d0253e0 <putq>
   return m;
 d0269fc:	e0bffc17 	ldw	r2,-16(fp)
 d026a00:	e0bfff15 	stw	r2,-4(fp)
 d026a04:	e0bfff17 	ldw	r2,-4(fp)
}
 d026a08:	e037883a 	mov	sp,fp
 d026a0c:	dfc00117 	ldw	ra,4(sp)
 d026a10:	df000017 	ldw	fp,0(sp)
 d026a14:	dec00204 	addi	sp,sp,8
 d026a18:	f800283a 	ret

0d026a1c <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 d026a1c:	defffb04 	addi	sp,sp,-20
 d026a20:	dfc00415 	stw	ra,16(sp)
 d026a24:	df000315 	stw	fp,12(sp)
 d026a28:	df000304 	addi	fp,sp,12
 d026a2c:	e13ffe15 	stw	r4,-8(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 d026a30:	008341b4 	movhi	r2,3334
 d026a34:	10846b04 	addi	r2,r2,4524
 d026a38:	10800217 	ldw	r2,8(r2)
 d026a3c:	10800048 	cmpgei	r2,r2,1
 d026a40:	1000031e 	bne	r2,zero,d026a50 <m_free+0x34>
      panic("mfree: q_len");
 d026a44:	01034174 	movhi	r4,3333
 d026a48:	213e5c04 	addi	r4,r4,-1680
 d026a4c:	d02093c0 	call	d02093c <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 d026a50:	e0bffe17 	ldw	r2,-8(fp)
 d026a54:	10800817 	ldw	r2,32(r2)
 d026a58:	10800050 	cmplti	r2,r2,1
 d026a5c:	1000041e 	bne	r2,zero,d026a70 <m_free+0x54>
 d026a60:	e0bffe17 	ldw	r2,-8(fp)
 d026a64:	10800817 	ldw	r2,32(r2)
 d026a68:	10800390 	cmplti	r2,r2,14
 d026a6c:	10000c1e 	bne	r2,zero,d026aa0 <m_free+0x84>
   {
      if (m->m_type == MT_FREE)
 d026a70:	e0bffe17 	ldw	r2,-8(fp)
 d026a74:	10800817 	ldw	r2,32(r2)
 d026a78:	1004c03a 	cmpne	r2,r2,zero
 d026a7c:	1000051e 	bne	r2,zero,d026a94 <m_free+0x78>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 d026a80:	d025a500 	call	d025a50 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 d026a84:	e0bffe17 	ldw	r2,-8(fp)
 d026a88:	10800617 	ldw	r2,24(r2)
 d026a8c:	e0bfff15 	stw	r2,-4(fp)
 d026a90:	00002906 	br	d026b38 <m_free+0x11c>
      }
      else
         panic("m_free: type");
 d026a94:	01034174 	movhi	r4,3333
 d026a98:	213e6004 	addi	r4,r4,-1664
 d026a9c:	d02093c0 	call	d02093c <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 d026aa0:	e0bffe17 	ldw	r2,-8(fp)
 d026aa4:	10800617 	ldw	r2,24(r2)
 d026aa8:	e0bffd15 	stw	r2,-12(fp)

   if (qdel(&mbufq, m) == NULL)
 d026aac:	010341b4 	movhi	r4,3334
 d026ab0:	21046b04 	addi	r4,r4,4524
 d026ab4:	e17ffe17 	ldw	r5,-8(fp)
 d026ab8:	d0254900 	call	d025490 <qdel>
 d026abc:	1004c03a 	cmpne	r2,r2,zero
 d026ac0:	1000031e 	bne	r2,zero,d026ad0 <m_free+0xb4>
      panic("m_free: missing");
 d026ac4:	01034174 	movhi	r4,3333
 d026ac8:	213e6404 	addi	r4,r4,-1648
 d026acc:	d02093c0 	call	d02093c <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 d026ad0:	e0bffe17 	ldw	r2,-8(fp)
 d026ad4:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 d026ad8:	e0bffe17 	ldw	r2,-8(fp)
 d026adc:	10800117 	ldw	r2,4(r2)
 d026ae0:	1005003a 	cmpeq	r2,r2,zero
 d026ae4:	1000071e 	bne	r2,zero,d026b04 <m_free+0xe8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d026ae8:	01000084 	movi	r4,2
 d026aec:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 d026af0:	e0bffe17 	ldw	r2,-8(fp)
 d026af4:	11000117 	ldw	r4,4(r2)
 d026af8:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d026afc:	01000084 	movi	r4,2
 d026b00:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 d026b04:	00834174 	movhi	r2,3333
 d026b08:	109b4c04 	addi	r2,r2,27952
 d026b0c:	10800017 	ldw	r2,0(r2)
 d026b10:	10c00044 	addi	r3,r2,1
 d026b14:	00834174 	movhi	r2,3333
 d026b18:	109b4c04 	addi	r2,r2,27952
 d026b1c:	10c00015 	stw	r3,0(r2)
   putq(&mfreeq, (qp)m);
 d026b20:	e17ffe17 	ldw	r5,-8(fp)
 d026b24:	010341b4 	movhi	r4,3334
 d026b28:	21047004 	addi	r4,r4,4544
 d026b2c:	d0253e00 	call	d0253e0 <putq>
   return nextptr;
 d026b30:	e0bffd17 	ldw	r2,-12(fp)
 d026b34:	e0bfff15 	stw	r2,-4(fp)
 d026b38:	e0bfff17 	ldw	r2,-4(fp)
}
 d026b3c:	e037883a 	mov	sp,fp
 d026b40:	dfc00117 	ldw	ra,4(sp)
 d026b44:	df000017 	ldw	fp,0(sp)
 d026b48:	dec00204 	addi	sp,sp,8
 d026b4c:	f800283a 	ret

0d026b50 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 d026b50:	defffd04 	addi	sp,sp,-12
 d026b54:	dfc00215 	stw	ra,8(sp)
 d026b58:	df000115 	stw	fp,4(sp)
 d026b5c:	df000104 	addi	fp,sp,4
 d026b60:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 d026b64:	00000306 	br	d026b74 <m_freem+0x24>
      m = m_free(m);
 d026b68:	e13fff17 	ldw	r4,-4(fp)
 d026b6c:	d026a1c0 	call	d026a1c <m_free>
 d026b70:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 d026b74:	e0bfff17 	ldw	r2,-4(fp)
 d026b78:	1004c03a 	cmpne	r2,r2,zero
 d026b7c:	103ffa1e 	bne	r2,zero,d026b68 <m_freem+0x18>
      m = m_free(m);
}
 d026b80:	e037883a 	mov	sp,fp
 d026b84:	dfc00117 	ldw	ra,4(sp)
 d026b88:	df000017 	ldw	fp,0(sp)
 d026b8c:	dec00204 	addi	sp,sp,8
 d026b90:	f800283a 	ret

0d026b94 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 d026b94:	defff404 	addi	sp,sp,-48
 d026b98:	dfc00b15 	stw	ra,44(sp)
 d026b9c:	df000a15 	stw	fp,40(sp)
 d026ba0:	df000a04 	addi	fp,sp,40
 d026ba4:	e13ffa15 	stw	r4,-24(fp)
 d026ba8:	e17ffb15 	stw	r5,-20(fp)
 d026bac:	e1bffc15 	stw	r6,-16(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 d026bb0:	e0bffc17 	ldw	r2,-16(fp)
 d026bb4:	1004c03a 	cmpne	r2,r2,zero
 d026bb8:	1000021e 	bne	r2,zero,d026bc4 <m_copy+0x30>
      return NULL;
 d026bbc:	e03ffd15 	stw	zero,-12(fp)
 d026bc0:	0000b706 	br	d026ea0 <m_copy+0x30c>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 d026bc4:	e0bffb17 	ldw	r2,-20(fp)
 d026bc8:	1004803a 	cmplt	r2,r2,zero
 d026bcc:	1000061e 	bne	r2,zero,d026be8 <m_copy+0x54>
 d026bd0:	e0bffc17 	ldw	r2,-16(fp)
 d026bd4:	1004403a 	cmpge	r2,r2,zero
 d026bd8:	1000191e 	bne	r2,zero,d026c40 <m_copy+0xac>
 d026bdc:	e0bffc17 	ldw	r2,-16(fp)
 d026be0:	10bfffe0 	cmpeqi	r2,r2,-1
 d026be4:	1000161e 	bne	r2,zero,d026c40 <m_copy+0xac>
   {
      dtrap();
 d026be8:	d025a500 	call	d025a50 <dtrap>
      return NULL;
 d026bec:	e03ffd15 	stw	zero,-12(fp)
 d026bf0:	0000ab06 	br	d026ea0 <m_copy+0x30c>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 d026bf4:	e0bffa17 	ldw	r2,-24(fp)
 d026bf8:	1004c03a 	cmpne	r2,r2,zero
 d026bfc:	1000031e 	bne	r2,zero,d026c0c <m_copy+0x78>
      {
         dtrap();
 d026c00:	d025a500 	call	d025a50 <dtrap>
         return NULL;
 d026c04:	e03ffd15 	stw	zero,-12(fp)
 d026c08:	0000a506 	br	d026ea0 <m_copy+0x30c>
      }
      if (off < (int)m->m_len)
 d026c0c:	e0bffa17 	ldw	r2,-24(fp)
 d026c10:	10800217 	ldw	r2,8(r2)
 d026c14:	1007883a 	mov	r3,r2
 d026c18:	e0bffb17 	ldw	r2,-20(fp)
 d026c1c:	10c00b16 	blt	r2,r3,d026c4c <m_copy+0xb8>
         break;
      off -= m->m_len;
 d026c20:	e0fffb17 	ldw	r3,-20(fp)
 d026c24:	e0bffa17 	ldw	r2,-24(fp)
 d026c28:	10800217 	ldw	r2,8(r2)
 d026c2c:	1885c83a 	sub	r2,r3,r2
 d026c30:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 d026c34:	e0bffa17 	ldw	r2,-24(fp)
 d026c38:	10800617 	ldw	r2,24(r2)
 d026c3c:	e0bffa15 	stw	r2,-24(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 d026c40:	e0bffb17 	ldw	r2,-20(fp)
 d026c44:	10800048 	cmpgei	r2,r2,1
 d026c48:	103fea1e 	bne	r2,zero,d026bf4 <m_copy+0x60>
         break;
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 d026c4c:	e03ff715 	stw	zero,-36(fp)
 d026c50:	e0bff717 	ldw	r2,-36(fp)
 d026c54:	e0bff815 	stw	r2,-32(fp)

   while (len > 0)
 d026c58:	00008806 	br	d026e7c <m_copy+0x2e8>
   {
      if (m == NULL) /* at end of queue? */
 d026c5c:	e0bffa17 	ldw	r2,-24(fp)
 d026c60:	1004c03a 	cmpne	r2,r2,zero
 d026c64:	1000051e 	bne	r2,zero,d026c7c <m_copy+0xe8>
      {
         panic("m_copy: bad len");
 d026c68:	01034174 	movhi	r4,3333
 d026c6c:	213e6804 	addi	r4,r4,-1632
 d026c70:	d02093c0 	call	d02093c <panic>
         return NULL;
 d026c74:	e03ffd15 	stw	zero,-12(fp)
 d026c78:	00008906 	br	d026ea0 <m_copy+0x30c>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 d026c7c:	e0bffa17 	ldw	r2,-24(fp)
 d026c80:	10c00217 	ldw	r3,8(r2)
 d026c84:	e0bffb17 	ldw	r2,-20(fp)
 d026c88:	1885c83a 	sub	r2,r3,r2
 d026c8c:	e0fffc17 	ldw	r3,-16(fp)
 d026c90:	e0ffff15 	stw	r3,-4(fp)
 d026c94:	e0bffe15 	stw	r2,-8(fp)
 d026c98:	e0bfff17 	ldw	r2,-4(fp)
 d026c9c:	e0fffe17 	ldw	r3,-8(fp)
 d026ca0:	10c0020e 	bge	r2,r3,d026cac <m_copy+0x118>
 d026ca4:	e0bfff17 	ldw	r2,-4(fp)
 d026ca8:	e0bffe15 	stw	r2,-8(fp)
 d026cac:	e0fffe17 	ldw	r3,-8(fp)
 d026cb0:	e0fff615 	stw	r3,-40(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 d026cb4:	e0bffb17 	ldw	r2,-20(fp)
 d026cb8:	108000cc 	andi	r2,r2,3
 d026cbc:	1004c03a 	cmpne	r2,r2,zero
 d026cc0:	1000051e 	bne	r2,zero,d026cd8 <m_copy+0x144>
 d026cc4:	e0bffa17 	ldw	r2,-24(fp)
 d026cc8:	10800117 	ldw	r2,4(r2)
 d026ccc:	10800917 	ldw	r2,36(r2)
 d026cd0:	10800060 	cmpeqi	r2,r2,1
 d026cd4:	1000251e 	bne	r2,zero,d026d6c <m_copy+0x1d8>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 d026cd8:	e0bffa17 	ldw	r2,-24(fp)
 d026cdc:	11000817 	ldw	r4,32(r2)
 d026ce0:	e17ff617 	ldw	r5,-40(fp)
 d026ce4:	d0268740 	call	d026874 <m_getnbuf>
 d026ce8:	e0bff915 	stw	r2,-28(fp)
 d026cec:	e0bff917 	ldw	r2,-28(fp)
 d026cf0:	1005003a 	cmpeq	r2,r2,zero
 d026cf4:	1000671e 	bne	r2,zero,d026e94 <m_copy+0x300>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 d026cf8:	e0bff917 	ldw	r2,-28(fp)
 d026cfc:	11000317 	ldw	r4,12(r2)
 d026d00:	e0bffa17 	ldw	r2,-24(fp)
 d026d04:	10c00317 	ldw	r3,12(r2)
 d026d08:	e0bffb17 	ldw	r2,-20(fp)
 d026d0c:	1885883a 	add	r2,r3,r2
 d026d10:	e0fff617 	ldw	r3,-40(fp)
 d026d14:	100b883a 	mov	r5,r2
 d026d18:	180d883a 	mov	r6,r3
 d026d1c:	d0026080 	call	d002608 <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 d026d20:	e0fff617 	ldw	r3,-40(fp)
 d026d24:	e0bff917 	ldw	r2,-28(fp)
 d026d28:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 d026d2c:	008341b4 	movhi	r2,3334
 d026d30:	10848a04 	addi	r2,r2,4648
 d026d34:	10802e17 	ldw	r2,184(r2)
 d026d38:	10c00044 	addi	r3,r2,1
 d026d3c:	008341b4 	movhi	r2,3334
 d026d40:	10848a04 	addi	r2,r2,4648
 d026d44:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 d026d48:	008341b4 	movhi	r2,3334
 d026d4c:	10848a04 	addi	r2,r2,4648
 d026d50:	10c03017 	ldw	r3,192(r2)
 d026d54:	e0bff617 	ldw	r2,-40(fp)
 d026d58:	1887883a 	add	r3,r3,r2
 d026d5c:	008341b4 	movhi	r2,3334
 d026d60:	10848a04 	addi	r2,r2,4648
 d026d64:	10c03015 	stw	r3,192(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 d026d68:	00003106 	br	d026e30 <m_copy+0x29c>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 d026d6c:	e0bffa17 	ldw	r2,-24(fp)
 d026d70:	11000817 	ldw	r4,32(r2)
 d026d74:	000b883a 	mov	r5,zero
 d026d78:	d0268740 	call	d026874 <m_getnbuf>
 d026d7c:	e0bff915 	stw	r2,-28(fp)
 d026d80:	e0bff917 	ldw	r2,-28(fp)
 d026d84:	1005003a 	cmpeq	r2,r2,zero
 d026d88:	1000421e 	bne	r2,zero,d026e94 <m_copy+0x300>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 d026d8c:	e0bffa17 	ldw	r2,-24(fp)
 d026d90:	10c00117 	ldw	r3,4(r2)
 d026d94:	18800917 	ldw	r2,36(r3)
 d026d98:	10800044 	addi	r2,r2,1
 d026d9c:	18800915 	stw	r2,36(r3)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 d026da0:	e0bffa17 	ldw	r2,-24(fp)
 d026da4:	10c00117 	ldw	r3,4(r2)
 d026da8:	e0bff917 	ldw	r2,-28(fp)
 d026dac:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 d026db0:	e0bffa17 	ldw	r2,-24(fp)
 d026db4:	10c00417 	ldw	r3,16(r2)
 d026db8:	e0bff917 	ldw	r2,-28(fp)
 d026dbc:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 d026dc0:	e0bffa17 	ldw	r2,-24(fp)
 d026dc4:	10c00517 	ldw	r3,20(r2)
 d026dc8:	e0bff917 	ldw	r2,-28(fp)
 d026dcc:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 d026dd0:	e0bffa17 	ldw	r2,-24(fp)
 d026dd4:	10c00317 	ldw	r3,12(r2)
 d026dd8:	e0bffb17 	ldw	r2,-20(fp)
 d026ddc:	1887883a 	add	r3,r3,r2
 d026de0:	e0bff917 	ldw	r2,-28(fp)
 d026de4:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 d026de8:	e0fff617 	ldw	r3,-40(fp)
 d026dec:	e0bff917 	ldw	r2,-28(fp)
 d026df0:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 d026df4:	008341b4 	movhi	r2,3334
 d026df8:	10848a04 	addi	r2,r2,4648
 d026dfc:	10802f17 	ldw	r2,188(r2)
 d026e00:	10c00044 	addi	r3,r2,1
 d026e04:	008341b4 	movhi	r2,3334
 d026e08:	10848a04 	addi	r2,r2,4648
 d026e0c:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 d026e10:	008341b4 	movhi	r2,3334
 d026e14:	10848a04 	addi	r2,r2,4648
 d026e18:	10c03117 	ldw	r3,196(r2)
 d026e1c:	e0bff617 	ldw	r2,-40(fp)
 d026e20:	1887883a 	add	r3,r3,r2
 d026e24:	008341b4 	movhi	r2,3334
 d026e28:	10848a04 	addi	r2,r2,4648
 d026e2c:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 d026e30:	e0fffc17 	ldw	r3,-16(fp)
 d026e34:	e0bff617 	ldw	r2,-40(fp)
 d026e38:	1885c83a 	sub	r2,r3,r2
 d026e3c:	e0bffc15 	stw	r2,-16(fp)
      off = 0;
 d026e40:	e03ffb15 	stw	zero,-20(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 d026e44:	e0bff717 	ldw	r2,-36(fp)
 d026e48:	1005003a 	cmpeq	r2,r2,zero
 d026e4c:	1000041e 	bne	r2,zero,d026e60 <m_copy+0x2cc>
         tail->m_next = nb;
 d026e50:	e0fff717 	ldw	r3,-36(fp)
 d026e54:	e0bff917 	ldw	r2,-28(fp)
 d026e58:	18800615 	stw	r2,24(r3)
 d026e5c:	00000206 	br	d026e68 <m_copy+0x2d4>
      else
         head = nb;
 d026e60:	e0bff917 	ldw	r2,-28(fp)
 d026e64:	e0bff815 	stw	r2,-32(fp)
      tail = nb;     /* always make new mbuf the tail */
 d026e68:	e0bff917 	ldw	r2,-28(fp)
 d026e6c:	e0bff715 	stw	r2,-36(fp)
      m = m->m_next;
 d026e70:	e0bffa17 	ldw	r2,-24(fp)
 d026e74:	10800617 	ldw	r2,24(r2)
 d026e78:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 d026e7c:	e0bffc17 	ldw	r2,-16(fp)
 d026e80:	10800048 	cmpgei	r2,r2,1
 d026e84:	103f751e 	bne	r2,zero,d026c5c <m_copy+0xc8>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 d026e88:	e0bff817 	ldw	r2,-32(fp)
 d026e8c:	e0bffd15 	stw	r2,-12(fp)
 d026e90:	00000306 	br	d026ea0 <m_copy+0x30c>

nospace:
   m_freem (head);
 d026e94:	e13ff817 	ldw	r4,-32(fp)
 d026e98:	d026b500 	call	d026b50 <m_freem>
   return NULL;
 d026e9c:	e03ffd15 	stw	zero,-12(fp)
 d026ea0:	e0bffd17 	ldw	r2,-12(fp)
}
 d026ea4:	e037883a 	mov	sp,fp
 d026ea8:	dfc00117 	ldw	ra,4(sp)
 d026eac:	df000017 	ldw	fp,0(sp)
 d026eb0:	dec00204 	addi	sp,sp,8
 d026eb4:	f800283a 	ret

0d026eb8 <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 d026eb8:	defffb04 	addi	sp,sp,-20
 d026ebc:	df000415 	stw	fp,16(sp)
 d026ec0:	df000404 	addi	fp,sp,16
 d026ec4:	e13ffe15 	stw	r4,-8(fp)
 d026ec8:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 d026ecc:	e0bffe17 	ldw	r2,-8(fp)
 d026ed0:	e0bffd15 	stw	r2,-12(fp)
 d026ed4:	e0bffd17 	ldw	r2,-12(fp)
 d026ed8:	1005003a 	cmpeq	r2,r2,zero
 d026edc:	1000661e 	bne	r2,zero,d027078 <m_adj+0x1c0>
      return;

   if (len >= 0) 
 d026ee0:	e0bfff17 	ldw	r2,-4(fp)
 d026ee4:	1004803a 	cmplt	r2,r2,zero
 d026ee8:	1000241e 	bne	r2,zero,d026f7c <m_adj+0xc4>
   {
      while (m != NULL && len > 0) 
 d026eec:	00001c06 	br	d026f60 <m_adj+0xa8>
      {
         if (m->m_len <= (unsigned)len)
 d026ef0:	e0bffd17 	ldw	r2,-12(fp)
 d026ef4:	10c00217 	ldw	r3,8(r2)
 d026ef8:	e0bfff17 	ldw	r2,-4(fp)
 d026efc:	10c00b36 	bltu	r2,r3,d026f2c <m_adj+0x74>
         {
            len -= m->m_len;
 d026f00:	e0ffff17 	ldw	r3,-4(fp)
 d026f04:	e0bffd17 	ldw	r2,-12(fp)
 d026f08:	10800217 	ldw	r2,8(r2)
 d026f0c:	1885c83a 	sub	r2,r3,r2
 d026f10:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 d026f14:	e0bffd17 	ldw	r2,-12(fp)
 d026f18:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 d026f1c:	e0bffd17 	ldw	r2,-12(fp)
 d026f20:	10800617 	ldw	r2,24(r2)
 d026f24:	e0bffd15 	stw	r2,-12(fp)
 d026f28:	00000d06 	br	d026f60 <m_adj+0xa8>
         }
         else
         {
            m->m_len -= len;
 d026f2c:	e0bffd17 	ldw	r2,-12(fp)
 d026f30:	10c00217 	ldw	r3,8(r2)
 d026f34:	e0bfff17 	ldw	r2,-4(fp)
 d026f38:	1887c83a 	sub	r3,r3,r2
 d026f3c:	e0bffd17 	ldw	r2,-12(fp)
 d026f40:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 d026f44:	e0bffd17 	ldw	r2,-12(fp)
 d026f48:	10c00317 	ldw	r3,12(r2)
 d026f4c:	e0bfff17 	ldw	r2,-4(fp)
 d026f50:	1887883a 	add	r3,r3,r2
 d026f54:	e0bffd17 	ldw	r2,-12(fp)
 d026f58:	10c00315 	stw	r3,12(r2)
            break;
 d026f5c:	00004606 	br	d027078 <m_adj+0x1c0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 d026f60:	e0bffd17 	ldw	r2,-12(fp)
 d026f64:	1005003a 	cmpeq	r2,r2,zero
 d026f68:	1000431e 	bne	r2,zero,d027078 <m_adj+0x1c0>
 d026f6c:	e0bfff17 	ldw	r2,-4(fp)
 d026f70:	10800048 	cmpgei	r2,r2,1
 d026f74:	103fde1e 	bne	r2,zero,d026ef0 <m_adj+0x38>
 d026f78:	00003f06 	br	d027078 <m_adj+0x1c0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 d026f7c:	e0bfff17 	ldw	r2,-4(fp)
 d026f80:	0085c83a 	sub	r2,zero,r2
 d026f84:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 d026f88:	e03ffc15 	stw	zero,-16(fp)
      for (;;) 
      {
         count += m->m_len;
 d026f8c:	e0bffd17 	ldw	r2,-12(fp)
 d026f90:	10c00217 	ldw	r3,8(r2)
 d026f94:	e0bffc17 	ldw	r2,-16(fp)
 d026f98:	1885883a 	add	r2,r3,r2
 d026f9c:	e0bffc15 	stw	r2,-16(fp)
         if (m->m_next == (struct mbuf *)0)
 d026fa0:	e0bffd17 	ldw	r2,-12(fp)
 d026fa4:	10800617 	ldw	r2,24(r2)
 d026fa8:	1005003a 	cmpeq	r2,r2,zero
 d026fac:	1000041e 	bne	r2,zero,d026fc0 <m_adj+0x108>
            break;
         m = m->m_next;
 d026fb0:	e0bffd17 	ldw	r2,-12(fp)
 d026fb4:	10800617 	ldw	r2,24(r2)
 d026fb8:	e0bffd15 	stw	r2,-12(fp)
      }
 d026fbc:	003ff306 	br	d026f8c <m_adj+0xd4>
      if (m->m_len >= (unsigned)len)
 d026fc0:	e0bffd17 	ldw	r2,-12(fp)
 d026fc4:	10c00217 	ldw	r3,8(r2)
 d026fc8:	e0bfff17 	ldw	r2,-4(fp)
 d026fcc:	18800736 	bltu	r3,r2,d026fec <m_adj+0x134>
      {
         m->m_len -= len;
 d026fd0:	e0bffd17 	ldw	r2,-12(fp)
 d026fd4:	10c00217 	ldw	r3,8(r2)
 d026fd8:	e0bfff17 	ldw	r2,-4(fp)
 d026fdc:	1887c83a 	sub	r3,r3,r2
 d026fe0:	e0bffd17 	ldw	r2,-12(fp)
 d026fe4:	10c00215 	stw	r3,8(r2)
         return;
 d026fe8:	00002306 	br	d027078 <m_adj+0x1c0>
      }
      count -= len;
 d026fec:	e0fffc17 	ldw	r3,-16(fp)
 d026ff0:	e0bfff17 	ldw	r2,-4(fp)
 d026ff4:	1885c83a 	sub	r2,r3,r2
 d026ff8:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 d026ffc:	e0bffe17 	ldw	r2,-8(fp)
 d027000:	e0bffd15 	stw	r2,-12(fp)
 d027004:	00001006 	br	d027048 <m_adj+0x190>
      {
         if (m->m_len >= (unsigned)count)
 d027008:	e0bffd17 	ldw	r2,-12(fp)
 d02700c:	10c00217 	ldw	r3,8(r2)
 d027010:	e0bffc17 	ldw	r2,-16(fp)
 d027014:	18800436 	bltu	r3,r2,d027028 <m_adj+0x170>
         {
            m->m_len = count;
 d027018:	e0fffc17 	ldw	r3,-16(fp)
 d02701c:	e0bffd17 	ldw	r2,-12(fp)
 d027020:	10c00215 	stw	r3,8(r2)
            break;
 d027024:	00000e06 	br	d027060 <m_adj+0x1a8>
         }
         count -= m->m_len;
 d027028:	e0fffc17 	ldw	r3,-16(fp)
 d02702c:	e0bffd17 	ldw	r2,-12(fp)
 d027030:	10800217 	ldw	r2,8(r2)
 d027034:	1885c83a 	sub	r2,r3,r2
 d027038:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 d02703c:	e0bffd17 	ldw	r2,-12(fp)
 d027040:	10800617 	ldw	r2,24(r2)
 d027044:	e0bffd15 	stw	r2,-12(fp)
 d027048:	e0bffd17 	ldw	r2,-12(fp)
 d02704c:	1004c03a 	cmpne	r2,r2,zero
 d027050:	103fed1e 	bne	r2,zero,d027008 <m_adj+0x150>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 d027054:	00000206 	br	d027060 <m_adj+0x1a8>
         m->m_len = 0;
 d027058:	e0bffd17 	ldw	r2,-12(fp)
 d02705c:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 d027060:	e0bffd17 	ldw	r2,-12(fp)
 d027064:	10800617 	ldw	r2,24(r2)
 d027068:	e0bffd15 	stw	r2,-12(fp)
 d02706c:	e0bffd17 	ldw	r2,-12(fp)
 d027070:	1004c03a 	cmpne	r2,r2,zero
 d027074:	103ff81e 	bne	r2,zero,d027058 <m_adj+0x1a0>
         m->m_len = 0;
   }
}
 d027078:	e037883a 	mov	sp,fp
 d02707c:	df000017 	ldw	fp,0(sp)
 d027080:	dec00104 	addi	sp,sp,4
 d027084:	f800283a 	ret

0d027088 <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 d027088:	defffd04 	addi	sp,sp,-12
 d02708c:	df000215 	stw	fp,8(sp)
 d027090:	df000204 	addi	fp,sp,8
 d027094:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 d027098:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 d02709c:	00000806 	br	d0270c0 <mbuf_len+0x38>
   {
      len += m->m_len;
 d0270a0:	e0bfff17 	ldw	r2,-4(fp)
 d0270a4:	10c00217 	ldw	r3,8(r2)
 d0270a8:	e0bffe17 	ldw	r2,-8(fp)
 d0270ac:	1885883a 	add	r2,r3,r2
 d0270b0:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 d0270b4:	e0bfff17 	ldw	r2,-4(fp)
 d0270b8:	10800617 	ldw	r2,24(r2)
 d0270bc:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 d0270c0:	e0bfff17 	ldw	r2,-4(fp)
 d0270c4:	1004c03a 	cmpne	r2,r2,zero
 d0270c8:	103ff51e 	bne	r2,zero,d0270a0 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 d0270cc:	e0bffe17 	ldw	r2,-8(fp)
}
 d0270d0:	e037883a 	mov	sp,fp
 d0270d4:	df000017 	ldw	fp,0(sp)
 d0270d8:	dec00104 	addi	sp,sp,4
 d0270dc:	f800283a 	ret

0d0270e0 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 d0270e0:	defffa04 	addi	sp,sp,-24
 d0270e4:	dfc00515 	stw	ra,20(sp)
 d0270e8:	df000415 	stw	fp,16(sp)
 d0270ec:	df000404 	addi	fp,sp,16
 d0270f0:	e13ffe15 	stw	r4,-8(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 d0270f4:	008341b4 	movhi	r2,3334
 d0270f8:	10846b04 	addi	r2,r2,4524
 d0270fc:	10800017 	ldw	r2,0(r2)
 d027100:	e0bffd15 	stw	r2,-12(fp)
 d027104:	00001306 	br	d027154 <dtom+0x74>
   {
      m = (struct mbuf *)qptr;
 d027108:	e0bffd17 	ldw	r2,-12(fp)
 d02710c:	e0bffc15 	stw	r2,-16(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 d027110:	e0bffc17 	ldw	r2,-16(fp)
 d027114:	10c00417 	ldw	r3,16(r2)
 d027118:	e0bffe17 	ldw	r2,-8(fp)
 d02711c:	10c00a36 	bltu	r2,r3,d027148 <dtom+0x68>
 d027120:	e0bffc17 	ldw	r2,-16(fp)
 d027124:	10c00417 	ldw	r3,16(r2)
 d027128:	e0bffc17 	ldw	r2,-16(fp)
 d02712c:	10800517 	ldw	r2,20(r2)
 d027130:	1887883a 	add	r3,r3,r2
 d027134:	e0bffe17 	ldw	r2,-8(fp)
 d027138:	10c0032e 	bgeu	r2,r3,d027148 <dtom+0x68>
         return (struct mbuf *)qptr;
 d02713c:	e0bffd17 	ldw	r2,-12(fp)
 d027140:	e0bfff15 	stw	r2,-4(fp)
 d027144:	00000a06 	br	d027170 <dtom+0x90>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 d027148:	e0bffd17 	ldw	r2,-12(fp)
 d02714c:	10800017 	ldw	r2,0(r2)
 d027150:	e0bffd15 	stw	r2,-12(fp)
 d027154:	e0bffd17 	ldw	r2,-12(fp)
 d027158:	1004c03a 	cmpne	r2,r2,zero
 d02715c:	103fea1e 	bne	r2,zero,d027108 <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 d027160:	01034174 	movhi	r4,3333
 d027164:	213e6c04 	addi	r4,r4,-1616
 d027168:	d02093c0 	call	d02093c <panic>
   return NULL;
 d02716c:	e03fff15 	stw	zero,-4(fp)
 d027170:	e0bfff17 	ldw	r2,-4(fp)
}
 d027174:	e037883a 	mov	sp,fp
 d027178:	dfc00117 	ldw	ra,4(sp)
 d02717c:	df000017 	ldw	fp,0(sp)
 d027180:	dec00204 	addi	sp,sp,8
 d027184:	f800283a 	ret

0d027188 <remque>:
};


void
remque (void * arg)
{
 d027188:	defffd04 	addi	sp,sp,-12
 d02718c:	df000215 	stw	fp,8(sp)
 d027190:	df000204 	addi	fp,sp,8
 d027194:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 d027198:	e0bfff17 	ldw	r2,-4(fp)
 d02719c:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 d0271a0:	e0bffe17 	ldw	r2,-8(fp)
 d0271a4:	10800117 	ldw	r2,4(r2)
 d0271a8:	1005003a 	cmpeq	r2,r2,zero
 d0271ac:	10000e1e 	bne	r2,zero,d0271e8 <remque+0x60>
      old->prev->next = old->next;
 d0271b0:	e0bffe17 	ldw	r2,-8(fp)
 d0271b4:	10c00117 	ldw	r3,4(r2)
 d0271b8:	e0bffe17 	ldw	r2,-8(fp)
 d0271bc:	10800017 	ldw	r2,0(r2)
 d0271c0:	18800015 	stw	r2,0(r3)
   if (old->next)
 d0271c4:	e0bffe17 	ldw	r2,-8(fp)
 d0271c8:	10800017 	ldw	r2,0(r2)
 d0271cc:	1005003a 	cmpeq	r2,r2,zero
 d0271d0:	1000051e 	bne	r2,zero,d0271e8 <remque+0x60>
      old->next->prev = old->prev;
 d0271d4:	e0bffe17 	ldw	r2,-8(fp)
 d0271d8:	10c00017 	ldw	r3,0(r2)
 d0271dc:	e0bffe17 	ldw	r2,-8(fp)
 d0271e0:	10800117 	ldw	r2,4(r2)
 d0271e4:	18800115 	stw	r2,4(r3)
}
 d0271e8:	e037883a 	mov	sp,fp
 d0271ec:	df000017 	ldw	fp,0(sp)
 d0271f0:	dec00104 	addi	sp,sp,4
 d0271f4:	f800283a 	ret

0d0271f8 <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 d0271f8:	defffb04 	addi	sp,sp,-20
 d0271fc:	df000415 	stw	fp,16(sp)
 d027200:	df000404 	addi	fp,sp,16
 d027204:	e13ffe15 	stw	r4,-8(fp)
 d027208:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 d02720c:	e0bffe17 	ldw	r2,-8(fp)
 d027210:	e0bffd15 	stw	r2,-12(fp)
   prev = (struct bsdq *)p;
 d027214:	e0bfff17 	ldw	r2,-4(fp)
 d027218:	e0bffc15 	stw	r2,-16(fp)
   newe->next = prev->next;
 d02721c:	e0bffc17 	ldw	r2,-16(fp)
 d027220:	10c00017 	ldw	r3,0(r2)
 d027224:	e0bffd17 	ldw	r2,-12(fp)
 d027228:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 d02722c:	e0fffd17 	ldw	r3,-12(fp)
 d027230:	e0bffc17 	ldw	r2,-16(fp)
 d027234:	18800115 	stw	r2,4(r3)
   prev->next = newe;
 d027238:	e0fffc17 	ldw	r3,-16(fp)
 d02723c:	e0bffd17 	ldw	r2,-12(fp)
 d027240:	18800015 	stw	r2,0(r3)
   if (newe->next)
 d027244:	e0bffd17 	ldw	r2,-12(fp)
 d027248:	10800017 	ldw	r2,0(r2)
 d02724c:	1005003a 	cmpeq	r2,r2,zero
 d027250:	1000041e 	bne	r2,zero,d027264 <insque+0x6c>
      newe->next->prev = newe;
 d027254:	e0bffd17 	ldw	r2,-12(fp)
 d027258:	10c00017 	ldw	r3,0(r2)
 d02725c:	e0bffd17 	ldw	r2,-12(fp)
 d027260:	18800115 	stw	r2,4(r3)
}
 d027264:	e037883a 	mov	sp,fp
 d027268:	df000017 	ldw	fp,0(sp)
 d02726c:	dec00104 	addi	sp,sp,4
 d027270:	f800283a 	ret

0d027274 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 d027274:	defffb04 	addi	sp,sp,-20
 d027278:	dfc00415 	stw	ra,16(sp)
 d02727c:	df000315 	stw	fp,12(sp)
 d027280:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 d027284:	00834174 	movhi	r2,3333
 d027288:	10925404 	addi	r2,r2,18768
 d02728c:	10c00017 	ldw	r3,0(r2)
 d027290:	00834174 	movhi	r2,3333
 d027294:	10925604 	addi	r2,r2,18776
 d027298:	10800017 	ldw	r2,0(r2)
 d02729c:	1885883a 	add	r2,r3,r2
 d0272a0:	1085883a 	add	r2,r2,r2
 d0272a4:	108000c4 	addi	r2,r2,3
 d0272a8:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 d0272ac:	008341b4 	movhi	r2,3334
 d0272b0:	10845704 	addi	r2,r2,4444
 d0272b4:	10000015 	stw	zero,0(r2)
 d0272b8:	10000115 	stw	zero,4(r2)
 d0272bc:	10000215 	stw	zero,8(r2)
 d0272c0:	10000315 	stw	zero,12(r2)
 d0272c4:	10000415 	stw	zero,16(r2)
   MEMSET(&mbufq, 0, sizeof(mbufq));
 d0272c8:	008341b4 	movhi	r2,3334
 d0272cc:	10846b04 	addi	r2,r2,4524
 d0272d0:	10000015 	stw	zero,0(r2)
 d0272d4:	10000115 	stw	zero,4(r2)
 d0272d8:	10000215 	stw	zero,8(r2)
 d0272dc:	10000315 	stw	zero,12(r2)
 d0272e0:	10000415 	stw	zero,16(r2)
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 d0272e4:	008341b4 	movhi	r2,3334
 d0272e8:	10847004 	addi	r2,r2,4544
 d0272ec:	10000015 	stw	zero,0(r2)
 d0272f0:	10000115 	stw	zero,4(r2)
 d0272f4:	10000215 	stw	zero,8(r2)
 d0272f8:	10000315 	stw	zero,12(r2)
 d0272fc:	10000415 	stw	zero,16(r2)
   for (i = 0; i < (int)bufcount; i++)
 d027300:	e03fff15 	stw	zero,-4(fp)
 d027304:	00001606 	br	d027360 <nptcp_init+0xec>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 d027308:	01000904 	movi	r4,36
 d02730c:	d0264b80 	call	d0264b8 <npalloc>
 d027310:	e0bffd15 	stw	r2,-12(fp)
      if (!m)  /* malloc error, bail out */
 d027314:	e0bffd17 	ldw	r2,-12(fp)
 d027318:	1004c03a 	cmpne	r2,r2,zero
 d02731c:	1000031e 	bne	r2,zero,d02732c <nptcp_init+0xb8>
         panic("tcpinit");
 d027320:	01034174 	movhi	r4,3333
 d027324:	213e6e04 	addi	r4,r4,-1608
 d027328:	d02093c0 	call	d02093c <panic>
      m->m_type = MT_FREE;
 d02732c:	e0bffd17 	ldw	r2,-12(fp)
 d027330:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 d027334:	e0bffd17 	ldw	r2,-12(fp)
 d027338:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 d02733c:	e0bffd17 	ldw	r2,-12(fp)
 d027340:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 d027344:	e17ffd17 	ldw	r5,-12(fp)
 d027348:	010341b4 	movhi	r4,3334
 d02734c:	21047004 	addi	r4,r4,4544
 d027350:	d0253e00 	call	d0253e0 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 d027354:	e0bfff17 	ldw	r2,-4(fp)
 d027358:	10800044 	addi	r2,r2,1
 d02735c:	e0bfff15 	stw	r2,-4(fp)
 d027360:	e0fffe17 	ldw	r3,-8(fp)
 d027364:	e0bfff17 	ldw	r2,-4(fp)
 d027368:	10ffe716 	blt	r2,r3,d027308 <nptcp_init+0x94>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 d02736c:	e0fffe17 	ldw	r3,-8(fp)
 d027370:	008341b4 	movhi	r2,3334
 d027374:	10847004 	addi	r2,r2,4544
 d027378:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 d02737c:	d0325b80 	call	d0325b8 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 d027380:	0005883a 	mov	r2,zero
}
 d027384:	e037883a 	mov	sp,fp
 d027388:	dfc00117 	ldw	ra,4(sp)
 d02738c:	df000017 	ldw	fp,0(sp)
 d027390:	dec00204 	addi	sp,sp,8
 d027394:	f800283a 	ret

0d027398 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 d027398:	defff804 	addi	sp,sp,-32
 d02739c:	dfc00715 	stw	ra,28(sp)
 d0273a0:	df000615 	stw	fp,24(sp)
 d0273a4:	df000604 	addi	fp,sp,24
 d0273a8:	e13ffe15 	stw	r4,-8(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 d0273ac:	e0bffe17 	ldw	r2,-8(fp)
 d0273b0:	10800317 	ldw	r2,12(r2)
 d0273b4:	e0bffc15 	stw	r2,-16(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 d0273b8:	e0bffc17 	ldw	r2,-16(fp)
 d0273bc:	1080008b 	ldhu	r2,2(r2)
 d0273c0:	10bfffcc 	andi	r2,r2,65535
 d0273c4:	1004d23a 	srli	r2,r2,8
 d0273c8:	10803fcc 	andi	r2,r2,255
 d0273cc:	1009883a 	mov	r4,r2
 d0273d0:	e0bffc17 	ldw	r2,-16(fp)
 d0273d4:	1080008b 	ldhu	r2,2(r2)
 d0273d8:	10bfffcc 	andi	r2,r2,65535
 d0273dc:	1004923a 	slli	r2,r2,8
 d0273e0:	1007883a 	mov	r3,r2
 d0273e4:	00bfc004 	movi	r2,-256
 d0273e8:	1884703a 	and	r2,r3,r2
 d0273ec:	2084b03a 	or	r2,r4,r2
 d0273f0:	e0bffa0d 	sth	r2,-24(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 d0273f4:	e0bffc17 	ldw	r2,-16(fp)
 d0273f8:	10800003 	ldbu	r2,0(r2)
 d0273fc:	10803fcc 	andi	r2,r2,255
 d027400:	108003cc 	andi	r2,r2,15
 d027404:	1085883a 	add	r2,r2,r2
 d027408:	1085883a 	add	r2,r2,r2
 d02740c:	1007883a 	mov	r3,r2
 d027410:	e0bffc17 	ldw	r2,-16(fp)
 d027414:	1885883a 	add	r2,r3,r2
 d027418:	e0bffb15 	stw	r2,-20(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 d02741c:	e13ffc17 	ldw	r4,-16(fp)
 d027420:	d047f640 	call	d047f64 <tcp_cksum>
 d027424:	1007883a 	mov	r3,r2
 d027428:	e0bffb17 	ldw	r2,-20(fp)
 d02742c:	1080040b 	ldhu	r2,16(r2)
 d027430:	18ffffcc 	andi	r3,r3,65535
 d027434:	10bfffcc 	andi	r2,r2,65535
 d027438:	18801726 	beq	r3,r2,d027498 <tcp_rcv+0x100>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 d02743c:	008341b4 	movhi	r2,3334
 d027440:	10845c04 	addi	r2,r2,4464
 d027444:	10800d17 	ldw	r2,52(r2)
 d027448:	10c00044 	addi	r3,r2,1
 d02744c:	008341b4 	movhi	r2,3334
 d027450:	10845c04 	addi	r2,r2,4464
 d027454:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 d027458:	008341b4 	movhi	r2,3334
 d02745c:	10848a04 	addi	r2,r2,4648
 d027460:	10801c17 	ldw	r2,112(r2)
 d027464:	10c00044 	addi	r3,r2,1
 d027468:	008341b4 	movhi	r2,3334
 d02746c:	10848a04 	addi	r2,r2,4648
 d027470:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d027474:	01000084 	movi	r4,2
 d027478:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 d02747c:	e13ffe17 	ldw	r4,-8(fp)
 d027480:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d027484:	01000084 	movi	r4,2
 d027488:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 d02748c:	00bff804 	movi	r2,-32
 d027490:	e0bfff15 	stw	r2,-4(fp)
 d027494:	00003506 	br	d02756c <tcp_rcv+0x1d4>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 d027498:	01000044 	movi	r4,1
 d02749c:	000b883a 	mov	r5,zero
 d0274a0:	d0268740 	call	d026874 <m_getnbuf>
 d0274a4:	e0bffd15 	stw	r2,-12(fp)
   if (!m_in){
 d0274a8:	e0bffd17 	ldw	r2,-12(fp)
 d0274ac:	1004c03a 	cmpne	r2,r2,zero
 d0274b0:	1000091e 	bne	r2,zero,d0274d8 <tcp_rcv+0x140>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d0274b4:	01000084 	movi	r4,2
 d0274b8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d0274bc:	e13ffe17 	ldw	r4,-8(fp)
 d0274c0:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0274c4:	01000084 	movi	r4,2
 d0274c8:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 d0274cc:	00bffa84 	movi	r2,-22
 d0274d0:	e0bfff15 	stw	r2,-4(fp)
 d0274d4:	00002506 	br	d02756c <tcp_rcv+0x1d4>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 d0274d8:	e0bffc17 	ldw	r2,-16(fp)
 d0274dc:	10800003 	ldbu	r2,0(r2)
 d0274e0:	10803fcc 	andi	r2,r2,255
 d0274e4:	108003cc 	andi	r2,r2,15
 d0274e8:	1085883a 	add	r2,r2,r2
 d0274ec:	1085883a 	add	r2,r2,r2
 d0274f0:	1007883a 	mov	r3,r2
 d0274f4:	e0bffa0b 	ldhu	r2,-24(fp)
 d0274f8:	10c5c83a 	sub	r2,r2,r3
 d0274fc:	e0bffa0d 	sth	r2,-24(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 d027500:	e0fffc17 	ldw	r3,-16(fp)
 d027504:	e0bffa0b 	ldhu	r2,-24(fp)
 d027508:	1880008d 	sth	r2,2(r3)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 d02750c:	e0fffd17 	ldw	r3,-12(fp)
 d027510:	e0bffe17 	ldw	r2,-8(fp)
 d027514:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 d027518:	e0bffe17 	ldw	r2,-8(fp)
 d02751c:	10c00317 	ldw	r3,12(r2)
 d027520:	e0bffd17 	ldw	r2,-12(fp)
 d027524:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 d027528:	e0bffe17 	ldw	r2,-8(fp)
 d02752c:	10c00417 	ldw	r3,16(r2)
 d027530:	e0bffd17 	ldw	r2,-12(fp)
 d027534:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 d027538:	e0bffe17 	ldw	r2,-8(fp)
 d02753c:	10c00117 	ldw	r3,4(r2)
 d027540:	e0bffd17 	ldw	r2,-12(fp)
 d027544:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 d027548:	e0bffe17 	ldw	r2,-8(fp)
 d02754c:	10c00217 	ldw	r3,8(r2)
 d027550:	e0bffd17 	ldw	r2,-12(fp)
 d027554:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 d027558:	e0bffe17 	ldw	r2,-8(fp)
 d02755c:	11400617 	ldw	r5,24(r2)
 d027560:	e13ffd17 	ldw	r4,-12(fp)
 d027564:	d02e6600 	call	d02e660 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 d027568:	e03fff15 	stw	zero,-4(fp)
 d02756c:	e0bfff17 	ldw	r2,-4(fp)
}
 d027570:	e037883a 	mov	sp,fp
 d027574:	dfc00117 	ldw	ra,4(sp)
 d027578:	df000017 	ldw	fp,0(sp)
 d02757c:	dec00204 	addi	sp,sp,8
 d027580:	f800283a 	ret

0d027584 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 d027584:	defff304 	addi	sp,sp,-52
 d027588:	dfc00c15 	stw	ra,48(sp)
 d02758c:	df000b15 	stw	fp,44(sp)
 d027590:	df000b04 	addi	fp,sp,44
 d027594:	e13ffd15 	stw	r4,-12(fp)
 d027598:	e17ffe15 	stw	r5,-8(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 d02759c:	e0bffd17 	ldw	r2,-12(fp)
 d0275a0:	10800617 	ldw	r2,24(r2)
 d0275a4:	1005003a 	cmpeq	r2,r2,zero
 d0275a8:	1001101e 	bne	r2,zero,d0279ec <ip_output+0x468>
   {
      m1 = data;
 d0275ac:	e0bffd17 	ldw	r2,-12(fp)
 d0275b0:	e0bff915 	stw	r2,-28(fp)
      m2 = data->m_next;
 d0275b4:	e0bffd17 	ldw	r2,-12(fp)
 d0275b8:	10800617 	ldw	r2,24(r2)
 d0275bc:	e0bff815 	stw	r2,-32(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 d0275c0:	00003406 	br	d027694 <ip_output+0x110>
      {
         pkt = m1->pkt;
 d0275c4:	e0bff917 	ldw	r2,-28(fp)
 d0275c8:	10800117 	ldw	r2,4(r2)
 d0275cc:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 d0275d0:	e0bffa17 	ldw	r2,-24(fp)
 d0275d4:	10c00117 	ldw	r3,4(r2)
 d0275d8:	e0bffa17 	ldw	r2,-24(fp)
 d0275dc:	10800217 	ldw	r2,8(r2)
 d0275e0:	1889883a 	add	r4,r3,r2
 d0275e4:	e0bff917 	ldw	r2,-28(fp)
 d0275e8:	10c00317 	ldw	r3,12(r2)
 d0275ec:	e0bff917 	ldw	r2,-28(fp)
 d0275f0:	10800217 	ldw	r2,8(r2)
 d0275f4:	1887883a 	add	r3,r3,r2
 d0275f8:	e0bff817 	ldw	r2,-32(fp)
 d0275fc:	10800217 	ldw	r2,8(r2)
 d027600:	1885883a 	add	r2,r3,r2
 d027604:	1100822e 	bgeu	r2,r4,d027810 <ip_output+0x28c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 d027608:	e0bff917 	ldw	r2,-28(fp)
 d02760c:	10c00317 	ldw	r3,12(r2)
 d027610:	e0bff917 	ldw	r2,-28(fp)
 d027614:	10800217 	ldw	r2,8(r2)
 d027618:	1887883a 	add	r3,r3,r2
 d02761c:	e0bff817 	ldw	r2,-32(fp)
 d027620:	11400317 	ldw	r5,12(r2)
 d027624:	e0bff817 	ldw	r2,-32(fp)
 d027628:	10800217 	ldw	r2,8(r2)
 d02762c:	1809883a 	mov	r4,r3
 d027630:	100d883a 	mov	r6,r2
 d027634:	d0026080 	call	d002608 <memcpy>
            m1->m_len += m2->m_len;
 d027638:	e0bff917 	ldw	r2,-28(fp)
 d02763c:	10c00217 	ldw	r3,8(r2)
 d027640:	e0bff817 	ldw	r2,-32(fp)
 d027644:	10800217 	ldw	r2,8(r2)
 d027648:	1887883a 	add	r3,r3,r2
 d02764c:	e0bff917 	ldw	r2,-28(fp)
 d027650:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 d027654:	e0bff817 	ldw	r2,-32(fp)
 d027658:	10c00617 	ldw	r3,24(r2)
 d02765c:	e0bff917 	ldw	r2,-28(fp)
 d027660:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 d027664:	e13ff817 	ldw	r4,-32(fp)
 d027668:	d026a1c0 	call	d026a1c <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 d02766c:	e0bff917 	ldw	r2,-28(fp)
 d027670:	10800617 	ldw	r2,24(r2)
 d027674:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oappends++;
 d027678:	008341b4 	movhi	r2,3334
 d02767c:	10848a04 	addi	r2,r2,4648
 d027680:	10803317 	ldw	r2,204(r2)
 d027684:	10c00044 	addi	r3,r2,1
 d027688:	008341b4 	movhi	r2,3334
 d02768c:	10848a04 	addi	r2,r2,4648
 d027690:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 d027694:	e0bff817 	ldw	r2,-32(fp)
 d027698:	1005003a 	cmpeq	r2,r2,zero
 d02769c:	10005c1e 	bne	r2,zero,d027810 <ip_output+0x28c>
 d0276a0:	e0bff817 	ldw	r2,-32(fp)
 d0276a4:	10800217 	ldw	r2,8(r2)
 d0276a8:	108002b0 	cmpltui	r2,r2,10
 d0276ac:	103fc51e 	bne	r2,zero,d0275c4 <ip_output+0x40>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 d0276b0:	00005706 	br	d027810 <ip_output+0x28c>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 d0276b4:	e0bff817 	ldw	r2,-32(fp)
 d0276b8:	10800317 	ldw	r2,12(r2)
 d0276bc:	1007883a 	mov	r3,r2
 d0276c0:	e0bff817 	ldw	r2,-32(fp)
 d0276c4:	10800117 	ldw	r2,4(r2)
 d0276c8:	10800117 	ldw	r2,4(r2)
 d0276cc:	1885c83a 	sub	r2,r3,r2
 d0276d0:	e0bff615 	stw	r2,-40(fp)
         if (e < MaxLnh)
 d0276d4:	00834174 	movhi	r2,3333
 d0276d8:	109b1e04 	addi	r2,r2,27768
 d0276dc:	10c00017 	ldw	r3,0(r2)
 d0276e0:	e0bff617 	ldw	r2,-40(fp)
 d0276e4:	10c00a0e 	bge	r2,r3,d027710 <ip_output+0x18c>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 d0276e8:	00834174 	movhi	r2,3333
 d0276ec:	109b1e04 	addi	r2,r2,27768
 d0276f0:	11400017 	ldw	r5,0(r2)
 d0276f4:	01034174 	movhi	r4,3333
 d0276f8:	213e7004 	addi	r4,r4,-1600
 d0276fc:	e1bff617 	ldw	r6,-40(fp)
 d027700:	d0028a00 	call	d0028a0 <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 d027704:	01034174 	movhi	r4,3333
 d027708:	213e7604 	addi	r4,r4,-1576
 d02770c:	d02093c0 	call	d02093c <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 d027710:	e0bff917 	ldw	r2,-28(fp)
 d027714:	11000217 	ldw	r4,8(r2)
 d027718:	00834174 	movhi	r2,3333
 d02771c:	109b1e04 	addi	r2,r2,27768
 d027720:	10c00017 	ldw	r3,0(r2)
 d027724:	e0bff617 	ldw	r2,-40(fp)
 d027728:	10c5c83a 	sub	r2,r2,r3
 d02772c:	20803b2e 	bgeu	r4,r2,d02781c <ip_output+0x298>
 d027730:	e0bff917 	ldw	r2,-28(fp)
 d027734:	10800217 	ldw	r2,8(r2)
 d027738:	108000cc 	andi	r2,r2,3
 d02773c:	1004c03a 	cmpne	r2,r2,zero
 d027740:	1000361e 	bne	r2,zero,d02781c <ip_output+0x298>
 d027744:	e0bff817 	ldw	r2,-32(fp)
 d027748:	10800317 	ldw	r2,12(r2)
 d02774c:	1007883a 	mov	r3,r2
 d027750:	e0bff817 	ldw	r2,-32(fp)
 d027754:	10800117 	ldw	r2,4(r2)
 d027758:	10800117 	ldw	r2,4(r2)
 d02775c:	1885c83a 	sub	r2,r3,r2
 d027760:	10800e18 	cmpnei	r2,r2,56
 d027764:	10002d1e 	bne	r2,zero,d02781c <ip_output+0x298>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 d027768:	e0bff817 	ldw	r2,-32(fp)
 d02776c:	10c00317 	ldw	r3,12(r2)
 d027770:	e0bff917 	ldw	r2,-28(fp)
 d027774:	10800217 	ldw	r2,8(r2)
 d027778:	1887c83a 	sub	r3,r3,r2
 d02777c:	e0bff917 	ldw	r2,-28(fp)
 d027780:	11400317 	ldw	r5,12(r2)
 d027784:	e0bff917 	ldw	r2,-28(fp)
 d027788:	10800217 	ldw	r2,8(r2)
 d02778c:	1809883a 	mov	r4,r3
 d027790:	100d883a 	mov	r6,r2
 d027794:	d0026080 	call	d002608 <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 d027798:	e0bff817 	ldw	r2,-32(fp)
 d02779c:	10c00317 	ldw	r3,12(r2)
 d0277a0:	e0bff917 	ldw	r2,-28(fp)
 d0277a4:	10800217 	ldw	r2,8(r2)
 d0277a8:	1887c83a 	sub	r3,r3,r2
 d0277ac:	e0bff817 	ldw	r2,-32(fp)
 d0277b0:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 d0277b4:	e0bff817 	ldw	r2,-32(fp)
 d0277b8:	10c00217 	ldw	r3,8(r2)
 d0277bc:	e0bff917 	ldw	r2,-28(fp)
 d0277c0:	10800217 	ldw	r2,8(r2)
 d0277c4:	1887883a 	add	r3,r3,r2
 d0277c8:	e0bff817 	ldw	r2,-32(fp)
 d0277cc:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 d0277d0:	e13ff917 	ldw	r4,-28(fp)
 d0277d4:	d026a1c0 	call	d026a1c <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 d0277d8:	e0bff817 	ldw	r2,-32(fp)
 d0277dc:	e0bff915 	stw	r2,-28(fp)
 d0277e0:	e0bff917 	ldw	r2,-28(fp)
 d0277e4:	e0bffd15 	stw	r2,-12(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 d0277e8:	e0bff817 	ldw	r2,-32(fp)
 d0277ec:	10800617 	ldw	r2,24(r2)
 d0277f0:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oprepends++;
 d0277f4:	008341b4 	movhi	r2,3334
 d0277f8:	10848a04 	addi	r2,r2,4648
 d0277fc:	10803217 	ldw	r2,200(r2)
 d027800:	10c00044 	addi	r3,r2,1
 d027804:	008341b4 	movhi	r2,3334
 d027808:	10848a04 	addi	r2,r2,4648
 d02780c:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 d027810:	e0bff817 	ldw	r2,-32(fp)
 d027814:	1004c03a 	cmpne	r2,r2,zero
 d027818:	103fa61e 	bne	r2,zero,d0276b4 <ip_output+0x130>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 d02781c:	e0bff817 	ldw	r2,-32(fp)
 d027820:	1005003a 	cmpeq	r2,r2,zero
 d027824:	1000711e 	bne	r2,zero,d0279ec <ip_output+0x468>
      {
         total = 0;
 d027828:	e03ff515 	stw	zero,-44(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 d02782c:	e0bff917 	ldw	r2,-28(fp)
 d027830:	e0bff715 	stw	r2,-36(fp)
 d027834:	00000806 	br	d027858 <ip_output+0x2d4>
            total += mtmp->m_len;
 d027838:	e0bff717 	ldw	r2,-36(fp)
 d02783c:	10c00217 	ldw	r3,8(r2)
 d027840:	e0bff517 	ldw	r2,-44(fp)
 d027844:	1885883a 	add	r2,r3,r2
 d027848:	e0bff515 	stw	r2,-44(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 d02784c:	e0bff717 	ldw	r2,-36(fp)
 d027850:	10800617 	ldw	r2,24(r2)
 d027854:	e0bff715 	stw	r2,-36(fp)
 d027858:	e0bff717 	ldw	r2,-36(fp)
 d02785c:	1004c03a 	cmpne	r2,r2,zero
 d027860:	103ff51e 	bne	r2,zero,d027838 <ip_output+0x2b4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d027864:	01000084 	movi	r4,2
 d027868:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 d02786c:	e0bff517 	ldw	r2,-44(fp)
 d027870:	10800e04 	addi	r2,r2,56
 d027874:	1009883a 	mov	r4,r2
 d027878:	d024e0c0 	call	d024e0c <pk_alloc>
 d02787c:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d027880:	01000084 	movi	r4,2
 d027884:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 d027888:	e0bffa17 	ldw	r2,-24(fp)
 d02788c:	1004c03a 	cmpne	r2,r2,zero
 d027890:	1000031e 	bne	r2,zero,d0278a0 <ip_output+0x31c>
            return ENOBUFS;
 d027894:	00801a44 	movi	r2,105
 d027898:	e0bfff15 	stw	r2,-4(fp)
 d02789c:	0000b106 	br	d027b64 <ip_output+0x5e0>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 d0278a0:	e0bffa17 	ldw	r2,-24(fp)
 d0278a4:	10c00117 	ldw	r3,4(r2)
 d0278a8:	00834174 	movhi	r2,3333
 d0278ac:	109b1e04 	addi	r2,r2,27768
 d0278b0:	10800017 	ldw	r2,0(r2)
 d0278b4:	1887883a 	add	r3,r3,r2
 d0278b8:	e0bffa17 	ldw	r2,-24(fp)
 d0278bc:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 d0278c0:	e0bff917 	ldw	r2,-28(fp)
 d0278c4:	e0bff715 	stw	r2,-36(fp)
         while (mtmp)
 d0278c8:	00002806 	br	d02796c <ip_output+0x3e8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 d0278cc:	e0bffa17 	ldw	r2,-24(fp)
 d0278d0:	10c00317 	ldw	r3,12(r2)
 d0278d4:	e0bff717 	ldw	r2,-36(fp)
 d0278d8:	11400317 	ldw	r5,12(r2)
 d0278dc:	e0bff717 	ldw	r2,-36(fp)
 d0278e0:	10800217 	ldw	r2,8(r2)
 d0278e4:	1809883a 	mov	r4,r3
 d0278e8:	100d883a 	mov	r6,r2
 d0278ec:	d0026080 	call	d002608 <memcpy>
            pkt->nb_prot += mtmp->m_len;
 d0278f0:	e0bffa17 	ldw	r2,-24(fp)
 d0278f4:	10c00317 	ldw	r3,12(r2)
 d0278f8:	e0bff717 	ldw	r2,-36(fp)
 d0278fc:	10800217 	ldw	r2,8(r2)
 d027900:	1887883a 	add	r3,r3,r2
 d027904:	e0bffa17 	ldw	r2,-24(fp)
 d027908:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 d02790c:	e0bffa17 	ldw	r2,-24(fp)
 d027910:	10c00417 	ldw	r3,16(r2)
 d027914:	e0bff717 	ldw	r2,-36(fp)
 d027918:	10800217 	ldw	r2,8(r2)
 d02791c:	1887883a 	add	r3,r3,r2
 d027920:	e0bffa17 	ldw	r2,-24(fp)
 d027924:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 d027928:	e0bff717 	ldw	r2,-36(fp)
 d02792c:	e0bff815 	stw	r2,-32(fp)
            mtmp = mtmp->m_next;
 d027930:	e0bff717 	ldw	r2,-36(fp)
 d027934:	10800617 	ldw	r2,24(r2)
 d027938:	e0bff715 	stw	r2,-36(fp)
            if (m2 != data)   /* save original head */
 d02793c:	e0fff817 	ldw	r3,-32(fp)
 d027940:	e0bffd17 	ldw	r2,-12(fp)
 d027944:	18800226 	beq	r3,r2,d027950 <ip_output+0x3cc>
               m_free(m2);
 d027948:	e13ff817 	ldw	r4,-32(fp)
 d02794c:	d026a1c0 	call	d026a1c <m_free>
            tcpstat.tcps_ocopies++;
 d027950:	008341b4 	movhi	r2,3334
 d027954:	10848a04 	addi	r2,r2,4648
 d027958:	10803417 	ldw	r2,208(r2)
 d02795c:	10c00044 	addi	r3,r2,1
 d027960:	008341b4 	movhi	r2,3334
 d027964:	10848a04 	addi	r2,r2,4648
 d027968:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 d02796c:	e0bff717 	ldw	r2,-36(fp)
 d027970:	1004c03a 	cmpne	r2,r2,zero
 d027974:	103fd51e 	bne	r2,zero,d0278cc <ip_output+0x348>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 d027978:	e0bffa17 	ldw	r2,-24(fp)
 d02797c:	10c00317 	ldw	r3,12(r2)
 d027980:	e0bff517 	ldw	r2,-44(fp)
 d027984:	1887c83a 	sub	r3,r3,r2
 d027988:	e0bffa17 	ldw	r2,-24(fp)
 d02798c:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d027990:	01000084 	movi	r4,2
 d027994:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 d027998:	e0bffd17 	ldw	r2,-12(fp)
 d02799c:	11000117 	ldw	r4,4(r2)
 d0279a0:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0279a4:	01000084 	movi	r4,2
 d0279a8:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 d0279ac:	e0fffd17 	ldw	r3,-12(fp)
 d0279b0:	e0bffa17 	ldw	r2,-24(fp)
 d0279b4:	18800115 	stw	r2,4(r3)
         data->m_len = pkt->nb_plen;
 d0279b8:	e0bffa17 	ldw	r2,-24(fp)
 d0279bc:	10c00417 	ldw	r3,16(r2)
 d0279c0:	e0bffd17 	ldw	r2,-12(fp)
 d0279c4:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 d0279c8:	e0bffd17 	ldw	r2,-12(fp)
 d0279cc:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 d0279d0:	e0bffa17 	ldw	r2,-24(fp)
 d0279d4:	10c00317 	ldw	r3,12(r2)
 d0279d8:	e0bffd17 	ldw	r2,-12(fp)
 d0279dc:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 d0279e0:	e0fff517 	ldw	r3,-44(fp)
 d0279e4:	e0bffd17 	ldw	r2,-12(fp)
 d0279e8:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 d0279ec:	e0bffd17 	ldw	r2,-12(fp)
 d0279f0:	11000317 	ldw	r4,12(r2)
 d0279f4:	e0bffd17 	ldw	r2,-12(fp)
 d0279f8:	10800117 	ldw	r2,4(r2)
 d0279fc:	10c00117 	ldw	r3,4(r2)
 d027a00:	00834174 	movhi	r2,3333
 d027a04:	109b1e04 	addi	r2,r2,27768
 d027a08:	10800017 	ldw	r2,0(r2)
 d027a0c:	1885883a 	add	r2,r3,r2
 d027a10:	2080032e 	bgeu	r4,r2,d027a20 <ip_output+0x49c>
      panic("ip_output: overflow");
 d027a14:	01034174 	movhi	r4,3333
 d027a18:	213e7b04 	addi	r4,r4,-1556
 d027a1c:	d02093c0 	call	d02093c <panic>

   pkt = data->pkt;
 d027a20:	e0bffd17 	ldw	r2,-12(fp)
 d027a24:	10800117 	ldw	r2,4(r2)
 d027a28:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 d027a2c:	e0bffe17 	ldw	r2,-8(fp)
 d027a30:	1005003a 	cmpeq	r2,r2,zero
 d027a34:	1000031e 	bne	r2,zero,d027a44 <ip_output+0x4c0>
	   pkt->soxopts = so_optsPack;   /* yup */
 d027a38:	e0fffa17 	ldw	r3,-24(fp)
 d027a3c:	e0bffe17 	ldw	r2,-8(fp)
 d027a40:	18800c15 	stw	r2,48(r3)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 d027a44:	e0bffd17 	ldw	r2,-12(fp)
 d027a48:	10800317 	ldw	r2,12(r2)
 d027a4c:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 d027a50:	e0bffc17 	ldw	r2,-16(fp)
 d027a54:	10c00417 	ldw	r3,16(r2)
 d027a58:	e0bffa17 	ldw	r2,-24(fp)
 d027a5c:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 d027a60:	e0fffc17 	ldw	r3,-16(fp)
 d027a64:	00801144 	movi	r2,69
 d027a68:	18800005 	stb	r2,0(r3)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 d027a6c:	e0bffc17 	ldw	r2,-16(fp)
 d027a70:	1080008b 	ldhu	r2,2(r2)
 d027a74:	10bfffcc 	andi	r2,r2,65535
 d027a78:	1004d23a 	srli	r2,r2,8
 d027a7c:	10803fcc 	andi	r2,r2,255
 d027a80:	1009883a 	mov	r4,r2
 d027a84:	e0bffc17 	ldw	r2,-16(fp)
 d027a88:	1080008b 	ldhu	r2,2(r2)
 d027a8c:	10bfffcc 	andi	r2,r2,65535
 d027a90:	1004923a 	slli	r2,r2,8
 d027a94:	1007883a 	mov	r3,r2
 d027a98:	00bfc004 	movi	r2,-256
 d027a9c:	1884703a 	and	r2,r3,r2
 d027aa0:	2084b03a 	or	r2,r4,r2
 d027aa4:	1007883a 	mov	r3,r2
 d027aa8:	e0bffc17 	ldw	r2,-16(fp)
 d027aac:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 d027ab0:	e0bffc17 	ldw	r2,-16(fp)
 d027ab4:	10800003 	ldbu	r2,0(r2)
 d027ab8:	10803fcc 	andi	r2,r2,255
 d027abc:	108003cc 	andi	r2,r2,15
 d027ac0:	1085883a 	add	r2,r2,r2
 d027ac4:	1085883a 	add	r2,r2,r2
 d027ac8:	1007883a 	mov	r3,r2
 d027acc:	e0bffc17 	ldw	r2,-16(fp)
 d027ad0:	1885883a 	add	r2,r3,r2
 d027ad4:	e0bffb15 	stw	r2,-20(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 d027ad8:	e13ffc17 	ldw	r4,-16(fp)
 d027adc:	d047f640 	call	d047f64 <tcp_cksum>
 d027ae0:	1007883a 	mov	r3,r2
 d027ae4:	e0bffb17 	ldw	r2,-20(fp)
 d027ae8:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 d027aec:	e0bffc17 	ldw	r2,-16(fp)
 d027af0:	10800504 	addi	r2,r2,20
 d027af4:	1007883a 	mov	r3,r2
 d027af8:	e0bffa17 	ldw	r2,-24(fp)
 d027afc:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 d027b00:	e0bffd17 	ldw	r2,-12(fp)
 d027b04:	10800217 	ldw	r2,8(r2)
 d027b08:	10fffb04 	addi	r3,r2,-20
 d027b0c:	e0bffa17 	ldw	r2,-24(fp)
 d027b10:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 d027b14:	01000184 	movi	r4,6
 d027b18:	e17ffa17 	ldw	r5,-24(fp)
 d027b1c:	d03f2780 	call	d03f278 <ip_write>
 d027b20:	e0bff615 	stw	r2,-40(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 d027b24:	e0bffd17 	ldw	r2,-12(fp)
 d027b28:	10000115 	stw	zero,4(r2)
   m_freem(data);
 d027b2c:	e13ffd17 	ldw	r4,-12(fp)
 d027b30:	d026b500 	call	d026b50 <m_freem>

   if (e < 0)
 d027b34:	e0bff617 	ldw	r2,-40(fp)
 d027b38:	1004403a 	cmpge	r2,r2,zero
 d027b3c:	1000081e 	bne	r2,zero,d027b60 <ip_output+0x5dc>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 d027b40:	e0bff617 	ldw	r2,-40(fp)
 d027b44:	10bffa98 	cmpnei	r2,r2,-22
 d027b48:	1000021e 	bne	r2,zero,d027b54 <ip_output+0x5d0>
         return 0;
 d027b4c:	e03fff15 	stw	zero,-4(fp)
 d027b50:	00000406 	br	d027b64 <ip_output+0x5e0>
      return e;
 d027b54:	e0bff617 	ldw	r2,-40(fp)
 d027b58:	e0bfff15 	stw	r2,-4(fp)
 d027b5c:	00000106 	br	d027b64 <ip_output+0x5e0>
   }
   else
      return 0;
 d027b60:	e03fff15 	stw	zero,-4(fp)
 d027b64:	e0bfff17 	ldw	r2,-4(fp)
}
 d027b68:	e037883a 	mov	sp,fp
 d027b6c:	dfc00117 	ldw	ra,4(sp)
 d027b70:	df000017 	ldw	fp,0(sp)
 d027b74:	dec00204 	addi	sp,sp,8
 d027b78:	f800283a 	ret

0d027b7c <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 d027b7c:	defffd04 	addi	sp,sp,-12
 d027b80:	df000215 	stw	fp,8(sp)
 d027b84:	df000204 	addi	fp,sp,8
 d027b88:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr == 0xffffffff)
 d027b8c:	e0bffe17 	ldw	r2,-8(fp)
 d027b90:	10bfffd8 	cmpnei	r2,r2,-1
 d027b94:	1000031e 	bne	r2,zero,d027ba4 <in_broadcast+0x28>
      return TRUE;
 d027b98:	00800044 	movi	r2,1
 d027b9c:	e0bfff15 	stw	r2,-4(fp)
 d027ba0:	00000106 	br	d027ba8 <in_broadcast+0x2c>

   return FALSE;
 d027ba4:	e03fff15 	stw	zero,-4(fp)
 d027ba8:	e0bfff17 	ldw	r2,-4(fp)
}
 d027bac:	e037883a 	mov	sp,fp
 d027bb0:	df000017 	ldw	fp,0(sp)
 d027bb4:	dec00104 	addi	sp,sp,4
 d027bb8:	f800283a 	ret

0d027bbc <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 d027bbc:	defffb04 	addi	sp,sp,-20
 d027bc0:	dfc00415 	stw	ra,16(sp)
 d027bc4:	df000315 	stw	fp,12(sp)
 d027bc8:	df000304 	addi	fp,sp,12
 d027bcc:	e13ffe15 	stw	r4,-8(fp)
 d027bd0:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 d027bd4:	e0bffe17 	ldw	r2,-8(fp)
 d027bd8:	10800003 	ldbu	r2,0(r2)
 d027bdc:	10803fcc 	andi	r2,r2,255
 d027be0:	108003cc 	andi	r2,r2,15
 d027be4:	1085883a 	add	r2,r2,r2
 d027be8:	1085883a 	add	r2,r2,r2
 d027bec:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 d027bf0:	e0bffd17 	ldw	r2,-12(fp)
 d027bf4:	10800550 	cmplti	r2,r2,21
 d027bf8:	1000251e 	bne	r2,zero,d027c90 <np_stripoptions+0xd4>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 d027bfc:	e0bffd17 	ldw	r2,-12(fp)
 d027c00:	10bffb04 	addi	r2,r2,-20
 d027c04:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 d027c08:	e0bffe17 	ldw	r2,-8(fp)
 d027c0c:	10c0008b 	ldhu	r3,2(r2)
 d027c10:	e0bffd17 	ldw	r2,-12(fp)
 d027c14:	1885c83a 	sub	r2,r3,r2
 d027c18:	1007883a 	mov	r3,r2
 d027c1c:	e0bffe17 	ldw	r2,-8(fp)
 d027c20:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 d027c24:	e0bffe17 	ldw	r2,-8(fp)
 d027c28:	10800003 	ldbu	r2,0(r2)
 d027c2c:	1007883a 	mov	r3,r2
 d027c30:	00bffc04 	movi	r2,-16
 d027c34:	1884703a 	and	r2,r3,r2
 d027c38:	10800154 	ori	r2,r2,5
 d027c3c:	1007883a 	mov	r3,r2
 d027c40:	e0bffe17 	ldw	r2,-8(fp)
 d027c44:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 d027c48:	e0fffe17 	ldw	r3,-8(fp)
 d027c4c:	e0bffd17 	ldw	r2,-12(fp)
 d027c50:	1889883a 	add	r4,r3,r2
 d027c54:	e17ffe17 	ldw	r5,-8(fp)
 d027c58:	01800504 	movi	r6,20
 d027c5c:	d0026a80 	call	d0026a8 <memmove>
   m->m_len -= ihlen;
 d027c60:	e0bfff17 	ldw	r2,-4(fp)
 d027c64:	10c00217 	ldw	r3,8(r2)
 d027c68:	e0bffd17 	ldw	r2,-12(fp)
 d027c6c:	1887c83a 	sub	r3,r3,r2
 d027c70:	e0bfff17 	ldw	r2,-4(fp)
 d027c74:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 d027c78:	e0bfff17 	ldw	r2,-4(fp)
 d027c7c:	10c00317 	ldw	r3,12(r2)
 d027c80:	e0bffd17 	ldw	r2,-12(fp)
 d027c84:	1887883a 	add	r3,r3,r2
 d027c88:	e0bfff17 	ldw	r2,-4(fp)
 d027c8c:	10c00315 	stw	r3,12(r2)
}
 d027c90:	e037883a 	mov	sp,fp
 d027c94:	dfc00117 	ldw	ra,4(sp)
 d027c98:	df000017 	ldw	fp,0(sp)
 d027c9c:	dec00204 	addi	sp,sp,8
 d027ca0:	f800283a 	ret

0d027ca4 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 d027ca4:	defff304 	addi	sp,sp,-52
 d027ca8:	dfc00c15 	stw	ra,48(sp)
 d027cac:	df000b15 	stw	fp,44(sp)
 d027cb0:	df000b04 	addi	fp,sp,44
 d027cb4:	e13ffe15 	stw	r4,-8(fp)
 d027cb8:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 d027cbc:	e0bfff17 	ldw	r2,-4(fp)
 d027cc0:	10800617 	ldw	r2,24(r2)
 d027cc4:	1004d63a 	srli	r2,r2,24
 d027cc8:	10c03fcc 	andi	r3,r2,255
 d027ccc:	e0bfff17 	ldw	r2,-4(fp)
 d027cd0:	10800617 	ldw	r2,24(r2)
 d027cd4:	1004d23a 	srli	r2,r2,8
 d027cd8:	10bfc00c 	andi	r2,r2,65280
 d027cdc:	1886b03a 	or	r3,r3,r2
 d027ce0:	e0bfff17 	ldw	r2,-4(fp)
 d027ce4:	10800617 	ldw	r2,24(r2)
 d027ce8:	10bfc00c 	andi	r2,r2,65280
 d027cec:	1004923a 	slli	r2,r2,8
 d027cf0:	1886b03a 	or	r3,r3,r2
 d027cf4:	e0bfff17 	ldw	r2,-4(fp)
 d027cf8:	10800617 	ldw	r2,24(r2)
 d027cfc:	10803fcc 	andi	r2,r2,255
 d027d00:	1004963a 	slli	r2,r2,24
 d027d04:	1884b03a 	or	r2,r3,r2
 d027d08:	e0bffc15 	stw	r2,-16(fp)
   lhost = htonl(pdp->dip.ip_src);
 d027d0c:	e0bfff17 	ldw	r2,-4(fp)
 d027d10:	10800517 	ldw	r2,20(r2)
 d027d14:	1004d63a 	srli	r2,r2,24
 d027d18:	10c03fcc 	andi	r3,r2,255
 d027d1c:	e0bfff17 	ldw	r2,-4(fp)
 d027d20:	10800517 	ldw	r2,20(r2)
 d027d24:	1004d23a 	srli	r2,r2,8
 d027d28:	10bfc00c 	andi	r2,r2,65280
 d027d2c:	1886b03a 	or	r3,r3,r2
 d027d30:	e0bfff17 	ldw	r2,-4(fp)
 d027d34:	10800517 	ldw	r2,20(r2)
 d027d38:	10bfc00c 	andi	r2,r2,65280
 d027d3c:	1004923a 	slli	r2,r2,8
 d027d40:	1886b03a 	or	r3,r3,r2
 d027d44:	e0bfff17 	ldw	r2,-4(fp)
 d027d48:	10800517 	ldw	r2,20(r2)
 d027d4c:	10803fcc 	andi	r2,r2,255
 d027d50:	1004963a 	slli	r2,r2,24
 d027d54:	1884b03a 	or	r2,r3,r2
 d027d58:	e0bffd15 	stw	r2,-12(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 d027d5c:	e0bfff17 	ldw	r2,-4(fp)
 d027d60:	10800704 	addi	r2,r2,28
 d027d64:	1080000b 	ldhu	r2,0(r2)
 d027d68:	10bfffcc 	andi	r2,r2,65535
 d027d6c:	1004d23a 	srli	r2,r2,8
 d027d70:	10803fcc 	andi	r2,r2,255
 d027d74:	1009883a 	mov	r4,r2
 d027d78:	e0bfff17 	ldw	r2,-4(fp)
 d027d7c:	10800704 	addi	r2,r2,28
 d027d80:	1080000b 	ldhu	r2,0(r2)
 d027d84:	10bfffcc 	andi	r2,r2,65535
 d027d88:	1004923a 	slli	r2,r2,8
 d027d8c:	1007883a 	mov	r3,r2
 d027d90:	00bfc004 	movi	r2,-256
 d027d94:	1884703a 	and	r2,r3,r2
 d027d98:	2084b03a 	or	r2,r4,r2
 d027d9c:	e0bffb0d 	sth	r2,-20(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 d027da0:	e0bfff17 	ldw	r2,-4(fp)
 d027da4:	10800704 	addi	r2,r2,28
 d027da8:	10800084 	addi	r2,r2,2
 d027dac:	1080000b 	ldhu	r2,0(r2)
 d027db0:	10bfffcc 	andi	r2,r2,65535
 d027db4:	1004d23a 	srli	r2,r2,8
 d027db8:	10803fcc 	andi	r2,r2,255
 d027dbc:	1009883a 	mov	r4,r2
 d027dc0:	e0bfff17 	ldw	r2,-4(fp)
 d027dc4:	10800704 	addi	r2,r2,28
 d027dc8:	10800084 	addi	r2,r2,2
 d027dcc:	1080000b 	ldhu	r2,0(r2)
 d027dd0:	10bfffcc 	andi	r2,r2,65535
 d027dd4:	1004923a 	slli	r2,r2,8
 d027dd8:	1007883a 	mov	r3,r2
 d027ddc:	00bfc004 	movi	r2,-256
 d027de0:	1884703a 	and	r2,r3,r2
 d027de4:	2084b03a 	or	r2,r4,r2
 d027de8:	e0bffb8d 	sth	r2,-18(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 d027dec:	e0bfff17 	ldw	r2,-4(fp)
 d027df0:	10800043 	ldbu	r2,1(r2)
 d027df4:	10803fcc 	andi	r2,r2,255
 d027df8:	1080201c 	xori	r2,r2,128
 d027dfc:	10bfe004 	addi	r2,r2,-128
 d027e00:	10800120 	cmpeqi	r2,r2,4
 d027e04:	1000721e 	bne	r2,zero,d027fd0 <so_icmpdu+0x32c>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 d027e08:	e0bfff17 	ldw	r2,-4(fp)
 d027e0c:	10800443 	ldbu	r2,17(r2)
 d027e10:	10803fcc 	andi	r2,r2,255
 d027e14:	10800198 	cmpnei	r2,r2,6
 d027e18:	1000241e 	bne	r2,zero,d027eac <so_icmpdu+0x208>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 d027e1c:	e1bffb8b 	ldhu	r6,-18(fp)
 d027e20:	e0bffb0b 	ldhu	r2,-20(fp)
 d027e24:	d8800015 	stw	r2,0(sp)
 d027e28:	00800044 	movi	r2,1
 d027e2c:	d8800115 	stw	r2,4(sp)
 d027e30:	010341b4 	movhi	r4,3334
 d027e34:	21047f04 	addi	r4,r4,4604
 d027e38:	e17ffc17 	ldw	r5,-16(fp)
 d027e3c:	e1fffd17 	ldw	r7,-12(fp)
 d027e40:	d0487d40 	call	d0487d4 <in_pcblookup>
 d027e44:	e0bffa15 	stw	r2,-24(fp)
      if (inp == 0)
 d027e48:	e0bffa17 	ldw	r2,-24(fp)
 d027e4c:	1005003a 	cmpeq	r2,r2,zero
 d027e50:	10005f1e 	bne	r2,zero,d027fd0 <so_icmpdu+0x32c>
         goto done;
      so = inp->inp_socket;
 d027e54:	e0bffa17 	ldw	r2,-24(fp)
 d027e58:	10800817 	ldw	r2,32(r2)
 d027e5c:	e0bff915 	stw	r2,-28(fp)
      if (so == 0)
 d027e60:	e0bff917 	ldw	r2,-28(fp)
 d027e64:	1005003a 	cmpeq	r2,r2,zero
 d027e68:	1000591e 	bne	r2,zero,d027fd0 <so_icmpdu+0x32c>
         goto done;
      tp = intotcpcb(inp);
 d027e6c:	e0bffa17 	ldw	r2,-24(fp)
 d027e70:	10800917 	ldw	r2,36(r2)
 d027e74:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 d027e78:	e0bff817 	ldw	r2,-32(fp)
 d027e7c:	1005003a 	cmpeq	r2,r2,zero
 d027e80:	1000061e 	bne	r2,zero,d027e9c <so_icmpdu+0x1f8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 d027e84:	e0bff817 	ldw	r2,-32(fp)
 d027e88:	10800217 	ldw	r2,8(r2)
 d027e8c:	10800090 	cmplti	r2,r2,2
 d027e90:	10004f1e 	bne	r2,zero,d027fd0 <so_icmpdu+0x32c>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 d027e94:	e13ff817 	ldw	r4,-32(fp)
 d027e98:	d032d740 	call	d032d74 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 d027e9c:	e0fff917 	ldw	r3,-28(fp)
 d027ea0:	00801bc4 	movi	r2,111
 d027ea4:	18800615 	stw	r2,24(r3)
 d027ea8:	00004906 	br	d027fd0 <so_icmpdu+0x32c>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 d027eac:	e0bfff17 	ldw	r2,-4(fp)
 d027eb0:	10800443 	ldbu	r2,17(r2)
 d027eb4:	10803fcc 	andi	r2,r2,255
 d027eb8:	10800458 	cmpnei	r2,r2,17
 d027ebc:	1000441e 	bne	r2,zero,d027fd0 <so_icmpdu+0x32c>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d027ec0:	00834174 	movhi	r2,3333
 d027ec4:	109b3904 	addi	r2,r2,27876
 d027ec8:	10800017 	ldw	r2,0(r2)
 d027ecc:	e0bff715 	stw	r2,-36(fp)
 d027ed0:	00002406 	br	d027f64 <so_icmpdu+0x2c0>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 d027ed4:	e0bff717 	ldw	r2,-36(fp)
 d027ed8:	1080020b 	ldhu	r2,8(r2)
 d027edc:	10ffffcc 	andi	r3,r2,65535
 d027ee0:	e0bffb8b 	ldhu	r2,-18(fp)
 d027ee4:	18800526 	beq	r3,r2,d027efc <so_icmpdu+0x258>
 d027ee8:	e0bff717 	ldw	r2,-36(fp)
 d027eec:	1080020b 	ldhu	r2,8(r2)
 d027ef0:	10bfffcc 	andi	r2,r2,65535
 d027ef4:	1004c03a 	cmpne	r2,r2,zero
 d027ef8:	1000171e 	bne	r2,zero,d027f58 <so_icmpdu+0x2b4>
 d027efc:	e0bff717 	ldw	r2,-36(fp)
 d027f00:	11000417 	ldw	r4,16(r2)
 d027f04:	e0bffc17 	ldw	r2,-16(fp)
 d027f08:	1004d63a 	srli	r2,r2,24
 d027f0c:	10c03fcc 	andi	r3,r2,255
 d027f10:	e0bffc17 	ldw	r2,-16(fp)
 d027f14:	1004d23a 	srli	r2,r2,8
 d027f18:	10bfc00c 	andi	r2,r2,65280
 d027f1c:	1886b03a 	or	r3,r3,r2
 d027f20:	e0bffc17 	ldw	r2,-16(fp)
 d027f24:	10bfc00c 	andi	r2,r2,65280
 d027f28:	1004923a 	slli	r2,r2,8
 d027f2c:	1886b03a 	or	r3,r3,r2
 d027f30:	e0bffc17 	ldw	r2,-16(fp)
 d027f34:	10803fcc 	andi	r2,r2,255
 d027f38:	1004963a 	slli	r2,r2,24
 d027f3c:	1884b03a 	or	r2,r3,r2
 d027f40:	2080051e 	bne	r4,r2,d027f58 <so_icmpdu+0x2b4>
 d027f44:	e0bff717 	ldw	r2,-36(fp)
 d027f48:	1080018b 	ldhu	r2,6(r2)
 d027f4c:	10ffffcc 	andi	r3,r2,65535
 d027f50:	e0bffb0b 	ldhu	r2,-20(fp)
 d027f54:	18800626 	beq	r3,r2,d027f70 <so_icmpdu+0x2cc>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d027f58:	e0bff717 	ldw	r2,-36(fp)
 d027f5c:	10800017 	ldw	r2,0(r2)
 d027f60:	e0bff715 	stw	r2,-36(fp)
 d027f64:	e0bff717 	ldw	r2,-36(fp)
 d027f68:	1004c03a 	cmpne	r2,r2,zero
 d027f6c:	103fd91e 	bne	r2,zero,d027ed4 <so_icmpdu+0x230>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
 d027f70:	e0bff717 	ldw	r2,-36(fp)
 d027f74:	1005003a 	cmpeq	r2,r2,zero
 d027f78:	1000151e 	bne	r2,zero,d027fd0 <so_icmpdu+0x32c>
         goto done;
      so = (struct socket *)tmp->u_data;
 d027f7c:	e0bff717 	ldw	r2,-36(fp)
 d027f80:	10800617 	ldw	r2,24(r2)
 d027f84:	e0bff915 	stw	r2,-28(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 d027f88:	e0bff917 	ldw	r2,-28(fp)
 d027f8c:	10800983 	ldbu	r2,38(r2)
 d027f90:	10803fcc 	andi	r2,r2,255
 d027f94:	1080201c 	xori	r2,r2,128
 d027f98:	10bfe004 	addi	r2,r2,-128
 d027f9c:	10800098 	cmpnei	r2,r2,2
 d027fa0:	10000b1e 	bne	r2,zero,d027fd0 <so_icmpdu+0x32c>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 d027fa4:	e0fff917 	ldw	r3,-28(fp)
 d027fa8:	00801bc4 	movi	r2,111
 d027fac:	18800615 	stw	r2,24(r3)
      /* do a select() notify on socket here */
      sorwakeup(so);
 d027fb0:	e0bff917 	ldw	r2,-28(fp)
 d027fb4:	11400a04 	addi	r5,r2,40
 d027fb8:	e13ff917 	ldw	r4,-28(fp)
 d027fbc:	d02cdfc0 	call	d02cdfc <sbwakeup>
      sowwakeup(so);
 d027fc0:	e0bff917 	ldw	r2,-28(fp)
 d027fc4:	11401204 	addi	r5,r2,72
 d027fc8:	e13ff917 	ldw	r4,-28(fp)
 d027fcc:	d02cdfc0 	call	d02cdfc <sbwakeup>
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d027fd0:	01000084 	movi	r4,2
 d027fd4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 d027fd8:	e13ffe17 	ldw	r4,-8(fp)
 d027fdc:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d027fe0:	01000084 	movi	r4,2
 d027fe4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return;
}
 d027fe8:	e037883a 	mov	sp,fp
 d027fec:	dfc00117 	ldw	ra,4(sp)
 d027ff0:	df000017 	ldw	fp,0(sp)
 d027ff4:	dec00204 	addi	sp,sp,8
 d027ff8:	f800283a 	ret

0d027ffc <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 d027ffc:	defffe04 	addi	sp,sp,-8
 d028000:	dfc00115 	stw	ra,4(sp)
 d028004:	df000015 	stw	fp,0(sp)
 d028008:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 d02800c:	d0a92b17 	ldw	r2,-23380(gp)
 d028010:	1004c03a 	cmpne	r2,r2,zero
 d028014:	1000151e 	bne	r2,zero,d02806c <tcp_tick+0x70>
      return;
   in_tcptick++;
 d028018:	d0a92b17 	ldw	r2,-23380(gp)
 d02801c:	10800044 	addi	r2,r2,1
 d028020:	d0a92b15 	stw	r2,-23380(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 d028024:	0009883a 	mov	r4,zero
 d028028:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 d02802c:	00834174 	movhi	r2,3333
 d028030:	109b4504 	addi	r2,r2,27924
 d028034:	10c00017 	ldw	r3,0(r2)
 d028038:	d0a92a17 	ldw	r2,-23384(gp)
 d02803c:	18800636 	bltu	r3,r2,d028058 <tcp_tick+0x5c>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 d028040:	d032fa00 	call	d032fa0 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 d028044:	00834174 	movhi	r2,3333
 d028048:	109b4504 	addi	r2,r2,27924
 d02804c:	10800017 	ldw	r2,0(r2)
 d028050:	10800c84 	addi	r2,r2,50
 d028054:	d0a92a15 	stw	r2,-23384(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 d028058:	0009883a 	mov	r4,zero
 d02805c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 d028060:	d0a92b17 	ldw	r2,-23380(gp)
 d028064:	10bfffc4 	addi	r2,r2,-1
 d028068:	d0a92b15 	stw	r2,-23380(gp)
}
 d02806c:	e037883a 	mov	sp,fp
 d028070:	dfc00117 	ldw	ra,4(sp)
 d028074:	df000017 	ldw	fp,0(sp)
 d028078:	dec00204 	addi	sp,sp,8
 d02807c:	f800283a 	ret

0d028080 <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 d028080:	defffc04 	addi	sp,sp,-16
 d028084:	df000315 	stw	fp,12(sp)
 d028088:	df000304 	addi	fp,sp,12
 d02808c:	e13ffe15 	stw	r4,-8(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 d028090:	00834174 	movhi	r2,3333
 d028094:	109b6d04 	addi	r2,r2,28084
 d028098:	10800017 	ldw	r2,0(r2)
 d02809c:	e0bffd15 	stw	r2,-12(fp)
 d0280a0:	00000a06 	br	d0280cc <rawip_lookup+0x4c>
      if (tmp->ipr_data == (void*)so)
 d0280a4:	e0bffd17 	ldw	r2,-12(fp)
 d0280a8:	10c00417 	ldw	r3,16(r2)
 d0280ac:	e0bffe17 	ldw	r2,-8(fp)
 d0280b0:	1880031e 	bne	r3,r2,d0280c0 <rawip_lookup+0x40>
      return (tmp);
 d0280b4:	e0bffd17 	ldw	r2,-12(fp)
 d0280b8:	e0bfff15 	stw	r2,-4(fp)
 d0280bc:	00000706 	br	d0280dc <rawip_lookup+0x5c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 d0280c0:	e0bffd17 	ldw	r2,-12(fp)
 d0280c4:	10800017 	ldw	r2,0(r2)
 d0280c8:	e0bffd15 	stw	r2,-12(fp)
 d0280cc:	e0bffd17 	ldw	r2,-12(fp)
 d0280d0:	1004c03a 	cmpne	r2,r2,zero
 d0280d4:	103ff31e 	bne	r2,zero,d0280a4 <rawip_lookup+0x24>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 d0280d8:	e03fff15 	stw	zero,-4(fp)
 d0280dc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0280e0:	e037883a 	mov	sp,fp
 d0280e4:	df000017 	ldw	fp,0(sp)
 d0280e8:	dec00104 	addi	sp,sp,4
 d0280ec:	f800283a 	ret

0d0280f0 <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 d0280f0:	defff404 	addi	sp,sp,-48
 d0280f4:	dfc00b15 	stw	ra,44(sp)
 d0280f8:	df000a15 	stw	fp,40(sp)
 d0280fc:	df000a04 	addi	fp,sp,40
 d028100:	e13ffd15 	stw	r4,-12(fp)
 d028104:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 d028108:	e0bffe17 	ldw	r2,-8(fp)
 d02810c:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 d028110:	0009883a 	mov	r4,zero
 d028114:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 d028118:	e0bff717 	ldw	r2,-36(fp)
 d02811c:	10c00a17 	ldw	r3,40(r2)
 d028120:	e0bffd17 	ldw	r2,-12(fp)
 d028124:	10800417 	ldw	r2,16(r2)
 d028128:	1887883a 	add	r3,r3,r2
 d02812c:	e0bff717 	ldw	r2,-36(fp)
 d028130:	10800b17 	ldw	r2,44(r2)
 d028134:	18800536 	bltu	r3,r2,d02814c <rawip_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d028138:	0009883a 	mov	r4,zero
 d02813c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d028140:	00801a44 	movi	r2,105
 d028144:	e0bfff15 	stw	r2,-4(fp)
 d028148:	00005806 	br	d0282ac <rawip_soinput+0x1bc>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 d02814c:	01000044 	movi	r4,1
 d028150:	000b883a 	mov	r5,zero
 d028154:	d0268740 	call	d026874 <m_getnbuf>
 d028158:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 d02815c:	e0bff817 	ldw	r2,-32(fp)
 d028160:	1004c03a 	cmpne	r2,r2,zero
 d028164:	1000051e 	bne	r2,zero,d02817c <rawip_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d028168:	0009883a 	mov	r4,zero
 d02816c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d028170:	00801a44 	movi	r2,105
 d028174:	e0bfff15 	stw	r2,-4(fp)
 d028178:	00004c06 	br	d0282ac <rawip_soinput+0x1bc>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 d02817c:	e0fff817 	ldw	r3,-32(fp)
 d028180:	e0bffd17 	ldw	r2,-12(fp)
 d028184:	18800115 	stw	r2,4(r3)
   m_in->m_base = pkt->nb_buff;
 d028188:	e0bffd17 	ldw	r2,-12(fp)
 d02818c:	10c00117 	ldw	r3,4(r2)
 d028190:	e0bff817 	ldw	r2,-32(fp)
 d028194:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 d028198:	e0bffd17 	ldw	r2,-12(fp)
 d02819c:	10c00217 	ldw	r3,8(r2)
 d0281a0:	e0bff817 	ldw	r2,-32(fp)
 d0281a4:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 d0281a8:	e0bffd17 	ldw	r2,-12(fp)
 d0281ac:	10c00317 	ldw	r3,12(r2)
 d0281b0:	e0bff817 	ldw	r2,-32(fp)
 d0281b4:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 d0281b8:	e0bffd17 	ldw	r2,-12(fp)
 d0281bc:	10c00417 	ldw	r3,16(r2)
 d0281c0:	e0bff817 	ldw	r2,-32(fp)
 d0281c4:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 d0281c8:	e0bff717 	ldw	r2,-36(fp)
 d0281cc:	10800417 	ldw	r2,16(r2)
 d0281d0:	1088000c 	andi	r2,r2,8192
 d0281d4:	1004c03a 	cmpne	r2,r2,zero
 d0281d8:	1000141e 	bne	r2,zero,d02822c <rawip_soinput+0x13c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 d0281dc:	e0bffd17 	ldw	r2,-12(fp)
 d0281e0:	10800317 	ldw	r2,12(r2)
 d0281e4:	10800003 	ldbu	r2,0(r2)
 d0281e8:	10803fcc 	andi	r2,r2,255
 d0281ec:	108003cc 	andi	r2,r2,15
 d0281f0:	1085883a 	add	r2,r2,r2
 d0281f4:	1085883a 	add	r2,r2,r2
 d0281f8:	e0bff615 	stw	r2,-40(fp)
      m_in->m_data += ihl;
 d0281fc:	e0bff817 	ldw	r2,-32(fp)
 d028200:	10c00317 	ldw	r3,12(r2)
 d028204:	e0bff617 	ldw	r2,-40(fp)
 d028208:	1887883a 	add	r3,r3,r2
 d02820c:	e0bff817 	ldw	r2,-32(fp)
 d028210:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 d028214:	e0bff817 	ldw	r2,-32(fp)
 d028218:	10c00217 	ldw	r3,8(r2)
 d02821c:	e0bff617 	ldw	r2,-40(fp)
 d028220:	1887c83a 	sub	r3,r3,r2
 d028224:	e0bff817 	ldw	r2,-32(fp)
 d028228:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 d02822c:	e0bffd17 	ldw	r2,-12(fp)
 d028230:	10800717 	ldw	r2,28(r2)
 d028234:	e0bffa15 	stw	r2,-24(fp)
   sin.sin_port = 0;
 d028238:	e03ff98d 	sth	zero,-26(fp)
   sin.sin_family = AF_INET;
 d02823c:	00800084 	movi	r2,2
 d028240:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 d028244:	e0bff717 	ldw	r2,-36(fp)
 d028248:	11000a04 	addi	r4,r2,40
 d02824c:	e17ff904 	addi	r5,fp,-28
 d028250:	e1bff817 	ldw	r6,-32(fp)
 d028254:	d02d1480 	call	d02d148 <sbappendaddr>
 d028258:	1004c03a 	cmpne	r2,r2,zero
 d02825c:	1000091e 	bne	r2,zero,d028284 <rawip_soinput+0x194>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 d028260:	e0bff817 	ldw	r2,-32(fp)
 d028264:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 d028268:	e13ff817 	ldw	r4,-32(fp)
 d02826c:	d026a1c0 	call	d026a1c <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d028270:	0009883a 	mov	r4,zero
 d028274:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d028278:	00801a44 	movi	r2,105
 d02827c:	e0bfff15 	stw	r2,-4(fp)
 d028280:	00000a06 	br	d0282ac <rawip_soinput+0x1bc>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 d028284:	e0bff717 	ldw	r2,-36(fp)
 d028288:	11000a04 	addi	r4,r2,40
 d02828c:	d02147c0 	call	d02147c <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 d028290:	e0bff717 	ldw	r2,-36(fp)
 d028294:	11400a04 	addi	r5,r2,40
 d028298:	e13ff717 	ldw	r4,-36(fp)
 d02829c:	d02cdfc0 	call	d02cdfc <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d0282a0:	0009883a 	mov	r4,zero
 d0282a4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return 0;
 d0282a8:	e03fff15 	stw	zero,-4(fp)
 d0282ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d0282b0:	e037883a 	mov	sp,fp
 d0282b4:	dfc00117 	ldw	ra,4(sp)
 d0282b8:	df000017 	ldw	fp,0(sp)
 d0282bc:	dec00204 	addi	sp,sp,8
 d0282c0:	f800283a 	ret

0d0282c4 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 d0282c4:	deffee04 	addi	sp,sp,-72
 d0282c8:	dfc01115 	stw	ra,68(sp)
 d0282cc:	df001015 	stw	fp,64(sp)
 d0282d0:	dc000f15 	stw	r16,60(sp)
 d0282d4:	df000f04 	addi	fp,sp,60
 d0282d8:	e13ffc15 	stw	r4,-16(fp)
 d0282dc:	e17ffd15 	stw	r5,-12(fp)
 d0282e0:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 d0282e4:	e0bffc17 	ldw	r2,-16(fp)
 d0282e8:	10800717 	ldw	r2,28(r2)
 d0282ec:	e0bff315 	stw	r2,-52(fp)

   switch (req) 
 d0282f0:	e0bff317 	ldw	r2,-52(fp)
 d0282f4:	10800468 	cmpgeui	r2,r2,17
 d0282f8:	1001e31e 	bne	r2,zero,d028a88 <rawip_usrreq+0x7c4>
 d0282fc:	e0bff317 	ldw	r2,-52(fp)
 d028300:	1085883a 	add	r2,r2,r2
 d028304:	1087883a 	add	r3,r2,r2
 d028308:	008340f4 	movhi	r2,3331
 d02830c:	10a0c704 	addi	r2,r2,-31972
 d028310:	1885883a 	add	r2,r3,r2
 d028314:	10800017 	ldw	r2,0(r2)
 d028318:	1000683a 	jmp	r2
 d02831c:	0d028360 	cmpeqi	r20,at,2573
 d028320:	0d0283e8 	cmpgeui	r20,at,2575
 d028324:	0d02842c 	andhi	r20,at,2576
 d028328:	0d028a88 	cmpgei	r20,at,2602
 d02832c:	0d02842c 	andhi	r20,at,2576
 d028330:	0d028a88 	cmpgei	r20,at,2602
 d028334:	0d028a7c 	xorhi	r20,at,2601
 d028338:	0d028a88 	cmpgei	r20,at,2602
 d02833c:	0d028a7c 	xorhi	r20,at,2601
 d028340:	0d0285e0 	cmpeqi	r20,at,2583
 d028344:	0d028a88 	cmpgei	r20,at,2602
 d028348:	0d028a88 	cmpgei	r20,at,2602
 d02834c:	0d028a88 	cmpgei	r20,at,2602
 d028350:	0d028a88 	cmpgei	r20,at,2602
 d028354:	0d028a88 	cmpgei	r20,at,2602
 d028358:	0d0289d0 	cmplti	r20,at,2599
 d02835c:	0d0289d0 	cmplti	r20,at,2599
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 d028360:	e0bffc17 	ldw	r2,-16(fp)
 d028364:	10800417 	ldw	r2,16(r2)
 d028368:	1108000c 	andi	r4,r2,8192
 d02836c:	d043fac0 	call	d043fac <ip_raw_maxalloc>
 d028370:	1007883a 	mov	r3,r2
 d028374:	e0bffc17 	ldw	r2,-16(fp)
 d028378:	10c01315 	stw	r3,76(r2)
 d02837c:	e0bffc17 	ldw	r2,-16(fp)
 d028380:	10c01317 	ldw	r3,76(r2)
 d028384:	e0bffc17 	ldw	r2,-16(fp)
 d028388:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 d02838c:	e0bffe17 	ldw	r2,-8(fp)
 d028390:	e0bff505 	stb	r2,-44(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d028394:	0009883a 	mov	r4,zero
 d028398:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 d02839c:	e13ff503 	ldbu	r4,-44(fp)
 d0283a0:	e0bffc17 	ldw	r2,-16(fp)
 d0283a4:	d8800015 	stw	r2,0(sp)
 d0283a8:	000b883a 	mov	r5,zero
 d0283ac:	000d883a 	mov	r6,zero
 d0283b0:	01c340f4 	movhi	r7,3331
 d0283b4:	39e03c04 	addi	r7,r7,-32528
 d0283b8:	d043ab80 	call	d043ab8 <ip_raw_open>
 d0283bc:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 d0283c0:	0009883a 	mov	r4,zero
 d0283c4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      if (!ep)
 d0283c8:	e0bff817 	ldw	r2,-32(fp)
 d0283cc:	1004c03a 	cmpne	r2,r2,zero
 d0283d0:	1000031e 	bne	r2,zero,d0283e0 <rawip_usrreq+0x11c>
         return(EINVAL);
 d0283d4:	00800584 	movi	r2,22
 d0283d8:	e0bfff15 	stw	r2,-4(fp)
 d0283dc:	0001ac06 	br	d028a90 <rawip_usrreq+0x7cc>
      return 0;
 d0283e0:	e03fff15 	stw	zero,-4(fp)
 d0283e4:	0001aa06 	br	d028a90 <rawip_usrreq+0x7cc>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 d0283e8:	e13ffc17 	ldw	r4,-16(fp)
 d0283ec:	d0280800 	call	d028080 <rawip_lookup>
 d0283f0:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d0283f4:	e0bff817 	ldw	r2,-32(fp)
 d0283f8:	1004c03a 	cmpne	r2,r2,zero
 d0283fc:	1000031e 	bne	r2,zero,d02840c <rawip_usrreq+0x148>
         return(EINVAL);
 d028400:	00800584 	movi	r2,22
 d028404:	e0bfff15 	stw	r2,-4(fp)
 d028408:	0001a106 	br	d028a90 <rawip_usrreq+0x7cc>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02840c:	0009883a 	mov	r4,zero
 d028410:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 d028414:	e13ff817 	ldw	r4,-32(fp)
 d028418:	d043ba80 	call	d043ba8 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 d02841c:	0009883a 	mov	r4,zero
 d028420:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      return 0;
 d028424:	e03fff15 	stw	zero,-4(fp)
 d028428:	00019906 	br	d028a90 <rawip_usrreq+0x7cc>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 d02842c:	e0bffe17 	ldw	r2,-8(fp)
 d028430:	1004c03a 	cmpne	r2,r2,zero
 d028434:	1000031e 	bne	r2,zero,d028444 <rawip_usrreq+0x180>
         return(EINVAL);
 d028438:	00800584 	movi	r2,22
 d02843c:	e0bfff15 	stw	r2,-4(fp)
 d028440:	00019306 	br	d028a90 <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 d028444:	e0bffe17 	ldw	r2,-8(fp)
 d028448:	10800317 	ldw	r2,12(r2)
 d02844c:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 d028450:	e0bff917 	ldw	r2,-28(fp)
 d028454:	1004c03a 	cmpne	r2,r2,zero
 d028458:	1000031e 	bne	r2,zero,d028468 <rawip_usrreq+0x1a4>
         return(EINVAL);
 d02845c:	00800584 	movi	r2,22
 d028460:	e0bfff15 	stw	r2,-4(fp)
 d028464:	00018a06 	br	d028a90 <rawip_usrreq+0x7cc>
      if (nam->m_len != sizeof (*sin))
 d028468:	e0bffe17 	ldw	r2,-8(fp)
 d02846c:	10800217 	ldw	r2,8(r2)
 d028470:	10800420 	cmpeqi	r2,r2,16
 d028474:	1000031e 	bne	r2,zero,d028484 <rawip_usrreq+0x1c0>
         return(EINVAL);
 d028478:	00800584 	movi	r2,22
 d02847c:	e0bfff15 	stw	r2,-4(fp)
 d028480:	00018306 	br	d028a90 <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 d028484:	e13ffc17 	ldw	r4,-16(fp)
 d028488:	d0280800 	call	d028080 <rawip_lookup>
 d02848c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d028490:	e0bff817 	ldw	r2,-32(fp)
 d028494:	1004c03a 	cmpne	r2,r2,zero
 d028498:	1000031e 	bne	r2,zero,d0284a8 <rawip_usrreq+0x1e4>
         return(EINVAL);
 d02849c:	00800584 	movi	r2,22
 d0284a0:	e0bfff15 	stw	r2,-4(fp)
 d0284a4:	00017a06 	br	d028a90 <rawip_usrreq+0x7cc>
      if (req == PRU_BIND)
 d0284a8:	e0bff317 	ldw	r2,-52(fp)
 d0284ac:	10800098 	cmpnei	r2,r2,2
 d0284b0:	1000221e 	bne	r2,zero,d02853c <rawip_usrreq+0x278>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 d0284b4:	e0bff917 	ldw	r2,-28(fp)
 d0284b8:	10800117 	ldw	r2,4(r2)
 d0284bc:	1004c03a 	cmpne	r2,r2,zero
 d0284c0:	1000021e 	bne	r2,zero,d0284cc <rawip_usrreq+0x208>
         {
            lhost = 0L;
 d0284c4:	e03ff615 	stw	zero,-40(fp)
 d0284c8:	00001806 	br	d02852c <rawip_usrreq+0x268>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 d0284cc:	e0bff917 	ldw	r2,-28(fp)
 d0284d0:	10800117 	ldw	r2,4(r2)
 d0284d4:	e0bff615 	stw	r2,-40(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0284d8:	008341b4 	movhi	r2,3334
 d0284dc:	10856304 	addi	r2,r2,5516
 d0284e0:	10800017 	ldw	r2,0(r2)
 d0284e4:	e0bff215 	stw	r2,-56(fp)
 d0284e8:	00000706 	br	d028508 <rawip_usrreq+0x244>
               if (ifp->n_ipaddr == lhost)
 d0284ec:	e0bff217 	ldw	r2,-56(fp)
 d0284f0:	10c00a17 	ldw	r3,40(r2)
 d0284f4:	e0bff617 	ldw	r2,-40(fp)
 d0284f8:	18800626 	beq	r3,r2,d028514 <rawip_usrreq+0x250>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0284fc:	e0bff217 	ldw	r2,-56(fp)
 d028500:	10800017 	ldw	r2,0(r2)
 d028504:	e0bff215 	stw	r2,-56(fp)
 d028508:	e0bff217 	ldw	r2,-56(fp)
 d02850c:	1004c03a 	cmpne	r2,r2,zero
 d028510:	103ff61e 	bne	r2,zero,d0284ec <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
            if (ifp == NULL)
 d028514:	e0bff217 	ldw	r2,-56(fp)
 d028518:	1004c03a 	cmpne	r2,r2,zero
 d02851c:	1000031e 	bne	r2,zero,d02852c <rawip_usrreq+0x268>
               return(EADDRNOTAVAIL);
 d028520:	00801f44 	movi	r2,125
 d028524:	e0bfff15 	stw	r2,-4(fp)
 d028528:	00015906 	br	d028a90 <rawip_usrreq+0x7cc>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 d02852c:	e0fff817 	ldw	r3,-32(fp)
 d028530:	e0bff617 	ldw	r2,-40(fp)
 d028534:	18800115 	stw	r2,4(r3)
 d028538:	00002706 	br	d0285d8 <rawip_usrreq+0x314>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 d02853c:	e0bff917 	ldw	r2,-28(fp)
 d028540:	10800117 	ldw	r2,4(r2)
 d028544:	1004c03a 	cmpne	r2,r2,zero
 d028548:	1000021e 	bne	r2,zero,d028554 <rawip_usrreq+0x290>
            fhost = 0L;
 d02854c:	e03ff715 	stw	zero,-36(fp)
 d028550:	00000306 	br	d028560 <rawip_usrreq+0x29c>
         else
            fhost = sin->sin_addr.s_addr;
 d028554:	e0bff917 	ldw	r2,-28(fp)
 d028558:	10800117 	ldw	r2,4(r2)
 d02855c:	e0bff715 	stw	r2,-36(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 d028560:	e0fff817 	ldw	r3,-32(fp)
 d028564:	e0bff717 	ldw	r2,-36(fp)
 d028568:	18800215 	stw	r2,8(r3)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 d02856c:	e0bff717 	ldw	r2,-36(fp)
 d028570:	1005003a 	cmpeq	r2,r2,zero
 d028574:	10000e1e 	bne	r2,zero,d0285b0 <rawip_usrreq+0x2ec>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 d028578:	e0bffc17 	ldw	r2,-16(fp)
 d02857c:	10c0088b 	ldhu	r3,34(r2)
 d028580:	00bffcc4 	movi	r2,-13
 d028584:	1884703a 	and	r2,r3,r2
 d028588:	1007883a 	mov	r3,r2
 d02858c:	e0bffc17 	ldw	r2,-16(fp)
 d028590:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 d028594:	e0bffc17 	ldw	r2,-16(fp)
 d028598:	1080088b 	ldhu	r2,34(r2)
 d02859c:	10800094 	ori	r2,r2,2
 d0285a0:	1007883a 	mov	r3,r2
 d0285a4:	e0bffc17 	ldw	r2,-16(fp)
 d0285a8:	10c0088d 	sth	r3,34(r2)
 d0285ac:	00000706 	br	d0285cc <rawip_usrreq+0x308>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 d0285b0:	e0bffc17 	ldw	r2,-16(fp)
 d0285b4:	10c0088b 	ldhu	r3,34(r2)
 d0285b8:	00bfff44 	movi	r2,-3
 d0285bc:	1884703a 	and	r2,r3,r2
 d0285c0:	1007883a 	mov	r3,r2
 d0285c4:	e0bffc17 	ldw	r2,-16(fp)
 d0285c8:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 d0285cc:	e0bffc17 	ldw	r2,-16(fp)
 d0285d0:	11000a04 	addi	r4,r2,40
 d0285d4:	d02d5380 	call	d02d538 <sbflush>
      }
      return 0;
 d0285d8:	e03fff15 	stw	zero,-4(fp)
 d0285dc:	00012c06 	br	d028a90 <rawip_usrreq+0x7cc>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 d0285e0:	e0bffd17 	ldw	r2,-12(fp)
 d0285e4:	1004c03a 	cmpne	r2,r2,zero
 d0285e8:	1000031e 	bne	r2,zero,d0285f8 <rawip_usrreq+0x334>
         return(EINVAL);
 d0285ec:	00800584 	movi	r2,22
 d0285f0:	e0bfff15 	stw	r2,-4(fp)
 d0285f4:	00012606 	br	d028a90 <rawip_usrreq+0x7cc>

      ep = rawip_lookup(so);
 d0285f8:	e13ffc17 	ldw	r4,-16(fp)
 d0285fc:	d0280800 	call	d028080 <rawip_lookup>
 d028600:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d028604:	e0bff817 	ldw	r2,-32(fp)
 d028608:	1004c03a 	cmpne	r2,r2,zero
 d02860c:	1000051e 	bne	r2,zero,d028624 <rawip_usrreq+0x360>
      {
         m_free(m);
 d028610:	e13ffd17 	ldw	r4,-12(fp)
 d028614:	d026a1c0 	call	d026a1c <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 d028618:	00801bc4 	movi	r2,111
 d02861c:	e0bfff15 	stw	r2,-4(fp)
 d028620:	00011b06 	br	d028a90 <rawip_usrreq+0x7cc>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 d028624:	e0bffe17 	ldw	r2,-8(fp)
 d028628:	1004c03a 	cmpne	r2,r2,zero
 d02862c:	10000d1e 	bne	r2,zero,d028664 <rawip_usrreq+0x3a0>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 d028630:	e0bffc17 	ldw	r2,-16(fp)
 d028634:	1080088b 	ldhu	r2,34(r2)
 d028638:	10bfffcc 	andi	r2,r2,65535
 d02863c:	1080008c 	andi	r2,r2,2
 d028640:	1004c03a 	cmpne	r2,r2,zero
 d028644:	1000031e 	bne	r2,zero,d028654 <rawip_usrreq+0x390>
            return (ENOTCONN);
 d028648:	00802004 	movi	r2,128
 d02864c:	e0bfff15 	stw	r2,-4(fp)
 d028650:	00010f06 	br	d028a90 <rawip_usrreq+0x7cc>
         fhost = ep->ipr_faddr;
 d028654:	e0bff817 	ldw	r2,-32(fp)
 d028658:	10800217 	ldw	r2,8(r2)
 d02865c:	e0bff715 	stw	r2,-36(fp)
 d028660:	00001706 	br	d0286c0 <rawip_usrreq+0x3fc>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 d028664:	e0bffc17 	ldw	r2,-16(fp)
 d028668:	1080088b 	ldhu	r2,34(r2)
 d02866c:	10bfffcc 	andi	r2,r2,65535
 d028670:	1080008c 	andi	r2,r2,2
 d028674:	1005003a 	cmpeq	r2,r2,zero
 d028678:	1000031e 	bne	r2,zero,d028688 <rawip_usrreq+0x3c4>
            return (EISCONN);
 d02867c:	00801fc4 	movi	r2,127
 d028680:	e0bfff15 	stw	r2,-4(fp)
 d028684:	00010206 	br	d028a90 <rawip_usrreq+0x7cc>
         if (nam->m_len != sizeof (*sin))
 d028688:	e0bffe17 	ldw	r2,-8(fp)
 d02868c:	10800217 	ldw	r2,8(r2)
 d028690:	10800420 	cmpeqi	r2,r2,16
 d028694:	1000041e 	bne	r2,zero,d0286a8 <rawip_usrreq+0x3e4>
         {
            dtrap();
 d028698:	d025a500 	call	d025a50 <dtrap>
            return (EINVAL);
 d02869c:	00800584 	movi	r2,22
 d0286a0:	e0bfff15 	stw	r2,-4(fp)
 d0286a4:	0000fa06 	br	d028a90 <rawip_usrreq+0x7cc>
         }
         sin = mtod(nam, struct sockaddr_in *);
 d0286a8:	e0bffe17 	ldw	r2,-8(fp)
 d0286ac:	10800317 	ldw	r2,12(r2)
 d0286b0:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 d0286b4:	e0bff917 	ldw	r2,-28(fp)
 d0286b8:	10800117 	ldw	r2,4(r2)
 d0286bc:	e0bff715 	stw	r2,-36(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 d0286c0:	e0bffd17 	ldw	r2,-12(fp)
 d0286c4:	14000217 	ldw	r16,8(r2)
 d0286c8:	e0bffc17 	ldw	r2,-16(fp)
 d0286cc:	10800417 	ldw	r2,16(r2)
 d0286d0:	1108000c 	andi	r4,r2,8192
 d0286d4:	d043fac0 	call	d043fac <ip_raw_maxalloc>
 d0286d8:	1400042e 	bgeu	r2,r16,d0286ec <rawip_usrreq+0x428>
      {
         dtrap(); /* should never happen */
 d0286dc:	d025a500 	call	d025a50 <dtrap>
         return EMSGSIZE;  /* try to recover */
 d0286e0:	00801e84 	movi	r2,122
 d0286e4:	e0bfff15 	stw	r2,-4(fp)
 d0286e8:	0000e906 	br	d028a90 <rawip_usrreq+0x7cc>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 d0286ec:	e0bffd17 	ldw	r2,-12(fp)
 d0286f0:	10800217 	ldw	r2,8(r2)
 d0286f4:	1009883a 	mov	r4,r2
 d0286f8:	e0bffc17 	ldw	r2,-16(fp)
 d0286fc:	10800417 	ldw	r2,16(r2)
 d028700:	1148000c 	andi	r5,r2,8192
 d028704:	d043ea00 	call	d043ea0 <ip_raw_alloc>
 d028708:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 d02870c:	e0bffa17 	ldw	r2,-24(fp)
 d028710:	1004c03a 	cmpne	r2,r2,zero
 d028714:	1000051e 	bne	r2,zero,d02872c <rawip_usrreq+0x468>
      {
         m_free(m);
 d028718:	e13ffd17 	ldw	r4,-12(fp)
 d02871c:	d026a1c0 	call	d026a1c <m_free>
         return ENOBUFS;   /* report buffer shortages */
 d028720:	00801a44 	movi	r2,105
 d028724:	e0bfff15 	stw	r2,-4(fp)
 d028728:	0000d906 	br	d028a90 <rawip_usrreq+0x7cc>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 d02872c:	e0bffa17 	ldw	r2,-24(fp)
 d028730:	10c00317 	ldw	r3,12(r2)
 d028734:	e0bffd17 	ldw	r2,-12(fp)
 d028738:	11400317 	ldw	r5,12(r2)
 d02873c:	e0bffd17 	ldw	r2,-12(fp)
 d028740:	10800217 	ldw	r2,8(r2)
 d028744:	1809883a 	mov	r4,r3
 d028748:	100d883a 	mov	r6,r2
 d02874c:	d0026080 	call	d002608 <memcpy>
      pkt->nb_plen = m->m_len;
 d028750:	e0bffd17 	ldw	r2,-12(fp)
 d028754:	10c00217 	ldw	r3,8(r2)
 d028758:	e0bffa17 	ldw	r2,-24(fp)
 d02875c:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 d028760:	e13ffd17 	ldw	r4,-12(fp)
 d028764:	d026a1c0 	call	d026a1c <m_free>
      pkt->fhost = fhost;
 d028768:	e0fffa17 	ldw	r3,-24(fp)
 d02876c:	e0bff717 	ldw	r2,-36(fp)
 d028770:	18800715 	stw	r2,28(r3)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 d028774:	e0bff717 	ldw	r2,-36(fp)
 d028778:	10bfffd8 	cmpnei	r2,r2,-1
 d02877c:	10004f1e 	bne	r2,zero,d0288bc <rawip_usrreq+0x5f8>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 d028780:	e0bff817 	ldw	r2,-32(fp)
 d028784:	10800117 	ldw	r2,4(r2)
 d028788:	1005003a 	cmpeq	r2,r2,zero
 d02878c:	1000111e 	bne	r2,zero,d0287d4 <rawip_usrreq+0x510>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d028790:	008341b4 	movhi	r2,3334
 d028794:	10856304 	addi	r2,r2,5516
 d028798:	10800017 	ldw	r2,0(r2)
 d02879c:	e0bff215 	stw	r2,-56(fp)
 d0287a0:	00000806 	br	d0287c4 <rawip_usrreq+0x500>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 d0287a4:	e0bff217 	ldw	r2,-56(fp)
 d0287a8:	10c00a17 	ldw	r3,40(r2)
 d0287ac:	e0bff817 	ldw	r2,-32(fp)
 d0287b0:	10800117 	ldw	r2,4(r2)
 d0287b4:	18802126 	beq	r3,r2,d02883c <rawip_usrreq+0x578>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0287b8:	e0bff217 	ldw	r2,-56(fp)
 d0287bc:	10800017 	ldw	r2,0(r2)
 d0287c0:	e0bff215 	stw	r2,-56(fp)
 d0287c4:	e0bff217 	ldw	r2,-56(fp)
 d0287c8:	1004c03a 	cmpne	r2,r2,zero
 d0287cc:	103ff51e 	bne	r2,zero,d0287a4 <rawip_usrreq+0x4e0>
 d0287d0:	00001a06 	br	d02883c <rawip_usrreq+0x578>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0287d4:	008341b4 	movhi	r2,3334
 d0287d8:	10856304 	addi	r2,r2,5516
 d0287dc:	10800017 	ldw	r2,0(r2)
 d0287e0:	e0bff215 	stw	r2,-56(fp)
 d0287e4:	00001206 	br	d028830 <rawip_usrreq+0x56c>
               if ((ifp->n_flags & NF_BCAST) &&
 d0287e8:	e0bff217 	ldw	r2,-56(fp)
 d0287ec:	10802a17 	ldw	r2,168(r2)
 d0287f0:	1080004c 	andi	r2,r2,1
 d0287f4:	10803fcc 	andi	r2,r2,255
 d0287f8:	1005003a 	cmpeq	r2,r2,zero
 d0287fc:	1000091e 	bne	r2,zero,d028824 <rawip_usrreq+0x560>
 d028800:	e0bff217 	ldw	r2,-56(fp)
 d028804:	10802717 	ldw	r2,156(r2)
 d028808:	1005003a 	cmpeq	r2,r2,zero
 d02880c:	1000051e 	bne	r2,zero,d028824 <rawip_usrreq+0x560>
 d028810:	e0bff217 	ldw	r2,-56(fp)
 d028814:	10802717 	ldw	r2,156(r2)
 d028818:	10800617 	ldw	r2,24(r2)
 d02881c:	10800060 	cmpeqi	r2,r2,1
 d028820:	1000061e 	bne	r2,zero,d02883c <rawip_usrreq+0x578>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d028824:	e0bff217 	ldw	r2,-56(fp)
 d028828:	10800017 	ldw	r2,0(r2)
 d02882c:	e0bff215 	stw	r2,-56(fp)
 d028830:	e0bff217 	ldw	r2,-56(fp)
 d028834:	1004c03a 	cmpne	r2,r2,zero
 d028838:	103feb1e 	bne	r2,zero,d0287e8 <rawip_usrreq+0x524>
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
 d02883c:	e0bff217 	ldw	r2,-56(fp)
 d028840:	1004c03a 	cmpne	r2,r2,zero
 d028844:	10001a1e 	bne	r2,zero,d0288b0 <rawip_usrreq+0x5ec>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d028848:	008341b4 	movhi	r2,3334
 d02884c:	10856304 	addi	r2,r2,5516
 d028850:	10800017 	ldw	r2,0(r2)
 d028854:	e0bff215 	stw	r2,-56(fp)
 d028858:	00000c06 	br	d02888c <rawip_usrreq+0x5c8>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 d02885c:	e0bff217 	ldw	r2,-56(fp)
 d028860:	10802717 	ldw	r2,156(r2)
 d028864:	1005003a 	cmpeq	r2,r2,zero
 d028868:	1000051e 	bne	r2,zero,d028880 <rawip_usrreq+0x5bc>
 d02886c:	e0bff217 	ldw	r2,-56(fp)
 d028870:	10802717 	ldw	r2,156(r2)
 d028874:	10800617 	ldw	r2,24(r2)
 d028878:	10800060 	cmpeqi	r2,r2,1
 d02887c:	1000061e 	bne	r2,zero,d028898 <rawip_usrreq+0x5d4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d028880:	e0bff217 	ldw	r2,-56(fp)
 d028884:	10800017 	ldw	r2,0(r2)
 d028888:	e0bff215 	stw	r2,-56(fp)
 d02888c:	e0bff217 	ldw	r2,-56(fp)
 d028890:	1004c03a 	cmpne	r2,r2,zero
 d028894:	103ff11e 	bne	r2,zero,d02885c <rawip_usrreq+0x598>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
            if (ifp == NULL)
 d028898:	e0bff217 	ldw	r2,-56(fp)
 d02889c:	1004c03a 	cmpne	r2,r2,zero
 d0288a0:	1000031e 	bne	r2,zero,d0288b0 <rawip_usrreq+0x5ec>
               return(EADDRNOTAVAIL);
 d0288a4:	00801f44 	movi	r2,125
 d0288a8:	e0bfff15 	stw	r2,-4(fp)
 d0288ac:	00007806 	br	d028a90 <rawip_usrreq+0x7cc>
         }
         pkt->net = ifp;
 d0288b0:	e0fffa17 	ldw	r3,-24(fp)
 d0288b4:	e0bff217 	ldw	r2,-56(fp)
 d0288b8:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 d0288bc:	e0bffc17 	ldw	r2,-16(fp)
 d0288c0:	10800317 	ldw	r2,12(r2)
 d0288c4:	1005003a 	cmpeq	r2,r2,zero
 d0288c8:	1000041e 	bne	r2,zero,d0288dc <rawip_usrreq+0x618>
         pkt->imo = so->inp_moptions;
 d0288cc:	e0bffc17 	ldw	r2,-16(fp)
 d0288d0:	10c00317 	ldw	r3,12(r2)
 d0288d4:	e0bffa17 	ldw	r2,-24(fp)
 d0288d8:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 d0288dc:	e0bffc17 	ldw	r2,-16(fp)
 d0288e0:	10800417 	ldw	r2,16(r2)
 d0288e4:	1088000c 	andi	r2,r2,8192
 d0288e8:	1005003a 	cmpeq	r2,r2,zero
 d0288ec:	1000081e 	bne	r2,zero,d028910 <rawip_usrreq+0x64c>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 d0288f0:	0009883a 	mov	r4,zero
 d0288f4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 d0288f8:	e13ffa17 	ldw	r4,-24(fp)
 d0288fc:	d03f8700 	call	d03f870 <ip_raw_write>
 d028900:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 d028904:	0009883a 	mov	r4,zero
 d028908:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
 d02890c:	00002806 	br	d0289b0 <rawip_usrreq+0x6ec>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 d028910:	e0bffa17 	ldw	r2,-24(fp)
 d028914:	10800317 	ldw	r2,12(r2)
 d028918:	10bffb04 	addi	r2,r2,-20
 d02891c:	e0bff415 	stw	r2,-48(fp)
         if (ep->ipr_laddr)
 d028920:	e0bff817 	ldw	r2,-32(fp)
 d028924:	10800117 	ldw	r2,4(r2)
 d028928:	1005003a 	cmpeq	r2,r2,zero
 d02892c:	1000051e 	bne	r2,zero,d028944 <rawip_usrreq+0x680>
            pip->ip_src = ep->ipr_laddr;
 d028930:	e0bff817 	ldw	r2,-32(fp)
 d028934:	10c00117 	ldw	r3,4(r2)
 d028938:	e0bff417 	ldw	r2,-48(fp)
 d02893c:	10c00315 	stw	r3,12(r2)
 d028940:	00000e06 	br	d02897c <rawip_usrreq+0x6b8>
         else
         {
            if (fhost == 0xffffffff)
 d028944:	e0bff717 	ldw	r2,-36(fp)
 d028948:	10bfffd8 	cmpnei	r2,r2,-1
 d02894c:	1000061e 	bne	r2,zero,d028968 <rawip_usrreq+0x6a4>
               pip->ip_src = pkt->net->n_ipaddr;
 d028950:	e0bffa17 	ldw	r2,-24(fp)
 d028954:	10800617 	ldw	r2,24(r2)
 d028958:	10c00a17 	ldw	r3,40(r2)
 d02895c:	e0bff417 	ldw	r2,-48(fp)
 d028960:	10c00315 	stw	r3,12(r2)
 d028964:	00000506 	br	d02897c <rawip_usrreq+0x6b8>
            else
               pip->ip_src = ip_mymach(fhost);
 d028968:	e13ff717 	ldw	r4,-36(fp)
 d02896c:	d0404040 	call	d040404 <ip_mymach>
 d028970:	1007883a 	mov	r3,r2
 d028974:	e0bff417 	ldw	r2,-48(fp)
 d028978:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 d02897c:	e0fff417 	ldw	r3,-48(fp)
 d028980:	e0bff717 	ldw	r2,-36(fp)
 d028984:	18800415 	stw	r2,16(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 d028988:	0009883a 	mov	r4,zero
 d02898c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 d028990:	e0bff817 	ldw	r2,-32(fp)
 d028994:	10800503 	ldbu	r2,20(r2)
 d028998:	11003fcc 	andi	r4,r2,255
 d02899c:	e17ffa17 	ldw	r5,-24(fp)
 d0289a0:	d03f2780 	call	d03f278 <ip_write>
 d0289a4:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 d0289a8:	0009883a 	mov	r4,zero
 d0289ac:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 d0289b0:	e0bffb17 	ldw	r2,-20(fp)
 d0289b4:	1004403a 	cmpge	r2,r2,zero
 d0289b8:	1000031e 	bne	r2,zero,d0289c8 <rawip_usrreq+0x704>
         return(e);
 d0289bc:	e0bffb17 	ldw	r2,-20(fp)
 d0289c0:	e0bfff15 	stw	r2,-4(fp)
 d0289c4:	00003206 	br	d028a90 <rawip_usrreq+0x7cc>
      return 0;
 d0289c8:	e03fff15 	stw	zero,-4(fp)
 d0289cc:	00003006 	br	d028a90 <rawip_usrreq+0x7cc>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 d0289d0:	e0bffe17 	ldw	r2,-8(fp)
 d0289d4:	1004c03a 	cmpne	r2,r2,zero
 d0289d8:	1000031e 	bne	r2,zero,d0289e8 <rawip_usrreq+0x724>
         return(EINVAL);
 d0289dc:	00800584 	movi	r2,22
 d0289e0:	e0bfff15 	stw	r2,-4(fp)
 d0289e4:	00002a06 	br	d028a90 <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 d0289e8:	e0bffe17 	ldw	r2,-8(fp)
 d0289ec:	10800317 	ldw	r2,12(r2)
 d0289f0:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 d0289f4:	e0bff917 	ldw	r2,-28(fp)
 d0289f8:	1004c03a 	cmpne	r2,r2,zero
 d0289fc:	1000031e 	bne	r2,zero,d028a0c <rawip_usrreq+0x748>
         return(EINVAL);
 d028a00:	00800584 	movi	r2,22
 d028a04:	e0bfff15 	stw	r2,-4(fp)
 d028a08:	00002106 	br	d028a90 <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 d028a0c:	e13ffc17 	ldw	r4,-16(fp)
 d028a10:	d0280800 	call	d028080 <rawip_lookup>
 d028a14:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d028a18:	e0bff817 	ldw	r2,-32(fp)
 d028a1c:	1004c03a 	cmpne	r2,r2,zero
 d028a20:	1000031e 	bne	r2,zero,d028a30 <rawip_usrreq+0x76c>
         return(EINVAL);
 d028a24:	00800584 	movi	r2,22
 d028a28:	e0bfff15 	stw	r2,-4(fp)
 d028a2c:	00001806 	br	d028a90 <rawip_usrreq+0x7cc>
      sin->sin_port = 0;
 d028a30:	e0bff917 	ldw	r2,-28(fp)
 d028a34:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 d028a38:	e0fffe17 	ldw	r3,-8(fp)
 d028a3c:	00800404 	movi	r2,16
 d028a40:	18800215 	stw	r2,8(r3)
      if (req == PRU_SOCKADDR)
 d028a44:	e0bff317 	ldw	r2,-52(fp)
 d028a48:	108003d8 	cmpnei	r2,r2,15
 d028a4c:	1000051e 	bne	r2,zero,d028a64 <rawip_usrreq+0x7a0>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 d028a50:	e0bff817 	ldw	r2,-32(fp)
 d028a54:	10c00117 	ldw	r3,4(r2)
 d028a58:	e0bff917 	ldw	r2,-28(fp)
 d028a5c:	10c00115 	stw	r3,4(r2)
 d028a60:	00000406 	br	d028a74 <rawip_usrreq+0x7b0>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 d028a64:	e0bff817 	ldw	r2,-32(fp)
 d028a68:	10c00217 	ldw	r3,8(r2)
 d028a6c:	e0bff917 	ldw	r2,-28(fp)
 d028a70:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 d028a74:	e03fff15 	stw	zero,-4(fp)
 d028a78:	00000506 	br	d028a90 <rawip_usrreq+0x7cc>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 d028a7c:	d025a500 	call	d025a50 <dtrap>
      return 0;
 d028a80:	e03fff15 	stw	zero,-4(fp)
 d028a84:	00000206 	br	d028a90 <rawip_usrreq+0x7cc>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 d028a88:	008017c4 	movi	r2,95
 d028a8c:	e0bfff15 	stw	r2,-4(fp)
 d028a90:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d028a94:	e037883a 	mov	sp,fp
 d028a98:	dfc00217 	ldw	ra,8(sp)
 d028a9c:	df000117 	ldw	fp,4(sp)
 d028aa0:	dc000017 	ldw	r16,0(sp)
 d028aa4:	dec00304 	addi	sp,sp,12
 d028aa8:	f800283a 	ret

0d028aac <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 d028aac:	defffc04 	addi	sp,sp,-16
 d028ab0:	dfc00315 	stw	ra,12(sp)
 d028ab4:	df000215 	stw	fp,8(sp)
 d028ab8:	df000204 	addi	fp,sp,8
 d028abc:	e13ffe15 	stw	r4,-8(fp)
 d028ac0:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 d028ac4:	e0bffe17 	ldw	r2,-8(fp)
 d028ac8:	10800517 	ldw	r2,20(r2)
 d028acc:	10800098 	cmpnei	r2,r2,2
 d028ad0:	1000041e 	bne	r2,zero,d028ae4 <DOMAIN_CHECK+0x38>
 d028ad4:	e0bfff17 	ldw	r2,-4(fp)
 d028ad8:	10800428 	cmpgeui	r2,r2,16
 d028adc:	1000011e 	bne	r2,zero,d028ae4 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 d028ae0:	d025a500 	call	d025a50 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 d028ae4:	e037883a 	mov	sp,fp
 d028ae8:	dfc00117 	ldw	ra,4(sp)
 d028aec:	df000017 	ldw	fp,0(sp)
 d028af0:	dec00204 	addi	sp,sp,8
 d028af4:	f800283a 	ret

0d028af8 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 d028af8:	defff904 	addi	sp,sp,-28
 d028afc:	dfc00615 	stw	ra,24(sp)
 d028b00:	df000515 	stw	fp,20(sp)
 d028b04:	df000504 	addi	fp,sp,20
 d028b08:	e13ffc15 	stw	r4,-16(fp)
 d028b0c:	e17ffd15 	stw	r5,-12(fp)
 d028b10:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 d028b14:	0009883a 	mov	r4,zero
 d028b18:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 d028b1c:	e13ffc17 	ldw	r4,-16(fp)
 d028b20:	e17ffd17 	ldw	r5,-12(fp)
 d028b24:	e1bffe17 	ldw	r6,-8(fp)
 d028b28:	d02a2a80 	call	d02a2a8 <socreate>
 d028b2c:	e0bffb15 	stw	r2,-20(fp)
 d028b30:	e0bffb17 	ldw	r2,-20(fp)
 d028b34:	1004c03a 	cmpne	r2,r2,zero
 d028b38:	1000051e 	bne	r2,zero,d028b50 <t_socket+0x58>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d028b3c:	0009883a 	mov	r4,zero
 d028b40:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 d028b44:	00bfffc4 	movi	r2,-1
 d028b48:	e0bfff15 	stw	r2,-4(fp)
 d028b4c:	00000806 	br	d028b70 <t_socket+0x78>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 d028b50:	e0bffb17 	ldw	r2,-20(fp)
 d028b54:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d028b58:	0009883a 	mov	r4,zero
 d028b5c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 d028b60:	e0bffb17 	ldw	r2,-20(fp)
 d028b64:	1004d0ba 	srli	r2,r2,2
 d028b68:	10800804 	addi	r2,r2,32
 d028b6c:	e0bfff15 	stw	r2,-4(fp)
 d028b70:	e0bfff17 	ldw	r2,-4(fp)
}
 d028b74:	e037883a 	mov	sp,fp
 d028b78:	dfc00117 	ldw	ra,4(sp)
 d028b7c:	df000017 	ldw	fp,0(sp)
 d028b80:	dec00204 	addi	sp,sp,8
 d028b84:	f800283a 	ret

0d028b88 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 d028b88:	defff104 	addi	sp,sp,-60
 d028b8c:	dfc00e15 	stw	ra,56(sp)
 d028b90:	df000d15 	stw	fp,52(sp)
 d028b94:	df000d04 	addi	fp,sp,52
 d028b98:	e13ffc15 	stw	r4,-16(fp)
 d028b9c:	e17ffd15 	stw	r5,-12(fp)
 d028ba0:	e1bffe15 	stw	r6,-8(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 d028ba4:	e0bffc17 	ldw	r2,-16(fp)
 d028ba8:	10bff804 	addi	r2,r2,-32
 d028bac:	1085883a 	add	r2,r2,r2
 d028bb0:	1085883a 	add	r2,r2,r2
 d028bb4:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 d028bb8:	008341b4 	movhi	r2,3334
 d028bbc:	10845704 	addi	r2,r2,4444
 d028bc0:	e0bff315 	stw	r2,-52(fp)
 d028bc4:	00000606 	br	d028be0 <t_bind+0x58>
 d028bc8:	e0fff317 	ldw	r3,-52(fp)
 d028bcc:	e0bff517 	ldw	r2,-44(fp)
 d028bd0:	18800626 	beq	r3,r2,d028bec <t_bind+0x64>
 d028bd4:	e0bff317 	ldw	r2,-52(fp)
 d028bd8:	10800017 	ldw	r2,0(r2)
 d028bdc:	e0bff315 	stw	r2,-52(fp)
 d028be0:	e0bff317 	ldw	r2,-52(fp)
 d028be4:	1004c03a 	cmpne	r2,r2,zero
 d028be8:	103ff71e 	bne	r2,zero,d028bc8 <t_bind+0x40>
 d028bec:	e0fff317 	ldw	r3,-52(fp)
 d028bf0:	e0bff517 	ldw	r2,-44(fp)
 d028bf4:	18800426 	beq	r3,r2,d028c08 <t_bind+0x80>
 d028bf8:	d025a500 	call	d025a50 <dtrap>
 d028bfc:	00bfffc4 	movi	r2,-1
 d028c00:	e0bfff15 	stw	r2,-4(fp)
 d028c04:	00003906 	br	d028cec <t_bind+0x164>
   DOMAIN_CHECK(so, addrlen);
 d028c08:	e13ff517 	ldw	r4,-44(fp)
 d028c0c:	e17ffe17 	ldw	r5,-8(fp)
 d028c10:	d028aac0 	call	d028aac <DOMAIN_CHECK>

   so->so_error = 0;
 d028c14:	e0bff517 	ldw	r2,-44(fp)
 d028c18:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 d028c1c:	e0bffd17 	ldw	r2,-12(fp)
 d028c20:	1004c03a 	cmpne	r2,r2,zero
 d028c24:	10000d1e 	bne	r2,zero,d028c5c <t_bind+0xd4>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 d028c28:	e0bff804 	addi	r2,fp,-32
 d028c2c:	10000015 	stw	zero,0(r2)
 d028c30:	10000115 	stw	zero,4(r2)
 d028c34:	10000215 	stw	zero,8(r2)
 d028c38:	10000315 	stw	zero,12(r2)
      addrlen = sizeof(sa);
 d028c3c:	00800404 	movi	r2,16
 d028c40:	e0bffe15 	stw	r2,-8(fp)
      sa.sa_family = so->so_domain;
 d028c44:	e0bff517 	ldw	r2,-44(fp)
 d028c48:	10800517 	ldw	r2,20(r2)
 d028c4c:	e0bff80d 	sth	r2,-32(fp)
      sap = &sa;
 d028c50:	e0bff804 	addi	r2,fp,-32
 d028c54:	e0bff615 	stw	r2,-40(fp)
 d028c58:	00000206 	br	d028c64 <t_bind+0xdc>
   } else
      sap = addr;
 d028c5c:	e0bffd17 	ldw	r2,-12(fp)
 d028c60:	e0bff615 	stw	r2,-40(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 d028c64:	e13ff617 	ldw	r4,-40(fp)
 d028c68:	e17ffe17 	ldw	r5,-8(fp)
 d028c6c:	01800244 	movi	r6,9
 d028c70:	d02a1740 	call	d02a174 <sockargs>
 d028c74:	e0bff715 	stw	r2,-36(fp)
 d028c78:	e0bff717 	ldw	r2,-36(fp)
 d028c7c:	1004c03a 	cmpne	r2,r2,zero
 d028c80:	1000061e 	bne	r2,zero,d028c9c <t_bind+0x114>
   {
      so->so_error = ENOMEM;
 d028c84:	e0fff517 	ldw	r3,-44(fp)
 d028c88:	00800304 	movi	r2,12
 d028c8c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d028c90:	00bfffc4 	movi	r2,-1
 d028c94:	e0bfff15 	stw	r2,-4(fp)
 d028c98:	00001406 	br	d028cec <t_bind+0x164>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 d028c9c:	0009883a 	mov	r4,zero
 d028ca0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 d028ca4:	e13ff517 	ldw	r4,-44(fp)
 d028ca8:	e17ff717 	ldw	r5,-36(fp)
 d028cac:	d02a4740 	call	d02a474 <sobind>
 d028cb0:	e0bff415 	stw	r2,-48(fp)
   m_freem(nam);
 d028cb4:	e13ff717 	ldw	r4,-36(fp)
 d028cb8:	d026b500 	call	d026b50 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d028cbc:	0009883a 	mov	r4,zero
 d028cc0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   if (err) 
 d028cc4:	e0bff417 	ldw	r2,-48(fp)
 d028cc8:	1005003a 	cmpeq	r2,r2,zero
 d028ccc:	1000061e 	bne	r2,zero,d028ce8 <t_bind+0x160>
   {
      so->so_error = err;
 d028cd0:	e0fff517 	ldw	r3,-44(fp)
 d028cd4:	e0bff417 	ldw	r2,-48(fp)
 d028cd8:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d028cdc:	00bfffc4 	movi	r2,-1
 d028ce0:	e0bfff15 	stw	r2,-4(fp)
 d028ce4:	00000106 	br	d028cec <t_bind+0x164>
   }
   return 0;
 d028ce8:	e03fff15 	stw	zero,-4(fp)
 d028cec:	e0bfff17 	ldw	r2,-4(fp)
}
 d028cf0:	e037883a 	mov	sp,fp
 d028cf4:	dfc00117 	ldw	ra,4(sp)
 d028cf8:	df000017 	ldw	fp,0(sp)
 d028cfc:	dec00204 	addi	sp,sp,8
 d028d00:	f800283a 	ret

0d028d04 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 d028d04:	defff804 	addi	sp,sp,-32
 d028d08:	dfc00715 	stw	ra,28(sp)
 d028d0c:	df000615 	stw	fp,24(sp)
 d028d10:	df000604 	addi	fp,sp,24
 d028d14:	e13ffd15 	stw	r4,-12(fp)
 d028d18:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 d028d1c:	e0bffd17 	ldw	r2,-12(fp)
 d028d20:	10bff804 	addi	r2,r2,-32
 d028d24:	1085883a 	add	r2,r2,r2
 d028d28:	1085883a 	add	r2,r2,r2
 d028d2c:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 d028d30:	008341b4 	movhi	r2,3334
 d028d34:	10845704 	addi	r2,r2,4444
 d028d38:	e0bffa15 	stw	r2,-24(fp)
 d028d3c:	00000606 	br	d028d58 <t_listen+0x54>
 d028d40:	e0fffa17 	ldw	r3,-24(fp)
 d028d44:	e0bffc17 	ldw	r2,-16(fp)
 d028d48:	18800626 	beq	r3,r2,d028d64 <t_listen+0x60>
 d028d4c:	e0bffa17 	ldw	r2,-24(fp)
 d028d50:	10800017 	ldw	r2,0(r2)
 d028d54:	e0bffa15 	stw	r2,-24(fp)
 d028d58:	e0bffa17 	ldw	r2,-24(fp)
 d028d5c:	1004c03a 	cmpne	r2,r2,zero
 d028d60:	103ff71e 	bne	r2,zero,d028d40 <t_listen+0x3c>
 d028d64:	e0fffa17 	ldw	r3,-24(fp)
 d028d68:	e0bffc17 	ldw	r2,-16(fp)
 d028d6c:	18800426 	beq	r3,r2,d028d80 <t_listen+0x7c>
 d028d70:	d025a500 	call	d025a50 <dtrap>
 d028d74:	00bfffc4 	movi	r2,-1
 d028d78:	e0bfff15 	stw	r2,-4(fp)
 d028d7c:	00001406 	br	d028dd0 <t_listen+0xcc>
   so->so_error = 0;
 d028d80:	e0bffc17 	ldw	r2,-16(fp)
 d028d84:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 d028d88:	0009883a 	mov	r4,zero
 d028d8c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 d028d90:	e13ffc17 	ldw	r4,-16(fp)
 d028d94:	e17ffe17 	ldw	r5,-8(fp)
 d028d98:	d02a4d00 	call	d02a4d0 <solisten>
 d028d9c:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d028da0:	0009883a 	mov	r4,zero
 d028da4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 d028da8:	e0bffb17 	ldw	r2,-20(fp)
 d028dac:	1005003a 	cmpeq	r2,r2,zero
 d028db0:	1000061e 	bne	r2,zero,d028dcc <t_listen+0xc8>
   {
      so->so_error = err;
 d028db4:	e0fffc17 	ldw	r3,-16(fp)
 d028db8:	e0bffb17 	ldw	r2,-20(fp)
 d028dbc:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d028dc0:	00bfffc4 	movi	r2,-1
 d028dc4:	e0bfff15 	stw	r2,-4(fp)
 d028dc8:	00000106 	br	d028dd0 <t_listen+0xcc>
   }
   return 0;
 d028dcc:	e03fff15 	stw	zero,-4(fp)
 d028dd0:	e0bfff17 	ldw	r2,-4(fp)
}
 d028dd4:	e037883a 	mov	sp,fp
 d028dd8:	dfc00117 	ldw	ra,4(sp)
 d028ddc:	df000017 	ldw	fp,0(sp)
 d028de0:	dec00204 	addi	sp,sp,8
 d028de4:	f800283a 	ret

0d028de8 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 d028de8:	defff604 	addi	sp,sp,-40
 d028dec:	dfc00915 	stw	ra,36(sp)
 d028df0:	df000815 	stw	fp,32(sp)
 d028df4:	df000804 	addi	fp,sp,32
 d028df8:	e13ffc15 	stw	r4,-16(fp)
 d028dfc:	e17ffd15 	stw	r5,-12(fp)
 d028e00:	e1bffe15 	stw	r6,-8(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 d028e04:	e0bffc17 	ldw	r2,-16(fp)
 d028e08:	10bff804 	addi	r2,r2,-32
 d028e0c:	1085883a 	add	r2,r2,r2
 d028e10:	1085883a 	add	r2,r2,r2
 d028e14:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 d028e18:	008341b4 	movhi	r2,3334
 d028e1c:	10845704 	addi	r2,r2,4444
 d028e20:	e0bff915 	stw	r2,-28(fp)
 d028e24:	00000606 	br	d028e40 <t_accept+0x58>
 d028e28:	e0fff917 	ldw	r3,-28(fp)
 d028e2c:	e0bffb17 	ldw	r2,-20(fp)
 d028e30:	18800626 	beq	r3,r2,d028e4c <t_accept+0x64>
 d028e34:	e0bff917 	ldw	r2,-28(fp)
 d028e38:	10800017 	ldw	r2,0(r2)
 d028e3c:	e0bff915 	stw	r2,-28(fp)
 d028e40:	e0bff917 	ldw	r2,-28(fp)
 d028e44:	1004c03a 	cmpne	r2,r2,zero
 d028e48:	103ff71e 	bne	r2,zero,d028e28 <t_accept+0x40>
 d028e4c:	e0fff917 	ldw	r3,-28(fp)
 d028e50:	e0bffb17 	ldw	r2,-20(fp)
 d028e54:	18800426 	beq	r3,r2,d028e68 <t_accept+0x80>
 d028e58:	d025a500 	call	d025a50 <dtrap>
 d028e5c:	00bfffc4 	movi	r2,-1
 d028e60:	e0bfff15 	stw	r2,-4(fp)
 d028e64:	00008006 	br	d029068 <t_accept+0x280>
   DOMAIN_CHECK(so, *addrlen);
 d028e68:	e0bffe17 	ldw	r2,-8(fp)
 d028e6c:	11400017 	ldw	r5,0(r2)
 d028e70:	e13ffb17 	ldw	r4,-20(fp)
 d028e74:	d028aac0 	call	d028aac <DOMAIN_CHECK>

   so->so_error = 0;
 d028e78:	e0bffb17 	ldw	r2,-20(fp)
 d028e7c:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 d028e80:	e0bffb17 	ldw	r2,-20(fp)
 d028e84:	10800417 	ldw	r2,16(r2)
 d028e88:	1080008c 	andi	r2,r2,2
 d028e8c:	1004c03a 	cmpne	r2,r2,zero
 d028e90:	1000061e 	bne	r2,zero,d028eac <t_accept+0xc4>
   {
      so->so_error = EINVAL;
 d028e94:	e0fffb17 	ldw	r3,-20(fp)
 d028e98:	00800584 	movi	r2,22
 d028e9c:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d028ea0:	00bfffc4 	movi	r2,-1
 d028ea4:	e0bfff15 	stw	r2,-4(fp)
 d028ea8:	00006f06 	br	d029068 <t_accept+0x280>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 d028eac:	e0bffb17 	ldw	r2,-20(fp)
 d028eb0:	1080088b 	ldhu	r2,34(r2)
 d028eb4:	10bfffcc 	andi	r2,r2,65535
 d028eb8:	1080400c 	andi	r2,r2,256
 d028ebc:	1005003a 	cmpeq	r2,r2,zero
 d028ec0:	10000d1e 	bne	r2,zero,d028ef8 <t_accept+0x110>
 d028ec4:	e0bffb17 	ldw	r2,-20(fp)
 d028ec8:	10801e43 	ldbu	r2,121(r2)
 d028ecc:	10803fcc 	andi	r2,r2,255
 d028ed0:	1080201c 	xori	r2,r2,128
 d028ed4:	10bfe004 	addi	r2,r2,-128
 d028ed8:	1004c03a 	cmpne	r2,r2,zero
 d028edc:	1000061e 	bne	r2,zero,d028ef8 <t_accept+0x110>
   {
      so->so_error = EWOULDBLOCK;
 d028ee0:	e0fffb17 	ldw	r3,-20(fp)
 d028ee4:	008002c4 	movi	r2,11
 d028ee8:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d028eec:	00bfffc4 	movi	r2,-1
 d028ef0:	e0bfff15 	stw	r2,-4(fp)
 d028ef4:	00005c06 	br	d029068 <t_accept+0x280>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 d028ef8:	0009883a 	mov	r4,zero
 d028efc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 d028f00:	00001206 	br	d028f4c <t_accept+0x164>
   {
      if (so->so_state & SS_CANTRCVMORE)
 d028f04:	e0bffb17 	ldw	r2,-20(fp)
 d028f08:	1080088b 	ldhu	r2,34(r2)
 d028f0c:	10bfffcc 	andi	r2,r2,65535
 d028f10:	1080080c 	andi	r2,r2,32
 d028f14:	1005003a 	cmpeq	r2,r2,zero
 d028f18:	1000081e 	bne	r2,zero,d028f3c <t_accept+0x154>
      {
         so->so_error = ECONNABORTED;
 d028f1c:	e0fffb17 	ldw	r3,-20(fp)
 d028f20:	00801c44 	movi	r2,113
 d028f24:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 d028f28:	0009883a 	mov	r4,zero
 d028f2c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d028f30:	00bfffc4 	movi	r2,-1
 d028f34:	e0bfff15 	stw	r2,-4(fp)
 d028f38:	00004b06 	br	d029068 <t_accept+0x280>
      }
      tcp_sleep ((char *)&so->so_timeo);
 d028f3c:	e0bffb17 	ldw	r2,-20(fp)
 d028f40:	10800904 	addi	r2,r2,36
 d028f44:	1009883a 	mov	r4,r2
 d028f48:	d0212b40 	call	d0212b4 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 d028f4c:	e0bffb17 	ldw	r2,-20(fp)
 d028f50:	10801e43 	ldbu	r2,121(r2)
 d028f54:	10803fcc 	andi	r2,r2,255
 d028f58:	1080201c 	xori	r2,r2,128
 d028f5c:	10bfe004 	addi	r2,r2,-128
 d028f60:	1004c03a 	cmpne	r2,r2,zero
 d028f64:	1000041e 	bne	r2,zero,d028f78 <t_accept+0x190>
 d028f68:	e0bffb17 	ldw	r2,-20(fp)
 d028f6c:	10800617 	ldw	r2,24(r2)
 d028f70:	1005003a 	cmpeq	r2,r2,zero
 d028f74:	103fe31e 	bne	r2,zero,d028f04 <t_accept+0x11c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 d028f78:	e0bffb17 	ldw	r2,-20(fp)
 d028f7c:	10800617 	ldw	r2,24(r2)
 d028f80:	1005003a 	cmpeq	r2,r2,zero
 d028f84:	1000051e 	bne	r2,zero,d028f9c <t_accept+0x1b4>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 d028f88:	0009883a 	mov	r4,zero
 d028f8c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 d028f90:	00bfffc4 	movi	r2,-1
 d028f94:	e0bfff15 	stw	r2,-4(fp)
 d028f98:	00003306 	br	d029068 <t_accept+0x280>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 d028f9c:	01000244 	movi	r4,9
 d028fa0:	01400404 	movi	r5,16
 d028fa4:	d0268740 	call	d026874 <m_getnbuf>
 d028fa8:	e0bffa15 	stw	r2,-24(fp)
   if (nam == NULL) 
 d028fac:	e0bffa17 	ldw	r2,-24(fp)
 d028fb0:	1004c03a 	cmpne	r2,r2,zero
 d028fb4:	1000081e 	bne	r2,zero,d028fd8 <t_accept+0x1f0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d028fb8:	0009883a 	mov	r4,zero
 d028fbc:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 d028fc0:	e0fffb17 	ldw	r3,-20(fp)
 d028fc4:	00800304 	movi	r2,12
 d028fc8:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d028fcc:	00bfffc4 	movi	r2,-1
 d028fd0:	e0bfff15 	stw	r2,-4(fp)
 d028fd4:	00002406 	br	d029068 <t_accept+0x280>
   }
   { 
      struct socket *aso = so->so_q;
 d028fd8:	e0bffb17 	ldw	r2,-20(fp)
 d028fdc:	10801d17 	ldw	r2,116(r2)
 d028fe0:	e0bff815 	stw	r2,-32(fp)
      if (soqremque (aso, 1) == 0)
 d028fe4:	e13ff817 	ldw	r4,-32(fp)
 d028fe8:	01400044 	movi	r5,1
 d028fec:	d02cb9c0 	call	d02cb9c <soqremque>
 d028ff0:	1004c03a 	cmpne	r2,r2,zero
 d028ff4:	1000031e 	bne	r2,zero,d029004 <t_accept+0x21c>
         panic("accept");
 d028ff8:	01034174 	movhi	r4,3333
 d028ffc:	213e8004 	addi	r4,r4,-1536
 d029000:	d02093c0 	call	d02093c <panic>
      so = aso;
 d029004:	e0bff817 	ldw	r2,-32(fp)
 d029008:	e0bffb15 	stw	r2,-20(fp)
   }
   (void)soaccept (so, nam);
 d02900c:	e13ffb17 	ldw	r4,-20(fp)
 d029010:	e17ffa17 	ldw	r5,-24(fp)
 d029014:	d02aa3c0 	call	d02aa3c <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 d029018:	e0bffd17 	ldw	r2,-12(fp)
 d02901c:	1005003a 	cmpeq	r2,r2,zero
 d029020:	1000091e 	bne	r2,zero,d029048 <t_accept+0x260>
      MEMCPY(addr, nam->m_data, *addrlen);
 d029024:	e0bffa17 	ldw	r2,-24(fp)
 d029028:	11400317 	ldw	r5,12(r2)
 d02902c:	e0bffe17 	ldw	r2,-8(fp)
 d029030:	10800017 	ldw	r2,0(r2)
 d029034:	1007883a 	mov	r3,r2
 d029038:	e0bffd17 	ldw	r2,-12(fp)
 d02903c:	1009883a 	mov	r4,r2
 d029040:	180d883a 	mov	r6,r3
 d029044:	d0026080 	call	d002608 <memcpy>
   m_freem (nam);
 d029048:	e13ffa17 	ldw	r4,-24(fp)
 d02904c:	d026b500 	call	d026b50 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d029050:	0009883a 	mov	r4,zero
 d029054:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 d029058:	e0bffb17 	ldw	r2,-20(fp)
 d02905c:	1004d0ba 	srli	r2,r2,2
 d029060:	10800804 	addi	r2,r2,32
 d029064:	e0bfff15 	stw	r2,-4(fp)
 d029068:	e0bfff17 	ldw	r2,-4(fp)
}
 d02906c:	e037883a 	mov	sp,fp
 d029070:	dfc00117 	ldw	ra,4(sp)
 d029074:	df000017 	ldw	fp,0(sp)
 d029078:	dec00204 	addi	sp,sp,8
 d02907c:	f800283a 	ret

0d029080 <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 d029080:	defff704 	addi	sp,sp,-36
 d029084:	dfc00815 	stw	ra,32(sp)
 d029088:	df000715 	stw	fp,28(sp)
 d02908c:	df000704 	addi	fp,sp,28
 d029090:	e13ffc15 	stw	r4,-16(fp)
 d029094:	e17ffd15 	stw	r5,-12(fp)
 d029098:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 d02909c:	e0bffc17 	ldw	r2,-16(fp)
 d0290a0:	10bff804 	addi	r2,r2,-32
 d0290a4:	1085883a 	add	r2,r2,r2
 d0290a8:	1085883a 	add	r2,r2,r2
 d0290ac:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 d0290b0:	008341b4 	movhi	r2,3334
 d0290b4:	10845704 	addi	r2,r2,4444
 d0290b8:	e0bff915 	stw	r2,-28(fp)
 d0290bc:	00000606 	br	d0290d8 <t_connect+0x58>
 d0290c0:	e0fff917 	ldw	r3,-28(fp)
 d0290c4:	e0bffb17 	ldw	r2,-20(fp)
 d0290c8:	18800626 	beq	r3,r2,d0290e4 <t_connect+0x64>
 d0290cc:	e0bff917 	ldw	r2,-28(fp)
 d0290d0:	10800017 	ldw	r2,0(r2)
 d0290d4:	e0bff915 	stw	r2,-28(fp)
 d0290d8:	e0bff917 	ldw	r2,-28(fp)
 d0290dc:	1004c03a 	cmpne	r2,r2,zero
 d0290e0:	103ff71e 	bne	r2,zero,d0290c0 <t_connect+0x40>
 d0290e4:	e0fff917 	ldw	r3,-28(fp)
 d0290e8:	e0bffb17 	ldw	r2,-20(fp)
 d0290ec:	18800426 	beq	r3,r2,d029100 <t_connect+0x80>
 d0290f0:	d025a500 	call	d025a50 <dtrap>
 d0290f4:	00bfffc4 	movi	r2,-1
 d0290f8:	e0bfff15 	stw	r2,-4(fp)
 d0290fc:	00008406 	br	d029310 <t_connect+0x290>
   DOMAIN_CHECK(so, addrlen);
 d029100:	e13ffb17 	ldw	r4,-20(fp)
 d029104:	e17ffe17 	ldw	r5,-8(fp)
 d029108:	d028aac0 	call	d028aac <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 d02910c:	e0bffb17 	ldw	r2,-20(fp)
 d029110:	1080088b 	ldhu	r2,34(r2)
 d029114:	10bfffcc 	andi	r2,r2,65535
 d029118:	1080400c 	andi	r2,r2,256
 d02911c:	1005003a 	cmpeq	r2,r2,zero
 d029120:	10002a1e 	bne	r2,zero,d0291cc <t_connect+0x14c>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 d029124:	e0bffb17 	ldw	r2,-20(fp)
 d029128:	1080088b 	ldhu	r2,34(r2)
 d02912c:	10bfffcc 	andi	r2,r2,65535
 d029130:	1080010c 	andi	r2,r2,4
 d029134:	1005003a 	cmpeq	r2,r2,zero
 d029138:	1000061e 	bne	r2,zero,d029154 <t_connect+0xd4>
      {
         so->so_error = EINPROGRESS;
 d02913c:	e0fffb17 	ldw	r3,-20(fp)
 d029140:	00801dc4 	movi	r2,119
 d029144:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 d029148:	00bfffc4 	movi	r2,-1
 d02914c:	e0bfff15 	stw	r2,-4(fp)
 d029150:	00006f06 	br	d029310 <t_connect+0x290>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 d029154:	e0bffb17 	ldw	r2,-20(fp)
 d029158:	1080088b 	ldhu	r2,34(r2)
 d02915c:	10bfffcc 	andi	r2,r2,65535
 d029160:	1080008c 	andi	r2,r2,2
 d029164:	1005003a 	cmpeq	r2,r2,zero
 d029168:	1000041e 	bne	r2,zero,d02917c <t_connect+0xfc>
      {
         so->so_error = 0;
 d02916c:	e0bffb17 	ldw	r2,-20(fp)
 d029170:	10000615 	stw	zero,24(r2)
         return 0;
 d029174:	e03fff15 	stw	zero,-4(fp)
 d029178:	00006506 	br	d029310 <t_connect+0x290>
      }
      if (so->so_state & SS_WASCONNECTING)
 d02917c:	e0bffb17 	ldw	r2,-20(fp)
 d029180:	1080088b 	ldhu	r2,34(r2)
 d029184:	10bfffcc 	andi	r2,r2,65535
 d029188:	1088000c 	andi	r2,r2,8192
 d02918c:	1005003a 	cmpeq	r2,r2,zero
 d029190:	10000e1e 	bne	r2,zero,d0291cc <t_connect+0x14c>
      {
         so->so_state &= ~SS_WASCONNECTING;
 d029194:	e0bffb17 	ldw	r2,-20(fp)
 d029198:	10c0088b 	ldhu	r3,34(r2)
 d02919c:	00b7ffc4 	movi	r2,-8193
 d0291a0:	1884703a 	and	r2,r3,r2
 d0291a4:	1007883a 	mov	r3,r2
 d0291a8:	e0bffb17 	ldw	r2,-20(fp)
 d0291ac:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 d0291b0:	e0bffb17 	ldw	r2,-20(fp)
 d0291b4:	10800617 	ldw	r2,24(r2)
 d0291b8:	1005003a 	cmpeq	r2,r2,zero
 d0291bc:	1000031e 	bne	r2,zero,d0291cc <t_connect+0x14c>
            return SOCKET_ERROR;
 d0291c0:	00bfffc4 	movi	r2,-1
 d0291c4:	e0bfff15 	stw	r2,-4(fp)
 d0291c8:	00005106 	br	d029310 <t_connect+0x290>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 d0291cc:	e0bffb17 	ldw	r2,-20(fp)
 d0291d0:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 d0291d4:	e13ffd17 	ldw	r4,-12(fp)
 d0291d8:	e17ffe17 	ldw	r5,-8(fp)
 d0291dc:	01800244 	movi	r6,9
 d0291e0:	d02a1740 	call	d02a174 <sockargs>
 d0291e4:	e0bffa15 	stw	r2,-24(fp)
 d0291e8:	e0bffa17 	ldw	r2,-24(fp)
 d0291ec:	1004c03a 	cmpne	r2,r2,zero
 d0291f0:	1000061e 	bne	r2,zero,d02920c <t_connect+0x18c>
       == NULL)
   {
      so->so_error = ENOMEM;
 d0291f4:	e0fffb17 	ldw	r3,-20(fp)
 d0291f8:	00800304 	movi	r2,12
 d0291fc:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d029200:	00bfffc4 	movi	r2,-1
 d029204:	e0bfff15 	stw	r2,-4(fp)
 d029208:	00004106 	br	d029310 <t_connect+0x290>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 d02920c:	0009883a 	mov	r4,zero
 d029210:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 d029214:	e13ffb17 	ldw	r4,-20(fp)
 d029218:	e17ffa17 	ldw	r5,-24(fp)
 d02921c:	d02aad80 	call	d02aad8 <soconnect>
 d029220:	1007883a 	mov	r3,r2
 d029224:	e0bffb17 	ldw	r2,-20(fp)
 d029228:	10c00615 	stw	r3,24(r2)
 d02922c:	e0bffb17 	ldw	r2,-20(fp)
 d029230:	10800617 	ldw	r2,24(r2)
 d029234:	1004c03a 	cmpne	r2,r2,zero
 d029238:	10001e1e 	bne	r2,zero,d0292b4 <t_connect+0x234>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 d02923c:	e0bffb17 	ldw	r2,-20(fp)
 d029240:	1080088b 	ldhu	r2,34(r2)
 d029244:	10bfffcc 	andi	r2,r2,65535
 d029248:	1080400c 	andi	r2,r2,256
 d02924c:	1005003a 	cmpeq	r2,r2,zero
 d029250:	10000e1e 	bne	r2,zero,d02928c <t_connect+0x20c>
 d029254:	e0bffb17 	ldw	r2,-20(fp)
 d029258:	1080088b 	ldhu	r2,34(r2)
 d02925c:	10bfffcc 	andi	r2,r2,65535
 d029260:	1080010c 	andi	r2,r2,4
 d029264:	1005003a 	cmpeq	r2,r2,zero
 d029268:	1000081e 	bne	r2,zero,d02928c <t_connect+0x20c>
   {
      so->so_error = EINPROGRESS;
 d02926c:	e0fffb17 	ldw	r3,-20(fp)
 d029270:	00801dc4 	movi	r2,119
 d029274:	18800615 	stw	r2,24(r3)
      goto bad;
 d029278:	00000e06 	br	d0292b4 <t_connect+0x234>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 d02927c:	e0bffb17 	ldw	r2,-20(fp)
 d029280:	10800904 	addi	r2,r2,36
 d029284:	1009883a 	mov	r4,r2
 d029288:	d0212b40 	call	d0212b4 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 d02928c:	e0bffb17 	ldw	r2,-20(fp)
 d029290:	1080088b 	ldhu	r2,34(r2)
 d029294:	10bfffcc 	andi	r2,r2,65535
 d029298:	1080010c 	andi	r2,r2,4
 d02929c:	1005003a 	cmpeq	r2,r2,zero
 d0292a0:	1000041e 	bne	r2,zero,d0292b4 <t_connect+0x234>
 d0292a4:	e0bffb17 	ldw	r2,-20(fp)
 d0292a8:	10800617 	ldw	r2,24(r2)
 d0292ac:	1005003a 	cmpeq	r2,r2,zero
 d0292b0:	103ff21e 	bne	r2,zero,d02927c <t_connect+0x1fc>
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 d0292b4:	e0bffb17 	ldw	r2,-20(fp)
 d0292b8:	10800617 	ldw	r2,24(r2)
 d0292bc:	10801de0 	cmpeqi	r2,r2,119
 d0292c0:	1000071e 	bne	r2,zero,d0292e0 <t_connect+0x260>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 d0292c4:	e0bffb17 	ldw	r2,-20(fp)
 d0292c8:	10c0088b 	ldhu	r3,34(r2)
 d0292cc:	00b7fec4 	movi	r2,-8197
 d0292d0:	1884703a 	and	r2,r3,r2
 d0292d4:	1007883a 	mov	r3,r2
 d0292d8:	e0bffb17 	ldw	r2,-20(fp)
 d0292dc:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 d0292e0:	e13ffa17 	ldw	r4,-24(fp)
 d0292e4:	d026b500 	call	d026b50 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d0292e8:	0009883a 	mov	r4,zero
 d0292ec:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 d0292f0:	e0bffb17 	ldw	r2,-20(fp)
 d0292f4:	10800617 	ldw	r2,24(r2)
 d0292f8:	1005003a 	cmpeq	r2,r2,zero
 d0292fc:	1000031e 	bne	r2,zero,d02930c <t_connect+0x28c>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 d029300:	00bfffc4 	movi	r2,-1
 d029304:	e0bfff15 	stw	r2,-4(fp)
 d029308:	00000106 	br	d029310 <t_connect+0x290>

   }
      return 0;
 d02930c:	e03fff15 	stw	zero,-4(fp)
 d029310:	e0bfff17 	ldw	r2,-4(fp)
}
 d029314:	e037883a 	mov	sp,fp
 d029318:	dfc00117 	ldw	ra,4(sp)
 d02931c:	df000017 	ldw	fp,0(sp)
 d029320:	dec00204 	addi	sp,sp,8
 d029324:	f800283a 	ret

0d029328 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 d029328:	defffb04 	addi	sp,sp,-20
 d02932c:	dfc00415 	stw	ra,16(sp)
 d029330:	df000315 	stw	fp,12(sp)
 d029334:	df000304 	addi	fp,sp,12
 d029338:	e13ffd15 	stw	r4,-12(fp)
 d02933c:	e17ffe15 	stw	r5,-8(fp)
 d029340:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 d029344:	e13ffd17 	ldw	r4,-12(fp)
 d029348:	e17ffe17 	ldw	r5,-8(fp)
 d02934c:	e1bfff17 	ldw	r6,-4(fp)
 d029350:	01c00404 	movi	r7,16
 d029354:	d0293b00 	call	d0293b0 <t_getname>
}
 d029358:	e037883a 	mov	sp,fp
 d02935c:	dfc00117 	ldw	ra,4(sp)
 d029360:	df000017 	ldw	fp,0(sp)
 d029364:	dec00204 	addi	sp,sp,8
 d029368:	f800283a 	ret

0d02936c <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 d02936c:	defffb04 	addi	sp,sp,-20
 d029370:	dfc00415 	stw	ra,16(sp)
 d029374:	df000315 	stw	fp,12(sp)
 d029378:	df000304 	addi	fp,sp,12
 d02937c:	e13ffd15 	stw	r4,-12(fp)
 d029380:	e17ffe15 	stw	r5,-8(fp)
 d029384:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 d029388:	e13ffd17 	ldw	r4,-12(fp)
 d02938c:	e17ffe17 	ldw	r5,-8(fp)
 d029390:	e1bfff17 	ldw	r6,-4(fp)
 d029394:	01c003c4 	movi	r7,15
 d029398:	d0293b00 	call	d0293b0 <t_getname>
}
 d02939c:	e037883a 	mov	sp,fp
 d0293a0:	dfc00117 	ldw	ra,4(sp)
 d0293a4:	df000017 	ldw	fp,0(sp)
 d0293a8:	dec00204 	addi	sp,sp,8
 d0293ac:	f800283a 	ret

0d0293b0 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 d0293b0:	defff504 	addi	sp,sp,-44
 d0293b4:	dfc00a15 	stw	ra,40(sp)
 d0293b8:	df000915 	stw	fp,36(sp)
 d0293bc:	df000904 	addi	fp,sp,36
 d0293c0:	e13ffb15 	stw	r4,-20(fp)
 d0293c4:	e17ffc15 	stw	r5,-16(fp)
 d0293c8:	e1bffd15 	stw	r6,-12(fp)
 d0293cc:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 d0293d0:	e0bffb17 	ldw	r2,-20(fp)
 d0293d4:	10bff804 	addi	r2,r2,-32
 d0293d8:	1085883a 	add	r2,r2,r2
 d0293dc:	1085883a 	add	r2,r2,r2
 d0293e0:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d0293e4:	008341b4 	movhi	r2,3334
 d0293e8:	10845704 	addi	r2,r2,4444
 d0293ec:	e0bff715 	stw	r2,-36(fp)
 d0293f0:	00000606 	br	d02940c <t_getname+0x5c>
 d0293f4:	e0fff717 	ldw	r3,-36(fp)
 d0293f8:	e0bffa17 	ldw	r2,-24(fp)
 d0293fc:	18800626 	beq	r3,r2,d029418 <t_getname+0x68>
 d029400:	e0bff717 	ldw	r2,-36(fp)
 d029404:	10800017 	ldw	r2,0(r2)
 d029408:	e0bff715 	stw	r2,-36(fp)
 d02940c:	e0bff717 	ldw	r2,-36(fp)
 d029410:	1004c03a 	cmpne	r2,r2,zero
 d029414:	103ff71e 	bne	r2,zero,d0293f4 <t_getname+0x44>
 d029418:	e0fff717 	ldw	r3,-36(fp)
 d02941c:	e0bffa17 	ldw	r2,-24(fp)
 d029420:	18800426 	beq	r3,r2,d029434 <t_getname+0x84>
 d029424:	d025a500 	call	d025a50 <dtrap>
 d029428:	00bfffc4 	movi	r2,-1
 d02942c:	e0bfff15 	stw	r2,-4(fp)
 d029430:	00005806 	br	d029594 <t_getname+0x1e4>

   so->so_error = 0;
 d029434:	e0bffa17 	ldw	r2,-24(fp)
 d029438:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 d02943c:	e0bffe17 	ldw	r2,-8(fp)
 d029440:	10800418 	cmpnei	r2,r2,16
 d029444:	10000c1e 	bne	r2,zero,d029478 <t_getname+0xc8>
 d029448:	e0bffa17 	ldw	r2,-24(fp)
 d02944c:	1080088b 	ldhu	r2,34(r2)
 d029450:	10bfffcc 	andi	r2,r2,65535
 d029454:	1080008c 	andi	r2,r2,2
 d029458:	1004c03a 	cmpne	r2,r2,zero
 d02945c:	1000061e 	bne	r2,zero,d029478 <t_getname+0xc8>
   {
      so->so_error = ENOTCONN;
 d029460:	e0fffa17 	ldw	r3,-24(fp)
 d029464:	00802004 	movi	r2,128
 d029468:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02946c:	00bfffc4 	movi	r2,-1
 d029470:	e0bfff15 	stw	r2,-4(fp)
 d029474:	00004706 	br	d029594 <t_getname+0x1e4>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 d029478:	0009883a 	mov	r4,zero
 d02947c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 d029480:	01000244 	movi	r4,9
 d029484:	01400404 	movi	r5,16
 d029488:	d0268740 	call	d026874 <m_getnbuf>
 d02948c:	e0bff915 	stw	r2,-28(fp)
   if (m == NULL) 
 d029490:	e0bff917 	ldw	r2,-28(fp)
 d029494:	1004c03a 	cmpne	r2,r2,zero
 d029498:	1000081e 	bne	r2,zero,d0294bc <t_getname+0x10c>
   {
      so->so_error = ENOMEM;
 d02949c:	e0fffa17 	ldw	r3,-24(fp)
 d0294a0:	00800304 	movi	r2,12
 d0294a4:	18800615 	stw	r2,24(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 d0294a8:	0009883a 	mov	r4,zero
 d0294ac:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 d0294b0:	00bfffc4 	movi	r2,-1
 d0294b4:	e0bfff15 	stw	r2,-4(fp)
 d0294b8:	00003606 	br	d029594 <t_getname+0x1e4>
   }
   so->so_req = opcode;
 d0294bc:	e0fffa17 	ldw	r3,-24(fp)
 d0294c0:	e0bffe17 	ldw	r2,-8(fp)
 d0294c4:	18800715 	stw	r2,28(r3)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 d0294c8:	e0bffa17 	ldw	r2,-24(fp)
 d0294cc:	10800217 	ldw	r2,8(r2)
 d0294d0:	10800317 	ldw	r2,12(r2)
 d0294d4:	e13ffa17 	ldw	r4,-24(fp)
 d0294d8:	000b883a 	mov	r5,zero
 d0294dc:	e1bff917 	ldw	r6,-28(fp)
 d0294e0:	103ee83a 	callr	r2
 d0294e4:	e0bff815 	stw	r2,-32(fp)
 d0294e8:	e0bff817 	ldw	r2,-32(fp)
 d0294ec:	1004c03a 	cmpne	r2,r2,zero
 d0294f0:	10001a1e 	bne	r2,zero,d02955c <t_getname+0x1ac>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 d0294f4:	e0bffa17 	ldw	r2,-24(fp)
 d0294f8:	10800517 	ldw	r2,20(r2)
 d0294fc:	10800098 	cmpnei	r2,r2,2
 d029500:	1000161e 	bne	r2,zero,d02955c <t_getname+0x1ac>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 d029504:	e0bffd17 	ldw	r2,-12(fp)
 d029508:	10800017 	ldw	r2,0(r2)
 d02950c:	10800428 	cmpgeui	r2,r2,16
 d029510:	1000081e 	bne	r2,zero,d029534 <t_getname+0x184>
      {
         dtrap();    /* programming error */
 d029514:	d025a500 	call	d025a50 <dtrap>
         m_freem(m);
 d029518:	e13ff917 	ldw	r4,-28(fp)
 d02951c:	d026b500 	call	d026b50 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 d029520:	0009883a 	mov	r4,zero
 d029524:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 d029528:	00800584 	movi	r2,22
 d02952c:	e0bfff15 	stw	r2,-4(fp)
 d029530:	00001806 	br	d029594 <t_getname+0x1e4>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 d029534:	e0bff917 	ldw	r2,-28(fp)
 d029538:	10c00317 	ldw	r3,12(r2)
 d02953c:	e0bffc17 	ldw	r2,-16(fp)
 d029540:	1009883a 	mov	r4,r2
 d029544:	180b883a 	mov	r5,r3
 d029548:	01800404 	movi	r6,16
 d02954c:	d0026080 	call	d002608 <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 d029550:	e0fffd17 	ldw	r3,-12(fp)
 d029554:	00800404 	movi	r2,16
 d029558:	18800015 	stw	r2,0(r3)
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 d02955c:	e13ff917 	ldw	r4,-28(fp)
 d029560:	d026b500 	call	d026b50 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d029564:	0009883a 	mov	r4,zero
 d029568:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   if (err) 
 d02956c:	e0bff817 	ldw	r2,-32(fp)
 d029570:	1005003a 	cmpeq	r2,r2,zero
 d029574:	1000061e 	bne	r2,zero,d029590 <t_getname+0x1e0>
   {
      so->so_error = err;
 d029578:	e0fffa17 	ldw	r3,-24(fp)
 d02957c:	e0bff817 	ldw	r2,-32(fp)
 d029580:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d029584:	00bfffc4 	movi	r2,-1
 d029588:	e0bfff15 	stw	r2,-4(fp)
 d02958c:	00000106 	br	d029594 <t_getname+0x1e4>
   }
   return 0;
 d029590:	e03fff15 	stw	zero,-4(fp)
 d029594:	e0bfff17 	ldw	r2,-4(fp)
}
 d029598:	e037883a 	mov	sp,fp
 d02959c:	dfc00117 	ldw	ra,4(sp)
 d0295a0:	df000017 	ldw	fp,0(sp)
 d0295a4:	dec00204 	addi	sp,sp,8
 d0295a8:	f800283a 	ret

0d0295ac <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 d0295ac:	defff604 	addi	sp,sp,-40
 d0295b0:	dfc00915 	stw	ra,36(sp)
 d0295b4:	df000815 	stw	fp,32(sp)
 d0295b8:	df000804 	addi	fp,sp,32
 d0295bc:	e13ffb15 	stw	r4,-20(fp)
 d0295c0:	e17ffc15 	stw	r5,-16(fp)
 d0295c4:	e1bffd15 	stw	r6,-12(fp)
 d0295c8:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 d0295cc:	e0bffb17 	ldw	r2,-20(fp)
 d0295d0:	10bff804 	addi	r2,r2,-32
 d0295d4:	1085883a 	add	r2,r2,r2
 d0295d8:	1085883a 	add	r2,r2,r2
 d0295dc:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d0295e0:	008341b4 	movhi	r2,3334
 d0295e4:	10845704 	addi	r2,r2,4444
 d0295e8:	e0bff815 	stw	r2,-32(fp)
 d0295ec:	00000606 	br	d029608 <t_setsockopt+0x5c>
 d0295f0:	e0fff817 	ldw	r3,-32(fp)
 d0295f4:	e0bffa17 	ldw	r2,-24(fp)
 d0295f8:	18800626 	beq	r3,r2,d029614 <t_setsockopt+0x68>
 d0295fc:	e0bff817 	ldw	r2,-32(fp)
 d029600:	10800017 	ldw	r2,0(r2)
 d029604:	e0bff815 	stw	r2,-32(fp)
 d029608:	e0bff817 	ldw	r2,-32(fp)
 d02960c:	1004c03a 	cmpne	r2,r2,zero
 d029610:	103ff71e 	bne	r2,zero,d0295f0 <t_setsockopt+0x44>
 d029614:	e0fff817 	ldw	r3,-32(fp)
 d029618:	e0bffa17 	ldw	r2,-24(fp)
 d02961c:	18800426 	beq	r3,r2,d029630 <t_setsockopt+0x84>
 d029620:	d025a500 	call	d025a50 <dtrap>
 d029624:	00bfffc4 	movi	r2,-1
 d029628:	e0bfff15 	stw	r2,-4(fp)
 d02962c:	00005006 	br	d029770 <t_setsockopt+0x1c4>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 d029630:	0009883a 	mov	r4,zero
 d029634:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 d029638:	e0bffa17 	ldw	r2,-24(fp)
 d02963c:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 d029640:	e0bffc17 	ldw	r2,-16(fp)
 d029644:	10800060 	cmpeqi	r2,r2,1
 d029648:	1000101e 	bne	r2,zero,d02968c <t_setsockopt+0xe0>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 d02964c:	e13ffa17 	ldw	r4,-24(fp)
 d029650:	e17ffd17 	ldw	r5,-12(fp)
 d029654:	e1bffe17 	ldw	r6,-8(fp)
 d029658:	d02bbe00 	call	d02bbe0 <sosetopt>
 d02965c:	e0bff915 	stw	r2,-28(fp)
 d029660:	e0bff917 	ldw	r2,-28(fp)
 d029664:	1005003a 	cmpeq	r2,r2,zero
 d029668:	10003e1e 	bne	r2,zero,d029764 <t_setsockopt+0x1b8>
      {
         so->so_error = err;
 d02966c:	e0fffa17 	ldw	r3,-24(fp)
 d029670:	e0bff917 	ldw	r2,-28(fp)
 d029674:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 d029678:	0009883a 	mov	r4,zero
 d02967c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d029680:	00bfffc4 	movi	r2,-1
 d029684:	e0bfff15 	stw	r2,-4(fp)
 d029688:	00003906 	br	d029770 <t_setsockopt+0x1c4>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 d02968c:	e0bffa17 	ldw	r2,-24(fp)
 d029690:	10801f17 	ldw	r2,124(r2)
 d029694:	1004c03a 	cmpne	r2,r2,zero
 d029698:	1000111e 	bne	r2,zero,d0296e0 <t_setsockopt+0x134>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 d02969c:	01000104 	movi	r4,4
 d0296a0:	d0264b80 	call	d0264b8 <npalloc>
 d0296a4:	1007883a 	mov	r3,r2
 d0296a8:	e0bffa17 	ldw	r2,-24(fp)
 d0296ac:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 d0296b0:	e0bffa17 	ldw	r2,-24(fp)
 d0296b4:	10801f17 	ldw	r2,124(r2)
 d0296b8:	1004c03a 	cmpne	r2,r2,zero
 d0296bc:	1000081e 	bne	r2,zero,d0296e0 <t_setsockopt+0x134>
         {
            so->so_error = ENOMEM;
 d0296c0:	e0fffa17 	ldw	r3,-24(fp)
 d0296c4:	00800304 	movi	r2,12
 d0296c8:	18800615 	stw	r2,24(r3)
            UNLOCK_NET_RESOURCE (NET_RESID);
 d0296cc:	0009883a 	mov	r4,zero
 d0296d0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 d0296d4:	00bfffc4 	movi	r2,-1
 d0296d8:	e0bfff15 	stw	r2,-4(fp)
 d0296dc:	00002406 	br	d029770 <t_setsockopt+0x1c4>
         }
      }
      
      if (name == IP_TTL_OPT)
 d0296e0:	e0bffd17 	ldw	r2,-12(fp)
 d0296e4:	10800118 	cmpnei	r2,r2,4
 d0296e8:	1000061e 	bne	r2,zero,d029704 <t_setsockopt+0x158>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 d0296ec:	e0bffa17 	ldw	r2,-24(fp)
 d0296f0:	10c01f17 	ldw	r3,124(r2)
 d0296f4:	e0bffe17 	ldw	r2,-8(fp)
 d0296f8:	10800017 	ldw	r2,0(r2)
 d0296fc:	18800045 	stb	r2,1(r3)
 d029700:	00001806 	br	d029764 <t_setsockopt+0x1b8>
      else
      if (name == IP_TOS)
 d029704:	e0bffd17 	ldw	r2,-12(fp)
 d029708:	108000d8 	cmpnei	r2,r2,3
 d02970c:	1000061e 	bne	r2,zero,d029728 <t_setsockopt+0x17c>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 d029710:	e0bffa17 	ldw	r2,-24(fp)
 d029714:	10c01f17 	ldw	r3,124(r2)
 d029718:	e0bffe17 	ldw	r2,-8(fp)
 d02971c:	10800017 	ldw	r2,0(r2)
 d029720:	18800005 	stb	r2,0(r3)
 d029724:	00000f06 	br	d029764 <t_setsockopt+0x1b8>
	   else
	   if (name == IP_SCOPEID)
 d029728:	e0bffd17 	ldw	r2,-12(fp)
 d02972c:	10800398 	cmpnei	r2,r2,14
 d029730:	1000071e 	bne	r2,zero,d029750 <t_setsockopt+0x1a4>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 d029734:	e0bffa17 	ldw	r2,-24(fp)
 d029738:	10c01f17 	ldw	r3,124(r2)
 d02973c:	e0bffe17 	ldw	r2,-8(fp)
 d029740:	10800017 	ldw	r2,0(r2)
 d029744:	10803fcc 	andi	r2,r2,255
 d029748:	18800115 	stw	r2,4(r3)
 d02974c:	00000506 	br	d029764 <t_setsockopt+0x1b8>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 d029750:	0009883a 	mov	r4,zero
 d029754:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d029758:	00bfffc4 	movi	r2,-1
 d02975c:	e0bfff15 	stw	r2,-4(fp)
 d029760:	00000306 	br	d029770 <t_setsockopt+0x1c4>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 d029764:	0009883a 	mov	r4,zero
 d029768:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return 0;
 d02976c:	e03fff15 	stw	zero,-4(fp)
 d029770:	e0bfff17 	ldw	r2,-4(fp)
}
 d029774:	e037883a 	mov	sp,fp
 d029778:	dfc00117 	ldw	ra,4(sp)
 d02977c:	df000017 	ldw	fp,0(sp)
 d029780:	dec00204 	addi	sp,sp,8
 d029784:	f800283a 	ret

0d029788 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 d029788:	defff604 	addi	sp,sp,-40
 d02978c:	dfc00915 	stw	ra,36(sp)
 d029790:	df000815 	stw	fp,32(sp)
 d029794:	df000804 	addi	fp,sp,32
 d029798:	e13ffb15 	stw	r4,-20(fp)
 d02979c:	e17ffc15 	stw	r5,-16(fp)
 d0297a0:	e1bffd15 	stw	r6,-12(fp)
 d0297a4:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 d0297a8:	e0bffb17 	ldw	r2,-20(fp)
 d0297ac:	10bff804 	addi	r2,r2,-32
 d0297b0:	1085883a 	add	r2,r2,r2
 d0297b4:	1085883a 	add	r2,r2,r2
 d0297b8:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d0297bc:	008341b4 	movhi	r2,3334
 d0297c0:	10845704 	addi	r2,r2,4444
 d0297c4:	e0bff815 	stw	r2,-32(fp)
 d0297c8:	00000606 	br	d0297e4 <t_getsockopt+0x5c>
 d0297cc:	e0fff817 	ldw	r3,-32(fp)
 d0297d0:	e0bffa17 	ldw	r2,-24(fp)
 d0297d4:	18800626 	beq	r3,r2,d0297f0 <t_getsockopt+0x68>
 d0297d8:	e0bff817 	ldw	r2,-32(fp)
 d0297dc:	10800017 	ldw	r2,0(r2)
 d0297e0:	e0bff815 	stw	r2,-32(fp)
 d0297e4:	e0bff817 	ldw	r2,-32(fp)
 d0297e8:	1004c03a 	cmpne	r2,r2,zero
 d0297ec:	103ff71e 	bne	r2,zero,d0297cc <t_getsockopt+0x44>
 d0297f0:	e0fff817 	ldw	r3,-32(fp)
 d0297f4:	e0bffa17 	ldw	r2,-24(fp)
 d0297f8:	18800426 	beq	r3,r2,d02980c <t_getsockopt+0x84>
 d0297fc:	d025a500 	call	d025a50 <dtrap>
 d029800:	00bfffc4 	movi	r2,-1
 d029804:	e0bfff15 	stw	r2,-4(fp)
 d029808:	00004206 	br	d029914 <t_getsockopt+0x18c>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 d02980c:	0009883a 	mov	r4,zero
 d029810:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 d029814:	e0bffc17 	ldw	r2,-16(fp)
 d029818:	10800060 	cmpeqi	r2,r2,1
 d02981c:	1000101e 	bne	r2,zero,d029860 <t_getsockopt+0xd8>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 d029820:	e13ffa17 	ldw	r4,-24(fp)
 d029824:	e17ffd17 	ldw	r5,-12(fp)
 d029828:	e1bffe17 	ldw	r6,-8(fp)
 d02982c:	d02c0a00 	call	d02c0a0 <sogetopt>
 d029830:	e0bff915 	stw	r2,-28(fp)
 d029834:	e0bff917 	ldw	r2,-28(fp)
 d029838:	1005003a 	cmpeq	r2,r2,zero
 d02983c:	1000301e 	bne	r2,zero,d029900 <t_getsockopt+0x178>
      {
         so->so_error = err;
 d029840:	e0fffa17 	ldw	r3,-24(fp)
 d029844:	e0bff917 	ldw	r2,-28(fp)
 d029848:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 d02984c:	0009883a 	mov	r4,zero
 d029850:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d029854:	00bfffc4 	movi	r2,-1
 d029858:	e0bfff15 	stw	r2,-4(fp)
 d02985c:	00002d06 	br	d029914 <t_getsockopt+0x18c>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 d029860:	e0bffd17 	ldw	r2,-12(fp)
 d029864:	10800118 	cmpnei	r2,r2,4
 d029868:	10000f1e 	bne	r2,zero,d0298a8 <t_getsockopt+0x120>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 d02986c:	e0bffa17 	ldw	r2,-24(fp)
 d029870:	10801f17 	ldw	r2,124(r2)
 d029874:	1004c03a 	cmpne	r2,r2,zero
 d029878:	1000041e 	bne	r2,zero,d02988c <t_getsockopt+0x104>
 d02987c:	e0fffe17 	ldw	r3,-8(fp)
 d029880:	00801004 	movi	r2,64
 d029884:	18800015 	stw	r2,0(r3)
 d029888:	00001d06 	br	d029900 <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 d02988c:	e0fffe17 	ldw	r3,-8(fp)
 d029890:	e0bffa17 	ldw	r2,-24(fp)
 d029894:	10801f17 	ldw	r2,124(r2)
 d029898:	10800043 	ldbu	r2,1(r2)
 d02989c:	10803fcc 	andi	r2,r2,255
 d0298a0:	18800015 	stw	r2,0(r3)
 d0298a4:	00001606 	br	d029900 <t_getsockopt+0x178>
      }
      else if (name == IP_TOS)
 d0298a8:	e0bffd17 	ldw	r2,-12(fp)
 d0298ac:	108000d8 	cmpnei	r2,r2,3
 d0298b0:	10000e1e 	bne	r2,zero,d0298ec <t_getsockopt+0x164>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 d0298b4:	e0bffa17 	ldw	r2,-24(fp)
 d0298b8:	10801f17 	ldw	r2,124(r2)
 d0298bc:	1004c03a 	cmpne	r2,r2,zero
 d0298c0:	1000031e 	bne	r2,zero,d0298d0 <t_getsockopt+0x148>
 d0298c4:	e0bffe17 	ldw	r2,-8(fp)
 d0298c8:	10000015 	stw	zero,0(r2)
 d0298cc:	00000c06 	br	d029900 <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 d0298d0:	e0fffe17 	ldw	r3,-8(fp)
 d0298d4:	e0bffa17 	ldw	r2,-24(fp)
 d0298d8:	10801f17 	ldw	r2,124(r2)
 d0298dc:	10800003 	ldbu	r2,0(r2)
 d0298e0:	10803fcc 	andi	r2,r2,255
 d0298e4:	18800015 	stw	r2,0(r3)
 d0298e8:	00000506 	br	d029900 <t_getsockopt+0x178>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 d0298ec:	0009883a 	mov	r4,zero
 d0298f0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d0298f4:	00bfffc4 	movi	r2,-1
 d0298f8:	e0bfff15 	stw	r2,-4(fp)
 d0298fc:	00000506 	br	d029914 <t_getsockopt+0x18c>
      }
   }   
   so->so_error = 0;
 d029900:	e0bffa17 	ldw	r2,-24(fp)
 d029904:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 d029908:	0009883a 	mov	r4,zero
 d02990c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return 0;
 d029910:	e03fff15 	stw	zero,-4(fp)
 d029914:	e0bfff17 	ldw	r2,-4(fp)
}
 d029918:	e037883a 	mov	sp,fp
 d02991c:	dfc00117 	ldw	ra,4(sp)
 d029920:	df000017 	ldw	fp,0(sp)
 d029924:	dec00204 	addi	sp,sp,8
 d029928:	f800283a 	ret

0d02992c <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 d02992c:	defff504 	addi	sp,sp,-44
 d029930:	dfc00a15 	stw	ra,40(sp)
 d029934:	df000915 	stw	fp,36(sp)
 d029938:	df000904 	addi	fp,sp,36
 d02993c:	e13ffb15 	stw	r4,-20(fp)
 d029940:	e17ffc15 	stw	r5,-16(fp)
 d029944:	e1bffd15 	stw	r6,-12(fp)
 d029948:	e1fffe15 	stw	r7,-8(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 d02994c:	e0bffd17 	ldw	r2,-12(fp)
 d029950:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 d029954:	e0bffb17 	ldw	r2,-20(fp)
 d029958:	10bff804 	addi	r2,r2,-32
 d02995c:	1085883a 	add	r2,r2,r2
 d029960:	1085883a 	add	r2,r2,r2
 d029964:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 d029968:	e0bffa17 	ldw	r2,-24(fp)
 d02996c:	1080088b 	ldhu	r2,34(r2)
 d029970:	10bfffcc 	andi	r2,r2,65535
 d029974:	1080038c 	andi	r2,r2,14
 d029978:	108000a0 	cmpeqi	r2,r2,2
 d02997c:	1000061e 	bne	r2,zero,d029998 <t_recv+0x6c>
   {
      so->so_error = EPIPE;
 d029980:	e0fffa17 	ldw	r3,-24(fp)
 d029984:	00800804 	movi	r2,32
 d029988:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d02998c:	00bfffc4 	movi	r2,-1
 d029990:	e0bfff15 	stw	r2,-4(fp)
 d029994:	00001b06 	br	d029a04 <t_recv+0xd8>
   }
   so->so_error = 0;
 d029998:	e0bffa17 	ldw	r2,-24(fp)
 d02999c:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 d0299a0:	0009883a 	mov	r4,zero
 d0299a4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 d0299a8:	e1fffd04 	addi	r7,fp,-12
 d0299ac:	e0bffe17 	ldw	r2,-8(fp)
 d0299b0:	d8800015 	stw	r2,0(sp)
 d0299b4:	e13ffa17 	ldw	r4,-24(fp)
 d0299b8:	000b883a 	mov	r5,zero
 d0299bc:	e1bffc17 	ldw	r6,-16(fp)
 d0299c0:	d02b2540 	call	d02b254 <soreceive>
 d0299c4:	e0bff915 	stw	r2,-28(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 d0299c8:	0009883a 	mov	r4,zero
 d0299cc:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if(err)
 d0299d0:	e0bff917 	ldw	r2,-28(fp)
 d0299d4:	1005003a 	cmpeq	r2,r2,zero
 d0299d8:	1000061e 	bne	r2,zero,d0299f4 <t_recv+0xc8>
   {
      so->so_error = err;
 d0299dc:	e0fffa17 	ldw	r3,-24(fp)
 d0299e0:	e0bff917 	ldw	r2,-28(fp)
 d0299e4:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d0299e8:	00bfffc4 	movi	r2,-1
 d0299ec:	e0bfff15 	stw	r2,-4(fp)
 d0299f0:	00000406 	br	d029a04 <t_recv+0xd8>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 d0299f4:	e0fffd17 	ldw	r3,-12(fp)
 d0299f8:	e0bff817 	ldw	r2,-32(fp)
 d0299fc:	10c5c83a 	sub	r2,r2,r3
 d029a00:	e0bfff15 	stw	r2,-4(fp)
 d029a04:	e0bfff17 	ldw	r2,-4(fp)
}
 d029a08:	e037883a 	mov	sp,fp
 d029a0c:	dfc00117 	ldw	ra,4(sp)
 d029a10:	df000017 	ldw	fp,0(sp)
 d029a14:	dec00204 	addi	sp,sp,8
 d029a18:	f800283a 	ret

0d029a1c <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 d029a1c:	defff304 	addi	sp,sp,-52
 d029a20:	dfc00c15 	stw	ra,48(sp)
 d029a24:	df000b15 	stw	fp,44(sp)
 d029a28:	df000b04 	addi	fp,sp,44
 d029a2c:	e13ffb15 	stw	r4,-20(fp)
 d029a30:	e17ffc15 	stw	r5,-16(fp)
 d029a34:	e1bffd15 	stw	r6,-12(fp)
 d029a38:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 d029a3c:	e03ffa15 	stw	zero,-24(fp)
   int   err;
   int   sendlen = len;
 d029a40:	e0bffd17 	ldw	r2,-12(fp)
 d029a44:	e0bff715 	stw	r2,-36(fp)

   so = LONG2SO(s);
 d029a48:	e0bffb17 	ldw	r2,-20(fp)
 d029a4c:	10bff804 	addi	r2,r2,-32
 d029a50:	1085883a 	add	r2,r2,r2
 d029a54:	1085883a 	add	r2,r2,r2
 d029a58:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 d029a5c:	008341b4 	movhi	r2,3334
 d029a60:	10845704 	addi	r2,r2,4444
 d029a64:	e0bff615 	stw	r2,-40(fp)
 d029a68:	00000606 	br	d029a84 <t_recvfrom+0x68>
 d029a6c:	e0fff617 	ldw	r3,-40(fp)
 d029a70:	e0bff917 	ldw	r2,-28(fp)
 d029a74:	18800626 	beq	r3,r2,d029a90 <t_recvfrom+0x74>
 d029a78:	e0bff617 	ldw	r2,-40(fp)
 d029a7c:	10800017 	ldw	r2,0(r2)
 d029a80:	e0bff615 	stw	r2,-40(fp)
 d029a84:	e0bff617 	ldw	r2,-40(fp)
 d029a88:	1004c03a 	cmpne	r2,r2,zero
 d029a8c:	103ff71e 	bne	r2,zero,d029a6c <t_recvfrom+0x50>
 d029a90:	e0fff617 	ldw	r3,-40(fp)
 d029a94:	e0bff917 	ldw	r2,-28(fp)
 d029a98:	18800426 	beq	r3,r2,d029aac <t_recvfrom+0x90>
 d029a9c:	d025a500 	call	d025a50 <dtrap>
 d029aa0:	00bfffc4 	movi	r2,-1
 d029aa4:	e0bfff15 	stw	r2,-4(fp)
 d029aa8:	00002a06 	br	d029b54 <t_recvfrom+0x138>
   so->so_error = 0;
 d029aac:	e0bff917 	ldw	r2,-28(fp)
 d029ab0:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 d029ab4:	0009883a 	mov	r4,zero
 d029ab8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 d029abc:	e17ffa04 	addi	r5,fp,-24
 d029ac0:	e1fffd04 	addi	r7,fp,-12
 d029ac4:	e0bffe17 	ldw	r2,-8(fp)
 d029ac8:	d8800015 	stw	r2,0(sp)
 d029acc:	e13ff917 	ldw	r4,-28(fp)
 d029ad0:	e1bffc17 	ldw	r6,-16(fp)
 d029ad4:	d02b2540 	call	d02b254 <soreceive>
 d029ad8:	e0bff815 	stw	r2,-32(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 d029adc:	e0bffa17 	ldw	r2,-24(fp)
 d029ae0:	1005003a 	cmpeq	r2,r2,zero
 d029ae4:	10000c1e 	bne	r2,zero,d029b18 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 d029ae8:	e0bffa17 	ldw	r2,-24(fp)
 d029aec:	10800317 	ldw	r2,12(r2)
 d029af0:	100b883a 	mov	r5,r2
 d029af4:	e0800317 	ldw	r2,12(fp)
 d029af8:	10800017 	ldw	r2,0(r2)
 d029afc:	1007883a 	mov	r3,r2
 d029b00:	e0800217 	ldw	r2,8(fp)
 d029b04:	1009883a 	mov	r4,r2
 d029b08:	180d883a 	mov	r6,r3
 d029b0c:	d0026080 	call	d002608 <memcpy>
      m_freem (sender);
 d029b10:	e13ffa17 	ldw	r4,-24(fp)
 d029b14:	d026b500 	call	d026b50 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 d029b18:	0009883a 	mov	r4,zero
 d029b1c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if(err)
 d029b20:	e0bff817 	ldw	r2,-32(fp)
 d029b24:	1005003a 	cmpeq	r2,r2,zero
 d029b28:	1000061e 	bne	r2,zero,d029b44 <t_recvfrom+0x128>
   {
      so->so_error = err;
 d029b2c:	e0fff917 	ldw	r3,-28(fp)
 d029b30:	e0bff817 	ldw	r2,-32(fp)
 d029b34:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d029b38:	00bfffc4 	movi	r2,-1
 d029b3c:	e0bfff15 	stw	r2,-4(fp)
 d029b40:	00000406 	br	d029b54 <t_recvfrom+0x138>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 d029b44:	e0fffd17 	ldw	r3,-12(fp)
 d029b48:	e0bff717 	ldw	r2,-36(fp)
 d029b4c:	10c5c83a 	sub	r2,r2,r3
 d029b50:	e0bfff15 	stw	r2,-4(fp)
 d029b54:	e0bfff17 	ldw	r2,-4(fp)
}
 d029b58:	e037883a 	mov	sp,fp
 d029b5c:	dfc00117 	ldw	ra,4(sp)
 d029b60:	df000017 	ldw	fp,0(sp)
 d029b64:	dec00204 	addi	sp,sp,8
 d029b68:	f800283a 	ret

0d029b6c <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 d029b6c:	defff204 	addi	sp,sp,-56
 d029b70:	dfc00d15 	stw	ra,52(sp)
 d029b74:	df000c15 	stw	fp,48(sp)
 d029b78:	df000c04 	addi	fp,sp,48
 d029b7c:	e13ffa15 	stw	r4,-24(fp)
 d029b80:	e17ffb15 	stw	r5,-20(fp)
 d029b84:	e1bffc15 	stw	r6,-16(fp)
 d029b88:	e1fffd15 	stw	r7,-12(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 d029b8c:	e0bffa17 	ldw	r2,-24(fp)
 d029b90:	10bff804 	addi	r2,r2,-32
 d029b94:	1085883a 	add	r2,r2,r2
 d029b98:	1085883a 	add	r2,r2,r2
 d029b9c:	e0bff815 	stw	r2,-32(fp)
   SOC_CHECK(so);
 d029ba0:	008341b4 	movhi	r2,3334
 d029ba4:	10845704 	addi	r2,r2,4444
 d029ba8:	e0bff515 	stw	r2,-44(fp)
 d029bac:	00000606 	br	d029bc8 <t_sendto+0x5c>
 d029bb0:	e0fff517 	ldw	r3,-44(fp)
 d029bb4:	e0bff817 	ldw	r2,-32(fp)
 d029bb8:	18800626 	beq	r3,r2,d029bd4 <t_sendto+0x68>
 d029bbc:	e0bff517 	ldw	r2,-44(fp)
 d029bc0:	10800017 	ldw	r2,0(r2)
 d029bc4:	e0bff515 	stw	r2,-44(fp)
 d029bc8:	e0bff517 	ldw	r2,-44(fp)
 d029bcc:	1004c03a 	cmpne	r2,r2,zero
 d029bd0:	103ff71e 	bne	r2,zero,d029bb0 <t_sendto+0x44>
 d029bd4:	e0fff517 	ldw	r3,-44(fp)
 d029bd8:	e0bff817 	ldw	r2,-32(fp)
 d029bdc:	18800426 	beq	r3,r2,d029bf0 <t_sendto+0x84>
 d029be0:	d025a500 	call	d025a50 <dtrap>
 d029be4:	00bfffc4 	movi	r2,-1
 d029be8:	e0bfff15 	stw	r2,-4(fp)
 d029bec:	00006406 	br	d029d80 <t_sendto+0x214>
   so->so_error = 0;
 d029bf0:	e0bff817 	ldw	r2,-32(fp)
 d029bf4:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 d029bf8:	e0bff817 	ldw	r2,-32(fp)
 d029bfc:	10800983 	ldbu	r2,38(r2)
 d029c00:	10803fcc 	andi	r2,r2,255
 d029c04:	1080201c 	xori	r2,r2,128
 d029c08:	10bfe004 	addi	r2,r2,-128
 d029c0c:	e0bffe15 	stw	r2,-8(fp)
 d029c10:	e0fffe17 	ldw	r3,-8(fp)
 d029c14:	188000a0 	cmpeqi	r2,r3,2
 d029c18:	10000e1e 	bne	r2,zero,d029c54 <t_sendto+0xe8>
 d029c1c:	e0fffe17 	ldw	r3,-8(fp)
 d029c20:	188000e0 	cmpeqi	r2,r3,3
 d029c24:	10000e1e 	bne	r2,zero,d029c60 <t_sendto+0xf4>
 d029c28:	e0fffe17 	ldw	r3,-8(fp)
 d029c2c:	18800060 	cmpeqi	r2,r3,1
 d029c30:	1000011e 	bne	r2,zero,d029c38 <t_sendto+0xcc>
 d029c34:	00001006 	br	d029c78 <t_sendto+0x10c>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 d029c38:	e13ffa17 	ldw	r4,-24(fp)
 d029c3c:	e17ffb17 	ldw	r5,-20(fp)
 d029c40:	e1bffc17 	ldw	r6,-16(fp)
 d029c44:	e1fffd17 	ldw	r7,-12(fp)
 d029c48:	d029d980 	call	d029d98 <t_send>
 d029c4c:	e0bfff15 	stw	r2,-4(fp)
 d029c50:	00004b06 	br	d029d80 <t_sendto+0x214>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 d029c54:	d0454dc0 	call	d0454dc <udp_maxalloc>
 d029c58:	e0bff915 	stw	r2,-28(fp)
      break;
 d029c5c:	00000d06 	br	d029c94 <t_sendto+0x128>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 d029c60:	e0bff817 	ldw	r2,-32(fp)
 d029c64:	10800417 	ldw	r2,16(r2)
 d029c68:	1108000c 	andi	r4,r2,8192
 d029c6c:	d043fac0 	call	d043fac <ip_raw_maxalloc>
 d029c70:	e0bff915 	stw	r2,-28(fp)
      break;
 d029c74:	00000706 	br	d029c94 <t_sendto+0x128>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 d029c78:	d025a500 	call	d025a50 <dtrap>
      so->so_error = EFAULT;
 d029c7c:	e0fff817 	ldw	r3,-32(fp)
 d029c80:	00800384 	movi	r2,14
 d029c84:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d029c88:	00bfffc4 	movi	r2,-1
 d029c8c:	e0bfff15 	stw	r2,-4(fp)
 d029c90:	00003b06 	br	d029d80 <t_sendto+0x214>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 d029c94:	e0fff917 	ldw	r3,-28(fp)
 d029c98:	e0bffc17 	ldw	r2,-16(fp)
 d029c9c:	1880060e 	bge	r3,r2,d029cb8 <t_sendto+0x14c>
   {
      so->so_error = EMSGSIZE;
 d029ca0:	e0fff817 	ldw	r3,-32(fp)
 d029ca4:	00801e84 	movi	r2,122
 d029ca8:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d029cac:	00ffffc4 	movi	r3,-1
 d029cb0:	e0ffff15 	stw	r3,-4(fp)
 d029cb4:	00003206 	br	d029d80 <t_sendto+0x214>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 d029cb8:	e0800217 	ldw	r2,8(fp)
 d029cbc:	1005003a 	cmpeq	r2,r2,zero
 d029cc0:	10000e1e 	bne	r2,zero,d029cfc <t_sendto+0x190>
   {
      name = sockargs(to, tolen, MT_SONAME);
 d029cc4:	e1000217 	ldw	r4,8(fp)
 d029cc8:	e1400317 	ldw	r5,12(fp)
 d029ccc:	01800244 	movi	r6,9
 d029cd0:	d02a1740 	call	d02a174 <sockargs>
 d029cd4:	e0bff615 	stw	r2,-40(fp)
      if(name == NULL)
 d029cd8:	e0bff617 	ldw	r2,-40(fp)
 d029cdc:	1004c03a 	cmpne	r2,r2,zero
 d029ce0:	1000071e 	bne	r2,zero,d029d00 <t_sendto+0x194>
      {
         so->so_error = ENOMEM;
 d029ce4:	e0fff817 	ldw	r3,-32(fp)
 d029ce8:	00800304 	movi	r2,12
 d029cec:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 d029cf0:	00bfffc4 	movi	r2,-1
 d029cf4:	e0bfff15 	stw	r2,-4(fp)
 d029cf8:	00002106 	br	d029d80 <t_sendto+0x214>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 d029cfc:	e03ff615 	stw	zero,-40(fp)
   
   sendlen = len;
 d029d00:	e0bffc17 	ldw	r2,-16(fp)
 d029d04:	e0bff915 	stw	r2,-28(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 d029d08:	0009883a 	mov	r4,zero
 d029d0c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 d029d10:	e1fff904 	addi	r7,fp,-28
 d029d14:	e0bffd17 	ldw	r2,-12(fp)
 d029d18:	d8800015 	stw	r2,0(sp)
 d029d1c:	e13ff817 	ldw	r4,-32(fp)
 d029d20:	e17ff617 	ldw	r5,-40(fp)
 d029d24:	e1bffb17 	ldw	r6,-20(fp)
 d029d28:	d02ac4c0 	call	d02ac4c <sosend>
 d029d2c:	e0bff715 	stw	r2,-36(fp)

   if (name)
 d029d30:	e0bff617 	ldw	r2,-40(fp)
 d029d34:	1005003a 	cmpeq	r2,r2,zero
 d029d38:	1000021e 	bne	r2,zero,d029d44 <t_sendto+0x1d8>
      m_freem(name);
 d029d3c:	e13ff617 	ldw	r4,-40(fp)
 d029d40:	d026b500 	call	d026b50 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d029d44:	0009883a 	mov	r4,zero
 d029d48:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 d029d4c:	e0bff717 	ldw	r2,-36(fp)
 d029d50:	1005003a 	cmpeq	r2,r2,zero
 d029d54:	1000061e 	bne	r2,zero,d029d70 <t_sendto+0x204>
   {
      so->so_error = err;
 d029d58:	e0fff817 	ldw	r3,-32(fp)
 d029d5c:	e0bff717 	ldw	r2,-36(fp)
 d029d60:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d029d64:	00ffffc4 	movi	r3,-1
 d029d68:	e0ffff15 	stw	r3,-4(fp)
 d029d6c:	00000406 	br	d029d80 <t_sendto+0x214>
   }

   return (len - sendlen);
 d029d70:	e0fff917 	ldw	r3,-28(fp)
 d029d74:	e0bffc17 	ldw	r2,-16(fp)
 d029d78:	10c5c83a 	sub	r2,r2,r3
 d029d7c:	e0bfff15 	stw	r2,-4(fp)
 d029d80:	e0bfff17 	ldw	r2,-4(fp)
}
 d029d84:	e037883a 	mov	sp,fp
 d029d88:	dfc00117 	ldw	ra,4(sp)
 d029d8c:	df000017 	ldw	fp,0(sp)
 d029d90:	dec00204 	addi	sp,sp,8
 d029d94:	f800283a 	ret

0d029d98 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 d029d98:	defff004 	addi	sp,sp,-64
 d029d9c:	dfc00f15 	stw	ra,60(sp)
 d029da0:	df000e15 	stw	fp,56(sp)
 d029da4:	df000e04 	addi	fp,sp,56
 d029da8:	e13ffb15 	stw	r4,-20(fp)
 d029dac:	e17ffc15 	stw	r5,-16(fp)
 d029db0:	e1bffd15 	stw	r6,-12(fp)
 d029db4:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 d029db8:	e03ff715 	stw	zero,-36(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 d029dbc:	e0bffb17 	ldw	r2,-20(fp)
 d029dc0:	10bff804 	addi	r2,r2,-32
 d029dc4:	1085883a 	add	r2,r2,r2
 d029dc8:	1085883a 	add	r2,r2,r2
 d029dcc:	e0bff915 	stw	r2,-28(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 d029dd0:	e0bff917 	ldw	r2,-28(fp)
 d029dd4:	1080088b 	ldhu	r2,34(r2)
 d029dd8:	10bfffcc 	andi	r2,r2,65535
 d029ddc:	1080038c 	andi	r2,r2,14
 d029de0:	108000a0 	cmpeqi	r2,r2,2
 d029de4:	1000061e 	bne	r2,zero,d029e00 <t_send+0x68>
   {
      so->so_error = EPIPE;
 d029de8:	e0fff917 	ldw	r3,-28(fp)
 d029dec:	00800804 	movi	r2,32
 d029df0:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d029df4:	00bfffc4 	movi	r2,-1
 d029df8:	e0bfff15 	stw	r2,-4(fp)
 d029dfc:	00006a06 	br	d029fa8 <t_send+0x210>
   }
   so->so_error = 0;
 d029e00:	e0bff917 	ldw	r2,-28(fp)
 d029e04:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 d029e08:	e0bff917 	ldw	r2,-28(fp)
 d029e0c:	10800983 	ldbu	r2,38(r2)
 d029e10:	10803fcc 	andi	r2,r2,255
 d029e14:	1080201c 	xori	r2,r2,128
 d029e18:	10bfe004 	addi	r2,r2,-128
 d029e1c:	10800060 	cmpeqi	r2,r2,1
 d029e20:	1000091e 	bne	r2,zero,d029e48 <t_send+0xb0>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 d029e24:	d8000015 	stw	zero,0(sp)
 d029e28:	d8000115 	stw	zero,4(sp)
 d029e2c:	e13ffb17 	ldw	r4,-20(fp)
 d029e30:	e17ffc17 	ldw	r5,-16(fp)
 d029e34:	e1bffd17 	ldw	r6,-12(fp)
 d029e38:	e1fffe17 	ldw	r7,-8(fp)
 d029e3c:	d029b6c0 	call	d029b6c <t_sendto>
 d029e40:	e0bfff15 	stw	r2,-4(fp)
 d029e44:	00005806 	br	d029fa8 <t_send+0x210>

   maxpkt = TCP_MSS;
 d029e48:	00816d04 	movi	r2,1460
 d029e4c:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 d029e50:	e0bff917 	ldw	r2,-28(fp)
 d029e54:	10800117 	ldw	r2,4(r2)
 d029e58:	1005003a 	cmpeq	r2,r2,zero
 d029e5c:	10004d1e 	bne	r2,zero,d029f94 <t_send+0x1fc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 d029e60:	e0bff917 	ldw	r2,-28(fp)
 d029e64:	10800117 	ldw	r2,4(r2)
 d029e68:	10800917 	ldw	r2,36(r2)
 d029e6c:	e0bff415 	stw	r2,-48(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 d029e70:	e0bff417 	ldw	r2,-48(fp)
 d029e74:	10800a0b 	ldhu	r2,40(r2)
 d029e78:	10bfffcc 	andi	r2,r2,65535
 d029e7c:	1005003a 	cmpeq	r2,r2,zero
 d029e80:	1000441e 	bne	r2,zero,d029f94 <t_send+0x1fc>
         maxpkt = tp->t_maxseg;
 d029e84:	e0bff417 	ldw	r2,-48(fp)
 d029e88:	10800a0b 	ldhu	r2,40(r2)
 d029e8c:	10bfffcc 	andi	r2,r2,65535
 d029e90:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 d029e94:	00003f06 	br	d029f94 <t_send+0x1fc>
   {
      if (len > maxpkt)
 d029e98:	e0fffd17 	ldw	r3,-12(fp)
 d029e9c:	e0bff617 	ldw	r2,-40(fp)
 d029ea0:	10c0030e 	bge	r2,r3,d029eb0 <t_send+0x118>
         sendlen = maxpkt;  /* take biggest block we can */
 d029ea4:	e0bff617 	ldw	r2,-40(fp)
 d029ea8:	e0bffa15 	stw	r2,-24(fp)
 d029eac:	00000206 	br	d029eb8 <t_send+0x120>
      else
         sendlen = len;
 d029eb0:	e0bffd17 	ldw	r2,-12(fp)
 d029eb4:	e0bffa15 	stw	r2,-24(fp)
      sent = sendlen;
 d029eb8:	e0bffa17 	ldw	r2,-24(fp)
 d029ebc:	e0bff515 	stw	r2,-44(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 d029ec0:	0009883a 	mov	r4,zero
 d029ec4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 d029ec8:	e1fffa04 	addi	r7,fp,-24
 d029ecc:	e0bffe17 	ldw	r2,-8(fp)
 d029ed0:	d8800015 	stw	r2,0(sp)
 d029ed4:	e13ff917 	ldw	r4,-28(fp)
 d029ed8:	000b883a 	mov	r5,zero
 d029edc:	e1bffc17 	ldw	r6,-16(fp)
 d029ee0:	d02ac4c0 	call	d02ac4c <sosend>
 d029ee4:	e0bff815 	stw	r2,-32(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 d029ee8:	0009883a 	mov	r4,zero
 d029eec:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 d029ef0:	e0bff817 	ldw	r2,-32(fp)
 d029ef4:	1005003a 	cmpeq	r2,r2,zero
 d029ef8:	1000121e 	bne	r2,zero,d029f44 <t_send+0x1ac>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 d029efc:	e0bff817 	ldw	r2,-32(fp)
 d029f00:	10801a60 	cmpeqi	r2,r2,105
 d029f04:	1000031e 	bne	r2,zero,d029f14 <t_send+0x17c>
 d029f08:	e0bff817 	ldw	r2,-32(fp)
 d029f0c:	108002d8 	cmpnei	r2,r2,11
 d029f10:	1000061e 	bne	r2,zero,d029f2c <t_send+0x194>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 d029f14:	e0bff717 	ldw	r2,-36(fp)
 d029f18:	1005003a 	cmpeq	r2,r2,zero
 d029f1c:	1000031e 	bne	r2,zero,d029f2c <t_send+0x194>
            {
               so->so_error = 0;
 d029f20:	e0bff917 	ldw	r2,-28(fp)
 d029f24:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 d029f28:	00001d06 	br	d029fa0 <t_send+0x208>
            }
         }
         so->so_error = e;
 d029f2c:	e0fff917 	ldw	r3,-28(fp)
 d029f30:	e0bff817 	ldw	r2,-32(fp)
 d029f34:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 d029f38:	00bfffc4 	movi	r2,-1
 d029f3c:	e0bfff15 	stw	r2,-4(fp)
 d029f40:	00001906 	br	d029fa8 <t_send+0x210>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 d029f44:	e0bffa17 	ldw	r2,-24(fp)
 d029f48:	1004c03a 	cmpne	r2,r2,zero
 d029f4c:	1000141e 	bne	r2,zero,d029fa0 <t_send+0x208>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 d029f50:	e0fffa17 	ldw	r3,-24(fp)
 d029f54:	e0bff517 	ldw	r2,-44(fp)
 d029f58:	10c5c83a 	sub	r2,r2,r3
 d029f5c:	e0bff515 	stw	r2,-44(fp)
      buf += sent;
 d029f60:	e0bff517 	ldw	r2,-44(fp)
 d029f64:	1007883a 	mov	r3,r2
 d029f68:	e0bffc17 	ldw	r2,-16(fp)
 d029f6c:	10c5883a 	add	r2,r2,r3
 d029f70:	e0bffc15 	stw	r2,-16(fp)
      len -= sent;
 d029f74:	e0fffd17 	ldw	r3,-12(fp)
 d029f78:	e0bff517 	ldw	r2,-44(fp)
 d029f7c:	1885c83a 	sub	r2,r3,r2
 d029f80:	e0bffd15 	stw	r2,-12(fp)
      total_sent += sent;
 d029f84:	e0fff717 	ldw	r3,-36(fp)
 d029f88:	e0bff517 	ldw	r2,-44(fp)
 d029f8c:	1885883a 	add	r2,r3,r2
 d029f90:	e0bff715 	stw	r2,-36(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 d029f94:	e0bffd17 	ldw	r2,-12(fp)
 d029f98:	1004c03a 	cmpne	r2,r2,zero
 d029f9c:	103fbe1e 	bne	r2,zero,d029e98 <t_send+0x100>
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 d029fa0:	e0bff717 	ldw	r2,-36(fp)
 d029fa4:	e0bfff15 	stw	r2,-4(fp)
 d029fa8:	e0bfff17 	ldw	r2,-4(fp)
}
 d029fac:	e037883a 	mov	sp,fp
 d029fb0:	dfc00117 	ldw	ra,4(sp)
 d029fb4:	df000017 	ldw	fp,0(sp)
 d029fb8:	dec00204 	addi	sp,sp,8
 d029fbc:	f800283a 	ret

0d029fc0 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 d029fc0:	defff804 	addi	sp,sp,-32
 d029fc4:	dfc00715 	stw	ra,28(sp)
 d029fc8:	df000615 	stw	fp,24(sp)
 d029fcc:	df000604 	addi	fp,sp,24
 d029fd0:	e13ffd15 	stw	r4,-12(fp)
 d029fd4:	e17ffe15 	stw	r5,-8(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 d029fd8:	e0bffd17 	ldw	r2,-12(fp)
 d029fdc:	10bff804 	addi	r2,r2,-32
 d029fe0:	1085883a 	add	r2,r2,r2
 d029fe4:	1085883a 	add	r2,r2,r2
 d029fe8:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 d029fec:	008341b4 	movhi	r2,3334
 d029ff0:	10845704 	addi	r2,r2,4444
 d029ff4:	e0bffa15 	stw	r2,-24(fp)
 d029ff8:	00000606 	br	d02a014 <t_shutdown+0x54>
 d029ffc:	e0fffa17 	ldw	r3,-24(fp)
 d02a000:	e0bffc17 	ldw	r2,-16(fp)
 d02a004:	18800626 	beq	r3,r2,d02a020 <t_shutdown+0x60>
 d02a008:	e0bffa17 	ldw	r2,-24(fp)
 d02a00c:	10800017 	ldw	r2,0(r2)
 d02a010:	e0bffa15 	stw	r2,-24(fp)
 d02a014:	e0bffa17 	ldw	r2,-24(fp)
 d02a018:	1004c03a 	cmpne	r2,r2,zero
 d02a01c:	103ff71e 	bne	r2,zero,d029ffc <t_shutdown+0x3c>
 d02a020:	e0fffa17 	ldw	r3,-24(fp)
 d02a024:	e0bffc17 	ldw	r2,-16(fp)
 d02a028:	18800426 	beq	r3,r2,d02a03c <t_shutdown+0x7c>
 d02a02c:	d025a500 	call	d025a50 <dtrap>
 d02a030:	00bfffc4 	movi	r2,-1
 d02a034:	e0bfff15 	stw	r2,-4(fp)
 d02a038:	00001406 	br	d02a08c <t_shutdown+0xcc>
   so->so_error = 0;
 d02a03c:	e0bffc17 	ldw	r2,-16(fp)
 d02a040:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 d02a044:	0009883a 	mov	r4,zero
 d02a048:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 d02a04c:	e13ffc17 	ldw	r4,-16(fp)
 d02a050:	e17ffe17 	ldw	r5,-8(fp)
 d02a054:	d02ba380 	call	d02ba38 <soshutdown>
 d02a058:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02a05c:	0009883a 	mov	r4,zero
 d02a060:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 d02a064:	e0bffb17 	ldw	r2,-20(fp)
 d02a068:	1005003a 	cmpeq	r2,r2,zero
 d02a06c:	1000061e 	bne	r2,zero,d02a088 <t_shutdown+0xc8>
   {
      so->so_error = err;
 d02a070:	e0fffc17 	ldw	r3,-16(fp)
 d02a074:	e0bffb17 	ldw	r2,-20(fp)
 d02a078:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02a07c:	00bfffc4 	movi	r2,-1
 d02a080:	e0bfff15 	stw	r2,-4(fp)
 d02a084:	00000106 	br	d02a08c <t_shutdown+0xcc>
   }
   return 0;
 d02a088:	e03fff15 	stw	zero,-4(fp)
 d02a08c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a090:	e037883a 	mov	sp,fp
 d02a094:	dfc00117 	ldw	ra,4(sp)
 d02a098:	df000017 	ldw	fp,0(sp)
 d02a09c:	dec00204 	addi	sp,sp,8
 d02a0a0:	f800283a 	ret

0d02a0a4 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 d02a0a4:	defff904 	addi	sp,sp,-28
 d02a0a8:	dfc00615 	stw	ra,24(sp)
 d02a0ac:	df000515 	stw	fp,20(sp)
 d02a0b0:	df000504 	addi	fp,sp,20
 d02a0b4:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 d02a0b8:	e0bffe17 	ldw	r2,-8(fp)
 d02a0bc:	10bff804 	addi	r2,r2,-32
 d02a0c0:	1085883a 	add	r2,r2,r2
 d02a0c4:	1085883a 	add	r2,r2,r2
 d02a0c8:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 d02a0cc:	008341b4 	movhi	r2,3334
 d02a0d0:	10845704 	addi	r2,r2,4444
 d02a0d4:	e0bffb15 	stw	r2,-20(fp)
 d02a0d8:	00000606 	br	d02a0f4 <t_socketclose+0x50>
 d02a0dc:	e0fffb17 	ldw	r3,-20(fp)
 d02a0e0:	e0bffd17 	ldw	r2,-12(fp)
 d02a0e4:	18800626 	beq	r3,r2,d02a100 <t_socketclose+0x5c>
 d02a0e8:	e0bffb17 	ldw	r2,-20(fp)
 d02a0ec:	10800017 	ldw	r2,0(r2)
 d02a0f0:	e0bffb15 	stw	r2,-20(fp)
 d02a0f4:	e0bffb17 	ldw	r2,-20(fp)
 d02a0f8:	1004c03a 	cmpne	r2,r2,zero
 d02a0fc:	103ff71e 	bne	r2,zero,d02a0dc <t_socketclose+0x38>
 d02a100:	e0fffb17 	ldw	r3,-20(fp)
 d02a104:	e0bffd17 	ldw	r2,-12(fp)
 d02a108:	18800426 	beq	r3,r2,d02a11c <t_socketclose+0x78>
 d02a10c:	d025a500 	call	d025a50 <dtrap>
 d02a110:	00bfffc4 	movi	r2,-1
 d02a114:	e0bfff15 	stw	r2,-4(fp)
 d02a118:	00001006 	br	d02a15c <t_socketclose+0xb8>
   so->so_error = 0;
 d02a11c:	e0bffd17 	ldw	r2,-12(fp)
 d02a120:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 d02a124:	0009883a 	mov	r4,zero
 d02a128:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   err = soclose(so);
 d02a12c:	e13ffd17 	ldw	r4,-12(fp)
 d02a130:	d02a6f00 	call	d02a6f0 <soclose>
 d02a134:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02a138:	0009883a 	mov	r4,zero
 d02a13c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 d02a140:	e0bffc17 	ldw	r2,-16(fp)
 d02a144:	1005003a 	cmpeq	r2,r2,zero
 d02a148:	1000031e 	bne	r2,zero,d02a158 <t_socketclose+0xb4>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 d02a14c:	00bfffc4 	movi	r2,-1
 d02a150:	e0bfff15 	stw	r2,-4(fp)
 d02a154:	00000106 	br	d02a15c <t_socketclose+0xb8>
   }
   return 0;
 d02a158:	e03fff15 	stw	zero,-4(fp)
 d02a15c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a160:	e037883a 	mov	sp,fp
 d02a164:	dfc00117 	ldw	ra,4(sp)
 d02a168:	df000017 	ldw	fp,0(sp)
 d02a16c:	dec00204 	addi	sp,sp,8
 d02a170:	f800283a 	ret

0d02a174 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 d02a174:	defff904 	addi	sp,sp,-28
 d02a178:	dfc00615 	stw	ra,24(sp)
 d02a17c:	df000515 	stw	fp,20(sp)
 d02a180:	df000504 	addi	fp,sp,20
 d02a184:	e13ffc15 	stw	r4,-16(fp)
 d02a188:	e17ffd15 	stw	r5,-12(fp)
 d02a18c:	e1bffe15 	stw	r6,-8(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 d02a190:	0009883a 	mov	r4,zero
 d02a194:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 d02a198:	e13ffe17 	ldw	r4,-8(fp)
 d02a19c:	e17ffd17 	ldw	r5,-12(fp)
 d02a1a0:	d0268740 	call	d026874 <m_getnbuf>
 d02a1a4:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02a1a8:	0009883a 	mov	r4,zero
 d02a1ac:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 d02a1b0:	e0bffb17 	ldw	r2,-20(fp)
 d02a1b4:	1004c03a 	cmpne	r2,r2,zero
 d02a1b8:	1000021e 	bne	r2,zero,d02a1c4 <sockargs+0x50>
      return NULL;
 d02a1bc:	e03fff15 	stw	zero,-4(fp)
 d02a1c0:	00000c06 	br	d02a1f4 <sockargs+0x80>
   m->m_len = arglen;
 d02a1c4:	e0fffd17 	ldw	r3,-12(fp)
 d02a1c8:	e0bffb17 	ldw	r2,-20(fp)
 d02a1cc:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 d02a1d0:	e0bffb17 	ldw	r2,-20(fp)
 d02a1d4:	10c00317 	ldw	r3,12(r2)
 d02a1d8:	e1bffd17 	ldw	r6,-12(fp)
 d02a1dc:	e0bffc17 	ldw	r2,-16(fp)
 d02a1e0:	1809883a 	mov	r4,r3
 d02a1e4:	100b883a 	mov	r5,r2
 d02a1e8:	d0026080 	call	d002608 <memcpy>
   return m;
 d02a1ec:	e0bffb17 	ldw	r2,-20(fp)
 d02a1f0:	e0bfff15 	stw	r2,-4(fp)
 d02a1f4:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a1f8:	e037883a 	mov	sp,fp
 d02a1fc:	dfc00117 	ldw	ra,4(sp)
 d02a200:	df000017 	ldw	fp,0(sp)
 d02a204:	dec00204 	addi	sp,sp,8
 d02a208:	f800283a 	ret

0d02a20c <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 d02a20c:	defffa04 	addi	sp,sp,-24
 d02a210:	dfc00515 	stw	ra,20(sp)
 d02a214:	df000415 	stw	fp,16(sp)
 d02a218:	df000404 	addi	fp,sp,16
 d02a21c:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 d02a220:	e0bfff17 	ldw	r2,-4(fp)
 d02a224:	10bff804 	addi	r2,r2,-32
 d02a228:	1085883a 	add	r2,r2,r2
 d02a22c:	1085883a 	add	r2,r2,r2
 d02a230:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 d02a234:	00801b04 	movi	r2,108
 d02a238:	e0bffc15 	stw	r2,-16(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 d02a23c:	0009883a 	mov	r4,zero
 d02a240:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 d02a244:	008341b4 	movhi	r2,3334
 d02a248:	10845704 	addi	r2,r2,4444
 d02a24c:	e0bffd15 	stw	r2,-12(fp)
 d02a250:	00000a06 	br	d02a27c <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 d02a254:	e0fffd17 	ldw	r3,-12(fp)
 d02a258:	e0bffe17 	ldw	r2,-8(fp)
 d02a25c:	1880041e 	bne	r3,r2,d02a270 <t_errno+0x64>
      {
         errcode = so->so_error;
 d02a260:	e0bffe17 	ldw	r2,-8(fp)
 d02a264:	10800617 	ldw	r2,24(r2)
 d02a268:	e0bffc15 	stw	r2,-16(fp)
         break;
 d02a26c:	00000606 	br	d02a288 <t_errno+0x7c>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 d02a270:	e0bffd17 	ldw	r2,-12(fp)
 d02a274:	10800017 	ldw	r2,0(r2)
 d02a278:	e0bffd15 	stw	r2,-12(fp)
 d02a27c:	e0bffd17 	ldw	r2,-12(fp)
 d02a280:	1004c03a 	cmpne	r2,r2,zero
 d02a284:	103ff31e 	bne	r2,zero,d02a254 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02a288:	0009883a 	mov	r4,zero
 d02a28c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   return errcode;
 d02a290:	e0bffc17 	ldw	r2,-16(fp)
}
 d02a294:	e037883a 	mov	sp,fp
 d02a298:	dfc00117 	ldw	ra,4(sp)
 d02a29c:	df000017 	ldw	fp,0(sp)
 d02a2a0:	dec00204 	addi	sp,sp,8
 d02a2a4:	f800283a 	ret

0d02a2a8 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 d02a2a8:	defff604 	addi	sp,sp,-40
 d02a2ac:	dfc00915 	stw	ra,36(sp)
 d02a2b0:	df000815 	stw	fp,32(sp)
 d02a2b4:	df000804 	addi	fp,sp,32
 d02a2b8:	e13ffc15 	stw	r4,-16(fp)
 d02a2bc:	e17ffd15 	stw	r5,-12(fp)
 d02a2c0:	e1bffe15 	stw	r6,-8(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 d02a2c4:	e0bffe17 	ldw	r2,-8(fp)
 d02a2c8:	1005003a 	cmpeq	r2,r2,zero
 d02a2cc:	1000061e 	bne	r2,zero,d02a2e8 <socreate+0x40>
      prp = pffindproto(dom, proto, type);
 d02a2d0:	e13ffc17 	ldw	r4,-16(fp)
 d02a2d4:	e17ffe17 	ldw	r5,-8(fp)
 d02a2d8:	e1bffd17 	ldw	r6,-12(fp)
 d02a2dc:	d0267a40 	call	d0267a4 <pffindproto>
 d02a2e0:	e0bffb15 	stw	r2,-20(fp)
 d02a2e4:	00000406 	br	d02a2f8 <socreate+0x50>
   else
      prp = pffindtype(dom, type);
 d02a2e8:	e13ffc17 	ldw	r4,-16(fp)
 d02a2ec:	e17ffd17 	ldw	r5,-12(fp)
 d02a2f0:	d0267040 	call	d026704 <pffindtype>
 d02a2f4:	e0bffb15 	stw	r2,-20(fp)
   if (prp == 0)
 d02a2f8:	e0bffb17 	ldw	r2,-20(fp)
 d02a2fc:	1004c03a 	cmpne	r2,r2,zero
 d02a300:	1000021e 	bne	r2,zero,d02a30c <socreate+0x64>
      return NULL;
 d02a304:	e03fff15 	stw	zero,-4(fp)
 d02a308:	00005406 	br	d02a45c <socreate+0x1b4>
   if (prp->pr_type != type)
 d02a30c:	e0bffb17 	ldw	r2,-20(fp)
 d02a310:	1080000b 	ldhu	r2,0(r2)
 d02a314:	10ffffcc 	andi	r3,r2,65535
 d02a318:	18e0001c 	xori	r3,r3,32768
 d02a31c:	18e00004 	addi	r3,r3,-32768
 d02a320:	e0bffd17 	ldw	r2,-12(fp)
 d02a324:	18800226 	beq	r3,r2,d02a330 <socreate+0x88>
      return NULL;
 d02a328:	e03fff15 	stw	zero,-4(fp)
 d02a32c:	00004b06 	br	d02a45c <socreate+0x1b4>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 d02a330:	01002104 	movi	r4,132
 d02a334:	d0264b80 	call	d0264b8 <npalloc>
 d02a338:	e0bffa15 	stw	r2,-24(fp)
 d02a33c:	e0bffa17 	ldw	r2,-24(fp)
 d02a340:	1004c03a 	cmpne	r2,r2,zero
 d02a344:	1000021e 	bne	r2,zero,d02a350 <socreate+0xa8>
      return NULL;
 d02a348:	e03fff15 	stw	zero,-4(fp)
 d02a34c:	00004306 	br	d02a45c <socreate+0x1b4>
   so->next = NULL;
 d02a350:	e0bffa17 	ldw	r2,-24(fp)
 d02a354:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 d02a358:	e17ffa17 	ldw	r5,-24(fp)
 d02a35c:	010341b4 	movhi	r4,3334
 d02a360:	21045704 	addi	r4,r4,4444
 d02a364:	d0253e00 	call	d0253e0 <putq>

   so->so_options = socket_defaults;
 d02a368:	d0a03b0b 	ldhu	r2,-32532(gp)
 d02a36c:	10ffffcc 	andi	r3,r2,65535
 d02a370:	e0bffa17 	ldw	r2,-24(fp)
 d02a374:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 d02a378:	e0fffa17 	ldw	r3,-24(fp)
 d02a37c:	e0bffc17 	ldw	r2,-16(fp)
 d02a380:	18800515 	stw	r2,20(r3)
   so->so_state = 0;
 d02a384:	e0bffa17 	ldw	r2,-24(fp)
 d02a388:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 d02a38c:	e0bffd17 	ldw	r2,-12(fp)
 d02a390:	1007883a 	mov	r3,r2
 d02a394:	e0bffa17 	ldw	r2,-24(fp)
 d02a398:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 d02a39c:	e0fffa17 	ldw	r3,-24(fp)
 d02a3a0:	e0bffb17 	ldw	r2,-20(fp)
 d02a3a4:	18800215 	stw	r2,8(r3)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 d02a3a8:	e0bffa17 	ldw	r2,-24(fp)
 d02a3ac:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 d02a3b0:	e0bffa17 	ldw	r2,-24(fp)
 d02a3b4:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 d02a3b8:	e0bffb17 	ldw	r2,-20(fp)
 d02a3bc:	10800317 	ldw	r2,12(r2)
 d02a3c0:	e1bffe17 	ldw	r6,-8(fp)
 d02a3c4:	e13ffa17 	ldw	r4,-24(fp)
 d02a3c8:	000b883a 	mov	r5,zero
 d02a3cc:	103ee83a 	callr	r2
 d02a3d0:	e0bff915 	stw	r2,-28(fp)
   if (error) goto bad;
 d02a3d4:	e0bff917 	ldw	r2,-28(fp)
 d02a3d8:	1004c03a 	cmpne	r2,r2,zero
 d02a3dc:	10000f1e 	bne	r2,zero,d02a41c <socreate+0x174>

   if (so_evtmap)
 d02a3e0:	00834174 	movhi	r2,3333
 d02a3e4:	109b6c04 	addi	r2,r2,28080
 d02a3e8:	10800003 	ldbu	r2,0(r2)
 d02a3ec:	10803fcc 	andi	r2,r2,255
 d02a3f0:	1005003a 	cmpeq	r2,r2,zero
 d02a3f4:	1000171e 	bne	r2,zero,d02a454 <socreate+0x1ac>
   {                       
      rc = (*so_evtmap_create) (so);
 d02a3f8:	00834174 	movhi	r2,3333
 d02a3fc:	109b6a04 	addi	r2,r2,28072
 d02a400:	10800017 	ldw	r2,0(r2)
 d02a404:	e13ffa17 	ldw	r4,-24(fp)
 d02a408:	103ee83a 	callr	r2
 d02a40c:	e0bff815 	stw	r2,-32(fp)
      if (rc != 0)
 d02a410:	e0bff817 	ldw	r2,-32(fp)
 d02a414:	1005003a 	cmpeq	r2,r2,zero
 d02a418:	10000a1e 	bne	r2,zero,d02a444 <socreate+0x19c>
      {
bad:   
         so->so_state |= SS_NOFDREF;
 d02a41c:	e0bffa17 	ldw	r2,-24(fp)
 d02a420:	1080088b 	ldhu	r2,34(r2)
 d02a424:	10800054 	ori	r2,r2,1
 d02a428:	1007883a 	mov	r3,r2
 d02a42c:	e0bffa17 	ldw	r2,-24(fp)
 d02a430:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 d02a434:	e13ffa17 	ldw	r4,-24(fp)
 d02a438:	d02a5c00 	call	d02a5c0 <sofree>
         return NULL;   
 d02a43c:	e03fff15 	stw	zero,-4(fp)
 d02a440:	00000606 	br	d02a45c <socreate+0x1b4>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 d02a444:	d02159c0 	call	d02159c <TK_OSTaskQuery>
 d02a448:	1007883a 	mov	r3,r2
 d02a44c:	e0bffa17 	ldw	r2,-24(fp)
 d02a450:	10c02005 	stb	r3,128(r2)
   }

   return so;
 d02a454:	e0bffa17 	ldw	r2,-24(fp)
 d02a458:	e0bfff15 	stw	r2,-4(fp)
 d02a45c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a460:	e037883a 	mov	sp,fp
 d02a464:	dfc00117 	ldw	ra,4(sp)
 d02a468:	df000017 	ldw	fp,0(sp)
 d02a46c:	dec00204 	addi	sp,sp,8
 d02a470:	f800283a 	ret

0d02a474 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 d02a474:	defffb04 	addi	sp,sp,-20
 d02a478:	dfc00415 	stw	ra,16(sp)
 d02a47c:	df000315 	stw	fp,12(sp)
 d02a480:	df000304 	addi	fp,sp,12
 d02a484:	e13ffe15 	stw	r4,-8(fp)
 d02a488:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 d02a48c:	e0fffe17 	ldw	r3,-8(fp)
 d02a490:	00800084 	movi	r2,2
 d02a494:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 d02a498:	e0bffe17 	ldw	r2,-8(fp)
 d02a49c:	10800217 	ldw	r2,8(r2)
 d02a4a0:	10800317 	ldw	r2,12(r2)
 d02a4a4:	e13ffe17 	ldw	r4,-8(fp)
 d02a4a8:	000b883a 	mov	r5,zero
 d02a4ac:	e1bfff17 	ldw	r6,-4(fp)
 d02a4b0:	103ee83a 	callr	r2
 d02a4b4:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 d02a4b8:	e0bffd17 	ldw	r2,-12(fp)
}
 d02a4bc:	e037883a 	mov	sp,fp
 d02a4c0:	dfc00117 	ldw	ra,4(sp)
 d02a4c4:	df000017 	ldw	fp,0(sp)
 d02a4c8:	dec00204 	addi	sp,sp,8
 d02a4cc:	f800283a 	ret

0d02a4d0 <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 d02a4d0:	defff904 	addi	sp,sp,-28
 d02a4d4:	dfc00615 	stw	ra,24(sp)
 d02a4d8:	df000515 	stw	fp,20(sp)
 d02a4dc:	df000504 	addi	fp,sp,20
 d02a4e0:	e13ffc15 	stw	r4,-16(fp)
 d02a4e4:	e17ffd15 	stw	r5,-12(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 d02a4e8:	e0fffc17 	ldw	r3,-16(fp)
 d02a4ec:	008000c4 	movi	r2,3
 d02a4f0:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so,
 d02a4f4:	e0bffc17 	ldw	r2,-16(fp)
 d02a4f8:	10800217 	ldw	r2,8(r2)
 d02a4fc:	10800317 	ldw	r2,12(r2)
 d02a500:	e13ffc17 	ldw	r4,-16(fp)
 d02a504:	000b883a 	mov	r5,zero
 d02a508:	000d883a 	mov	r6,zero
 d02a50c:	103ee83a 	callr	r2
 d02a510:	e0bffb15 	stw	r2,-20(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 d02a514:	e0bffb17 	ldw	r2,-20(fp)
 d02a518:	1005003a 	cmpeq	r2,r2,zero
 d02a51c:	1000031e 	bne	r2,zero,d02a52c <solisten+0x5c>
   {
      return (error);
 d02a520:	e0bffb17 	ldw	r2,-20(fp)
 d02a524:	e0bfff15 	stw	r2,-4(fp)
 d02a528:	00001f06 	br	d02a5a8 <solisten+0xd8>
   }
   if (so->so_q == 0) 
 d02a52c:	e0bffc17 	ldw	r2,-16(fp)
 d02a530:	10801d17 	ldw	r2,116(r2)
 d02a534:	1004c03a 	cmpne	r2,r2,zero
 d02a538:	10000b1e 	bne	r2,zero,d02a568 <solisten+0x98>
   {
      so->so_q = so;
 d02a53c:	e0fffc17 	ldw	r3,-16(fp)
 d02a540:	e0bffc17 	ldw	r2,-16(fp)
 d02a544:	18801d15 	stw	r2,116(r3)
      so->so_q0 = so;
 d02a548:	e0fffc17 	ldw	r3,-16(fp)
 d02a54c:	e0bffc17 	ldw	r2,-16(fp)
 d02a550:	18801c15 	stw	r2,112(r3)
      so->so_options |= SO_ACCEPTCONN;
 d02a554:	e0bffc17 	ldw	r2,-16(fp)
 d02a558:	10800417 	ldw	r2,16(r2)
 d02a55c:	10c00094 	ori	r3,r2,2
 d02a560:	e0bffc17 	ldw	r2,-16(fp)
 d02a564:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 d02a568:	e0bffd17 	ldw	r2,-12(fp)
 d02a56c:	1004403a 	cmpge	r2,r2,zero
 d02a570:	1000011e 	bne	r2,zero,d02a578 <solisten+0xa8>
      backlog = 0;
 d02a574:	e03ffd15 	stw	zero,-12(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 d02a578:	e0fffd17 	ldw	r3,-12(fp)
 d02a57c:	e0fffe15 	stw	r3,-8(fp)
 d02a580:	e0fffe17 	ldw	r3,-8(fp)
 d02a584:	18800190 	cmplti	r2,r3,6
 d02a588:	1000021e 	bne	r2,zero,d02a594 <solisten+0xc4>
 d02a58c:	00800144 	movi	r2,5
 d02a590:	e0bffe15 	stw	r2,-8(fp)
 d02a594:	e0bffe17 	ldw	r2,-8(fp)
 d02a598:	1007883a 	mov	r3,r2
 d02a59c:	e0bffc17 	ldw	r2,-16(fp)
 d02a5a0:	10c01e85 	stb	r3,122(r2)
   return 0;
 d02a5a4:	e03fff15 	stw	zero,-4(fp)
 d02a5a8:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a5ac:	e037883a 	mov	sp,fp
 d02a5b0:	dfc00117 	ldw	ra,4(sp)
 d02a5b4:	df000017 	ldw	fp,0(sp)
 d02a5b8:	dec00204 	addi	sp,sp,8
 d02a5bc:	f800283a 	ret

0d02a5c0 <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 d02a5c0:	defffd04 	addi	sp,sp,-12
 d02a5c4:	dfc00215 	stw	ra,8(sp)
 d02a5c8:	df000115 	stw	fp,4(sp)
 d02a5cc:	df000104 	addi	fp,sp,4
 d02a5d0:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 d02a5d4:	e0bfff17 	ldw	r2,-4(fp)
 d02a5d8:	10800117 	ldw	r2,4(r2)
 d02a5dc:	1004c03a 	cmpne	r2,r2,zero
 d02a5e0:	10003e1e 	bne	r2,zero,d02a6dc <sofree+0x11c>
 d02a5e4:	e0bfff17 	ldw	r2,-4(fp)
 d02a5e8:	1080088b 	ldhu	r2,34(r2)
 d02a5ec:	10bfffcc 	andi	r2,r2,65535
 d02a5f0:	1080004c 	andi	r2,r2,1
 d02a5f4:	1004c03a 	cmpne	r2,r2,zero
 d02a5f8:	1000011e 	bne	r2,zero,d02a600 <sofree+0x40>
      return;
 d02a5fc:	00003706 	br	d02a6dc <sofree+0x11c>
   if (so->so_head) 
 d02a600:	e0bfff17 	ldw	r2,-4(fp)
 d02a604:	10801b17 	ldw	r2,108(r2)
 d02a608:	1005003a 	cmpeq	r2,r2,zero
 d02a60c:	10000f1e 	bne	r2,zero,d02a64c <sofree+0x8c>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 d02a610:	e13fff17 	ldw	r4,-4(fp)
 d02a614:	000b883a 	mov	r5,zero
 d02a618:	d02cb9c0 	call	d02cb9c <soqremque>
 d02a61c:	1004c03a 	cmpne	r2,r2,zero
 d02a620:	1000081e 	bne	r2,zero,d02a644 <sofree+0x84>
 d02a624:	e13fff17 	ldw	r4,-4(fp)
 d02a628:	01400044 	movi	r5,1
 d02a62c:	d02cb9c0 	call	d02cb9c <soqremque>
 d02a630:	1004c03a 	cmpne	r2,r2,zero
 d02a634:	1000031e 	bne	r2,zero,d02a644 <sofree+0x84>
         panic("sofree");
 d02a638:	01034174 	movhi	r4,3333
 d02a63c:	213e8204 	addi	r4,r4,-1528
 d02a640:	d02093c0 	call	d02093c <panic>
      so->so_head = 0;
 d02a644:	e0bfff17 	ldw	r2,-4(fp)
 d02a648:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 d02a64c:	e0bfff17 	ldw	r2,-4(fp)
 d02a650:	11001204 	addi	r4,r2,72
 d02a654:	d02cf780 	call	d02cf78 <sbrelease>
   sorflush(so);
 d02a658:	e13fff17 	ldw	r4,-4(fp)
 d02a65c:	d02bae00 	call	d02bae0 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 d02a660:	e0bfff17 	ldw	r2,-4(fp)
 d02a664:	10800317 	ldw	r2,12(r2)
 d02a668:	1005003a 	cmpeq	r2,r2,zero
 d02a66c:	1000031e 	bne	r2,zero,d02a67c <sofree+0xbc>
	   ip_freemoptions(so->inp_moptions);
 d02a670:	e0bfff17 	ldw	r2,-4(fp)
 d02a674:	11000317 	ldw	r4,12(r2)
 d02a678:	d0468680 	call	d046868 <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 d02a67c:	e0bfff17 	ldw	r2,-4(fp)
 d02a680:	10801f17 	ldw	r2,124(r2)
 d02a684:	1005003a 	cmpeq	r2,r2,zero
 d02a688:	1000031e 	bne	r2,zero,d02a698 <sofree+0xd8>
      SOCOPT_FREE(so->so_optsPack);
 d02a68c:	e0bfff17 	ldw	r2,-4(fp)
 d02a690:	11001f17 	ldw	r4,124(r2)
 d02a694:	d0265ac0 	call	d0265ac <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 d02a698:	010341b4 	movhi	r4,3334
 d02a69c:	21045704 	addi	r4,r4,4444
 d02a6a0:	e17fff17 	ldw	r5,-4(fp)
 d02a6a4:	d0254900 	call	d025490 <qdel>
   
   if (so_evtmap)  
 d02a6a8:	00834174 	movhi	r2,3333
 d02a6ac:	109b6c04 	addi	r2,r2,28080
 d02a6b0:	10800003 	ldbu	r2,0(r2)
 d02a6b4:	10803fcc 	andi	r2,r2,255
 d02a6b8:	1005003a 	cmpeq	r2,r2,zero
 d02a6bc:	1000051e 	bne	r2,zero,d02a6d4 <sofree+0x114>
      (*so_evtmap_delete) (so);
 d02a6c0:	00834174 	movhi	r2,3333
 d02a6c4:	109b6b04 	addi	r2,r2,28076
 d02a6c8:	10800017 	ldw	r2,0(r2)
 d02a6cc:	e13fff17 	ldw	r4,-4(fp)
 d02a6d0:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 d02a6d4:	e13fff17 	ldw	r4,-4(fp)
 d02a6d8:	d0265ac0 	call	d0265ac <npfree>
}
 d02a6dc:	e037883a 	mov	sp,fp
 d02a6e0:	dfc00117 	ldw	ra,4(sp)
 d02a6e4:	df000017 	ldw	fp,0(sp)
 d02a6e8:	dec00204 	addi	sp,sp,8
 d02a6ec:	f800283a 	ret

0d02a6f0 <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 d02a6f0:	defff804 	addi	sp,sp,-32
 d02a6f4:	dfc00715 	stw	ra,28(sp)
 d02a6f8:	df000615 	stw	fp,24(sp)
 d02a6fc:	df000604 	addi	fp,sp,24
 d02a700:	e13ffe15 	stw	r4,-8(fp)
   int   error =  0;
 d02a704:	e03ffd15 	stw	zero,-12(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 d02a708:	008341b4 	movhi	r2,3334
 d02a70c:	10845704 	addi	r2,r2,4444
 d02a710:	10800017 	ldw	r2,0(r2)
 d02a714:	e0bffc15 	stw	r2,-16(fp)
 d02a718:	00000606 	br	d02a734 <soclose+0x44>
   {
      if (so == tmpso)
 d02a71c:	e0fffe17 	ldw	r3,-8(fp)
 d02a720:	e0bffc17 	ldw	r2,-16(fp)
 d02a724:	18800626 	beq	r3,r2,d02a740 <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 d02a728:	e0bffc17 	ldw	r2,-16(fp)
 d02a72c:	10800017 	ldw	r2,0(r2)
 d02a730:	e0bffc15 	stw	r2,-16(fp)
 d02a734:	e0bffc17 	ldw	r2,-16(fp)
 d02a738:	1004c03a 	cmpne	r2,r2,zero
 d02a73c:	103ff71e 	bne	r2,zero,d02a71c <soclose+0x2c>
   {
      if (so == tmpso)
         break;
   }
   if ( tmpso == NULL)
 d02a740:	e0bffc17 	ldw	r2,-16(fp)
 d02a744:	1004c03a 	cmpne	r2,r2,zero
 d02a748:	1000031e 	bne	r2,zero,d02a758 <soclose+0x68>
      return EINVAL;
 d02a74c:	00800584 	movi	r2,22
 d02a750:	e0bfff15 	stw	r2,-4(fp)
 d02a754:	00009f06 	br	d02a9d4 <soclose+0x2e4>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 d02a758:	e0bffe17 	ldw	r2,-8(fp)
 d02a75c:	10800417 	ldw	r2,16(r2)
 d02a760:	1080008c 	andi	r2,r2,2
 d02a764:	1005003a 	cmpeq	r2,r2,zero
 d02a768:	1000101e 	bne	r2,zero,d02a7ac <soclose+0xbc>
   {
      while (so->so_q0 != so)
 d02a76c:	00000306 	br	d02a77c <soclose+0x8c>
         (void) soabort(so->so_q0);
 d02a770:	e0bffe17 	ldw	r2,-8(fp)
 d02a774:	11001c17 	ldw	r4,112(r2)
 d02a778:	d02a9ec0 	call	d02a9ec <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 d02a77c:	e0bffe17 	ldw	r2,-8(fp)
 d02a780:	10c01c17 	ldw	r3,112(r2)
 d02a784:	e0bffe17 	ldw	r2,-8(fp)
 d02a788:	18bff91e 	bne	r3,r2,d02a770 <soclose+0x80>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 d02a78c:	00000306 	br	d02a79c <soclose+0xac>
         (void) soabort(so->so_q);
 d02a790:	e0bffe17 	ldw	r2,-8(fp)
 d02a794:	11001d17 	ldw	r4,116(r2)
 d02a798:	d02a9ec0 	call	d02a9ec <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 d02a79c:	e0bffe17 	ldw	r2,-8(fp)
 d02a7a0:	10c01d17 	ldw	r3,116(r2)
 d02a7a4:	e0bffe17 	ldw	r2,-8(fp)
 d02a7a8:	18bff91e 	bne	r3,r2,d02a790 <soclose+0xa0>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 d02a7ac:	e0bffe17 	ldw	r2,-8(fp)
 d02a7b0:	10800983 	ldbu	r2,38(r2)
 d02a7b4:	10803fcc 	andi	r2,r2,255
 d02a7b8:	1080201c 	xori	r2,r2,128
 d02a7bc:	10bfe004 	addi	r2,r2,-128
 d02a7c0:	10800060 	cmpeqi	r2,r2,1
 d02a7c4:	10000c1e 	bne	r2,zero,d02a7f8 <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 d02a7c8:	e0fffe17 	ldw	r3,-8(fp)
 d02a7cc:	00800044 	movi	r2,1
 d02a7d0:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so,
 d02a7d4:	e0bffe17 	ldw	r2,-8(fp)
 d02a7d8:	10800217 	ldw	r2,8(r2)
 d02a7dc:	10800317 	ldw	r2,12(r2)
 d02a7e0:	e13ffe17 	ldw	r4,-8(fp)
 d02a7e4:	000b883a 	mov	r5,zero
 d02a7e8:	000d883a 	mov	r6,zero
 d02a7ec:	103ee83a 	callr	r2
 d02a7f0:	e0bffd15 	stw	r2,-12(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 d02a7f4:	00006506 	br	d02a98c <soclose+0x29c>
   }

   if (so->so_pcb == 0)
 d02a7f8:	e0bffe17 	ldw	r2,-8(fp)
 d02a7fc:	10800117 	ldw	r2,4(r2)
 d02a800:	1005003a 	cmpeq	r2,r2,zero
 d02a804:	1000611e 	bne	r2,zero,d02a98c <soclose+0x29c>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 d02a808:	e0bffe17 	ldw	r2,-8(fp)
 d02a80c:	1080088b 	ldhu	r2,34(r2)
 d02a810:	10bfffcc 	andi	r2,r2,65535
 d02a814:	1080008c 	andi	r2,r2,2
 d02a818:	1005003a 	cmpeq	r2,r2,zero
 d02a81c:	1000471e 	bne	r2,zero,d02a93c <soclose+0x24c>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 d02a820:	e0bffe17 	ldw	r2,-8(fp)
 d02a824:	1080088b 	ldhu	r2,34(r2)
 d02a828:	10bfffcc 	andi	r2,r2,65535
 d02a82c:	1080020c 	andi	r2,r2,8
 d02a830:	1004c03a 	cmpne	r2,r2,zero
 d02a834:	1000061e 	bne	r2,zero,d02a850 <soclose+0x160>
      {
         error = sodisconnect(so);
 d02a838:	e13ffe17 	ldw	r4,-8(fp)
 d02a83c:	d02abac0 	call	d02abac <sodisconnect>
 d02a840:	e0bffd15 	stw	r2,-12(fp)
         if (error)
 d02a844:	e0bffd17 	ldw	r2,-12(fp)
 d02a848:	1004c03a 	cmpne	r2,r2,zero
 d02a84c:	10003b1e 	bne	r2,zero,d02a93c <soclose+0x24c>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 d02a850:	e0bffe17 	ldw	r2,-8(fp)
 d02a854:	10800417 	ldw	r2,16(r2)
 d02a858:	1080200c 	andi	r2,r2,128
 d02a85c:	1005003a 	cmpeq	r2,r2,zero
 d02a860:	10002a1e 	bne	r2,zero,d02a90c <soclose+0x21c>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 d02a864:	e0bffe17 	ldw	r2,-8(fp)
 d02a868:	1080088b 	ldhu	r2,34(r2)
 d02a86c:	10bfffcc 	andi	r2,r2,65535
 d02a870:	1080020c 	andi	r2,r2,8
 d02a874:	1005003a 	cmpeq	r2,r2,zero
 d02a878:	1000061e 	bne	r2,zero,d02a894 <soclose+0x1a4>
 d02a87c:	e0bffe17 	ldw	r2,-8(fp)
 d02a880:	1080088b 	ldhu	r2,34(r2)
 d02a884:	10bfffcc 	andi	r2,r2,65535
 d02a888:	1080400c 	andi	r2,r2,256
 d02a88c:	1004c03a 	cmpne	r2,r2,zero
 d02a890:	10002a1e 	bne	r2,zero,d02a93c <soclose+0x24c>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 d02a894:	e0bffe17 	ldw	r2,-8(fp)
 d02a898:	1080080b 	ldhu	r2,32(r2)
 d02a89c:	113fffcc 	andi	r4,r2,65535
 d02a8a0:	2120001c 	xori	r4,r4,32768
 d02a8a4:	21200004 	addi	r4,r4,-32768
 d02a8a8:	01401904 	movi	r5,100
 d02a8ac:	d00235c0 	call	d00235c <__mulsi3>
 d02a8b0:	1007883a 	mov	r3,r2
 d02a8b4:	00834174 	movhi	r2,3333
 d02a8b8:	109b4504 	addi	r2,r2,27924
 d02a8bc:	10800017 	ldw	r2,0(r2)
 d02a8c0:	1885883a 	add	r2,r3,r2
 d02a8c4:	e0bffb15 	stw	r2,-20(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 d02a8c8:	00000406 	br	d02a8dc <soclose+0x1ec>
         {
            tcp_sleep((char *)&so->so_timeo);
 d02a8cc:	e0bffe17 	ldw	r2,-8(fp)
 d02a8d0:	10800904 	addi	r2,r2,36
 d02a8d4:	1009883a 	mov	r4,r2
 d02a8d8:	d0212b40 	call	d0212b4 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 d02a8dc:	e0bffe17 	ldw	r2,-8(fp)
 d02a8e0:	1080088b 	ldhu	r2,34(r2)
 d02a8e4:	10bfffcc 	andi	r2,r2,65535
 d02a8e8:	1080008c 	andi	r2,r2,2
 d02a8ec:	1005003a 	cmpeq	r2,r2,zero
 d02a8f0:	1000121e 	bne	r2,zero,d02a93c <soclose+0x24c>
 d02a8f4:	00834174 	movhi	r2,3333
 d02a8f8:	109b4504 	addi	r2,r2,27924
 d02a8fc:	10c00017 	ldw	r3,0(r2)
 d02a900:	e0bffb17 	ldw	r2,-20(fp)
 d02a904:	18bff136 	bltu	r3,r2,d02a8cc <soclose+0x1dc>
 d02a908:	00000c06 	br	d02a93c <soclose+0x24c>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 d02a90c:	e0bffe17 	ldw	r2,-8(fp)
 d02a910:	10801217 	ldw	r2,72(r2)
 d02a914:	1005003a 	cmpeq	r2,r2,zero
 d02a918:	1000081e 	bne	r2,zero,d02a93c <soclose+0x24c>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 d02a91c:	e0bffe17 	ldw	r2,-8(fp)
 d02a920:	1080088b 	ldhu	r2,34(r2)
 d02a924:	10800054 	ori	r2,r2,1
 d02a928:	1007883a 	mov	r3,r2
 d02a92c:	e0bffe17 	ldw	r2,-8(fp)
 d02a930:	10c0088d 	sth	r3,34(r2)
            return 0;
 d02a934:	e03fff15 	stw	zero,-4(fp)
 d02a938:	00002606 	br	d02a9d4 <soclose+0x2e4>
         }
      }
   }
drop:
   if (so->so_pcb) 
 d02a93c:	e0bffe17 	ldw	r2,-8(fp)
 d02a940:	10800117 	ldw	r2,4(r2)
 d02a944:	1005003a 	cmpeq	r2,r2,zero
 d02a948:	1000101e 	bne	r2,zero,d02a98c <soclose+0x29c>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 d02a94c:	e0fffe17 	ldw	r3,-8(fp)
 d02a950:	00800044 	movi	r2,1
 d02a954:	18800715 	stw	r2,28(r3)
      error2 = (*so->so_proto->pr_usrreq)(so,
 d02a958:	e0bffe17 	ldw	r2,-8(fp)
 d02a95c:	10800217 	ldw	r2,8(r2)
 d02a960:	10800317 	ldw	r2,12(r2)
 d02a964:	e13ffe17 	ldw	r4,-8(fp)
 d02a968:	000b883a 	mov	r5,zero
 d02a96c:	000d883a 	mov	r6,zero
 d02a970:	103ee83a 	callr	r2
 d02a974:	e0bffa15 	stw	r2,-24(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 d02a978:	e0bffd17 	ldw	r2,-12(fp)
 d02a97c:	1004c03a 	cmpne	r2,r2,zero
 d02a980:	1000021e 	bne	r2,zero,d02a98c <soclose+0x29c>
         error = error2;
 d02a984:	e0bffa17 	ldw	r2,-24(fp)
 d02a988:	e0bffd15 	stw	r2,-12(fp)
   }
discard:
   if (so->so_state & SS_NOFDREF)
 d02a98c:	e0bffe17 	ldw	r2,-8(fp)
 d02a990:	1080088b 	ldhu	r2,34(r2)
 d02a994:	10bfffcc 	andi	r2,r2,65535
 d02a998:	1080004c 	andi	r2,r2,1
 d02a99c:	10803fcc 	andi	r2,r2,255
 d02a9a0:	1005003a 	cmpeq	r2,r2,zero
 d02a9a4:	1000011e 	bne	r2,zero,d02a9ac <soclose+0x2bc>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 d02a9a8:	d025a500 	call	d025a50 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 d02a9ac:	e0bffe17 	ldw	r2,-8(fp)
 d02a9b0:	1080088b 	ldhu	r2,34(r2)
 d02a9b4:	10800054 	ori	r2,r2,1
 d02a9b8:	1007883a 	mov	r3,r2
 d02a9bc:	e0bffe17 	ldw	r2,-8(fp)
 d02a9c0:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 d02a9c4:	e13ffe17 	ldw	r4,-8(fp)
 d02a9c8:	d02a5c00 	call	d02a5c0 <sofree>
   return (error);
 d02a9cc:	e0bffd17 	ldw	r2,-12(fp)
 d02a9d0:	e0bfff15 	stw	r2,-4(fp)
 d02a9d4:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a9d8:	e037883a 	mov	sp,fp
 d02a9dc:	dfc00117 	ldw	ra,4(sp)
 d02a9e0:	df000017 	ldw	fp,0(sp)
 d02a9e4:	dec00204 	addi	sp,sp,8
 d02a9e8:	f800283a 	ret

0d02a9ec <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 d02a9ec:	defffd04 	addi	sp,sp,-12
 d02a9f0:	dfc00215 	stw	ra,8(sp)
 d02a9f4:	df000115 	stw	fp,4(sp)
 d02a9f8:	df000104 	addi	fp,sp,4
 d02a9fc:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 d02aa00:	e0ffff17 	ldw	r3,-4(fp)
 d02aa04:	00800284 	movi	r2,10
 d02aa08:	18800715 	stw	r2,28(r3)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 d02aa0c:	e0bfff17 	ldw	r2,-4(fp)
 d02aa10:	10800217 	ldw	r2,8(r2)
 d02aa14:	10800317 	ldw	r2,12(r2)
 d02aa18:	e13fff17 	ldw	r4,-4(fp)
 d02aa1c:	000b883a 	mov	r5,zero
 d02aa20:	000d883a 	mov	r6,zero
 d02aa24:	103ee83a 	callr	r2
}
 d02aa28:	e037883a 	mov	sp,fp
 d02aa2c:	dfc00117 	ldw	ra,4(sp)
 d02aa30:	df000017 	ldw	fp,0(sp)
 d02aa34:	dec00204 	addi	sp,sp,8
 d02aa38:	f800283a 	ret

0d02aa3c <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 d02aa3c:	defffb04 	addi	sp,sp,-20
 d02aa40:	dfc00415 	stw	ra,16(sp)
 d02aa44:	df000315 	stw	fp,12(sp)
 d02aa48:	df000304 	addi	fp,sp,12
 d02aa4c:	e13ffe15 	stw	r4,-8(fp)
 d02aa50:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 d02aa54:	e0bffe17 	ldw	r2,-8(fp)
 d02aa58:	1080088b 	ldhu	r2,34(r2)
 d02aa5c:	10bfffcc 	andi	r2,r2,65535
 d02aa60:	1080004c 	andi	r2,r2,1
 d02aa64:	1004c03a 	cmpne	r2,r2,zero
 d02aa68:	1000031e 	bne	r2,zero,d02aa78 <soaccept+0x3c>
      panic("soaccept");
 d02aa6c:	01034174 	movhi	r4,3333
 d02aa70:	213e8404 	addi	r4,r4,-1520
 d02aa74:	d02093c0 	call	d02093c <panic>
   so->so_state &= ~SS_NOFDREF;
 d02aa78:	e0bffe17 	ldw	r2,-8(fp)
 d02aa7c:	10c0088b 	ldhu	r3,34(r2)
 d02aa80:	00bfff84 	movi	r2,-2
 d02aa84:	1884703a 	and	r2,r3,r2
 d02aa88:	1007883a 	mov	r3,r2
 d02aa8c:	e0bffe17 	ldw	r2,-8(fp)
 d02aa90:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 d02aa94:	e0fffe17 	ldw	r3,-8(fp)
 d02aa98:	00800144 	movi	r2,5
 d02aa9c:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 d02aaa0:	e0bffe17 	ldw	r2,-8(fp)
 d02aaa4:	10800217 	ldw	r2,8(r2)
 d02aaa8:	10800317 	ldw	r2,12(r2)
 d02aaac:	e13ffe17 	ldw	r4,-8(fp)
 d02aab0:	000b883a 	mov	r5,zero
 d02aab4:	e1bfff17 	ldw	r6,-4(fp)
 d02aab8:	103ee83a 	callr	r2
 d02aabc:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 d02aac0:	e0bffd17 	ldw	r2,-12(fp)
}
 d02aac4:	e037883a 	mov	sp,fp
 d02aac8:	dfc00117 	ldw	ra,4(sp)
 d02aacc:	df000017 	ldw	fp,0(sp)
 d02aad0:	dec00204 	addi	sp,sp,8
 d02aad4:	f800283a 	ret

0d02aad8 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 d02aad8:	defffa04 	addi	sp,sp,-24
 d02aadc:	dfc00515 	stw	ra,20(sp)
 d02aae0:	df000415 	stw	fp,16(sp)
 d02aae4:	df000404 	addi	fp,sp,16
 d02aae8:	e13ffd15 	stw	r4,-12(fp)
 d02aaec:	e17ffe15 	stw	r5,-8(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 d02aaf0:	e0bffd17 	ldw	r2,-12(fp)
 d02aaf4:	10800417 	ldw	r2,16(r2)
 d02aaf8:	1080008c 	andi	r2,r2,2
 d02aafc:	1005003a 	cmpeq	r2,r2,zero
 d02ab00:	1000031e 	bne	r2,zero,d02ab10 <soconnect+0x38>
      return (EOPNOTSUPP);
 d02ab04:	008017c4 	movi	r2,95
 d02ab08:	e0bfff15 	stw	r2,-4(fp)
 d02ab0c:	00002106 	br	d02ab94 <soconnect+0xbc>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 d02ab10:	e0bffd17 	ldw	r2,-12(fp)
 d02ab14:	1080088b 	ldhu	r2,34(r2)
 d02ab18:	10bfffcc 	andi	r2,r2,65535
 d02ab1c:	1080018c 	andi	r2,r2,6
 d02ab20:	1005003a 	cmpeq	r2,r2,zero
 d02ab24:	10000e1e 	bne	r2,zero,d02ab60 <soconnect+0x88>
 d02ab28:	e0bffd17 	ldw	r2,-12(fp)
 d02ab2c:	10800217 	ldw	r2,8(r2)
 d02ab30:	1080010b 	ldhu	r2,4(r2)
 d02ab34:	10bfffcc 	andi	r2,r2,65535
 d02ab38:	1080010c 	andi	r2,r2,4
 d02ab3c:	1004c03a 	cmpne	r2,r2,zero
 d02ab40:	1000041e 	bne	r2,zero,d02ab54 <soconnect+0x7c>
 d02ab44:	e13ffd17 	ldw	r4,-12(fp)
 d02ab48:	d02abac0 	call	d02abac <sodisconnect>
 d02ab4c:	1005003a 	cmpeq	r2,r2,zero
 d02ab50:	1000031e 	bne	r2,zero,d02ab60 <soconnect+0x88>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 d02ab54:	00801fc4 	movi	r2,127
 d02ab58:	e0bffc15 	stw	r2,-16(fp)
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 d02ab5c:	00000b06 	br	d02ab8c <soconnect+0xb4>
   {
      error = EISCONN;
   }
   else
   {
      so->so_req = PRU_CONNECT;
 d02ab60:	e0fffd17 	ldw	r3,-12(fp)
 d02ab64:	00800104 	movi	r2,4
 d02ab68:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 d02ab6c:	e0bffd17 	ldw	r2,-12(fp)
 d02ab70:	10800217 	ldw	r2,8(r2)
 d02ab74:	10800317 	ldw	r2,12(r2)
 d02ab78:	e13ffd17 	ldw	r4,-12(fp)
 d02ab7c:	000b883a 	mov	r5,zero
 d02ab80:	e1bffe17 	ldw	r6,-8(fp)
 d02ab84:	103ee83a 	callr	r2
 d02ab88:	e0bffc15 	stw	r2,-16(fp)
   }
   return error;
 d02ab8c:	e0bffc17 	ldw	r2,-16(fp)
 d02ab90:	e0bfff15 	stw	r2,-4(fp)
 d02ab94:	e0bfff17 	ldw	r2,-4(fp)
}
 d02ab98:	e037883a 	mov	sp,fp
 d02ab9c:	dfc00117 	ldw	ra,4(sp)
 d02aba0:	df000017 	ldw	fp,0(sp)
 d02aba4:	dec00204 	addi	sp,sp,8
 d02aba8:	f800283a 	ret

0d02abac <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 d02abac:	defffc04 	addi	sp,sp,-16
 d02abb0:	dfc00315 	stw	ra,12(sp)
 d02abb4:	df000215 	stw	fp,8(sp)
 d02abb8:	df000204 	addi	fp,sp,8
 d02abbc:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 d02abc0:	e0bfff17 	ldw	r2,-4(fp)
 d02abc4:	1080088b 	ldhu	r2,34(r2)
 d02abc8:	10bfffcc 	andi	r2,r2,65535
 d02abcc:	1080008c 	andi	r2,r2,2
 d02abd0:	1004c03a 	cmpne	r2,r2,zero
 d02abd4:	1000031e 	bne	r2,zero,d02abe4 <sodisconnect+0x38>
   {
      error = ENOTCONN;
 d02abd8:	00802004 	movi	r2,128
 d02abdc:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 d02abe0:	00001406 	br	d02ac34 <sodisconnect+0x88>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 d02abe4:	e0bfff17 	ldw	r2,-4(fp)
 d02abe8:	1080088b 	ldhu	r2,34(r2)
 d02abec:	10bfffcc 	andi	r2,r2,65535
 d02abf0:	1080020c 	andi	r2,r2,8
 d02abf4:	1005003a 	cmpeq	r2,r2,zero
 d02abf8:	1000031e 	bne	r2,zero,d02ac08 <sodisconnect+0x5c>
   {
      error = EALREADY;
 d02abfc:	00801e04 	movi	r2,120
 d02ac00:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 d02ac04:	00000b06 	br	d02ac34 <sodisconnect+0x88>
   }
   so->so_req = PRU_DISCONNECT;
 d02ac08:	e0ffff17 	ldw	r3,-4(fp)
 d02ac0c:	00800184 	movi	r2,6
 d02ac10:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 d02ac14:	e0bfff17 	ldw	r2,-4(fp)
 d02ac18:	10800217 	ldw	r2,8(r2)
 d02ac1c:	10800317 	ldw	r2,12(r2)
 d02ac20:	e13fff17 	ldw	r4,-4(fp)
 d02ac24:	000b883a 	mov	r5,zero
 d02ac28:	000d883a 	mov	r6,zero
 d02ac2c:	103ee83a 	callr	r2
 d02ac30:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 d02ac34:	e0bffe17 	ldw	r2,-8(fp)
}
 d02ac38:	e037883a 	mov	sp,fp
 d02ac3c:	dfc00117 	ldw	ra,4(sp)
 d02ac40:	df000017 	ldw	fp,0(sp)
 d02ac44:	dec00204 	addi	sp,sp,8
 d02ac48:	f800283a 	ret

0d02ac4c <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 d02ac4c:	deffee04 	addi	sp,sp,-72
 d02ac50:	dfc01115 	stw	ra,68(sp)
 d02ac54:	df001015 	stw	fp,64(sp)
 d02ac58:	df001004 	addi	fp,sp,64
 d02ac5c:	e13ff815 	stw	r4,-32(fp)
 d02ac60:	e17ff915 	stw	r5,-28(fp)
 d02ac64:	e1bffa15 	stw	r6,-24(fp)
 d02ac68:	e1fffb15 	stw	r7,-20(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 d02ac6c:	e03ff715 	stw	zero,-36(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 d02ac70:	e03ff215 	stw	zero,-56(fp)
   int   dontroute;
   int   first = 1;
 d02ac74:	00800044 	movi	r2,1
 d02ac78:	e0bff015 	stw	r2,-64(fp)

   resid = *data_length;
 d02ac7c:	e0bffb17 	ldw	r2,-20(fp)
 d02ac80:	10800017 	ldw	r2,0(r2)
 d02ac84:	e0bff415 	stw	r2,-48(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 d02ac88:	e0bff417 	ldw	r2,-48(fp)
 d02ac8c:	1004403a 	cmpge	r2,r2,zero
 d02ac90:	1000031e 	bne	r2,zero,d02aca0 <sosend+0x54>
      return (EINVAL);
 d02ac94:	00800584 	movi	r2,22
 d02ac98:	e0bfff15 	stw	r2,-4(fp)
 d02ac9c:	00016706 	br	d02b23c <sosend+0x5f0>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 d02aca0:	e0bff817 	ldw	r2,-32(fp)
 d02aca4:	10800217 	ldw	r2,8(r2)
 d02aca8:	1080010b 	ldhu	r2,4(r2)
 d02acac:	10bfffcc 	andi	r2,r2,65535
 d02acb0:	1080004c 	andi	r2,r2,1
 d02acb4:	10803fcc 	andi	r2,r2,255
 d02acb8:	1005003a 	cmpeq	r2,r2,zero
 d02acbc:	1000081e 	bne	r2,zero,d02ace0 <sosend+0x94>
 d02acc0:	e0bff817 	ldw	r2,-32(fp)
 d02acc4:	10801317 	ldw	r2,76(r2)
 d02acc8:	1007883a 	mov	r3,r2
 d02accc:	e0bff417 	ldw	r2,-48(fp)
 d02acd0:	1880030e 	bge	r3,r2,d02ace0 <sosend+0x94>
      return (EMSGSIZE);
 d02acd4:	00c01e84 	movi	r3,122
 d02acd8:	e0ffff15 	stw	r3,-4(fp)
 d02acdc:	00015706 	br	d02b23c <sosend+0x5f0>

   dontroute = (flags & MSG_DONTROUTE) &&
 d02ace0:	e0800217 	ldw	r2,8(fp)
 d02ace4:	1080010c 	andi	r2,r2,4
 d02ace8:	1005003a 	cmpeq	r2,r2,zero
 d02acec:	1000111e 	bne	r2,zero,d02ad34 <sosend+0xe8>
 d02acf0:	e0bff817 	ldw	r2,-32(fp)
 d02acf4:	10800417 	ldw	r2,16(r2)
 d02acf8:	1080040c 	andi	r2,r2,16
 d02acfc:	1004c03a 	cmpne	r2,r2,zero
 d02ad00:	10000c1e 	bne	r2,zero,d02ad34 <sosend+0xe8>
 d02ad04:	e0bff817 	ldw	r2,-32(fp)
 d02ad08:	10800217 	ldw	r2,8(r2)
 d02ad0c:	1080010b 	ldhu	r2,4(r2)
 d02ad10:	10bfffcc 	andi	r2,r2,65535
 d02ad14:	1080004c 	andi	r2,r2,1
 d02ad18:	1080005c 	xori	r2,r2,1
 d02ad1c:	10803fcc 	andi	r2,r2,255
 d02ad20:	1004c03a 	cmpne	r2,r2,zero
 d02ad24:	1000031e 	bne	r2,zero,d02ad34 <sosend+0xe8>
 d02ad28:	00800044 	movi	r2,1
 d02ad2c:	e0bffe15 	stw	r2,-8(fp)
 d02ad30:	00000106 	br	d02ad38 <sosend+0xec>
 d02ad34:	e03ffe15 	stw	zero,-8(fp)
 d02ad38:	e0fffe17 	ldw	r3,-8(fp)
 d02ad3c:	e0fff115 	stw	r3,-60(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 d02ad40:	00000406 	br	d02ad54 <sosend+0x108>
 d02ad44:	e0bff817 	ldw	r2,-32(fp)
 d02ad48:	10801904 	addi	r2,r2,100
 d02ad4c:	1009883a 	mov	r4,r2
 d02ad50:	d0212b40 	call	d0212b4 <tcp_sleep>
 d02ad54:	e0bff817 	ldw	r2,-32(fp)
 d02ad58:	1080190b 	ldhu	r2,100(r2)
 d02ad5c:	10bfffcc 	andi	r2,r2,65535
 d02ad60:	1080004c 	andi	r2,r2,1
 d02ad64:	10803fcc 	andi	r2,r2,255
 d02ad68:	1004c03a 	cmpne	r2,r2,zero
 d02ad6c:	103ff51e 	bne	r2,zero,d02ad44 <sosend+0xf8>
 d02ad70:	e0bff817 	ldw	r2,-32(fp)
 d02ad74:	1080190b 	ldhu	r2,100(r2)
 d02ad78:	10800054 	ori	r2,r2,1
 d02ad7c:	1007883a 	mov	r3,r2
 d02ad80:	e0bff817 	ldw	r2,-32(fp)
 d02ad84:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 d02ad88:	e0bff817 	ldw	r2,-32(fp)
 d02ad8c:	10800617 	ldw	r2,24(r2)
 d02ad90:	1005003a 	cmpeq	r2,r2,zero
 d02ad94:	1000061e 	bne	r2,zero,d02adb0 <sosend+0x164>
      {
         error = so->so_error;
 d02ad98:	e0bff817 	ldw	r2,-32(fp)
 d02ad9c:	10800617 	ldw	r2,24(r2)
 d02ada0:	e0bff215 	stw	r2,-56(fp)
         so->so_error = 0;          /* ??? */
 d02ada4:	e0bff817 	ldw	r2,-32(fp)
 d02ada8:	10000615 	stw	zero,24(r2)
         goto release;
 d02adac:	00011106 	br	d02b1f4 <sosend+0x5a8>
      }
      if (so->so_state & SS_CANTSENDMORE)
 d02adb0:	e0bff817 	ldw	r2,-32(fp)
 d02adb4:	1080088b 	ldhu	r2,34(r2)
 d02adb8:	10bfffcc 	andi	r2,r2,65535
 d02adbc:	1080040c 	andi	r2,r2,16
 d02adc0:	1005003a 	cmpeq	r2,r2,zero
 d02adc4:	1000031e 	bne	r2,zero,d02add4 <sosend+0x188>
         snderr(EPIPE);
 d02adc8:	00800804 	movi	r2,32
 d02adcc:	e0bff215 	stw	r2,-56(fp)
 d02add0:	00010806 	br	d02b1f4 <sosend+0x5a8>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 d02add4:	e0bff817 	ldw	r2,-32(fp)
 d02add8:	1080088b 	ldhu	r2,34(r2)
 d02addc:	10bfffcc 	andi	r2,r2,65535
 d02ade0:	1080008c 	andi	r2,r2,2
 d02ade4:	1004c03a 	cmpne	r2,r2,zero
 d02ade8:	1000101e 	bne	r2,zero,d02ae2c <sosend+0x1e0>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 d02adec:	e0bff817 	ldw	r2,-32(fp)
 d02adf0:	10800217 	ldw	r2,8(r2)
 d02adf4:	1080010b 	ldhu	r2,4(r2)
 d02adf8:	10bfffcc 	andi	r2,r2,65535
 d02adfc:	1080010c 	andi	r2,r2,4
 d02ae00:	1005003a 	cmpeq	r2,r2,zero
 d02ae04:	1000031e 	bne	r2,zero,d02ae14 <sosend+0x1c8>
            snderr(ENOTCONN);
 d02ae08:	00802004 	movi	r2,128
 d02ae0c:	e0bff215 	stw	r2,-56(fp)
 d02ae10:	0000f806 	br	d02b1f4 <sosend+0x5a8>
         if (nam == 0)
 d02ae14:	e0bff917 	ldw	r2,-28(fp)
 d02ae18:	1004c03a 	cmpne	r2,r2,zero
 d02ae1c:	1000031e 	bne	r2,zero,d02ae2c <sosend+0x1e0>
            snderr(EDESTADDRREQ);
 d02ae20:	00801e44 	movi	r2,121
 d02ae24:	e0bff215 	stw	r2,-56(fp)
 d02ae28:	0000f206 	br	d02b1f4 <sosend+0x5a8>
      }
      if (flags & MSG_OOB)
 d02ae2c:	e0800217 	ldw	r2,8(fp)
 d02ae30:	1080004c 	andi	r2,r2,1
 d02ae34:	10803fcc 	andi	r2,r2,255
 d02ae38:	1005003a 	cmpeq	r2,r2,zero
 d02ae3c:	1000031e 	bne	r2,zero,d02ae4c <sosend+0x200>
         space = 1024;
 d02ae40:	00810004 	movi	r2,1024
 d02ae44:	e0bff515 	stw	r2,-44(fp)
 d02ae48:	00005106 	br	d02af90 <sosend+0x344>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 d02ae4c:	e0bff817 	ldw	r2,-32(fp)
 d02ae50:	10801317 	ldw	r2,76(r2)
 d02ae54:	1007883a 	mov	r3,r2
 d02ae58:	e0bff817 	ldw	r2,-32(fp)
 d02ae5c:	10801217 	ldw	r2,72(r2)
 d02ae60:	1885c83a 	sub	r2,r3,r2
 d02ae64:	1004803a 	cmplt	r2,r2,zero
 d02ae68:	1000071e 	bne	r2,zero,d02ae88 <sosend+0x23c>
 d02ae6c:	e0bff817 	ldw	r2,-32(fp)
 d02ae70:	10c01317 	ldw	r3,76(r2)
 d02ae74:	e0bff817 	ldw	r2,-32(fp)
 d02ae78:	10801217 	ldw	r2,72(r2)
 d02ae7c:	1885c83a 	sub	r2,r3,r2
 d02ae80:	e0bffd15 	stw	r2,-12(fp)
 d02ae84:	00000106 	br	d02ae8c <sosend+0x240>
 d02ae88:	e03ffd15 	stw	zero,-12(fp)
 d02ae8c:	e0bffd17 	ldw	r2,-12(fp)
 d02ae90:	e0bff515 	stw	r2,-44(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 d02ae94:	e0bff817 	ldw	r2,-32(fp)
 d02ae98:	10800217 	ldw	r2,8(r2)
 d02ae9c:	1080010b 	ldhu	r2,4(r2)
 d02aea0:	10bfffcc 	andi	r2,r2,65535
 d02aea4:	1080004c 	andi	r2,r2,1
 d02aea8:	1080005c 	xori	r2,r2,1
 d02aeac:	10803fcc 	andi	r2,r2,255
 d02aeb0:	1004c03a 	cmpne	r2,r2,zero
 d02aeb4:	1000031e 	bne	r2,zero,d02aec4 <sosend+0x278>
 d02aeb8:	e0fff517 	ldw	r3,-44(fp)
 d02aebc:	e0bff417 	ldw	r2,-48(fp)
 d02aec0:	18801416 	blt	r3,r2,d02af14 <sosend+0x2c8>
 d02aec4:	e0bff417 	ldw	r2,-48(fp)
 d02aec8:	10815e10 	cmplti	r2,r2,1400
 d02aecc:	1000301e 	bne	r2,zero,d02af90 <sosend+0x344>
 d02aed0:	e0bff517 	ldw	r2,-44(fp)
 d02aed4:	10815e08 	cmpgei	r2,r2,1400
 d02aed8:	10002d1e 	bne	r2,zero,d02af90 <sosend+0x344>
 d02aedc:	e0bff817 	ldw	r2,-32(fp)
 d02aee0:	10801217 	ldw	r2,72(r2)
 d02aee4:	10815e30 	cmpltui	r2,r2,1400
 d02aee8:	1000291e 	bne	r2,zero,d02af90 <sosend+0x344>
 d02aeec:	e0bff817 	ldw	r2,-32(fp)
 d02aef0:	1080088b 	ldhu	r2,34(r2)
 d02aef4:	10bfffcc 	andi	r2,r2,65535
 d02aef8:	1080400c 	andi	r2,r2,256
 d02aefc:	1004c03a 	cmpne	r2,r2,zero
 d02af00:	1000231e 	bne	r2,zero,d02af90 <sosend+0x344>
 d02af04:	e0800217 	ldw	r2,8(fp)
 d02af08:	1080080c 	andi	r2,r2,32
 d02af0c:	1004c03a 	cmpne	r2,r2,zero
 d02af10:	10001f1e 	bne	r2,zero,d02af90 <sosend+0x344>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 d02af14:	e0bff817 	ldw	r2,-32(fp)
 d02af18:	1080088b 	ldhu	r2,34(r2)
 d02af1c:	10bfffcc 	andi	r2,r2,65535
 d02af20:	1080400c 	andi	r2,r2,256
 d02af24:	1004c03a 	cmpne	r2,r2,zero
 d02af28:	1000041e 	bne	r2,zero,d02af3c <sosend+0x2f0>
 d02af2c:	e0800217 	ldw	r2,8(fp)
 d02af30:	1080080c 	andi	r2,r2,32
 d02af34:	1005003a 	cmpeq	r2,r2,zero
 d02af38:	1000061e 	bne	r2,zero,d02af54 <sosend+0x308>
            {
               if (first)
 d02af3c:	e0bff017 	ldw	r2,-64(fp)
 d02af40:	1005003a 	cmpeq	r2,r2,zero
 d02af44:	1000ab1e 	bne	r2,zero,d02b1f4 <sosend+0x5a8>
                  error = EWOULDBLOCK;
 d02af48:	008002c4 	movi	r2,11
 d02af4c:	e0bff215 	stw	r2,-56(fp)
               goto release;
 d02af50:	0000a806 	br	d02b1f4 <sosend+0x5a8>
            }
            sbunlock(&so->so_snd);
 d02af54:	e0bff817 	ldw	r2,-32(fp)
 d02af58:	10c0190b 	ldhu	r3,100(r2)
 d02af5c:	00bfff84 	movi	r2,-2
 d02af60:	1884703a 	and	r2,r3,r2
 d02af64:	1007883a 	mov	r3,r2
 d02af68:	e0bff817 	ldw	r2,-32(fp)
 d02af6c:	10c0190d 	sth	r3,100(r2)
 d02af70:	e0bff817 	ldw	r2,-32(fp)
 d02af74:	10801904 	addi	r2,r2,100
 d02af78:	1009883a 	mov	r4,r2
 d02af7c:	d02147c0 	call	d02147c <tcp_wakeup>
            sbwait(&so->so_snd);
 d02af80:	e0bff817 	ldw	r2,-32(fp)
 d02af84:	11001204 	addi	r4,r2,72
 d02af88:	d02cd940 	call	d02cd94 <sbwait>
            goto restart;
 d02af8c:	003f7106 	br	d02ad54 <sosend+0x108>
         }
      }
      if ( space <= 0 ) 
 d02af90:	e0bff517 	ldw	r2,-44(fp)
 d02af94:	10800048 	cmpgei	r2,r2,1
 d02af98:	1000651e 	bne	r2,zero,d02b130 <sosend+0x4e4>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 d02af9c:	e0bff817 	ldw	r2,-32(fp)
 d02afa0:	1080088b 	ldhu	r2,34(r2)
 d02afa4:	10bfffcc 	andi	r2,r2,65535
 d02afa8:	1080400c 	andi	r2,r2,256
 d02afac:	1004c03a 	cmpne	r2,r2,zero
 d02afb0:	1000041e 	bne	r2,zero,d02afc4 <sosend+0x378>
 d02afb4:	e0800217 	ldw	r2,8(fp)
 d02afb8:	1080080c 	andi	r2,r2,32
 d02afbc:	1005003a 	cmpeq	r2,r2,zero
 d02afc0:	1000061e 	bne	r2,zero,d02afdc <sosend+0x390>
         {
            if (first)     /* report first error */
 d02afc4:	e0bff017 	ldw	r2,-64(fp)
 d02afc8:	1005003a 	cmpeq	r2,r2,zero
 d02afcc:	1000891e 	bne	r2,zero,d02b1f4 <sosend+0x5a8>
               error = EWOULDBLOCK;
 d02afd0:	008002c4 	movi	r2,11
 d02afd4:	e0bff215 	stw	r2,-56(fp)
            goto release;
 d02afd8:	00008606 	br	d02b1f4 <sosend+0x5a8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 d02afdc:	e0bff817 	ldw	r2,-32(fp)
 d02afe0:	10c0190b 	ldhu	r3,100(r2)
 d02afe4:	00bfff84 	movi	r2,-2
 d02afe8:	1884703a 	and	r2,r3,r2
 d02afec:	1007883a 	mov	r3,r2
 d02aff0:	e0bff817 	ldw	r2,-32(fp)
 d02aff4:	10c0190d 	sth	r3,100(r2)
 d02aff8:	e0bff817 	ldw	r2,-32(fp)
 d02affc:	10801904 	addi	r2,r2,100
 d02b000:	1009883a 	mov	r4,r2
 d02b004:	d02147c0 	call	d02147c <tcp_wakeup>
         sbwait(&so->so_snd);
 d02b008:	e0bff817 	ldw	r2,-32(fp)
 d02b00c:	11001204 	addi	r4,r2,72
 d02b010:	d02cd940 	call	d02cd94 <sbwait>
         goto restart;
 d02b014:	003f4f06 	br	d02ad54 <sosend+0x108>
      }

      while (space > 0) 
      {
         len = resid;
 d02b018:	e0bff417 	ldw	r2,-48(fp)
 d02b01c:	e0bff315 	stw	r2,-52(fp)
         if ( so->so_type == SOCK_STREAM )
 d02b020:	e0bff817 	ldw	r2,-32(fp)
 d02b024:	10800983 	ldbu	r2,38(r2)
 d02b028:	10803fcc 	andi	r2,r2,255
 d02b02c:	1080201c 	xori	r2,r2,128
 d02b030:	10bfe004 	addi	r2,r2,-128
 d02b034:	10800058 	cmpnei	r2,r2,1
 d02b038:	1000181e 	bne	r2,zero,d02b09c <sosend+0x450>
         {
            m = m_getwithdata(MT_TXDATA, len);
 d02b03c:	01000084 	movi	r4,2
 d02b040:	e17ff317 	ldw	r5,-52(fp)
 d02b044:	d0268740 	call	d026874 <m_getnbuf>
 d02b048:	e0bff615 	stw	r2,-40(fp)
            if (!m)   
 d02b04c:	e0bff617 	ldw	r2,-40(fp)
 d02b050:	1004c03a 	cmpne	r2,r2,zero
 d02b054:	1000031e 	bne	r2,zero,d02b064 <sosend+0x418>
               snderr(ENOBUFS);
 d02b058:	00801a44 	movi	r2,105
 d02b05c:	e0bff215 	stw	r2,-56(fp)
 d02b060:	00006406 	br	d02b1f4 <sosend+0x5a8>
            MEMCPY(m->m_data, data, len);
 d02b064:	e0bff617 	ldw	r2,-40(fp)
 d02b068:	10c00317 	ldw	r3,12(r2)
 d02b06c:	e1bff317 	ldw	r6,-52(fp)
 d02b070:	e0bffa17 	ldw	r2,-24(fp)
 d02b074:	1809883a 	mov	r4,r3
 d02b078:	100b883a 	mov	r5,r2
 d02b07c:	d0026080 	call	d002608 <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 d02b080:	e0bff817 	ldw	r2,-32(fp)
 d02b084:	1080190b 	ldhu	r2,100(r2)
 d02b088:	10802014 	ori	r2,r2,128
 d02b08c:	1007883a 	mov	r3,r2
 d02b090:	e0bff817 	ldw	r2,-32(fp)
 d02b094:	10c0190d 	sth	r3,100(r2)
 d02b098:	00000706 	br	d02b0b8 <sosend+0x46c>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 d02b09c:	01000084 	movi	r4,2
 d02b0a0:	000b883a 	mov	r5,zero
 d02b0a4:	d0268740 	call	d026874 <m_getnbuf>
 d02b0a8:	e0bff615 	stw	r2,-40(fp)
            m->m_data = data;
 d02b0ac:	e0fff617 	ldw	r3,-40(fp)
 d02b0b0:	e0bffa17 	ldw	r2,-24(fp)
 d02b0b4:	18800315 	stw	r2,12(r3)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 d02b0b8:	e0bffb17 	ldw	r2,-20(fp)
 d02b0bc:	10c00017 	ldw	r3,0(r2)
 d02b0c0:	e0bff317 	ldw	r2,-52(fp)
 d02b0c4:	1887c83a 	sub	r3,r3,r2
 d02b0c8:	e0bffb17 	ldw	r2,-20(fp)
 d02b0cc:	10c00015 	stw	r3,0(r2)
         resid -= len;
 d02b0d0:	e0fff417 	ldw	r3,-48(fp)
 d02b0d4:	e0bff317 	ldw	r2,-52(fp)
 d02b0d8:	1885c83a 	sub	r2,r3,r2
 d02b0dc:	e0bff415 	stw	r2,-48(fp)
         data += len;
 d02b0e0:	e0bff317 	ldw	r2,-52(fp)
 d02b0e4:	1007883a 	mov	r3,r2
 d02b0e8:	e0bffa17 	ldw	r2,-24(fp)
 d02b0ec:	10c5883a 	add	r2,r2,r3
 d02b0f0:	e0bffa15 	stw	r2,-24(fp)
         m->m_len = len;
 d02b0f4:	e0fff317 	ldw	r3,-52(fp)
 d02b0f8:	e0bff617 	ldw	r2,-40(fp)
 d02b0fc:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 d02b100:	e0bff717 	ldw	r2,-36(fp)
 d02b104:	1004c03a 	cmpne	r2,r2,zero
 d02b108:	1000021e 	bne	r2,zero,d02b114 <sosend+0x4c8>
            head = m;
 d02b10c:	e0bff617 	ldw	r2,-40(fp)
 d02b110:	e0bff715 	stw	r2,-36(fp)
         if (error)
 d02b114:	e0bff217 	ldw	r2,-56(fp)
 d02b118:	1004c03a 	cmpne	r2,r2,zero
 d02b11c:	1000351e 	bne	r2,zero,d02b1f4 <sosend+0x5a8>
            goto release;
         if (*data_length <= 0)
 d02b120:	e0bffb17 	ldw	r2,-20(fp)
 d02b124:	10800017 	ldw	r2,0(r2)
 d02b128:	10800050 	cmplti	r2,r2,1
 d02b12c:	1000031e 	bne	r2,zero,d02b13c <sosend+0x4f0>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 d02b130:	e0bff517 	ldw	r2,-44(fp)
 d02b134:	10800048 	cmpgei	r2,r2,1
 d02b138:	103fb71e 	bne	r2,zero,d02b018 <sosend+0x3cc>
            goto release;
         if (*data_length <= 0)
            break;
      }

      if (dontroute)
 d02b13c:	e0bff117 	ldw	r2,-60(fp)
 d02b140:	1005003a 	cmpeq	r2,r2,zero
 d02b144:	1000051e 	bne	r2,zero,d02b15c <sosend+0x510>
         so->so_options |= SO_DONTROUTE;
 d02b148:	e0bff817 	ldw	r2,-32(fp)
 d02b14c:	10800417 	ldw	r2,16(r2)
 d02b150:	10c00414 	ori	r3,r2,16
 d02b154:	e0bff817 	ldw	r2,-32(fp)
 d02b158:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 d02b15c:	e0800217 	ldw	r2,8(fp)
 d02b160:	1080004c 	andi	r2,r2,1
 d02b164:	10803fcc 	andi	r2,r2,255
 d02b168:	1005003a 	cmpeq	r2,r2,zero
 d02b16c:	1000031e 	bne	r2,zero,d02b17c <sosend+0x530>
 d02b170:	00c00384 	movi	r3,14
 d02b174:	e0fffc15 	stw	r3,-16(fp)
 d02b178:	00000206 	br	d02b184 <sosend+0x538>
 d02b17c:	00800244 	movi	r2,9
 d02b180:	e0bffc15 	stw	r2,-16(fp)
 d02b184:	e0bff817 	ldw	r2,-32(fp)
 d02b188:	e0fffc17 	ldw	r3,-16(fp)
 d02b18c:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 d02b190:	e0bff817 	ldw	r2,-32(fp)
 d02b194:	10800217 	ldw	r2,8(r2)
 d02b198:	10800317 	ldw	r2,12(r2)
 d02b19c:	e13ff817 	ldw	r4,-32(fp)
 d02b1a0:	e17ff717 	ldw	r5,-36(fp)
 d02b1a4:	e1bff917 	ldw	r6,-28(fp)
 d02b1a8:	103ee83a 	callr	r2
 d02b1ac:	e0bff215 	stw	r2,-56(fp)

      if (dontroute)
 d02b1b0:	e0bff117 	ldw	r2,-60(fp)
 d02b1b4:	1005003a 	cmpeq	r2,r2,zero
 d02b1b8:	1000061e 	bne	r2,zero,d02b1d4 <sosend+0x588>
         so->so_options &= ~SO_DONTROUTE;
 d02b1bc:	e0bff817 	ldw	r2,-32(fp)
 d02b1c0:	10c00417 	ldw	r3,16(r2)
 d02b1c4:	00bffbc4 	movi	r2,-17
 d02b1c8:	1886703a 	and	r3,r3,r2
 d02b1cc:	e0bff817 	ldw	r2,-32(fp)
 d02b1d0:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 d02b1d4:	e03ff715 	stw	zero,-36(fp)
      first = 0;
 d02b1d8:	e03ff015 	stw	zero,-64(fp)
   } while ((resid != 0) && (error == 0));
 d02b1dc:	e0bff417 	ldw	r2,-48(fp)
 d02b1e0:	1005003a 	cmpeq	r2,r2,zero
 d02b1e4:	1000031e 	bne	r2,zero,d02b1f4 <sosend+0x5a8>
 d02b1e8:	e0bff217 	ldw	r2,-56(fp)
 d02b1ec:	1005003a 	cmpeq	r2,r2,zero
 d02b1f0:	103ee51e 	bne	r2,zero,d02ad88 <sosend+0x13c>

release:
   sbunlock(&so->so_snd);  
 d02b1f4:	e0bff817 	ldw	r2,-32(fp)
 d02b1f8:	10c0190b 	ldhu	r3,100(r2)
 d02b1fc:	00bfff84 	movi	r2,-2
 d02b200:	1884703a 	and	r2,r3,r2
 d02b204:	1007883a 	mov	r3,r2
 d02b208:	e0bff817 	ldw	r2,-32(fp)
 d02b20c:	10c0190d 	sth	r3,100(r2)
 d02b210:	e0bff817 	ldw	r2,-32(fp)
 d02b214:	10801904 	addi	r2,r2,100
 d02b218:	1009883a 	mov	r4,r2
 d02b21c:	d02147c0 	call	d02147c <tcp_wakeup>
   if (head)
 d02b220:	e0bff717 	ldw	r2,-36(fp)
 d02b224:	1005003a 	cmpeq	r2,r2,zero
 d02b228:	1000021e 	bne	r2,zero,d02b234 <sosend+0x5e8>
      m_freem(head);
 d02b22c:	e13ff717 	ldw	r4,-36(fp)
 d02b230:	d026b500 	call	d026b50 <m_freem>
   return error;
 d02b234:	e0bff217 	ldw	r2,-56(fp)
 d02b238:	e0bfff15 	stw	r2,-4(fp)
 d02b23c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02b240:	e037883a 	mov	sp,fp
 d02b244:	dfc00117 	ldw	ra,4(sp)
 d02b248:	df000017 	ldw	fp,0(sp)
 d02b24c:	dec00204 	addi	sp,sp,8
 d02b250:	f800283a 	ret

0d02b254 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 d02b254:	defff104 	addi	sp,sp,-60
 d02b258:	dfc00e15 	stw	ra,56(sp)
 d02b25c:	df000d15 	stw	fp,52(sp)
 d02b260:	df000d04 	addi	fp,sp,52
 d02b264:	e13ffb15 	stw	r4,-20(fp)
 d02b268:	e17ffc15 	stw	r5,-16(fp)
 d02b26c:	e1bffd15 	stw	r6,-12(fp)
 d02b270:	e1fffe15 	stw	r7,-8(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 d02b274:	e03ff815 	stw	zero,-32(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 d02b278:	e0bffb17 	ldw	r2,-20(fp)
 d02b27c:	10800217 	ldw	r2,8(r2)
 d02b280:	e0bff615 	stw	r2,-40(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 d02b284:	e0bffc17 	ldw	r2,-16(fp)
 d02b288:	1005003a 	cmpeq	r2,r2,zero
 d02b28c:	1000021e 	bne	r2,zero,d02b298 <soreceive+0x44>
      *aname = 0;
 d02b290:	e0bffc17 	ldw	r2,-16(fp)
 d02b294:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 d02b298:	e0800217 	ldw	r2,8(fp)
 d02b29c:	1080004c 	andi	r2,r2,1
 d02b2a0:	10803fcc 	andi	r2,r2,255
 d02b2a4:	1005003a 	cmpeq	r2,r2,zero
 d02b2a8:	10004d1e 	bne	r2,zero,d02b3e0 <soreceive+0x18c>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 d02b2ac:	01000044 	movi	r4,1
 d02b2b0:	000b883a 	mov	r5,zero
 d02b2b4:	d0268740 	call	d026874 <m_getnbuf>
 d02b2b8:	e0bffa15 	stw	r2,-24(fp)
      if (m == NULL)
 d02b2bc:	e0bffa17 	ldw	r2,-24(fp)
 d02b2c0:	1004c03a 	cmpne	r2,r2,zero
 d02b2c4:	1000031e 	bne	r2,zero,d02b2d4 <soreceive+0x80>
         return ENOBUFS;
 d02b2c8:	00801a44 	movi	r2,105
 d02b2cc:	e0bfff15 	stw	r2,-4(fp)
 d02b2d0:	0001d306 	br	d02ba20 <soreceive+0x7cc>
      lflags = flags & MSG_PEEK;
 d02b2d4:	e0800217 	ldw	r2,8(fp)
 d02b2d8:	1080008c 	andi	r2,r2,2
 d02b2dc:	e0bff315 	stw	r2,-52(fp)

      so->so_req = PRU_RCVOOB;
 d02b2e0:	e0fffb17 	ldw	r3,-20(fp)
 d02b2e4:	00800344 	movi	r2,13
 d02b2e8:	18800715 	stw	r2,28(r3)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 d02b2ec:	e0bff617 	ldw	r2,-40(fp)
 d02b2f0:	10800317 	ldw	r2,12(r2)
 d02b2f4:	e1bff317 	ldw	r6,-52(fp)
 d02b2f8:	e13ffb17 	ldw	r4,-20(fp)
 d02b2fc:	e17ffa17 	ldw	r5,-24(fp)
 d02b300:	103ee83a 	callr	r2
 d02b304:	e0bff815 	stw	r2,-32(fp)
      if (error == 0)
 d02b308:	e0bff817 	ldw	r2,-32(fp)
 d02b30c:	1004c03a 	cmpne	r2,r2,zero
 d02b310:	1000271e 	bne	r2,zero,d02b3b0 <soreceive+0x15c>
      {
         do 
         {
            len = *datalen;
 d02b314:	e0bffe17 	ldw	r2,-8(fp)
 d02b318:	10800017 	ldw	r2,0(r2)
 d02b31c:	e0bff915 	stw	r2,-28(fp)
            if (len > (int)m->m_len)
 d02b320:	e0bffa17 	ldw	r2,-24(fp)
 d02b324:	10800217 	ldw	r2,8(r2)
 d02b328:	1007883a 	mov	r3,r2
 d02b32c:	e0bff917 	ldw	r2,-28(fp)
 d02b330:	1880030e 	bge	r3,r2,d02b340 <soreceive+0xec>
               len = m->m_len;
 d02b334:	e0bffa17 	ldw	r2,-24(fp)
 d02b338:	10800217 	ldw	r2,8(r2)
 d02b33c:	e0bff915 	stw	r2,-28(fp)

            MEMCPY(data, mtod(m, char*), len);
 d02b340:	e0bffa17 	ldw	r2,-24(fp)
 d02b344:	10c00317 	ldw	r3,12(r2)
 d02b348:	e1bff917 	ldw	r6,-28(fp)
 d02b34c:	e0bffd17 	ldw	r2,-12(fp)
 d02b350:	1009883a 	mov	r4,r2
 d02b354:	180b883a 	mov	r5,r3
 d02b358:	d0026080 	call	d002608 <memcpy>
            data += len;
 d02b35c:	e0bff917 	ldw	r2,-28(fp)
 d02b360:	1007883a 	mov	r3,r2
 d02b364:	e0bffd17 	ldw	r2,-12(fp)
 d02b368:	10c5883a 	add	r2,r2,r3
 d02b36c:	e0bffd15 	stw	r2,-12(fp)
            *datalen = len;
 d02b370:	e0fffe17 	ldw	r3,-8(fp)
 d02b374:	e0bff917 	ldw	r2,-28(fp)
 d02b378:	18800015 	stw	r2,0(r3)
            m = m_free(m);
 d02b37c:	e13ffa17 	ldw	r4,-24(fp)
 d02b380:	d026a1c0 	call	d026a1c <m_free>
 d02b384:	e0bffa15 	stw	r2,-24(fp)
         } while (*datalen && (error == 0) && m);
 d02b388:	e0bffe17 	ldw	r2,-8(fp)
 d02b38c:	10800017 	ldw	r2,0(r2)
 d02b390:	1005003a 	cmpeq	r2,r2,zero
 d02b394:	1000061e 	bne	r2,zero,d02b3b0 <soreceive+0x15c>
 d02b398:	e0bff817 	ldw	r2,-32(fp)
 d02b39c:	1004c03a 	cmpne	r2,r2,zero
 d02b3a0:	1000031e 	bne	r2,zero,d02b3b0 <soreceive+0x15c>
 d02b3a4:	e0bffa17 	ldw	r2,-24(fp)
 d02b3a8:	1004c03a 	cmpne	r2,r2,zero
 d02b3ac:	103fd91e 	bne	r2,zero,d02b314 <soreceive+0xc0>
      }

      if (m)
 d02b3b0:	e0bffa17 	ldw	r2,-24(fp)
 d02b3b4:	1005003a 	cmpeq	r2,r2,zero
 d02b3b8:	1000021e 	bne	r2,zero,d02b3c4 <soreceive+0x170>
         m_freem(m);
 d02b3bc:	e13ffa17 	ldw	r4,-24(fp)
 d02b3c0:	d026b500 	call	d026b50 <m_freem>
      return (error);
 d02b3c4:	e0bff817 	ldw	r2,-32(fp)
 d02b3c8:	e0bfff15 	stw	r2,-4(fp)
 d02b3cc:	00019406 	br	d02ba20 <soreceive+0x7cc>
   }

restart:
   sblock (&so->so_rcv);
 d02b3d0:	e0bffb17 	ldw	r2,-20(fp)
 d02b3d4:	10801104 	addi	r2,r2,68
 d02b3d8:	1009883a 	mov	r4,r2
 d02b3dc:	d0212b40 	call	d0212b4 <tcp_sleep>
 d02b3e0:	e0bffb17 	ldw	r2,-20(fp)
 d02b3e4:	1080110b 	ldhu	r2,68(r2)
 d02b3e8:	10bfffcc 	andi	r2,r2,65535
 d02b3ec:	1080004c 	andi	r2,r2,1
 d02b3f0:	10803fcc 	andi	r2,r2,255
 d02b3f4:	1004c03a 	cmpne	r2,r2,zero
 d02b3f8:	103ff51e 	bne	r2,zero,d02b3d0 <soreceive+0x17c>
 d02b3fc:	e0bffb17 	ldw	r2,-20(fp)
 d02b400:	1080110b 	ldhu	r2,68(r2)
 d02b404:	10800054 	ori	r2,r2,1
 d02b408:	1007883a 	mov	r3,r2
 d02b40c:	e0bffb17 	ldw	r2,-20(fp)
 d02b410:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 d02b414:	e0bffb17 	ldw	r2,-20(fp)
 d02b418:	10800a17 	ldw	r2,40(r2)
 d02b41c:	1004c03a 	cmpne	r2,r2,zero
 d02b420:	1000401e 	bne	r2,zero,d02b524 <soreceive+0x2d0>
   {
      if (so->so_error) 
 d02b424:	e0bffb17 	ldw	r2,-20(fp)
 d02b428:	10800617 	ldw	r2,24(r2)
 d02b42c:	1005003a 	cmpeq	r2,r2,zero
 d02b430:	1000061e 	bne	r2,zero,d02b44c <soreceive+0x1f8>
      {
         error = so->so_error;
 d02b434:	e0bffb17 	ldw	r2,-20(fp)
 d02b438:	10800617 	ldw	r2,24(r2)
 d02b43c:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;
 d02b440:	e0bffb17 	ldw	r2,-20(fp)
 d02b444:	10000615 	stw	zero,24(r2)
         goto release;
 d02b448:	00016806 	br	d02b9ec <soreceive+0x798>
      }
      if (so->so_state & SS_CANTRCVMORE)
 d02b44c:	e0bffb17 	ldw	r2,-20(fp)
 d02b450:	1080088b 	ldhu	r2,34(r2)
 d02b454:	10bfffcc 	andi	r2,r2,65535
 d02b458:	1080080c 	andi	r2,r2,32
 d02b45c:	1004c03a 	cmpne	r2,r2,zero
 d02b460:	1001621e 	bne	r2,zero,d02b9ec <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 d02b464:	e0bffb17 	ldw	r2,-20(fp)
 d02b468:	1080088b 	ldhu	r2,34(r2)
 d02b46c:	10bfffcc 	andi	r2,r2,65535
 d02b470:	1080008c 	andi	r2,r2,2
 d02b474:	1004c03a 	cmpne	r2,r2,zero
 d02b478:	10000a1e 	bne	r2,zero,d02b4a4 <soreceive+0x250>
 d02b47c:	e0bffb17 	ldw	r2,-20(fp)
 d02b480:	10800217 	ldw	r2,8(r2)
 d02b484:	1080010b 	ldhu	r2,4(r2)
 d02b488:	10bfffcc 	andi	r2,r2,65535
 d02b48c:	1080010c 	andi	r2,r2,4
 d02b490:	1005003a 	cmpeq	r2,r2,zero
 d02b494:	1000031e 	bne	r2,zero,d02b4a4 <soreceive+0x250>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 d02b498:	00802004 	movi	r2,128
 d02b49c:	e0bff815 	stw	r2,-32(fp)
         goto release;
 d02b4a0:	00015206 	br	d02b9ec <soreceive+0x798>
      }
      if (*datalen == 0)
 d02b4a4:	e0bffe17 	ldw	r2,-8(fp)
 d02b4a8:	10800017 	ldw	r2,0(r2)
 d02b4ac:	1005003a 	cmpeq	r2,r2,zero
 d02b4b0:	10014e1e 	bne	r2,zero,d02b9ec <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 d02b4b4:	e0bffb17 	ldw	r2,-20(fp)
 d02b4b8:	1080088b 	ldhu	r2,34(r2)
 d02b4bc:	10bfffcc 	andi	r2,r2,65535
 d02b4c0:	1080400c 	andi	r2,r2,256
 d02b4c4:	1004c03a 	cmpne	r2,r2,zero
 d02b4c8:	1000041e 	bne	r2,zero,d02b4dc <soreceive+0x288>
 d02b4cc:	e0800217 	ldw	r2,8(fp)
 d02b4d0:	1080080c 	andi	r2,r2,32
 d02b4d4:	1005003a 	cmpeq	r2,r2,zero
 d02b4d8:	1000031e 	bne	r2,zero,d02b4e8 <soreceive+0x294>
      {
         error = EWOULDBLOCK;
 d02b4dc:	008002c4 	movi	r2,11
 d02b4e0:	e0bff815 	stw	r2,-32(fp)
         goto release;
 d02b4e4:	00014106 	br	d02b9ec <soreceive+0x798>
      }
      sbunlock(&so->so_rcv);
 d02b4e8:	e0bffb17 	ldw	r2,-20(fp)
 d02b4ec:	10c0110b 	ldhu	r3,68(r2)
 d02b4f0:	00bfff84 	movi	r2,-2
 d02b4f4:	1884703a 	and	r2,r3,r2
 d02b4f8:	1007883a 	mov	r3,r2
 d02b4fc:	e0bffb17 	ldw	r2,-20(fp)
 d02b500:	10c0110d 	sth	r3,68(r2)
 d02b504:	e0bffb17 	ldw	r2,-20(fp)
 d02b508:	10801104 	addi	r2,r2,68
 d02b50c:	1009883a 	mov	r4,r2
 d02b510:	d02147c0 	call	d02147c <tcp_wakeup>
      sbwait(&so->so_rcv);
 d02b514:	e0bffb17 	ldw	r2,-20(fp)
 d02b518:	11000a04 	addi	r4,r2,40
 d02b51c:	d02cd940 	call	d02cd94 <sbwait>
      goto restart;
 d02b520:	003faf06 	br	d02b3e0 <soreceive+0x18c>
   }
   m = so->so_rcv.sb_mb;
 d02b524:	e0bffb17 	ldw	r2,-20(fp)
 d02b528:	10801017 	ldw	r2,64(r2)
 d02b52c:	e0bffa15 	stw	r2,-24(fp)
   if (m == 0)
 d02b530:	e0bffa17 	ldw	r2,-24(fp)
 d02b534:	1004c03a 	cmpne	r2,r2,zero
 d02b538:	1000031e 	bne	r2,zero,d02b548 <soreceive+0x2f4>
      panic("sorecv 1");
 d02b53c:	01034174 	movhi	r4,3333
 d02b540:	213e8704 	addi	r4,r4,-1508
 d02b544:	d02093c0 	call	d02093c <panic>
   nextrecord = m->m_act;
 d02b548:	e0bffa17 	ldw	r2,-24(fp)
 d02b54c:	10800717 	ldw	r2,28(r2)
 d02b550:	e0bff515 	stw	r2,-44(fp)
   if (pr->pr_flags & PR_ADDR) 
 d02b554:	e0bff617 	ldw	r2,-40(fp)
 d02b558:	1080010b 	ldhu	r2,4(r2)
 d02b55c:	10bfffcc 	andi	r2,r2,65535
 d02b560:	1080008c 	andi	r2,r2,2
 d02b564:	1005003a 	cmpeq	r2,r2,zero
 d02b568:	1000451e 	bne	r2,zero,d02b680 <soreceive+0x42c>
   {
      if (m->m_type != MT_SONAME) 
 d02b56c:	e0bffa17 	ldw	r2,-24(fp)
 d02b570:	10800817 	ldw	r2,32(r2)
 d02b574:	10800260 	cmpeqi	r2,r2,9
 d02b578:	1000081e 	bne	r2,zero,d02b59c <soreceive+0x348>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 d02b57c:	e0bffa17 	ldw	r2,-24(fp)
 d02b580:	11400817 	ldw	r5,32(r2)
 d02b584:	01034174 	movhi	r4,3333
 d02b588:	213e8a04 	addi	r4,r4,-1496
 d02b58c:	d0028a00 	call	d0028a0 <printf>
         panic("sorecv 2");
 d02b590:	01034174 	movhi	r4,3333
 d02b594:	213e9004 	addi	r4,r4,-1472
 d02b598:	d02093c0 	call	d02093c <panic>
      }
      if (flags & MSG_PEEK) 
 d02b59c:	e0800217 	ldw	r2,8(fp)
 d02b5a0:	1080008c 	andi	r2,r2,2
 d02b5a4:	1005003a 	cmpeq	r2,r2,zero
 d02b5a8:	1000101e 	bne	r2,zero,d02b5ec <soreceive+0x398>
      {
         if (aname)
 d02b5ac:	e0bffc17 	ldw	r2,-16(fp)
 d02b5b0:	1005003a 	cmpeq	r2,r2,zero
 d02b5b4:	1000091e 	bne	r2,zero,d02b5dc <soreceive+0x388>
            *aname = m_copy (m, 0, m->m_len);
 d02b5b8:	e0bffa17 	ldw	r2,-24(fp)
 d02b5bc:	10800217 	ldw	r2,8(r2)
 d02b5c0:	100d883a 	mov	r6,r2
 d02b5c4:	e13ffa17 	ldw	r4,-24(fp)
 d02b5c8:	000b883a 	mov	r5,zero
 d02b5cc:	d026b940 	call	d026b94 <m_copy>
 d02b5d0:	1007883a 	mov	r3,r2
 d02b5d4:	e0bffc17 	ldw	r2,-16(fp)
 d02b5d8:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 d02b5dc:	e0bffa17 	ldw	r2,-24(fp)
 d02b5e0:	10800617 	ldw	r2,24(r2)
 d02b5e4:	e0bffa15 	stw	r2,-24(fp)
 d02b5e8:	00002506 	br	d02b680 <soreceive+0x42c>
      } else 
      {
         sbfree (&so->so_rcv, m);
 d02b5ec:	e0bffb17 	ldw	r2,-20(fp)
 d02b5f0:	10c00a17 	ldw	r3,40(r2)
 d02b5f4:	e0bffa17 	ldw	r2,-24(fp)
 d02b5f8:	10800217 	ldw	r2,8(r2)
 d02b5fc:	1887c83a 	sub	r3,r3,r2
 d02b600:	e0bffb17 	ldw	r2,-20(fp)
 d02b604:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 d02b608:	e0bffc17 	ldw	r2,-16(fp)
 d02b60c:	1005003a 	cmpeq	r2,r2,zero
 d02b610:	10000d1e 	bne	r2,zero,d02b648 <soreceive+0x3f4>
         {
            *aname = m;
 d02b614:	e0fffc17 	ldw	r3,-16(fp)
 d02b618:	e0bffa17 	ldw	r2,-24(fp)
 d02b61c:	18800015 	stw	r2,0(r3)
            m = m->m_next;
 d02b620:	e0bffa17 	ldw	r2,-24(fp)
 d02b624:	10800617 	ldw	r2,24(r2)
 d02b628:	e0bffa15 	stw	r2,-24(fp)
            (*aname)->m_next = 0;
 d02b62c:	e0bffc17 	ldw	r2,-16(fp)
 d02b630:	10800017 	ldw	r2,0(r2)
 d02b634:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 d02b638:	e0fffb17 	ldw	r3,-20(fp)
 d02b63c:	e0bffa17 	ldw	r2,-24(fp)
 d02b640:	18801015 	stw	r2,64(r3)
 d02b644:	00000806 	br	d02b668 <soreceive+0x414>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 d02b648:	e13ffa17 	ldw	r4,-24(fp)
 d02b64c:	d026a1c0 	call	d026a1c <m_free>
 d02b650:	1007883a 	mov	r3,r2
 d02b654:	e0bffb17 	ldw	r2,-20(fp)
 d02b658:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 d02b65c:	e0bffb17 	ldw	r2,-20(fp)
 d02b660:	10801017 	ldw	r2,64(r2)
 d02b664:	e0bffa15 	stw	r2,-24(fp)
         }
         if (m)
 d02b668:	e0bffa17 	ldw	r2,-24(fp)
 d02b66c:	1005003a 	cmpeq	r2,r2,zero
 d02b670:	1000031e 	bne	r2,zero,d02b680 <soreceive+0x42c>
            m->m_act = nextrecord;
 d02b674:	e0fffa17 	ldw	r3,-24(fp)
 d02b678:	e0bff517 	ldw	r2,-44(fp)
 d02b67c:	18800715 	stw	r2,28(r3)
      }
   }
   moff = 0;
 d02b680:	e03ff415 	stw	zero,-48(fp)
   offset = 0;
 d02b684:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 d02b688:	0000a606 	br	d02b924 <soreceive+0x6d0>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 d02b68c:	e0bffa17 	ldw	r2,-24(fp)
 d02b690:	10800817 	ldw	r2,32(r2)
 d02b694:	10800060 	cmpeqi	r2,r2,1
 d02b698:	1000071e 	bne	r2,zero,d02b6b8 <soreceive+0x464>
 d02b69c:	e0bffa17 	ldw	r2,-24(fp)
 d02b6a0:	10800817 	ldw	r2,32(r2)
 d02b6a4:	108000e0 	cmpeqi	r2,r2,3
 d02b6a8:	1000031e 	bne	r2,zero,d02b6b8 <soreceive+0x464>
         panic("sorecv 3");
 d02b6ac:	01034174 	movhi	r4,3333
 d02b6b0:	213e9304 	addi	r4,r4,-1460
 d02b6b4:	d02093c0 	call	d02093c <panic>
      len = *datalen;
 d02b6b8:	e0bffe17 	ldw	r2,-8(fp)
 d02b6bc:	10800017 	ldw	r2,0(r2)
 d02b6c0:	e0bff915 	stw	r2,-28(fp)
      so->so_state &= ~SS_RCVATMARK;
 d02b6c4:	e0bffb17 	ldw	r2,-20(fp)
 d02b6c8:	10c0088b 	ldhu	r3,34(r2)
 d02b6cc:	00bfefc4 	movi	r2,-65
 d02b6d0:	1884703a 	and	r2,r3,r2
 d02b6d4:	1007883a 	mov	r3,r2
 d02b6d8:	e0bffb17 	ldw	r2,-20(fp)
 d02b6dc:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 d02b6e0:	e0bffb17 	ldw	r2,-20(fp)
 d02b6e4:	10801a17 	ldw	r2,104(r2)
 d02b6e8:	1005003a 	cmpeq	r2,r2,zero
 d02b6ec:	10000c1e 	bne	r2,zero,d02b720 <soreceive+0x4cc>
 d02b6f0:	e0bffb17 	ldw	r2,-20(fp)
 d02b6f4:	10c01a17 	ldw	r3,104(r2)
 d02b6f8:	e0bff717 	ldw	r2,-36(fp)
 d02b6fc:	1885c83a 	sub	r2,r3,r2
 d02b700:	1007883a 	mov	r3,r2
 d02b704:	e0bff917 	ldw	r2,-28(fp)
 d02b708:	1880050e 	bge	r3,r2,d02b720 <soreceive+0x4cc>
         len = (int)(so->so_oobmark - offset);
 d02b70c:	e0bffb17 	ldw	r2,-20(fp)
 d02b710:	10c01a17 	ldw	r3,104(r2)
 d02b714:	e0bff717 	ldw	r2,-36(fp)
 d02b718:	1885c83a 	sub	r2,r3,r2
 d02b71c:	e0bff915 	stw	r2,-28(fp)
      if (len > (int)(m->m_len - moff))
 d02b720:	e0bffa17 	ldw	r2,-24(fp)
 d02b724:	10c00217 	ldw	r3,8(r2)
 d02b728:	e0bff417 	ldw	r2,-48(fp)
 d02b72c:	1885c83a 	sub	r2,r3,r2
 d02b730:	1007883a 	mov	r3,r2
 d02b734:	e0bff917 	ldw	r2,-28(fp)
 d02b738:	1880050e 	bge	r3,r2,d02b750 <soreceive+0x4fc>
         len = m->m_len - moff;
 d02b73c:	e0bffa17 	ldw	r2,-24(fp)
 d02b740:	10c00217 	ldw	r3,8(r2)
 d02b744:	e0bff417 	ldw	r2,-48(fp)
 d02b748:	1885c83a 	sub	r2,r3,r2
 d02b74c:	e0bff915 	stw	r2,-28(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 d02b750:	e0bffa17 	ldw	r2,-24(fp)
 d02b754:	10c00317 	ldw	r3,12(r2)
 d02b758:	e0bff417 	ldw	r2,-48(fp)
 d02b75c:	1887883a 	add	r3,r3,r2
 d02b760:	e1bff917 	ldw	r6,-28(fp)
 d02b764:	e0bffd17 	ldw	r2,-12(fp)
 d02b768:	1009883a 	mov	r4,r2
 d02b76c:	180b883a 	mov	r5,r3
 d02b770:	d0026080 	call	d002608 <memcpy>
      data += len;
 d02b774:	e0bff917 	ldw	r2,-28(fp)
 d02b778:	1007883a 	mov	r3,r2
 d02b77c:	e0bffd17 	ldw	r2,-12(fp)
 d02b780:	10c5883a 	add	r2,r2,r3
 d02b784:	e0bffd15 	stw	r2,-12(fp)
      *datalen -= len;
 d02b788:	e0bffe17 	ldw	r2,-8(fp)
 d02b78c:	10c00017 	ldw	r3,0(r2)
 d02b790:	e0bff917 	ldw	r2,-28(fp)
 d02b794:	1887c83a 	sub	r3,r3,r2
 d02b798:	e0bffe17 	ldw	r2,-8(fp)
 d02b79c:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 d02b7a0:	e0bffa17 	ldw	r2,-24(fp)
 d02b7a4:	10c00217 	ldw	r3,8(r2)
 d02b7a8:	e0bff417 	ldw	r2,-48(fp)
 d02b7ac:	1885c83a 	sub	r2,r3,r2
 d02b7b0:	1007883a 	mov	r3,r2
 d02b7b4:	e0bff917 	ldw	r2,-28(fp)
 d02b7b8:	1880221e 	bne	r3,r2,d02b844 <soreceive+0x5f0>
      {
         if (flags & MSG_PEEK) 
 d02b7bc:	e0800217 	ldw	r2,8(fp)
 d02b7c0:	1080008c 	andi	r2,r2,2
 d02b7c4:	1005003a 	cmpeq	r2,r2,zero
 d02b7c8:	1000051e 	bne	r2,zero,d02b7e0 <soreceive+0x58c>
         {
            m = m->m_next;
 d02b7cc:	e0bffa17 	ldw	r2,-24(fp)
 d02b7d0:	10800617 	ldw	r2,24(r2)
 d02b7d4:	e0bffa15 	stw	r2,-24(fp)
            moff = 0;
 d02b7d8:	e03ff415 	stw	zero,-48(fp)
 d02b7dc:	00003406 	br	d02b8b0 <soreceive+0x65c>
         } else 
         {
            nextrecord = m->m_act;
 d02b7e0:	e0bffa17 	ldw	r2,-24(fp)
 d02b7e4:	10800717 	ldw	r2,28(r2)
 d02b7e8:	e0bff515 	stw	r2,-44(fp)
            sbfree(&so->so_rcv, m);
 d02b7ec:	e0bffb17 	ldw	r2,-20(fp)
 d02b7f0:	10c00a17 	ldw	r3,40(r2)
 d02b7f4:	e0bffa17 	ldw	r2,-24(fp)
 d02b7f8:	10800217 	ldw	r2,8(r2)
 d02b7fc:	1887c83a 	sub	r3,r3,r2
 d02b800:	e0bffb17 	ldw	r2,-20(fp)
 d02b804:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 d02b808:	e13ffa17 	ldw	r4,-24(fp)
 d02b80c:	d026a1c0 	call	d026a1c <m_free>
 d02b810:	1007883a 	mov	r3,r2
 d02b814:	e0bffb17 	ldw	r2,-20(fp)
 d02b818:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 d02b81c:	e0bffb17 	ldw	r2,-20(fp)
 d02b820:	10801017 	ldw	r2,64(r2)
 d02b824:	e0bffa15 	stw	r2,-24(fp)
            }
            if (m)
 d02b828:	e0bffa17 	ldw	r2,-24(fp)
 d02b82c:	1005003a 	cmpeq	r2,r2,zero
 d02b830:	10001f1e 	bne	r2,zero,d02b8b0 <soreceive+0x65c>
               m->m_act = nextrecord;
 d02b834:	e0fffa17 	ldw	r3,-24(fp)
 d02b838:	e0bff517 	ldw	r2,-44(fp)
 d02b83c:	18800715 	stw	r2,28(r3)
 d02b840:	00001b06 	br	d02b8b0 <soreceive+0x65c>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 d02b844:	e0800217 	ldw	r2,8(fp)
 d02b848:	1080008c 	andi	r2,r2,2
 d02b84c:	1005003a 	cmpeq	r2,r2,zero
 d02b850:	1000051e 	bne	r2,zero,d02b868 <soreceive+0x614>
            moff += len;
 d02b854:	e0bff417 	ldw	r2,-48(fp)
 d02b858:	e0fff917 	ldw	r3,-28(fp)
 d02b85c:	10c5883a 	add	r2,r2,r3
 d02b860:	e0bff415 	stw	r2,-48(fp)
 d02b864:	00001206 	br	d02b8b0 <soreceive+0x65c>
         else 
         {
            m->m_data += len;
 d02b868:	e0bffa17 	ldw	r2,-24(fp)
 d02b86c:	10c00317 	ldw	r3,12(r2)
 d02b870:	e0bff917 	ldw	r2,-28(fp)
 d02b874:	1887883a 	add	r3,r3,r2
 d02b878:	e0bffa17 	ldw	r2,-24(fp)
 d02b87c:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 d02b880:	e0bffa17 	ldw	r2,-24(fp)
 d02b884:	10c00217 	ldw	r3,8(r2)
 d02b888:	e0bff917 	ldw	r2,-28(fp)
 d02b88c:	1887c83a 	sub	r3,r3,r2
 d02b890:	e0bffa17 	ldw	r2,-24(fp)
 d02b894:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 d02b898:	e0bffb17 	ldw	r2,-20(fp)
 d02b89c:	10c00a17 	ldw	r3,40(r2)
 d02b8a0:	e0bff917 	ldw	r2,-28(fp)
 d02b8a4:	1887c83a 	sub	r3,r3,r2
 d02b8a8:	e0bffb17 	ldw	r2,-20(fp)
 d02b8ac:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 d02b8b0:	e0bffb17 	ldw	r2,-20(fp)
 d02b8b4:	10801a17 	ldw	r2,104(r2)
 d02b8b8:	1005003a 	cmpeq	r2,r2,zero
 d02b8bc:	1000191e 	bne	r2,zero,d02b924 <soreceive+0x6d0>
      {
         if ((flags & MSG_PEEK) == 0) 
 d02b8c0:	e0800217 	ldw	r2,8(fp)
 d02b8c4:	1080008c 	andi	r2,r2,2
 d02b8c8:	1004c03a 	cmpne	r2,r2,zero
 d02b8cc:	1000111e 	bne	r2,zero,d02b914 <soreceive+0x6c0>
         {
            so->so_oobmark -= len;
 d02b8d0:	e0bffb17 	ldw	r2,-20(fp)
 d02b8d4:	10c01a17 	ldw	r3,104(r2)
 d02b8d8:	e0bff917 	ldw	r2,-28(fp)
 d02b8dc:	1887c83a 	sub	r3,r3,r2
 d02b8e0:	e0bffb17 	ldw	r2,-20(fp)
 d02b8e4:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 d02b8e8:	e0bffb17 	ldw	r2,-20(fp)
 d02b8ec:	10801a17 	ldw	r2,104(r2)
 d02b8f0:	1004c03a 	cmpne	r2,r2,zero
 d02b8f4:	10000b1e 	bne	r2,zero,d02b924 <soreceive+0x6d0>
            {
               so->so_state |= SS_RCVATMARK;
 d02b8f8:	e0bffb17 	ldw	r2,-20(fp)
 d02b8fc:	1080088b 	ldhu	r2,34(r2)
 d02b900:	10801014 	ori	r2,r2,64
 d02b904:	1007883a 	mov	r3,r2
 d02b908:	e0bffb17 	ldw	r2,-20(fp)
 d02b90c:	10c0088d 	sth	r3,34(r2)
               break;
 d02b910:	00000e06 	br	d02b94c <soreceive+0x6f8>
            }
         } else
            offset += len;
 d02b914:	e0bff717 	ldw	r2,-36(fp)
 d02b918:	e0fff917 	ldw	r3,-28(fp)
 d02b91c:	10c5883a 	add	r2,r2,r3
 d02b920:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 d02b924:	e0bffa17 	ldw	r2,-24(fp)
 d02b928:	1005003a 	cmpeq	r2,r2,zero
 d02b92c:	1000071e 	bne	r2,zero,d02b94c <soreceive+0x6f8>
 d02b930:	e0bffe17 	ldw	r2,-8(fp)
 d02b934:	10800017 	ldw	r2,0(r2)
 d02b938:	10800050 	cmplti	r2,r2,1
 d02b93c:	1000031e 	bne	r2,zero,d02b94c <soreceive+0x6f8>
 d02b940:	e0bff817 	ldw	r2,-32(fp)
 d02b944:	1005003a 	cmpeq	r2,r2,zero
 d02b948:	103f501e 	bne	r2,zero,d02b68c <soreceive+0x438>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 d02b94c:	e0800217 	ldw	r2,8(fp)
 d02b950:	1080008c 	andi	r2,r2,2
 d02b954:	1004c03a 	cmpne	r2,r2,zero
 d02b958:	1000241e 	bne	r2,zero,d02b9ec <soreceive+0x798>
   {
      if (m == 0)
 d02b95c:	e0bffa17 	ldw	r2,-24(fp)
 d02b960:	1004c03a 	cmpne	r2,r2,zero
 d02b964:	1000041e 	bne	r2,zero,d02b978 <soreceive+0x724>
         so->so_rcv.sb_mb = nextrecord;
 d02b968:	e0fffb17 	ldw	r3,-20(fp)
 d02b96c:	e0bff517 	ldw	r2,-44(fp)
 d02b970:	18801015 	stw	r2,64(r3)
 d02b974:	00000a06 	br	d02b9a0 <soreceive+0x74c>
      else if (pr->pr_flags & PR_ATOMIC)
 d02b978:	e0bff617 	ldw	r2,-40(fp)
 d02b97c:	1080010b 	ldhu	r2,4(r2)
 d02b980:	10bfffcc 	andi	r2,r2,65535
 d02b984:	1080004c 	andi	r2,r2,1
 d02b988:	10803fcc 	andi	r2,r2,255
 d02b98c:	1005003a 	cmpeq	r2,r2,zero
 d02b990:	1000031e 	bne	r2,zero,d02b9a0 <soreceive+0x74c>
         (void) sbdroprecord(&so->so_rcv);
 d02b994:	e0bffb17 	ldw	r2,-20(fp)
 d02b998:	11000a04 	addi	r4,r2,40
 d02b99c:	d02d8a80 	call	d02d8a8 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 d02b9a0:	e0bff617 	ldw	r2,-40(fp)
 d02b9a4:	1080010b 	ldhu	r2,4(r2)
 d02b9a8:	10bfffcc 	andi	r2,r2,65535
 d02b9ac:	1080020c 	andi	r2,r2,8
 d02b9b0:	1005003a 	cmpeq	r2,r2,zero
 d02b9b4:	10000d1e 	bne	r2,zero,d02b9ec <soreceive+0x798>
 d02b9b8:	e0bffb17 	ldw	r2,-20(fp)
 d02b9bc:	10800117 	ldw	r2,4(r2)
 d02b9c0:	1005003a 	cmpeq	r2,r2,zero
 d02b9c4:	1000091e 	bne	r2,zero,d02b9ec <soreceive+0x798>
      {
         so->so_req = PRU_RCVD;
 d02b9c8:	e0fffb17 	ldw	r3,-20(fp)
 d02b9cc:	00800204 	movi	r2,8
 d02b9d0:	18800715 	stw	r2,28(r3)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 d02b9d4:	e0bff617 	ldw	r2,-40(fp)
 d02b9d8:	10800317 	ldw	r2,12(r2)
 d02b9dc:	e13ffb17 	ldw	r4,-20(fp)
 d02b9e0:	000b883a 	mov	r5,zero
 d02b9e4:	000d883a 	mov	r6,zero
 d02b9e8:	103ee83a 	callr	r2
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 d02b9ec:	e0bffb17 	ldw	r2,-20(fp)
 d02b9f0:	10c0110b 	ldhu	r3,68(r2)
 d02b9f4:	00bfff84 	movi	r2,-2
 d02b9f8:	1884703a 	and	r2,r3,r2
 d02b9fc:	1007883a 	mov	r3,r2
 d02ba00:	e0bffb17 	ldw	r2,-20(fp)
 d02ba04:	10c0110d 	sth	r3,68(r2)
 d02ba08:	e0bffb17 	ldw	r2,-20(fp)
 d02ba0c:	10801104 	addi	r2,r2,68
 d02ba10:	1009883a 	mov	r4,r2
 d02ba14:	d02147c0 	call	d02147c <tcp_wakeup>
   return (error);
 d02ba18:	e0bff817 	ldw	r2,-32(fp)
 d02ba1c:	e0bfff15 	stw	r2,-4(fp)
 d02ba20:	e0bfff17 	ldw	r2,-4(fp)
}
 d02ba24:	e037883a 	mov	sp,fp
 d02ba28:	dfc00117 	ldw	ra,4(sp)
 d02ba2c:	df000017 	ldw	fp,0(sp)
 d02ba30:	dec00204 	addi	sp,sp,8
 d02ba34:	f800283a 	ret

0d02ba38 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 d02ba38:	defffb04 	addi	sp,sp,-20
 d02ba3c:	dfc00415 	stw	ra,16(sp)
 d02ba40:	df000315 	stw	fp,12(sp)
 d02ba44:	df000304 	addi	fp,sp,12
 d02ba48:	e13ffd15 	stw	r4,-12(fp)
 d02ba4c:	e17ffe15 	stw	r5,-8(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 d02ba50:	e0bffe17 	ldw	r2,-8(fp)
 d02ba54:	10800044 	addi	r2,r2,1
 d02ba58:	e0bffe15 	stw	r2,-8(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 d02ba5c:	e0bffe17 	ldw	r2,-8(fp)
 d02ba60:	1080004c 	andi	r2,r2,1
 d02ba64:	10803fcc 	andi	r2,r2,255
 d02ba68:	1005003a 	cmpeq	r2,r2,zero
 d02ba6c:	1000021e 	bne	r2,zero,d02ba78 <soshutdown+0x40>
      sorflush(so);
 d02ba70:	e13ffd17 	ldw	r4,-12(fp)
 d02ba74:	d02bae00 	call	d02bae0 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 d02ba78:	e0bffe17 	ldw	r2,-8(fp)
 d02ba7c:	1080008c 	andi	r2,r2,2
 d02ba80:	1005003a 	cmpeq	r2,r2,zero
 d02ba84:	10000f1e 	bne	r2,zero,d02bac4 <soshutdown+0x8c>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 d02ba88:	e0bffd17 	ldw	r2,-12(fp)
 d02ba8c:	11001204 	addi	r4,r2,72
 d02ba90:	d02d5380 	call	d02d538 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 d02ba94:	e0fffd17 	ldw	r3,-12(fp)
 d02ba98:	008001c4 	movi	r2,7
 d02ba9c:	18800715 	stw	r2,28(r3)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 d02baa0:	e0bffd17 	ldw	r2,-12(fp)
 d02baa4:	10800217 	ldw	r2,8(r2)
 d02baa8:	10800317 	ldw	r2,12(r2)
 d02baac:	e13ffd17 	ldw	r4,-12(fp)
 d02bab0:	000b883a 	mov	r5,zero
 d02bab4:	000d883a 	mov	r6,zero
 d02bab8:	103ee83a 	callr	r2
 d02babc:	e0bfff15 	stw	r2,-4(fp)
 d02bac0:	00000106 	br	d02bac8 <soshutdown+0x90>
   }

   return 0;
 d02bac4:	e03fff15 	stw	zero,-4(fp)
 d02bac8:	e0bfff17 	ldw	r2,-4(fp)
}
 d02bacc:	e037883a 	mov	sp,fp
 d02bad0:	dfc00117 	ldw	ra,4(sp)
 d02bad4:	df000017 	ldw	fp,0(sp)
 d02bad8:	dec00204 	addi	sp,sp,8
 d02badc:	f800283a 	ret

0d02bae0 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 d02bae0:	defffb04 	addi	sp,sp,-20
 d02bae4:	dfc00415 	stw	ra,16(sp)
 d02bae8:	df000315 	stw	fp,12(sp)
 d02baec:	df000304 	addi	fp,sp,12
 d02baf0:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 d02baf4:	e0bfff17 	ldw	r2,-4(fp)
 d02baf8:	10800a04 	addi	r2,r2,40
 d02bafc:	e0bffe15 	stw	r2,-8(fp)
   int   s;

   sblock(sb);
 d02bb00:	00000406 	br	d02bb14 <sorflush+0x34>
 d02bb04:	e0bffe17 	ldw	r2,-8(fp)
 d02bb08:	10800704 	addi	r2,r2,28
 d02bb0c:	1009883a 	mov	r4,r2
 d02bb10:	d0212b40 	call	d0212b4 <tcp_sleep>
 d02bb14:	e0bffe17 	ldw	r2,-8(fp)
 d02bb18:	1080070b 	ldhu	r2,28(r2)
 d02bb1c:	10bfffcc 	andi	r2,r2,65535
 d02bb20:	1080004c 	andi	r2,r2,1
 d02bb24:	10803fcc 	andi	r2,r2,255
 d02bb28:	1004c03a 	cmpne	r2,r2,zero
 d02bb2c:	103ff51e 	bne	r2,zero,d02bb04 <sorflush+0x24>
 d02bb30:	e0bffe17 	ldw	r2,-8(fp)
 d02bb34:	1080070b 	ldhu	r2,28(r2)
 d02bb38:	10800054 	ori	r2,r2,1
 d02bb3c:	1007883a 	mov	r3,r2
 d02bb40:	e0bffe17 	ldw	r2,-8(fp)
 d02bb44:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 d02bb48:	e13fff17 	ldw	r4,-4(fp)
 d02bb4c:	d02cd0c0 	call	d02cd0c <socantrcvmore>
   sbunlock(sb);
 d02bb50:	e0bffe17 	ldw	r2,-8(fp)
 d02bb54:	10c0070b 	ldhu	r3,28(r2)
 d02bb58:	00bfff84 	movi	r2,-2
 d02bb5c:	1884703a 	and	r2,r3,r2
 d02bb60:	1007883a 	mov	r3,r2
 d02bb64:	e0bffe17 	ldw	r2,-8(fp)
 d02bb68:	10c0070d 	sth	r3,28(r2)
 d02bb6c:	e0bffe17 	ldw	r2,-8(fp)
 d02bb70:	10800704 	addi	r2,r2,28
 d02bb74:	1009883a 	mov	r4,r2
 d02bb78:	d02147c0 	call	d02147c <tcp_wakeup>
   sbrelease(sb);
 d02bb7c:	e13ffe17 	ldw	r4,-8(fp)
 d02bb80:	d02cf780 	call	d02cf78 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 d02bb84:	e0bffe17 	ldw	r2,-8(fp)
 d02bb88:	1009883a 	mov	r4,r2
 d02bb8c:	01800804 	movi	r6,32
 d02bb90:	000b883a 	mov	r5,zero
 d02bb94:	d0027880 	call	d002788 <memset>
   s = so->so_error;
 d02bb98:	e0bfff17 	ldw	r2,-4(fp)
 d02bb9c:	10800617 	ldw	r2,24(r2)
 d02bba0:	e0bffd15 	stw	r2,-12(fp)
   so->so_error = ESHUTDOWN;
 d02bba4:	e0ffff17 	ldw	r3,-4(fp)
 d02bba8:	00801b84 	movi	r2,110
 d02bbac:	18800615 	stw	r2,24(r3)
   sorwakeup(so);
 d02bbb0:	e0bfff17 	ldw	r2,-4(fp)
 d02bbb4:	11400a04 	addi	r5,r2,40
 d02bbb8:	e13fff17 	ldw	r4,-4(fp)
 d02bbbc:	d02cdfc0 	call	d02cdfc <sbwakeup>
   so->so_error = s;
 d02bbc0:	e0ffff17 	ldw	r3,-4(fp)
 d02bbc4:	e0bffd17 	ldw	r2,-12(fp)
 d02bbc8:	18800615 	stw	r2,24(r3)
}
 d02bbcc:	e037883a 	mov	sp,fp
 d02bbd0:	dfc00117 	ldw	ra,4(sp)
 d02bbd4:	df000017 	ldw	fp,0(sp)
 d02bbd8:	dec00204 	addi	sp,sp,8
 d02bbdc:	f800283a 	ret

0d02bbe0 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 d02bbe0:	defff404 	addi	sp,sp,-48
 d02bbe4:	dfc00b15 	stw	ra,44(sp)
 d02bbe8:	df000a15 	stw	fp,40(sp)
 d02bbec:	df000a04 	addi	fp,sp,40
 d02bbf0:	e13ffb15 	stw	r4,-20(fp)
 d02bbf4:	e17ffc15 	stw	r5,-16(fp)
 d02bbf8:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 d02bbfc:	e03ffa15 	stw	zero,-24(fp)

   switch (optname) 
 d02bc00:	e0bffc17 	ldw	r2,-16(fp)
 d02bc04:	e0bfff15 	stw	r2,-4(fp)
 d02bc08:	e0ffff17 	ldw	r3,-4(fp)
 d02bc0c:	18808020 	cmpeqi	r2,r3,512
 d02bc10:	1000521e 	bne	r2,zero,d02bd5c <sosetopt+0x17c>
 d02bc14:	e0ffff17 	ldw	r3,-4(fp)
 d02bc18:	18808048 	cmpgei	r2,r3,513
 d02bc1c:	1000211e 	bne	r2,zero,d02bca4 <sosetopt+0xc4>
 d02bc20:	e0ffff17 	ldw	r3,-4(fp)
 d02bc24:	18800388 	cmpgei	r2,r3,14
 d02bc28:	10000d1e 	bne	r2,zero,d02bc60 <sosetopt+0x80>
 d02bc2c:	e0ffff17 	ldw	r3,-4(fp)
 d02bc30:	18800248 	cmpgei	r2,r3,9
 d02bc34:	10009d1e 	bne	r2,zero,d02beac <sosetopt+0x2cc>
 d02bc38:	e0ffff17 	ldw	r3,-4(fp)
 d02bc3c:	18800120 	cmpeqi	r2,r3,4
 d02bc40:	1000461e 	bne	r2,zero,d02bd5c <sosetopt+0x17c>
 d02bc44:	e0ffff17 	ldw	r3,-4(fp)
 d02bc48:	18800220 	cmpeqi	r2,r3,8
 d02bc4c:	1000431e 	bne	r2,zero,d02bd5c <sosetopt+0x17c>
 d02bc50:	e0ffff17 	ldw	r3,-4(fp)
 d02bc54:	188000a0 	cmpeqi	r2,r3,2
 d02bc58:	10009a1e 	bne	r2,zero,d02bec4 <sosetopt+0x2e4>
 d02bc5c:	00010806 	br	d02c080 <sosetopt+0x4a0>
 d02bc60:	e0ffff17 	ldw	r3,-4(fp)
 d02bc64:	18800820 	cmpeqi	r2,r3,32
 d02bc68:	10003c1e 	bne	r2,zero,d02bd5c <sosetopt+0x17c>
 d02bc6c:	e0ffff17 	ldw	r3,-4(fp)
 d02bc70:	18800848 	cmpgei	r2,r3,33
 d02bc74:	1000041e 	bne	r2,zero,d02bc88 <sosetopt+0xa8>
 d02bc78:	e0ffff17 	ldw	r3,-4(fp)
 d02bc7c:	18800420 	cmpeqi	r2,r3,16
 d02bc80:	1000361e 	bne	r2,zero,d02bd5c <sosetopt+0x17c>
 d02bc84:	0000fe06 	br	d02c080 <sosetopt+0x4a0>
 d02bc88:	e0ffff17 	ldw	r3,-4(fp)
 d02bc8c:	18802020 	cmpeqi	r2,r3,128
 d02bc90:	10002d1e 	bne	r2,zero,d02bd48 <sosetopt+0x168>
 d02bc94:	e0ffff17 	ldw	r3,-4(fp)
 d02bc98:	18804020 	cmpeqi	r2,r3,256
 d02bc9c:	10002f1e 	bne	r2,zero,d02bd5c <sosetopt+0x17c>
 d02bca0:	0000f706 	br	d02c080 <sosetopt+0x4a0>
 d02bca4:	e0ffff17 	ldw	r3,-4(fp)
 d02bca8:	18840520 	cmpeqi	r2,r3,4116
 d02bcac:	1000571e 	bne	r2,zero,d02be0c <sosetopt+0x22c>
 d02bcb0:	e0ffff17 	ldw	r3,-4(fp)
 d02bcb4:	18840548 	cmpgei	r2,r3,4117
 d02bcb8:	10000f1e 	bne	r2,zero,d02bcf8 <sosetopt+0x118>
 d02bcbc:	e0ffff17 	ldw	r3,-4(fp)
 d02bcc0:	188401a0 	cmpeqi	r2,r3,4102
 d02bcc4:	10004c1e 	bne	r2,zero,d02bdf8 <sosetopt+0x218>
 d02bcc8:	e0ffff17 	ldw	r3,-4(fp)
 d02bccc:	188401c8 	cmpgei	r2,r3,4103
 d02bcd0:	1000051e 	bne	r2,zero,d02bce8 <sosetopt+0x108>
 d02bcd4:	e0ffff17 	ldw	r3,-4(fp)
 d02bcd8:	18bbffc4 	addi	r2,r3,-4097
 d02bcdc:	108000a8 	cmpgeui	r2,r2,2
 d02bce0:	1000e71e 	bne	r2,zero,d02c080 <sosetopt+0x4a0>
 d02bce4:	00003006 	br	d02bda8 <sosetopt+0x1c8>
 d02bce8:	e0ffff17 	ldw	r3,-4(fp)
 d02bcec:	18840420 	cmpeqi	r2,r3,4112
 d02bcf0:	1000ba1e 	bne	r2,zero,d02bfdc <sosetopt+0x3fc>
 d02bcf4:	0000e206 	br	d02c080 <sosetopt+0x4a0>
 d02bcf8:	e0ffff17 	ldw	r3,-4(fp)
 d02bcfc:	188800e0 	cmpeqi	r2,r3,8195
 d02bd00:	1000b61e 	bne	r2,zero,d02bfdc <sosetopt+0x3fc>
 d02bd04:	e0ffff17 	ldw	r3,-4(fp)
 d02bd08:	18880108 	cmpgei	r2,r3,8196
 d02bd0c:	1000071e 	bne	r2,zero,d02bd2c <sosetopt+0x14c>
 d02bd10:	e0ffff17 	ldw	r3,-4(fp)
 d02bd14:	18840560 	cmpeqi	r2,r3,4117
 d02bd18:	1000431e 	bne	r2,zero,d02be28 <sosetopt+0x248>
 d02bd1c:	e0ffff17 	ldw	r3,-4(fp)
 d02bd20:	188405a0 	cmpeqi	r2,r3,4118
 d02bd24:	1000481e 	bne	r2,zero,d02be48 <sosetopt+0x268>
 d02bd28:	0000d506 	br	d02c080 <sosetopt+0x4a0>
 d02bd2c:	e0ffff17 	ldw	r3,-4(fp)
 d02bd30:	18880120 	cmpeqi	r2,r3,8196
 d02bd34:	10007a1e 	bne	r2,zero,d02bf20 <sosetopt+0x340>
 d02bd38:	e0ffff17 	ldw	r3,-4(fp)
 d02bd3c:	18900020 	cmpeqi	r2,r3,16384
 d02bd40:	1000061e 	bne	r2,zero,d02bd5c <sosetopt+0x17c>
 d02bd44:	0000ce06 	br	d02c080 <sosetopt+0x4a0>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 d02bd48:	e0bffd17 	ldw	r2,-12(fp)
 d02bd4c:	10800117 	ldw	r2,4(r2)
 d02bd50:	1007883a 	mov	r3,r2
 d02bd54:	e0bffb17 	ldw	r2,-20(fp)
 d02bd58:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 d02bd5c:	e0bffd17 	ldw	r2,-12(fp)
 d02bd60:	10800017 	ldw	r2,0(r2)
 d02bd64:	1005003a 	cmpeq	r2,r2,zero
 d02bd68:	1000071e 	bne	r2,zero,d02bd88 <sosetopt+0x1a8>
         so->so_options |= optname;
 d02bd6c:	e0bffb17 	ldw	r2,-20(fp)
 d02bd70:	10c00417 	ldw	r3,16(r2)
 d02bd74:	e0bffc17 	ldw	r2,-16(fp)
 d02bd78:	1886b03a 	or	r3,r3,r2
 d02bd7c:	e0bffb17 	ldw	r2,-20(fp)
 d02bd80:	10c00415 	stw	r3,16(r2)
 d02bd84:	0000c006 	br	d02c088 <sosetopt+0x4a8>
      else
         so->so_options &= ~optname;
 d02bd88:	e0bffb17 	ldw	r2,-20(fp)
 d02bd8c:	10c00417 	ldw	r3,16(r2)
 d02bd90:	e0bffc17 	ldw	r2,-16(fp)
 d02bd94:	0084303a 	nor	r2,zero,r2
 d02bd98:	1886703a 	and	r3,r3,r2
 d02bd9c:	e0bffb17 	ldw	r2,-20(fp)
 d02bda0:	10c00415 	stw	r3,16(r2)
      break;
 d02bda4:	0000b806 	br	d02c088 <sosetopt+0x4a8>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 d02bda8:	e0bffc17 	ldw	r2,-16(fp)
 d02bdac:	10840058 	cmpnei	r2,r2,4097
 d02bdb0:	1000041e 	bne	r2,zero,d02bdc4 <sosetopt+0x1e4>
 d02bdb4:	e0bffb17 	ldw	r2,-20(fp)
 d02bdb8:	10801204 	addi	r2,r2,72
 d02bdbc:	e0bffe15 	stw	r2,-8(fp)
 d02bdc0:	00000306 	br	d02bdd0 <sosetopt+0x1f0>
 d02bdc4:	e0bffb17 	ldw	r2,-20(fp)
 d02bdc8:	10800a04 	addi	r2,r2,40
 d02bdcc:	e0bffe15 	stw	r2,-8(fp)
 d02bdd0:	e0bffd17 	ldw	r2,-12(fp)
 d02bdd4:	10800017 	ldw	r2,0(r2)
 d02bdd8:	100b883a 	mov	r5,r2
 d02bddc:	e13ffe17 	ldw	r4,-8(fp)
 d02bde0:	d02cf180 	call	d02cf18 <sbreserve>
 d02bde4:	1004c03a 	cmpne	r2,r2,zero
 d02bde8:	1000a71e 	bne	r2,zero,d02c088 <sosetopt+0x4a8>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 d02bdec:	00801a44 	movi	r2,105
 d02bdf0:	e0bffa15 	stw	r2,-24(fp)
         goto bad;
 d02bdf4:	0000a406 	br	d02c088 <sosetopt+0x4a8>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 d02bdf8:	e0bffd17 	ldw	r2,-12(fp)
 d02bdfc:	10c0000b 	ldhu	r3,0(r2)
 d02be00:	e0bffb17 	ldw	r2,-20(fp)
 d02be04:	10c0118d 	sth	r3,70(r2)
      break;
 d02be08:	00009f06 	br	d02c088 <sosetopt+0x4a8>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 d02be0c:	e0bffb17 	ldw	r2,-20(fp)
 d02be10:	1080088b 	ldhu	r2,34(r2)
 d02be14:	10804014 	ori	r2,r2,256
 d02be18:	1007883a 	mov	r3,r2
 d02be1c:	e0bffb17 	ldw	r2,-20(fp)
 d02be20:	10c0088d 	sth	r3,34(r2)
      break;
 d02be24:	00009806 	br	d02c088 <sosetopt+0x4a8>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 d02be28:	e0bffb17 	ldw	r2,-20(fp)
 d02be2c:	10c0088b 	ldhu	r3,34(r2)
 d02be30:	00bfbfc4 	movi	r2,-257
 d02be34:	1884703a 	and	r2,r3,r2
 d02be38:	1007883a 	mov	r3,r2
 d02be3c:	e0bffb17 	ldw	r2,-20(fp)
 d02be40:	10c0088d 	sth	r3,34(r2)
      break;
 d02be44:	00009006 	br	d02c088 <sosetopt+0x4a8>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 d02be48:	e0bffd17 	ldw	r2,-12(fp)
 d02be4c:	1004c03a 	cmpne	r2,r2,zero
 d02be50:	1000031e 	bne	r2,zero,d02be60 <sosetopt+0x280>
      {
         error = ENP_PARAM;
 d02be54:	00bffd84 	movi	r2,-10
 d02be58:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02be5c:	00008a06 	br	d02c088 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 d02be60:	e0bffd17 	ldw	r2,-12(fp)
 d02be64:	10800017 	ldw	r2,0(r2)
 d02be68:	1005003a 	cmpeq	r2,r2,zero
 d02be6c:	1000071e 	bne	r2,zero,d02be8c <sosetopt+0x2ac>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 d02be70:	e0bffb17 	ldw	r2,-20(fp)
 d02be74:	1080088b 	ldhu	r2,34(r2)
 d02be78:	10804014 	ori	r2,r2,256
 d02be7c:	1007883a 	mov	r3,r2
 d02be80:	e0bffb17 	ldw	r2,-20(fp)
 d02be84:	10c0088d 	sth	r3,34(r2)
 d02be88:	00007f06 	br	d02c088 <sosetopt+0x4a8>
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 d02be8c:	e0bffb17 	ldw	r2,-20(fp)
 d02be90:	10c0088b 	ldhu	r3,34(r2)
 d02be94:	00bfbfc4 	movi	r2,-257
 d02be98:	1884703a 	and	r2,r3,r2
 d02be9c:	1007883a 	mov	r3,r2
 d02bea0:	e0bffb17 	ldw	r2,-20(fp)
 d02bea4:	10c0088d 	sth	r3,34(r2)
      break;
 d02bea8:	00007706 	br	d02c088 <sosetopt+0x4a8>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 d02beac:	e13ffc17 	ldw	r4,-16(fp)
 d02beb0:	e17ffb17 	ldw	r5,-20(fp)
 d02beb4:	e1bffd17 	ldw	r6,-12(fp)
 d02beb8:	d0461380 	call	d046138 <ip_setmoptions>
 d02bebc:	e0bffa15 	stw	r2,-24(fp)
      break;
 d02bec0:	00007106 	br	d02c088 <sosetopt+0x4a8>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 d02bec4:	e0bffd17 	ldw	r2,-12(fp)
 d02bec8:	1004c03a 	cmpne	r2,r2,zero
 d02becc:	1000031e 	bne	r2,zero,d02bedc <sosetopt+0x2fc>
      {
         error = ENP_PARAM;
 d02bed0:	00bffd84 	movi	r2,-10
 d02bed4:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02bed8:	00006b06 	br	d02c088 <sosetopt+0x4a8>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 d02bedc:	e0bffd17 	ldw	r2,-12(fp)
 d02bee0:	10800017 	ldw	r2,0(r2)
 d02bee4:	1005003a 	cmpeq	r2,r2,zero
 d02bee8:	1000061e 	bne	r2,zero,d02bf04 <sosetopt+0x324>
         so->so_options |= SO_HDRINCL;
 d02beec:	e0bffb17 	ldw	r2,-20(fp)
 d02bef0:	10800417 	ldw	r2,16(r2)
 d02bef4:	10c80014 	ori	r3,r2,8192
 d02bef8:	e0bffb17 	ldw	r2,-20(fp)
 d02befc:	10c00415 	stw	r3,16(r2)
 d02bf00:	00006106 	br	d02c088 <sosetopt+0x4a8>
      else
         so->so_options &= ~SO_HDRINCL;
 d02bf04:	e0bffb17 	ldw	r2,-20(fp)
 d02bf08:	10c00417 	ldw	r3,16(r2)
 d02bf0c:	00b7ffc4 	movi	r2,-8193
 d02bf10:	1886703a 	and	r3,r3,r2
 d02bf14:	e0bffb17 	ldw	r2,-20(fp)
 d02bf18:	10c00415 	stw	r3,16(r2)
      break;
 d02bf1c:	00005a06 	br	d02c088 <sosetopt+0x4a8>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02bf20:	e0bffb17 	ldw	r2,-20(fp)
 d02bf24:	10800983 	ldbu	r2,38(r2)
 d02bf28:	10803fcc 	andi	r2,r2,255
 d02bf2c:	1080201c 	xori	r2,r2,128
 d02bf30:	10bfe004 	addi	r2,r2,-128
 d02bf34:	10800060 	cmpeqi	r2,r2,1
 d02bf38:	1000031e 	bne	r2,zero,d02bf48 <sosetopt+0x368>
      {
         error = EINVAL;
 d02bf3c:	00800584 	movi	r2,22
 d02bf40:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02bf44:	00005006 	br	d02c088 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02bf48:	e0bffb17 	ldw	r2,-20(fp)
 d02bf4c:	10800117 	ldw	r2,4(r2)
 d02bf50:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 d02bf54:	e0bff917 	ldw	r2,-28(fp)
 d02bf58:	10800917 	ldw	r2,36(r2)
 d02bf5c:	e0bff815 	stw	r2,-32(fp)
      if(!tp)
 d02bf60:	e0bff817 	ldw	r2,-32(fp)
 d02bf64:	1004c03a 	cmpne	r2,r2,zero
 d02bf68:	1000031e 	bne	r2,zero,d02bf78 <sosetopt+0x398>
      {
         error = ENOTCONN;
 d02bf6c:	00802004 	movi	r2,128
 d02bf70:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02bf74:	00004406 	br	d02c088 <sosetopt+0x4a8>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 d02bf78:	e0bffd17 	ldw	r2,-12(fp)
 d02bf7c:	1004c03a 	cmpne	r2,r2,zero
 d02bf80:	1000031e 	bne	r2,zero,d02bf90 <sosetopt+0x3b0>
      {
         error = ENP_PARAM;
 d02bf84:	00bffd84 	movi	r2,-10
 d02bf88:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02bf8c:	00003e06 	br	d02c088 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 d02bf90:	e0bffd17 	ldw	r2,-12(fp)
 d02bf94:	10800017 	ldw	r2,0(r2)
 d02bf98:	1005003a 	cmpeq	r2,r2,zero
 d02bf9c:	1000071e 	bne	r2,zero,d02bfbc <sosetopt+0x3dc>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 d02bfa0:	e0bff817 	ldw	r2,-32(fp)
 d02bfa4:	10800b0b 	ldhu	r2,44(r2)
 d02bfa8:	10800114 	ori	r2,r2,4
 d02bfac:	1007883a 	mov	r3,r2
 d02bfb0:	e0bff817 	ldw	r2,-32(fp)
 d02bfb4:	10c00b0d 	sth	r3,44(r2)
 d02bfb8:	00003306 	br	d02c088 <sosetopt+0x4a8>
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 d02bfbc:	e0bff817 	ldw	r2,-32(fp)
 d02bfc0:	10c00b0b 	ldhu	r3,44(r2)
 d02bfc4:	00bffec4 	movi	r2,-5
 d02bfc8:	1884703a 	and	r2,r3,r2
 d02bfcc:	1007883a 	mov	r3,r2
 d02bfd0:	e0bff817 	ldw	r2,-32(fp)
 d02bfd4:	10c00b0d 	sth	r3,44(r2)

      break;
 d02bfd8:	00002b06 	br	d02c088 <sosetopt+0x4a8>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02bfdc:	e0bffb17 	ldw	r2,-20(fp)
 d02bfe0:	10800983 	ldbu	r2,38(r2)
 d02bfe4:	10803fcc 	andi	r2,r2,255
 d02bfe8:	1080201c 	xori	r2,r2,128
 d02bfec:	10bfe004 	addi	r2,r2,-128
 d02bff0:	10800060 	cmpeqi	r2,r2,1
 d02bff4:	1000031e 	bne	r2,zero,d02c004 <sosetopt+0x424>
      {
         error = EINVAL;
 d02bff8:	00800584 	movi	r2,22
 d02bffc:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c000:	00002106 	br	d02c088 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02c004:	e0bffb17 	ldw	r2,-20(fp)
 d02c008:	10800117 	ldw	r2,4(r2)
 d02c00c:	e0bff715 	stw	r2,-36(fp)
      tp = intotcpcb(inp);
 d02c010:	e0bff717 	ldw	r2,-36(fp)
 d02c014:	10800917 	ldw	r2,36(r2)
 d02c018:	e0bff615 	stw	r2,-40(fp)
      if(!tp)
 d02c01c:	e0bff617 	ldw	r2,-40(fp)
 d02c020:	1004c03a 	cmpne	r2,r2,zero
 d02c024:	1000031e 	bne	r2,zero,d02c034 <sosetopt+0x454>
      {
         error = ENOTCONN;
 d02c028:	00802004 	movi	r2,128
 d02c02c:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c030:	00001506 	br	d02c088 <sosetopt+0x4a8>
      }
      if (tp->t_state != TCPS_CLOSED)
 d02c034:	e0bff617 	ldw	r2,-40(fp)
 d02c038:	10800217 	ldw	r2,8(r2)
 d02c03c:	1005003a 	cmpeq	r2,r2,zero
 d02c040:	1000031e 	bne	r2,zero,d02c050 <sosetopt+0x470>
      {
         error = EINVAL;
 d02c044:	00800584 	movi	r2,22
 d02c048:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c04c:	00000e06 	br	d02c088 <sosetopt+0x4a8>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 d02c050:	e0bffd17 	ldw	r2,-12(fp)
 d02c054:	10800017 	ldw	r2,0(r2)
 d02c058:	1007883a 	mov	r3,r2
 d02c05c:	e0bff617 	ldw	r2,-40(fp)
 d02c060:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 d02c064:	e0bff617 	ldw	r2,-40(fp)
 d02c068:	10800b0b 	ldhu	r2,44(r2)
 d02c06c:	10810014 	ori	r2,r2,1024
 d02c070:	1007883a 	mov	r3,r2
 d02c074:	e0bff617 	ldw	r2,-40(fp)
 d02c078:	10c00b0d 	sth	r3,44(r2)
      break;
 d02c07c:	00000206 	br	d02c088 <sosetopt+0x4a8>
   }
   default:
      error = ENOPROTOOPT;
 d02c080:	00801b44 	movi	r2,109
 d02c084:	e0bffa15 	stw	r2,-24(fp)
      break;
   }
bad:
   return (error);
 d02c088:	e0bffa17 	ldw	r2,-24(fp)
}
 d02c08c:	e037883a 	mov	sp,fp
 d02c090:	dfc00117 	ldw	ra,4(sp)
 d02c094:	df000017 	ldw	fp,0(sp)
 d02c098:	dec00204 	addi	sp,sp,8
 d02c09c:	f800283a 	ret

0d02c0a0 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 d02c0a0:	defff304 	addi	sp,sp,-52
 d02c0a4:	dfc00c15 	stw	ra,48(sp)
 d02c0a8:	df000b15 	stw	fp,44(sp)
 d02c0ac:	df000b04 	addi	fp,sp,44
 d02c0b0:	e13ffb15 	stw	r4,-20(fp)
 d02c0b4:	e17ffc15 	stw	r5,-16(fp)
 d02c0b8:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 d02c0bc:	e03ffa15 	stw	zero,-24(fp)

   /* sanity check the val parameter */
   if (!val)
 d02c0c0:	e0bffd17 	ldw	r2,-12(fp)
 d02c0c4:	1004c03a 	cmpne	r2,r2,zero
 d02c0c8:	1000031e 	bne	r2,zero,d02c0d8 <sogetopt+0x38>
   {
      return ENP_PARAM;
 d02c0cc:	00bffd84 	movi	r2,-10
 d02c0d0:	e0bffe15 	stw	r2,-8(fp)
 d02c0d4:	00013c06 	br	d02c5c8 <sogetopt+0x528>
   }

   switch (optname) 
 d02c0d8:	e0fffc17 	ldw	r3,-16(fp)
 d02c0dc:	e0ffff15 	stw	r3,-4(fp)
 d02c0e0:	e0ffff17 	ldw	r3,-4(fp)
 d02c0e4:	188400e0 	cmpeqi	r2,r3,4099
 d02c0e8:	10008f1e 	bne	r2,zero,d02c328 <sogetopt+0x288>
 d02c0ec:	e0ffff17 	ldw	r3,-4(fp)
 d02c0f0:	18840108 	cmpgei	r2,r3,4100
 d02c0f4:	10002e1e 	bne	r2,zero,d02c1b0 <sogetopt+0x110>
 d02c0f8:	e0ffff17 	ldw	r3,-4(fp)
 d02c0fc:	18800420 	cmpeqi	r2,r3,16
 d02c100:	1000821e 	bne	r2,zero,d02c30c <sogetopt+0x26c>
 d02c104:	e0ffff17 	ldw	r3,-4(fp)
 d02c108:	18800448 	cmpgei	r2,r3,17
 d02c10c:	1000111e 	bne	r2,zero,d02c154 <sogetopt+0xb4>
 d02c110:	e0ffff17 	ldw	r3,-4(fp)
 d02c114:	18800220 	cmpeqi	r2,r3,8
 d02c118:	10007c1e 	bne	r2,zero,d02c30c <sogetopt+0x26c>
 d02c11c:	e0ffff17 	ldw	r3,-4(fp)
 d02c120:	18800248 	cmpgei	r2,r3,9
 d02c124:	1000071e 	bne	r2,zero,d02c144 <sogetopt+0xa4>
 d02c128:	e0ffff17 	ldw	r3,-4(fp)
 d02c12c:	188000a0 	cmpeqi	r2,r3,2
 d02c130:	1000eb1e 	bne	r2,zero,d02c4e0 <sogetopt+0x440>
 d02c134:	e0ffff17 	ldw	r3,-4(fp)
 d02c138:	18800120 	cmpeqi	r2,r3,4
 d02c13c:	1000731e 	bne	r2,zero,d02c30c <sogetopt+0x26c>
 d02c140:	00011c06 	br	d02c5b4 <sogetopt+0x514>
 d02c144:	e0ffff17 	ldw	r3,-4(fp)
 d02c148:	18800308 	cmpgei	r2,r3,12
 d02c14c:	1001191e 	bne	r2,zero,d02c5b4 <sogetopt+0x514>
 d02c150:	0000dd06 	br	d02c4c8 <sogetopt+0x428>
 d02c154:	e0ffff17 	ldw	r3,-4(fp)
 d02c158:	18804020 	cmpeqi	r2,r3,256
 d02c15c:	10006b1e 	bne	r2,zero,d02c30c <sogetopt+0x26c>
 d02c160:	e0ffff17 	ldw	r3,-4(fp)
 d02c164:	18804048 	cmpgei	r2,r3,257
 d02c168:	1000071e 	bne	r2,zero,d02c188 <sogetopt+0xe8>
 d02c16c:	e0ffff17 	ldw	r3,-4(fp)
 d02c170:	18800820 	cmpeqi	r2,r3,32
 d02c174:	1000651e 	bne	r2,zero,d02c30c <sogetopt+0x26c>
 d02c178:	e0ffff17 	ldw	r3,-4(fp)
 d02c17c:	18802020 	cmpeqi	r2,r3,128
 d02c180:	1000531e 	bne	r2,zero,d02c2d0 <sogetopt+0x230>
 d02c184:	00010b06 	br	d02c5b4 <sogetopt+0x514>
 d02c188:	e0ffff17 	ldw	r3,-4(fp)
 d02c18c:	18840060 	cmpeqi	r2,r3,4097
 d02c190:	10006f1e 	bne	r2,zero,d02c350 <sogetopt+0x2b0>
 d02c194:	e0ffff17 	ldw	r3,-4(fp)
 d02c198:	18840088 	cmpgei	r2,r3,4098
 d02c19c:	1000711e 	bne	r2,zero,d02c364 <sogetopt+0x2c4>
 d02c1a0:	e0ffff17 	ldw	r3,-4(fp)
 d02c1a4:	18808020 	cmpeqi	r2,r3,512
 d02c1a8:	1000581e 	bne	r2,zero,d02c30c <sogetopt+0x26c>
 d02c1ac:	00010106 	br	d02c5b4 <sogetopt+0x514>
 d02c1b0:	e0ffff17 	ldw	r3,-4(fp)
 d02c1b4:	18840420 	cmpeqi	r2,r3,4112
 d02c1b8:	1000881e 	bne	r2,zero,d02c3dc <sogetopt+0x33c>
 d02c1bc:	e0ffff17 	ldw	r3,-4(fp)
 d02c1c0:	18840448 	cmpgei	r2,r3,4113
 d02c1c4:	1000171e 	bne	r2,zero,d02c224 <sogetopt+0x184>
 d02c1c8:	e0ffff17 	ldw	r3,-4(fp)
 d02c1cc:	188401a0 	cmpeqi	r2,r3,4102
 d02c1d0:	1000a31e 	bne	r2,zero,d02c460 <sogetopt+0x3c0>
 d02c1d4:	e0ffff17 	ldw	r3,-4(fp)
 d02c1d8:	188401c8 	cmpgei	r2,r3,4103
 d02c1dc:	1000071e 	bne	r2,zero,d02c1fc <sogetopt+0x15c>
 d02c1e0:	e0ffff17 	ldw	r3,-4(fp)
 d02c1e4:	18840120 	cmpeqi	r2,r3,4100
 d02c1e8:	1000541e 	bne	r2,zero,d02c33c <sogetopt+0x29c>
 d02c1ec:	e0ffff17 	ldw	r3,-4(fp)
 d02c1f0:	18840160 	cmpeqi	r2,r3,4101
 d02c1f4:	1000951e 	bne	r2,zero,d02c44c <sogetopt+0x3ac>
 d02c1f8:	0000ee06 	br	d02c5b4 <sogetopt+0x514>
 d02c1fc:	e0ffff17 	ldw	r3,-4(fp)
 d02c200:	18840220 	cmpeqi	r2,r3,4104
 d02c204:	1000661e 	bne	r2,zero,d02c3a0 <sogetopt+0x300>
 d02c208:	e0ffff17 	ldw	r3,-4(fp)
 d02c20c:	18840210 	cmplti	r2,r3,4104
 d02c210:	10006b1e 	bne	r2,zero,d02c3c0 <sogetopt+0x320>
 d02c214:	e0ffff17 	ldw	r3,-4(fp)
 d02c218:	18840260 	cmpeqi	r2,r3,4105
 d02c21c:	1000951e 	bne	r2,zero,d02c474 <sogetopt+0x3d4>
 d02c220:	0000e406 	br	d02c5b4 <sogetopt+0x514>
 d02c224:	e0ffff17 	ldw	r3,-4(fp)
 d02c228:	188404e0 	cmpeqi	r2,r3,4115
 d02c22c:	1000141e 	bne	r2,zero,d02c280 <sogetopt+0x1e0>
 d02c230:	e0ffff17 	ldw	r3,-4(fp)
 d02c234:	18840508 	cmpgei	r2,r3,4116
 d02c238:	1000071e 	bne	r2,zero,d02c258 <sogetopt+0x1b8>
 d02c23c:	e0ffff17 	ldw	r3,-4(fp)
 d02c240:	18840460 	cmpeqi	r2,r3,4113
 d02c244:	10004c1e 	bne	r2,zero,d02c378 <sogetopt+0x2d8>
 d02c248:	e0ffff17 	ldw	r3,-4(fp)
 d02c24c:	188404a0 	cmpeqi	r2,r3,4114
 d02c250:	10004e1e 	bne	r2,zero,d02c38c <sogetopt+0x2ec>
 d02c254:	0000d706 	br	d02c5b4 <sogetopt+0x514>
 d02c258:	e0ffff17 	ldw	r3,-4(fp)
 d02c25c:	188800e0 	cmpeqi	r2,r3,8195
 d02c260:	10005e1e 	bne	r2,zero,d02c3dc <sogetopt+0x33c>
 d02c264:	e0ffff17 	ldw	r3,-4(fp)
 d02c268:	18880120 	cmpeqi	r2,r3,8196
 d02c26c:	1000a81e 	bne	r2,zero,d02c510 <sogetopt+0x470>
 d02c270:	e0ffff17 	ldw	r3,-4(fp)
 d02c274:	188405a0 	cmpeqi	r2,r3,4118
 d02c278:	1000861e 	bne	r2,zero,d02c494 <sogetopt+0x3f4>
 d02c27c:	0000cd06 	br	d02c5b4 <sogetopt+0x514>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 d02c280:	e0bffb17 	ldw	r2,-20(fp)
 d02c284:	1080088b 	ldhu	r2,34(r2)
 d02c288:	10bfffcc 	andi	r2,r2,65535
 d02c28c:	1080008c 	andi	r2,r2,2
 d02c290:	1005003a 	cmpeq	r2,r2,zero
 d02c294:	1000071e 	bne	r2,zero,d02c2b4 <sogetopt+0x214>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 d02c298:	e0fffd17 	ldw	r3,-12(fp)
 d02c29c:	e0bffb17 	ldw	r2,-20(fp)
 d02c2a0:	10800117 	ldw	r2,4(r2)
 d02c2a4:	10800a17 	ldw	r2,40(r2)
 d02c2a8:	10800a17 	ldw	r2,40(r2)
 d02c2ac:	18800015 	stw	r2,0(r3)
 d02c2b0:	0000c306 	br	d02c5c0 <sogetopt+0x520>
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 d02c2b4:	e0fffd17 	ldw	r3,-12(fp)
 d02c2b8:	008341b4 	movhi	r2,3334
 d02c2bc:	10831a04 	addi	r2,r2,3176
 d02c2c0:	10800017 	ldw	r2,0(r2)
 d02c2c4:	10800a17 	ldw	r2,40(r2)
 d02c2c8:	18800015 	stw	r2,0(r3)
      break;
 d02c2cc:	0000bc06 	br	d02c5c0 <sogetopt+0x520>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 d02c2d0:	e0bffd17 	ldw	r2,-12(fp)
 d02c2d4:	e0bff915 	stw	r2,-28(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 d02c2d8:	e0bffb17 	ldw	r2,-20(fp)
 d02c2dc:	10800417 	ldw	r2,16(r2)
 d02c2e0:	10c0200c 	andi	r3,r2,128
 d02c2e4:	e0bff917 	ldw	r2,-28(fp)
 d02c2e8:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 d02c2ec:	e0bffb17 	ldw	r2,-20(fp)
 d02c2f0:	1080080b 	ldhu	r2,32(r2)
 d02c2f4:	10ffffcc 	andi	r3,r2,65535
 d02c2f8:	18e0001c 	xori	r3,r3,32768
 d02c2fc:	18e00004 	addi	r3,r3,-32768
 d02c300:	e0bff917 	ldw	r2,-28(fp)
 d02c304:	10c00115 	stw	r3,4(r2)
      }
      break;
 d02c308:	0000ad06 	br	d02c5c0 <sogetopt+0x520>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 d02c30c:	e13ffd17 	ldw	r4,-12(fp)
 d02c310:	e0bffb17 	ldw	r2,-20(fp)
 d02c314:	10c00417 	ldw	r3,16(r2)
 d02c318:	e0bffc17 	ldw	r2,-16(fp)
 d02c31c:	1884703a 	and	r2,r3,r2
 d02c320:	20800015 	stw	r2,0(r4)
      break;
 d02c324:	0000a606 	br	d02c5c0 <sogetopt+0x520>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 d02c328:	e0fffd17 	ldw	r3,-12(fp)
 d02c32c:	e0bffb17 	ldw	r2,-20(fp)
 d02c330:	10801617 	ldw	r2,88(r2)
 d02c334:	18800015 	stw	r2,0(r3)
      break;
 d02c338:	0000a106 	br	d02c5c0 <sogetopt+0x520>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 d02c33c:	e0fffd17 	ldw	r3,-12(fp)
 d02c340:	e0bffb17 	ldw	r2,-20(fp)
 d02c344:	10800e17 	ldw	r2,56(r2)
 d02c348:	18800015 	stw	r2,0(r3)
      break;
 d02c34c:	00009c06 	br	d02c5c0 <sogetopt+0x520>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 d02c350:	e0fffd17 	ldw	r3,-12(fp)
 d02c354:	e0bffb17 	ldw	r2,-20(fp)
 d02c358:	10801317 	ldw	r2,76(r2)
 d02c35c:	18800015 	stw	r2,0(r3)
      break;
 d02c360:	00009706 	br	d02c5c0 <sogetopt+0x520>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 d02c364:	e0fffd17 	ldw	r3,-12(fp)
 d02c368:	e0bffb17 	ldw	r2,-20(fp)
 d02c36c:	10800b17 	ldw	r2,44(r2)
 d02c370:	18800015 	stw	r2,0(r3)
      break;
 d02c374:	00009206 	br	d02c5c0 <sogetopt+0x520>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 d02c378:	e0fffd17 	ldw	r3,-12(fp)
 d02c37c:	e0bffb17 	ldw	r2,-20(fp)
 d02c380:	10800a17 	ldw	r2,40(r2)
 d02c384:	18800015 	stw	r2,0(r3)
      break;
 d02c388:	00008d06 	br	d02c5c0 <sogetopt+0x520>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 d02c38c:	e0fffd17 	ldw	r3,-12(fp)
 d02c390:	e0bffb17 	ldw	r2,-20(fp)
 d02c394:	10801217 	ldw	r2,72(r2)
 d02c398:	18800015 	stw	r2,0(r3)
      break;
 d02c39c:	00008806 	br	d02c5c0 <sogetopt+0x520>

   case SO_TYPE:
      *(int *)val = so->so_type;
 d02c3a0:	e0fffd17 	ldw	r3,-12(fp)
 d02c3a4:	e0bffb17 	ldw	r2,-20(fp)
 d02c3a8:	10800983 	ldbu	r2,38(r2)
 d02c3ac:	10803fcc 	andi	r2,r2,255
 d02c3b0:	1080201c 	xori	r2,r2,128
 d02c3b4:	10bfe004 	addi	r2,r2,-128
 d02c3b8:	18800015 	stw	r2,0(r3)
      break;
 d02c3bc:	00008006 	br	d02c5c0 <sogetopt+0x520>

   case SO_ERROR:
      *(int *)val = so->so_error;
 d02c3c0:	e0fffd17 	ldw	r3,-12(fp)
 d02c3c4:	e0bffb17 	ldw	r2,-20(fp)
 d02c3c8:	10800617 	ldw	r2,24(r2)
 d02c3cc:	18800015 	stw	r2,0(r3)
      so->so_error = 0;
 d02c3d0:	e0bffb17 	ldw	r2,-20(fp)
 d02c3d4:	10000615 	stw	zero,24(r2)
      break;
 d02c3d8:	00007906 	br	d02c5c0 <sogetopt+0x520>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02c3dc:	e0bffb17 	ldw	r2,-20(fp)
 d02c3e0:	10800983 	ldbu	r2,38(r2)
 d02c3e4:	10803fcc 	andi	r2,r2,255
 d02c3e8:	1080201c 	xori	r2,r2,128
 d02c3ec:	10bfe004 	addi	r2,r2,-128
 d02c3f0:	10800060 	cmpeqi	r2,r2,1
 d02c3f4:	1000031e 	bne	r2,zero,d02c404 <sogetopt+0x364>
      {
         error = EINVAL;
 d02c3f8:	00800584 	movi	r2,22
 d02c3fc:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c400:	00006f06 	br	d02c5c0 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02c404:	e0bffb17 	ldw	r2,-20(fp)
 d02c408:	10800117 	ldw	r2,4(r2)
 d02c40c:	e0bff815 	stw	r2,-32(fp)
      tp = intotcpcb(inp);
 d02c410:	e0bff817 	ldw	r2,-32(fp)
 d02c414:	10800917 	ldw	r2,36(r2)
 d02c418:	e0bff715 	stw	r2,-36(fp)
      if(!tp)
 d02c41c:	e0bff717 	ldw	r2,-36(fp)
 d02c420:	1004c03a 	cmpne	r2,r2,zero
 d02c424:	1000031e 	bne	r2,zero,d02c434 <sogetopt+0x394>
      {
         error = ENOTCONN;
 d02c428:	00802004 	movi	r2,128
 d02c42c:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c430:	00006306 	br	d02c5c0 <sogetopt+0x520>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 d02c434:	e0fffd17 	ldw	r3,-12(fp)
 d02c438:	e0bff717 	ldw	r2,-36(fp)
 d02c43c:	10800a0b 	ldhu	r2,40(r2)
 d02c440:	10bfffcc 	andi	r2,r2,65535
 d02c444:	18800015 	stw	r2,0(r3)
      break;
 d02c448:	00005d06 	br	d02c5c0 <sogetopt+0x520>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 d02c44c:	e0bffd17 	ldw	r2,-12(fp)
 d02c450:	e0fffb17 	ldw	r3,-20(fp)
 d02c454:	18c0198b 	ldhu	r3,102(r3)
 d02c458:	10c0000d 	sth	r3,0(r2)
      break;
 d02c45c:	00005806 	br	d02c5c0 <sogetopt+0x520>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 d02c460:	e0bffd17 	ldw	r2,-12(fp)
 d02c464:	e0fffb17 	ldw	r3,-20(fp)
 d02c468:	18c0118b 	ldhu	r3,70(r3)
 d02c46c:	10c0000d 	sth	r3,0(r2)
      break;
 d02c470:	00005306 	br	d02c5c0 <sogetopt+0x520>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 d02c474:	e0fffd17 	ldw	r3,-12(fp)
 d02c478:	e0bffb17 	ldw	r2,-20(fp)
 d02c47c:	108009c3 	ldbu	r2,39(r2)
 d02c480:	10803fcc 	andi	r2,r2,255
 d02c484:	1080201c 	xori	r2,r2,128
 d02c488:	10bfe004 	addi	r2,r2,-128
 d02c48c:	18800015 	stw	r2,0(r3)
      break;
 d02c490:	00004b06 	br	d02c5c0 <sogetopt+0x520>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 d02c494:	e0bffb17 	ldw	r2,-20(fp)
 d02c498:	1080088b 	ldhu	r2,34(r2)
 d02c49c:	10bfffcc 	andi	r2,r2,65535
 d02c4a0:	1080400c 	andi	r2,r2,256
 d02c4a4:	1005003a 	cmpeq	r2,r2,zero
 d02c4a8:	1000041e 	bne	r2,zero,d02c4bc <sogetopt+0x41c>
         *(int *)val = 1;   /* return 1 in val */
 d02c4ac:	e0fffd17 	ldw	r3,-12(fp)
 d02c4b0:	00800044 	movi	r2,1
 d02c4b4:	18800015 	stw	r2,0(r3)
 d02c4b8:	00004106 	br	d02c5c0 <sogetopt+0x520>
      else
         *(int *)val = 0;     /* return 0 in val */
 d02c4bc:	e0bffd17 	ldw	r2,-12(fp)
 d02c4c0:	10000015 	stw	zero,0(r2)
      break;
 d02c4c4:	00003e06 	br	d02c5c0 <sogetopt+0x520>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 d02c4c8:	e13ffc17 	ldw	r4,-16(fp)
 d02c4cc:	e17ffb17 	ldw	r5,-20(fp)
 d02c4d0:	e1bffd17 	ldw	r6,-12(fp)
 d02c4d4:	d0467280 	call	d046728 <ip_getmoptions>
 d02c4d8:	e0bffa15 	stw	r2,-24(fp)
      break;
 d02c4dc:	00003806 	br	d02c5c0 <sogetopt+0x520>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 d02c4e0:	e0bffb17 	ldw	r2,-20(fp)
 d02c4e4:	10800417 	ldw	r2,16(r2)
 d02c4e8:	1088000c 	andi	r2,r2,8192
 d02c4ec:	1005003a 	cmpeq	r2,r2,zero
 d02c4f0:	1000041e 	bne	r2,zero,d02c504 <sogetopt+0x464>
         *(int *)val = 1;
 d02c4f4:	e0fffd17 	ldw	r3,-12(fp)
 d02c4f8:	00800044 	movi	r2,1
 d02c4fc:	18800015 	stw	r2,0(r3)
 d02c500:	00002f06 	br	d02c5c0 <sogetopt+0x520>
      else
         *(int *)val = 0;
 d02c504:	e0bffd17 	ldw	r2,-12(fp)
 d02c508:	10000015 	stw	zero,0(r2)
      break;
 d02c50c:	00002c06 	br	d02c5c0 <sogetopt+0x520>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02c510:	e0bffb17 	ldw	r2,-20(fp)
 d02c514:	10800983 	ldbu	r2,38(r2)
 d02c518:	10803fcc 	andi	r2,r2,255
 d02c51c:	1080201c 	xori	r2,r2,128
 d02c520:	10bfe004 	addi	r2,r2,-128
 d02c524:	10800060 	cmpeqi	r2,r2,1
 d02c528:	1000031e 	bne	r2,zero,d02c538 <sogetopt+0x498>
      {
         error = EINVAL;
 d02c52c:	00800584 	movi	r2,22
 d02c530:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c534:	00002206 	br	d02c5c0 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02c538:	e0bffb17 	ldw	r2,-20(fp)
 d02c53c:	10800117 	ldw	r2,4(r2)
 d02c540:	e0bff615 	stw	r2,-40(fp)
      tp = intotcpcb(inp);
 d02c544:	e0bff617 	ldw	r2,-40(fp)
 d02c548:	10800917 	ldw	r2,36(r2)
 d02c54c:	e0bff515 	stw	r2,-44(fp)
      if (!tp)
 d02c550:	e0bff517 	ldw	r2,-44(fp)
 d02c554:	1004c03a 	cmpne	r2,r2,zero
 d02c558:	1000031e 	bne	r2,zero,d02c568 <sogetopt+0x4c8>
      {
         error = ENOTCONN;
 d02c55c:	00802004 	movi	r2,128
 d02c560:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c564:	00001606 	br	d02c5c0 <sogetopt+0x520>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 d02c568:	e0bffd17 	ldw	r2,-12(fp)
 d02c56c:	1004c03a 	cmpne	r2,r2,zero
 d02c570:	1000031e 	bne	r2,zero,d02c580 <sogetopt+0x4e0>
      {
         error = ENP_PARAM;
 d02c574:	00bffd84 	movi	r2,-10
 d02c578:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02c57c:	00001006 	br	d02c5c0 <sogetopt+0x520>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 d02c580:	e0bff517 	ldw	r2,-44(fp)
 d02c584:	10800b0b 	ldhu	r2,44(r2)
 d02c588:	10bfffcc 	andi	r2,r2,65535
 d02c58c:	1080010c 	andi	r2,r2,4
 d02c590:	1005003a 	cmpeq	r2,r2,zero
 d02c594:	1000041e 	bne	r2,zero,d02c5a8 <sogetopt+0x508>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 d02c598:	e0fffd17 	ldw	r3,-12(fp)
 d02c59c:	00800044 	movi	r2,1
 d02c5a0:	18800015 	stw	r2,0(r3)
 d02c5a4:	00000606 	br	d02c5c0 <sogetopt+0x520>
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 d02c5a8:	e0bffd17 	ldw	r2,-12(fp)
 d02c5ac:	10000015 	stw	zero,0(r2)

      break;
 d02c5b0:	00000306 	br	d02c5c0 <sogetopt+0x520>
   }

   default:
      return ENOPROTOOPT;
 d02c5b4:	00801b44 	movi	r2,109
 d02c5b8:	e0bffe15 	stw	r2,-8(fp)
 d02c5bc:	00000206 	br	d02c5c8 <sogetopt+0x528>
   }
   return error;     /* no error */
 d02c5c0:	e0fffa17 	ldw	r3,-24(fp)
 d02c5c4:	e0fffe15 	stw	r3,-8(fp)
 d02c5c8:	e0bffe17 	ldw	r2,-8(fp)
}
 d02c5cc:	e037883a 	mov	sp,fp
 d02c5d0:	dfc00117 	ldw	ra,4(sp)
 d02c5d4:	df000017 	ldw	fp,0(sp)
 d02c5d8:	dec00204 	addi	sp,sp,8
 d02c5dc:	f800283a 	ret

0d02c5e0 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 d02c5e0:	defffd04 	addi	sp,sp,-12
 d02c5e4:	dfc00215 	stw	ra,8(sp)
 d02c5e8:	df000115 	stw	fp,4(sp)
 d02c5ec:	df000104 	addi	fp,sp,4
 d02c5f0:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 d02c5f4:	e0ffff17 	ldw	r3,-4(fp)
 d02c5f8:	00803644 	movi	r2,217
 d02c5fc:	18800615 	stw	r2,24(r3)
   sorwakeup (so);
 d02c600:	e0bfff17 	ldw	r2,-4(fp)
 d02c604:	11400a04 	addi	r5,r2,40
 d02c608:	e13fff17 	ldw	r4,-4(fp)
 d02c60c:	d02cdfc0 	call	d02cdfc <sbwakeup>
}
 d02c610:	e037883a 	mov	sp,fp
 d02c614:	dfc00117 	ldw	ra,4(sp)
 d02c618:	df000017 	ldw	fp,0(sp)
 d02c61c:	dec00204 	addi	sp,sp,8
 d02c620:	f800283a 	ret

0d02c624 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 d02c624:	defffd04 	addi	sp,sp,-12
 d02c628:	dfc00215 	stw	ra,8(sp)
 d02c62c:	df000115 	stw	fp,4(sp)
 d02c630:	df000104 	addi	fp,sp,4
 d02c634:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 d02c638:	e0bfff17 	ldw	r2,-4(fp)
 d02c63c:	10c0088b 	ldhu	r3,34(r2)
 d02c640:	00bffd44 	movi	r2,-11
 d02c644:	1884703a 	and	r2,r3,r2
 d02c648:	1007883a 	mov	r3,r2
 d02c64c:	e0bfff17 	ldw	r2,-4(fp)
 d02c650:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 d02c654:	e0bfff17 	ldw	r2,-4(fp)
 d02c658:	1080088b 	ldhu	r2,34(r2)
 d02c65c:	10800114 	ori	r2,r2,4
 d02c660:	1007883a 	mov	r3,r2
 d02c664:	e0bfff17 	ldw	r2,-4(fp)
 d02c668:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 d02c66c:	e0bfff17 	ldw	r2,-4(fp)
 d02c670:	10800904 	addi	r2,r2,36
 d02c674:	1009883a 	mov	r4,r2
 d02c678:	d02147c0 	call	d02147c <tcp_wakeup>
}
 d02c67c:	e037883a 	mov	sp,fp
 d02c680:	dfc00117 	ldw	ra,4(sp)
 d02c684:	df000017 	ldw	fp,0(sp)
 d02c688:	dec00204 	addi	sp,sp,8
 d02c68c:	f800283a 	ret

0d02c690 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 d02c690:	defffc04 	addi	sp,sp,-16
 d02c694:	dfc00315 	stw	ra,12(sp)
 d02c698:	df000215 	stw	fp,8(sp)
 d02c69c:	df000204 	addi	fp,sp,8
 d02c6a0:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 d02c6a4:	e0bfff17 	ldw	r2,-4(fp)
 d02c6a8:	10801b17 	ldw	r2,108(r2)
 d02c6ac:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 d02c6b0:	e0bffe17 	ldw	r2,-8(fp)
 d02c6b4:	1005003a 	cmpeq	r2,r2,zero
 d02c6b8:	1000141e 	bne	r2,zero,d02c70c <soisconnected+0x7c>
   {
      if (soqremque(so, 0) == 0)
 d02c6bc:	e13fff17 	ldw	r4,-4(fp)
 d02c6c0:	000b883a 	mov	r5,zero
 d02c6c4:	d02cb9c0 	call	d02cb9c <soqremque>
 d02c6c8:	1004c03a 	cmpne	r2,r2,zero
 d02c6cc:	1000031e 	bne	r2,zero,d02c6dc <soisconnected+0x4c>
         panic("soisconnected");
 d02c6d0:	01034174 	movhi	r4,3333
 d02c6d4:	213e9604 	addi	r4,r4,-1448
 d02c6d8:	d02093c0 	call	d02093c <panic>
      soqinsque(head, so, 1);
 d02c6dc:	e13ffe17 	ldw	r4,-8(fp)
 d02c6e0:	e17fff17 	ldw	r5,-4(fp)
 d02c6e4:	01800044 	movi	r6,1
 d02c6e8:	d02caf00 	call	d02caf0 <soqinsque>
      sorwakeup(head);
 d02c6ec:	e0bffe17 	ldw	r2,-8(fp)
 d02c6f0:	11400a04 	addi	r5,r2,40
 d02c6f4:	e13ffe17 	ldw	r4,-8(fp)
 d02c6f8:	d02cdfc0 	call	d02cdfc <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 d02c6fc:	e0bffe17 	ldw	r2,-8(fp)
 d02c700:	10800904 	addi	r2,r2,36
 d02c704:	1009883a 	mov	r4,r2
 d02c708:	d02147c0 	call	d02147c <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 d02c70c:	e0bfff17 	ldw	r2,-4(fp)
 d02c710:	10c0088b 	ldhu	r3,34(r2)
 d02c714:	00bffcc4 	movi	r2,-13
 d02c718:	1884703a 	and	r2,r3,r2
 d02c71c:	1007883a 	mov	r3,r2
 d02c720:	e0bfff17 	ldw	r2,-4(fp)
 d02c724:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 d02c728:	e0bfff17 	ldw	r2,-4(fp)
 d02c72c:	1080088b 	ldhu	r2,34(r2)
 d02c730:	10800094 	ori	r2,r2,2
 d02c734:	1007883a 	mov	r3,r2
 d02c738:	e0bfff17 	ldw	r2,-4(fp)
 d02c73c:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 d02c740:	e0bfff17 	ldw	r2,-4(fp)
 d02c744:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 d02c748:	e0bfff17 	ldw	r2,-4(fp)
 d02c74c:	10800904 	addi	r2,r2,36
 d02c750:	1009883a 	mov	r4,r2
 d02c754:	d02147c0 	call	d02147c <tcp_wakeup>
   sorwakeup (so);
 d02c758:	e0bfff17 	ldw	r2,-4(fp)
 d02c75c:	11400a04 	addi	r5,r2,40
 d02c760:	e13fff17 	ldw	r4,-4(fp)
 d02c764:	d02cdfc0 	call	d02cdfc <sbwakeup>
   sowwakeup (so);
 d02c768:	e0bfff17 	ldw	r2,-4(fp)
 d02c76c:	11401204 	addi	r5,r2,72
 d02c770:	e13fff17 	ldw	r4,-4(fp)
 d02c774:	d02cdfc0 	call	d02cdfc <sbwakeup>
}
 d02c778:	e037883a 	mov	sp,fp
 d02c77c:	dfc00117 	ldw	ra,4(sp)
 d02c780:	df000017 	ldw	fp,0(sp)
 d02c784:	dec00204 	addi	sp,sp,8
 d02c788:	f800283a 	ret

0d02c78c <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 d02c78c:	defffd04 	addi	sp,sp,-12
 d02c790:	dfc00215 	stw	ra,8(sp)
 d02c794:	df000115 	stw	fp,4(sp)
 d02c798:	df000104 	addi	fp,sp,4
 d02c79c:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 d02c7a0:	e0bfff17 	ldw	r2,-4(fp)
 d02c7a4:	10c0088b 	ldhu	r3,34(r2)
 d02c7a8:	00bffec4 	movi	r2,-5
 d02c7ac:	1884703a 	and	r2,r3,r2
 d02c7b0:	1007883a 	mov	r3,r2
 d02c7b4:	e0bfff17 	ldw	r2,-4(fp)
 d02c7b8:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 d02c7bc:	e0bfff17 	ldw	r2,-4(fp)
 d02c7c0:	1080088b 	ldhu	r2,34(r2)
 d02c7c4:	10800e14 	ori	r2,r2,56
 d02c7c8:	1007883a 	mov	r3,r2
 d02c7cc:	e0bfff17 	ldw	r2,-4(fp)
 d02c7d0:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 d02c7d4:	e0bfff17 	ldw	r2,-4(fp)
 d02c7d8:	10800904 	addi	r2,r2,36
 d02c7dc:	1009883a 	mov	r4,r2
 d02c7e0:	d02147c0 	call	d02147c <tcp_wakeup>
   sowwakeup (so);
 d02c7e4:	e0bfff17 	ldw	r2,-4(fp)
 d02c7e8:	11401204 	addi	r5,r2,72
 d02c7ec:	e13fff17 	ldw	r4,-4(fp)
 d02c7f0:	d02cdfc0 	call	d02cdfc <sbwakeup>
   sorwakeup (so);
 d02c7f4:	e0bfff17 	ldw	r2,-4(fp)
 d02c7f8:	11400a04 	addi	r5,r2,40
 d02c7fc:	e13fff17 	ldw	r4,-4(fp)
 d02c800:	d02cdfc0 	call	d02cdfc <sbwakeup>
}
 d02c804:	e037883a 	mov	sp,fp
 d02c808:	dfc00117 	ldw	ra,4(sp)
 d02c80c:	df000017 	ldw	fp,0(sp)
 d02c810:	dec00204 	addi	sp,sp,8
 d02c814:	f800283a 	ret

0d02c818 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 d02c818:	defffd04 	addi	sp,sp,-12
 d02c81c:	dfc00215 	stw	ra,8(sp)
 d02c820:	df000115 	stw	fp,4(sp)
 d02c824:	df000104 	addi	fp,sp,4
 d02c828:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 d02c82c:	e0bfff17 	ldw	r2,-4(fp)
 d02c830:	1080088b 	ldhu	r2,34(r2)
 d02c834:	10bfffcc 	andi	r2,r2,65535
 d02c838:	1080010c 	andi	r2,r2,4
 d02c83c:	1005003a 	cmpeq	r2,r2,zero
 d02c840:	1000061e 	bne	r2,zero,d02c85c <soisdisconnected+0x44>
      so->so_state |= SS_WASCONNECTING;
 d02c844:	e0bfff17 	ldw	r2,-4(fp)
 d02c848:	1080088b 	ldhu	r2,34(r2)
 d02c84c:	10880014 	ori	r2,r2,8192
 d02c850:	1007883a 	mov	r3,r2
 d02c854:	e0bfff17 	ldw	r2,-4(fp)
 d02c858:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 d02c85c:	e0bfff17 	ldw	r2,-4(fp)
 d02c860:	10c0088b 	ldhu	r3,34(r2)
 d02c864:	00bffc44 	movi	r2,-15
 d02c868:	1884703a 	and	r2,r3,r2
 d02c86c:	1007883a 	mov	r3,r2
 d02c870:	e0bfff17 	ldw	r2,-4(fp)
 d02c874:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 d02c878:	e0bfff17 	ldw	r2,-4(fp)
 d02c87c:	1080088b 	ldhu	r2,34(r2)
 d02c880:	10800c14 	ori	r2,r2,48
 d02c884:	1007883a 	mov	r3,r2
 d02c888:	e0bfff17 	ldw	r2,-4(fp)
 d02c88c:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 d02c890:	e0bfff17 	ldw	r2,-4(fp)
 d02c894:	10800904 	addi	r2,r2,36
 d02c898:	1009883a 	mov	r4,r2
 d02c89c:	d02147c0 	call	d02147c <tcp_wakeup>
   sowwakeup (so);
 d02c8a0:	e0bfff17 	ldw	r2,-4(fp)
 d02c8a4:	11401204 	addi	r5,r2,72
 d02c8a8:	e13fff17 	ldw	r4,-4(fp)
 d02c8ac:	d02cdfc0 	call	d02cdfc <sbwakeup>
   sorwakeup (so);
 d02c8b0:	e0bfff17 	ldw	r2,-4(fp)
 d02c8b4:	11400a04 	addi	r5,r2,40
 d02c8b8:	e13fff17 	ldw	r4,-4(fp)
 d02c8bc:	d02cdfc0 	call	d02cdfc <sbwakeup>
}
 d02c8c0:	e037883a 	mov	sp,fp
 d02c8c4:	dfc00117 	ldw	ra,4(sp)
 d02c8c8:	df000017 	ldw	fp,0(sp)
 d02c8cc:	dec00204 	addi	sp,sp,8
 d02c8d0:	f800283a 	ret

0d02c8d4 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 d02c8d4:	defffa04 	addi	sp,sp,-24
 d02c8d8:	dfc00515 	stw	ra,20(sp)
 d02c8dc:	df000415 	stw	fp,16(sp)
 d02c8e0:	df000404 	addi	fp,sp,16
 d02c8e4:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 d02c8e8:	e0bffe17 	ldw	r2,-8(fp)
 d02c8ec:	10801e43 	ldbu	r2,121(r2)
 d02c8f0:	10c03fcc 	andi	r3,r2,255
 d02c8f4:	18c0201c 	xori	r3,r3,128
 d02c8f8:	18ffe004 	addi	r3,r3,-128
 d02c8fc:	e0bffe17 	ldw	r2,-8(fp)
 d02c900:	10801e03 	ldbu	r2,120(r2)
 d02c904:	10803fcc 	andi	r2,r2,255
 d02c908:	1080201c 	xori	r2,r2,128
 d02c90c:	10bfe004 	addi	r2,r2,-128
 d02c910:	1889883a 	add	r4,r3,r2
 d02c914:	e0bffe17 	ldw	r2,-8(fp)
 d02c918:	10801e83 	ldbu	r2,122(r2)
 d02c91c:	10c03fcc 	andi	r3,r2,255
 d02c920:	18c0201c 	xori	r3,r3,128
 d02c924:	18ffe004 	addi	r3,r3,-128
 d02c928:	1805883a 	mov	r2,r3
 d02c92c:	1085883a 	add	r2,r2,r2
 d02c930:	10c7883a 	add	r3,r2,r3
 d02c934:	1804d7fa 	srli	r2,r3,31
 d02c938:	10c5883a 	add	r2,r2,r3
 d02c93c:	1005d07a 	srai	r2,r2,1
 d02c940:	11006416 	blt	r2,r4,d02cad4 <sonewconn+0x200>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 d02c944:	01002104 	movi	r4,132
 d02c948:	d0264b80 	call	d0264b8 <npalloc>
 d02c94c:	e0bffd15 	stw	r2,-12(fp)
 d02c950:	e0bffd17 	ldw	r2,-12(fp)
 d02c954:	1005003a 	cmpeq	r2,r2,zero
 d02c958:	10005e1e 	bne	r2,zero,d02cad4 <sonewconn+0x200>
      goto bad;
   so->next = NULL;
 d02c95c:	e0bffd17 	ldw	r2,-12(fp)
 d02c960:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 d02c964:	e17ffd17 	ldw	r5,-12(fp)
 d02c968:	010341b4 	movhi	r4,3334
 d02c96c:	21045704 	addi	r4,r4,4444
 d02c970:	d0253e00 	call	d0253e0 <putq>
   so->so_type = head->so_type;
 d02c974:	e0bffe17 	ldw	r2,-8(fp)
 d02c978:	10c00983 	ldbu	r3,38(r2)
 d02c97c:	e0bffd17 	ldw	r2,-12(fp)
 d02c980:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 d02c984:	e0bffe17 	ldw	r2,-8(fp)
 d02c988:	10c00417 	ldw	r3,16(r2)
 d02c98c:	00bfff44 	movi	r2,-3
 d02c990:	1886703a 	and	r3,r3,r2
 d02c994:	e0bffd17 	ldw	r2,-12(fp)
 d02c998:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 d02c99c:	e0bffe17 	ldw	r2,-8(fp)
 d02c9a0:	10c0080b 	ldhu	r3,32(r2)
 d02c9a4:	e0bffd17 	ldw	r2,-12(fp)
 d02c9a8:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 d02c9ac:	e0bffe17 	ldw	r2,-8(fp)
 d02c9b0:	1080088b 	ldhu	r2,34(r2)
 d02c9b4:	10800054 	ori	r2,r2,1
 d02c9b8:	1007883a 	mov	r3,r2
 d02c9bc:	e0bffd17 	ldw	r2,-12(fp)
 d02c9c0:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 d02c9c4:	e0bffe17 	ldw	r2,-8(fp)
 d02c9c8:	10c00217 	ldw	r3,8(r2)
 d02c9cc:	e0bffd17 	ldw	r2,-12(fp)
 d02c9d0:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 d02c9d4:	e0bffe17 	ldw	r2,-8(fp)
 d02c9d8:	10c0090b 	ldhu	r3,36(r2)
 d02c9dc:	e0bffd17 	ldw	r2,-12(fp)
 d02c9e0:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 d02c9e4:	00834174 	movhi	r2,3333
 d02c9e8:	10925f04 	addi	r2,r2,18812
 d02c9ec:	10c00017 	ldw	r3,0(r2)
 d02c9f0:	e0bffd17 	ldw	r2,-12(fp)
 d02c9f4:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 d02c9f8:	00834174 	movhi	r2,3333
 d02c9fc:	10925e04 	addi	r2,r2,18808
 d02ca00:	10c00017 	ldw	r3,0(r2)
 d02ca04:	e0bffd17 	ldw	r2,-12(fp)
 d02ca08:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 d02ca0c:	e13ffe17 	ldw	r4,-8(fp)
 d02ca10:	e17ffd17 	ldw	r5,-12(fp)
 d02ca14:	000d883a 	mov	r6,zero
 d02ca18:	d02caf00 	call	d02caf0 <soqinsque>
   so->so_req = PRU_ATTACH;
 d02ca1c:	e0bffd17 	ldw	r2,-12(fp)
 d02ca20:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 d02ca24:	e0bffe17 	ldw	r2,-8(fp)
 d02ca28:	10c00517 	ldw	r3,20(r2)
 d02ca2c:	e0bffd17 	ldw	r2,-12(fp)
 d02ca30:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 d02ca34:	e0bffd17 	ldw	r2,-12(fp)
 d02ca38:	10800217 	ldw	r2,8(r2)
 d02ca3c:	10800317 	ldw	r2,12(r2)
 d02ca40:	e13ffd17 	ldw	r4,-12(fp)
 d02ca44:	000b883a 	mov	r5,zero
 d02ca48:	000d883a 	mov	r6,zero
 d02ca4c:	103ee83a 	callr	r2
 d02ca50:	1004c03a 	cmpne	r2,r2,zero
 d02ca54:	1000161e 	bne	r2,zero,d02cab0 <sonewconn+0x1dc>
      goto bad2;
   if (so_evtmap)
 d02ca58:	00834174 	movhi	r2,3333
 d02ca5c:	109b6c04 	addi	r2,r2,28080
 d02ca60:	10800003 	ldbu	r2,0(r2)
 d02ca64:	10803fcc 	andi	r2,r2,255
 d02ca68:	1005003a 	cmpeq	r2,r2,zero
 d02ca6c:	10000d1e 	bne	r2,zero,d02caa4 <sonewconn+0x1d0>
   {
      rc = (*so_evtmap_create) (so);                       
 d02ca70:	00834174 	movhi	r2,3333
 d02ca74:	109b6a04 	addi	r2,r2,28072
 d02ca78:	10800017 	ldw	r2,0(r2)
 d02ca7c:	e13ffd17 	ldw	r4,-12(fp)
 d02ca80:	103ee83a 	callr	r2
 d02ca84:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0) goto bad2;
 d02ca88:	e0bffc17 	ldw	r2,-16(fp)
 d02ca8c:	1004c03a 	cmpne	r2,r2,zero
 d02ca90:	1000071e 	bne	r2,zero,d02cab0 <sonewconn+0x1dc>
      so->owner = head->owner;
 d02ca94:	e0bffe17 	ldw	r2,-8(fp)
 d02ca98:	10c02003 	ldbu	r3,128(r2)
 d02ca9c:	e0bffd17 	ldw	r2,-12(fp)
 d02caa0:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 d02caa4:	e0bffd17 	ldw	r2,-12(fp)
 d02caa8:	e0bfff15 	stw	r2,-4(fp)
 d02caac:	00000a06 	br	d02cad8 <sonewconn+0x204>
   
bad2:
   (void) soqremque (so, 0);
 d02cab0:	e13ffd17 	ldw	r4,-12(fp)
 d02cab4:	000b883a 	mov	r5,zero
 d02cab8:	d02cb9c0 	call	d02cb9c <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 d02cabc:	010341b4 	movhi	r4,3334
 d02cac0:	21045704 	addi	r4,r4,4444
 d02cac4:	e17ffd17 	ldw	r5,-12(fp)
 d02cac8:	d0254900 	call	d025490 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 d02cacc:	e13ffd17 	ldw	r4,-12(fp)
 d02cad0:	d0265ac0 	call	d0265ac <npfree>
bad:
   return ((struct socket *)0);
 d02cad4:	e03fff15 	stw	zero,-4(fp)
 d02cad8:	e0bfff17 	ldw	r2,-4(fp)
}
 d02cadc:	e037883a 	mov	sp,fp
 d02cae0:	dfc00117 	ldw	ra,4(sp)
 d02cae4:	df000017 	ldw	fp,0(sp)
 d02cae8:	dec00204 	addi	sp,sp,8
 d02caec:	f800283a 	ret

0d02caf0 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 d02caf0:	defffc04 	addi	sp,sp,-16
 d02caf4:	df000315 	stw	fp,12(sp)
 d02caf8:	df000304 	addi	fp,sp,12
 d02cafc:	e13ffd15 	stw	r4,-12(fp)
 d02cb00:	e17ffe15 	stw	r5,-8(fp)
 d02cb04:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 d02cb08:	e0fffe17 	ldw	r3,-8(fp)
 d02cb0c:	e0bffd17 	ldw	r2,-12(fp)
 d02cb10:	18801b15 	stw	r2,108(r3)
   if (q == 0) 
 d02cb14:	e0bfff17 	ldw	r2,-4(fp)
 d02cb18:	1004c03a 	cmpne	r2,r2,zero
 d02cb1c:	10000e1e 	bne	r2,zero,d02cb58 <soqinsque+0x68>
   {
      head->so_q0len++;
 d02cb20:	e0bffd17 	ldw	r2,-12(fp)
 d02cb24:	10801e03 	ldbu	r2,120(r2)
 d02cb28:	10800044 	addi	r2,r2,1
 d02cb2c:	1007883a 	mov	r3,r2
 d02cb30:	e0bffd17 	ldw	r2,-12(fp)
 d02cb34:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 d02cb38:	e0bffd17 	ldw	r2,-12(fp)
 d02cb3c:	10c01c17 	ldw	r3,112(r2)
 d02cb40:	e0bffe17 	ldw	r2,-8(fp)
 d02cb44:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 d02cb48:	e0fffd17 	ldw	r3,-12(fp)
 d02cb4c:	e0bffe17 	ldw	r2,-8(fp)
 d02cb50:	18801c15 	stw	r2,112(r3)
 d02cb54:	00000d06 	br	d02cb8c <soqinsque+0x9c>
   } else 
   {
      head->so_qlen++;
 d02cb58:	e0bffd17 	ldw	r2,-12(fp)
 d02cb5c:	10801e43 	ldbu	r2,121(r2)
 d02cb60:	10800044 	addi	r2,r2,1
 d02cb64:	1007883a 	mov	r3,r2
 d02cb68:	e0bffd17 	ldw	r2,-12(fp)
 d02cb6c:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 d02cb70:	e0bffd17 	ldw	r2,-12(fp)
 d02cb74:	10c01d17 	ldw	r3,116(r2)
 d02cb78:	e0bffe17 	ldw	r2,-8(fp)
 d02cb7c:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 d02cb80:	e0fffd17 	ldw	r3,-12(fp)
 d02cb84:	e0bffe17 	ldw	r2,-8(fp)
 d02cb88:	18801d15 	stw	r2,116(r3)
   }
}
 d02cb8c:	e037883a 	mov	sp,fp
 d02cb90:	df000017 	ldw	fp,0(sp)
 d02cb94:	dec00104 	addi	sp,sp,4
 d02cb98:	f800283a 	ret

0d02cb9c <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 d02cb9c:	defff804 	addi	sp,sp,-32
 d02cba0:	df000715 	stw	fp,28(sp)
 d02cba4:	df000704 	addi	fp,sp,28
 d02cba8:	e13ffc15 	stw	r4,-16(fp)
 d02cbac:	e17ffd15 	stw	r5,-12(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 d02cbb0:	e0bffc17 	ldw	r2,-16(fp)
 d02cbb4:	10801b17 	ldw	r2,108(r2)
 d02cbb8:	e0bffb15 	stw	r2,-20(fp)
   prev = head;
 d02cbbc:	e0bffb17 	ldw	r2,-20(fp)
 d02cbc0:	e0bffa15 	stw	r2,-24(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 d02cbc4:	e0bffd17 	ldw	r2,-12(fp)
 d02cbc8:	1005003a 	cmpeq	r2,r2,zero
 d02cbcc:	1000041e 	bne	r2,zero,d02cbe0 <soqremque+0x44>
 d02cbd0:	e0bffa17 	ldw	r2,-24(fp)
 d02cbd4:	10801d17 	ldw	r2,116(r2)
 d02cbd8:	e0bfff15 	stw	r2,-4(fp)
 d02cbdc:	00000306 	br	d02cbec <soqremque+0x50>
 d02cbe0:	e0bffa17 	ldw	r2,-24(fp)
 d02cbe4:	10801c17 	ldw	r2,112(r2)
 d02cbe8:	e0bfff15 	stw	r2,-4(fp)
 d02cbec:	e0bfff17 	ldw	r2,-4(fp)
 d02cbf0:	e0bff915 	stw	r2,-28(fp)
      if (next == so)
 d02cbf4:	e0fff917 	ldw	r3,-28(fp)
 d02cbf8:	e0bffc17 	ldw	r2,-16(fp)
 d02cbfc:	18800826 	beq	r3,r2,d02cc20 <soqremque+0x84>
         break;
      if (next == head)
 d02cc00:	e0fff917 	ldw	r3,-28(fp)
 d02cc04:	e0bffb17 	ldw	r2,-20(fp)
 d02cc08:	1880021e 	bne	r3,r2,d02cc14 <soqremque+0x78>
         return (0);
 d02cc0c:	e03ffe15 	stw	zero,-8(fp)
 d02cc10:	00002506 	br	d02cca8 <soqremque+0x10c>
      prev = next;
 d02cc14:	e0bff917 	ldw	r2,-28(fp)
 d02cc18:	e0bffa15 	stw	r2,-24(fp)
   }
 d02cc1c:	003fe906 	br	d02cbc4 <soqremque+0x28>
   if (q == 0) 
 d02cc20:	e0bffd17 	ldw	r2,-12(fp)
 d02cc24:	1004c03a 	cmpne	r2,r2,zero
 d02cc28:	10000b1e 	bne	r2,zero,d02cc58 <soqremque+0xbc>
   {
      prev->so_q0 = next->so_q0;
 d02cc2c:	e0bff917 	ldw	r2,-28(fp)
 d02cc30:	10c01c17 	ldw	r3,112(r2)
 d02cc34:	e0bffa17 	ldw	r2,-24(fp)
 d02cc38:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 d02cc3c:	e0bffb17 	ldw	r2,-20(fp)
 d02cc40:	10801e03 	ldbu	r2,120(r2)
 d02cc44:	10bfffc4 	addi	r2,r2,-1
 d02cc48:	1007883a 	mov	r3,r2
 d02cc4c:	e0bffb17 	ldw	r2,-20(fp)
 d02cc50:	10c01e05 	stb	r3,120(r2)
 d02cc54:	00000a06 	br	d02cc80 <soqremque+0xe4>
   } else 
   {
      prev->so_q = next->so_q;
 d02cc58:	e0bff917 	ldw	r2,-28(fp)
 d02cc5c:	10c01d17 	ldw	r3,116(r2)
 d02cc60:	e0bffa17 	ldw	r2,-24(fp)
 d02cc64:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 d02cc68:	e0bffb17 	ldw	r2,-20(fp)
 d02cc6c:	10801e43 	ldbu	r2,121(r2)
 d02cc70:	10bfffc4 	addi	r2,r2,-1
 d02cc74:	1007883a 	mov	r3,r2
 d02cc78:	e0bffb17 	ldw	r2,-20(fp)
 d02cc7c:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 d02cc80:	e0bff917 	ldw	r2,-28(fp)
 d02cc84:	10001d15 	stw	zero,116(r2)
 d02cc88:	e0bff917 	ldw	r2,-28(fp)
 d02cc8c:	10c01d17 	ldw	r3,116(r2)
 d02cc90:	e0bff917 	ldw	r2,-28(fp)
 d02cc94:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 d02cc98:	e0bff917 	ldw	r2,-28(fp)
 d02cc9c:	10001b15 	stw	zero,108(r2)
   return 1;
 d02cca0:	00800044 	movi	r2,1
 d02cca4:	e0bffe15 	stw	r2,-8(fp)
 d02cca8:	e0bffe17 	ldw	r2,-8(fp)
}
 d02ccac:	e037883a 	mov	sp,fp
 d02ccb0:	df000017 	ldw	fp,0(sp)
 d02ccb4:	dec00104 	addi	sp,sp,4
 d02ccb8:	f800283a 	ret

0d02ccbc <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 d02ccbc:	defffd04 	addi	sp,sp,-12
 d02ccc0:	dfc00215 	stw	ra,8(sp)
 d02ccc4:	df000115 	stw	fp,4(sp)
 d02ccc8:	df000104 	addi	fp,sp,4
 d02cccc:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 d02ccd0:	e0bfff17 	ldw	r2,-4(fp)
 d02ccd4:	1080088b 	ldhu	r2,34(r2)
 d02ccd8:	10800414 	ori	r2,r2,16
 d02ccdc:	1007883a 	mov	r3,r2
 d02cce0:	e0bfff17 	ldw	r2,-4(fp)
 d02cce4:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 d02cce8:	e0bfff17 	ldw	r2,-4(fp)
 d02ccec:	11401204 	addi	r5,r2,72
 d02ccf0:	e13fff17 	ldw	r4,-4(fp)
 d02ccf4:	d02cdfc0 	call	d02cdfc <sbwakeup>
}
 d02ccf8:	e037883a 	mov	sp,fp
 d02ccfc:	dfc00117 	ldw	ra,4(sp)
 d02cd00:	df000017 	ldw	fp,0(sp)
 d02cd04:	dec00204 	addi	sp,sp,8
 d02cd08:	f800283a 	ret

0d02cd0c <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 d02cd0c:	defffd04 	addi	sp,sp,-12
 d02cd10:	dfc00215 	stw	ra,8(sp)
 d02cd14:	df000115 	stw	fp,4(sp)
 d02cd18:	df000104 	addi	fp,sp,4
 d02cd1c:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 d02cd20:	e0bfff17 	ldw	r2,-4(fp)
 d02cd24:	1080088b 	ldhu	r2,34(r2)
 d02cd28:	10800814 	ori	r2,r2,32
 d02cd2c:	1007883a 	mov	r3,r2
 d02cd30:	e0bfff17 	ldw	r2,-4(fp)
 d02cd34:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 d02cd38:	e0bfff17 	ldw	r2,-4(fp)
 d02cd3c:	11400a04 	addi	r5,r2,40
 d02cd40:	e13fff17 	ldw	r4,-4(fp)
 d02cd44:	d02cdfc0 	call	d02cdfc <sbwakeup>
}
 d02cd48:	e037883a 	mov	sp,fp
 d02cd4c:	dfc00117 	ldw	ra,4(sp)
 d02cd50:	df000017 	ldw	fp,0(sp)
 d02cd54:	dec00204 	addi	sp,sp,8
 d02cd58:	f800283a 	ret

0d02cd5c <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 d02cd5c:	defffe04 	addi	sp,sp,-8
 d02cd60:	df000115 	stw	fp,4(sp)
 d02cd64:	df000104 	addi	fp,sp,4
 d02cd68:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 d02cd6c:	e0bfff17 	ldw	r2,-4(fp)
 d02cd70:	1080070b 	ldhu	r2,28(r2)
 d02cd74:	10800214 	ori	r2,r2,8
 d02cd78:	1007883a 	mov	r3,r2
 d02cd7c:	e0bfff17 	ldw	r2,-4(fp)
 d02cd80:	10c0070d 	sth	r3,28(r2)
}
 d02cd84:	e037883a 	mov	sp,fp
 d02cd88:	df000017 	ldw	fp,0(sp)
 d02cd8c:	dec00104 	addi	sp,sp,4
 d02cd90:	f800283a 	ret

0d02cd94 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 d02cd94:	defffd04 	addi	sp,sp,-12
 d02cd98:	dfc00215 	stw	ra,8(sp)
 d02cd9c:	df000115 	stw	fp,4(sp)
 d02cda0:	df000104 	addi	fp,sp,4
 d02cda4:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 d02cda8:	e0bfff17 	ldw	r2,-4(fp)
 d02cdac:	1080070b 	ldhu	r2,28(r2)
 d02cdb0:	10800114 	ori	r2,r2,4
 d02cdb4:	1007883a 	mov	r3,r2
 d02cdb8:	e0bfff17 	ldw	r2,-4(fp)
 d02cdbc:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 d02cdc0:	e0bfff17 	ldw	r2,-4(fp)
 d02cdc4:	1009883a 	mov	r4,r2
 d02cdc8:	d0212b40 	call	d0212b4 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 d02cdcc:	e0bfff17 	ldw	r2,-4(fp)
 d02cdd0:	10c0070b 	ldhu	r3,28(r2)
 d02cdd4:	00bffec4 	movi	r2,-5
 d02cdd8:	1884703a 	and	r2,r3,r2
 d02cddc:	1007883a 	mov	r3,r2
 d02cde0:	e0bfff17 	ldw	r2,-4(fp)
 d02cde4:	10c0070d 	sth	r3,28(r2)
}
 d02cde8:	e037883a 	mov	sp,fp
 d02cdec:	dfc00117 	ldw	ra,4(sp)
 d02cdf0:	df000017 	ldw	fp,0(sp)
 d02cdf4:	dec00204 	addi	sp,sp,8
 d02cdf8:	f800283a 	ret

0d02cdfc <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 d02cdfc:	defffc04 	addi	sp,sp,-16
 d02ce00:	dfc00315 	stw	ra,12(sp)
 d02ce04:	df000215 	stw	fp,8(sp)
 d02ce08:	df000204 	addi	fp,sp,8
 d02ce0c:	e13ffe15 	stw	r4,-8(fp)
 d02ce10:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 d02ce14:	e0bfff17 	ldw	r2,-4(fp)
 d02ce18:	1080070b 	ldhu	r2,28(r2)
 d02ce1c:	10bfffcc 	andi	r2,r2,65535
 d02ce20:	1080020c 	andi	r2,r2,8
 d02ce24:	1005003a 	cmpeq	r2,r2,zero
 d02ce28:	10000d1e 	bne	r2,zero,d02ce60 <sbwakeup+0x64>
   {
      select_wait = 0;
 d02ce2c:	00834174 	movhi	r2,3333
 d02ce30:	109b4d04 	addi	r2,r2,27956
 d02ce34:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 d02ce38:	01034174 	movhi	r4,3333
 d02ce3c:	211b4d04 	addi	r4,r4,27956
 d02ce40:	d02147c0 	call	d02147c <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 d02ce44:	e0bfff17 	ldw	r2,-4(fp)
 d02ce48:	10c0070b 	ldhu	r3,28(r2)
 d02ce4c:	00bffdc4 	movi	r2,-9
 d02ce50:	1884703a 	and	r2,r3,r2
 d02ce54:	1007883a 	mov	r3,r2
 d02ce58:	e0bfff17 	ldw	r2,-4(fp)
 d02ce5c:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 d02ce60:	e0bfff17 	ldw	r2,-4(fp)
 d02ce64:	1080070b 	ldhu	r2,28(r2)
 d02ce68:	10bfffcc 	andi	r2,r2,65535
 d02ce6c:	1080010c 	andi	r2,r2,4
 d02ce70:	1005003a 	cmpeq	r2,r2,zero
 d02ce74:	1000031e 	bne	r2,zero,d02ce84 <sbwakeup+0x88>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 d02ce78:	e0bfff17 	ldw	r2,-4(fp)
 d02ce7c:	1009883a 	mov	r4,r2
 d02ce80:	d02147c0 	call	d02147c <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 d02ce84:	e037883a 	mov	sp,fp
 d02ce88:	dfc00117 	ldw	ra,4(sp)
 d02ce8c:	df000017 	ldw	fp,0(sp)
 d02ce90:	dec00204 	addi	sp,sp,8
 d02ce94:	f800283a 	ret

0d02ce98 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 d02ce98:	defffa04 	addi	sp,sp,-24
 d02ce9c:	dfc00515 	stw	ra,20(sp)
 d02cea0:	df000415 	stw	fp,16(sp)
 d02cea4:	df000404 	addi	fp,sp,16
 d02cea8:	e13ffc15 	stw	r4,-16(fp)
 d02ceac:	e17ffd15 	stw	r5,-12(fp)
 d02ceb0:	e1bffe15 	stw	r6,-8(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 d02ceb4:	e0bffc17 	ldw	r2,-16(fp)
 d02ceb8:	11001204 	addi	r4,r2,72
 d02cebc:	e17ffd17 	ldw	r5,-12(fp)
 d02cec0:	d02cf180 	call	d02cf18 <sbreserve>
 d02cec4:	1005003a 	cmpeq	r2,r2,zero
 d02cec8:	10000b1e 	bne	r2,zero,d02cef8 <soreserve+0x60>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 d02cecc:	e0bffc17 	ldw	r2,-16(fp)
 d02ced0:	11000a04 	addi	r4,r2,40
 d02ced4:	e17ffe17 	ldw	r5,-8(fp)
 d02ced8:	d02cf180 	call	d02cf18 <sbreserve>
 d02cedc:	1005003a 	cmpeq	r2,r2,zero
 d02cee0:	1000021e 	bne	r2,zero,d02ceec <soreserve+0x54>
      goto bad2;
   return (0);
 d02cee4:	e03fff15 	stw	zero,-4(fp)
 d02cee8:	00000506 	br	d02cf00 <soreserve+0x68>
bad2:
   sbrelease(&so->so_snd);
 d02ceec:	e0bffc17 	ldw	r2,-16(fp)
 d02cef0:	11001204 	addi	r4,r2,72
 d02cef4:	d02cf780 	call	d02cf78 <sbrelease>
bad:
   return (ENOBUFS);
 d02cef8:	00801a44 	movi	r2,105
 d02cefc:	e0bfff15 	stw	r2,-4(fp)
 d02cf00:	e0bfff17 	ldw	r2,-4(fp)
}
 d02cf04:	e037883a 	mov	sp,fp
 d02cf08:	dfc00117 	ldw	ra,4(sp)
 d02cf0c:	df000017 	ldw	fp,0(sp)
 d02cf10:	dec00204 	addi	sp,sp,8
 d02cf14:	f800283a 	ret

0d02cf18 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 d02cf18:	defffc04 	addi	sp,sp,-16
 d02cf1c:	df000315 	stw	fp,12(sp)
 d02cf20:	df000304 	addi	fp,sp,12
 d02cf24:	e13ffd15 	stw	r4,-12(fp)
 d02cf28:	e17ffe15 	stw	r5,-8(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 d02cf2c:	e0fffd17 	ldw	r3,-12(fp)
 d02cf30:	e0bffe17 	ldw	r2,-8(fp)
 d02cf34:	18800115 	stw	r2,4(r3)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 d02cf38:	e0bffe17 	ldw	r2,-8(fp)
 d02cf3c:	1085883a 	add	r2,r2,r2
 d02cf40:	e0bfff15 	stw	r2,-4(fp)
 d02cf44:	e0ffff17 	ldw	r3,-4(fp)
 d02cf48:	18900070 	cmpltui	r2,r3,16385
 d02cf4c:	1000021e 	bne	r2,zero,d02cf58 <sbreserve+0x40>
 d02cf50:	00900004 	movi	r2,16384
 d02cf54:	e0bfff15 	stw	r2,-4(fp)
 d02cf58:	e0bffd17 	ldw	r2,-12(fp)
 d02cf5c:	e0ffff17 	ldw	r3,-4(fp)
 d02cf60:	10c00315 	stw	r3,12(r2)
   return (1);
 d02cf64:	00800044 	movi	r2,1
}
 d02cf68:	e037883a 	mov	sp,fp
 d02cf6c:	df000017 	ldw	fp,0(sp)
 d02cf70:	dec00104 	addi	sp,sp,4
 d02cf74:	f800283a 	ret

0d02cf78 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 d02cf78:	defffd04 	addi	sp,sp,-12
 d02cf7c:	dfc00215 	stw	ra,8(sp)
 d02cf80:	df000115 	stw	fp,4(sp)
 d02cf84:	df000104 	addi	fp,sp,4
 d02cf88:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 d02cf8c:	e13fff17 	ldw	r4,-4(fp)
 d02cf90:	d02d5380 	call	d02d538 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 d02cf94:	e0bfff17 	ldw	r2,-4(fp)
 d02cf98:	10000315 	stw	zero,12(r2)
 d02cf9c:	e0bfff17 	ldw	r2,-4(fp)
 d02cfa0:	10c00317 	ldw	r3,12(r2)
 d02cfa4:	e0bfff17 	ldw	r2,-4(fp)
 d02cfa8:	10c00115 	stw	r3,4(r2)
}
 d02cfac:	e037883a 	mov	sp,fp
 d02cfb0:	dfc00117 	ldw	ra,4(sp)
 d02cfb4:	df000017 	ldw	fp,0(sp)
 d02cfb8:	dec00204 	addi	sp,sp,8
 d02cfbc:	f800283a 	ret

0d02cfc0 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 d02cfc0:	defffb04 	addi	sp,sp,-20
 d02cfc4:	dfc00415 	stw	ra,16(sp)
 d02cfc8:	df000315 	stw	fp,12(sp)
 d02cfcc:	df000304 	addi	fp,sp,12
 d02cfd0:	e13ffe15 	stw	r4,-8(fp)
 d02cfd4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 d02cfd8:	e0bfff17 	ldw	r2,-4(fp)
 d02cfdc:	1005003a 	cmpeq	r2,r2,zero
 d02cfe0:	10001c1e 	bne	r2,zero,d02d054 <sbappend+0x94>
      return;
   ENTER_CRIT_SECTION(sb);
 d02cfe4:	d025c500 	call	d025c50 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 d02cfe8:	e0bffe17 	ldw	r2,-8(fp)
 d02cfec:	10800617 	ldw	r2,24(r2)
 d02cff0:	e0bffd15 	stw	r2,-12(fp)
 d02cff4:	e0bffd17 	ldw	r2,-12(fp)
 d02cff8:	1005003a 	cmpeq	r2,r2,zero
 d02cffc:	1000101e 	bne	r2,zero,d02d040 <sbappend+0x80>
   {
      while (n->m_act)
 d02d000:	00000306 	br	d02d010 <sbappend+0x50>
         n = n->m_act;
 d02d004:	e0bffd17 	ldw	r2,-12(fp)
 d02d008:	10800717 	ldw	r2,28(r2)
 d02d00c:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 d02d010:	e0bffd17 	ldw	r2,-12(fp)
 d02d014:	10800717 	ldw	r2,28(r2)
 d02d018:	1004c03a 	cmpne	r2,r2,zero
 d02d01c:	103ff91e 	bne	r2,zero,d02d004 <sbappend+0x44>
         n = n->m_act;
      while (n->m_next)
 d02d020:	00000306 	br	d02d030 <sbappend+0x70>
         n = n->m_next;
 d02d024:	e0bffd17 	ldw	r2,-12(fp)
 d02d028:	10800617 	ldw	r2,24(r2)
 d02d02c:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 d02d030:	e0bffd17 	ldw	r2,-12(fp)
 d02d034:	10800617 	ldw	r2,24(r2)
 d02d038:	1004c03a 	cmpne	r2,r2,zero
 d02d03c:	103ff91e 	bne	r2,zero,d02d024 <sbappend+0x64>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 d02d040:	e13ffe17 	ldw	r4,-8(fp)
 d02d044:	e17fff17 	ldw	r5,-4(fp)
 d02d048:	e1bffd17 	ldw	r6,-12(fp)
 d02d04c:	d02d3500 	call	d02d350 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 d02d050:	d025cac0 	call	d025cac <irq_Unmask>
}
 d02d054:	e037883a 	mov	sp,fp
 d02d058:	dfc00117 	ldw	ra,4(sp)
 d02d05c:	df000017 	ldw	fp,0(sp)
 d02d060:	dec00204 	addi	sp,sp,8
 d02d064:	f800283a 	ret

0d02d068 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 d02d068:	defffb04 	addi	sp,sp,-20
 d02d06c:	dfc00415 	stw	ra,16(sp)
 d02d070:	df000315 	stw	fp,12(sp)
 d02d074:	df000304 	addi	fp,sp,12
 d02d078:	e13ffe15 	stw	r4,-8(fp)
 d02d07c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 d02d080:	e0bfff17 	ldw	r2,-4(fp)
 d02d084:	1005003a 	cmpeq	r2,r2,zero
 d02d088:	10002a1e 	bne	r2,zero,d02d134 <sbappendrecord+0xcc>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 d02d08c:	d025c500 	call	d025c50 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 d02d090:	e0bffe17 	ldw	r2,-8(fp)
 d02d094:	10800617 	ldw	r2,24(r2)
 d02d098:	e0bffd15 	stw	r2,-12(fp)
 d02d09c:	e0bffd17 	ldw	r2,-12(fp)
 d02d0a0:	1005003a 	cmpeq	r2,r2,zero
 d02d0a4:	1000081e 	bne	r2,zero,d02d0c8 <sbappendrecord+0x60>
      while (m->m_act)
 d02d0a8:	00000306 	br	d02d0b8 <sbappendrecord+0x50>
      m = m->m_act;
 d02d0ac:	e0bffd17 	ldw	r2,-12(fp)
 d02d0b0:	10800717 	ldw	r2,28(r2)
 d02d0b4:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 d02d0b8:	e0bffd17 	ldw	r2,-12(fp)
 d02d0bc:	10800717 	ldw	r2,28(r2)
 d02d0c0:	1004c03a 	cmpne	r2,r2,zero
 d02d0c4:	103ff91e 	bne	r2,zero,d02d0ac <sbappendrecord+0x44>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 d02d0c8:	e0bffe17 	ldw	r2,-8(fp)
 d02d0cc:	10c00017 	ldw	r3,0(r2)
 d02d0d0:	e0bfff17 	ldw	r2,-4(fp)
 d02d0d4:	10800217 	ldw	r2,8(r2)
 d02d0d8:	1887883a 	add	r3,r3,r2
 d02d0dc:	e0bffe17 	ldw	r2,-8(fp)
 d02d0e0:	10c00015 	stw	r3,0(r2)
   if (m)
 d02d0e4:	e0bffd17 	ldw	r2,-12(fp)
 d02d0e8:	1005003a 	cmpeq	r2,r2,zero
 d02d0ec:	1000041e 	bne	r2,zero,d02d100 <sbappendrecord+0x98>
      m->m_act = m0;
 d02d0f0:	e0fffd17 	ldw	r3,-12(fp)
 d02d0f4:	e0bfff17 	ldw	r2,-4(fp)
 d02d0f8:	18800715 	stw	r2,28(r3)
 d02d0fc:	00000306 	br	d02d10c <sbappendrecord+0xa4>
   else
      sb->sb_mb = m0;
 d02d100:	e0fffe17 	ldw	r3,-8(fp)
 d02d104:	e0bfff17 	ldw	r2,-4(fp)
 d02d108:	18800615 	stw	r2,24(r3)
   m = m0->m_next;
 d02d10c:	e0bfff17 	ldw	r2,-4(fp)
 d02d110:	10800617 	ldw	r2,24(r2)
 d02d114:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 d02d118:	e0bfff17 	ldw	r2,-4(fp)
 d02d11c:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 d02d120:	e13ffe17 	ldw	r4,-8(fp)
 d02d124:	e17ffd17 	ldw	r5,-12(fp)
 d02d128:	e1bfff17 	ldw	r6,-4(fp)
 d02d12c:	d02d3500 	call	d02d350 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 d02d130:	d025cac0 	call	d025cac <irq_Unmask>
}
 d02d134:	e037883a 	mov	sp,fp
 d02d138:	dfc00117 	ldw	ra,4(sp)
 d02d13c:	df000017 	ldw	fp,0(sp)
 d02d140:	dec00204 	addi	sp,sp,8
 d02d144:	f800283a 	ret

0d02d148 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 d02d148:	defff604 	addi	sp,sp,-40
 d02d14c:	dfc00915 	stw	ra,36(sp)
 d02d150:	df000815 	stw	fp,32(sp)
 d02d154:	df000804 	addi	fp,sp,32
 d02d158:	e13ffb15 	stw	r4,-20(fp)
 d02d15c:	e17ffc15 	stw	r5,-16(fp)
 d02d160:	e1bffd15 	stw	r6,-12(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 d02d164:	00800404 	movi	r2,16
 d02d168:	e0bff815 	stw	r2,-32(fp)

   ENTER_CRIT_SECTION(sb);
 d02d16c:	d025c500 	call	d025c50 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 d02d170:	e0bffd17 	ldw	r2,-12(fp)
 d02d174:	e0bffa15 	stw	r2,-24(fp)
 d02d178:	00000806 	br	d02d19c <sbappendaddr+0x54>
      space += m->m_len;
 d02d17c:	e0bffa17 	ldw	r2,-24(fp)
 d02d180:	10c00217 	ldw	r3,8(r2)
 d02d184:	e0bff817 	ldw	r2,-32(fp)
 d02d188:	1885883a 	add	r2,r3,r2
 d02d18c:	e0bff815 	stw	r2,-32(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 d02d190:	e0bffa17 	ldw	r2,-24(fp)
 d02d194:	10800617 	ldw	r2,24(r2)
 d02d198:	e0bffa15 	stw	r2,-24(fp)
 d02d19c:	e0bffa17 	ldw	r2,-24(fp)
 d02d1a0:	1004c03a 	cmpne	r2,r2,zero
 d02d1a4:	103ff51e 	bne	r2,zero,d02d17c <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 d02d1a8:	e0bffb17 	ldw	r2,-20(fp)
 d02d1ac:	10800117 	ldw	r2,4(r2)
 d02d1b0:	1007883a 	mov	r3,r2
 d02d1b4:	e0bffb17 	ldw	r2,-20(fp)
 d02d1b8:	10800017 	ldw	r2,0(r2)
 d02d1bc:	1885c83a 	sub	r2,r3,r2
 d02d1c0:	1004803a 	cmplt	r2,r2,zero
 d02d1c4:	1000071e 	bne	r2,zero,d02d1e4 <sbappendaddr+0x9c>
 d02d1c8:	e0bffb17 	ldw	r2,-20(fp)
 d02d1cc:	10c00117 	ldw	r3,4(r2)
 d02d1d0:	e0bffb17 	ldw	r2,-20(fp)
 d02d1d4:	10800017 	ldw	r2,0(r2)
 d02d1d8:	1885c83a 	sub	r2,r3,r2
 d02d1dc:	e0bfff15 	stw	r2,-4(fp)
 d02d1e0:	00000106 	br	d02d1e8 <sbappendaddr+0xa0>
 d02d1e4:	e03fff15 	stw	zero,-4(fp)
 d02d1e8:	e0bff817 	ldw	r2,-32(fp)
 d02d1ec:	e0ffff17 	ldw	r3,-4(fp)
 d02d1f0:	1880030e 	bge	r3,r2,d02d200 <sbappendaddr+0xb8>
   {
      EXIT_CRIT_SECTION(sb);
 d02d1f4:	d025cac0 	call	d025cac <irq_Unmask>
      return (0);
 d02d1f8:	e03ffe15 	stw	zero,-8(fp)
 d02d1fc:	00004e06 	br	d02d338 <sbappendaddr+0x1f0>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 d02d200:	01000244 	movi	r4,9
 d02d204:	01400404 	movi	r5,16
 d02d208:	d0268740 	call	d026874 <m_getnbuf>
 d02d20c:	e0bffa15 	stw	r2,-24(fp)
 d02d210:	e0bffa17 	ldw	r2,-24(fp)
 d02d214:	1004c03a 	cmpne	r2,r2,zero
 d02d218:	1000031e 	bne	r2,zero,d02d228 <sbappendaddr+0xe0>
   {
      EXIT_CRIT_SECTION(sb);
 d02d21c:	d025cac0 	call	d025cac <irq_Unmask>
      return 0;
 d02d220:	e03ffe15 	stw	zero,-8(fp)
 d02d224:	00004406 	br	d02d338 <sbappendaddr+0x1f0>
   }
   *mtod(m, struct sockaddr *) = *asa;
 d02d228:	e0bffa17 	ldw	r2,-24(fp)
 d02d22c:	10800317 	ldw	r2,12(r2)
 d02d230:	1009883a 	mov	r4,r2
 d02d234:	e0fffc17 	ldw	r3,-16(fp)
 d02d238:	1880000b 	ldhu	r2,0(r3)
 d02d23c:	2080000d 	sth	r2,0(r4)
 d02d240:	1880008b 	ldhu	r2,2(r3)
 d02d244:	2080008d 	sth	r2,2(r4)
 d02d248:	1880010b 	ldhu	r2,4(r3)
 d02d24c:	2080010d 	sth	r2,4(r4)
 d02d250:	1880018b 	ldhu	r2,6(r3)
 d02d254:	2080018d 	sth	r2,6(r4)
 d02d258:	1880020b 	ldhu	r2,8(r3)
 d02d25c:	2080020d 	sth	r2,8(r4)
 d02d260:	1880028b 	ldhu	r2,10(r3)
 d02d264:	2080028d 	sth	r2,10(r4)
 d02d268:	1880030b 	ldhu	r2,12(r3)
 d02d26c:	2080030d 	sth	r2,12(r4)
 d02d270:	1880038b 	ldhu	r2,14(r3)
 d02d274:	2080038d 	sth	r2,14(r4)
   m->m_len = sizeof (*asa);
 d02d278:	e0fffa17 	ldw	r3,-24(fp)
 d02d27c:	00800404 	movi	r2,16
 d02d280:	18800215 	stw	r2,8(r3)
   sballoc (sb, m);
 d02d284:	e0bffb17 	ldw	r2,-20(fp)
 d02d288:	10c00017 	ldw	r3,0(r2)
 d02d28c:	e0bffa17 	ldw	r2,-24(fp)
 d02d290:	10800217 	ldw	r2,8(r2)
 d02d294:	1887883a 	add	r3,r3,r2
 d02d298:	e0bffb17 	ldw	r2,-20(fp)
 d02d29c:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 d02d2a0:	e0bffb17 	ldw	r2,-20(fp)
 d02d2a4:	10800617 	ldw	r2,24(r2)
 d02d2a8:	e0bff915 	stw	r2,-28(fp)
 d02d2ac:	e0bff917 	ldw	r2,-28(fp)
 d02d2b0:	1005003a 	cmpeq	r2,r2,zero
 d02d2b4:	10000c1e 	bne	r2,zero,d02d2e8 <sbappendaddr+0x1a0>
   {
      while (n->m_act)
 d02d2b8:	00000306 	br	d02d2c8 <sbappendaddr+0x180>
         n = n->m_act;
 d02d2bc:	e0bff917 	ldw	r2,-28(fp)
 d02d2c0:	10800717 	ldw	r2,28(r2)
 d02d2c4:	e0bff915 	stw	r2,-28(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 d02d2c8:	e0bff917 	ldw	r2,-28(fp)
 d02d2cc:	10800717 	ldw	r2,28(r2)
 d02d2d0:	1004c03a 	cmpne	r2,r2,zero
 d02d2d4:	103ff91e 	bne	r2,zero,d02d2bc <sbappendaddr+0x174>
         n = n->m_act;
      n->m_act = m;
 d02d2d8:	e0fff917 	ldw	r3,-28(fp)
 d02d2dc:	e0bffa17 	ldw	r2,-24(fp)
 d02d2e0:	18800715 	stw	r2,28(r3)
 d02d2e4:	00000306 	br	d02d2f4 <sbappendaddr+0x1ac>
   } else
      sb->sb_mb = m;
 d02d2e8:	e0fffb17 	ldw	r3,-20(fp)
 d02d2ec:	e0bffa17 	ldw	r2,-24(fp)
 d02d2f0:	18800615 	stw	r2,24(r3)
   if (m->m_next)
 d02d2f4:	e0bffa17 	ldw	r2,-24(fp)
 d02d2f8:	10800617 	ldw	r2,24(r2)
 d02d2fc:	1005003a 	cmpeq	r2,r2,zero
 d02d300:	1000031e 	bne	r2,zero,d02d310 <sbappendaddr+0x1c8>
      m = m->m_next;
 d02d304:	e0bffa17 	ldw	r2,-24(fp)
 d02d308:	10800617 	ldw	r2,24(r2)
 d02d30c:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 d02d310:	e0bffd17 	ldw	r2,-12(fp)
 d02d314:	1005003a 	cmpeq	r2,r2,zero
 d02d318:	1000041e 	bne	r2,zero,d02d32c <sbappendaddr+0x1e4>
      sbcompress(sb, m0, m);
 d02d31c:	e13ffb17 	ldw	r4,-20(fp)
 d02d320:	e17ffd17 	ldw	r5,-12(fp)
 d02d324:	e1bffa17 	ldw	r6,-24(fp)
 d02d328:	d02d3500 	call	d02d350 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 d02d32c:	d025cac0 	call	d025cac <irq_Unmask>
   return (1);
 d02d330:	00800044 	movi	r2,1
 d02d334:	e0bffe15 	stw	r2,-8(fp)
 d02d338:	e0bffe17 	ldw	r2,-8(fp)
}
 d02d33c:	e037883a 	mov	sp,fp
 d02d340:	dfc00117 	ldw	ra,4(sp)
 d02d344:	df000017 	ldw	fp,0(sp)
 d02d348:	dec00204 	addi	sp,sp,8
 d02d34c:	f800283a 	ret

0d02d350 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 d02d350:	defffb04 	addi	sp,sp,-20
 d02d354:	dfc00415 	stw	ra,16(sp)
 d02d358:	df000315 	stw	fp,12(sp)
 d02d35c:	df000304 	addi	fp,sp,12
 d02d360:	e13ffd15 	stw	r4,-12(fp)
 d02d364:	e17ffe15 	stw	r5,-8(fp)
 d02d368:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 d02d36c:	00006a06 	br	d02d518 <sbcompress+0x1c8>
   {
      if (m->m_len == 0) 
 d02d370:	e0bffe17 	ldw	r2,-8(fp)
 d02d374:	10800217 	ldw	r2,8(r2)
 d02d378:	1004c03a 	cmpne	r2,r2,zero
 d02d37c:	1000041e 	bne	r2,zero,d02d390 <sbcompress+0x40>
      {
         m = m_free(m);
 d02d380:	e13ffe17 	ldw	r4,-8(fp)
 d02d384:	d026a1c0 	call	d026a1c <m_free>
 d02d388:	e0bffe15 	stw	r2,-8(fp)
         continue;
 d02d38c:	00006206 	br	d02d518 <sbcompress+0x1c8>
      }
      if (m->m_type != MT_RXDATA && 
 d02d390:	e0bffe17 	ldw	r2,-8(fp)
 d02d394:	10800817 	ldw	r2,32(r2)
 d02d398:	10800060 	cmpeqi	r2,r2,1
 d02d39c:	1000101e 	bne	r2,zero,d02d3e0 <sbcompress+0x90>
 d02d3a0:	e0bffe17 	ldw	r2,-8(fp)
 d02d3a4:	10800817 	ldw	r2,32(r2)
 d02d3a8:	108000a0 	cmpeqi	r2,r2,2
 d02d3ac:	10000c1e 	bne	r2,zero,d02d3e0 <sbcompress+0x90>
 d02d3b0:	e0bffe17 	ldw	r2,-8(fp)
 d02d3b4:	10800817 	ldw	r2,32(r2)
 d02d3b8:	10800260 	cmpeqi	r2,r2,9
 d02d3bc:	1000081e 	bne	r2,zero,d02d3e0 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 d02d3c0:	e0bffe17 	ldw	r2,-8(fp)
 d02d3c4:	11400817 	ldw	r5,32(r2)
 d02d3c8:	01034174 	movhi	r4,3333
 d02d3cc:	213e9a04 	addi	r4,r4,-1432
 d02d3d0:	d0028a00 	call	d0028a0 <printf>
         panic ("sbcomp:bad");
 d02d3d4:	01034174 	movhi	r4,3333
 d02d3d8:	213e9f04 	addi	r4,r4,-1412
 d02d3dc:	d02093c0 	call	d02093c <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 d02d3e0:	e0bfff17 	ldw	r2,-4(fp)
 d02d3e4:	1005003a 	cmpeq	r2,r2,zero
 d02d3e8:	1000331e 	bne	r2,zero,d02d4b8 <sbcompress+0x168>
 d02d3ec:	e0bffd17 	ldw	r2,-12(fp)
 d02d3f0:	1080070b 	ldhu	r2,28(r2)
 d02d3f4:	10bfffcc 	andi	r2,r2,65535
 d02d3f8:	1080200c 	andi	r2,r2,128
 d02d3fc:	1005003a 	cmpeq	r2,r2,zero
 d02d400:	10002d1e 	bne	r2,zero,d02d4b8 <sbcompress+0x168>
 d02d404:	e0bfff17 	ldw	r2,-4(fp)
 d02d408:	10c00217 	ldw	r3,8(r2)
 d02d40c:	e0bffe17 	ldw	r2,-8(fp)
 d02d410:	10800217 	ldw	r2,8(r2)
 d02d414:	188b883a 	add	r5,r3,r2
 d02d418:	e0bfff17 	ldw	r2,-4(fp)
 d02d41c:	11000517 	ldw	r4,20(r2)
 d02d420:	e0bfff17 	ldw	r2,-4(fp)
 d02d424:	10800317 	ldw	r2,12(r2)
 d02d428:	1007883a 	mov	r3,r2
 d02d42c:	e0bfff17 	ldw	r2,-4(fp)
 d02d430:	10800417 	ldw	r2,16(r2)
 d02d434:	1885c83a 	sub	r2,r3,r2
 d02d438:	2085c83a 	sub	r2,r4,r2
 d02d43c:	28801e2e 	bgeu	r5,r2,d02d4b8 <sbcompress+0x168>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 d02d440:	e0bfff17 	ldw	r2,-4(fp)
 d02d444:	10c00317 	ldw	r3,12(r2)
 d02d448:	e0bfff17 	ldw	r2,-4(fp)
 d02d44c:	10800217 	ldw	r2,8(r2)
 d02d450:	1887883a 	add	r3,r3,r2
 d02d454:	e0bffe17 	ldw	r2,-8(fp)
 d02d458:	11400317 	ldw	r5,12(r2)
 d02d45c:	e0bffe17 	ldw	r2,-8(fp)
 d02d460:	10800217 	ldw	r2,8(r2)
 d02d464:	1809883a 	mov	r4,r3
 d02d468:	100d883a 	mov	r6,r2
 d02d46c:	d0026080 	call	d002608 <memcpy>
         sballoc(sb, m);
 d02d470:	e0bffd17 	ldw	r2,-12(fp)
 d02d474:	10c00017 	ldw	r3,0(r2)
 d02d478:	e0bffe17 	ldw	r2,-8(fp)
 d02d47c:	10800217 	ldw	r2,8(r2)
 d02d480:	1887883a 	add	r3,r3,r2
 d02d484:	e0bffd17 	ldw	r2,-12(fp)
 d02d488:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 d02d48c:	e0bfff17 	ldw	r2,-4(fp)
 d02d490:	10c00217 	ldw	r3,8(r2)
 d02d494:	e0bffe17 	ldw	r2,-8(fp)
 d02d498:	10800217 	ldw	r2,8(r2)
 d02d49c:	1887883a 	add	r3,r3,r2
 d02d4a0:	e0bfff17 	ldw	r2,-4(fp)
 d02d4a4:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 d02d4a8:	e13ffe17 	ldw	r4,-8(fp)
 d02d4ac:	d026a1c0 	call	d026a1c <m_free>
 d02d4b0:	e0bffe15 	stw	r2,-8(fp)
         continue;
 d02d4b4:	00001806 	br	d02d518 <sbcompress+0x1c8>
      }
      sballoc(sb, m);
 d02d4b8:	e0bffd17 	ldw	r2,-12(fp)
 d02d4bc:	10c00017 	ldw	r3,0(r2)
 d02d4c0:	e0bffe17 	ldw	r2,-8(fp)
 d02d4c4:	10800217 	ldw	r2,8(r2)
 d02d4c8:	1887883a 	add	r3,r3,r2
 d02d4cc:	e0bffd17 	ldw	r2,-12(fp)
 d02d4d0:	10c00015 	stw	r3,0(r2)
      if (n)
 d02d4d4:	e0bfff17 	ldw	r2,-4(fp)
 d02d4d8:	1005003a 	cmpeq	r2,r2,zero
 d02d4dc:	1000041e 	bne	r2,zero,d02d4f0 <sbcompress+0x1a0>
         n->m_next = m;
 d02d4e0:	e0ffff17 	ldw	r3,-4(fp)
 d02d4e4:	e0bffe17 	ldw	r2,-8(fp)
 d02d4e8:	18800615 	stw	r2,24(r3)
 d02d4ec:	00000306 	br	d02d4fc <sbcompress+0x1ac>
      else
         sb->sb_mb = m;
 d02d4f0:	e0fffd17 	ldw	r3,-12(fp)
 d02d4f4:	e0bffe17 	ldw	r2,-8(fp)
 d02d4f8:	18800615 	stw	r2,24(r3)
      n = m;
 d02d4fc:	e0bffe17 	ldw	r2,-8(fp)
 d02d500:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 d02d504:	e0bffe17 	ldw	r2,-8(fp)
 d02d508:	10800617 	ldw	r2,24(r2)
 d02d50c:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 d02d510:	e0bfff17 	ldw	r2,-4(fp)
 d02d514:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 d02d518:	e0bffe17 	ldw	r2,-8(fp)
 d02d51c:	1004c03a 	cmpne	r2,r2,zero
 d02d520:	103f931e 	bne	r2,zero,d02d370 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 d02d524:	e037883a 	mov	sp,fp
 d02d528:	dfc00117 	ldw	ra,4(sp)
 d02d52c:	df000017 	ldw	fp,0(sp)
 d02d530:	dec00204 	addi	sp,sp,8
 d02d534:	f800283a 	ret

0d02d538 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 d02d538:	defffd04 	addi	sp,sp,-12
 d02d53c:	dfc00215 	stw	ra,8(sp)
 d02d540:	df000115 	stw	fp,4(sp)
 d02d544:	df000104 	addi	fp,sp,4
 d02d548:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 d02d54c:	d025c500 	call	d025c50 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 d02d550:	e0bfff17 	ldw	r2,-4(fp)
 d02d554:	1080070b 	ldhu	r2,28(r2)
 d02d558:	10bfffcc 	andi	r2,r2,65535
 d02d55c:	1080004c 	andi	r2,r2,1
 d02d560:	10803fcc 	andi	r2,r2,255
 d02d564:	1005003a 	cmpeq	r2,r2,zero
 d02d568:	1000091e 	bne	r2,zero,d02d590 <sbflush+0x58>
      panic("sbflush");
 d02d56c:	01034174 	movhi	r4,3333
 d02d570:	213ea204 	addi	r4,r4,-1400
 d02d574:	d02093c0 	call	d02093c <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 d02d578:	00000506 	br	d02d590 <sbflush+0x58>
      sbdrop (sb, (int)sb->sb_cc);
 d02d57c:	e0bfff17 	ldw	r2,-4(fp)
 d02d580:	10800017 	ldw	r2,0(r2)
 d02d584:	100b883a 	mov	r5,r2
 d02d588:	e13fff17 	ldw	r4,-4(fp)
 d02d58c:	d02d5c80 	call	d02d5c8 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 d02d590:	e0bfff17 	ldw	r2,-4(fp)
 d02d594:	10800217 	ldw	r2,8(r2)
 d02d598:	1004c03a 	cmpne	r2,r2,zero
 d02d59c:	103ff71e 	bne	r2,zero,d02d57c <sbflush+0x44>
 d02d5a0:	e0bfff17 	ldw	r2,-4(fp)
 d02d5a4:	10800017 	ldw	r2,0(r2)
 d02d5a8:	1004c03a 	cmpne	r2,r2,zero
 d02d5ac:	103ff31e 	bne	r2,zero,d02d57c <sbflush+0x44>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 d02d5b0:	d025cac0 	call	d025cac <irq_Unmask>
}
 d02d5b4:	e037883a 	mov	sp,fp
 d02d5b8:	dfc00117 	ldw	ra,4(sp)
 d02d5bc:	df000017 	ldw	fp,0(sp)
 d02d5c0:	dec00204 	addi	sp,sp,8
 d02d5c4:	f800283a 	ret

0d02d5c8 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 d02d5c8:	defff904 	addi	sp,sp,-28
 d02d5cc:	dfc00615 	stw	ra,24(sp)
 d02d5d0:	df000515 	stw	fp,20(sp)
 d02d5d4:	df000504 	addi	fp,sp,20
 d02d5d8:	e13ffe15 	stw	r4,-8(fp)
 d02d5dc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 d02d5e0:	d025c500 	call	d025c50 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 d02d5e4:	e0bffe17 	ldw	r2,-8(fp)
 d02d5e8:	10800617 	ldw	r2,24(r2)
 d02d5ec:	e0bffd15 	stw	r2,-12(fp)
 d02d5f0:	e0bffd17 	ldw	r2,-12(fp)
 d02d5f4:	1005003a 	cmpeq	r2,r2,zero
 d02d5f8:	1000041e 	bne	r2,zero,d02d60c <sbdrop+0x44>
      next = m->m_act;
 d02d5fc:	e0bffd17 	ldw	r2,-12(fp)
 d02d600:	10800717 	ldw	r2,28(r2)
 d02d604:	e0bffb15 	stw	r2,-20(fp)
 d02d608:	00003906 	br	d02d6f0 <sbdrop+0x128>
   else
      next = NULL;
 d02d60c:	e03ffb15 	stw	zero,-20(fp)
   while (len > 0) 
 d02d610:	00003706 	br	d02d6f0 <sbdrop+0x128>
   {
      if (m == 0) 
 d02d614:	e0bffd17 	ldw	r2,-12(fp)
 d02d618:	1004c03a 	cmpne	r2,r2,zero
 d02d61c:	10000c1e 	bne	r2,zero,d02d650 <sbdrop+0x88>
      {
         if (next == 0)
 d02d620:	e0bffb17 	ldw	r2,-20(fp)
 d02d624:	1004c03a 	cmpne	r2,r2,zero
 d02d628:	1000031e 	bne	r2,zero,d02d638 <sbdrop+0x70>
            panic("sbdrop");
 d02d62c:	01034174 	movhi	r4,3333
 d02d630:	213ea404 	addi	r4,r4,-1392
 d02d634:	d02093c0 	call	d02093c <panic>
         m = next;
 d02d638:	e0bffb17 	ldw	r2,-20(fp)
 d02d63c:	e0bffd15 	stw	r2,-12(fp)
         next = m->m_act;
 d02d640:	e0bffd17 	ldw	r2,-12(fp)
 d02d644:	10800717 	ldw	r2,28(r2)
 d02d648:	e0bffb15 	stw	r2,-20(fp)
         continue;
 d02d64c:	00002806 	br	d02d6f0 <sbdrop+0x128>
      }
      if (m->m_len > (unsigned)len) 
 d02d650:	e0bffd17 	ldw	r2,-12(fp)
 d02d654:	10c00217 	ldw	r3,8(r2)
 d02d658:	e0bfff17 	ldw	r2,-4(fp)
 d02d65c:	10c0132e 	bgeu	r2,r3,d02d6ac <sbdrop+0xe4>
      {
         m->m_len -= len;
 d02d660:	e0bffd17 	ldw	r2,-12(fp)
 d02d664:	10c00217 	ldw	r3,8(r2)
 d02d668:	e0bfff17 	ldw	r2,-4(fp)
 d02d66c:	1887c83a 	sub	r3,r3,r2
 d02d670:	e0bffd17 	ldw	r2,-12(fp)
 d02d674:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 d02d678:	e0bffd17 	ldw	r2,-12(fp)
 d02d67c:	10c00317 	ldw	r3,12(r2)
 d02d680:	e0bfff17 	ldw	r2,-4(fp)
 d02d684:	1887883a 	add	r3,r3,r2
 d02d688:	e0bffd17 	ldw	r2,-12(fp)
 d02d68c:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 d02d690:	e0bffe17 	ldw	r2,-8(fp)
 d02d694:	10c00017 	ldw	r3,0(r2)
 d02d698:	e0bfff17 	ldw	r2,-4(fp)
 d02d69c:	1887c83a 	sub	r3,r3,r2
 d02d6a0:	e0bffe17 	ldw	r2,-8(fp)
 d02d6a4:	10c00015 	stw	r3,0(r2)
         break;
 d02d6a8:	00002106 	br	d02d730 <sbdrop+0x168>
      }
      len -= m->m_len;
 d02d6ac:	e0ffff17 	ldw	r3,-4(fp)
 d02d6b0:	e0bffd17 	ldw	r2,-12(fp)
 d02d6b4:	10800217 	ldw	r2,8(r2)
 d02d6b8:	1885c83a 	sub	r2,r3,r2
 d02d6bc:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 d02d6c0:	e0bffe17 	ldw	r2,-8(fp)
 d02d6c4:	10c00017 	ldw	r3,0(r2)
 d02d6c8:	e0bffd17 	ldw	r2,-12(fp)
 d02d6cc:	10800217 	ldw	r2,8(r2)
 d02d6d0:	1887c83a 	sub	r3,r3,r2
 d02d6d4:	e0bffe17 	ldw	r2,-8(fp)
 d02d6d8:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 d02d6dc:	e13ffd17 	ldw	r4,-12(fp)
 d02d6e0:	d026a1c0 	call	d026a1c <m_free>
 d02d6e4:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 d02d6e8:	e0bffc17 	ldw	r2,-16(fp)
 d02d6ec:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 d02d6f0:	e0bfff17 	ldw	r2,-4(fp)
 d02d6f4:	10800048 	cmpgei	r2,r2,1
 d02d6f8:	103fc61e 	bne	r2,zero,d02d614 <sbdrop+0x4c>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 d02d6fc:	00000c06 	br	d02d730 <sbdrop+0x168>
   {
      sbfree(sb, m);
 d02d700:	e0bffe17 	ldw	r2,-8(fp)
 d02d704:	10c00017 	ldw	r3,0(r2)
 d02d708:	e0bffd17 	ldw	r2,-12(fp)
 d02d70c:	10800217 	ldw	r2,8(r2)
 d02d710:	1887c83a 	sub	r3,r3,r2
 d02d714:	e0bffe17 	ldw	r2,-8(fp)
 d02d718:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 d02d71c:	e13ffd17 	ldw	r4,-12(fp)
 d02d720:	d026a1c0 	call	d026a1c <m_free>
 d02d724:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 d02d728:	e0bffc17 	ldw	r2,-16(fp)
 d02d72c:	e0bffd15 	stw	r2,-12(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 d02d730:	e0bffd17 	ldw	r2,-12(fp)
 d02d734:	1005003a 	cmpeq	r2,r2,zero
 d02d738:	1000041e 	bne	r2,zero,d02d74c <sbdrop+0x184>
 d02d73c:	e0bffd17 	ldw	r2,-12(fp)
 d02d740:	10800217 	ldw	r2,8(r2)
 d02d744:	1005003a 	cmpeq	r2,r2,zero
 d02d748:	103fed1e 	bne	r2,zero,d02d700 <sbdrop+0x138>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 d02d74c:	e0bffd17 	ldw	r2,-12(fp)
 d02d750:	1005003a 	cmpeq	r2,r2,zero
 d02d754:	1000071e 	bne	r2,zero,d02d774 <sbdrop+0x1ac>
   {
      sb->sb_mb = m;
 d02d758:	e0fffe17 	ldw	r3,-8(fp)
 d02d75c:	e0bffd17 	ldw	r2,-12(fp)
 d02d760:	18800615 	stw	r2,24(r3)
      m->m_act = next;
 d02d764:	e0fffd17 	ldw	r3,-12(fp)
 d02d768:	e0bffb17 	ldw	r2,-20(fp)
 d02d76c:	18800715 	stw	r2,28(r3)
 d02d770:	00000306 	br	d02d780 <sbdrop+0x1b8>
   } else
      sb->sb_mb = next;
 d02d774:	e0fffe17 	ldw	r3,-8(fp)
 d02d778:	e0bffb17 	ldw	r2,-20(fp)
 d02d77c:	18800615 	stw	r2,24(r3)
   EXIT_CRIT_SECTION(sb);
 d02d780:	d025cac0 	call	d025cac <irq_Unmask>
}
 d02d784:	e037883a 	mov	sp,fp
 d02d788:	dfc00117 	ldw	ra,4(sp)
 d02d78c:	df000017 	ldw	fp,0(sp)
 d02d790:	dec00204 	addi	sp,sp,8
 d02d794:	f800283a 	ret

0d02d798 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 d02d798:	defff904 	addi	sp,sp,-28
 d02d79c:	dfc00615 	stw	ra,24(sp)
 d02d7a0:	df000515 	stw	fp,20(sp)
 d02d7a4:	df000504 	addi	fp,sp,20
 d02d7a8:	e13ffe15 	stw	r4,-8(fp)
 d02d7ac:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 d02d7b0:	d025c500 	call	d025c50 <irq_Mask>
   len = mbuf_len(m);
 d02d7b4:	e13fff17 	ldw	r4,-4(fp)
 d02d7b8:	d0270880 	call	d027088 <mbuf_len>
 d02d7bc:	e0bffb15 	stw	r2,-20(fp)
   if (len > 0)
 d02d7c0:	e0bffb17 	ldw	r2,-20(fp)
 d02d7c4:	10800050 	cmplti	r2,r2,1
 d02d7c8:	1000051e 	bne	r2,zero,d02d7e0 <sbdropend+0x48>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 d02d7cc:	e0bffe17 	ldw	r2,-8(fp)
 d02d7d0:	11000617 	ldw	r4,24(r2)
 d02d7d4:	e0bffb17 	ldw	r2,-20(fp)
 d02d7d8:	008bc83a 	sub	r5,zero,r2
 d02d7dc:	d026eb80 	call	d026eb8 <m_adj>
   nmb = sb->sb_mb;
 d02d7e0:	e0bffe17 	ldw	r2,-8(fp)
 d02d7e4:	10800617 	ldw	r2,24(r2)
 d02d7e8:	e0bffd15 	stw	r2,-12(fp)
   pmb = NULL;
 d02d7ec:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 d02d7f0:	e0bffe17 	ldw	r2,-8(fp)
 d02d7f4:	10800617 	ldw	r2,24(r2)
 d02d7f8:	10800217 	ldw	r2,8(r2)
 d02d7fc:	1004c03a 	cmpne	r2,r2,zero
 d02d800:	1000081e 	bne	r2,zero,d02d824 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 d02d804:	e0bffe17 	ldw	r2,-8(fp)
 d02d808:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 d02d80c:	00000506 	br	d02d824 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 d02d810:	e0bffd17 	ldw	r2,-12(fp)
 d02d814:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 d02d818:	e0bffd17 	ldw	r2,-12(fp)
 d02d81c:	10800617 	ldw	r2,24(r2)
 d02d820:	e0bffd15 	stw	r2,-12(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 d02d824:	e0bffd17 	ldw	r2,-12(fp)
 d02d828:	1005003a 	cmpeq	r2,r2,zero
 d02d82c:	1000041e 	bne	r2,zero,d02d840 <sbdropend+0xa8>
 d02d830:	e0bffd17 	ldw	r2,-12(fp)
 d02d834:	10800217 	ldw	r2,8(r2)
 d02d838:	1004c03a 	cmpne	r2,r2,zero
 d02d83c:	103ff41e 	bne	r2,zero,d02d810 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 d02d840:	e0bffd17 	ldw	r2,-12(fp)
 d02d844:	1005003a 	cmpeq	r2,r2,zero
 d02d848:	10000b1e 	bne	r2,zero,d02d878 <sbdropend+0xe0>
 d02d84c:	e0bffd17 	ldw	r2,-12(fp)
 d02d850:	10800217 	ldw	r2,8(r2)
 d02d854:	1004c03a 	cmpne	r2,r2,zero
 d02d858:	1000071e 	bne	r2,zero,d02d878 <sbdropend+0xe0>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 d02d85c:	e0bffc17 	ldw	r2,-16(fp)
 d02d860:	1005003a 	cmpeq	r2,r2,zero
 d02d864:	1000021e 	bne	r2,zero,d02d870 <sbdropend+0xd8>
         pmb->m_next = NULL;
 d02d868:	e0bffc17 	ldw	r2,-16(fp)
 d02d86c:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 d02d870:	e13ffd17 	ldw	r4,-12(fp)
 d02d874:	d026b500 	call	d026b50 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 d02d878:	e0bffe17 	ldw	r2,-8(fp)
 d02d87c:	10c00017 	ldw	r3,0(r2)
 d02d880:	e0bffb17 	ldw	r2,-20(fp)
 d02d884:	1887c83a 	sub	r3,r3,r2
 d02d888:	e0bffe17 	ldw	r2,-8(fp)
 d02d88c:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 d02d890:	d025cac0 	call	d025cac <irq_Unmask>
}
 d02d894:	e037883a 	mov	sp,fp
 d02d898:	dfc00117 	ldw	ra,4(sp)
 d02d89c:	df000017 	ldw	fp,0(sp)
 d02d8a0:	dec00204 	addi	sp,sp,8
 d02d8a4:	f800283a 	ret

0d02d8a8 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 d02d8a8:	defffb04 	addi	sp,sp,-20
 d02d8ac:	dfc00415 	stw	ra,16(sp)
 d02d8b0:	df000315 	stw	fp,12(sp)
 d02d8b4:	df000304 	addi	fp,sp,12
 d02d8b8:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 d02d8bc:	d025c500 	call	d025c50 <irq_Mask>
   m = sb->sb_mb;
 d02d8c0:	e0bfff17 	ldw	r2,-4(fp)
 d02d8c4:	10800617 	ldw	r2,24(r2)
 d02d8c8:	e0bffe15 	stw	r2,-8(fp)
   if (m)
 d02d8cc:	e0bffe17 	ldw	r2,-8(fp)
 d02d8d0:	1005003a 	cmpeq	r2,r2,zero
 d02d8d4:	1000131e 	bne	r2,zero,d02d924 <sbdroprecord+0x7c>
   {  sb->sb_mb = m->m_act;
 d02d8d8:	e0bffe17 	ldw	r2,-8(fp)
 d02d8dc:	10c00717 	ldw	r3,28(r2)
 d02d8e0:	e0bfff17 	ldw	r2,-4(fp)
 d02d8e4:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 d02d8e8:	e0bfff17 	ldw	r2,-4(fp)
 d02d8ec:	10c00017 	ldw	r3,0(r2)
 d02d8f0:	e0bffe17 	ldw	r2,-8(fp)
 d02d8f4:	10800217 	ldw	r2,8(r2)
 d02d8f8:	1887c83a 	sub	r3,r3,r2
 d02d8fc:	e0bfff17 	ldw	r2,-4(fp)
 d02d900:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 d02d904:	e13ffe17 	ldw	r4,-8(fp)
 d02d908:	d026a1c0 	call	d026a1c <m_free>
 d02d90c:	e0bffd15 	stw	r2,-12(fp)
      } while ((m = mn) != NULL);
 d02d910:	e0bffd17 	ldw	r2,-12(fp)
 d02d914:	e0bffe15 	stw	r2,-8(fp)
 d02d918:	e0bffe17 	ldw	r2,-8(fp)
 d02d91c:	1004c03a 	cmpne	r2,r2,zero
 d02d920:	103ff11e 	bne	r2,zero,d02d8e8 <sbdroprecord+0x40>
         }
   EXIT_CRIT_SECTION(sb);
 d02d924:	d025cac0 	call	d025cac <irq_Unmask>
}
 d02d928:	e037883a 	mov	sp,fp
 d02d92c:	dfc00117 	ldw	ra,4(sp)
 d02d930:	df000017 	ldw	fp,0(sp)
 d02d934:	dec00204 	addi	sp,sp,8
 d02d938:	f800283a 	ret

0d02d93c <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 d02d93c:	defe7204 	addi	sp,sp,-1592
 d02d940:	dfc18d15 	stw	ra,1588(sp)
 d02d944:	df018c15 	stw	fp,1584(sp)
 d02d948:	df018c04 	addi	fp,sp,1584
 d02d94c:	e13ffc15 	stw	r4,-16(fp)
 d02d950:	e17ffd15 	stw	r5,-12(fp)
 d02d954:	e1bffe15 	stw	r6,-8(fp)
 d02d958:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 d02d95c:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 d02d960:	e0be7604 	addi	r2,fp,-1576
 d02d964:	1009883a 	mov	r4,r2
 d02d968:	0180c304 	movi	r6,780
 d02d96c:	000b883a 	mov	r5,zero
 d02d970:	d0027880 	call	d002788 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 d02d974:	e0bf3904 	addi	r2,fp,-796
 d02d978:	1009883a 	mov	r4,r2
 d02d97c:	0180c304 	movi	r6,780
 d02d980:	000b883a 	mov	r5,zero
 d02d984:	d0027880 	call	d002788 <memset>

   if (in)
 d02d988:	e0bffc17 	ldw	r2,-16(fp)
 d02d98c:	1005003a 	cmpeq	r2,r2,zero
 d02d990:	1000061e 	bne	r2,zero,d02d9ac <t_select+0x70>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 d02d994:	e0bf3904 	addi	r2,fp,-796
 d02d998:	e0fffc17 	ldw	r3,-16(fp)
 d02d99c:	1009883a 	mov	r4,r2
 d02d9a0:	180b883a 	mov	r5,r3
 d02d9a4:	01804104 	movi	r6,260
 d02d9a8:	d0026080 	call	d002608 <memcpy>
   if (out)
 d02d9ac:	e0bffd17 	ldw	r2,-12(fp)
 d02d9b0:	1005003a 	cmpeq	r2,r2,zero
 d02d9b4:	1000071e 	bne	r2,zero,d02d9d4 <t_select+0x98>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 d02d9b8:	e0bf3904 	addi	r2,fp,-796
 d02d9bc:	10804104 	addi	r2,r2,260
 d02d9c0:	e0fffd17 	ldw	r3,-12(fp)
 d02d9c4:	1009883a 	mov	r4,r2
 d02d9c8:	180b883a 	mov	r5,r3
 d02d9cc:	01804104 	movi	r6,260
 d02d9d0:	d0026080 	call	d002608 <memcpy>
   if (ex)
 d02d9d4:	e0bffe17 	ldw	r2,-8(fp)
 d02d9d8:	1005003a 	cmpeq	r2,r2,zero
 d02d9dc:	1000071e 	bne	r2,zero,d02d9fc <t_select+0xc0>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 d02d9e0:	e0bf3904 	addi	r2,fp,-796
 d02d9e4:	10808204 	addi	r2,r2,520
 d02d9e8:	e0fffe17 	ldw	r3,-8(fp)
 d02d9ec:	1009883a 	mov	r4,r2
 d02d9f0:	180b883a 	mov	r5,r3
 d02d9f4:	01804104 	movi	r6,260
 d02d9f8:	d0026080 	call	d002608 <memcpy>
   tmo = cticks + tv;
 d02d9fc:	00834174 	movhi	r2,3333
 d02da00:	109b4504 	addi	r2,r2,27924
 d02da04:	10c00017 	ldw	r3,0(r2)
 d02da08:	e0bfff17 	ldw	r2,-4(fp)
 d02da0c:	1885883a 	add	r2,r3,r2
 d02da10:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 d02da14:	e0bf3917 	ldw	r2,-796(fp)
 d02da18:	1004c03a 	cmpne	r2,r2,zero
 d02da1c:	10000e1e 	bne	r2,zero,d02da58 <t_select+0x11c>
 d02da20:	e0bf7a17 	ldw	r2,-536(fp)
 d02da24:	1004c03a 	cmpne	r2,r2,zero
 d02da28:	10000b1e 	bne	r2,zero,d02da58 <t_select+0x11c>
 d02da2c:	e0bfbb17 	ldw	r2,-276(fp)
 d02da30:	1004c03a 	cmpne	r2,r2,zero
 d02da34:	1000081e 	bne	r2,zero,d02da58 <t_select+0x11c>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 d02da38:	e0bfff17 	ldw	r2,-4(fp)
 d02da3c:	10800050 	cmplti	r2,r2,1
 d02da40:	1000201e 	bne	r2,zero,d02dac4 <t_select+0x188>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 d02da44:	e0bfff17 	ldw	r2,-4(fp)
 d02da48:	10800044 	addi	r2,r2,1
 d02da4c:	113fffcc 	andi	r4,r2,65535
 d02da50:	d0156dc0 	call	d0156dc <OSTimeDly>
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 d02da54:	00001b06 	br	d02dac4 <t_select+0x188>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 d02da58:	0009883a 	mov	r4,zero
 d02da5c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 d02da60:	00000f06 	br	d02daa0 <t_select+0x164>
      {
         if (tv != -1L) 
 d02da64:	e0bfff17 	ldw	r2,-4(fp)
 d02da68:	10bfffe0 	cmpeqi	r2,r2,-1
 d02da6c:	1000051e 	bne	r2,zero,d02da84 <t_select+0x148>
         {
            if (tmo <= cticks)
 d02da70:	00834174 	movhi	r2,3333
 d02da74:	109b4504 	addi	r2,r2,27924
 d02da78:	10c00017 	ldw	r3,0(r2)
 d02da7c:	e0be7517 	ldw	r2,-1580(fp)
 d02da80:	18800e2e 	bgeu	r3,r2,d02dabc <t_select+0x180>
               break;
         }
         select_wait = 1;
 d02da84:	00c34174 	movhi	r3,3333
 d02da88:	18db4d04 	addi	r3,r3,27956
 d02da8c:	00800044 	movi	r2,1
 d02da90:	1880000d 	sth	r2,0(r3)
         tcp_sleep (&select_wait);
 d02da94:	01034174 	movhi	r4,3333
 d02da98:	211b4d04 	addi	r4,r4,27956
 d02da9c:	d0212b40 	call	d0212b4 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 d02daa0:	e13f3904 	addi	r4,fp,-796
 d02daa4:	e17e7604 	addi	r5,fp,-1576
 d02daa8:	d02db5c0 	call	d02db5c <sock_selscan>
 d02daac:	e0be7415 	stw	r2,-1584(fp)
 d02dab0:	e0be7417 	ldw	r2,-1584(fp)
 d02dab4:	1005003a 	cmpeq	r2,r2,zero
 d02dab8:	103fea1e 	bne	r2,zero,d02da64 <t_select+0x128>
               break;
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02dabc:	0009883a 	mov	r4,zero
 d02dac0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 d02dac4:	e0be7417 	ldw	r2,-1584(fp)
 d02dac8:	1004803a 	cmplt	r2,r2,zero
 d02dacc:	10001d1e 	bne	r2,zero,d02db44 <t_select+0x208>
   {
      if (in)
 d02dad0:	e0bffc17 	ldw	r2,-16(fp)
 d02dad4:	1005003a 	cmpeq	r2,r2,zero
 d02dad8:	1000061e 	bne	r2,zero,d02daf4 <t_select+0x1b8>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 d02dadc:	e0bffc17 	ldw	r2,-16(fp)
 d02dae0:	e0fe7604 	addi	r3,fp,-1576
 d02dae4:	1009883a 	mov	r4,r2
 d02dae8:	180b883a 	mov	r5,r3
 d02daec:	01804104 	movi	r6,260
 d02daf0:	d0026080 	call	d002608 <memcpy>
      if (out)
 d02daf4:	e0bffd17 	ldw	r2,-12(fp)
 d02daf8:	1005003a 	cmpeq	r2,r2,zero
 d02dafc:	1000071e 	bne	r2,zero,d02db1c <t_select+0x1e0>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 d02db00:	e0be7604 	addi	r2,fp,-1576
 d02db04:	10c04104 	addi	r3,r2,260
 d02db08:	e0bffd17 	ldw	r2,-12(fp)
 d02db0c:	1009883a 	mov	r4,r2
 d02db10:	180b883a 	mov	r5,r3
 d02db14:	01804104 	movi	r6,260
 d02db18:	d0026080 	call	d002608 <memcpy>
      if (ex)
 d02db1c:	e0bffe17 	ldw	r2,-8(fp)
 d02db20:	1005003a 	cmpeq	r2,r2,zero
 d02db24:	1000071e 	bne	r2,zero,d02db44 <t_select+0x208>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 d02db28:	e0be7604 	addi	r2,fp,-1576
 d02db2c:	10c08204 	addi	r3,r2,520
 d02db30:	e0bffe17 	ldw	r2,-8(fp)
 d02db34:	1009883a 	mov	r4,r2
 d02db38:	180b883a 	mov	r5,r3
 d02db3c:	01804104 	movi	r6,260
 d02db40:	d0026080 	call	d002608 <memcpy>
   }
   return retval;
 d02db44:	e0be7417 	ldw	r2,-1584(fp)
}
 d02db48:	e037883a 	mov	sp,fp
 d02db4c:	dfc00117 	ldw	ra,4(sp)
 d02db50:	df000017 	ldw	fp,0(sp)
 d02db54:	dec00204 	addi	sp,sp,8
 d02db58:	f800283a 	ret

0d02db5c <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 d02db5c:	defff504 	addi	sp,sp,-44
 d02db60:	dfc00a15 	stw	ra,40(sp)
 d02db64:	df000915 	stw	fp,36(sp)
 d02db68:	df000904 	addi	fp,sp,36
 d02db6c:	e13ffd15 	stw	r4,-12(fp)
 d02db70:	e17ffe15 	stw	r5,-8(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 d02db74:	e03ff815 	stw	zero,-32(fp)
   int   num_sel  =  0;
 d02db78:	e03ff715 	stw	zero,-36(fp)

   for (which = 0; which < 3; which++)
 d02db7c:	e03ffa15 	stw	zero,-24(fp)
 d02db80:	00004506 	br	d02dc98 <sock_selscan+0x13c>
   {
      switch (which)
 d02db84:	e0bffa17 	ldw	r2,-24(fp)
 d02db88:	e0bfff15 	stw	r2,-4(fp)
 d02db8c:	e0ffff17 	ldw	r3,-4(fp)
 d02db90:	18800060 	cmpeqi	r2,r3,1
 d02db94:	10000a1e 	bne	r2,zero,d02dbc0 <sock_selscan+0x64>
 d02db98:	e0ffff17 	ldw	r3,-4(fp)
 d02db9c:	188000a0 	cmpeqi	r2,r3,2
 d02dba0:	10000a1e 	bne	r2,zero,d02dbcc <sock_selscan+0x70>
 d02dba4:	e0ffff17 	ldw	r3,-4(fp)
 d02dba8:	1805003a 	cmpeq	r2,r3,zero
 d02dbac:	1000011e 	bne	r2,zero,d02dbb4 <sock_selscan+0x58>
 d02dbb0:	00000706 	br	d02dbd0 <sock_selscan+0x74>
      {
      case 0:
         flag = SOREAD; break;
 d02dbb4:	00800044 	movi	r2,1
 d02dbb8:	e0bff815 	stw	r2,-32(fp)
 d02dbbc:	00000406 	br	d02dbd0 <sock_selscan+0x74>

      case 1:
         flag = SOWRITE; break;
 d02dbc0:	00800084 	movi	r2,2
 d02dbc4:	e0bff815 	stw	r2,-32(fp)
 d02dbc8:	00000106 	br	d02dbd0 <sock_selscan+0x74>

      case 2:
         flag = 0; break;
 d02dbcc:	e03ff815 	stw	zero,-32(fp)
      }
      in = &ibits [which];
 d02dbd0:	e13ffa17 	ldw	r4,-24(fp)
 d02dbd4:	01404104 	movi	r5,260
 d02dbd8:	d00235c0 	call	d00235c <__mulsi3>
 d02dbdc:	1007883a 	mov	r3,r2
 d02dbe0:	e0bffd17 	ldw	r2,-12(fp)
 d02dbe4:	1885883a 	add	r2,r3,r2
 d02dbe8:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 d02dbec:	e13ffa17 	ldw	r4,-24(fp)
 d02dbf0:	01404104 	movi	r5,260
 d02dbf4:	d00235c0 	call	d00235c <__mulsi3>
 d02dbf8:	1007883a 	mov	r3,r2
 d02dbfc:	e0bffe17 	ldw	r2,-8(fp)
 d02dc00:	1885883a 	add	r2,r3,r2
 d02dc04:	e0bffb15 	stw	r2,-20(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 d02dc08:	e03ff915 	stw	zero,-28(fp)
 d02dc0c:	00001a06 	br	d02dc78 <sock_selscan+0x11c>
      {
         if (sock_select (in->fd_array[sock], flag))
 d02dc10:	e0bff917 	ldw	r2,-28(fp)
 d02dc14:	e0fffc17 	ldw	r3,-16(fp)
 d02dc18:	1085883a 	add	r2,r2,r2
 d02dc1c:	1085883a 	add	r2,r2,r2
 d02dc20:	10c5883a 	add	r2,r2,r3
 d02dc24:	10800104 	addi	r2,r2,4
 d02dc28:	11000017 	ldw	r4,0(r2)
 d02dc2c:	e17ff817 	ldw	r5,-32(fp)
 d02dc30:	d02dcbc0 	call	d02dcbc <sock_select>
 d02dc34:	1005003a 	cmpeq	r2,r2,zero
 d02dc38:	10000c1e 	bne	r2,zero,d02dc6c <sock_selscan+0x110>
         {
            FD_SET(in->fd_array[sock], out);
 d02dc3c:	e0bff917 	ldw	r2,-28(fp)
 d02dc40:	e0fffc17 	ldw	r3,-16(fp)
 d02dc44:	1085883a 	add	r2,r2,r2
 d02dc48:	1085883a 	add	r2,r2,r2
 d02dc4c:	10c5883a 	add	r2,r2,r3
 d02dc50:	10800104 	addi	r2,r2,4
 d02dc54:	11000017 	ldw	r4,0(r2)
 d02dc58:	e17ffb17 	ldw	r5,-20(fp)
 d02dc5c:	d02e0f40 	call	d02e0f4 <ifd_set>
            num_sel++;
 d02dc60:	e0bff717 	ldw	r2,-36(fp)
 d02dc64:	10800044 	addi	r2,r2,1
 d02dc68:	e0bff715 	stw	r2,-36(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 d02dc6c:	e0bff917 	ldw	r2,-28(fp)
 d02dc70:	10800044 	addi	r2,r2,1
 d02dc74:	e0bff915 	stw	r2,-28(fp)
 d02dc78:	e0bffc17 	ldw	r2,-16(fp)
 d02dc7c:	10800017 	ldw	r2,0(r2)
 d02dc80:	1007883a 	mov	r3,r2
 d02dc84:	e0bff917 	ldw	r2,-28(fp)
 d02dc88:	10ffe116 	blt	r2,r3,d02dc10 <sock_selscan+0xb4>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 d02dc8c:	e0bffa17 	ldw	r2,-24(fp)
 d02dc90:	10800044 	addi	r2,r2,1
 d02dc94:	e0bffa15 	stw	r2,-24(fp)
 d02dc98:	e0bffa17 	ldw	r2,-24(fp)
 d02dc9c:	108000d0 	cmplti	r2,r2,3
 d02dca0:	103fb81e 	bne	r2,zero,d02db84 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 d02dca4:	e0bff717 	ldw	r2,-36(fp)
}
 d02dca8:	e037883a 	mov	sp,fp
 d02dcac:	dfc00117 	ldw	ra,4(sp)
 d02dcb0:	df000017 	ldw	fp,0(sp)
 d02dcb4:	dec00204 	addi	sp,sp,8
 d02dcb8:	f800283a 	ret

0d02dcbc <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 d02dcbc:	defff904 	addi	sp,sp,-28
 d02dcc0:	dfc00615 	stw	ra,24(sp)
 d02dcc4:	df000515 	stw	fp,20(sp)
 d02dcc8:	df000504 	addi	fp,sp,20
 d02dccc:	e13ffd15 	stw	r4,-12(fp)
 d02dcd0:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   ready =  0;
 d02dcd4:	e03ffb15 	stw	zero,-20(fp)

   so = LONG2SO(sock);
 d02dcd8:	e0bffd17 	ldw	r2,-12(fp)
 d02dcdc:	10bff804 	addi	r2,r2,-32
 d02dce0:	1085883a 	add	r2,r2,r2
 d02dce4:	1085883a 	add	r2,r2,r2
 d02dce8:	e0bffc15 	stw	r2,-16(fp)

   switch (flag) 
 d02dcec:	e0bffe17 	ldw	r2,-8(fp)
 d02dcf0:	e0bfff15 	stw	r2,-4(fp)
 d02dcf4:	e0ffff17 	ldw	r3,-4(fp)
 d02dcf8:	18800060 	cmpeqi	r2,r3,1
 d02dcfc:	1000071e 	bne	r2,zero,d02dd1c <sock_select+0x60>
 d02dd00:	e0ffff17 	ldw	r3,-4(fp)
 d02dd04:	188000a0 	cmpeqi	r2,r3,2
 d02dd08:	1000251e 	bne	r2,zero,d02dda0 <sock_select+0xe4>
 d02dd0c:	e0ffff17 	ldw	r3,-4(fp)
 d02dd10:	1805003a 	cmpeq	r2,r3,zero
 d02dd14:	1000491e 	bne	r2,zero,d02de3c <sock_select+0x180>
 d02dd18:	00006706 	br	d02deb8 <sock_select+0x1fc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 d02dd1c:	e0bffc17 	ldw	r2,-16(fp)
 d02dd20:	10800a17 	ldw	r2,40(r2)
 d02dd24:	1005003a 	cmpeq	r2,r2,zero
 d02dd28:	1000031e 	bne	r2,zero,d02dd38 <sock_select+0x7c>
      {
         ready = 1;
 d02dd2c:	00800044 	movi	r2,1
 d02dd30:	e0bffb15 	stw	r2,-20(fp)
         break;
 d02dd34:	00006006 	br	d02deb8 <sock_select+0x1fc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 d02dd38:	e0bffc17 	ldw	r2,-16(fp)
 d02dd3c:	1080088b 	ldhu	r2,34(r2)
 d02dd40:	10bfffcc 	andi	r2,r2,65535
 d02dd44:	1080080c 	andi	r2,r2,32
 d02dd48:	1005003a 	cmpeq	r2,r2,zero
 d02dd4c:	1000031e 	bne	r2,zero,d02dd5c <sock_select+0xa0>
      {  ready = 1;
 d02dd50:	00800044 	movi	r2,1
 d02dd54:	e0bffb15 	stw	r2,-20(fp)
         break;
 d02dd58:	00005706 	br	d02deb8 <sock_select+0x1fc>
      }
      if (so->so_qlen)  /* attach is ready */
 d02dd5c:	e0bffc17 	ldw	r2,-16(fp)
 d02dd60:	10801e43 	ldbu	r2,121(r2)
 d02dd64:	10803fcc 	andi	r2,r2,255
 d02dd68:	1080201c 	xori	r2,r2,128
 d02dd6c:	10bfe004 	addi	r2,r2,-128
 d02dd70:	1005003a 	cmpeq	r2,r2,zero
 d02dd74:	1000031e 	bne	r2,zero,d02dd84 <sock_select+0xc8>
      {
         ready = 1;
 d02dd78:	00800044 	movi	r2,1
 d02dd7c:	e0bffb15 	stw	r2,-20(fp)
         break;
 d02dd80:	00004d06 	br	d02deb8 <sock_select+0x1fc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 d02dd84:	e0bffc17 	ldw	r2,-16(fp)
 d02dd88:	1080110b 	ldhu	r2,68(r2)
 d02dd8c:	10800214 	ori	r2,r2,8
 d02dd90:	1007883a 	mov	r3,r2
 d02dd94:	e0bffc17 	ldw	r2,-16(fp)
 d02dd98:	10c0110d 	sth	r3,68(r2)
      break;
 d02dd9c:	00004606 	br	d02deb8 <sock_select+0x1fc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 d02dda0:	e0bffc17 	ldw	r2,-16(fp)
 d02dda4:	10801317 	ldw	r2,76(r2)
 d02dda8:	1007883a 	mov	r3,r2
 d02ddac:	e0bffc17 	ldw	r2,-16(fp)
 d02ddb0:	10801217 	ldw	r2,72(r2)
 d02ddb4:	1885c83a 	sub	r2,r3,r2
 d02ddb8:	1004803a 	cmplt	r2,r2,zero
 d02ddbc:	10001b1e 	bne	r2,zero,d02de2c <sock_select+0x170>
 d02ddc0:	e0bffc17 	ldw	r2,-16(fp)
 d02ddc4:	10c01317 	ldw	r3,76(r2)
 d02ddc8:	e0bffc17 	ldw	r2,-16(fp)
 d02ddcc:	10801217 	ldw	r2,72(r2)
 d02ddd0:	18801626 	beq	r3,r2,d02de2c <sock_select+0x170>
 d02ddd4:	e0bffc17 	ldw	r2,-16(fp)
 d02ddd8:	1080088b 	ldhu	r2,34(r2)
 d02dddc:	10bfffcc 	andi	r2,r2,65535
 d02dde0:	1080008c 	andi	r2,r2,2
 d02dde4:	1004c03a 	cmpne	r2,r2,zero
 d02dde8:	10000d1e 	bne	r2,zero,d02de20 <sock_select+0x164>
 d02ddec:	e0bffc17 	ldw	r2,-16(fp)
 d02ddf0:	10800217 	ldw	r2,8(r2)
 d02ddf4:	1080010b 	ldhu	r2,4(r2)
 d02ddf8:	10bfffcc 	andi	r2,r2,65535
 d02ddfc:	1080010c 	andi	r2,r2,4
 d02de00:	1005003a 	cmpeq	r2,r2,zero
 d02de04:	1000061e 	bne	r2,zero,d02de20 <sock_select+0x164>
 d02de08:	e0bffc17 	ldw	r2,-16(fp)
 d02de0c:	1080088b 	ldhu	r2,34(r2)
 d02de10:	10bfffcc 	andi	r2,r2,65535
 d02de14:	1080040c 	andi	r2,r2,16
 d02de18:	1005003a 	cmpeq	r2,r2,zero
 d02de1c:	1000031e 	bne	r2,zero,d02de2c <sock_select+0x170>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 d02de20:	00800044 	movi	r2,1
 d02de24:	e0bffb15 	stw	r2,-20(fp)
         break;
 d02de28:	00002306 	br	d02deb8 <sock_select+0x1fc>
      }
      sbselqueue (&so->so_snd);
 d02de2c:	e0bffc17 	ldw	r2,-16(fp)
 d02de30:	11001204 	addi	r4,r2,72
 d02de34:	d02cd5c0 	call	d02cd5c <sbselqueue>
      break;
 d02de38:	00001f06 	br	d02deb8 <sock_select+0x1fc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 d02de3c:	e0bffc17 	ldw	r2,-16(fp)
 d02de40:	10801a17 	ldw	r2,104(r2)
 d02de44:	1004c03a 	cmpne	r2,r2,zero
 d02de48:	1000061e 	bne	r2,zero,d02de64 <sock_select+0x1a8>
 d02de4c:	e0bffc17 	ldw	r2,-16(fp)
 d02de50:	1080088b 	ldhu	r2,34(r2)
 d02de54:	10bfffcc 	andi	r2,r2,65535
 d02de58:	1080100c 	andi	r2,r2,64
 d02de5c:	1005003a 	cmpeq	r2,r2,zero
 d02de60:	1000031e 	bne	r2,zero,d02de70 <sock_select+0x1b4>
      {
         ready = 1;
 d02de64:	00800044 	movi	r2,1
 d02de68:	e0bffb15 	stw	r2,-20(fp)
         break;
 d02de6c:	00001206 	br	d02deb8 <sock_select+0x1fc>
      }
      if (so->so_error &&
 d02de70:	e0bffc17 	ldw	r2,-16(fp)
 d02de74:	10800617 	ldw	r2,24(r2)
 d02de78:	1005003a 	cmpeq	r2,r2,zero
 d02de7c:	10000b1e 	bne	r2,zero,d02deac <sock_select+0x1f0>
 d02de80:	e0bffc17 	ldw	r2,-16(fp)
 d02de84:	10800617 	ldw	r2,24(r2)
 d02de88:	10801de0 	cmpeqi	r2,r2,119
 d02de8c:	1000071e 	bne	r2,zero,d02deac <sock_select+0x1f0>
 d02de90:	e0bffc17 	ldw	r2,-16(fp)
 d02de94:	10800617 	ldw	r2,24(r2)
 d02de98:	108002e0 	cmpeqi	r2,r2,11
 d02de9c:	1000031e 	bne	r2,zero,d02deac <sock_select+0x1f0>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 d02dea0:	00800044 	movi	r2,1
 d02dea4:	e0bffb15 	stw	r2,-20(fp)
         break;
 d02dea8:	00000306 	br	d02deb8 <sock_select+0x1fc>
      }
      sbselqueue(&so->so_rcv);
 d02deac:	e0bffc17 	ldw	r2,-16(fp)
 d02deb0:	11000a04 	addi	r4,r2,40
 d02deb4:	d02cd5c0 	call	d02cd5c <sbselqueue>
      break;
   }

   return ready;
 d02deb8:	e0bffb17 	ldw	r2,-20(fp)
}
 d02debc:	e037883a 	mov	sp,fp
 d02dec0:	dfc00117 	ldw	ra,4(sp)
 d02dec4:	df000017 	ldw	fp,0(sp)
 d02dec8:	dec00204 	addi	sp,sp,8
 d02decc:	f800283a 	ret

0d02ded0 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 d02ded0:	defff804 	addi	sp,sp,-32
 d02ded4:	dfc00715 	stw	ra,28(sp)
 d02ded8:	df000615 	stw	fp,24(sp)
 d02dedc:	df000604 	addi	fp,sp,24
 d02dee0:	e13ffc15 	stw	r4,-16(fp)
 d02dee4:	e17ffd15 	stw	r5,-12(fp)
 d02dee8:	e1bffe15 	stw	r6,-8(fp)
 d02deec:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 d02def0:	e0bffc17 	ldw	r2,-16(fp)
 d02def4:	10800017 	ldw	r2,0(r2)
 d02def8:	e0bffb15 	stw	r2,-20(fp)
 d02defc:	00001f06 	br	d02df7c <in_pcbnotify+0xac>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 d02df00:	e0bffb17 	ldw	r2,-20(fp)
 d02df04:	10c00317 	ldw	r3,12(r2)
 d02df08:	e0bffd17 	ldw	r2,-12(fp)
 d02df0c:	10800017 	ldw	r2,0(r2)
 d02df10:	1880041e 	bne	r3,r2,d02df24 <in_pcbnotify+0x54>
 d02df14:	e0bffb17 	ldw	r2,-20(fp)
 d02df18:	10800817 	ldw	r2,32(r2)
 d02df1c:	1004c03a 	cmpne	r2,r2,zero
 d02df20:	1000041e 	bne	r2,zero,d02df34 <in_pcbnotify+0x64>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 d02df24:	e0bffb17 	ldw	r2,-20(fp)
 d02df28:	10800017 	ldw	r2,0(r2)
 d02df2c:	e0bffb15 	stw	r2,-20(fp)
         continue;
 d02df30:	00001206 	br	d02df7c <in_pcbnotify+0xac>
      }
      if (errnum) 
 d02df34:	e0bffe17 	ldw	r2,-8(fp)
 d02df38:	1005003a 	cmpeq	r2,r2,zero
 d02df3c:	1000041e 	bne	r2,zero,d02df50 <in_pcbnotify+0x80>
         inp->inp_socket->so_error = errnum;
 d02df40:	e0bffb17 	ldw	r2,-20(fp)
 d02df44:	10c00817 	ldw	r3,32(r2)
 d02df48:	e0bffe17 	ldw	r2,-8(fp)
 d02df4c:	18800615 	stw	r2,24(r3)
      oinp = inp;
 d02df50:	e0bffb17 	ldw	r2,-20(fp)
 d02df54:	e0bffa15 	stw	r2,-24(fp)
      inp = inp->inp_next;
 d02df58:	e0bffb17 	ldw	r2,-20(fp)
 d02df5c:	10800017 	ldw	r2,0(r2)
 d02df60:	e0bffb15 	stw	r2,-20(fp)
      if (notify)
 d02df64:	e0bfff17 	ldw	r2,-4(fp)
 d02df68:	1005003a 	cmpeq	r2,r2,zero
 d02df6c:	1000031e 	bne	r2,zero,d02df7c <in_pcbnotify+0xac>
         (*notify)(oinp);
 d02df70:	e0bfff17 	ldw	r2,-4(fp)
 d02df74:	e13ffa17 	ldw	r4,-24(fp)
 d02df78:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 d02df7c:	e0fffb17 	ldw	r3,-20(fp)
 d02df80:	e0bffc17 	ldw	r2,-16(fp)
 d02df84:	18bfde1e 	bne	r3,r2,d02df00 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 d02df88:	e037883a 	mov	sp,fp
 d02df8c:	dfc00117 	ldw	ra,4(sp)
 d02df90:	df000017 	ldw	fp,0(sp)
 d02df94:	dec00204 	addi	sp,sp,8
 d02df98:	f800283a 	ret

0d02df9c <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 d02df9c:	defffd04 	addi	sp,sp,-12
 d02dfa0:	dfc00215 	stw	ra,8(sp)
 d02dfa4:	df000115 	stw	fp,4(sp)
 d02dfa8:	df000104 	addi	fp,sp,4
 d02dfac:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 d02dfb0:	e0bfff17 	ldw	r2,-4(fp)
 d02dfb4:	10800817 	ldw	r2,32(r2)
 d02dfb8:	11000904 	addi	r4,r2,36
 d02dfbc:	d02147c0 	call	d02147c <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 d02dfc0:	e0bfff17 	ldw	r2,-4(fp)
 d02dfc4:	11000817 	ldw	r4,32(r2)
 d02dfc8:	e0bfff17 	ldw	r2,-4(fp)
 d02dfcc:	10800817 	ldw	r2,32(r2)
 d02dfd0:	11400a04 	addi	r5,r2,40
 d02dfd4:	d02cdfc0 	call	d02cdfc <sbwakeup>
   sowwakeup(inp->inp_socket);
 d02dfd8:	e0bfff17 	ldw	r2,-4(fp)
 d02dfdc:	11000817 	ldw	r4,32(r2)
 d02dfe0:	e0bfff17 	ldw	r2,-4(fp)
 d02dfe4:	10800817 	ldw	r2,32(r2)
 d02dfe8:	11401204 	addi	r5,r2,72
 d02dfec:	d02cdfc0 	call	d02cdfc <sbwakeup>
}
 d02dff0:	e037883a 	mov	sp,fp
 d02dff4:	dfc00117 	ldw	ra,4(sp)
 d02dff8:	df000017 	ldw	fp,0(sp)
 d02dffc:	dec00204 	addi	sp,sp,8
 d02e000:	f800283a 	ret

0d02e004 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 d02e004:	defffb04 	addi	sp,sp,-20
 d02e008:	dfc00415 	stw	ra,16(sp)
 d02e00c:	df000315 	stw	fp,12(sp)
 d02e010:	df000304 	addi	fp,sp,12
 d02e014:	e13ffe15 	stw	r4,-8(fp)
 d02e018:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 d02e01c:	e03ffd15 	stw	zero,-12(fp)
 d02e020:	00002a06 	br	d02e0cc <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 d02e024:	e0bffd17 	ldw	r2,-12(fp)
 d02e028:	e0ffff17 	ldw	r3,-4(fp)
 d02e02c:	1085883a 	add	r2,r2,r2
 d02e030:	1085883a 	add	r2,r2,r2
 d02e034:	10c5883a 	add	r2,r2,r3
 d02e038:	10800104 	addi	r2,r2,4
 d02e03c:	10c00017 	ldw	r3,0(r2)
 d02e040:	e0bffe17 	ldw	r2,-8(fp)
 d02e044:	18801e1e 	bne	r3,r2,d02e0c0 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 d02e048:	00001206 	br	d02e094 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 d02e04c:	e13ffd17 	ldw	r4,-12(fp)
 d02e050:	e0bffd17 	ldw	r2,-12(fp)
 d02e054:	10800044 	addi	r2,r2,1
 d02e058:	e0ffff17 	ldw	r3,-4(fp)
 d02e05c:	1085883a 	add	r2,r2,r2
 d02e060:	1085883a 	add	r2,r2,r2
 d02e064:	10c5883a 	add	r2,r2,r3
 d02e068:	10800104 	addi	r2,r2,4
 d02e06c:	11400017 	ldw	r5,0(r2)
 d02e070:	e0ffff17 	ldw	r3,-4(fp)
 d02e074:	2105883a 	add	r2,r4,r4
 d02e078:	1085883a 	add	r2,r2,r2
 d02e07c:	10c5883a 	add	r2,r2,r3
 d02e080:	10800104 	addi	r2,r2,4
 d02e084:	11400015 	stw	r5,0(r2)
            i++;
 d02e088:	e0bffd17 	ldw	r2,-12(fp)
 d02e08c:	10800044 	addi	r2,r2,1
 d02e090:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 d02e094:	e0bffd17 	ldw	r2,-12(fp)
 d02e098:	10c00044 	addi	r3,r2,1
 d02e09c:	e0bfff17 	ldw	r2,-4(fp)
 d02e0a0:	10800017 	ldw	r2,0(r2)
 d02e0a4:	18bfe936 	bltu	r3,r2,d02e04c <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 d02e0a8:	e0bfff17 	ldw	r2,-4(fp)
 d02e0ac:	10800017 	ldw	r2,0(r2)
 d02e0b0:	10ffffc4 	addi	r3,r2,-1
 d02e0b4:	e0bfff17 	ldw	r2,-4(fp)
 d02e0b8:	10c00015 	stw	r3,0(r2)
         return;
 d02e0bc:	00000806 	br	d02e0e0 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 d02e0c0:	e0bffd17 	ldw	r2,-12(fp)
 d02e0c4:	10800044 	addi	r2,r2,1
 d02e0c8:	e0bffd15 	stw	r2,-12(fp)
 d02e0cc:	e0bfff17 	ldw	r2,-4(fp)
 d02e0d0:	10c00017 	ldw	r3,0(r2)
 d02e0d4:	e0bffd17 	ldw	r2,-12(fp)
 d02e0d8:	10ffd236 	bltu	r2,r3,d02e024 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 d02e0dc:	d025a500 	call	d025a50 <dtrap>
#endif
}
 d02e0e0:	e037883a 	mov	sp,fp
 d02e0e4:	dfc00117 	ldw	ra,4(sp)
 d02e0e8:	df000017 	ldw	fp,0(sp)
 d02e0ec:	dec00204 	addi	sp,sp,8
 d02e0f0:	f800283a 	ret

0d02e0f4 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 d02e0f4:	defffc04 	addi	sp,sp,-16
 d02e0f8:	dfc00315 	stw	ra,12(sp)
 d02e0fc:	df000215 	stw	fp,8(sp)
 d02e100:	df000204 	addi	fp,sp,8
 d02e104:	e13ffe15 	stw	r4,-8(fp)
 d02e108:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 d02e10c:	e0bfff17 	ldw	r2,-4(fp)
 d02e110:	10800017 	ldw	r2,0(r2)
 d02e114:	10801028 	cmpgeui	r2,r2,64
 d02e118:	10000d1e 	bne	r2,zero,d02e150 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 d02e11c:	e0bfff17 	ldw	r2,-4(fp)
 d02e120:	10c00017 	ldw	r3,0(r2)
 d02e124:	e13fff17 	ldw	r4,-4(fp)
 d02e128:	18c5883a 	add	r2,r3,r3
 d02e12c:	1085883a 	add	r2,r2,r2
 d02e130:	1105883a 	add	r2,r2,r4
 d02e134:	11000104 	addi	r4,r2,4
 d02e138:	e0bffe17 	ldw	r2,-8(fp)
 d02e13c:	20800015 	stw	r2,0(r4)
 d02e140:	18c00044 	addi	r3,r3,1
 d02e144:	e0bfff17 	ldw	r2,-4(fp)
 d02e148:	10c00015 	stw	r3,0(r2)
 d02e14c:	00000106 	br	d02e154 <ifd_set+0x60>
#ifdef NPDEBUG
   else
      dtrap();
 d02e150:	d025a500 	call	d025a50 <dtrap>
#endif
}
 d02e154:	e037883a 	mov	sp,fp
 d02e158:	dfc00117 	ldw	ra,4(sp)
 d02e15c:	df000017 	ldw	fp,0(sp)
 d02e160:	dec00204 	addi	sp,sp,8
 d02e164:	f800283a 	ret

0d02e168 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 d02e168:	defffb04 	addi	sp,sp,-20
 d02e16c:	df000415 	stw	fp,16(sp)
 d02e170:	df000404 	addi	fp,sp,16
 d02e174:	e13ffd15 	stw	r4,-12(fp)
 d02e178:	e17ffe15 	stw	r5,-8(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 d02e17c:	e03ffc15 	stw	zero,-16(fp)
 d02e180:	00000f06 	br	d02e1c0 <ifd_isset+0x58>
   {
      if (set->fd_array[i] == sock)
 d02e184:	e0bffc17 	ldw	r2,-16(fp)
 d02e188:	e0fffe17 	ldw	r3,-8(fp)
 d02e18c:	1085883a 	add	r2,r2,r2
 d02e190:	1085883a 	add	r2,r2,r2
 d02e194:	10c5883a 	add	r2,r2,r3
 d02e198:	10800104 	addi	r2,r2,4
 d02e19c:	10c00017 	ldw	r3,0(r2)
 d02e1a0:	e0bffd17 	ldw	r2,-12(fp)
 d02e1a4:	1880031e 	bne	r3,r2,d02e1b4 <ifd_isset+0x4c>
         return TRUE;
 d02e1a8:	00800044 	movi	r2,1
 d02e1ac:	e0bfff15 	stw	r2,-4(fp)
 d02e1b0:	00000806 	br	d02e1d4 <ifd_isset+0x6c>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 d02e1b4:	e0bffc17 	ldw	r2,-16(fp)
 d02e1b8:	10800044 	addi	r2,r2,1
 d02e1bc:	e0bffc15 	stw	r2,-16(fp)
 d02e1c0:	e0bffe17 	ldw	r2,-8(fp)
 d02e1c4:	10c00017 	ldw	r3,0(r2)
 d02e1c8:	e0bffc17 	ldw	r2,-16(fp)
 d02e1cc:	10ffed36 	bltu	r2,r3,d02e184 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 d02e1d0:	e03fff15 	stw	zero,-4(fp)
 d02e1d4:	e0bfff17 	ldw	r2,-4(fp)
}
 d02e1d8:	e037883a 	mov	sp,fp
 d02e1dc:	df000017 	ldw	fp,0(sp)
 d02e1e0:	dec00104 	addi	sp,sp,4
 d02e1e4:	f800283a 	ret

0d02e1e8 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 d02e1e8:	defffb04 	addi	sp,sp,-20
 d02e1ec:	dfc00415 	stw	ra,16(sp)
 d02e1f0:	df000315 	stw	fp,12(sp)
 d02e1f4:	df000304 	addi	fp,sp,12
 d02e1f8:	e13ffd15 	stw	r4,-12(fp)
 d02e1fc:	e17ffe15 	stw	r5,-8(fp)
   if (i < set->fd_count)
 d02e200:	e0bffe17 	ldw	r2,-8(fp)
 d02e204:	10c00017 	ldw	r3,0(r2)
 d02e208:	e0bffd17 	ldw	r2,-12(fp)
 d02e20c:	10c0092e 	bgeu	r2,r3,d02e234 <ifd_get+0x4c>
      return set->fd_array[i];
 d02e210:	e0bffd17 	ldw	r2,-12(fp)
 d02e214:	e0fffe17 	ldw	r3,-8(fp)
 d02e218:	1085883a 	add	r2,r2,r2
 d02e21c:	1085883a 	add	r2,r2,r2
 d02e220:	10c5883a 	add	r2,r2,r3
 d02e224:	10800104 	addi	r2,r2,4
 d02e228:	10800017 	ldw	r2,0(r2)
 d02e22c:	e0bfff15 	stw	r2,-4(fp)
 d02e230:	00000306 	br	d02e240 <ifd_get+0x58>
   else
   {
#ifdef NPDEBUG
      dtrap();
 d02e234:	d025a500 	call	d025a50 <dtrap>
#endif
      return INVALID_SOCKET;
 d02e238:	00bfffc4 	movi	r2,-1
 d02e23c:	e0bfff15 	stw	r2,-4(fp)
 d02e240:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d02e244:	e037883a 	mov	sp,fp
 d02e248:	dfc00117 	ldw	ra,4(sp)
 d02e24c:	df000017 	ldw	fp,0(sp)
 d02e250:	dec00204 	addi	sp,sp,8
 d02e254:	f800283a 	ret

0d02e258 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 d02e258:	defff404 	addi	sp,sp,-48
 d02e25c:	dfc00b15 	stw	ra,44(sp)
 d02e260:	df000a15 	stw	fp,40(sp)
 d02e264:	df000a04 	addi	fp,sp,40
 d02e268:	e13ffc15 	stw	r4,-16(fp)
 d02e26c:	e17ffd15 	stw	r5,-12(fp)
 d02e270:	e1bffe15 	stw	r6,-8(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d02e274:	e0bffc17 	ldw	r2,-16(fp)
 d02e278:	10800d17 	ldw	r2,52(r2)
 d02e27c:	10800817 	ldw	r2,32(r2)
 d02e280:	e0bffa15 	stw	r2,-24(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 d02e284:	e0bffd17 	ldw	r2,-12(fp)
 d02e288:	1005003a 	cmpeq	r2,r2,zero
 d02e28c:	10009c1e 	bne	r2,zero,d02e500 <tcp_reass+0x2a8>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 d02e290:	e0bffc17 	ldw	r2,-16(fp)
 d02e294:	10800017 	ldw	r2,0(r2)
 d02e298:	e0bffb15 	stw	r2,-20(fp)
 d02e29c:	00000a06 	br	d02e2c8 <tcp_reass+0x70>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 d02e2a0:	e0bffb17 	ldw	r2,-20(fp)
 d02e2a4:	10c00617 	ldw	r3,24(r2)
 d02e2a8:	e0bffd17 	ldw	r2,-12(fp)
 d02e2ac:	10800617 	ldw	r2,24(r2)
 d02e2b0:	1885c83a 	sub	r2,r3,r2
 d02e2b4:	10800048 	cmpgei	r2,r2,1
 d02e2b8:	1000061e 	bne	r2,zero,d02e2d4 <tcp_reass+0x7c>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 d02e2bc:	e0bffb17 	ldw	r2,-20(fp)
 d02e2c0:	10800017 	ldw	r2,0(r2)
 d02e2c4:	e0bffb15 	stw	r2,-20(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 d02e2c8:	e0fffc17 	ldw	r3,-16(fp)
 d02e2cc:	e0bffb17 	ldw	r2,-20(fp)
 d02e2d0:	10fff31e 	bne	r2,r3,d02e2a0 <tcp_reass+0x48>
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 d02e2d4:	e0bffb17 	ldw	r2,-20(fp)
 d02e2d8:	10800117 	ldw	r2,4(r2)
 d02e2dc:	1007883a 	mov	r3,r2
 d02e2e0:	e0bffc17 	ldw	r2,-16(fp)
 d02e2e4:	18803c26 	beq	r3,r2,d02e3d8 <tcp_reass+0x180>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 d02e2e8:	e0bffb17 	ldw	r2,-20(fp)
 d02e2ec:	10800117 	ldw	r2,4(r2)
 d02e2f0:	e0bffb15 	stw	r2,-20(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 d02e2f4:	e0bffb17 	ldw	r2,-20(fp)
 d02e2f8:	10c00617 	ldw	r3,24(r2)
 d02e2fc:	e0bffb17 	ldw	r2,-20(fp)
 d02e300:	1080028b 	ldhu	r2,10(r2)
 d02e304:	10bfffcc 	andi	r2,r2,65535
 d02e308:	1887883a 	add	r3,r3,r2
 d02e30c:	e0bffd17 	ldw	r2,-12(fp)
 d02e310:	10800617 	ldw	r2,24(r2)
 d02e314:	1885c83a 	sub	r2,r3,r2
 d02e318:	e0bff715 	stw	r2,-36(fp)
      if (i > 0) 
 d02e31c:	e0bff717 	ldw	r2,-36(fp)
 d02e320:	10800050 	cmplti	r2,r2,1
 d02e324:	1000291e 	bne	r2,zero,d02e3cc <tcp_reass+0x174>
      {
         if (i >= (long)ti->ti_len) 
 d02e328:	e0bffd17 	ldw	r2,-12(fp)
 d02e32c:	1080028b 	ldhu	r2,10(r2)
 d02e330:	10ffffcc 	andi	r3,r2,65535
 d02e334:	e0bff717 	ldw	r2,-36(fp)
 d02e338:	10c01416 	blt	r2,r3,d02e38c <tcp_reass+0x134>
         {
            tcpstat.tcps_rcvduppack++;
 d02e33c:	008341b4 	movhi	r2,3334
 d02e340:	10848a04 	addi	r2,r2,4648
 d02e344:	10801f17 	ldw	r2,124(r2)
 d02e348:	10c00044 	addi	r3,r2,1
 d02e34c:	008341b4 	movhi	r2,3334
 d02e350:	10848a04 	addi	r2,r2,4648
 d02e354:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 d02e358:	008341b4 	movhi	r2,3334
 d02e35c:	10848a04 	addi	r2,r2,4648
 d02e360:	10c02017 	ldw	r3,128(r2)
 d02e364:	e0bffd17 	ldw	r2,-12(fp)
 d02e368:	1080028b 	ldhu	r2,10(r2)
 d02e36c:	10bfffcc 	andi	r2,r2,65535
 d02e370:	1887883a 	add	r3,r3,r2
 d02e374:	008341b4 	movhi	r2,3334
 d02e378:	10848a04 	addi	r2,r2,4648
 d02e37c:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 d02e380:	008025c4 	movi	r2,151
 d02e384:	d0a93015 	stw	r2,-23360(gp)
 d02e388:	0000ac06 	br	d02e63c <tcp_reass+0x3e4>
         }
         m_adj (ti_mbuf, (int)i);
 d02e38c:	e13ffe17 	ldw	r4,-8(fp)
 d02e390:	e17ff717 	ldw	r5,-36(fp)
 d02e394:	d026eb80 	call	d026eb8 <m_adj>
         ti->ti_len -= (short)i;
 d02e398:	e0bffd17 	ldw	r2,-12(fp)
 d02e39c:	10c0028b 	ldhu	r3,10(r2)
 d02e3a0:	e0bff717 	ldw	r2,-36(fp)
 d02e3a4:	1885c83a 	sub	r2,r3,r2
 d02e3a8:	1007883a 	mov	r3,r2
 d02e3ac:	e0bffd17 	ldw	r2,-12(fp)
 d02e3b0:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 d02e3b4:	e0bffd17 	ldw	r2,-12(fp)
 d02e3b8:	10c00617 	ldw	r3,24(r2)
 d02e3bc:	e0bff717 	ldw	r2,-36(fp)
 d02e3c0:	1887883a 	add	r3,r3,r2
 d02e3c4:	e0bffd17 	ldw	r2,-12(fp)
 d02e3c8:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 d02e3cc:	e0bffb17 	ldw	r2,-20(fp)
 d02e3d0:	10800017 	ldw	r2,0(r2)
 d02e3d4:	e0bffb15 	stw	r2,-20(fp)
   }
   tcpstat.tcps_rcvoopack++;
 d02e3d8:	008341b4 	movhi	r2,3334
 d02e3dc:	10848a04 	addi	r2,r2,4648
 d02e3e0:	10802317 	ldw	r2,140(r2)
 d02e3e4:	10c00044 	addi	r3,r2,1
 d02e3e8:	008341b4 	movhi	r2,3334
 d02e3ec:	10848a04 	addi	r2,r2,4648
 d02e3f0:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 d02e3f4:	008341b4 	movhi	r2,3334
 d02e3f8:	10848a04 	addi	r2,r2,4648
 d02e3fc:	10c02417 	ldw	r3,144(r2)
 d02e400:	e0bffd17 	ldw	r2,-12(fp)
 d02e404:	1080028b 	ldhu	r2,10(r2)
 d02e408:	10bfffcc 	andi	r2,r2,65535
 d02e40c:	1887883a 	add	r3,r3,r2
 d02e410:	008341b4 	movhi	r2,3334
 d02e414:	10848a04 	addi	r2,r2,4648
 d02e418:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 d02e41c:	00003106 	br	d02e4e4 <tcp_reass+0x28c>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 d02e420:	e0bffd17 	ldw	r2,-12(fp)
 d02e424:	10c00617 	ldw	r3,24(r2)
 d02e428:	e0bffd17 	ldw	r2,-12(fp)
 d02e42c:	1080028b 	ldhu	r2,10(r2)
 d02e430:	10bfffcc 	andi	r2,r2,65535
 d02e434:	1887883a 	add	r3,r3,r2
 d02e438:	e0bffb17 	ldw	r2,-20(fp)
 d02e43c:	10800617 	ldw	r2,24(r2)
 d02e440:	1885c83a 	sub	r2,r3,r2
 d02e444:	e0bff615 	stw	r2,-40(fp)
      if (i <= 0)
 d02e448:	e0bff617 	ldw	r2,-40(fp)
 d02e44c:	10800050 	cmplti	r2,r2,1
 d02e450:	1000271e 	bne	r2,zero,d02e4f0 <tcp_reass+0x298>
         break;
      if (i < (int)(q->ti_len))
 d02e454:	e0bffb17 	ldw	r2,-20(fp)
 d02e458:	1080028b 	ldhu	r2,10(r2)
 d02e45c:	10ffffcc 	andi	r3,r2,65535
 d02e460:	e0bff617 	ldw	r2,-40(fp)
 d02e464:	10c0130e 	bge	r2,r3,d02e4b4 <tcp_reass+0x25c>
      {
         q->ti_seq += i;
 d02e468:	e0bffb17 	ldw	r2,-20(fp)
 d02e46c:	10c00617 	ldw	r3,24(r2)
 d02e470:	e0bff617 	ldw	r2,-40(fp)
 d02e474:	1887883a 	add	r3,r3,r2
 d02e478:	e0bffb17 	ldw	r2,-20(fp)
 d02e47c:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 d02e480:	e0bffb17 	ldw	r2,-20(fp)
 d02e484:	10c0028b 	ldhu	r3,10(r2)
 d02e488:	e0bff617 	ldw	r2,-40(fp)
 d02e48c:	1885c83a 	sub	r2,r3,r2
 d02e490:	1007883a 	mov	r3,r2
 d02e494:	e0bffb17 	ldw	r2,-20(fp)
 d02e498:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 d02e49c:	e13ffb17 	ldw	r4,-20(fp)
 d02e4a0:	d0270e00 	call	d0270e0 <dtom>
 d02e4a4:	1009883a 	mov	r4,r2
 d02e4a8:	e17ff617 	ldw	r5,-40(fp)
 d02e4ac:	d026eb80 	call	d026eb8 <m_adj>
         break;
 d02e4b0:	00000f06 	br	d02e4f0 <tcp_reass+0x298>
      }
      q = (struct tcpiphdr *)q->ti_next;
 d02e4b4:	e0bffb17 	ldw	r2,-20(fp)
 d02e4b8:	10800017 	ldw	r2,0(r2)
 d02e4bc:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(q->ti_prev);
 d02e4c0:	e0bffb17 	ldw	r2,-20(fp)
 d02e4c4:	11000117 	ldw	r4,4(r2)
 d02e4c8:	d0270e00 	call	d0270e0 <dtom>
 d02e4cc:	e0bff915 	stw	r2,-28(fp)
      remque (q->ti_prev);
 d02e4d0:	e0bffb17 	ldw	r2,-20(fp)
 d02e4d4:	11000117 	ldw	r4,4(r2)
 d02e4d8:	d0271880 	call	d027188 <remque>
      m_freem (m);
 d02e4dc:	e13ff917 	ldw	r4,-28(fp)
 d02e4e0:	d026b500 	call	d026b50 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 d02e4e4:	e0fffc17 	ldw	r3,-16(fp)
 d02e4e8:	e0bffb17 	ldw	r2,-20(fp)
 d02e4ec:	10ffcc1e 	bne	r2,r3,d02e420 <tcp_reass+0x1c8>
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 d02e4f0:	e0bffb17 	ldw	r2,-20(fp)
 d02e4f4:	11400117 	ldw	r5,4(r2)
 d02e4f8:	e13ffd17 	ldw	r4,-12(fp)
 d02e4fc:	d0271f80 	call	d0271f8 <insque>
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 d02e500:	e0bffc17 	ldw	r2,-16(fp)
 d02e504:	10800217 	ldw	r2,8(r2)
 d02e508:	108000c8 	cmpgei	r2,r2,3
 d02e50c:	1000021e 	bne	r2,zero,d02e518 <tcp_reass+0x2c0>
      return (0);
 d02e510:	e03fff15 	stw	zero,-4(fp)
 d02e514:	00004c06 	br	d02e648 <tcp_reass+0x3f0>
   ti = tp->seg_next;
 d02e518:	e0bffc17 	ldw	r2,-16(fp)
 d02e51c:	10800017 	ldw	r2,0(r2)
 d02e520:	e0bffd15 	stw	r2,-12(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 d02e524:	e0fffc17 	ldw	r3,-16(fp)
 d02e528:	e0bffd17 	ldw	r2,-12(fp)
 d02e52c:	10c00526 	beq	r2,r3,d02e544 <tcp_reass+0x2ec>
 d02e530:	e0bffd17 	ldw	r2,-12(fp)
 d02e534:	10c00617 	ldw	r3,24(r2)
 d02e538:	e0bffc17 	ldw	r2,-16(fp)
 d02e53c:	10801617 	ldw	r2,88(r2)
 d02e540:	18800226 	beq	r3,r2,d02e54c <tcp_reass+0x2f4>
      return (0);
 d02e544:	e03fff15 	stw	zero,-4(fp)
 d02e548:	00003f06 	br	d02e648 <tcp_reass+0x3f0>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 d02e54c:	e0bffc17 	ldw	r2,-16(fp)
 d02e550:	10800217 	ldw	r2,8(r2)
 d02e554:	108000d8 	cmpnei	r2,r2,3
 d02e558:	1000071e 	bne	r2,zero,d02e578 <tcp_reass+0x320>
 d02e55c:	e0bffd17 	ldw	r2,-12(fp)
 d02e560:	1080028b 	ldhu	r2,10(r2)
 d02e564:	10bfffcc 	andi	r2,r2,65535
 d02e568:	1005003a 	cmpeq	r2,r2,zero
 d02e56c:	1000021e 	bne	r2,zero,d02e578 <tcp_reass+0x320>
      return (0);
 d02e570:	e03fff15 	stw	zero,-4(fp)
 d02e574:	00003406 	br	d02e648 <tcp_reass+0x3f0>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 d02e578:	e0bffc17 	ldw	r2,-16(fp)
 d02e57c:	10c01617 	ldw	r3,88(r2)
 d02e580:	e0bffd17 	ldw	r2,-12(fp)
 d02e584:	1080028b 	ldhu	r2,10(r2)
 d02e588:	10bfffcc 	andi	r2,r2,65535
 d02e58c:	1887883a 	add	r3,r3,r2
 d02e590:	e0bffc17 	ldw	r2,-16(fp)
 d02e594:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 d02e598:	e0bffd17 	ldw	r2,-12(fp)
 d02e59c:	10800843 	ldbu	r2,33(r2)
 d02e5a0:	10803fcc 	andi	r2,r2,255
 d02e5a4:	1080004c 	andi	r2,r2,1
 d02e5a8:	e0bff815 	stw	r2,-32(fp)
      remque(ti);
 d02e5ac:	e13ffd17 	ldw	r4,-12(fp)
 d02e5b0:	d0271880 	call	d027188 <remque>
      m = dtom(ti);
 d02e5b4:	e13ffd17 	ldw	r4,-12(fp)
 d02e5b8:	d0270e00 	call	d0270e0 <dtom>
 d02e5bc:	e0bff915 	stw	r2,-28(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 d02e5c0:	e0bffd17 	ldw	r2,-12(fp)
 d02e5c4:	10800017 	ldw	r2,0(r2)
 d02e5c8:	e0bffd15 	stw	r2,-12(fp)
      if (so->so_state & SS_CANTRCVMORE)
 d02e5cc:	e0bffa17 	ldw	r2,-24(fp)
 d02e5d0:	1080088b 	ldhu	r2,34(r2)
 d02e5d4:	10bfffcc 	andi	r2,r2,65535
 d02e5d8:	1080080c 	andi	r2,r2,32
 d02e5dc:	1005003a 	cmpeq	r2,r2,zero
 d02e5e0:	1000031e 	bne	r2,zero,d02e5f0 <tcp_reass+0x398>
         m_freem (m);
 d02e5e4:	e13ff917 	ldw	r4,-28(fp)
 d02e5e8:	d026b500 	call	d026b50 <m_freem>
 d02e5ec:	00000406 	br	d02e600 <tcp_reass+0x3a8>
      else
         sbappend (&so->so_rcv, m);
 d02e5f0:	e0bffa17 	ldw	r2,-24(fp)
 d02e5f4:	11000a04 	addi	r4,r2,40
 d02e5f8:	e17ff917 	ldw	r5,-28(fp)
 d02e5fc:	d02cfc00 	call	d02cfc0 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 d02e600:	e0fffc17 	ldw	r3,-16(fp)
 d02e604:	e0bffd17 	ldw	r2,-12(fp)
 d02e608:	10c00526 	beq	r2,r3,d02e620 <tcp_reass+0x3c8>
 d02e60c:	e0bffd17 	ldw	r2,-12(fp)
 d02e610:	10c00617 	ldw	r3,24(r2)
 d02e614:	e0bffc17 	ldw	r2,-16(fp)
 d02e618:	10801617 	ldw	r2,88(r2)
 d02e61c:	18bfd626 	beq	r3,r2,d02e578 <tcp_reass+0x320>
      sorwakeup(so);
 d02e620:	e0bffa17 	ldw	r2,-24(fp)
 d02e624:	11400a04 	addi	r5,r2,40
 d02e628:	e13ffa17 	ldw	r4,-24(fp)
 d02e62c:	d02cdfc0 	call	d02cdfc <sbwakeup>
   return (flags);
 d02e630:	e0bff817 	ldw	r2,-32(fp)
 d02e634:	e0bfff15 	stw	r2,-4(fp)
 d02e638:	00000306 	br	d02e648 <tcp_reass+0x3f0>
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 d02e63c:	e13ffe17 	ldw	r4,-8(fp)
 d02e640:	d026b500 	call	d026b50 <m_freem>
   return (0);
 d02e644:	e03fff15 	stw	zero,-4(fp)
 d02e648:	e0bfff17 	ldw	r2,-4(fp)
}
 d02e64c:	e037883a 	mov	sp,fp
 d02e650:	dfc00117 	ldw	ra,4(sp)
 d02e654:	df000017 	ldw	fp,0(sp)
 d02e658:	dec00204 	addi	sp,sp,8
 d02e65c:	f800283a 	ret

0d02e660 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 d02e660:	deffd004 	addi	sp,sp,-192
 d02e664:	dfc02f15 	stw	ra,188(sp)
 d02e668:	df002e15 	stw	fp,184(sp)
 d02e66c:	df002e04 	addi	fp,sp,184
 d02e670:	e13ff015 	stw	r4,-64(fp)
 d02e674:	e17ff115 	stw	r5,-60(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 d02e678:	e03feb15 	stw	zero,-84(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 d02e67c:	e03fe715 	stw	zero,-100(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 d02e680:	e03fe515 	stw	zero,-108(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 d02e684:	e03fe115 	stw	zero,-124(fp)
   int   dropsocket  =  0;
 d02e688:	e03fe015 	stw	zero,-128(fp)
   long  iss   =  0;
 d02e68c:	e03fdf15 	stw	zero,-132(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 d02e690:	008341b4 	movhi	r2,3334
 d02e694:	10848a04 	addi	r2,r2,4648
 d02e698:	10801917 	ldw	r2,100(r2)
 d02e69c:	10c00044 	addi	r3,r2,1
 d02e6a0:	008341b4 	movhi	r2,3334
 d02e6a4:	10848a04 	addi	r2,r2,4648
 d02e6a8:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 d02e6ac:	008341b4 	movhi	r2,3334
 d02e6b0:	10845c04 	addi	r2,r2,4464
 d02e6b4:	10800917 	ldw	r2,36(r2)
 d02e6b8:	10c00044 	addi	r3,r2,1
 d02e6bc:	008341b4 	movhi	r2,3334
 d02e6c0:	10845c04 	addi	r2,r2,4464
 d02e6c4:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 d02e6c8:	e0bff017 	ldw	r2,-64(fp)
 d02e6cc:	10800317 	ldw	r2,12(r2)
 d02e6d0:	e0bfee15 	stw	r2,-72(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 d02e6d4:	e0bfee17 	ldw	r2,-72(fp)
 d02e6d8:	10800003 	ldbu	r2,0(r2)
 d02e6dc:	10803fcc 	andi	r2,r2,255
 d02e6e0:	108011b0 	cmpltui	r2,r2,70
 d02e6e4:	1000061e 	bne	r2,zero,d02e700 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 d02e6e8:	e13fee17 	ldw	r4,-72(fp)
 d02e6ec:	e17ff017 	ldw	r5,-64(fp)
 d02e6f0:	d027bbc0 	call	d027bbc <np_stripoptions>
         pip = mtod(m, struct ip *);
 d02e6f4:	e0bff017 	ldw	r2,-64(fp)
 d02e6f8:	10800317 	ldw	r2,12(r2)
 d02e6fc:	e0bfee15 	stw	r2,-72(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 d02e700:	e0bff017 	ldw	r2,-64(fp)
 d02e704:	10800217 	ldw	r2,8(r2)
 d02e708:	10800a28 	cmpgeui	r2,r2,40
 d02e70c:	1000081e 	bne	r2,zero,d02e730 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 d02e710:	008341b4 	movhi	r2,3334
 d02e714:	10848a04 	addi	r2,r2,4648
 d02e718:	10801e17 	ldw	r2,120(r2)
 d02e71c:	10c00044 	addi	r3,r2,1
 d02e720:	008341b4 	movhi	r2,3334
 d02e724:	10848a04 	addi	r2,r2,4648
 d02e728:	10c01e15 	stw	r3,120(r2)
         return;
 d02e72c:	00091e06 	br	d030ba8 <tcp_input+0x2548>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 d02e730:	e0bfee17 	ldw	r2,-72(fp)
 d02e734:	1080008b 	ldhu	r2,2(r2)
 d02e738:	10bfffcc 	andi	r2,r2,65535
 d02e73c:	e0bfe915 	stw	r2,-92(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 d02e740:	e0bff017 	ldw	r2,-64(fp)
 d02e744:	10800317 	ldw	r2,12(r2)
 d02e748:	e0bfed15 	stw	r2,-76(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 d02e74c:	e0bff017 	ldw	r2,-64(fp)
 d02e750:	10800117 	ldw	r2,4(r2)
 d02e754:	10c00117 	ldw	r3,4(r2)
 d02e758:	e0bfed17 	ldw	r2,-76(fp)
 d02e75c:	10c0032e 	bgeu	r2,r3,d02e76c <tcp_input+0x10c>
      {
         panic("tcp_input");
 d02e760:	01034174 	movhi	r4,3333
 d02e764:	213ea604 	addi	r4,r4,-1384
 d02e768:	d02093c0 	call	d02093c <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 d02e76c:	e0bfed17 	ldw	r2,-76(fp)
 d02e770:	10800803 	ldbu	r2,32(r2)
 d02e774:	10803fcc 	andi	r2,r2,255
 d02e778:	1004d13a 	srli	r2,r2,4
 d02e77c:	10803fcc 	andi	r2,r2,255
 d02e780:	1085883a 	add	r2,r2,r2
 d02e784:	1085883a 	add	r2,r2,r2
 d02e788:	e0bfe815 	stw	r2,-96(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 d02e78c:	e0bfe817 	ldw	r2,-96(fp)
 d02e790:	10800530 	cmpltui	r2,r2,20
 d02e794:	1000031e 	bne	r2,zero,d02e7a4 <tcp_input+0x144>
 d02e798:	e0ffe817 	ldw	r3,-96(fp)
 d02e79c:	e0bfe917 	ldw	r2,-92(fp)
 d02e7a0:	10c0110e 	bge	r2,r3,d02e7e8 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 d02e7a4:	008341b4 	movhi	r2,3334
 d02e7a8:	10848a04 	addi	r2,r2,4648
 d02e7ac:	10801d17 	ldw	r2,116(r2)
 d02e7b0:	10c00044 	addi	r3,r2,1
 d02e7b4:	008341b4 	movhi	r2,3334
 d02e7b8:	10848a04 	addi	r2,r2,4648
 d02e7bc:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 d02e7c0:	008341b4 	movhi	r2,3334
 d02e7c4:	10845c04 	addi	r2,r2,4464
 d02e7c8:	10800d17 	ldw	r2,52(r2)
 d02e7cc:	10c00044 	addi	r3,r2,1
 d02e7d0:	008341b4 	movhi	r2,3334
 d02e7d4:	10845c04 	addi	r2,r2,4464
 d02e7d8:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 d02e7dc:	00805784 	movi	r2,350
 d02e7e0:	d0a93015 	stw	r2,-23360(gp)
 d02e7e4:	0008e406 	br	d030b78 <tcp_input+0x2518>
   }
   tlen -= (int)off;
 d02e7e8:	e0ffe917 	ldw	r3,-92(fp)
 d02e7ec:	e0bfe817 	ldw	r2,-96(fp)
 d02e7f0:	1885c83a 	sub	r2,r3,r2
 d02e7f4:	e0bfe915 	stw	r2,-92(fp)
   ti->ti_len = (u_short)tlen;
 d02e7f8:	e0bfe917 	ldw	r2,-92(fp)
 d02e7fc:	1007883a 	mov	r3,r2
 d02e800:	e0bfed17 	ldw	r2,-76(fp)
 d02e804:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 d02e808:	e0bfe817 	ldw	r2,-96(fp)
 d02e80c:	10800570 	cmpltui	r2,r2,21
 d02e810:	1000341e 	bne	r2,zero,d02e8e4 <tcp_input+0x284>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 d02e814:	e0bfe817 	ldw	r2,-96(fp)
 d02e818:	10bffb04 	addi	r2,r2,-20
 d02e81c:	e0bfdd15 	stw	r2,-140(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 d02e820:	01000044 	movi	r4,1
 d02e824:	e17fdd17 	ldw	r5,-140(fp)
 d02e828:	d0268740 	call	d026874 <m_getnbuf>
 d02e82c:	e0bfeb15 	stw	r2,-84(fp)
      if (om == 0)
 d02e830:	e0bfeb17 	ldw	r2,-84(fp)
 d02e834:	1004c03a 	cmpne	r2,r2,zero
 d02e838:	1000031e 	bne	r2,zero,d02e848 <tcp_input+0x1e8>
         GOTO_DROP;
 d02e83c:	00805a84 	movi	r2,362
 d02e840:	d0a93015 	stw	r2,-23360(gp)
 d02e844:	0008cc06 	br	d030b78 <tcp_input+0x2518>
      om->m_len = olen;       /* set mbuf length */
 d02e848:	e0ffdd17 	ldw	r3,-140(fp)
 d02e84c:	e0bfeb17 	ldw	r2,-84(fp)
 d02e850:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 d02e854:	e0bff017 	ldw	r2,-64(fp)
 d02e858:	10800117 	ldw	r2,4(r2)
 d02e85c:	1080080b 	ldhu	r2,32(r2)
 d02e860:	10ffffcc 	andi	r3,r2,65535
 d02e864:	00b76194 	movui	r2,56710
 d02e868:	1880051e 	bne	r3,r2,d02e880 <tcp_input+0x220>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 d02e86c:	e0bff017 	ldw	r2,-64(fp)
 d02e870:	10800317 	ldw	r2,12(r2)
 d02e874:	10800504 	addi	r2,r2,20
 d02e878:	e0bfdc15 	stw	r2,-144(fp)
 d02e87c:	00000406 	br	d02e890 <tcp_input+0x230>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 d02e880:	e0bff017 	ldw	r2,-64(fp)
 d02e884:	10800317 	ldw	r2,12(r2)
 d02e888:	10800a04 	addi	r2,r2,40
 d02e88c:	e0bfdc15 	stw	r2,-144(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 d02e890:	e0bfeb17 	ldw	r2,-84(fp)
 d02e894:	10c00317 	ldw	r3,12(r2)
 d02e898:	e1bfdd17 	ldw	r6,-140(fp)
 d02e89c:	e0bfdc17 	ldw	r2,-144(fp)
 d02e8a0:	1809883a 	mov	r4,r3
 d02e8a4:	100b883a 	mov	r5,r2
 d02e8a8:	d0026080 	call	d002608 <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 d02e8ac:	e0bff017 	ldw	r2,-64(fp)
 d02e8b0:	10c00317 	ldw	r3,12(r2)
 d02e8b4:	e0bfeb17 	ldw	r2,-84(fp)
 d02e8b8:	10800217 	ldw	r2,8(r2)
 d02e8bc:	1887883a 	add	r3,r3,r2
 d02e8c0:	e0bff017 	ldw	r2,-64(fp)
 d02e8c4:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 d02e8c8:	e0bff017 	ldw	r2,-64(fp)
 d02e8cc:	10c00217 	ldw	r3,8(r2)
 d02e8d0:	e0bfeb17 	ldw	r2,-84(fp)
 d02e8d4:	10800217 	ldw	r2,8(r2)
 d02e8d8:	1887c83a 	sub	r3,r3,r2
 d02e8dc:	e0bff017 	ldw	r2,-64(fp)
 d02e8e0:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 d02e8e4:	e0bfed17 	ldw	r2,-76(fp)
 d02e8e8:	10800843 	ldbu	r2,33(r2)
 d02e8ec:	10803fcc 	andi	r2,r2,255
 d02e8f0:	e0bfe615 	stw	r2,-104(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 d02e8f4:	e0bfed17 	ldw	r2,-76(fp)
 d02e8f8:	10800617 	ldw	r2,24(r2)
 d02e8fc:	1004d63a 	srli	r2,r2,24
 d02e900:	10c03fcc 	andi	r3,r2,255
 d02e904:	e0bfed17 	ldw	r2,-76(fp)
 d02e908:	10800617 	ldw	r2,24(r2)
 d02e90c:	1004d23a 	srli	r2,r2,8
 d02e910:	10bfc00c 	andi	r2,r2,65280
 d02e914:	1886b03a 	or	r3,r3,r2
 d02e918:	e0bfed17 	ldw	r2,-76(fp)
 d02e91c:	10800617 	ldw	r2,24(r2)
 d02e920:	10bfc00c 	andi	r2,r2,65280
 d02e924:	1004923a 	slli	r2,r2,8
 d02e928:	1886b03a 	or	r3,r3,r2
 d02e92c:	e0bfed17 	ldw	r2,-76(fp)
 d02e930:	10800617 	ldw	r2,24(r2)
 d02e934:	10803fcc 	andi	r2,r2,255
 d02e938:	1004963a 	slli	r2,r2,24
 d02e93c:	1886b03a 	or	r3,r3,r2
 d02e940:	e0bfed17 	ldw	r2,-76(fp)
 d02e944:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 d02e948:	e0bfed17 	ldw	r2,-76(fp)
 d02e94c:	10800717 	ldw	r2,28(r2)
 d02e950:	1004d63a 	srli	r2,r2,24
 d02e954:	10c03fcc 	andi	r3,r2,255
 d02e958:	e0bfed17 	ldw	r2,-76(fp)
 d02e95c:	10800717 	ldw	r2,28(r2)
 d02e960:	1004d23a 	srli	r2,r2,8
 d02e964:	10bfc00c 	andi	r2,r2,65280
 d02e968:	1886b03a 	or	r3,r3,r2
 d02e96c:	e0bfed17 	ldw	r2,-76(fp)
 d02e970:	10800717 	ldw	r2,28(r2)
 d02e974:	10bfc00c 	andi	r2,r2,65280
 d02e978:	1004923a 	slli	r2,r2,8
 d02e97c:	1886b03a 	or	r3,r3,r2
 d02e980:	e0bfed17 	ldw	r2,-76(fp)
 d02e984:	10800717 	ldw	r2,28(r2)
 d02e988:	10803fcc 	andi	r2,r2,255
 d02e98c:	1004963a 	slli	r2,r2,24
 d02e990:	1886b03a 	or	r3,r3,r2
 d02e994:	e0bfed17 	ldw	r2,-76(fp)
 d02e998:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 d02e99c:	e0bfed17 	ldw	r2,-76(fp)
 d02e9a0:	1080098b 	ldhu	r2,38(r2)
 d02e9a4:	10bfffcc 	andi	r2,r2,65535
 d02e9a8:	1004d23a 	srli	r2,r2,8
 d02e9ac:	10803fcc 	andi	r2,r2,255
 d02e9b0:	1009883a 	mov	r4,r2
 d02e9b4:	e0bfed17 	ldw	r2,-76(fp)
 d02e9b8:	1080098b 	ldhu	r2,38(r2)
 d02e9bc:	10bfffcc 	andi	r2,r2,65535
 d02e9c0:	1004923a 	slli	r2,r2,8
 d02e9c4:	1007883a 	mov	r3,r2
 d02e9c8:	00bfc004 	movi	r2,-256
 d02e9cc:	1884703a 	and	r2,r3,r2
 d02e9d0:	2084b03a 	or	r2,r4,r2
 d02e9d4:	1007883a 	mov	r3,r2
 d02e9d8:	e0bfed17 	ldw	r2,-76(fp)
 d02e9dc:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 d02e9e0:	e0bff017 	ldw	r2,-64(fp)
 d02e9e4:	10800117 	ldw	r2,4(r2)
 d02e9e8:	1080080b 	ldhu	r2,32(r2)
 d02e9ec:	10bfffcc 	andi	r2,r2,65535
 d02e9f0:	10800220 	cmpeqi	r2,r2,8
 d02e9f4:	1000011e 	bne	r2,zero,d02e9fc <tcp_input+0x39c>
 d02e9f8:	00001f06 	br	d02ea78 <tcp_input+0x418>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 d02e9fc:	e0bff017 	ldw	r2,-64(fp)
 d02ea00:	10800317 	ldw	r2,12(r2)
 d02ea04:	10c00a04 	addi	r3,r2,40
 d02ea08:	e0bff017 	ldw	r2,-64(fp)
 d02ea0c:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 d02ea10:	e0bff017 	ldw	r2,-64(fp)
 d02ea14:	10800217 	ldw	r2,8(r2)
 d02ea18:	10fff604 	addi	r3,r2,-40
 d02ea1c:	e0bff017 	ldw	r2,-64(fp)
 d02ea20:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 d02ea24:	e0bfed17 	ldw	r2,-76(fp)
 d02ea28:	11400317 	ldw	r5,12(r2)
 d02ea2c:	e0bfed17 	ldw	r2,-76(fp)
 d02ea30:	1080050b 	ldhu	r2,20(r2)
 d02ea34:	11bfffcc 	andi	r6,r2,65535
 d02ea38:	e0bfed17 	ldw	r2,-76(fp)
 d02ea3c:	11c00417 	ldw	r7,16(r2)
 d02ea40:	e0bfed17 	ldw	r2,-76(fp)
 d02ea44:	1080058b 	ldhu	r2,22(r2)
 d02ea48:	10bfffcc 	andi	r2,r2,65535
 d02ea4c:	d8800015 	stw	r2,0(sp)
 d02ea50:	00800044 	movi	r2,1
 d02ea54:	d8800115 	stw	r2,4(sp)
 d02ea58:	010341b4 	movhi	r4,3334
 d02ea5c:	21047f04 	addi	r4,r4,4604
 d02ea60:	d0487d40 	call	d0487d4 <in_pcblookup>
 d02ea64:	e0bfec15 	stw	r2,-80(fp)
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 d02ea68:	e0bfec17 	ldw	r2,-80(fp)
 d02ea6c:	1005003a 	cmpeq	r2,r2,zero
 d02ea70:	1000031e 	bne	r2,zero,d02ea80 <tcp_input+0x420>
 d02ea74:	00000506 	br	d02ea8c <tcp_input+0x42c>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 d02ea78:	d025a500 	call	d025a50 <dtrap>
      return;
 d02ea7c:	00084a06 	br	d030ba8 <tcp_input+0x2548>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 d02ea80:	00806b04 	movi	r2,428
 d02ea84:	d0a93015 	stw	r2,-23360(gp)
 d02ea88:	0007f706 	br	d030a68 <tcp_input+0x2408>
   tp = intotcpcb (inp);
 d02ea8c:	e0bfec17 	ldw	r2,-80(fp)
 d02ea90:	10800917 	ldw	r2,36(r2)
 d02ea94:	e0bfe715 	stw	r2,-100(fp)
   if (tp == 0)
 d02ea98:	e0bfe717 	ldw	r2,-100(fp)
 d02ea9c:	1004c03a 	cmpne	r2,r2,zero
 d02eaa0:	1000031e 	bne	r2,zero,d02eab0 <tcp_input+0x450>
      GOTO_DROPWITHRESET;
 d02eaa4:	00806bc4 	movi	r2,431
 d02eaa8:	d0a93015 	stw	r2,-23360(gp)
 d02eaac:	0007ee06 	br	d030a68 <tcp_input+0x2408>
   if (tp->t_state == TCPS_CLOSED)
 d02eab0:	e0bfe717 	ldw	r2,-100(fp)
 d02eab4:	10800217 	ldw	r2,8(r2)
 d02eab8:	1004c03a 	cmpne	r2,r2,zero
 d02eabc:	1000031e 	bne	r2,zero,d02eacc <tcp_input+0x46c>
      GOTO_DROP;
 d02eac0:	00806c44 	movi	r2,433
 d02eac4:	d0a93015 	stw	r2,-23360(gp)
 d02eac8:	00082b06 	br	d030b78 <tcp_input+0x2518>
   so = inp->inp_socket;
 d02eacc:	e0bfec17 	ldw	r2,-80(fp)
 d02ead0:	10800817 	ldw	r2,32(r2)
 d02ead4:	e0bfe515 	stw	r2,-108(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 d02ead8:	e0bfed17 	ldw	r2,-76(fp)
 d02eadc:	1080088b 	ldhu	r2,34(r2)
 d02eae0:	10bfffcc 	andi	r2,r2,65535
 d02eae4:	1004d23a 	srli	r2,r2,8
 d02eae8:	10bfffcc 	andi	r2,r2,65535
 d02eaec:	10c03fcc 	andi	r3,r2,255
 d02eaf0:	e0bfed17 	ldw	r2,-76(fp)
 d02eaf4:	1080088b 	ldhu	r2,34(r2)
 d02eaf8:	10bfffcc 	andi	r2,r2,65535
 d02eafc:	1004923a 	slli	r2,r2,8
 d02eb00:	10bfc00c 	andi	r2,r2,65280
 d02eb04:	1884b03a 	or	r2,r3,r2
 d02eb08:	e0bfde15 	stw	r2,-136(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 d02eb0c:	e0bfe517 	ldw	r2,-108(fp)
 d02eb10:	10800417 	ldw	r2,16(r2)
 d02eb14:	1080008c 	andi	r2,r2,2
 d02eb18:	1005003a 	cmpeq	r2,r2,zero
 d02eb1c:	10002d1e 	bne	r2,zero,d02ebd4 <tcp_input+0x574>
   {
      so = sonewconn(so);
 d02eb20:	e13fe517 	ldw	r4,-108(fp)
 d02eb24:	d02c8d40 	call	d02c8d4 <sonewconn>
 d02eb28:	e0bfe515 	stw	r2,-108(fp)
      if (so == 0)
 d02eb2c:	e0bfe517 	ldw	r2,-108(fp)
 d02eb30:	1004c03a 	cmpne	r2,r2,zero
 d02eb34:	1000031e 	bne	r2,zero,d02eb44 <tcp_input+0x4e4>
         GOTO_DROP;
 d02eb38:	00807344 	movi	r2,461
 d02eb3c:	d0a93015 	stw	r2,-23360(gp)
 d02eb40:	00080d06 	br	d030b78 <tcp_input+0x2518>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 d02eb44:	e0bfe017 	ldw	r2,-128(fp)
 d02eb48:	10800044 	addi	r2,r2,1
 d02eb4c:	e0bfe015 	stw	r2,-128(fp)

      inp = (struct inpcb *)so->so_pcb;
 d02eb50:	e0bfe517 	ldw	r2,-108(fp)
 d02eb54:	10800117 	ldw	r2,4(r2)
 d02eb58:	e0bfec15 	stw	r2,-80(fp)
      inp->ifp = ifp;      /* save iface to peer */
 d02eb5c:	e0ffec17 	ldw	r3,-80(fp)
 d02eb60:	e0bff117 	ldw	r2,-60(fp)
 d02eb64:	18800a15 	stw	r2,40(r3)

      switch(so->so_domain)
 d02eb68:	e0bfe517 	ldw	r2,-108(fp)
 d02eb6c:	10800517 	ldw	r2,20(r2)
 d02eb70:	108000a0 	cmpeqi	r2,r2,2
 d02eb74:	1000011e 	bne	r2,zero,d02eb7c <tcp_input+0x51c>
 d02eb78:	00000c06 	br	d02ebac <tcp_input+0x54c>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 d02eb7c:	e0bfed17 	ldw	r2,-76(fp)
 d02eb80:	10c00417 	ldw	r3,16(r2)
 d02eb84:	e0bfec17 	ldw	r2,-80(fp)
 d02eb88:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 d02eb8c:	e0bff117 	ldw	r2,-60(fp)
 d02eb90:	10c00917 	ldw	r3,36(r2)
 d02eb94:	e0bff117 	ldw	r2,-60(fp)
 d02eb98:	10800817 	ldw	r2,32(r2)
 d02eb9c:	1885c83a 	sub	r2,r3,r2
 d02eba0:	10fff604 	addi	r3,r2,-40
 d02eba4:	e0bfec17 	ldw	r2,-80(fp)
 d02eba8:	10c00615 	stw	r3,24(r2)
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 d02ebac:	e0bfed17 	ldw	r2,-76(fp)
 d02ebb0:	10c0058b 	ldhu	r3,22(r2)
 d02ebb4:	e0bfec17 	ldw	r2,-80(fp)
 d02ebb8:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 d02ebbc:	e0bfec17 	ldw	r2,-80(fp)
 d02ebc0:	10800917 	ldw	r2,36(r2)
 d02ebc4:	e0bfe715 	stw	r2,-100(fp)
      tp->t_state = TCPS_LISTEN;
 d02ebc8:	e0ffe717 	ldw	r3,-100(fp)
 d02ebcc:	00800044 	movi	r2,1
 d02ebd0:	18800215 	stw	r2,8(r3)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 d02ebd4:	e0bfe717 	ldw	r2,-100(fp)
 d02ebd8:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 d02ebdc:	00834174 	movhi	r2,3333
 d02ebe0:	10925c04 	addi	r2,r2,18800
 d02ebe4:	10c00017 	ldw	r3,0(r2)
 d02ebe8:	e0bfe717 	ldw	r2,-100(fp)
 d02ebec:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 d02ebf0:	e0bfeb17 	ldw	r2,-84(fp)
 d02ebf4:	1005003a 	cmpeq	r2,r2,zero
 d02ebf8:	1000091e 	bne	r2,zero,d02ec20 <tcp_input+0x5c0>
 d02ebfc:	e0bfe717 	ldw	r2,-100(fp)
 d02ec00:	10800217 	ldw	r2,8(r2)
 d02ec04:	10800060 	cmpeqi	r2,r2,1
 d02ec08:	1000051e 	bne	r2,zero,d02ec20 <tcp_input+0x5c0>
   {
      tcp_dooptions(tp, om, ti);
 d02ec0c:	e13fe717 	ldw	r4,-100(fp)
 d02ec10:	e17feb17 	ldw	r5,-84(fp)
 d02ec14:	e1bfed17 	ldw	r6,-76(fp)
 d02ec18:	d030bbc0 	call	d030bbc <tcp_dooptions>
      om = 0;
 d02ec1c:	e03feb15 	stw	zero,-84(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 d02ec20:	e0bfed17 	ldw	r2,-76(fp)
 d02ec24:	10c00717 	ldw	r3,28(r2)
 d02ec28:	e0bfe717 	ldw	r2,-100(fp)
 d02ec2c:	10800e17 	ldw	r2,56(r2)
 d02ec30:	1885c83a 	sub	r2,r3,r2
 d02ec34:	e0bfe315 	stw	r2,-116(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 d02ec38:	e0bfe517 	ldw	r2,-108(fp)
 d02ec3c:	10800b17 	ldw	r2,44(r2)
 d02ec40:	1007883a 	mov	r3,r2
 d02ec44:	e0bfe517 	ldw	r2,-108(fp)
 d02ec48:	10800a17 	ldw	r2,40(r2)
 d02ec4c:	1885c83a 	sub	r2,r3,r2
 d02ec50:	1004803a 	cmplt	r2,r2,zero
 d02ec54:	1000071e 	bne	r2,zero,d02ec74 <tcp_input+0x614>
 d02ec58:	e0bfe517 	ldw	r2,-108(fp)
 d02ec5c:	10c00b17 	ldw	r3,44(r2)
 d02ec60:	e0bfe517 	ldw	r2,-108(fp)
 d02ec64:	10800a17 	ldw	r2,40(r2)
 d02ec68:	1885c83a 	sub	r2,r3,r2
 d02ec6c:	e0bffd15 	stw	r2,-12(fp)
 d02ec70:	00000106 	br	d02ec78 <tcp_input+0x618>
 d02ec74:	e03ffd15 	stw	zero,-12(fp)
 d02ec78:	e0bffd17 	ldw	r2,-12(fp)
 d02ec7c:	e0bfdb15 	stw	r2,-148(fp)
      if (win < 0)
 d02ec80:	e0bfdb17 	ldw	r2,-148(fp)
 d02ec84:	1004403a 	cmpge	r2,r2,zero
 d02ec88:	1000011e 	bne	r2,zero,d02ec90 <tcp_input+0x630>
         win = 0;
 d02ec8c:	e03fdb15 	stw	zero,-148(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 d02ec90:	e0bfe717 	ldw	r2,-100(fp)
 d02ec94:	10c01917 	ldw	r3,100(r2)
 d02ec98:	e0bfe717 	ldw	r2,-100(fp)
 d02ec9c:	10801617 	ldw	r2,88(r2)
 d02eca0:	1885c83a 	sub	r2,r3,r2
 d02eca4:	e0ffdb17 	ldw	r3,-148(fp)
 d02eca8:	e0fffc15 	stw	r3,-16(fp)
 d02ecac:	e0bffb15 	stw	r2,-20(fp)
 d02ecb0:	e13ffb17 	ldw	r4,-20(fp)
 d02ecb4:	e0bffc17 	ldw	r2,-16(fp)
 d02ecb8:	2080022e 	bgeu	r4,r2,d02ecc4 <tcp_input+0x664>
 d02ecbc:	e0fffc17 	ldw	r3,-16(fp)
 d02ecc0:	e0fffb15 	stw	r3,-20(fp)
 d02ecc4:	e0bfe717 	ldw	r2,-100(fp)
 d02ecc8:	e13ffb17 	ldw	r4,-20(fp)
 d02eccc:	11001515 	stw	r4,84(r2)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 d02ecd0:	e0bfe717 	ldw	r2,-100(fp)
 d02ecd4:	10800217 	ldw	r2,8(r2)
 d02ecd8:	10800118 	cmpnei	r2,r2,4
 d02ecdc:	10010f1e 	bne	r2,zero,d02f11c <tcp_input+0xabc>
 d02ece0:	e0bfe617 	ldw	r2,-104(fp)
 d02ece4:	10800dcc 	andi	r2,r2,55
 d02ece8:	10800418 	cmpnei	r2,r2,16
 d02ecec:	10010b1e 	bne	r2,zero,d02f11c <tcp_input+0xabc>
 d02ecf0:	e0bfed17 	ldw	r2,-76(fp)
 d02ecf4:	10c00617 	ldw	r3,24(r2)
 d02ecf8:	e0bfe717 	ldw	r2,-100(fp)
 d02ecfc:	10801617 	ldw	r2,88(r2)
 d02ed00:	1881061e 	bne	r3,r2,d02f11c <tcp_input+0xabc>
 d02ed04:	e0bfde17 	ldw	r2,-136(fp)
 d02ed08:	1005003a 	cmpeq	r2,r2,zero
 d02ed0c:	1001031e 	bne	r2,zero,d02f11c <tcp_input+0xabc>
 d02ed10:	e0bfe717 	ldw	r2,-100(fp)
 d02ed14:	10c01417 	ldw	r3,80(r2)
 d02ed18:	e0bfde17 	ldw	r2,-136(fp)
 d02ed1c:	1880ff1e 	bne	r3,r2,d02f11c <tcp_input+0xabc>
 d02ed20:	e0bfe717 	ldw	r2,-100(fp)
 d02ed24:	10c00f17 	ldw	r3,60(r2)
 d02ed28:	e0bfe717 	ldw	r2,-100(fp)
 d02ed2c:	10801a17 	ldw	r2,104(r2)
 d02ed30:	1880fa1e 	bne	r3,r2,d02f11c <tcp_input+0xabc>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 d02ed34:	e0bfed17 	ldw	r2,-76(fp)
 d02ed38:	1080028b 	ldhu	r2,10(r2)
 d02ed3c:	10bfffcc 	andi	r2,r2,65535
 d02ed40:	1004c03a 	cmpne	r2,r2,zero
 d02ed44:	1000651e 	bne	r2,zero,d02eedc <tcp_input+0x87c>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 d02ed48:	e0bfed17 	ldw	r2,-76(fp)
 d02ed4c:	10c00717 	ldw	r3,28(r2)
 d02ed50:	e0bfe717 	ldw	r2,-100(fp)
 d02ed54:	10800e17 	ldw	r2,56(r2)
 d02ed58:	1885c83a 	sub	r2,r3,r2
 d02ed5c:	10800050 	cmplti	r2,r2,1
 d02ed60:	1000ee1e 	bne	r2,zero,d02f11c <tcp_input+0xabc>
 d02ed64:	e0bfed17 	ldw	r2,-76(fp)
 d02ed68:	10c00717 	ldw	r3,28(r2)
 d02ed6c:	e0bfe717 	ldw	r2,-100(fp)
 d02ed70:	10801a17 	ldw	r2,104(r2)
 d02ed74:	1885c83a 	sub	r2,r3,r2
 d02ed78:	10800048 	cmpgei	r2,r2,1
 d02ed7c:	1000e71e 	bne	r2,zero,d02f11c <tcp_input+0xabc>
 d02ed80:	e0bfe717 	ldw	r2,-100(fp)
 d02ed84:	10c01b17 	ldw	r3,108(r2)
 d02ed88:	e0bfe717 	ldw	r2,-100(fp)
 d02ed8c:	10801417 	ldw	r2,80(r2)
 d02ed90:	1880e236 	bltu	r3,r2,d02f11c <tcp_input+0xabc>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 d02ed94:	008341b4 	movhi	r2,3334
 d02ed98:	10848a04 	addi	r2,r2,4648
 d02ed9c:	10803517 	ldw	r2,212(r2)
 d02eda0:	10c00044 	addi	r3,r2,1
 d02eda4:	008341b4 	movhi	r2,3334
 d02eda8:	10848a04 	addi	r2,r2,4648
 d02edac:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 d02edb0:	e0bfe717 	ldw	r2,-100(fp)
 d02edb4:	10801e17 	ldw	r2,120(r2)
 d02edb8:	1005003a 	cmpeq	r2,r2,zero
 d02edbc:	1000091e 	bne	r2,zero,d02ede4 <tcp_input+0x784>
 d02edc0:	e0bfed17 	ldw	r2,-76(fp)
 d02edc4:	10c00717 	ldw	r3,28(r2)
 d02edc8:	e0bfe717 	ldw	r2,-100(fp)
 d02edcc:	10801f17 	ldw	r2,124(r2)
 d02edd0:	1885c83a 	sub	r2,r3,r2
 d02edd4:	10800050 	cmplti	r2,r2,1
 d02edd8:	1000021e 	bne	r2,zero,d02ede4 <tcp_input+0x784>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 d02eddc:	e13fe717 	ldw	r4,-100(fp)
 d02ede0:	d030e780 	call	d030e78 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 d02ede4:	008341b4 	movhi	r2,3334
 d02ede8:	10848a04 	addi	r2,r2,4648
 d02edec:	10802b17 	ldw	r2,172(r2)
 d02edf0:	10c00044 	addi	r3,r2,1
 d02edf4:	008341b4 	movhi	r2,3334
 d02edf8:	10848a04 	addi	r2,r2,4648
 d02edfc:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 d02ee00:	008341b4 	movhi	r2,3334
 d02ee04:	10848a04 	addi	r2,r2,4648
 d02ee08:	10c02c17 	ldw	r3,176(r2)
 d02ee0c:	e0bfe317 	ldw	r2,-116(fp)
 d02ee10:	1887883a 	add	r3,r3,r2
 d02ee14:	008341b4 	movhi	r2,3334
 d02ee18:	10848a04 	addi	r2,r2,4648
 d02ee1c:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 d02ee20:	e0bfe517 	ldw	r2,-108(fp)
 d02ee24:	11001204 	addi	r4,r2,72
 d02ee28:	e17fe317 	ldw	r5,-116(fp)
 d02ee2c:	d02d5c80 	call	d02d5c8 <sbdrop>
            tp->snd_una = ti->ti_ack;
 d02ee30:	e0bfed17 	ldw	r2,-76(fp)
 d02ee34:	10c00717 	ldw	r3,28(r2)
 d02ee38:	e0bfe717 	ldw	r2,-100(fp)
 d02ee3c:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 d02ee40:	e13ff017 	ldw	r4,-64(fp)
 d02ee44:	d026b500 	call	d026b50 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 d02ee48:	e0bfe717 	ldw	r2,-100(fp)
 d02ee4c:	10c00e17 	ldw	r3,56(r2)
 d02ee50:	e0bfe717 	ldw	r2,-100(fp)
 d02ee54:	10801a17 	ldw	r2,104(r2)
 d02ee58:	1880031e 	bne	r3,r2,d02ee68 <tcp_input+0x808>
               tp->t_timer[TCPT_REXMT] = 0;
 d02ee5c:	e0bfe717 	ldw	r2,-100(fp)
 d02ee60:	10000315 	stw	zero,12(r2)
 d02ee64:	00000806 	br	d02ee88 <tcp_input+0x828>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 d02ee68:	e0bfe717 	ldw	r2,-100(fp)
 d02ee6c:	10800417 	ldw	r2,16(r2)
 d02ee70:	1004c03a 	cmpne	r2,r2,zero
 d02ee74:	1000041e 	bne	r2,zero,d02ee88 <tcp_input+0x828>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d02ee78:	e0bfe717 	ldw	r2,-100(fp)
 d02ee7c:	10c00817 	ldw	r3,32(r2)
 d02ee80:	e0bfe717 	ldw	r2,-100(fp)
 d02ee84:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 d02ee88:	e0bfe517 	ldw	r2,-108(fp)
 d02ee8c:	1080190b 	ldhu	r2,100(r2)
 d02ee90:	10bfffcc 	andi	r2,r2,65535
 d02ee94:	1080030c 	andi	r2,r2,12
 d02ee98:	1005003a 	cmpeq	r2,r2,zero
 d02ee9c:	1000041e 	bne	r2,zero,d02eeb0 <tcp_input+0x850>
               sowwakeup(so);
 d02eea0:	e0bfe517 	ldw	r2,-108(fp)
 d02eea4:	11401204 	addi	r5,r2,72
 d02eea8:	e13fe517 	ldw	r4,-108(fp)
 d02eeac:	d02cdfc0 	call	d02cdfc <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 d02eeb0:	e0bfe517 	ldw	r2,-108(fp)
 d02eeb4:	11001217 	ldw	r4,72(r2)
 d02eeb8:	e0bfe717 	ldw	r2,-100(fp)
 d02eebc:	10c00f17 	ldw	r3,60(r2)
 d02eec0:	e0bfe717 	ldw	r2,-100(fp)
 d02eec4:	10800e17 	ldw	r2,56(r2)
 d02eec8:	1885c83a 	sub	r2,r3,r2
 d02eecc:	1107362e 	bgeu	r2,r4,d030ba8 <tcp_input+0x2548>
               (void) tcp_output(tp);
 d02eed0:	e13fe717 	ldw	r4,-100(fp)
 d02eed4:	d0312480 	call	d031248 <tcp_output>
            return;
 d02eed8:	00073306 	br	d030ba8 <tcp_input+0x2548>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 d02eedc:	e0bfed17 	ldw	r2,-76(fp)
 d02eee0:	10c00717 	ldw	r3,28(r2)
 d02eee4:	e0bfe717 	ldw	r2,-100(fp)
 d02eee8:	10800e17 	ldw	r2,56(r2)
 d02eeec:	18808b1e 	bne	r3,r2,d02f11c <tcp_input+0xabc>
 d02eef0:	e0bfe717 	ldw	r2,-100(fp)
 d02eef4:	10c00017 	ldw	r3,0(r2)
 d02eef8:	e0bfe717 	ldw	r2,-100(fp)
 d02eefc:	1880871e 	bne	r3,r2,d02f11c <tcp_input+0xabc>
 d02ef00:	e0bfed17 	ldw	r2,-76(fp)
 d02ef04:	1080028b 	ldhu	r2,10(r2)
 d02ef08:	10bfffcc 	andi	r2,r2,65535
 d02ef0c:	e0bffa15 	stw	r2,-24(fp)
 d02ef10:	e0bfe517 	ldw	r2,-108(fp)
 d02ef14:	10800b17 	ldw	r2,44(r2)
 d02ef18:	1007883a 	mov	r3,r2
 d02ef1c:	e0bfe517 	ldw	r2,-108(fp)
 d02ef20:	10800a17 	ldw	r2,40(r2)
 d02ef24:	1885c83a 	sub	r2,r3,r2
 d02ef28:	1004803a 	cmplt	r2,r2,zero
 d02ef2c:	1000071e 	bne	r2,zero,d02ef4c <tcp_input+0x8ec>
 d02ef30:	e0bfe517 	ldw	r2,-108(fp)
 d02ef34:	10c00b17 	ldw	r3,44(r2)
 d02ef38:	e0bfe517 	ldw	r2,-108(fp)
 d02ef3c:	10800a17 	ldw	r2,40(r2)
 d02ef40:	1887c83a 	sub	r3,r3,r2
 d02ef44:	e0fff915 	stw	r3,-28(fp)
 d02ef48:	00000106 	br	d02ef50 <tcp_input+0x8f0>
 d02ef4c:	e03ff915 	stw	zero,-28(fp)
 d02ef50:	e0bff917 	ldw	r2,-28(fp)
 d02ef54:	e0fffa17 	ldw	r3,-24(fp)
 d02ef58:	10c07036 	bltu	r2,r3,d02f11c <tcp_input+0xabc>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 d02ef5c:	e0bfe717 	ldw	r2,-100(fp)
 d02ef60:	10801517 	ldw	r2,84(r2)
 d02ef64:	1004c03a 	cmpne	r2,r2,zero
 d02ef68:	10000c1e 	bne	r2,zero,d02ef9c <tcp_input+0x93c>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 d02ef6c:	008341b4 	movhi	r2,3334
 d02ef70:	10848a04 	addi	r2,r2,4648
 d02ef74:	10802817 	ldw	r2,160(r2)
 d02ef78:	10c00044 	addi	r3,r2,1
 d02ef7c:	008341b4 	movhi	r2,3334
 d02ef80:	10848a04 	addi	r2,r2,4648
 d02ef84:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 d02ef88:	e13ff017 	ldw	r4,-64(fp)
 d02ef8c:	d026b500 	call	d026b50 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 d02ef90:	e13fe717 	ldw	r4,-100(fp)
 d02ef94:	d0312480 	call	d031248 <tcp_output>
            return;
 d02ef98:	00070306 	br	d030ba8 <tcp_input+0x2548>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 d02ef9c:	008341b4 	movhi	r2,3334
 d02efa0:	10848a04 	addi	r2,r2,4648
 d02efa4:	10803617 	ldw	r2,216(r2)
 d02efa8:	10c00044 	addi	r3,r2,1
 d02efac:	008341b4 	movhi	r2,3334
 d02efb0:	10848a04 	addi	r2,r2,4648
 d02efb4:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 d02efb8:	e0bfe717 	ldw	r2,-100(fp)
 d02efbc:	10c01617 	ldw	r3,88(r2)
 d02efc0:	e0bfed17 	ldw	r2,-76(fp)
 d02efc4:	1080028b 	ldhu	r2,10(r2)
 d02efc8:	10bfffcc 	andi	r2,r2,65535
 d02efcc:	1887883a 	add	r3,r3,r2
 d02efd0:	e0bfe717 	ldw	r2,-100(fp)
 d02efd4:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 d02efd8:	008341b4 	movhi	r2,3334
 d02efdc:	10848a04 	addi	r2,r2,4648
 d02efe0:	10801a17 	ldw	r2,104(r2)
 d02efe4:	10c00044 	addi	r3,r2,1
 d02efe8:	008341b4 	movhi	r2,3334
 d02efec:	10848a04 	addi	r2,r2,4648
 d02eff0:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 d02eff4:	008341b4 	movhi	r2,3334
 d02eff8:	10848a04 	addi	r2,r2,4648
 d02effc:	10c01b17 	ldw	r3,108(r2)
 d02f000:	e0bfed17 	ldw	r2,-76(fp)
 d02f004:	1080028b 	ldhu	r2,10(r2)
 d02f008:	10bfffcc 	andi	r2,r2,65535
 d02f00c:	1887883a 	add	r3,r3,r2
 d02f010:	008341b4 	movhi	r2,3334
 d02f014:	10848a04 	addi	r2,r2,4648
 d02f018:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 d02f01c:	e0bfe517 	ldw	r2,-108(fp)
 d02f020:	11000a04 	addi	r4,r2,40
 d02f024:	e17ff017 	ldw	r5,-64(fp)
 d02f028:	d02cfc00 	call	d02cfc0 <sbappend>
         sorwakeup(so);
 d02f02c:	e0bfe517 	ldw	r2,-108(fp)
 d02f030:	11400a04 	addi	r5,r2,40
 d02f034:	e13fe517 	ldw	r4,-108(fp)
 d02f038:	d02cdfc0 	call	d02cdfc <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 d02f03c:	e0bfe617 	ldw	r2,-104(fp)
 d02f040:	1080020c 	andi	r2,r2,8
 d02f044:	1005003a 	cmpeq	r2,r2,zero
 d02f048:	1000071e 	bne	r2,zero,d02f068 <tcp_input+0xa08>
            tp->t_flags |= TF_ACKNOW;
 d02f04c:	e0bfe717 	ldw	r2,-100(fp)
 d02f050:	10800b0b 	ldhu	r2,44(r2)
 d02f054:	10800054 	ori	r2,r2,1
 d02f058:	1007883a 	mov	r3,r2
 d02f05c:	e0bfe717 	ldw	r2,-100(fp)
 d02f060:	10c00b0d 	sth	r3,44(r2)
 d02f064:	00000606 	br	d02f080 <tcp_input+0xa20>
         else
            tp->t_flags |= TF_DELACK;
 d02f068:	e0bfe717 	ldw	r2,-100(fp)
 d02f06c:	10800b0b 	ldhu	r2,44(r2)
 d02f070:	10800094 	ori	r2,r2,2
 d02f074:	1007883a 	mov	r3,r2
 d02f078:	e0bfe717 	ldw	r2,-100(fp)
 d02f07c:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 d02f080:	e0bfe717 	ldw	r2,-100(fp)
 d02f084:	11001517 	ldw	r4,84(r2)
 d02f088:	e0bfe717 	ldw	r2,-100(fp)
 d02f08c:	10c01917 	ldw	r3,100(r2)
 d02f090:	e0bfe717 	ldw	r2,-100(fp)
 d02f094:	10801617 	ldw	r2,88(r2)
 d02f098:	1885c83a 	sub	r2,r3,r2
 d02f09c:	2085c83a 	sub	r2,r4,r2
 d02f0a0:	e0bfda15 	stw	r2,-152(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 d02f0a4:	e0bfe717 	ldw	r2,-100(fp)
 d02f0a8:	10800a0b 	ldhu	r2,40(r2)
 d02f0ac:	10bfffcc 	andi	r2,r2,65535
 d02f0b0:	1085883a 	add	r2,r2,r2
 d02f0b4:	1007883a 	mov	r3,r2
 d02f0b8:	e0bfda17 	ldw	r2,-152(fp)
 d02f0bc:	10c0070e 	bge	r2,r3,d02f0dc <tcp_input+0xa7c>
 d02f0c0:	e0bfe717 	ldw	r2,-100(fp)
 d02f0c4:	10800b0b 	ldhu	r2,44(r2)
 d02f0c8:	10bfffcc 	andi	r2,r2,65535
 d02f0cc:	1080004c 	andi	r2,r2,1
 d02f0d0:	10803fcc 	andi	r2,r2,255
 d02f0d4:	1005003a 	cmpeq	r2,r2,zero
 d02f0d8:	1006b31e 	bne	r2,zero,d030ba8 <tcp_input+0x2548>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 d02f0dc:	e0bfe717 	ldw	r2,-100(fp)
 d02f0e0:	10800b0b 	ldhu	r2,44(r2)
 d02f0e4:	10800054 	ori	r2,r2,1
 d02f0e8:	1007883a 	mov	r3,r2
 d02f0ec:	e0bfe717 	ldw	r2,-100(fp)
 d02f0f0:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 d02f0f4:	e0bfe717 	ldw	r2,-100(fp)
 d02f0f8:	10c00b0b 	ldhu	r3,44(r2)
 d02f0fc:	00bfff44 	movi	r2,-3
 d02f100:	1884703a 	and	r2,r3,r2
 d02f104:	1007883a 	mov	r3,r2
 d02f108:	e0bfe717 	ldw	r2,-100(fp)
 d02f10c:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 d02f110:	e13fe717 	ldw	r4,-100(fp)
 d02f114:	d0312480 	call	d031248 <tcp_output>
         }

         return;
 d02f118:	0006a306 	br	d030ba8 <tcp_input+0x2548>
      }
   }

   switch (tp->t_state) 
 d02f11c:	e0bfe717 	ldw	r2,-100(fp)
 d02f120:	10800217 	ldw	r2,8(r2)
 d02f124:	e0bff815 	stw	r2,-32(fp)
 d02f128:	e13ff817 	ldw	r4,-32(fp)
 d02f12c:	20800060 	cmpeqi	r2,r4,1
 d02f130:	1000041e 	bne	r2,zero,d02f144 <tcp_input+0xae4>
 d02f134:	e0fff817 	ldw	r3,-32(fp)
 d02f138:	188000a0 	cmpeqi	r2,r3,2
 d02f13c:	1000b91e 	bne	r2,zero,d02f424 <tcp_input+0xdc4>
 d02f140:	00019806 	br	d02f7a4 <tcp_input+0x1144>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 d02f144:	e0bfe617 	ldw	r2,-104(fp)
 d02f148:	1080010c 	andi	r2,r2,4
 d02f14c:	1005003a 	cmpeq	r2,r2,zero
 d02f150:	1000031e 	bne	r2,zero,d02f160 <tcp_input+0xb00>
            GOTO_DROP;
 d02f154:	0080bec4 	movi	r2,763
 d02f158:	d0a93015 	stw	r2,-23360(gp)
 d02f15c:	00068606 	br	d030b78 <tcp_input+0x2518>
         if (tiflags & TH_ACK)
 d02f160:	e0bfe617 	ldw	r2,-104(fp)
 d02f164:	1080040c 	andi	r2,r2,16
 d02f168:	1005003a 	cmpeq	r2,r2,zero
 d02f16c:	1000031e 	bne	r2,zero,d02f17c <tcp_input+0xb1c>
            GOTO_DROPWITHRESET;
 d02f170:	0080bf44 	movi	r2,765
 d02f174:	d0a93015 	stw	r2,-23360(gp)
 d02f178:	00063b06 	br	d030a68 <tcp_input+0x2408>
         if ((tiflags & TH_SYN) == 0)
 d02f17c:	e0bfe617 	ldw	r2,-104(fp)
 d02f180:	1080008c 	andi	r2,r2,2
 d02f184:	1004c03a 	cmpne	r2,r2,zero
 d02f188:	1000031e 	bne	r2,zero,d02f198 <tcp_input+0xb38>
            GOTO_DROP;
 d02f18c:	0080bfc4 	movi	r2,767
 d02f190:	d0a93015 	stw	r2,-23360(gp)
 d02f194:	00067806 	br	d030b78 <tcp_input+0x2518>
         if(in_broadcast(ti->ti_dst.s_addr))
 d02f198:	e0bfed17 	ldw	r2,-76(fp)
 d02f19c:	11000417 	ldw	r4,16(r2)
 d02f1a0:	d027b7c0 	call	d027b7c <in_broadcast>
 d02f1a4:	1005003a 	cmpeq	r2,r2,zero
 d02f1a8:	1000031e 	bne	r2,zero,d02f1b8 <tcp_input+0xb58>
            GOTO_DROP;
 d02f1ac:	0080c044 	movi	r2,769
 d02f1b0:	d0a93015 	stw	r2,-23360(gp)
 d02f1b4:	00067006 	br	d030b78 <tcp_input+0x2518>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 d02f1b8:	01000244 	movi	r4,9
 d02f1bc:	01400404 	movi	r5,16
 d02f1c0:	d0268740 	call	d026874 <m_getnbuf>
 d02f1c4:	e0bfd915 	stw	r2,-156(fp)
         if (am == NULL)
 d02f1c8:	e0bfd917 	ldw	r2,-156(fp)
 d02f1cc:	1004c03a 	cmpne	r2,r2,zero
 d02f1d0:	1000031e 	bne	r2,zero,d02f1e0 <tcp_input+0xb80>
            GOTO_DROP;
 d02f1d4:	0080c104 	movi	r2,772
 d02f1d8:	d0a93015 	stw	r2,-23360(gp)
 d02f1dc:	00066606 	br	d030b78 <tcp_input+0x2518>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 d02f1e0:	e0bfec17 	ldw	r2,-80(fp)
 d02f1e4:	10800817 	ldw	r2,32(r2)
 d02f1e8:	10800517 	ldw	r2,20(r2)
 d02f1ec:	10800098 	cmpnei	r2,r2,2
 d02f1f0:	10002e1e 	bne	r2,zero,d02f2ac <tcp_input+0xc4c>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 d02f1f4:	e0ffd917 	ldw	r3,-156(fp)
 d02f1f8:	00800404 	movi	r2,16
 d02f1fc:	18800215 	stw	r2,8(r3)
         sin = mtod(am, struct sockaddr_in *);
 d02f200:	e0bfd917 	ldw	r2,-156(fp)
 d02f204:	10800317 	ldw	r2,12(r2)
 d02f208:	e0bfd815 	stw	r2,-160(fp)
         sin->sin_family = AF_INET;
 d02f20c:	e0ffd817 	ldw	r3,-160(fp)
 d02f210:	00800084 	movi	r2,2
 d02f214:	1880000d 	sth	r2,0(r3)
         sin->sin_addr = ti->ti_src;
 d02f218:	e0bfed17 	ldw	r2,-76(fp)
 d02f21c:	10c00317 	ldw	r3,12(r2)
 d02f220:	e0bfd817 	ldw	r2,-160(fp)
 d02f224:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 d02f228:	e0bfed17 	ldw	r2,-76(fp)
 d02f22c:	10c0050b 	ldhu	r3,20(r2)
 d02f230:	e0bfd817 	ldw	r2,-160(fp)
 d02f234:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 d02f238:	e0bfec17 	ldw	r2,-80(fp)
 d02f23c:	10800417 	ldw	r2,16(r2)
 d02f240:	e0bfef15 	stw	r2,-68(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 d02f244:	e0bfec17 	ldw	r2,-80(fp)
 d02f248:	10800417 	ldw	r2,16(r2)
 d02f24c:	1004c03a 	cmpne	r2,r2,zero
 d02f250:	1000041e 	bne	r2,zero,d02f264 <tcp_input+0xc04>
            inp->inp_laddr = ti->ti_dst;
 d02f254:	e0bfed17 	ldw	r2,-76(fp)
 d02f258:	10c00417 	ldw	r3,16(r2)
 d02f25c:	e0bfec17 	ldw	r2,-80(fp)
 d02f260:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 d02f264:	e13fec17 	ldw	r4,-80(fp)
 d02f268:	e17fd917 	ldw	r5,-156(fp)
 d02f26c:	d04846c0 	call	d04846c <in_pcbconnect>
 d02f270:	1005003a 	cmpeq	r2,r2,zero
 d02f274:	1000081e 	bne	r2,zero,d02f298 <tcp_input+0xc38>
         {
            inp->inp_laddr = laddr;
 d02f278:	e0bfec17 	ldw	r2,-80(fp)
 d02f27c:	e0ffef17 	ldw	r3,-68(fp)
 d02f280:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 d02f284:	e13fd917 	ldw	r4,-156(fp)
 d02f288:	d026a1c0 	call	d026a1c <m_free>
            GOTO_DROP;
 d02f28c:	0080c684 	movi	r2,794
 d02f290:	d0a93015 	stw	r2,-23360(gp)
 d02f294:	00063806 	br	d030b78 <tcp_input+0x2518>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 d02f298:	e0ffec17 	ldw	r3,-80(fp)
 d02f29c:	e0bff117 	ldw	r2,-60(fp)
 d02f2a0:	18800a15 	stw	r2,40(r3)
         
         (void) m_free (am);
 d02f2a4:	e13fd917 	ldw	r4,-156(fp)
 d02f2a8:	d026a1c0 	call	d026a1c <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 d02f2ac:	e13fe717 	ldw	r4,-100(fp)
 d02f2b0:	d0326100 	call	d032610 <tcp_template>
 d02f2b4:	1007883a 	mov	r3,r2
 d02f2b8:	e0bfe717 	ldw	r2,-100(fp)
 d02f2bc:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 d02f2c0:	e0bfe717 	ldw	r2,-100(fp)
 d02f2c4:	10800c17 	ldw	r2,48(r2)
 d02f2c8:	1004c03a 	cmpne	r2,r2,zero
 d02f2cc:	1000071e 	bne	r2,zero,d02f2ec <tcp_input+0xc8c>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 d02f2d0:	e13fe717 	ldw	r4,-100(fp)
 d02f2d4:	01401a44 	movi	r5,105
 d02f2d8:	d032cc80 	call	d032cc8 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 d02f2dc:	e03fe015 	stw	zero,-128(fp)
            GOTO_DROP;
 d02f2e0:	0080d1c4 	movi	r2,839
 d02f2e4:	d0a93015 	stw	r2,-23360(gp)
 d02f2e8:	00062306 	br	d030b78 <tcp_input+0x2518>
         }
         if (om) 
 d02f2ec:	e0bfeb17 	ldw	r2,-84(fp)
 d02f2f0:	1005003a 	cmpeq	r2,r2,zero
 d02f2f4:	1000051e 	bne	r2,zero,d02f30c <tcp_input+0xcac>
         {
            tcp_dooptions(tp, om, ti);
 d02f2f8:	e13fe717 	ldw	r4,-100(fp)
 d02f2fc:	e17feb17 	ldw	r5,-84(fp)
 d02f300:	e1bfed17 	ldw	r6,-76(fp)
 d02f304:	d030bbc0 	call	d030bbc <tcp_dooptions>
            om = 0;
 d02f308:	e03feb15 	stw	zero,-84(fp)
         }
         if (iss)
 d02f30c:	e0bfdf17 	ldw	r2,-132(fp)
 d02f310:	1005003a 	cmpeq	r2,r2,zero
 d02f314:	1000041e 	bne	r2,zero,d02f328 <tcp_input+0xcc8>
            tp->iss = iss;
 d02f318:	e0ffdf17 	ldw	r3,-132(fp)
 d02f31c:	e0bfe717 	ldw	r2,-100(fp)
 d02f320:	10c01315 	stw	r3,76(r2)
 d02f324:	00000506 	br	d02f33c <tcp_input+0xcdc>
         else
            tp->iss = tcp_iss;
 d02f328:	00834174 	movhi	r2,3333
 d02f32c:	109b5204 	addi	r2,r2,27976
 d02f330:	10c00017 	ldw	r3,0(r2)
 d02f334:	e0bfe717 	ldw	r2,-100(fp)
 d02f338:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 d02f33c:	00834174 	movhi	r2,3333
 d02f340:	109b5204 	addi	r2,r2,27976
 d02f344:	10c00017 	ldw	r3,0(r2)
 d02f348:	00be9fd4 	movui	r2,64127
 d02f34c:	1887883a 	add	r3,r3,r2
 d02f350:	00834174 	movhi	r2,3333
 d02f354:	109b5204 	addi	r2,r2,27976
 d02f358:	10c00015 	stw	r3,0(r2)
         tp->irs = ti->ti_seq;
 d02f35c:	e0bfed17 	ldw	r2,-76(fp)
 d02f360:	10c00617 	ldw	r3,24(r2)
 d02f364:	e0bfe717 	ldw	r2,-100(fp)
 d02f368:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 d02f36c:	e0bfe717 	ldw	r2,-100(fp)
 d02f370:	10c01317 	ldw	r3,76(r2)
 d02f374:	e0bfe717 	ldw	r2,-100(fp)
 d02f378:	10c01015 	stw	r3,64(r2)
 d02f37c:	e0bfe717 	ldw	r2,-100(fp)
 d02f380:	10c01017 	ldw	r3,64(r2)
 d02f384:	e0bfe717 	ldw	r2,-100(fp)
 d02f388:	10c01a15 	stw	r3,104(r2)
 d02f38c:	e0bfe717 	ldw	r2,-100(fp)
 d02f390:	10c01a17 	ldw	r3,104(r2)
 d02f394:	e0bfe717 	ldw	r2,-100(fp)
 d02f398:	10c00f15 	stw	r3,60(r2)
 d02f39c:	e0bfe717 	ldw	r2,-100(fp)
 d02f3a0:	10c00f17 	ldw	r3,60(r2)
 d02f3a4:	e0bfe717 	ldw	r2,-100(fp)
 d02f3a8:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 d02f3ac:	e0bfe717 	ldw	r2,-100(fp)
 d02f3b0:	10801817 	ldw	r2,96(r2)
 d02f3b4:	10c00044 	addi	r3,r2,1
 d02f3b8:	e0bfe717 	ldw	r2,-100(fp)
 d02f3bc:	10c01615 	stw	r3,88(r2)
 d02f3c0:	e0bfe717 	ldw	r2,-100(fp)
 d02f3c4:	10c01617 	ldw	r3,88(r2)
 d02f3c8:	e0bfe717 	ldw	r2,-100(fp)
 d02f3cc:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 d02f3d0:	e0bfe717 	ldw	r2,-100(fp)
 d02f3d4:	10800b0b 	ldhu	r2,44(r2)
 d02f3d8:	10800054 	ori	r2,r2,1
 d02f3dc:	1007883a 	mov	r3,r2
 d02f3e0:	e0bfe717 	ldw	r2,-100(fp)
 d02f3e4:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 d02f3e8:	e0ffe717 	ldw	r3,-100(fp)
 d02f3ec:	008000c4 	movi	r2,3
 d02f3f0:	18800215 	stw	r2,8(r3)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 d02f3f4:	e0ffe717 	ldw	r3,-100(fp)
 d02f3f8:	00802584 	movi	r2,150
 d02f3fc:	18800515 	stw	r2,20(r3)
         dropsocket = 0;      /* committed to socket */
 d02f400:	e03fe015 	stw	zero,-128(fp)
         tcpstat.tcps_accepts++;
 d02f404:	008341b4 	movhi	r2,3334
 d02f408:	10848a04 	addi	r2,r2,4648
 d02f40c:	10800117 	ldw	r2,4(r2)
 d02f410:	10c00044 	addi	r3,r2,1
 d02f414:	008341b4 	movhi	r2,3334
 d02f418:	10848a04 	addi	r2,r2,4648
 d02f41c:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 d02f420:	00009d06 	br	d02f698 <tcp_input+0x1038>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 d02f424:	e0ffec17 	ldw	r3,-80(fp)
 d02f428:	e0bff117 	ldw	r2,-60(fp)
 d02f42c:	18800a15 	stw	r2,40(r3)
      if ((tiflags & TH_ACK) &&
 d02f430:	e0bfe617 	ldw	r2,-104(fp)
 d02f434:	1080040c 	andi	r2,r2,16
 d02f438:	1005003a 	cmpeq	r2,r2,zero
 d02f43c:	1000111e 	bne	r2,zero,d02f484 <tcp_input+0xe24>
 d02f440:	e0bfed17 	ldw	r2,-76(fp)
 d02f444:	10c00717 	ldw	r3,28(r2)
 d02f448:	e0bfe717 	ldw	r2,-100(fp)
 d02f44c:	10801317 	ldw	r2,76(r2)
 d02f450:	1885c83a 	sub	r2,r3,r2
 d02f454:	10800050 	cmplti	r2,r2,1
 d02f458:	1000071e 	bne	r2,zero,d02f478 <tcp_input+0xe18>
 d02f45c:	e0bfed17 	ldw	r2,-76(fp)
 d02f460:	10c00717 	ldw	r3,28(r2)
 d02f464:	e0bfe717 	ldw	r2,-100(fp)
 d02f468:	10801a17 	ldw	r2,104(r2)
 d02f46c:	1885c83a 	sub	r2,r3,r2
 d02f470:	10800050 	cmplti	r2,r2,1
 d02f474:	1000031e 	bne	r2,zero,d02f484 <tcp_input+0xe24>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 d02f478:	0080dc04 	movi	r2,880
 d02f47c:	d0a93015 	stw	r2,-23360(gp)
 d02f480:	00057906 	br	d030a68 <tcp_input+0x2408>
      }
      if (tiflags & TH_RST) 
 d02f484:	e0bfe617 	ldw	r2,-104(fp)
 d02f488:	1080010c 	andi	r2,r2,4
 d02f48c:	1005003a 	cmpeq	r2,r2,zero
 d02f490:	10000a1e 	bne	r2,zero,d02f4bc <tcp_input+0xe5c>
      {
         if (tiflags & TH_ACK)
 d02f494:	e0bfe617 	ldw	r2,-104(fp)
 d02f498:	1080040c 	andi	r2,r2,16
 d02f49c:	1005003a 	cmpeq	r2,r2,zero
 d02f4a0:	1000031e 	bne	r2,zero,d02f4b0 <tcp_input+0xe50>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 d02f4a4:	e13fe717 	ldw	r4,-100(fp)
 d02f4a8:	01401bc4 	movi	r5,111
 d02f4ac:	d032cc80 	call	d032cc8 <tcp_drop>
         GOTO_DROP;
 d02f4b0:	0080dd84 	movi	r2,886
 d02f4b4:	d0a93015 	stw	r2,-23360(gp)
 d02f4b8:	0005af06 	br	d030b78 <tcp_input+0x2518>
      }
      if ((tiflags & TH_SYN) == 0)
 d02f4bc:	e0bfe617 	ldw	r2,-104(fp)
 d02f4c0:	1080008c 	andi	r2,r2,2
 d02f4c4:	1004c03a 	cmpne	r2,r2,zero
 d02f4c8:	1000031e 	bne	r2,zero,d02f4d8 <tcp_input+0xe78>
         GOTO_DROP;
 d02f4cc:	0080de44 	movi	r2,889
 d02f4d0:	d0a93015 	stw	r2,-23360(gp)
 d02f4d4:	0005a806 	br	d030b78 <tcp_input+0x2518>
      if (tiflags & TH_ACK) 
 d02f4d8:	e0bfe617 	ldw	r2,-104(fp)
 d02f4dc:	1080040c 	andi	r2,r2,16
 d02f4e0:	1005003a 	cmpeq	r2,r2,zero
 d02f4e4:	10000f1e 	bne	r2,zero,d02f524 <tcp_input+0xec4>
      {
         tp->snd_una = ti->ti_ack;
 d02f4e8:	e0bfed17 	ldw	r2,-76(fp)
 d02f4ec:	10c00717 	ldw	r3,28(r2)
 d02f4f0:	e0bfe717 	ldw	r2,-100(fp)
 d02f4f4:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 d02f4f8:	e0bfe717 	ldw	r2,-100(fp)
 d02f4fc:	10c00f17 	ldw	r3,60(r2)
 d02f500:	e0bfe717 	ldw	r2,-100(fp)
 d02f504:	10800e17 	ldw	r2,56(r2)
 d02f508:	1885c83a 	sub	r2,r3,r2
 d02f50c:	1004403a 	cmpge	r2,r2,zero
 d02f510:	1000041e 	bne	r2,zero,d02f524 <tcp_input+0xec4>
            tp->snd_nxt = tp->snd_una;
 d02f514:	e0bfe717 	ldw	r2,-100(fp)
 d02f518:	10c00e17 	ldw	r3,56(r2)
 d02f51c:	e0bfe717 	ldw	r2,-100(fp)
 d02f520:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 d02f524:	e0bfe717 	ldw	r2,-100(fp)
 d02f528:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 d02f52c:	e0bfed17 	ldw	r2,-76(fp)
 d02f530:	10c00617 	ldw	r3,24(r2)
 d02f534:	e0bfe717 	ldw	r2,-100(fp)
 d02f538:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 d02f53c:	e0bfe717 	ldw	r2,-100(fp)
 d02f540:	10801817 	ldw	r2,96(r2)
 d02f544:	10c00044 	addi	r3,r2,1
 d02f548:	e0bfe717 	ldw	r2,-100(fp)
 d02f54c:	10c01615 	stw	r3,88(r2)
 d02f550:	e0bfe717 	ldw	r2,-100(fp)
 d02f554:	10c01617 	ldw	r3,88(r2)
 d02f558:	e0bfe717 	ldw	r2,-100(fp)
 d02f55c:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 d02f560:	e0bfec17 	ldw	r2,-80(fp)
 d02f564:	10c00417 	ldw	r3,16(r2)
 d02f568:	e0bfed17 	ldw	r2,-76(fp)
 d02f56c:	10800417 	ldw	r2,16(r2)
 d02f570:	18801926 	beq	r3,r2,d02f5d8 <tcp_input+0xf78>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 d02f574:	e0bff017 	ldw	r2,-64(fp)
 d02f578:	10800117 	ldw	r2,4(r2)
 d02f57c:	10800617 	ldw	r2,24(r2)
 d02f580:	1005003a 	cmpeq	r2,r2,zero
 d02f584:	1000141e 	bne	r2,zero,d02f5d8 <tcp_input+0xf78>
 d02f588:	e0bff017 	ldw	r2,-64(fp)
 d02f58c:	10800117 	ldw	r2,4(r2)
 d02f590:	10800617 	ldw	r2,24(r2)
 d02f594:	10c00a17 	ldw	r3,40(r2)
 d02f598:	e0bfed17 	ldw	r2,-76(fp)
 d02f59c:	10800417 	ldw	r2,16(r2)
 d02f5a0:	18800d1e 	bne	r3,r2,d02f5d8 <tcp_input+0xf78>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 d02f5a4:	e0bfed17 	ldw	r2,-76(fp)
 d02f5a8:	10c00417 	ldw	r3,16(r2)
 d02f5ac:	e0bfec17 	ldw	r2,-80(fp)
 d02f5b0:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 d02f5b4:	e0bfe717 	ldw	r2,-100(fp)
 d02f5b8:	10800c17 	ldw	r2,48(r2)
 d02f5bc:	1005003a 	cmpeq	r2,r2,zero
 d02f5c0:	1000051e 	bne	r2,zero,d02f5d8 <tcp_input+0xf78>
               tp->t_template->ti_src = ti->ti_dst;
 d02f5c4:	e0bfe717 	ldw	r2,-100(fp)
 d02f5c8:	10c00c17 	ldw	r3,48(r2)
 d02f5cc:	e0bfed17 	ldw	r2,-76(fp)
 d02f5d0:	10800417 	ldw	r2,16(r2)
 d02f5d4:	18800315 	stw	r2,12(r3)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 d02f5d8:	e0bfe717 	ldw	r2,-100(fp)
 d02f5dc:	10800b0b 	ldhu	r2,44(r2)
 d02f5e0:	10800054 	ori	r2,r2,1
 d02f5e4:	1007883a 	mov	r3,r2
 d02f5e8:	e0bfe717 	ldw	r2,-100(fp)
 d02f5ec:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 d02f5f0:	e0bfe617 	ldw	r2,-104(fp)
 d02f5f4:	1080040c 	andi	r2,r2,16
 d02f5f8:	1005003a 	cmpeq	r2,r2,zero
 d02f5fc:	1000231e 	bne	r2,zero,d02f68c <tcp_input+0x102c>
 d02f600:	e0bfe717 	ldw	r2,-100(fp)
 d02f604:	10c00e17 	ldw	r3,56(r2)
 d02f608:	e0bfe717 	ldw	r2,-100(fp)
 d02f60c:	10801317 	ldw	r2,76(r2)
 d02f610:	1885c83a 	sub	r2,r3,r2
 d02f614:	10800050 	cmplti	r2,r2,1
 d02f618:	10001c1e 	bne	r2,zero,d02f68c <tcp_input+0x102c>
      {
         tcpstat.tcps_connects++;
 d02f61c:	008341b4 	movhi	r2,3334
 d02f620:	10848a04 	addi	r2,r2,4648
 d02f624:	10800217 	ldw	r2,8(r2)
 d02f628:	10c00044 	addi	r3,r2,1
 d02f62c:	008341b4 	movhi	r2,3334
 d02f630:	10848a04 	addi	r2,r2,4648
 d02f634:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 d02f638:	e0ffe717 	ldw	r3,-100(fp)
 d02f63c:	00800104 	movi	r2,4
 d02f640:	18800215 	stw	r2,8(r3)
         soisconnected (so);
 d02f644:	e13fe517 	ldw	r4,-108(fp)
 d02f648:	d02c6900 	call	d02c690 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 d02f64c:	e13fe517 	ldw	r4,-108(fp)
 d02f650:	d03112c0 	call	d03112c <tcp_mss>
 d02f654:	1007883a 	mov	r3,r2
 d02f658:	e0bfe717 	ldw	r2,-100(fp)
 d02f65c:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 d02f660:	e13fe717 	ldw	r4,-100(fp)
 d02f664:	000b883a 	mov	r5,zero
 d02f668:	e1bff017 	ldw	r6,-64(fp)
 d02f66c:	d02e2580 	call	d02e258 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 d02f670:	e0bfe717 	ldw	r2,-100(fp)
 d02f674:	10801e17 	ldw	r2,120(r2)
 d02f678:	1005003a 	cmpeq	r2,r2,zero
 d02f67c:	1000061e 	bne	r2,zero,d02f698 <tcp_input+0x1038>
         {
            tcp_xmit_timer(tp);
 d02f680:	e13fe717 	ldw	r4,-100(fp)
 d02f684:	d030e780 	call	d030e78 <tcp_xmit_timer>
            if (tp->t_template != NULL)
               tp->t_template->ti_src = ti->ti_dst;
         }
      }
      tp->t_flags |= TF_ACKNOW;
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 d02f688:	00000306 	br	d02f698 <tcp_input+0x1038>
         if (tp->t_rttick) 
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 d02f68c:	e0ffe717 	ldw	r3,-100(fp)
 d02f690:	008000c4 	movi	r2,3
 d02f694:	18800215 	stw	r2,8(r3)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 d02f698:	e0bfed17 	ldw	r2,-76(fp)
 d02f69c:	10800617 	ldw	r2,24(r2)
 d02f6a0:	10c00044 	addi	r3,r2,1
 d02f6a4:	e0bfed17 	ldw	r2,-76(fp)
 d02f6a8:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 d02f6ac:	e0bfed17 	ldw	r2,-76(fp)
 d02f6b0:	1080028b 	ldhu	r2,10(r2)
 d02f6b4:	10ffffcc 	andi	r3,r2,65535
 d02f6b8:	e0bfe717 	ldw	r2,-100(fp)
 d02f6bc:	10801517 	ldw	r2,84(r2)
 d02f6c0:	10c02e2e 	bgeu	r2,r3,d02f77c <tcp_input+0x111c>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 d02f6c4:	e0bfed17 	ldw	r2,-76(fp)
 d02f6c8:	1080028b 	ldhu	r2,10(r2)
 d02f6cc:	10ffffcc 	andi	r3,r2,65535
 d02f6d0:	e0bfe717 	ldw	r2,-100(fp)
 d02f6d4:	10801517 	ldw	r2,84(r2)
 d02f6d8:	10bfffcc 	andi	r2,r2,65535
 d02f6dc:	1885c83a 	sub	r2,r3,r2
 d02f6e0:	e0bfe415 	stw	r2,-112(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 d02f6e4:	e0bff017 	ldw	r2,-64(fp)
 d02f6e8:	10800217 	ldw	r2,8(r2)
 d02f6ec:	1005003a 	cmpeq	r2,r2,zero
 d02f6f0:	1000051e 	bne	r2,zero,d02f708 <tcp_input+0x10a8>
         {
            m_adj(m, -todrop);
 d02f6f4:	e0bfe417 	ldw	r2,-112(fp)
 d02f6f8:	008bc83a 	sub	r5,zero,r2
 d02f6fc:	e13ff017 	ldw	r4,-64(fp)
 d02f700:	d026eb80 	call	d026eb8 <m_adj>
 d02f704:	00000506 	br	d02f71c <tcp_input+0x10bc>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 d02f708:	e0bff017 	ldw	r2,-64(fp)
 d02f70c:	11000617 	ldw	r4,24(r2)
 d02f710:	e0bfe417 	ldw	r2,-112(fp)
 d02f714:	008bc83a 	sub	r5,zero,r2
 d02f718:	d026eb80 	call	d026eb8 <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 d02f71c:	e0bfe717 	ldw	r2,-100(fp)
 d02f720:	10801517 	ldw	r2,84(r2)
 d02f724:	1007883a 	mov	r3,r2
 d02f728:	e0bfed17 	ldw	r2,-76(fp)
 d02f72c:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 d02f730:	e0ffe617 	ldw	r3,-104(fp)
 d02f734:	00bfff84 	movi	r2,-2
 d02f738:	1884703a 	and	r2,r3,r2
 d02f73c:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpackafterwin++;
 d02f740:	008341b4 	movhi	r2,3334
 d02f744:	10848a04 	addi	r2,r2,4648
 d02f748:	10802517 	ldw	r2,148(r2)
 d02f74c:	10c00044 	addi	r3,r2,1
 d02f750:	008341b4 	movhi	r2,3334
 d02f754:	10848a04 	addi	r2,r2,4648
 d02f758:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 d02f75c:	008341b4 	movhi	r2,3334
 d02f760:	10848a04 	addi	r2,r2,4648
 d02f764:	10c02617 	ldw	r3,152(r2)
 d02f768:	e0bfe417 	ldw	r2,-112(fp)
 d02f76c:	1887883a 	add	r3,r3,r2
 d02f770:	008341b4 	movhi	r2,3334
 d02f774:	10848a04 	addi	r2,r2,4648
 d02f778:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 d02f77c:	e0bfed17 	ldw	r2,-76(fp)
 d02f780:	10800617 	ldw	r2,24(r2)
 d02f784:	10ffffc4 	addi	r3,r2,-1
 d02f788:	e0bfe717 	ldw	r2,-100(fp)
 d02f78c:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 d02f790:	e0bfed17 	ldw	r2,-76(fp)
 d02f794:	10c00617 	ldw	r3,24(r2)
 d02f798:	e0bfe717 	ldw	r2,-100(fp)
 d02f79c:	10c01715 	stw	r3,92(r2)
      goto step6;
 d02f7a0:	00032606 	br	d03043c <tcp_input+0x1ddc>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 d02f7a4:	e0bfe717 	ldw	r2,-100(fp)
 d02f7a8:	10c01617 	ldw	r3,88(r2)
 d02f7ac:	e0bfed17 	ldw	r2,-76(fp)
 d02f7b0:	10800617 	ldw	r2,24(r2)
 d02f7b4:	1885c83a 	sub	r2,r3,r2
 d02f7b8:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 d02f7bc:	e0bfe417 	ldw	r2,-112(fp)
 d02f7c0:	10800050 	cmplti	r2,r2,1
 d02f7c4:	1000971e 	bne	r2,zero,d02fa24 <tcp_input+0x13c4>
   {
      if (tiflags & TH_SYN) 
 d02f7c8:	e0bfe617 	ldw	r2,-104(fp)
 d02f7cc:	1080008c 	andi	r2,r2,2
 d02f7d0:	1005003a 	cmpeq	r2,r2,zero
 d02f7d4:	10001c1e 	bne	r2,zero,d02f848 <tcp_input+0x11e8>
      {
         tiflags &= ~TH_SYN;
 d02f7d8:	e0ffe617 	ldw	r3,-104(fp)
 d02f7dc:	00bfff44 	movi	r2,-3
 d02f7e0:	1884703a 	and	r2,r3,r2
 d02f7e4:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_seq++;
 d02f7e8:	e0bfed17 	ldw	r2,-76(fp)
 d02f7ec:	10800617 	ldw	r2,24(r2)
 d02f7f0:	10c00044 	addi	r3,r2,1
 d02f7f4:	e0bfed17 	ldw	r2,-76(fp)
 d02f7f8:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 d02f7fc:	e0bfed17 	ldw	r2,-76(fp)
 d02f800:	1080098b 	ldhu	r2,38(r2)
 d02f804:	10bfffcc 	andi	r2,r2,65535
 d02f808:	108000b0 	cmpltui	r2,r2,2
 d02f80c:	1000071e 	bne	r2,zero,d02f82c <tcp_input+0x11cc>
            ti->ti_urp--;
 d02f810:	e0bfed17 	ldw	r2,-76(fp)
 d02f814:	1080098b 	ldhu	r2,38(r2)
 d02f818:	10bfffc4 	addi	r2,r2,-1
 d02f81c:	1007883a 	mov	r3,r2
 d02f820:	e0bfed17 	ldw	r2,-76(fp)
 d02f824:	10c0098d 	sth	r3,38(r2)
 d02f828:	00000406 	br	d02f83c <tcp_input+0x11dc>
         else
            tiflags &= ~TH_URG;
 d02f82c:	e0bfe617 	ldw	r2,-104(fp)
 d02f830:	00fff7c4 	movi	r3,-33
 d02f834:	10c4703a 	and	r2,r2,r3
 d02f838:	e0bfe615 	stw	r2,-104(fp)
         todrop--;
 d02f83c:	e0bfe417 	ldw	r2,-112(fp)
 d02f840:	10bfffc4 	addi	r2,r2,-1
 d02f844:	e0bfe415 	stw	r2,-112(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 d02f848:	e0bfed17 	ldw	r2,-76(fp)
 d02f84c:	1080028b 	ldhu	r2,10(r2)
 d02f850:	10ffffcc 	andi	r3,r2,65535
 d02f854:	e0bfe417 	ldw	r2,-112(fp)
 d02f858:	18800916 	blt	r3,r2,d02f880 <tcp_input+0x1220>
 d02f85c:	e0bfed17 	ldw	r2,-76(fp)
 d02f860:	1080028b 	ldhu	r2,10(r2)
 d02f864:	10ffffcc 	andi	r3,r2,65535
 d02f868:	e0bfe417 	ldw	r2,-112(fp)
 d02f86c:	18803a1e 	bne	r3,r2,d02f958 <tcp_input+0x12f8>
 d02f870:	e0bfe617 	ldw	r2,-104(fp)
 d02f874:	1080004c 	andi	r2,r2,1
 d02f878:	1004c03a 	cmpne	r2,r2,zero
 d02f87c:	1000361e 	bne	r2,zero,d02f958 <tcp_input+0x12f8>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 d02f880:	008341b4 	movhi	r2,3334
 d02f884:	10848a04 	addi	r2,r2,4648
 d02f888:	10801f17 	ldw	r2,124(r2)
 d02f88c:	10c00044 	addi	r3,r2,1
 d02f890:	008341b4 	movhi	r2,3334
 d02f894:	10848a04 	addi	r2,r2,4648
 d02f898:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 d02f89c:	008341b4 	movhi	r2,3334
 d02f8a0:	10848a04 	addi	r2,r2,4648
 d02f8a4:	10c02017 	ldw	r3,128(r2)
 d02f8a8:	e0bfed17 	ldw	r2,-76(fp)
 d02f8ac:	1080028b 	ldhu	r2,10(r2)
 d02f8b0:	10bfffcc 	andi	r2,r2,65535
 d02f8b4:	1887883a 	add	r3,r3,r2
 d02f8b8:	008341b4 	movhi	r2,3334
 d02f8bc:	10848a04 	addi	r2,r2,4648
 d02f8c0:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 d02f8c4:	e0bfe617 	ldw	r2,-104(fp)
 d02f8c8:	1080004c 	andi	r2,r2,1
 d02f8cc:	1080005c 	xori	r2,r2,1
 d02f8d0:	10803fcc 	andi	r2,r2,255
 d02f8d4:	1004c03a 	cmpne	r2,r2,zero
 d02f8d8:	1000061e 	bne	r2,zero,d02f8f4 <tcp_input+0x1294>
 d02f8dc:	e0bfed17 	ldw	r2,-76(fp)
 d02f8e0:	1080028b 	ldhu	r2,10(r2)
 d02f8e4:	10bfffcc 	andi	r2,r2,65535
 d02f8e8:	10c00044 	addi	r3,r2,1
 d02f8ec:	e0bfe417 	ldw	r2,-112(fp)
 d02f8f0:	18800a26 	beq	r3,r2,d02f91c <tcp_input+0x12bc>
 d02f8f4:	e0bfe617 	ldw	r2,-104(fp)
 d02f8f8:	1080010c 	andi	r2,r2,4
 d02f8fc:	1005003a 	cmpeq	r2,r2,zero
 d02f900:	1004471e 	bne	r2,zero,d030a20 <tcp_input+0x23c0>
 d02f904:	e0bfed17 	ldw	r2,-76(fp)
 d02f908:	10c00617 	ldw	r3,24(r2)
 d02f90c:	e0bfe717 	ldw	r2,-100(fp)
 d02f910:	10801617 	ldw	r2,88(r2)
 d02f914:	10bfffc4 	addi	r2,r2,-1
 d02f918:	1884411e 	bne	r3,r2,d030a20 <tcp_input+0x23c0>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
         {
            todrop = ti->ti_len;
 d02f91c:	e0bfed17 	ldw	r2,-76(fp)
 d02f920:	1080028b 	ldhu	r2,10(r2)
 d02f924:	10bfffcc 	andi	r2,r2,65535
 d02f928:	e0bfe415 	stw	r2,-112(fp)
            tiflags &= ~TH_FIN;
 d02f92c:	e0ffe617 	ldw	r3,-104(fp)
 d02f930:	00bfff84 	movi	r2,-2
 d02f934:	1884703a 	and	r2,r3,r2
 d02f938:	e0bfe615 	stw	r2,-104(fp)
            tp->t_flags |= TF_ACKNOW;
 d02f93c:	e0bfe717 	ldw	r2,-100(fp)
 d02f940:	10800b0b 	ldhu	r2,44(r2)
 d02f944:	10800054 	ori	r2,r2,1
 d02f948:	1007883a 	mov	r3,r2
 d02f94c:	e0bfe717 	ldw	r2,-100(fp)
 d02f950:	10c00b0d 	sth	r3,44(r2)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 d02f954:	00000f06 	br	d02f994 <tcp_input+0x1334>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 d02f958:	008341b4 	movhi	r2,3334
 d02f95c:	10848a04 	addi	r2,r2,4648
 d02f960:	10802117 	ldw	r2,132(r2)
 d02f964:	10c00044 	addi	r3,r2,1
 d02f968:	008341b4 	movhi	r2,3334
 d02f96c:	10848a04 	addi	r2,r2,4648
 d02f970:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 d02f974:	008341b4 	movhi	r2,3334
 d02f978:	10848a04 	addi	r2,r2,4648
 d02f97c:	10c02217 	ldw	r3,136(r2)
 d02f980:	e0bfe417 	ldw	r2,-112(fp)
 d02f984:	1887883a 	add	r3,r3,r2
 d02f988:	008341b4 	movhi	r2,3334
 d02f98c:	10848a04 	addi	r2,r2,4648
 d02f990:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 d02f994:	e13ff017 	ldw	r4,-64(fp)
 d02f998:	e17fe417 	ldw	r5,-112(fp)
 d02f99c:	d026eb80 	call	d026eb8 <m_adj>
      ti->ti_seq += todrop;
 d02f9a0:	e0bfed17 	ldw	r2,-76(fp)
 d02f9a4:	10c00617 	ldw	r3,24(r2)
 d02f9a8:	e0bfe417 	ldw	r2,-112(fp)
 d02f9ac:	1887883a 	add	r3,r3,r2
 d02f9b0:	e0bfed17 	ldw	r2,-76(fp)
 d02f9b4:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 d02f9b8:	e0bfed17 	ldw	r2,-76(fp)
 d02f9bc:	10c0028b 	ldhu	r3,10(r2)
 d02f9c0:	e0bfe417 	ldw	r2,-112(fp)
 d02f9c4:	1885c83a 	sub	r2,r3,r2
 d02f9c8:	1007883a 	mov	r3,r2
 d02f9cc:	e0bfed17 	ldw	r2,-76(fp)
 d02f9d0:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 d02f9d4:	e0bfed17 	ldw	r2,-76(fp)
 d02f9d8:	10c0098b 	ldhu	r3,38(r2)
 d02f9dc:	e0bfe417 	ldw	r2,-112(fp)
 d02f9e0:	18ffffcc 	andi	r3,r3,65535
 d02f9e4:	10bfffcc 	andi	r2,r2,65535
 d02f9e8:	10c0082e 	bgeu	r2,r3,d02fa0c <tcp_input+0x13ac>
         ti->ti_urp -= (u_short)todrop;
 d02f9ec:	e0bfed17 	ldw	r2,-76(fp)
 d02f9f0:	10c0098b 	ldhu	r3,38(r2)
 d02f9f4:	e0bfe417 	ldw	r2,-112(fp)
 d02f9f8:	1885c83a 	sub	r2,r3,r2
 d02f9fc:	1007883a 	mov	r3,r2
 d02fa00:	e0bfed17 	ldw	r2,-76(fp)
 d02fa04:	10c0098d 	sth	r3,38(r2)
 d02fa08:	00000606 	br	d02fa24 <tcp_input+0x13c4>
      else 
      {
         tiflags &= ~TH_URG;
 d02fa0c:	e0ffe617 	ldw	r3,-104(fp)
 d02fa10:	00bff7c4 	movi	r2,-33
 d02fa14:	1884703a 	and	r2,r3,r2
 d02fa18:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_urp = 0;
 d02fa1c:	e0bfed17 	ldw	r2,-76(fp)
 d02fa20:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 d02fa24:	e0bfe517 	ldw	r2,-108(fp)
 d02fa28:	1080088b 	ldhu	r2,34(r2)
 d02fa2c:	10bfffcc 	andi	r2,r2,65535
 d02fa30:	1080004c 	andi	r2,r2,1
 d02fa34:	10803fcc 	andi	r2,r2,255
 d02fa38:	1005003a 	cmpeq	r2,r2,zero
 d02fa3c:	1000161e 	bne	r2,zero,d02fa98 <tcp_input+0x1438>
 d02fa40:	e0bfe717 	ldw	r2,-100(fp)
 d02fa44:	10800217 	ldw	r2,8(r2)
 d02fa48:	10800190 	cmplti	r2,r2,6
 d02fa4c:	1000121e 	bne	r2,zero,d02fa98 <tcp_input+0x1438>
 d02fa50:	e0bfed17 	ldw	r2,-76(fp)
 d02fa54:	1080028b 	ldhu	r2,10(r2)
 d02fa58:	10bfffcc 	andi	r2,r2,65535
 d02fa5c:	1005003a 	cmpeq	r2,r2,zero
 d02fa60:	10000d1e 	bne	r2,zero,d02fa98 <tcp_input+0x1438>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
   {
      tp = tcp_close(tp);
 d02fa64:	e13fe717 	ldw	r4,-100(fp)
 d02fa68:	d032d740 	call	d032d74 <tcp_close>
 d02fa6c:	e0bfe715 	stw	r2,-100(fp)
      tcpstat.tcps_rcvafterclose++;
 d02fa70:	008341b4 	movhi	r2,3334
 d02fa74:	10848a04 	addi	r2,r2,4648
 d02fa78:	10802717 	ldw	r2,156(r2)
 d02fa7c:	10c00044 	addi	r3,r2,1
 d02fa80:	008341b4 	movhi	r2,3334
 d02fa84:	10848a04 	addi	r2,r2,4648
 d02fa88:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 d02fa8c:	00810444 	movi	r2,1041
 d02fa90:	d0a93015 	stw	r2,-23360(gp)
 d02fa94:	0003f406 	br	d030a68 <tcp_input+0x2408>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 d02fa98:	e0bfed17 	ldw	r2,-76(fp)
 d02fa9c:	10c00617 	ldw	r3,24(r2)
 d02faa0:	e0bfed17 	ldw	r2,-76(fp)
 d02faa4:	1080028b 	ldhu	r2,10(r2)
 d02faa8:	10bfffcc 	andi	r2,r2,65535
 d02faac:	10a0001c 	xori	r2,r2,32768
 d02fab0:	10a00004 	addi	r2,r2,-32768
 d02fab4:	1889883a 	add	r4,r3,r2
 d02fab8:	e0bfe717 	ldw	r2,-100(fp)
 d02fabc:	10c01617 	ldw	r3,88(r2)
 d02fac0:	e0bfe717 	ldw	r2,-100(fp)
 d02fac4:	10801517 	ldw	r2,84(r2)
 d02fac8:	1885883a 	add	r2,r3,r2
 d02facc:	2085c83a 	sub	r2,r4,r2
 d02fad0:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 d02fad4:	e0bfe417 	ldw	r2,-112(fp)
 d02fad8:	10800050 	cmplti	r2,r2,1
 d02fadc:	10006b1e 	bne	r2,zero,d02fc8c <tcp_input+0x162c>
   {
      tcpstat.tcps_rcvpackafterwin++;
 d02fae0:	008341b4 	movhi	r2,3334
 d02fae4:	10848a04 	addi	r2,r2,4648
 d02fae8:	10802517 	ldw	r2,148(r2)
 d02faec:	10c00044 	addi	r3,r2,1
 d02faf0:	008341b4 	movhi	r2,3334
 d02faf4:	10848a04 	addi	r2,r2,4648
 d02faf8:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 d02fafc:	e0bfed17 	ldw	r2,-76(fp)
 d02fb00:	1080028b 	ldhu	r2,10(r2)
 d02fb04:	10ffffcc 	andi	r3,r2,65535
 d02fb08:	e0bfe417 	ldw	r2,-112(fp)
 d02fb0c:	10c03e16 	blt	r2,r3,d02fc08 <tcp_input+0x15a8>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 d02fb10:	008341b4 	movhi	r2,3334
 d02fb14:	10848a04 	addi	r2,r2,4648
 d02fb18:	10c02617 	ldw	r3,152(r2)
 d02fb1c:	e0bfed17 	ldw	r2,-76(fp)
 d02fb20:	1080028b 	ldhu	r2,10(r2)
 d02fb24:	10bfffcc 	andi	r2,r2,65535
 d02fb28:	1887883a 	add	r3,r3,r2
 d02fb2c:	008341b4 	movhi	r2,3334
 d02fb30:	10848a04 	addi	r2,r2,4648
 d02fb34:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 d02fb38:	e0bfe617 	ldw	r2,-104(fp)
 d02fb3c:	1080008c 	andi	r2,r2,2
 d02fb40:	1005003a 	cmpeq	r2,r2,zero
 d02fb44:	1000191e 	bne	r2,zero,d02fbac <tcp_input+0x154c>
 d02fb48:	e0bfe717 	ldw	r2,-100(fp)
 d02fb4c:	10800217 	ldw	r2,8(r2)
 d02fb50:	10800298 	cmpnei	r2,r2,10
 d02fb54:	1000151e 	bne	r2,zero,d02fbac <tcp_input+0x154c>
 d02fb58:	e0bfed17 	ldw	r2,-76(fp)
 d02fb5c:	10c00617 	ldw	r3,24(r2)
 d02fb60:	e0bfe717 	ldw	r2,-100(fp)
 d02fb64:	10801617 	ldw	r2,88(r2)
 d02fb68:	1885c83a 	sub	r2,r3,r2
 d02fb6c:	10800050 	cmplti	r2,r2,1
 d02fb70:	10000e1e 	bne	r2,zero,d02fbac <tcp_input+0x154c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 d02fb74:	e0bfe717 	ldw	r2,-100(fp)
 d02fb78:	10c01617 	ldw	r3,88(r2)
 d02fb7c:	008000b4 	movhi	r2,2
 d02fb80:	10bd3fc4 	addi	r2,r2,-2817
 d02fb84:	1885883a 	add	r2,r3,r2
 d02fb88:	e0bfdf15 	stw	r2,-132(fp)
            if (iss & 0xff000000)
 d02fb8c:	e0bfdf17 	ldw	r2,-132(fp)
 d02fb90:	10bfc02c 	andhi	r2,r2,65280
 d02fb94:	1005003a 	cmpeq	r2,r2,zero
 d02fb98:	1000011e 	bne	r2,zero,d02fba0 <tcp_input+0x1540>
            {
               iss = 0L;
 d02fb9c:	e03fdf15 	stw	zero,-132(fp)
            }
            (void) tcp_close(tp);
 d02fba0:	e13fe717 	ldw	r4,-100(fp)
 d02fba4:	d032d740 	call	d032d74 <tcp_close>
            goto findpcb;
 d02fba8:	003b8d06 	br	d02e9e0 <tcp_input+0x380>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 d02fbac:	e0bfe717 	ldw	r2,-100(fp)
 d02fbb0:	10801517 	ldw	r2,84(r2)
 d02fbb4:	1004c03a 	cmpne	r2,r2,zero
 d02fbb8:	1003991e 	bne	r2,zero,d030a20 <tcp_input+0x23c0>
 d02fbbc:	e0bfed17 	ldw	r2,-76(fp)
 d02fbc0:	10c00617 	ldw	r3,24(r2)
 d02fbc4:	e0bfe717 	ldw	r2,-100(fp)
 d02fbc8:	10801617 	ldw	r2,88(r2)
 d02fbcc:	1883941e 	bne	r3,r2,d030a20 <tcp_input+0x23c0>
         {
            tp->t_flags |= TF_ACKNOW;
 d02fbd0:	e0bfe717 	ldw	r2,-100(fp)
 d02fbd4:	10800b0b 	ldhu	r2,44(r2)
 d02fbd8:	10800054 	ori	r2,r2,1
 d02fbdc:	1007883a 	mov	r3,r2
 d02fbe0:	e0bfe717 	ldw	r2,-100(fp)
 d02fbe4:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 d02fbe8:	008341b4 	movhi	r2,3334
 d02fbec:	10848a04 	addi	r2,r2,4648
 d02fbf0:	10802817 	ldw	r2,160(r2)
 d02fbf4:	10c00044 	addi	r3,r2,1
 d02fbf8:	008341b4 	movhi	r2,3334
 d02fbfc:	10848a04 	addi	r2,r2,4648
 d02fc00:	10c02815 	stw	r3,160(r2)
 d02fc04:	00000806 	br	d02fc28 <tcp_input+0x15c8>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 d02fc08:	008341b4 	movhi	r2,3334
 d02fc0c:	10848a04 	addi	r2,r2,4648
 d02fc10:	10c02617 	ldw	r3,152(r2)
 d02fc14:	e0bfe417 	ldw	r2,-112(fp)
 d02fc18:	1887883a 	add	r3,r3,r2
 d02fc1c:	008341b4 	movhi	r2,3334
 d02fc20:	10848a04 	addi	r2,r2,4648
 d02fc24:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 d02fc28:	e0bff017 	ldw	r2,-64(fp)
 d02fc2c:	10800217 	ldw	r2,8(r2)
 d02fc30:	1005003a 	cmpeq	r2,r2,zero
 d02fc34:	1000051e 	bne	r2,zero,d02fc4c <tcp_input+0x15ec>
      {
         m_adj(m, -todrop);
 d02fc38:	e0bfe417 	ldw	r2,-112(fp)
 d02fc3c:	008bc83a 	sub	r5,zero,r2
 d02fc40:	e13ff017 	ldw	r4,-64(fp)
 d02fc44:	d026eb80 	call	d026eb8 <m_adj>
 d02fc48:	00000506 	br	d02fc60 <tcp_input+0x1600>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 d02fc4c:	e0bff017 	ldw	r2,-64(fp)
 d02fc50:	11000617 	ldw	r4,24(r2)
 d02fc54:	e0bfe417 	ldw	r2,-112(fp)
 d02fc58:	008bc83a 	sub	r5,zero,r2
 d02fc5c:	d026eb80 	call	d026eb8 <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 d02fc60:	e0bfed17 	ldw	r2,-76(fp)
 d02fc64:	10c0028b 	ldhu	r3,10(r2)
 d02fc68:	e0bfe417 	ldw	r2,-112(fp)
 d02fc6c:	1885c83a 	sub	r2,r3,r2
 d02fc70:	1007883a 	mov	r3,r2
 d02fc74:	e0bfed17 	ldw	r2,-76(fp)
 d02fc78:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 d02fc7c:	e0ffe617 	ldw	r3,-104(fp)
 d02fc80:	00bffd84 	movi	r2,-10
 d02fc84:	1884703a 	and	r2,r3,r2
 d02fc88:	e0bfe615 	stw	r2,-104(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 d02fc8c:	e0bfe617 	ldw	r2,-104(fp)
 d02fc90:	1080010c 	andi	r2,r2,4
 d02fc94:	1005003a 	cmpeq	r2,r2,zero
 d02fc98:	1000391e 	bne	r2,zero,d02fd80 <tcp_input+0x1720>
   {
      switch (tp->t_state) 
 d02fc9c:	e0bfe717 	ldw	r2,-100(fp)
 d02fca0:	10800217 	ldw	r2,8(r2)
 d02fca4:	10bfff44 	addi	r2,r2,-3
 d02fca8:	e0bffe15 	stw	r2,-8(fp)
 d02fcac:	e13ffe17 	ldw	r4,-8(fp)
 d02fcb0:	20800228 	cmpgeui	r2,r4,8
 d02fcb4:	1000321e 	bne	r2,zero,d02fd80 <tcp_input+0x1720>
 d02fcb8:	e0fffe17 	ldw	r3,-8(fp)
 d02fcbc:	e0fffe17 	ldw	r3,-8(fp)
 d02fcc0:	18c5883a 	add	r2,r3,r3
 d02fcc4:	1087883a 	add	r3,r2,r2
 d02fcc8:	008340f4 	movhi	r2,3331
 d02fccc:	10bf3704 	addi	r2,r2,-804
 d02fcd0:	1885883a 	add	r2,r3,r2
 d02fcd4:	10800017 	ldw	r2,0(r2)
 d02fcd8:	1000683a 	jmp	r2
 d02fcdc:	0d02fcfc 	xorhi	r20,at,3059
 d02fce0:	0d02fd0c 	andi	r20,at,3060
 d02fce4:	0d02fd28 	cmpgeui	r20,at,3060
 d02fce8:	0d02fd28 	cmpgeui	r20,at,3060
 d02fcec:	0d02fd6c 	andhi	r20,at,3061
 d02fcf0:	0d02fd6c 	andhi	r20,at,3061
 d02fcf4:	0d02fd28 	cmpgeui	r20,at,3060
 d02fcf8:	0d02fd6c 	andhi	r20,at,3061
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 d02fcfc:	e0ffe517 	ldw	r3,-108(fp)
 d02fd00:	00801bc4 	movi	r2,111
 d02fd04:	18800615 	stw	r2,24(r3)
         goto close;
 d02fd08:	00000a06 	br	d02fd34 <tcp_input+0x16d4>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 d02fd0c:	008341b4 	movhi	r2,3334
 d02fd10:	10845c04 	addi	r2,r2,4464
 d02fd14:	10800717 	ldw	r2,28(r2)
 d02fd18:	10c00044 	addi	r3,r2,1
 d02fd1c:	008341b4 	movhi	r2,3334
 d02fd20:	10845c04 	addi	r2,r2,4464
 d02fd24:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 d02fd28:	e0ffe517 	ldw	r3,-108(fp)
 d02fd2c:	00801a04 	movi	r2,104
 d02fd30:	18800615 	stw	r2,24(r3)
         close:
         tp->t_state = TCPS_CLOSED;
 d02fd34:	e0bfe717 	ldw	r2,-100(fp)
 d02fd38:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 d02fd3c:	008341b4 	movhi	r2,3334
 d02fd40:	10848a04 	addi	r2,r2,4648
 d02fd44:	10800317 	ldw	r2,12(r2)
 d02fd48:	10c00044 	addi	r3,r2,1
 d02fd4c:	008341b4 	movhi	r2,3334
 d02fd50:	10848a04 	addi	r2,r2,4648
 d02fd54:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 d02fd58:	e13fe717 	ldw	r4,-100(fp)
 d02fd5c:	d032d740 	call	d032d74 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 d02fd60:	00812204 	movi	r2,1160
 d02fd64:	d0a93015 	stw	r2,-23360(gp)
 d02fd68:	00038306 	br	d030b78 <tcp_input+0x2518>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 d02fd6c:	e13fe717 	ldw	r4,-100(fp)
 d02fd70:	d032d740 	call	d032d74 <tcp_close>
         GOTO_DROP;
 d02fd74:	00812384 	movi	r2,1166
 d02fd78:	d0a93015 	stw	r2,-23360(gp)
 d02fd7c:	00037e06 	br	d030b78 <tcp_input+0x2518>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 d02fd80:	e0bfe617 	ldw	r2,-104(fp)
 d02fd84:	1080008c 	andi	r2,r2,2
 d02fd88:	1005003a 	cmpeq	r2,r2,zero
 d02fd8c:	1000071e 	bne	r2,zero,d02fdac <tcp_input+0x174c>
   {
      tp = tcp_drop(tp, ECONNRESET);
 d02fd90:	e13fe717 	ldw	r4,-100(fp)
 d02fd94:	01401a04 	movi	r5,104
 d02fd98:	d032cc80 	call	d032cc8 <tcp_drop>
 d02fd9c:	e0bfe715 	stw	r2,-100(fp)
      GOTO_DROPWITHRESET;
 d02fda0:	00812b04 	movi	r2,1196
 d02fda4:	d0a93015 	stw	r2,-23360(gp)
 d02fda8:	00032f06 	br	d030a68 <tcp_input+0x2408>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 d02fdac:	e0bfe617 	ldw	r2,-104(fp)
 d02fdb0:	1080040c 	andi	r2,r2,16
 d02fdb4:	1004c03a 	cmpne	r2,r2,zero
 d02fdb8:	1000031e 	bne	r2,zero,d02fdc8 <tcp_input+0x1768>
      GOTO_DROP;
 d02fdbc:	00812d04 	movi	r2,1204
 d02fdc0:	d0a93015 	stw	r2,-23360(gp)
 d02fdc4:	00036c06 	br	d030b78 <tcp_input+0x2518>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 d02fdc8:	e0bfe717 	ldw	r2,-100(fp)
 d02fdcc:	10800217 	ldw	r2,8(r2)
 d02fdd0:	e0bff715 	stw	r2,-36(fp)
 d02fdd4:	e13ff717 	ldw	r4,-36(fp)
 d02fdd8:	208000e0 	cmpeqi	r2,r4,3
 d02fddc:	1000071e 	bne	r2,zero,d02fdfc <tcp_input+0x179c>
 d02fde0:	e0fff717 	ldw	r3,-36(fp)
 d02fde4:	188000d0 	cmplti	r2,r3,3
 d02fde8:	1001941e 	bne	r2,zero,d03043c <tcp_input+0x1ddc>
 d02fdec:	e13ff717 	ldw	r4,-36(fp)
 d02fdf0:	208002c8 	cmpgei	r2,r4,11
 d02fdf4:	1001911e 	bne	r2,zero,d03043c <tcp_input+0x1ddc>
 d02fdf8:	00003206 	br	d02fec4 <tcp_input+0x1864>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 d02fdfc:	e0bfe717 	ldw	r2,-100(fp)
 d02fe00:	10c00e17 	ldw	r3,56(r2)
 d02fe04:	e0bfed17 	ldw	r2,-76(fp)
 d02fe08:	10800717 	ldw	r2,28(r2)
 d02fe0c:	1885c83a 	sub	r2,r3,r2
 d02fe10:	10800048 	cmpgei	r2,r2,1
 d02fe14:	1000071e 	bne	r2,zero,d02fe34 <tcp_input+0x17d4>
 d02fe18:	e0bfed17 	ldw	r2,-76(fp)
 d02fe1c:	10c00717 	ldw	r3,28(r2)
 d02fe20:	e0bfe717 	ldw	r2,-100(fp)
 d02fe24:	10801a17 	ldw	r2,104(r2)
 d02fe28:	1885c83a 	sub	r2,r3,r2
 d02fe2c:	10800050 	cmplti	r2,r2,1
 d02fe30:	10000a1e 	bne	r2,zero,d02fe5c <tcp_input+0x17fc>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 d02fe34:	008341b4 	movhi	r2,3334
 d02fe38:	10845c04 	addi	r2,r2,4464
 d02fe3c:	10800717 	ldw	r2,28(r2)
 d02fe40:	10c00044 	addi	r3,r2,1
 d02fe44:	008341b4 	movhi	r2,3334
 d02fe48:	10845c04 	addi	r2,r2,4464
 d02fe4c:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 d02fe50:	00813184 	movi	r2,1222
 d02fe54:	d0a93015 	stw	r2,-23360(gp)
 d02fe58:	00030306 	br	d030a68 <tcp_input+0x2408>
      }
      tcpstat.tcps_connects++;
 d02fe5c:	008341b4 	movhi	r2,3334
 d02fe60:	10848a04 	addi	r2,r2,4648
 d02fe64:	10800217 	ldw	r2,8(r2)
 d02fe68:	10c00044 	addi	r3,r2,1
 d02fe6c:	008341b4 	movhi	r2,3334
 d02fe70:	10848a04 	addi	r2,r2,4648
 d02fe74:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 d02fe78:	e0ffe717 	ldw	r3,-100(fp)
 d02fe7c:	00800104 	movi	r2,4
 d02fe80:	18800215 	stw	r2,8(r3)
      soisconnected(so);
 d02fe84:	e13fe517 	ldw	r4,-108(fp)
 d02fe88:	d02c6900 	call	d02c690 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 d02fe8c:	e13fe517 	ldw	r4,-108(fp)
 d02fe90:	d03112c0 	call	d03112c <tcp_mss>
 d02fe94:	1007883a 	mov	r3,r2
 d02fe98:	e0bfe717 	ldw	r2,-100(fp)
 d02fe9c:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 d02fea0:	e13fe717 	ldw	r4,-100(fp)
 d02fea4:	000b883a 	mov	r5,zero
 d02fea8:	e1bff017 	ldw	r6,-64(fp)
 d02feac:	d02e2580 	call	d02e258 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 d02feb0:	e0bfed17 	ldw	r2,-76(fp)
 d02feb4:	10800617 	ldw	r2,24(r2)
 d02feb8:	10ffffc4 	addi	r3,r2,-1
 d02febc:	e0bfe717 	ldw	r2,-100(fp)
 d02fec0:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 d02fec4:	e0bfed17 	ldw	r2,-76(fp)
 d02fec8:	10c00717 	ldw	r3,28(r2)
 d02fecc:	e0bfe717 	ldw	r2,-100(fp)
 d02fed0:	10800e17 	ldw	r2,56(r2)
 d02fed4:	1885c83a 	sub	r2,r3,r2
 d02fed8:	10800048 	cmpgei	r2,r2,1
 d02fedc:	1000691e 	bne	r2,zero,d030084 <tcp_input+0x1a24>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 d02fee0:	e0bfed17 	ldw	r2,-76(fp)
 d02fee4:	1080028b 	ldhu	r2,10(r2)
 d02fee8:	10bfffcc 	andi	r2,r2,65535
 d02feec:	1004c03a 	cmpne	r2,r2,zero
 d02fef0:	1000611e 	bne	r2,zero,d030078 <tcp_input+0x1a18>
 d02fef4:	e0bfe717 	ldw	r2,-100(fp)
 d02fef8:	10c01417 	ldw	r3,80(r2)
 d02fefc:	e0bfde17 	ldw	r2,-136(fp)
 d02ff00:	18805d1e 	bne	r3,r2,d030078 <tcp_input+0x1a18>
         {
            tcpstat.tcps_rcvdupack++;
 d02ff04:	008341b4 	movhi	r2,3334
 d02ff08:	10848a04 	addi	r2,r2,4648
 d02ff0c:	10802917 	ldw	r2,164(r2)
 d02ff10:	10c00044 	addi	r3,r2,1
 d02ff14:	008341b4 	movhi	r2,3334
 d02ff18:	10848a04 	addi	r2,r2,4648
 d02ff1c:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 d02ff20:	e0bfe717 	ldw	r2,-100(fp)
 d02ff24:	10800317 	ldw	r2,12(r2)
 d02ff28:	1005003a 	cmpeq	r2,r2,zero
 d02ff2c:	1000051e 	bne	r2,zero,d02ff44 <tcp_input+0x18e4>
 d02ff30:	e0bfed17 	ldw	r2,-76(fp)
 d02ff34:	10c00717 	ldw	r3,28(r2)
 d02ff38:	e0bfe717 	ldw	r2,-100(fp)
 d02ff3c:	10800e17 	ldw	r2,56(r2)
 d02ff40:	18800326 	beq	r3,r2,d02ff50 <tcp_input+0x18f0>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 d02ff44:	e0bfe717 	ldw	r2,-100(fp)
 d02ff48:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 d02ff4c:	00013b06 	br	d03043c <tcp_input+0x1ddc>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 d02ff50:	e0bfe717 	ldw	r2,-100(fp)
 d02ff54:	10800917 	ldw	r2,36(r2)
 d02ff58:	10c00044 	addi	r3,r2,1
 d02ff5c:	e0bfe717 	ldw	r2,-100(fp)
 d02ff60:	10c00915 	stw	r3,36(r2)
 d02ff64:	e0bfe717 	ldw	r2,-100(fp)
 d02ff68:	10c00917 	ldw	r3,36(r2)
 d02ff6c:	d0a03b83 	ldbu	r2,-32530(gp)
 d02ff70:	10803fcc 	andi	r2,r2,255
 d02ff74:	1080201c 	xori	r2,r2,128
 d02ff78:	10bfe004 	addi	r2,r2,-128
 d02ff7c:	18812f1e 	bne	r3,r2,d03043c <tcp_input+0x1ddc>
            {
               tcp_seq onxt = tp->snd_nxt;
 d02ff80:	e0bfe717 	ldw	r2,-100(fp)
 d02ff84:	10800f17 	ldw	r2,60(r2)
 d02ff88:	e0bfd715 	stw	r2,-164(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;
 d02ff8c:	e0bfe717 	ldw	r2,-100(fp)
 d02ff90:	10c01417 	ldw	r3,80(r2)
 d02ff94:	e0bfe717 	ldw	r2,-100(fp)
 d02ff98:	10801b17 	ldw	r2,108(r2)
 d02ff9c:	e0bff615 	stw	r2,-40(fp)
 d02ffa0:	e0fff515 	stw	r3,-44(fp)
 d02ffa4:	e0bff617 	ldw	r2,-40(fp)
 d02ffa8:	e0fff517 	ldw	r3,-44(fp)
 d02ffac:	10c0022e 	bgeu	r2,r3,d02ffb8 <tcp_input+0x1958>
 d02ffb0:	e13ff617 	ldw	r4,-40(fp)
 d02ffb4:	e13ff515 	stw	r4,-44(fp)
 d02ffb8:	e0bff517 	ldw	r2,-44(fp)
 d02ffbc:	1008d07a 	srli	r4,r2,1
 d02ffc0:	e0bfe717 	ldw	r2,-100(fp)
 d02ffc4:	10800a0b 	ldhu	r2,40(r2)
 d02ffc8:	117fffcc 	andi	r5,r2,65535
 d02ffcc:	d00c90c0 	call	d00c90c <__udivsi3>
 d02ffd0:	e0bfd60d 	sth	r2,-168(fp)

               if (win < 2)
 d02ffd4:	e0bfd60b 	ldhu	r2,-168(fp)
 d02ffd8:	108000a8 	cmpgeui	r2,r2,2
 d02ffdc:	1000021e 	bne	r2,zero,d02ffe8 <tcp_input+0x1988>
                  win = 2;
 d02ffe0:	00800084 	movi	r2,2
 d02ffe4:	e0bfd60d 	sth	r2,-168(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 d02ffe8:	e0bfe717 	ldw	r2,-100(fp)
 d02ffec:	10800a0b 	ldhu	r2,40(r2)
 d02fff0:	e0ffd60b 	ldhu	r3,-168(fp)
 d02fff4:	1009883a 	mov	r4,r2
 d02fff8:	180b883a 	mov	r5,r3
 d02fffc:	d00235c0 	call	d00235c <__mulsi3>
 d030000:	10ffffcc 	andi	r3,r2,65535
 d030004:	e0bfe717 	ldw	r2,-100(fp)
 d030008:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 d03000c:	e0bfe717 	ldw	r2,-100(fp)
 d030010:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 d030014:	e0bfe717 	ldw	r2,-100(fp)
 d030018:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 d03001c:	e0bfed17 	ldw	r2,-76(fp)
 d030020:	10c00717 	ldw	r3,28(r2)
 d030024:	e0bfe717 	ldw	r2,-100(fp)
 d030028:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 d03002c:	e0bfe717 	ldw	r2,-100(fp)
 d030030:	10800a0b 	ldhu	r2,40(r2)
 d030034:	10ffffcc 	andi	r3,r2,65535
 d030038:	e0bfe717 	ldw	r2,-100(fp)
 d03003c:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 d030040:	e13fe717 	ldw	r4,-100(fp)
 d030044:	d0312480 	call	d031248 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 d030048:	e0bfe717 	ldw	r2,-100(fp)
 d03004c:	10c00f17 	ldw	r3,60(r2)
 d030050:	e0bfd717 	ldw	r2,-164(fp)
 d030054:	10c5c83a 	sub	r2,r2,r3
 d030058:	10800050 	cmplti	r2,r2,1
 d03005c:	1000031e 	bne	r2,zero,d03006c <tcp_input+0x1a0c>
                  tp->snd_nxt = onxt;
 d030060:	e0ffe717 	ldw	r3,-100(fp)
 d030064:	e0bfd717 	ldw	r2,-164(fp)
 d030068:	18800f15 	stw	r2,60(r3)
               GOTO_DROP;
 d03006c:	00814544 	movi	r2,1301
 d030070:	d0a93015 	stw	r2,-23360(gp)
 d030074:	0002c006 	br	d030b78 <tcp_input+0x2518>
            }
         } else
            tp->t_dupacks = 0;
 d030078:	e0bfe717 	ldw	r2,-100(fp)
 d03007c:	10000915 	stw	zero,36(r2)
         break;
 d030080:	0000ee06 	br	d03043c <tcp_input+0x1ddc>
      }
      tp->t_dupacks = 0;
 d030084:	e0bfe717 	ldw	r2,-100(fp)
 d030088:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 d03008c:	e0bfed17 	ldw	r2,-76(fp)
 d030090:	10c00717 	ldw	r3,28(r2)
 d030094:	e0bfe717 	ldw	r2,-100(fp)
 d030098:	10801a17 	ldw	r2,104(r2)
 d03009c:	1885c83a 	sub	r2,r3,r2
 d0300a0:	10800050 	cmplti	r2,r2,1
 d0300a4:	1000081e 	bne	r2,zero,d0300c8 <tcp_input+0x1a68>
      {
         tcpstat.tcps_rcvacktoomuch++;
 d0300a8:	008341b4 	movhi	r2,3334
 d0300ac:	10848a04 	addi	r2,r2,4648
 d0300b0:	10802a17 	ldw	r2,168(r2)
 d0300b4:	10c00044 	addi	r3,r2,1
 d0300b8:	008341b4 	movhi	r2,3334
 d0300bc:	10848a04 	addi	r2,r2,4648
 d0300c0:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 d0300c4:	00025606 	br	d030a20 <tcp_input+0x23c0>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 d0300c8:	e0bfed17 	ldw	r2,-76(fp)
 d0300cc:	10c00717 	ldw	r3,28(r2)
 d0300d0:	e0bfe717 	ldw	r2,-100(fp)
 d0300d4:	10800e17 	ldw	r2,56(r2)
 d0300d8:	1885c83a 	sub	r2,r3,r2
 d0300dc:	e0bfe315 	stw	r2,-116(fp)
      tcpstat.tcps_rcvackpack++;
 d0300e0:	008341b4 	movhi	r2,3334
 d0300e4:	10848a04 	addi	r2,r2,4648
 d0300e8:	10802b17 	ldw	r2,172(r2)
 d0300ec:	10c00044 	addi	r3,r2,1
 d0300f0:	008341b4 	movhi	r2,3334
 d0300f4:	10848a04 	addi	r2,r2,4648
 d0300f8:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 d0300fc:	008341b4 	movhi	r2,3334
 d030100:	10848a04 	addi	r2,r2,4648
 d030104:	10c02c17 	ldw	r3,176(r2)
 d030108:	e0bfe317 	ldw	r2,-116(fp)
 d03010c:	1887883a 	add	r3,r3,r2
 d030110:	008341b4 	movhi	r2,3334
 d030114:	10848a04 	addi	r2,r2,4648
 d030118:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 d03011c:	e0bfe717 	ldw	r2,-100(fp)
 d030120:	10801e17 	ldw	r2,120(r2)
 d030124:	1005003a 	cmpeq	r2,r2,zero
 d030128:	1000091e 	bne	r2,zero,d030150 <tcp_input+0x1af0>
 d03012c:	e0bfed17 	ldw	r2,-76(fp)
 d030130:	10c00717 	ldw	r3,28(r2)
 d030134:	e0bfe717 	ldw	r2,-100(fp)
 d030138:	10801f17 	ldw	r2,124(r2)
 d03013c:	1885c83a 	sub	r2,r3,r2
 d030140:	10800050 	cmplti	r2,r2,1
 d030144:	1000021e 	bne	r2,zero,d030150 <tcp_input+0x1af0>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 d030148:	e13fe717 	ldw	r4,-100(fp)
 d03014c:	d030e780 	call	d030e78 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 d030150:	e0bfed17 	ldw	r2,-76(fp)
 d030154:	10c00717 	ldw	r3,28(r2)
 d030158:	e0bfe717 	ldw	r2,-100(fp)
 d03015c:	10801a17 	ldw	r2,104(r2)
 d030160:	1880051e 	bne	r3,r2,d030178 <tcp_input+0x1b18>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 d030164:	e0bfe717 	ldw	r2,-100(fp)
 d030168:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 d03016c:	00800044 	movi	r2,1
 d030170:	e0bfe115 	stw	r2,-124(fp)
 d030174:	00000806 	br	d030198 <tcp_input+0x1b38>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 d030178:	e0bfe717 	ldw	r2,-100(fp)
 d03017c:	10800417 	ldw	r2,16(r2)
 d030180:	1004c03a 	cmpne	r2,r2,zero
 d030184:	1000041e 	bne	r2,zero,d030198 <tcp_input+0x1b38>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d030188:	e0bfe717 	ldw	r2,-100(fp)
 d03018c:	10c00817 	ldw	r3,32(r2)
 d030190:	e0bfe717 	ldw	r2,-100(fp)
 d030194:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 d030198:	e0bfe717 	ldw	r2,-100(fp)
 d03019c:	10801b17 	ldw	r2,108(r2)
 d0301a0:	e0bfd515 	stw	r2,-172(fp)
         u_short  incr  =  tp->t_maxseg;
 d0301a4:	e0bfe717 	ldw	r2,-100(fp)
 d0301a8:	10800a0b 	ldhu	r2,40(r2)
 d0301ac:	e0bfd40d 	sth	r2,-176(fp)

         if (cw > tp->snd_ssthresh)
 d0301b0:	e0bfe717 	ldw	r2,-100(fp)
 d0301b4:	10c01c17 	ldw	r3,112(r2)
 d0301b8:	e0bfd517 	ldw	r2,-172(fp)
 d0301bc:	18800e2e 	bgeu	r3,r2,d0301f8 <tcp_input+0x1b98>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 d0301c0:	e13fd40b 	ldhu	r4,-176(fp)
 d0301c4:	e17fd40b 	ldhu	r5,-176(fp)
 d0301c8:	d00235c0 	call	d00235c <__mulsi3>
 d0301cc:	1009883a 	mov	r4,r2
 d0301d0:	e17fd517 	ldw	r5,-172(fp)
 d0301d4:	d00c90c0 	call	d00c90c <__udivsi3>
 d0301d8:	e0bff415 	stw	r2,-48(fp)
 d0301dc:	e0fff417 	ldw	r3,-48(fp)
 d0301e0:	18800428 	cmpgeui	r2,r3,16
 d0301e4:	1000021e 	bne	r2,zero,d0301f0 <tcp_input+0x1b90>
 d0301e8:	01000404 	movi	r4,16
 d0301ec:	e13ff415 	stw	r4,-48(fp)
 d0301f0:	e0bff417 	ldw	r2,-48(fp)
 d0301f4:	e0bfd40d 	sth	r2,-176(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 d0301f8:	e0ffd40b 	ldhu	r3,-176(fp)
 d0301fc:	e0bfd517 	ldw	r2,-172(fp)
 d030200:	1885883a 	add	r2,r3,r2
 d030204:	e0bff315 	stw	r2,-52(fp)
 d030208:	e0fff317 	ldw	r3,-52(fp)
 d03020c:	18980070 	cmpltui	r2,r3,24577
 d030210:	1000021e 	bne	r2,zero,d03021c <tcp_input+0x1bbc>
 d030214:	01180004 	movi	r4,24576
 d030218:	e13ff315 	stw	r4,-52(fp)
 d03021c:	e0bfe717 	ldw	r2,-100(fp)
 d030220:	e0fff317 	ldw	r3,-52(fp)
 d030224:	10c01b15 	stw	r3,108(r2)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 d030228:	e0bfe517 	ldw	r2,-108(fp)
 d03022c:	10801217 	ldw	r2,72(r2)
 d030230:	1007883a 	mov	r3,r2
 d030234:	e0bfe317 	ldw	r2,-116(fp)
 d030238:	1880110e 	bge	r3,r2,d030280 <tcp_input+0x1c20>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 d03023c:	e0bfe717 	ldw	r2,-100(fp)
 d030240:	10c01417 	ldw	r3,80(r2)
 d030244:	e0bfe517 	ldw	r2,-108(fp)
 d030248:	10801217 	ldw	r2,72(r2)
 d03024c:	10bfffcc 	andi	r2,r2,65535
 d030250:	1887c83a 	sub	r3,r3,r2
 d030254:	e0bfe717 	ldw	r2,-100(fp)
 d030258:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 d03025c:	e0bfe517 	ldw	r2,-108(fp)
 d030260:	11001204 	addi	r4,r2,72
 d030264:	e0bfe517 	ldw	r2,-108(fp)
 d030268:	10801217 	ldw	r2,72(r2)
 d03026c:	100b883a 	mov	r5,r2
 d030270:	d02d5c80 	call	d02d5c8 <sbdrop>
         ourfinisacked = 1;
 d030274:	00800044 	movi	r2,1
 d030278:	e0bfe215 	stw	r2,-120(fp)
 d03027c:	00000c06 	br	d0302b0 <tcp_input+0x1c50>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 d030280:	e0bfe517 	ldw	r2,-108(fp)
 d030284:	11001204 	addi	r4,r2,72
 d030288:	e17fe317 	ldw	r5,-116(fp)
 d03028c:	d02d5c80 	call	d02d5c8 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 d030290:	e0bfe717 	ldw	r2,-100(fp)
 d030294:	10c01417 	ldw	r3,80(r2)
 d030298:	e0bfe317 	ldw	r2,-116(fp)
 d03029c:	10bfffcc 	andi	r2,r2,65535
 d0302a0:	1887c83a 	sub	r3,r3,r2
 d0302a4:	e0bfe717 	ldw	r2,-100(fp)
 d0302a8:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 d0302ac:	e03fe215 	stw	zero,-120(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 d0302b0:	e0bfe517 	ldw	r2,-108(fp)
 d0302b4:	1080190b 	ldhu	r2,100(r2)
 d0302b8:	10bfffcc 	andi	r2,r2,65535
 d0302bc:	1080030c 	andi	r2,r2,12
 d0302c0:	1005003a 	cmpeq	r2,r2,zero
 d0302c4:	1000041e 	bne	r2,zero,d0302d8 <tcp_input+0x1c78>
         sowwakeup(so);
 d0302c8:	e0bfe517 	ldw	r2,-108(fp)
 d0302cc:	11401204 	addi	r5,r2,72
 d0302d0:	e13fe517 	ldw	r4,-108(fp)
 d0302d4:	d02cdfc0 	call	d02cdfc <sbwakeup>

      tp->snd_una = ti->ti_ack;
 d0302d8:	e0bfed17 	ldw	r2,-76(fp)
 d0302dc:	10c00717 	ldw	r3,28(r2)
 d0302e0:	e0bfe717 	ldw	r2,-100(fp)
 d0302e4:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 d0302e8:	e0bfe717 	ldw	r2,-100(fp)
 d0302ec:	10c00f17 	ldw	r3,60(r2)
 d0302f0:	e0bfe717 	ldw	r2,-100(fp)
 d0302f4:	10800e17 	ldw	r2,56(r2)
 d0302f8:	1885c83a 	sub	r2,r3,r2
 d0302fc:	1004403a 	cmpge	r2,r2,zero
 d030300:	1000041e 	bne	r2,zero,d030314 <tcp_input+0x1cb4>
         tp->snd_nxt = tp->snd_una;
 d030304:	e0bfe717 	ldw	r2,-100(fp)
 d030308:	10c00e17 	ldw	r3,56(r2)
 d03030c:	e0bfe717 	ldw	r2,-100(fp)
 d030310:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 d030314:	e0bfe717 	ldw	r2,-100(fp)
 d030318:	10800217 	ldw	r2,8(r2)
 d03031c:	e0bff215 	stw	r2,-56(fp)
 d030320:	e13ff217 	ldw	r4,-56(fp)
 d030324:	208001e0 	cmpeqi	r2,r4,7
 d030328:	1000221e 	bne	r2,zero,d0303b4 <tcp_input+0x1d54>
 d03032c:	e0fff217 	ldw	r3,-56(fp)
 d030330:	18800208 	cmpgei	r2,r3,8
 d030334:	1000041e 	bne	r2,zero,d030348 <tcp_input+0x1ce8>
 d030338:	e13ff217 	ldw	r4,-56(fp)
 d03033c:	208001a0 	cmpeqi	r2,r4,6
 d030340:	1000081e 	bne	r2,zero,d030364 <tcp_input+0x1d04>
 d030344:	00003d06 	br	d03043c <tcp_input+0x1ddc>
 d030348:	e0fff217 	ldw	r3,-56(fp)
 d03034c:	18800220 	cmpeqi	r2,r3,8
 d030350:	10002a1e 	bne	r2,zero,d0303fc <tcp_input+0x1d9c>
 d030354:	e13ff217 	ldw	r4,-56(fp)
 d030358:	208002a0 	cmpeqi	r2,r4,10
 d03035c:	10002f1e 	bne	r2,zero,d03041c <tcp_input+0x1dbc>
 d030360:	00003606 	br	d03043c <tcp_input+0x1ddc>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 d030364:	e0bfe217 	ldw	r2,-120(fp)
 d030368:	1005003a 	cmpeq	r2,r2,zero
 d03036c:	1000331e 	bne	r2,zero,d03043c <tcp_input+0x1ddc>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 d030370:	e0bfe517 	ldw	r2,-108(fp)
 d030374:	1080088b 	ldhu	r2,34(r2)
 d030378:	10bfffcc 	andi	r2,r2,65535
 d03037c:	1080080c 	andi	r2,r2,32
 d030380:	1005003a 	cmpeq	r2,r2,zero
 d030384:	1000071e 	bne	r2,zero,d0303a4 <tcp_input+0x1d44>
            {
               soisdisconnected(so);
 d030388:	e13fe517 	ldw	r4,-108(fp)
 d03038c:	d02c8180 	call	d02c818 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 d030390:	00834174 	movhi	r2,3333
 d030394:	109b5104 	addi	r2,r2,27972
 d030398:	10c00017 	ldw	r3,0(r2)
 d03039c:	e0bfe717 	ldw	r2,-100(fp)
 d0303a0:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 d0303a4:	e0ffe717 	ldw	r3,-100(fp)
 d0303a8:	00800244 	movi	r2,9
 d0303ac:	18800215 	stw	r2,8(r3)
         }
         break;
 d0303b0:	00002206 	br	d03043c <tcp_input+0x1ddc>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 d0303b4:	e0bfe217 	ldw	r2,-120(fp)
 d0303b8:	1005003a 	cmpeq	r2,r2,zero
 d0303bc:	10001f1e 	bne	r2,zero,d03043c <tcp_input+0x1ddc>
         {
            tp->t_state = TCPS_TIME_WAIT;
 d0303c0:	e0ffe717 	ldw	r3,-100(fp)
 d0303c4:	00800284 	movi	r2,10
 d0303c8:	18800215 	stw	r2,8(r3)
            tcp_canceltimers(tp);
 d0303cc:	e13fe717 	ldw	r4,-100(fp)
 d0303d0:	d0332400 	call	d033240 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d0303d4:	00834174 	movhi	r2,3333
 d0303d8:	10925904 	addi	r2,r2,18788
 d0303dc:	10800017 	ldw	r2,0(r2)
 d0303e0:	1085883a 	add	r2,r2,r2
 d0303e4:	1007883a 	mov	r3,r2
 d0303e8:	e0bfe717 	ldw	r2,-100(fp)
 d0303ec:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 d0303f0:	e13fe517 	ldw	r4,-108(fp)
 d0303f4:	d02c8180 	call	d02c818 <soisdisconnected>
         }
         break;
 d0303f8:	00001006 	br	d03043c <tcp_input+0x1ddc>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 d0303fc:	e0bfe217 	ldw	r2,-120(fp)
 d030400:	1005003a 	cmpeq	r2,r2,zero
 d030404:	10000d1e 	bne	r2,zero,d03043c <tcp_input+0x1ddc>
         {
            SETTP(tp, tcp_close(tp));
 d030408:	e13fe717 	ldw	r4,-100(fp)
 d03040c:	d032d740 	call	d032d74 <tcp_close>
            GOTO_DROP;
 d030410:	00816644 	movi	r2,1433
 d030414:	d0a93015 	stw	r2,-23360(gp)
 d030418:	0001d706 	br	d030b78 <tcp_input+0x2518>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d03041c:	00834174 	movhi	r2,3333
 d030420:	10925904 	addi	r2,r2,18788
 d030424:	10800017 	ldw	r2,0(r2)
 d030428:	1085883a 	add	r2,r2,r2
 d03042c:	1007883a 	mov	r3,r2
 d030430:	e0bfe717 	ldw	r2,-100(fp)
 d030434:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 d030438:	00017906 	br	d030a20 <tcp_input+0x23c0>
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 d03043c:	e0bfe617 	ldw	r2,-104(fp)
 d030440:	1080040c 	andi	r2,r2,16
 d030444:	1005003a 	cmpeq	r2,r2,zero
 d030448:	1000471e 	bne	r2,zero,d030568 <tcp_input+0x1f08>
 d03044c:	e0bfe717 	ldw	r2,-100(fp)
 d030450:	10c01117 	ldw	r3,68(r2)
 d030454:	e0bfed17 	ldw	r2,-76(fp)
 d030458:	10800617 	ldw	r2,24(r2)
 d03045c:	1885c83a 	sub	r2,r3,r2
 d030460:	1004803a 	cmplt	r2,r2,zero
 d030464:	1000151e 	bne	r2,zero,d0304bc <tcp_input+0x1e5c>
 d030468:	e0bfe717 	ldw	r2,-100(fp)
 d03046c:	10c01117 	ldw	r3,68(r2)
 d030470:	e0bfed17 	ldw	r2,-76(fp)
 d030474:	10800617 	ldw	r2,24(r2)
 d030478:	18803b1e 	bne	r3,r2,d030568 <tcp_input+0x1f08>
 d03047c:	e0bfe717 	ldw	r2,-100(fp)
 d030480:	10c01217 	ldw	r3,72(r2)
 d030484:	e0bfed17 	ldw	r2,-76(fp)
 d030488:	10800717 	ldw	r2,28(r2)
 d03048c:	1885c83a 	sub	r2,r3,r2
 d030490:	1004803a 	cmplt	r2,r2,zero
 d030494:	1000091e 	bne	r2,zero,d0304bc <tcp_input+0x1e5c>
 d030498:	e0bfe717 	ldw	r2,-100(fp)
 d03049c:	10c01217 	ldw	r3,72(r2)
 d0304a0:	e0bfed17 	ldw	r2,-76(fp)
 d0304a4:	10800717 	ldw	r2,28(r2)
 d0304a8:	18802f1e 	bne	r3,r2,d030568 <tcp_input+0x1f08>
 d0304ac:	e0bfe717 	ldw	r2,-100(fp)
 d0304b0:	10c01417 	ldw	r3,80(r2)
 d0304b4:	e0bfde17 	ldw	r2,-136(fp)
 d0304b8:	18802b2e 	bgeu	r3,r2,d030568 <tcp_input+0x1f08>
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 d0304bc:	e0bfed17 	ldw	r2,-76(fp)
 d0304c0:	1080028b 	ldhu	r2,10(r2)
 d0304c4:	10bfffcc 	andi	r2,r2,65535
 d0304c8:	1004c03a 	cmpne	r2,r2,zero
 d0304cc:	1000101e 	bne	r2,zero,d030510 <tcp_input+0x1eb0>
 d0304d0:	e0bfe717 	ldw	r2,-100(fp)
 d0304d4:	10c01217 	ldw	r3,72(r2)
 d0304d8:	e0bfed17 	ldw	r2,-76(fp)
 d0304dc:	10800717 	ldw	r2,28(r2)
 d0304e0:	18800b1e 	bne	r3,r2,d030510 <tcp_input+0x1eb0>
 d0304e4:	e0bfe717 	ldw	r2,-100(fp)
 d0304e8:	10c01417 	ldw	r3,80(r2)
 d0304ec:	e0bfde17 	ldw	r2,-136(fp)
 d0304f0:	1880072e 	bgeu	r3,r2,d030510 <tcp_input+0x1eb0>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 d0304f4:	008341b4 	movhi	r2,3334
 d0304f8:	10848a04 	addi	r2,r2,4648
 d0304fc:	10802d17 	ldw	r2,180(r2)
 d030500:	10c00044 	addi	r3,r2,1
 d030504:	008341b4 	movhi	r2,3334
 d030508:	10848a04 	addi	r2,r2,4648
 d03050c:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 d030510:	e0ffe717 	ldw	r3,-100(fp)
 d030514:	e0bfde17 	ldw	r2,-136(fp)
 d030518:	18801415 	stw	r2,80(r3)
      tp->snd_wl1 = ti->ti_seq;
 d03051c:	e0bfed17 	ldw	r2,-76(fp)
 d030520:	10c00617 	ldw	r3,24(r2)
 d030524:	e0bfe717 	ldw	r2,-100(fp)
 d030528:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 d03052c:	e0bfed17 	ldw	r2,-76(fp)
 d030530:	10c00717 	ldw	r3,28(r2)
 d030534:	e0bfe717 	ldw	r2,-100(fp)
 d030538:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 d03053c:	e0bfe717 	ldw	r2,-100(fp)
 d030540:	10c01417 	ldw	r3,80(r2)
 d030544:	e0bfe717 	ldw	r2,-100(fp)
 d030548:	10802317 	ldw	r2,140(r2)
 d03054c:	10c0042e 	bgeu	r2,r3,d030560 <tcp_input+0x1f00>
         tp->max_sndwnd = tp->snd_wnd;
 d030550:	e0bfe717 	ldw	r2,-100(fp)
 d030554:	10c01417 	ldw	r3,80(r2)
 d030558:	e0bfe717 	ldw	r2,-100(fp)
 d03055c:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 d030560:	00800044 	movi	r2,1
 d030564:	e0bfe115 	stw	r2,-124(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 d030568:	e0bfe617 	ldw	r2,-104(fp)
 d03056c:	1080080c 	andi	r2,r2,32
 d030570:	1005003a 	cmpeq	r2,r2,zero
 d030574:	10005a1e 	bne	r2,zero,d0306e0 <tcp_input+0x2080>
 d030578:	e0bfed17 	ldw	r2,-76(fp)
 d03057c:	1080098b 	ldhu	r2,38(r2)
 d030580:	10bfffcc 	andi	r2,r2,65535
 d030584:	1005003a 	cmpeq	r2,r2,zero
 d030588:	1000551e 	bne	r2,zero,d0306e0 <tcp_input+0x2080>
 d03058c:	e0bfe717 	ldw	r2,-100(fp)
 d030590:	10800217 	ldw	r2,8(r2)
 d030594:	10800288 	cmpgei	r2,r2,10
 d030598:	1000511e 	bne	r2,zero,d0306e0 <tcp_input+0x2080>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 d03059c:	e0bfed17 	ldw	r2,-76(fp)
 d0305a0:	1080098b 	ldhu	r2,38(r2)
 d0305a4:	10ffffcc 	andi	r3,r2,65535
 d0305a8:	e0bfe517 	ldw	r2,-108(fp)
 d0305ac:	10800a17 	ldw	r2,40(r2)
 d0305b0:	1885883a 	add	r2,r3,r2
 d0305b4:	10900070 	cmpltui	r2,r2,16385
 d0305b8:	1000071e 	bne	r2,zero,d0305d8 <tcp_input+0x1f78>
      {
         ti->ti_urp = 0;         /* XXX */
 d0305bc:	e0bfed17 	ldw	r2,-76(fp)
 d0305c0:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 d0305c4:	e0ffe617 	ldw	r3,-104(fp)
 d0305c8:	00bff7c4 	movi	r2,-33
 d0305cc:	1884703a 	and	r2,r3,r2
 d0305d0:	e0bfe615 	stw	r2,-104(fp)
         goto dodata;         /* XXX */
 d0305d4:	00004d06 	br	d03070c <tcp_input+0x20ac>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 d0305d8:	e0bfed17 	ldw	r2,-76(fp)
 d0305dc:	10c00617 	ldw	r3,24(r2)
 d0305e0:	e0bfed17 	ldw	r2,-76(fp)
 d0305e4:	1080098b 	ldhu	r2,38(r2)
 d0305e8:	10bfffcc 	andi	r2,r2,65535
 d0305ec:	1887883a 	add	r3,r3,r2
 d0305f0:	e0bfe717 	ldw	r2,-100(fp)
 d0305f4:	10801717 	ldw	r2,92(r2)
 d0305f8:	1885c83a 	sub	r2,r3,r2
 d0305fc:	10800050 	cmplti	r2,r2,1
 d030600:	1000261e 	bne	r2,zero,d03069c <tcp_input+0x203c>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 d030604:	e0bfed17 	ldw	r2,-76(fp)
 d030608:	10c00617 	ldw	r3,24(r2)
 d03060c:	e0bfed17 	ldw	r2,-76(fp)
 d030610:	1080098b 	ldhu	r2,38(r2)
 d030614:	10bfffcc 	andi	r2,r2,65535
 d030618:	1887883a 	add	r3,r3,r2
 d03061c:	e0bfe717 	ldw	r2,-100(fp)
 d030620:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 d030624:	e0bfe517 	ldw	r2,-108(fp)
 d030628:	11000a17 	ldw	r4,40(r2)
 d03062c:	e0bfe717 	ldw	r2,-100(fp)
 d030630:	10c01717 	ldw	r3,92(r2)
 d030634:	e0bfe717 	ldw	r2,-100(fp)
 d030638:	10801617 	ldw	r2,88(r2)
 d03063c:	1885c83a 	sub	r2,r3,r2
 d030640:	2085883a 	add	r2,r4,r2
 d030644:	10ffffc4 	addi	r3,r2,-1
 d030648:	e0bfe517 	ldw	r2,-108(fp)
 d03064c:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 d030650:	e0bfe517 	ldw	r2,-108(fp)
 d030654:	10801a17 	ldw	r2,104(r2)
 d030658:	1004c03a 	cmpne	r2,r2,zero
 d03065c:	1000061e 	bne	r2,zero,d030678 <tcp_input+0x2018>
            so->so_state |= SS_RCVATMARK;
 d030660:	e0bfe517 	ldw	r2,-108(fp)
 d030664:	1080088b 	ldhu	r2,34(r2)
 d030668:	10801014 	ori	r2,r2,64
 d03066c:	1007883a 	mov	r3,r2
 d030670:	e0bfe517 	ldw	r2,-108(fp)
 d030674:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 d030678:	e13fe517 	ldw	r4,-108(fp)
 d03067c:	d02c5e00 	call	d02c5e0 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 d030680:	e0bfe717 	ldw	r2,-100(fp)
 d030684:	10c02403 	ldbu	r3,144(r2)
 d030688:	00bfff04 	movi	r2,-4
 d03068c:	1884703a 	and	r2,r3,r2
 d030690:	1007883a 	mov	r3,r2
 d030694:	e0bfe717 	ldw	r2,-100(fp)
 d030698:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 d03069c:	e0bfed17 	ldw	r2,-76(fp)
 d0306a0:	10c0098b 	ldhu	r3,38(r2)
 d0306a4:	e0bfed17 	ldw	r2,-76(fp)
 d0306a8:	1080028b 	ldhu	r2,10(r2)
 d0306ac:	18ffffcc 	andi	r3,r3,65535
 d0306b0:	10bfffcc 	andi	r2,r2,65535
 d0306b4:	10c01536 	bltu	r2,r3,d03070c <tcp_input+0x20ac>
 d0306b8:	e0bfe517 	ldw	r2,-108(fp)
 d0306bc:	10800417 	ldw	r2,16(r2)
 d0306c0:	1080400c 	andi	r2,r2,256
 d0306c4:	1004c03a 	cmpne	r2,r2,zero
 d0306c8:	1000101e 	bne	r2,zero,d03070c <tcp_input+0x20ac>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 d0306cc:	e13fe517 	ldw	r4,-108(fp)
 d0306d0:	e17fed17 	ldw	r5,-76(fp)
 d0306d4:	e1bff017 	ldw	r6,-64(fp)
 d0306d8:	d030d4c0 	call	d030d4c <tcp_pulloutofband>
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 d0306dc:	00000b06 	br	d03070c <tcp_input+0x20ac>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 d0306e0:	e0bfe717 	ldw	r2,-100(fp)
 d0306e4:	10c01617 	ldw	r3,88(r2)
 d0306e8:	e0bfe717 	ldw	r2,-100(fp)
 d0306ec:	10801717 	ldw	r2,92(r2)
 d0306f0:	1885c83a 	sub	r2,r3,r2
 d0306f4:	10800050 	cmplti	r2,r2,1
 d0306f8:	1000041e 	bne	r2,zero,d03070c <tcp_input+0x20ac>
      tp->rcv_up = tp->rcv_nxt;
 d0306fc:	e0bfe717 	ldw	r2,-100(fp)
 d030700:	10c01617 	ldw	r3,88(r2)
 d030704:	e0bfe717 	ldw	r2,-100(fp)
 d030708:	10c01715 	stw	r3,92(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 d03070c:	e0bfed17 	ldw	r2,-76(fp)
 d030710:	1080028b 	ldhu	r2,10(r2)
 d030714:	10bfffcc 	andi	r2,r2,65535
 d030718:	1004c03a 	cmpne	r2,r2,zero
 d03071c:	1000051e 	bne	r2,zero,d030734 <tcp_input+0x20d4>
 d030720:	e0bfe617 	ldw	r2,-104(fp)
 d030724:	1080004c 	andi	r2,r2,1
 d030728:	10803fcc 	andi	r2,r2,255
 d03072c:	1005003a 	cmpeq	r2,r2,zero
 d030730:	10005c1e 	bne	r2,zero,d0308a4 <tcp_input+0x2244>
 d030734:	e0bfe717 	ldw	r2,-100(fp)
 d030738:	10800217 	ldw	r2,8(r2)
 d03073c:	10800288 	cmpgei	r2,r2,10
 d030740:	1000581e 	bne	r2,zero,d0308a4 <tcp_input+0x2244>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 d030744:	e0bfed17 	ldw	r2,-76(fp)
 d030748:	10c00617 	ldw	r3,24(r2)
 d03074c:	e0bfe717 	ldw	r2,-100(fp)
 d030750:	10801617 	ldw	r2,88(r2)
 d030754:	1880351e 	bne	r3,r2,d03082c <tcp_input+0x21cc>
 d030758:	e0bfe717 	ldw	r2,-100(fp)
 d03075c:	10c00017 	ldw	r3,0(r2)
 d030760:	e0bfe717 	ldw	r2,-100(fp)
 d030764:	1880311e 	bne	r3,r2,d03082c <tcp_input+0x21cc>
 d030768:	e0bfe717 	ldw	r2,-100(fp)
 d03076c:	10800217 	ldw	r2,8(r2)
 d030770:	10800118 	cmpnei	r2,r2,4
 d030774:	10002d1e 	bne	r2,zero,d03082c <tcp_input+0x21cc>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 d030778:	e0bfe717 	ldw	r2,-100(fp)
 d03077c:	10800b0b 	ldhu	r2,44(r2)
 d030780:	10800054 	ori	r2,r2,1
 d030784:	1007883a 	mov	r3,r2
 d030788:	e0bfe717 	ldw	r2,-100(fp)
 d03078c:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 d030790:	e0bfe717 	ldw	r2,-100(fp)
 d030794:	10c01617 	ldw	r3,88(r2)
 d030798:	e0bfed17 	ldw	r2,-76(fp)
 d03079c:	1080028b 	ldhu	r2,10(r2)
 d0307a0:	10bfffcc 	andi	r2,r2,65535
 d0307a4:	1887883a 	add	r3,r3,r2
 d0307a8:	e0bfe717 	ldw	r2,-100(fp)
 d0307ac:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 d0307b0:	e0bfed17 	ldw	r2,-76(fp)
 d0307b4:	10800843 	ldbu	r2,33(r2)
 d0307b8:	10803fcc 	andi	r2,r2,255
 d0307bc:	1080004c 	andi	r2,r2,1
 d0307c0:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpack++;
 d0307c4:	008341b4 	movhi	r2,3334
 d0307c8:	10848a04 	addi	r2,r2,4648
 d0307cc:	10801a17 	ldw	r2,104(r2)
 d0307d0:	10c00044 	addi	r3,r2,1
 d0307d4:	008341b4 	movhi	r2,3334
 d0307d8:	10848a04 	addi	r2,r2,4648
 d0307dc:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 d0307e0:	008341b4 	movhi	r2,3334
 d0307e4:	10848a04 	addi	r2,r2,4648
 d0307e8:	10c01b17 	ldw	r3,108(r2)
 d0307ec:	e0bfed17 	ldw	r2,-76(fp)
 d0307f0:	1080028b 	ldhu	r2,10(r2)
 d0307f4:	10bfffcc 	andi	r2,r2,65535
 d0307f8:	1887883a 	add	r3,r3,r2
 d0307fc:	008341b4 	movhi	r2,3334
 d030800:	10848a04 	addi	r2,r2,4648
 d030804:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 d030808:	e0bfe517 	ldw	r2,-108(fp)
 d03080c:	11000a04 	addi	r4,r2,40
 d030810:	e17ff017 	ldw	r5,-64(fp)
 d030814:	d02cfc00 	call	d02cfc0 <sbappend>
         sorwakeup(so);
 d030818:	e0bfe517 	ldw	r2,-108(fp)
 d03081c:	11400a04 	addi	r5,r2,40
 d030820:	e13fe517 	ldw	r4,-108(fp)
 d030824:	d02cdfc0 	call	d02cdfc <sbwakeup>
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 d030828:	00000b06 	br	d030858 <tcp_input+0x21f8>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 d03082c:	e13fe717 	ldw	r4,-100(fp)
 d030830:	e17fed17 	ldw	r5,-76(fp)
 d030834:	e1bff017 	ldw	r6,-64(fp)
 d030838:	d02e2580 	call	d02e258 <tcp_reass>
 d03083c:	e0bfe615 	stw	r2,-104(fp)
         tp->t_flags |= TF_ACKNOW;
 d030840:	e0bfe717 	ldw	r2,-100(fp)
 d030844:	10800b0b 	ldhu	r2,44(r2)
 d030848:	10800054 	ori	r2,r2,1
 d03084c:	1007883a 	mov	r3,r2
 d030850:	e0bfe717 	ldw	r2,-100(fp)
 d030854:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 d030858:	e0bfe517 	ldw	r2,-108(fp)
 d03085c:	11000b17 	ldw	r4,44(r2)
 d030860:	e0bfe717 	ldw	r2,-100(fp)
 d030864:	10c01917 	ldw	r3,100(r2)
 d030868:	e0bfe717 	ldw	r2,-100(fp)
 d03086c:	10801617 	ldw	r2,88(r2)
 d030870:	1885c83a 	sub	r2,r3,r2
 d030874:	2085c83a 	sub	r2,r4,r2
 d030878:	e0bfea15 	stw	r2,-88(fp)
      if (len > (int)tp->max_rcvd)
 d03087c:	e0bfe717 	ldw	r2,-100(fp)
 d030880:	10802217 	ldw	r2,136(r2)
 d030884:	1007883a 	mov	r3,r2
 d030888:	e0bfea17 	ldw	r2,-88(fp)
 d03088c:	18800b0e 	bge	r3,r2,d0308bc <tcp_input+0x225c>
         tp->max_rcvd = (u_short)len;
 d030890:	e0bfea17 	ldw	r2,-88(fp)
 d030894:	10ffffcc 	andi	r3,r2,65535
 d030898:	e0bfe717 	ldw	r2,-100(fp)
 d03089c:	10c02215 	stw	r3,136(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 d0308a0:	00000606 	br	d0308bc <tcp_input+0x225c>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 d0308a4:	e13ff017 	ldw	r4,-64(fp)
 d0308a8:	d026b500 	call	d026b50 <m_freem>
      tiflags &= ~TH_FIN;
 d0308ac:	e0bfe617 	ldw	r2,-104(fp)
 d0308b0:	00ffff84 	movi	r3,-2
 d0308b4:	10c4703a 	and	r2,r2,r3
 d0308b8:	e0bfe615 	stw	r2,-104(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 d0308bc:	e0bfe617 	ldw	r2,-104(fp)
 d0308c0:	1080004c 	andi	r2,r2,1
 d0308c4:	10803fcc 	andi	r2,r2,255
 d0308c8:	1005003a 	cmpeq	r2,r2,zero
 d0308cc:	1000471e 	bne	r2,zero,d0309ec <tcp_input+0x238c>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 d0308d0:	e0bfe717 	ldw	r2,-100(fp)
 d0308d4:	10800217 	ldw	r2,8(r2)
 d0308d8:	10800288 	cmpgei	r2,r2,10
 d0308dc:	10000d1e 	bne	r2,zero,d030914 <tcp_input+0x22b4>
      {
         socantrcvmore(so);
 d0308e0:	e13fe517 	ldw	r4,-108(fp)
 d0308e4:	d02cd0c0 	call	d02cd0c <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 d0308e8:	e0bfe717 	ldw	r2,-100(fp)
 d0308ec:	10800b0b 	ldhu	r2,44(r2)
 d0308f0:	10800054 	ori	r2,r2,1
 d0308f4:	1007883a 	mov	r3,r2
 d0308f8:	e0bfe717 	ldw	r2,-100(fp)
 d0308fc:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 d030900:	e0bfe717 	ldw	r2,-100(fp)
 d030904:	10801617 	ldw	r2,88(r2)
 d030908:	10c00044 	addi	r3,r2,1
 d03090c:	e0bfe717 	ldw	r2,-100(fp)
 d030910:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 d030914:	e0bfe717 	ldw	r2,-100(fp)
 d030918:	10800217 	ldw	r2,8(r2)
 d03091c:	10bfff44 	addi	r2,r2,-3
 d030920:	e0bfff15 	stw	r2,-4(fp)
 d030924:	e0ffff17 	ldw	r3,-4(fp)
 d030928:	18800228 	cmpgeui	r2,r3,8
 d03092c:	10002f1e 	bne	r2,zero,d0309ec <tcp_input+0x238c>
 d030930:	e13fff17 	ldw	r4,-4(fp)
 d030934:	e13fff17 	ldw	r4,-4(fp)
 d030938:	2105883a 	add	r2,r4,r4
 d03093c:	1087883a 	add	r3,r2,r2
 d030940:	008340f4 	movhi	r2,3331
 d030944:	10825504 	addi	r2,r2,2388
 d030948:	1885883a 	add	r2,r3,r2
 d03094c:	10800017 	ldw	r2,0(r2)
 d030950:	1000683a 	jmp	r2
 d030954:	0d030974 	orhi	r20,at,3109
 d030958:	0d030974 	orhi	r20,at,3109
 d03095c:	0d0309ec 	andhi	r20,at,3111
 d030960:	0d030984 	addi	r20,at,3110
 d030964:	0d0309ec 	andhi	r20,at,3111
 d030968:	0d0309ec 	andhi	r20,at,3111
 d03096c:	0d030994 	ori	r20,at,3110
 d030970:	0d0309d0 	cmplti	r20,at,3111
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 d030974:	e0ffe717 	ldw	r3,-100(fp)
 d030978:	00800144 	movi	r2,5
 d03097c:	18800215 	stw	r2,8(r3)
         break;
 d030980:	00001a06 	br	d0309ec <tcp_input+0x238c>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 d030984:	e0ffe717 	ldw	r3,-100(fp)
 d030988:	008001c4 	movi	r2,7
 d03098c:	18800215 	stw	r2,8(r3)
         break;
 d030990:	00001606 	br	d0309ec <tcp_input+0x238c>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 d030994:	e0ffe717 	ldw	r3,-100(fp)
 d030998:	00800284 	movi	r2,10
 d03099c:	18800215 	stw	r2,8(r3)
         tcp_canceltimers(tp);
 d0309a0:	e13fe717 	ldw	r4,-100(fp)
 d0309a4:	d0332400 	call	d033240 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d0309a8:	00834174 	movhi	r2,3333
 d0309ac:	10925904 	addi	r2,r2,18788
 d0309b0:	10800017 	ldw	r2,0(r2)
 d0309b4:	1085883a 	add	r2,r2,r2
 d0309b8:	1007883a 	mov	r3,r2
 d0309bc:	e0bfe717 	ldw	r2,-100(fp)
 d0309c0:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 d0309c4:	e13fe517 	ldw	r4,-108(fp)
 d0309c8:	d02c8180 	call	d02c818 <soisdisconnected>
         break;
 d0309cc:	00000706 	br	d0309ec <tcp_input+0x238c>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d0309d0:	00834174 	movhi	r2,3333
 d0309d4:	10925904 	addi	r2,r2,18788
 d0309d8:	10800017 	ldw	r2,0(r2)
 d0309dc:	1085883a 	add	r2,r2,r2
 d0309e0:	1007883a 	mov	r3,r2
 d0309e4:	e0bfe717 	ldw	r2,-100(fp)
 d0309e8:	10c00615 	stw	r3,24(r2)
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 d0309ec:	e0bfe117 	ldw	r2,-124(fp)
 d0309f0:	1004c03a 	cmpne	r2,r2,zero
 d0309f4:	1000071e 	bne	r2,zero,d030a14 <tcp_input+0x23b4>
 d0309f8:	e0bfe717 	ldw	r2,-100(fp)
 d0309fc:	10800b0b 	ldhu	r2,44(r2)
 d030a00:	10bfffcc 	andi	r2,r2,65535
 d030a04:	1080004c 	andi	r2,r2,1
 d030a08:	10803fcc 	andi	r2,r2,255
 d030a0c:	1005003a 	cmpeq	r2,r2,zero
 d030a10:	1000651e 	bne	r2,zero,d030ba8 <tcp_input+0x2548>
      (void) tcp_output(tp);
 d030a14:	e13fe717 	ldw	r4,-100(fp)
 d030a18:	d0312480 	call	d031248 <tcp_output>
   return;
 d030a1c:	00006206 	br	d030ba8 <tcp_input+0x2548>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 d030a20:	e0bfe617 	ldw	r2,-104(fp)
 d030a24:	1080010c 	andi	r2,r2,4
 d030a28:	1005003a 	cmpeq	r2,r2,zero
 d030a2c:	1000031e 	bne	r2,zero,d030a3c <tcp_input+0x23dc>
      GOTO_DROP;
 d030a30:	0081a904 	movi	r2,1700
 d030a34:	d0a93015 	stw	r2,-23360(gp)
 d030a38:	00004f06 	br	d030b78 <tcp_input+0x2518>
   m_freem (m);
 d030a3c:	e13ff017 	ldw	r4,-64(fp)
 d030a40:	d026b500 	call	d026b50 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 d030a44:	e0bfe717 	ldw	r2,-100(fp)
 d030a48:	10800b0b 	ldhu	r2,44(r2)
 d030a4c:	10800054 	ori	r2,r2,1
 d030a50:	1007883a 	mov	r3,r2
 d030a54:	e0bfe717 	ldw	r2,-100(fp)
 d030a58:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 d030a5c:	e13fe717 	ldw	r4,-100(fp)
 d030a60:	d0312480 	call	d031248 <tcp_output>
   return;
 d030a64:	00005006 	br	d030ba8 <tcp_input+0x2548>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 d030a68:	008341b4 	movhi	r2,3334
 d030a6c:	10845c04 	addi	r2,r2,4464
 d030a70:	10800d17 	ldw	r2,52(r2)
 d030a74:	10c00044 	addi	r3,r2,1
 d030a78:	008341b4 	movhi	r2,3334
 d030a7c:	10845c04 	addi	r2,r2,4464
 d030a80:	10c00d15 	stw	r3,52(r2)
   if (om) 
 d030a84:	e0bfeb17 	ldw	r2,-84(fp)
 d030a88:	1005003a 	cmpeq	r2,r2,zero
 d030a8c:	1000031e 	bne	r2,zero,d030a9c <tcp_input+0x243c>
   {
      (void) m_free(om);
 d030a90:	e13feb17 	ldw	r4,-84(fp)
 d030a94:	d026a1c0 	call	d026a1c <m_free>
      om = 0;
 d030a98:	e03feb15 	stw	zero,-84(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 d030a9c:	e0bfe617 	ldw	r2,-104(fp)
 d030aa0:	1080010c 	andi	r2,r2,4
 d030aa4:	1005003a 	cmpeq	r2,r2,zero
 d030aa8:	1000031e 	bne	r2,zero,d030ab8 <tcp_input+0x2458>
      GOTO_DROP;
 d030aac:	0081ad04 	movi	r2,1716
 d030ab0:	d0a93015 	stw	r2,-23360(gp)
 d030ab4:	00003006 	br	d030b78 <tcp_input+0x2518>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 d030ab8:	e0bfed17 	ldw	r2,-76(fp)
 d030abc:	11000417 	ldw	r4,16(r2)
 d030ac0:	d027b7c0 	call	d027b7c <in_broadcast>
 d030ac4:	1005003a 	cmpeq	r2,r2,zero
 d030ac8:	1000031e 	bne	r2,zero,d030ad8 <tcp_input+0x2478>
      GOTO_DROP;
 d030acc:	0081af44 	movi	r2,1725
 d030ad0:	d0a93015 	stw	r2,-23360(gp)
 d030ad4:	00002806 	br	d030b78 <tcp_input+0x2518>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 d030ad8:	e0bfe617 	ldw	r2,-104(fp)
 d030adc:	1080040c 	andi	r2,r2,16
 d030ae0:	1005003a 	cmpeq	r2,r2,zero
 d030ae4:	10000b1e 	bne	r2,zero,d030b14 <tcp_input+0x24b4>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 d030ae8:	e0bfed17 	ldw	r2,-76(fp)
 d030aec:	11c00717 	ldw	r7,28(r2)
 d030af0:	00800104 	movi	r2,4
 d030af4:	d8800015 	stw	r2,0(sp)
 d030af8:	e0bff017 	ldw	r2,-64(fp)
 d030afc:	d8800115 	stw	r2,4(sp)
 d030b00:	e13fe717 	ldw	r4,-100(fp)
 d030b04:	e17fed17 	ldw	r5,-76(fp)
 d030b08:	000d883a 	mov	r6,zero
 d030b0c:	d0327280 	call	d032728 <tcp_respond>
 d030b10:	00001306 	br	d030b60 <tcp_input+0x2500>
   else
   {
      if (tiflags & TH_SYN)
 d030b14:	e0bfe617 	ldw	r2,-104(fp)
 d030b18:	1080008c 	andi	r2,r2,2
 d030b1c:	1005003a 	cmpeq	r2,r2,zero
 d030b20:	1000051e 	bne	r2,zero,d030b38 <tcp_input+0x24d8>
         ti->ti_seq++;
 d030b24:	e0bfed17 	ldw	r2,-76(fp)
 d030b28:	10800617 	ldw	r2,24(r2)
 d030b2c:	10c00044 	addi	r3,r2,1
 d030b30:	e0bfed17 	ldw	r2,-76(fp)
 d030b34:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 d030b38:	e0bfed17 	ldw	r2,-76(fp)
 d030b3c:	11800617 	ldw	r6,24(r2)
 d030b40:	00800504 	movi	r2,20
 d030b44:	d8800015 	stw	r2,0(sp)
 d030b48:	e0bff017 	ldw	r2,-64(fp)
 d030b4c:	d8800115 	stw	r2,4(sp)
 d030b50:	e13fe717 	ldw	r4,-100(fp)
 d030b54:	e17fed17 	ldw	r5,-76(fp)
 d030b58:	000f883a 	mov	r7,zero
 d030b5c:	d0327280 	call	d032728 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 d030b60:	e0bfe017 	ldw	r2,-128(fp)
 d030b64:	1005003a 	cmpeq	r2,r2,zero
 d030b68:	10000f1e 	bne	r2,zero,d030ba8 <tcp_input+0x2548>
      (void) soabort(so);
 d030b6c:	e13fe517 	ldw	r4,-108(fp)
 d030b70:	d02a9ec0 	call	d02a9ec <soabort>
   return;
 d030b74:	00000c06 	br	d030ba8 <tcp_input+0x2548>

drop:
   if (om)
 d030b78:	e0bfeb17 	ldw	r2,-84(fp)
 d030b7c:	1005003a 	cmpeq	r2,r2,zero
 d030b80:	1000021e 	bne	r2,zero,d030b8c <tcp_input+0x252c>
      (void) m_free(om);
 d030b84:	e13feb17 	ldw	r4,-84(fp)
 d030b88:	d026a1c0 	call	d026a1c <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 d030b8c:	e13ff017 	ldw	r4,-64(fp)
 d030b90:	d026b500 	call	d026b50 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 d030b94:	e0bfe017 	ldw	r2,-128(fp)
 d030b98:	1005003a 	cmpeq	r2,r2,zero
 d030b9c:	1000021e 	bne	r2,zero,d030ba8 <tcp_input+0x2548>
      (void) soabort(so);
 d030ba0:	e13fe517 	ldw	r4,-108(fp)
 d030ba4:	d02a9ec0 	call	d02a9ec <soabort>
   return;
}
 d030ba8:	e037883a 	mov	sp,fp
 d030bac:	dfc00117 	ldw	ra,4(sp)
 d030bb0:	df000017 	ldw	fp,0(sp)
 d030bb4:	dec00204 	addi	sp,sp,8
 d030bb8:	f800283a 	ret

0d030bbc <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 d030bbc:	defff404 	addi	sp,sp,-48
 d030bc0:	dfc00b15 	stw	ra,44(sp)
 d030bc4:	df000a15 	stw	fp,40(sp)
 d030bc8:	df000a04 	addi	fp,sp,40
 d030bcc:	e13ffc15 	stw	r4,-16(fp)
 d030bd0:	e17ffd15 	stw	r5,-12(fp)
 d030bd4:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 d030bd8:	e0bffc17 	ldw	r2,-16(fp)
 d030bdc:	10800d17 	ldw	r2,52(r2)
 d030be0:	10800817 	ldw	r2,32(r2)
 d030be4:	e0bff715 	stw	r2,-36(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 d030be8:	e0bffd17 	ldw	r2,-12(fp)
 d030bec:	10800317 	ldw	r2,12(r2)
 d030bf0:	e0bffb15 	stw	r2,-20(fp)
   cnt = om->m_len;
 d030bf4:	e0bffd17 	ldw	r2,-12(fp)
 d030bf8:	10800217 	ldw	r2,8(r2)
 d030bfc:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 d030c00:	00004806 	br	d030d24 <tcp_dooptions+0x168>
   {
      opt = cp[0];
 d030c04:	e0bffb17 	ldw	r2,-20(fp)
 d030c08:	10800003 	ldbu	r2,0(r2)
 d030c0c:	10803fcc 	andi	r2,r2,255
 d030c10:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 d030c14:	e0bffa17 	ldw	r2,-24(fp)
 d030c18:	1005003a 	cmpeq	r2,r2,zero
 d030c1c:	1000441e 	bne	r2,zero,d030d30 <tcp_dooptions+0x174>
         break;
      if (opt == TCPOPT_NOP)
 d030c20:	e0bffa17 	ldw	r2,-24(fp)
 d030c24:	10800058 	cmpnei	r2,r2,1
 d030c28:	1000031e 	bne	r2,zero,d030c38 <tcp_dooptions+0x7c>
         optlen = 1;
 d030c2c:	00800044 	movi	r2,1
 d030c30:	e0bff915 	stw	r2,-28(fp)
 d030c34:	00000806 	br	d030c58 <tcp_dooptions+0x9c>
      else 
      {
         optlen = cp[1];
 d030c38:	e0bffb17 	ldw	r2,-20(fp)
 d030c3c:	10800044 	addi	r2,r2,1
 d030c40:	10800003 	ldbu	r2,0(r2)
 d030c44:	10803fcc 	andi	r2,r2,255
 d030c48:	e0bff915 	stw	r2,-28(fp)
         if (optlen <= 0)
 d030c4c:	e0bff917 	ldw	r2,-28(fp)
 d030c50:	10800050 	cmplti	r2,r2,1
 d030c54:	1000361e 	bne	r2,zero,d030d30 <tcp_dooptions+0x174>
            break;
      }

      switch (opt) 
 d030c58:	e0bffa17 	ldw	r2,-24(fp)
 d030c5c:	108000a0 	cmpeqi	r2,r2,2
 d030c60:	1000011e 	bne	r2,zero,d030c68 <tcp_dooptions+0xac>
 d030c64:	00002606 	br	d030d00 <tcp_dooptions+0x144>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 d030c68:	e0bff917 	ldw	r2,-28(fp)
 d030c6c:	10800118 	cmpnei	r2,r2,4
 d030c70:	1000231e 	bne	r2,zero,d030d00 <tcp_dooptions+0x144>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 d030c74:	e0bffe17 	ldw	r2,-8(fp)
 d030c78:	10800843 	ldbu	r2,33(r2)
 d030c7c:	10803fcc 	andi	r2,r2,255
 d030c80:	1080008c 	andi	r2,r2,2
 d030c84:	1005003a 	cmpeq	r2,r2,zero
 d030c88:	10001d1e 	bne	r2,zero,d030d00 <tcp_dooptions+0x144>
            continue;
         mssval = *(u_short *)(cp + 2);
 d030c8c:	e0bffb17 	ldw	r2,-20(fp)
 d030c90:	10800084 	addi	r2,r2,2
 d030c94:	1080000b 	ldhu	r2,0(r2)
 d030c98:	e0bff60d 	sth	r2,-40(fp)
         mssval = ntohs(mssval);
 d030c9c:	e0bff60b 	ldhu	r2,-40(fp)
 d030ca0:	1004d23a 	srli	r2,r2,8
 d030ca4:	10803fcc 	andi	r2,r2,255
 d030ca8:	1009883a 	mov	r4,r2
 d030cac:	e0bff60b 	ldhu	r2,-40(fp)
 d030cb0:	1004923a 	slli	r2,r2,8
 d030cb4:	1007883a 	mov	r3,r2
 d030cb8:	00bfc004 	movi	r2,-256
 d030cbc:	1884703a 	and	r2,r3,r2
 d030cc0:	2084b03a 	or	r2,r4,r2
 d030cc4:	e0bff60d 	sth	r2,-40(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 d030cc8:	e13ff717 	ldw	r4,-36(fp)
 d030ccc:	d03112c0 	call	d03112c <tcp_mss>
 d030cd0:	10ffffcc 	andi	r3,r2,65535
 d030cd4:	e0bff60b 	ldhu	r2,-40(fp)
 d030cd8:	1880042e 	bgeu	r3,r2,d030cec <tcp_dooptions+0x130>
 d030cdc:	e13ff717 	ldw	r4,-36(fp)
 d030ce0:	d03112c0 	call	d03112c <tcp_mss>
 d030ce4:	e0bfff0d 	sth	r2,-4(fp)
 d030ce8:	00000206 	br	d030cf4 <tcp_dooptions+0x138>
 d030cec:	e0bff60b 	ldhu	r2,-40(fp)
 d030cf0:	e0bfff0d 	sth	r2,-4(fp)
 d030cf4:	e0bffc17 	ldw	r2,-16(fp)
 d030cf8:	e0ffff0b 	ldhu	r3,-4(fp)
 d030cfc:	10c00a0d 	sth	r3,40(r2)
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 d030d00:	e0fff817 	ldw	r3,-32(fp)
 d030d04:	e0bff917 	ldw	r2,-28(fp)
 d030d08:	1885c83a 	sub	r2,r3,r2
 d030d0c:	e0bff815 	stw	r2,-32(fp)
 d030d10:	e0bff917 	ldw	r2,-28(fp)
 d030d14:	1007883a 	mov	r3,r2
 d030d18:	e0bffb17 	ldw	r2,-20(fp)
 d030d1c:	10c5883a 	add	r2,r2,r3
 d030d20:	e0bffb15 	stw	r2,-20(fp)
 d030d24:	e0bff817 	ldw	r2,-32(fp)
 d030d28:	10800048 	cmpgei	r2,r2,1
 d030d2c:	103fb51e 	bne	r2,zero,d030c04 <tcp_dooptions+0x48>

      default:
         break;
      }
   }
   (void) m_free(om);
 d030d30:	e13ffd17 	ldw	r4,-12(fp)
 d030d34:	d026a1c0 	call	d026a1c <m_free>
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
}
 d030d38:	e037883a 	mov	sp,fp
 d030d3c:	dfc00117 	ldw	ra,4(sp)
 d030d40:	df000017 	ldw	fp,0(sp)
 d030d44:	dec00204 	addi	sp,sp,8
 d030d48:	f800283a 	ret

0d030d4c <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 d030d4c:	defff804 	addi	sp,sp,-32
 d030d50:	dfc00715 	stw	ra,28(sp)
 d030d54:	df000615 	stw	fp,24(sp)
 d030d58:	df000604 	addi	fp,sp,24
 d030d5c:	e13ffd15 	stw	r4,-12(fp)
 d030d60:	e17ffe15 	stw	r5,-8(fp)
 d030d64:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 d030d68:	e0bffe17 	ldw	r2,-8(fp)
 d030d6c:	1080098b 	ldhu	r2,38(r2)
 d030d70:	10bfffcc 	andi	r2,r2,65535
 d030d74:	10bfffc4 	addi	r2,r2,-1
 d030d78:	e0bffc15 	stw	r2,-16(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 d030d7c:	00003306 	br	d030e4c <tcp_pulloutofband+0x100>
   {
      if (m->m_len > (unsigned)cnt) 
 d030d80:	e0bfff17 	ldw	r2,-4(fp)
 d030d84:	10c00217 	ldw	r3,8(r2)
 d030d88:	e0bffc17 	ldw	r2,-16(fp)
 d030d8c:	10c0242e 	bgeu	r2,r3,d030e20 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 d030d90:	e0bfff17 	ldw	r2,-4(fp)
 d030d94:	10c00317 	ldw	r3,12(r2)
 d030d98:	e0bffc17 	ldw	r2,-16(fp)
 d030d9c:	1885883a 	add	r2,r3,r2
 d030da0:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 d030da4:	e0bffd17 	ldw	r2,-12(fp)
 d030da8:	10800117 	ldw	r2,4(r2)
 d030dac:	10800917 	ldw	r2,36(r2)
 d030db0:	e0bffa15 	stw	r2,-24(fp)

         tp->t_iobc = *cp;
 d030db4:	e0bffb17 	ldw	r2,-20(fp)
 d030db8:	10c00003 	ldbu	r3,0(r2)
 d030dbc:	e0bffa17 	ldw	r2,-24(fp)
 d030dc0:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 d030dc4:	e0bffa17 	ldw	r2,-24(fp)
 d030dc8:	10802403 	ldbu	r2,144(r2)
 d030dcc:	10800054 	ori	r2,r2,1
 d030dd0:	1007883a 	mov	r3,r2
 d030dd4:	e0bffa17 	ldw	r2,-24(fp)
 d030dd8:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 d030ddc:	e0bffb17 	ldw	r2,-20(fp)
 d030de0:	11400044 	addi	r5,r2,1
 d030de4:	e0bfff17 	ldw	r2,-4(fp)
 d030de8:	10c00217 	ldw	r3,8(r2)
 d030dec:	e0bffc17 	ldw	r2,-16(fp)
 d030df0:	1885c83a 	sub	r2,r3,r2
 d030df4:	10ffffc4 	addi	r3,r2,-1
 d030df8:	e0bffb17 	ldw	r2,-20(fp)
 d030dfc:	1009883a 	mov	r4,r2
 d030e00:	180d883a 	mov	r6,r3
 d030e04:	d0026080 	call	d002608 <memcpy>
         m->m_len--;
 d030e08:	e0bfff17 	ldw	r2,-4(fp)
 d030e0c:	10800217 	ldw	r2,8(r2)
 d030e10:	10ffffc4 	addi	r3,r2,-1
 d030e14:	e0bfff17 	ldw	r2,-4(fp)
 d030e18:	10c00215 	stw	r3,8(r2)
         return;
 d030e1c:	00001106 	br	d030e64 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 d030e20:	e0fffc17 	ldw	r3,-16(fp)
 d030e24:	e0bfff17 	ldw	r2,-4(fp)
 d030e28:	10800217 	ldw	r2,8(r2)
 d030e2c:	1885c83a 	sub	r2,r3,r2
 d030e30:	e0bffc15 	stw	r2,-16(fp)
      m = m->m_next;
 d030e34:	e0bfff17 	ldw	r2,-4(fp)
 d030e38:	10800617 	ldw	r2,24(r2)
 d030e3c:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 d030e40:	e0bfff17 	ldw	r2,-4(fp)
 d030e44:	1005003a 	cmpeq	r2,r2,zero
 d030e48:	1000031e 	bne	r2,zero,d030e58 <tcp_pulloutofband+0x10c>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 d030e4c:	e0bffc17 	ldw	r2,-16(fp)
 d030e50:	1004403a 	cmpge	r2,r2,zero
 d030e54:	103fca1e 	bne	r2,zero,d030d80 <tcp_pulloutofband+0x34>
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
   }
   panic("tcp_pulloutofband");
 d030e58:	01034174 	movhi	r4,3333
 d030e5c:	213ea904 	addi	r4,r4,-1372
 d030e60:	d02093c0 	call	d02093c <panic>
}
 d030e64:	e037883a 	mov	sp,fp
 d030e68:	dfc00117 	ldw	ra,4(sp)
 d030e6c:	df000017 	ldw	fp,0(sp)
 d030e70:	dec00204 	addi	sp,sp,8
 d030e74:	f800283a 	ret

0d030e78 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 d030e78:	defffb04 	addi	sp,sp,-20
 d030e7c:	dfc00415 	stw	ra,16(sp)
 d030e80:	df000315 	stw	fp,12(sp)
 d030e84:	df000304 	addi	fp,sp,12
 d030e88:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 d030e8c:	e0bfff17 	ldw	r2,-4(fp)
 d030e90:	10801e17 	ldw	r2,120(r2)
 d030e94:	1004c03a 	cmpne	r2,r2,zero
 d030e98:	1000021e 	bne	r2,zero,d030ea4 <tcp_xmit_timer+0x2c>
 d030e9c:	d025a500 	call	d025a50 <dtrap>
 d030ea0:	00008b06 	br	d0310d0 <tcp_xmit_timer+0x258>
#endif

   tcpstat.tcps_rttupdated++;
 d030ea4:	008341b4 	movhi	r2,3334
 d030ea8:	10848a04 	addi	r2,r2,4648
 d030eac:	10800717 	ldw	r2,28(r2)
 d030eb0:	10c00044 	addi	r3,r2,1
 d030eb4:	008341b4 	movhi	r2,3334
 d030eb8:	10848a04 	addi	r2,r2,4648
 d030ebc:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 d030ec0:	00834174 	movhi	r2,3333
 d030ec4:	109b4504 	addi	r2,r2,27924
 d030ec8:	10c00017 	ldw	r3,0(r2)
 d030ecc:	e0bfff17 	ldw	r2,-4(fp)
 d030ed0:	10801e17 	ldw	r2,120(r2)
 d030ed4:	1889c83a 	sub	r4,r3,r2
 d030ed8:	01400c84 	movi	r5,50
 d030edc:	d00c90c0 	call	d00c90c <__udivsi3>
 d030ee0:	e0bffd15 	stw	r2,-12(fp)
   if(tp->t_srtt != 0)
 d030ee4:	e0bfff17 	ldw	r2,-4(fp)
 d030ee8:	10802017 	ldw	r2,128(r2)
 d030eec:	1005003a 	cmpeq	r2,r2,zero
 d030ef0:	10004a1e 	bne	r2,zero,d03101c <tcp_xmit_timer+0x1a4>
   {
      if(rtt == 0)      /* fast path for small round trip */
 d030ef4:	e0bffd17 	ldw	r2,-12(fp)
 d030ef8:	1004c03a 	cmpne	r2,r2,zero
 d030efc:	1000131e 	bne	r2,zero,d030f4c <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 d030f00:	e0bfff17 	ldw	r2,-4(fp)
 d030f04:	10802017 	ldw	r2,128(r2)
 d030f08:	10800090 	cmplti	r2,r2,2
 d030f0c:	1000051e 	bne	r2,zero,d030f24 <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 d030f10:	e0bfff17 	ldw	r2,-4(fp)
 d030f14:	10802017 	ldw	r2,128(r2)
 d030f18:	10ffffc4 	addi	r3,r2,-1
 d030f1c:	e0bfff17 	ldw	r2,-4(fp)
 d030f20:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 d030f24:	e0bfff17 	ldw	r2,-4(fp)
 d030f28:	10802117 	ldw	r2,132(r2)
 d030f2c:	10800090 	cmplti	r2,r2,2
 d030f30:	1000481e 	bne	r2,zero,d031054 <tcp_xmit_timer+0x1dc>
            tp->t_rttvar--;
 d030f34:	e0bfff17 	ldw	r2,-4(fp)
 d030f38:	10802117 	ldw	r2,132(r2)
 d030f3c:	10ffffc4 	addi	r3,r2,-1
 d030f40:	e0bfff17 	ldw	r2,-4(fp)
 d030f44:	10c02115 	stw	r3,132(r2)
 d030f48:	00004206 	br	d031054 <tcp_xmit_timer+0x1dc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 d030f4c:	e0bffd17 	ldw	r2,-12(fp)
 d030f50:	10bfffc4 	addi	r2,r2,-1
 d030f54:	1085883a 	add	r2,r2,r2
 d030f58:	1085883a 	add	r2,r2,r2
 d030f5c:	1007883a 	mov	r3,r2
 d030f60:	e0bfff17 	ldw	r2,-4(fp)
 d030f64:	10802017 	ldw	r2,128(r2)
 d030f68:	1005d0fa 	srai	r2,r2,3
 d030f6c:	1885c83a 	sub	r2,r3,r2
 d030f70:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_srtt += delta) <= 0)
 d030f74:	e0bfff17 	ldw	r2,-4(fp)
 d030f78:	10c02017 	ldw	r3,128(r2)
 d030f7c:	e0bffe17 	ldw	r2,-8(fp)
 d030f80:	1887883a 	add	r3,r3,r2
 d030f84:	e0bfff17 	ldw	r2,-4(fp)
 d030f88:	10c02015 	stw	r3,128(r2)
 d030f8c:	e0bfff17 	ldw	r2,-4(fp)
 d030f90:	10802017 	ldw	r2,128(r2)
 d030f94:	10800048 	cmpgei	r2,r2,1
 d030f98:	1000031e 	bne	r2,zero,d030fa8 <tcp_xmit_timer+0x130>
         tp->t_srtt = 1;
 d030f9c:	e0ffff17 	ldw	r3,-4(fp)
 d030fa0:	00800044 	movi	r2,1
 d030fa4:	18802015 	stw	r2,128(r3)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 d030fa8:	e0bffe17 	ldw	r2,-8(fp)
 d030fac:	1004403a 	cmpge	r2,r2,zero
 d030fb0:	1000031e 	bne	r2,zero,d030fc0 <tcp_xmit_timer+0x148>
         delta = -delta;
 d030fb4:	e0bffe17 	ldw	r2,-8(fp)
 d030fb8:	0085c83a 	sub	r2,zero,r2
 d030fbc:	e0bffe15 	stw	r2,-8(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 d030fc0:	e0bfff17 	ldw	r2,-4(fp)
 d030fc4:	10802117 	ldw	r2,132(r2)
 d030fc8:	1005d07a 	srai	r2,r2,1
 d030fcc:	10ffffcc 	andi	r3,r2,65535
 d030fd0:	18e0001c 	xori	r3,r3,32768
 d030fd4:	18e00004 	addi	r3,r3,-32768
 d030fd8:	e0bffe17 	ldw	r2,-8(fp)
 d030fdc:	10c5c83a 	sub	r2,r2,r3
 d030fe0:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_rttvar += delta) <= 0)
 d030fe4:	e0bfff17 	ldw	r2,-4(fp)
 d030fe8:	10c02117 	ldw	r3,132(r2)
 d030fec:	e0bffe17 	ldw	r2,-8(fp)
 d030ff0:	1887883a 	add	r3,r3,r2
 d030ff4:	e0bfff17 	ldw	r2,-4(fp)
 d030ff8:	10c02115 	stw	r3,132(r2)
 d030ffc:	e0bfff17 	ldw	r2,-4(fp)
 d031000:	10802117 	ldw	r2,132(r2)
 d031004:	10800048 	cmpgei	r2,r2,1
 d031008:	1000121e 	bne	r2,zero,d031054 <tcp_xmit_timer+0x1dc>
         tp->t_rttvar = 1;
 d03100c:	e0ffff17 	ldw	r3,-4(fp)
 d031010:	00800044 	movi	r2,1
 d031014:	18802115 	stw	r2,132(r3)
 d031018:	00000e06 	br	d031054 <tcp_xmit_timer+0x1dc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 d03101c:	e0bffd17 	ldw	r2,-12(fp)
 d031020:	10800048 	cmpgei	r2,r2,1
 d031024:	1000021e 	bne	r2,zero,d031030 <tcp_xmit_timer+0x1b8>
         rtt = 1;
 d031028:	00800044 	movi	r2,1
 d03102c:	e0bffd15 	stw	r2,-12(fp)
      tp->t_srtt = rtt << 3;
 d031030:	e0bffd17 	ldw	r2,-12(fp)
 d031034:	100690fa 	slli	r3,r2,3
 d031038:	e0bfff17 	ldw	r2,-4(fp)
 d03103c:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 d031040:	e0bffd17 	ldw	r2,-12(fp)
 d031044:	1085883a 	add	r2,r2,r2
 d031048:	1007883a 	mov	r3,r2
 d03104c:	e0bfff17 	ldw	r2,-4(fp)
 d031050:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 d031054:	e0bfff17 	ldw	r2,-4(fp)
 d031058:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 d03105c:	e0bfff17 	ldw	r2,-4(fp)
 d031060:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 d031064:	e0bfff17 	ldw	r2,-4(fp)
 d031068:	10802017 	ldw	r2,128(r2)
 d03106c:	1007d0ba 	srai	r3,r2,2
 d031070:	e0bfff17 	ldw	r2,-4(fp)
 d031074:	10802117 	ldw	r2,132(r2)
 d031078:	1885883a 	add	r2,r3,r2
 d03107c:	1005d07a 	srai	r2,r2,1
 d031080:	10ffffcc 	andi	r3,r2,65535
 d031084:	18e0001c 	xori	r3,r3,32768
 d031088:	18e00004 	addi	r3,r3,-32768
 d03108c:	e0bfff17 	ldw	r2,-4(fp)
 d031090:	10c00815 	stw	r3,32(r2)
 d031094:	e0bfff17 	ldw	r2,-4(fp)
 d031098:	10800817 	ldw	r2,32(r2)
 d03109c:	10800088 	cmpgei	r2,r2,2
 d0310a0:	1000041e 	bne	r2,zero,d0310b4 <tcp_xmit_timer+0x23c>
 d0310a4:	e0ffff17 	ldw	r3,-4(fp)
 d0310a8:	00800084 	movi	r2,2
 d0310ac:	18800815 	stw	r2,32(r3)
 d0310b0:	00000706 	br	d0310d0 <tcp_xmit_timer+0x258>
 d0310b4:	e0bfff17 	ldw	r2,-4(fp)
 d0310b8:	10800817 	ldw	r2,32(r2)
 d0310bc:	10802050 	cmplti	r2,r2,129
 d0310c0:	1000031e 	bne	r2,zero,d0310d0 <tcp_xmit_timer+0x258>
 d0310c4:	e0ffff17 	ldw	r3,-4(fp)
 d0310c8:	00802004 	movi	r2,128
 d0310cc:	18800815 	stw	r2,32(r3)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 d0310d0:	e037883a 	mov	sp,fp
 d0310d4:	dfc00117 	ldw	ra,4(sp)
 d0310d8:	df000017 	ldw	fp,0(sp)
 d0310dc:	dec00204 	addi	sp,sp,8
 d0310e0:	f800283a 	ret

0d0310e4 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 d0310e4:	defffd04 	addi	sp,sp,-12
 d0310e8:	df000215 	stw	fp,8(sp)
 d0310ec:	df000204 	addi	fp,sp,8
 d0310f0:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 d0310f4:	e0bfff17 	ldw	r2,-4(fp)
 d0310f8:	10800117 	ldw	r2,4(r2)
 d0310fc:	10800a17 	ldw	r2,40(r2)
 d031100:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 d031104:	e0bffe17 	ldw	r2,-8(fp)
 d031108:	10c00917 	ldw	r3,36(r2)
 d03110c:	e0bffe17 	ldw	r2,-8(fp)
 d031110:	10800817 	ldw	r2,32(r2)
 d031114:	1885c83a 	sub	r2,r3,r2
 d031118:	10bff604 	addi	r2,r2,-40
}
 d03111c:	e037883a 	mov	sp,fp
 d031120:	df000017 	ldw	fp,0(sp)
 d031124:	dec00104 	addi	sp,sp,4
 d031128:	f800283a 	ret

0d03112c <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 d03112c:	defff904 	addi	sp,sp,-28
 d031130:	dfc00615 	stw	ra,24(sp)
 d031134:	df000515 	stw	fp,20(sp)
 d031138:	df000504 	addi	fp,sp,20
 d03113c:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 d031140:	e0bffe17 	ldw	r2,-8(fp)
 d031144:	1005003a 	cmpeq	r2,r2,zero
 d031148:	1000091e 	bne	r2,zero,d031170 <tcp_mss+0x44>
 d03114c:	e0bffe17 	ldw	r2,-8(fp)
 d031150:	10800117 	ldw	r2,4(r2)
 d031154:	1005003a 	cmpeq	r2,r2,zero
 d031158:	1000051e 	bne	r2,zero,d031170 <tcp_mss+0x44>
 d03115c:	e0bffe17 	ldw	r2,-8(fp)
 d031160:	10800117 	ldw	r2,4(r2)
 d031164:	10800a17 	ldw	r2,40(r2)
 d031168:	1004c03a 	cmpne	r2,r2,zero
 d03116c:	1000071e 	bne	r2,zero,d03118c <tcp_mss+0x60>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 d031170:	e0bffe17 	ldw	r2,-8(fp)
 d031174:	10800517 	ldw	r2,20(r2)
 d031178:	10800098 	cmpnei	r2,r2,2
 d03117c:	1000031e 	bne	r2,zero,d03118c <tcp_mss+0x60>
         return TCP_MSS;            /* user defined */
 d031180:	00816d04 	movi	r2,1460
 d031184:	e0bfff15 	stw	r2,-4(fp)
 d031188:	00002906 	br	d031230 <tcp_mss+0x104>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 d03118c:	e13ffe17 	ldw	r4,-8(fp)
 d031190:	d0310e40 	call	d0310e4 <ip4_tcpmss>
 d031194:	e0bffd15 	stw	r2,-12(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 d031198:	e0bffd17 	ldw	r2,-12(fp)
 d03119c:	10816d50 	cmplti	r2,r2,1461
 d0311a0:	1000021e 	bne	r2,zero,d0311ac <tcp_mss+0x80>
      mss = TCP_MSS;
 d0311a4:	00816d04 	movi	r2,1460
 d0311a8:	e0bffd15 	stw	r2,-12(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 d0311ac:	e0bffe17 	ldw	r2,-8(fp)
 d0311b0:	10800117 	ldw	r2,4(r2)
 d0311b4:	e0bffc15 	stw	r2,-16(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 d0311b8:	e0bffc17 	ldw	r2,-16(fp)
 d0311bc:	10800917 	ldw	r2,36(r2)
 d0311c0:	e0bffb15 	stw	r2,-20(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 d0311c4:	e0bffb17 	ldw	r2,-20(fp)
 d0311c8:	10800b0b 	ldhu	r2,44(r2)
 d0311cc:	10bfffcc 	andi	r2,r2,65535
 d0311d0:	1081000c 	andi	r2,r2,1024
 d0311d4:	1005003a 	cmpeq	r2,r2,zero
 d0311d8:	1000051e 	bne	r2,zero,d0311f0 <tcp_mss+0xc4>
      return tp->t_maxseg;    /* yup */
 d0311dc:	e0bffb17 	ldw	r2,-20(fp)
 d0311e0:	10800a0b 	ldhu	r2,40(r2)
 d0311e4:	10bfffcc 	andi	r2,r2,65535
 d0311e8:	e0bfff15 	stw	r2,-4(fp)
 d0311ec:	00001006 	br	d031230 <tcp_mss+0x104>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 d0311f0:	e0bffb17 	ldw	r2,-20(fp)
 d0311f4:	10800a0b 	ldhu	r2,40(r2)
 d0311f8:	10bfffcc 	andi	r2,r2,65535
 d0311fc:	1005003a 	cmpeq	r2,r2,zero
 d031200:	1000091e 	bne	r2,zero,d031228 <tcp_mss+0xfc>
 d031204:	e0bffb17 	ldw	r2,-20(fp)
 d031208:	10800a0b 	ldhu	r2,40(r2)
 d03120c:	10ffffcc 	andi	r3,r2,65535
 d031210:	e0bffd17 	ldw	r2,-12(fp)
 d031214:	1880040e 	bge	r3,r2,d031228 <tcp_mss+0xfc>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 d031218:	e0bffb17 	ldw	r2,-20(fp)
 d03121c:	10800a0b 	ldhu	r2,40(r2)
 d031220:	10bfffcc 	andi	r2,r2,65535
 d031224:	e0bffd15 	stw	r2,-12(fp)
   }

   return mss;
 d031228:	e0bffd17 	ldw	r2,-12(fp)
 d03122c:	e0bfff15 	stw	r2,-4(fp)
 d031230:	e0bfff17 	ldw	r2,-4(fp)
}
 d031234:	e037883a 	mov	sp,fp
 d031238:	dfc00117 	ldw	ra,4(sp)
 d03123c:	df000017 	ldw	fp,0(sp)
 d031240:	dec00204 	addi	sp,sp,8
 d031244:	f800283a 	ret

0d031248 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 d031248:	deffe004 	addi	sp,sp,-128
 d03124c:	dfc01f15 	stw	ra,124(sp)
 d031250:	df001e15 	stw	fp,120(sp)
 d031254:	df001e04 	addi	fp,sp,120
 d031258:	e13ff715 	stw	r4,-36(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d03125c:	e0bff717 	ldw	r2,-36(fp)
 d031260:	10800d17 	ldw	r2,52(r2)
 d031264:	10800817 	ldw	r2,32(r2)
 d031268:	e0bff515 	stw	r2,-44(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 d03126c:	e03fed15 	stw	zero,-76(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 d031270:	e0bff717 	ldw	r2,-36(fp)
 d031274:	10c01a17 	ldw	r3,104(r2)
 d031278:	e0bff717 	ldw	r2,-36(fp)
 d03127c:	10800e17 	ldw	r2,56(r2)
 d031280:	1885003a 	cmpeq	r2,r3,r2
 d031284:	e0bfec15 	stw	r2,-80(fp)

again:
   sendalot = 0;
 d031288:	e03feb15 	stw	zero,-84(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 d03128c:	e0bff717 	ldw	r2,-36(fp)
 d031290:	10c00f17 	ldw	r3,60(r2)
 d031294:	e0bff717 	ldw	r2,-36(fp)
 d031298:	10800e17 	ldw	r2,56(r2)
 d03129c:	1885c83a 	sub	r2,r3,r2
 d0312a0:	e0bff215 	stw	r2,-56(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 d0312a4:	e0bff717 	ldw	r2,-36(fp)
 d0312a8:	10801417 	ldw	r2,80(r2)
 d0312ac:	e0bff315 	stw	r2,-52(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 d0312b0:	e0bff717 	ldw	r2,-36(fp)
 d0312b4:	10801b17 	ldw	r2,108(r2)
 d0312b8:	1007883a 	mov	r3,r2
 d0312bc:	e0bff317 	ldw	r2,-52(fp)
 d0312c0:	1880060e 	bge	r3,r2,d0312dc <tcp_output+0x94>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 d0312c4:	e0bff717 	ldw	r2,-36(fp)
 d0312c8:	10801b17 	ldw	r2,108(r2)
 d0312cc:	1007883a 	mov	r3,r2
 d0312d0:	00bfff04 	movi	r2,-4
 d0312d4:	1884703a 	and	r2,r3,r2
 d0312d8:	e0bff315 	stw	r2,-52(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 d0312dc:	e0bff717 	ldw	r2,-36(fp)
 d0312e0:	10800a83 	ldbu	r2,42(r2)
 d0312e4:	10803fcc 	andi	r2,r2,255
 d0312e8:	1080201c 	xori	r2,r2,128
 d0312ec:	10bfe004 	addi	r2,r2,-128
 d0312f0:	1005003a 	cmpeq	r2,r2,zero
 d0312f4:	10000a1e 	bne	r2,zero,d031320 <tcp_output+0xd8>
   {
      if (win == 0)
 d0312f8:	e0bff317 	ldw	r2,-52(fp)
 d0312fc:	1004c03a 	cmpne	r2,r2,zero
 d031300:	1000031e 	bne	r2,zero,d031310 <tcp_output+0xc8>
         win = 1;
 d031304:	00800044 	movi	r2,1
 d031308:	e0bff315 	stw	r2,-52(fp)
 d03130c:	00000406 	br	d031320 <tcp_output+0xd8>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 d031310:	e0bff717 	ldw	r2,-36(fp)
 d031314:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 d031318:	e0bff717 	ldw	r2,-36(fp)
 d03131c:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 d031320:	e0bff517 	ldw	r2,-44(fp)
 d031324:	10801217 	ldw	r2,72(r2)
 d031328:	e0fff317 	ldw	r3,-52(fp)
 d03132c:	e0fffb15 	stw	r3,-20(fp)
 d031330:	e0bffa15 	stw	r2,-24(fp)
 d031334:	e0bffb17 	ldw	r2,-20(fp)
 d031338:	e0fffa17 	ldw	r3,-24(fp)
 d03133c:	10c0022e 	bgeu	r2,r3,d031348 <tcp_output+0x100>
 d031340:	e0bffb17 	ldw	r2,-20(fp)
 d031344:	e0bffa15 	stw	r2,-24(fp)
 d031348:	e0fffa17 	ldw	r3,-24(fp)
 d03134c:	e0bff217 	ldw	r2,-56(fp)
 d031350:	1885c83a 	sub	r2,r3,r2
 d031354:	e0bff415 	stw	r2,-48(fp)
   }

   flags = tcp_outflags[tp->t_state];
 d031358:	e0bff717 	ldw	r2,-36(fp)
 d03135c:	10c00217 	ldw	r3,8(r2)
 d031360:	00834174 	movhi	r2,3333
 d031364:	10914b04 	addi	r2,r2,17708
 d031368:	10c5883a 	add	r2,r2,r3
 d03136c:	10800003 	ldbu	r2,0(r2)
 d031370:	10803fcc 	andi	r2,r2,255
 d031374:	e0bff115 	stw	r2,-60(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 d031378:	e0bff117 	ldw	r2,-60(fp)
 d03137c:	1080008c 	andi	r2,r2,2
 d031380:	1005003a 	cmpeq	r2,r2,zero
 d031384:	1000081e 	bne	r2,zero,d0313a8 <tcp_output+0x160>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 d031388:	e0ffed17 	ldw	r3,-76(fp)
 d03138c:	d0a93104 	addi	r2,gp,-23356
 d031390:	188b883a 	add	r5,r3,r2
 d031394:	e13ff717 	ldw	r4,-36(fp)
 d031398:	e1bff117 	ldw	r6,-60(fp)
 d03139c:	e1fff517 	ldw	r7,-44(fp)
 d0313a0:	d0324d00 	call	d0324d0 <bld_options>
 d0313a4:	e0bfed15 	stw	r2,-76(fp)
   }
#endif

   if (len < 0)
 d0313a8:	e0bff417 	ldw	r2,-48(fp)
 d0313ac:	1004403a 	cmpge	r2,r2,zero
 d0313b0:	10000a1e 	bne	r2,zero,d0313dc <tcp_output+0x194>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 d0313b4:	e03ff415 	stw	zero,-48(fp)
      if (win == 0) 
 d0313b8:	e0bff317 	ldw	r2,-52(fp)
 d0313bc:	1004c03a 	cmpne	r2,r2,zero
 d0313c0:	1000061e 	bne	r2,zero,d0313dc <tcp_output+0x194>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 d0313c4:	e0bff717 	ldw	r2,-36(fp)
 d0313c8:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 d0313cc:	e0bff717 	ldw	r2,-36(fp)
 d0313d0:	10c00e17 	ldw	r3,56(r2)
 d0313d4:	e0bff717 	ldw	r2,-36(fp)
 d0313d8:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 d0313dc:	e0bff717 	ldw	r2,-36(fp)
 d0313e0:	10800a0b 	ldhu	r2,40(r2)
 d0313e4:	10ffffcc 	andi	r3,r2,65535
 d0313e8:	e0bff417 	ldw	r2,-48(fp)
 d0313ec:	1880060e 	bge	r3,r2,d031408 <tcp_output+0x1c0>
   {
      len = tp->t_maxseg;
 d0313f0:	e0bff717 	ldw	r2,-36(fp)
 d0313f4:	10800a0b 	ldhu	r2,40(r2)
 d0313f8:	10bfffcc 	andi	r2,r2,65535
 d0313fc:	e0bff415 	stw	r2,-48(fp)
      sendalot = 1;
 d031400:	00800044 	movi	r2,1
 d031404:	e0bfeb15 	stw	r2,-84(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 d031408:	e0bff717 	ldw	r2,-36(fp)
 d03140c:	10c00f17 	ldw	r3,60(r2)
 d031410:	e0bff417 	ldw	r2,-48(fp)
 d031414:	1889883a 	add	r4,r3,r2
 d031418:	e0bff717 	ldw	r2,-36(fp)
 d03141c:	10c00e17 	ldw	r3,56(r2)
 d031420:	e0bff517 	ldw	r2,-44(fp)
 d031424:	10801217 	ldw	r2,72(r2)
 d031428:	1885883a 	add	r2,r3,r2
 d03142c:	2085c83a 	sub	r2,r4,r2
 d031430:	1004403a 	cmpge	r2,r2,zero
 d031434:	1000041e 	bne	r2,zero,d031448 <tcp_output+0x200>
      flags &= ~TH_FIN;
 d031438:	e0bff117 	ldw	r2,-60(fp)
 d03143c:	00ffff84 	movi	r3,-2
 d031440:	10c4703a 	and	r2,r2,r3
 d031444:	e0bff115 	stw	r2,-60(fp)
   win = (long)(sbspace(&so->so_rcv));
 d031448:	e0bff517 	ldw	r2,-44(fp)
 d03144c:	10800b17 	ldw	r2,44(r2)
 d031450:	1007883a 	mov	r3,r2
 d031454:	e0bff517 	ldw	r2,-44(fp)
 d031458:	10800a17 	ldw	r2,40(r2)
 d03145c:	1885c83a 	sub	r2,r3,r2
 d031460:	1004803a 	cmplt	r2,r2,zero
 d031464:	1000071e 	bne	r2,zero,d031484 <tcp_output+0x23c>
 d031468:	e0bff517 	ldw	r2,-44(fp)
 d03146c:	10c00b17 	ldw	r3,44(r2)
 d031470:	e0bff517 	ldw	r2,-44(fp)
 d031474:	10800a17 	ldw	r2,40(r2)
 d031478:	1885c83a 	sub	r2,r3,r2
 d03147c:	e0bff915 	stw	r2,-28(fp)
 d031480:	00000106 	br	d031488 <tcp_output+0x240>
 d031484:	e03ff915 	stw	zero,-28(fp)
 d031488:	e0fff917 	ldw	r3,-28(fp)
 d03148c:	e0fff315 	stw	r3,-52(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 d031490:	e0bff117 	ldw	r2,-60(fp)
 d031494:	1080004c 	andi	r2,r2,1
 d031498:	10803fcc 	andi	r2,r2,255
 d03149c:	1005003a 	cmpeq	r2,r2,zero
 d0314a0:	10000f1e 	bne	r2,zero,d0314e0 <tcp_output+0x298>
 d0314a4:	e0bff517 	ldw	r2,-44(fp)
 d0314a8:	10801217 	ldw	r2,72(r2)
 d0314ac:	1004c03a 	cmpne	r2,r2,zero
 d0314b0:	10000b1e 	bne	r2,zero,d0314e0 <tcp_output+0x298>
 d0314b4:	e0bff717 	ldw	r2,-36(fp)
 d0314b8:	10800b0b 	ldhu	r2,44(r2)
 d0314bc:	10bfffcc 	andi	r2,r2,65535
 d0314c0:	1080040c 	andi	r2,r2,16
 d0314c4:	1005003a 	cmpeq	r2,r2,zero
 d0314c8:	1000741e 	bne	r2,zero,d03169c <tcp_output+0x454>
 d0314cc:	e0bff717 	ldw	r2,-36(fp)
 d0314d0:	10c00f17 	ldw	r3,60(r2)
 d0314d4:	e0bff717 	ldw	r2,-36(fp)
 d0314d8:	10800e17 	ldw	r2,56(r2)
 d0314dc:	18806f26 	beq	r3,r2,d03169c <tcp_output+0x454>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 d0314e0:	e0bff717 	ldw	r2,-36(fp)
 d0314e4:	10800b0b 	ldhu	r2,44(r2)
 d0314e8:	10bfffcc 	andi	r2,r2,65535
 d0314ec:	1080004c 	andi	r2,r2,1
 d0314f0:	10803fcc 	andi	r2,r2,255
 d0314f4:	1004c03a 	cmpne	r2,r2,zero
 d0314f8:	1000681e 	bne	r2,zero,d03169c <tcp_output+0x454>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 d0314fc:	e0bff117 	ldw	r2,-60(fp)
 d031500:	1080018c 	andi	r2,r2,6
 d031504:	1004c03a 	cmpne	r2,r2,zero
 d031508:	1000641e 	bne	r2,zero,d03169c <tcp_output+0x454>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 d03150c:	e0bff717 	ldw	r2,-36(fp)
 d031510:	10c01017 	ldw	r3,64(r2)
 d031514:	e0bff717 	ldw	r2,-36(fp)
 d031518:	10800e17 	ldw	r2,56(r2)
 d03151c:	1885c83a 	sub	r2,r3,r2
 d031520:	10800048 	cmpgei	r2,r2,1
 d031524:	10005d1e 	bne	r2,zero,d03169c <tcp_output+0x454>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 d031528:	e0bff417 	ldw	r2,-48(fp)
 d03152c:	1005003a 	cmpeq	r2,r2,zero
 d031530:	1000281e 	bne	r2,zero,d0315d4 <tcp_output+0x38c>
   {
      if (len == (int)tp->t_maxseg)
 d031534:	e0bff717 	ldw	r2,-36(fp)
 d031538:	10800a0b 	ldhu	r2,40(r2)
 d03153c:	10ffffcc 	andi	r3,r2,65535
 d031540:	e0bff417 	ldw	r2,-48(fp)
 d031544:	18805526 	beq	r3,r2,d03169c <tcp_output+0x454>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 d031548:	e0bfec17 	ldw	r2,-80(fp)
 d03154c:	1004c03a 	cmpne	r2,r2,zero
 d031550:	1000061e 	bne	r2,zero,d03156c <tcp_output+0x324>
 d031554:	e0bff717 	ldw	r2,-36(fp)
 d031558:	10800b0b 	ldhu	r2,44(r2)
 d03155c:	10bfffcc 	andi	r2,r2,65535
 d031560:	1080010c 	andi	r2,r2,4
 d031564:	1005003a 	cmpeq	r2,r2,zero
 d031568:	1000061e 	bne	r2,zero,d031584 <tcp_output+0x33c>
 d03156c:	e0fff417 	ldw	r3,-48(fp)
 d031570:	e0bff217 	ldw	r2,-56(fp)
 d031574:	1887883a 	add	r3,r3,r2
 d031578:	e0bff517 	ldw	r2,-44(fp)
 d03157c:	10801217 	ldw	r2,72(r2)
 d031580:	1880460e 	bge	r3,r2,d03169c <tcp_output+0x454>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 d031584:	e0bff717 	ldw	r2,-36(fp)
 d031588:	10800a83 	ldbu	r2,42(r2)
 d03158c:	10803fcc 	andi	r2,r2,255
 d031590:	1080201c 	xori	r2,r2,128
 d031594:	10bfe004 	addi	r2,r2,-128
 d031598:	1004c03a 	cmpne	r2,r2,zero
 d03159c:	10003f1e 	bne	r2,zero,d03169c <tcp_output+0x454>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 d0315a0:	e0bff717 	ldw	r2,-36(fp)
 d0315a4:	10802317 	ldw	r2,140(r2)
 d0315a8:	1004d07a 	srli	r2,r2,1
 d0315ac:	1007883a 	mov	r3,r2
 d0315b0:	e0bff417 	ldw	r2,-48(fp)
 d0315b4:	10c0390e 	bge	r2,r3,d03169c <tcp_output+0x454>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 d0315b8:	e0bff717 	ldw	r2,-36(fp)
 d0315bc:	10c00f17 	ldw	r3,60(r2)
 d0315c0:	e0bff717 	ldw	r2,-36(fp)
 d0315c4:	10801a17 	ldw	r2,104(r2)
 d0315c8:	1885c83a 	sub	r2,r3,r2
 d0315cc:	1004803a 	cmplt	r2,r2,zero
 d0315d0:	1000321e 	bne	r2,zero,d03169c <tcp_output+0x454>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 d0315d4:	e0bff317 	ldw	r2,-52(fp)
 d0315d8:	10800050 	cmplti	r2,r2,1
 d0315dc:	10001d1e 	bne	r2,zero,d031654 <tcp_output+0x40c>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 d0315e0:	e0bff717 	ldw	r2,-36(fp)
 d0315e4:	10c01917 	ldw	r3,100(r2)
 d0315e8:	e0bff717 	ldw	r2,-36(fp)
 d0315ec:	10801617 	ldw	r2,88(r2)
 d0315f0:	1885c83a 	sub	r2,r3,r2
 d0315f4:	1007883a 	mov	r3,r2
 d0315f8:	e0bff317 	ldw	r2,-52(fp)
 d0315fc:	10c5c83a 	sub	r2,r2,r3
 d031600:	e0bfe715 	stw	r2,-100(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 d031604:	e0bff517 	ldw	r2,-44(fp)
 d031608:	10800a17 	ldw	r2,40(r2)
 d03160c:	1004c03a 	cmpne	r2,r2,zero
 d031610:	1000071e 	bne	r2,zero,d031630 <tcp_output+0x3e8>
 d031614:	e0bff717 	ldw	r2,-36(fp)
 d031618:	10800a0b 	ldhu	r2,40(r2)
 d03161c:	10bfffcc 	andi	r2,r2,65535
 d031620:	1085883a 	add	r2,r2,r2
 d031624:	1007883a 	mov	r3,r2
 d031628:	e0bfe717 	ldw	r2,-100(fp)
 d03162c:	10c01b0e 	bge	r2,r3,d03169c <tcp_output+0x454>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 d031630:	e13fe717 	ldw	r4,-100(fp)
 d031634:	01401904 	movi	r5,100
 d031638:	d00235c0 	call	d00235c <__mulsi3>
 d03163c:	1009883a 	mov	r4,r2
 d031640:	e0bff517 	ldw	r2,-44(fp)
 d031644:	11400b17 	ldw	r5,44(r2)
 d031648:	d00c90c0 	call	d00c90c <__udivsi3>
 d03164c:	108008e8 	cmpgeui	r2,r2,35
 d031650:	1000121e 	bne	r2,zero,d03169c <tcp_output+0x454>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 d031654:	e0bff517 	ldw	r2,-44(fp)
 d031658:	10801217 	ldw	r2,72(r2)
 d03165c:	1005003a 	cmpeq	r2,r2,zero
 d031660:	10000c1e 	bne	r2,zero,d031694 <tcp_output+0x44c>
 d031664:	e0bff717 	ldw	r2,-36(fp)
 d031668:	10800317 	ldw	r2,12(r2)
 d03166c:	1004c03a 	cmpne	r2,r2,zero
 d031670:	1000081e 	bne	r2,zero,d031694 <tcp_output+0x44c>
 d031674:	e0bff717 	ldw	r2,-36(fp)
 d031678:	10800417 	ldw	r2,16(r2)
 d03167c:	1004c03a 	cmpne	r2,r2,zero
 d031680:	1000041e 	bne	r2,zero,d031694 <tcp_output+0x44c>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 d031684:	e0bff717 	ldw	r2,-36(fp)
 d031688:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 d03168c:	e13ff717 	ldw	r4,-36(fp)
 d031690:	d0323d40 	call	d0323d4 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 d031694:	e03ff815 	stw	zero,-32(fp)
 d031698:	00034806 	br	d0323bc <tcp_output+0x1174>

send:
   ENTER_CRIT_SECTION(tp);
 d03169c:	d025c500 	call	d025c50 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 d0316a0:	e0bff217 	ldw	r2,-56(fp)
 d0316a4:	e0bfe815 	stw	r2,-96(fp)
   sendm = so->so_snd.sb_mb;
 d0316a8:	e0bff517 	ldw	r2,-44(fp)
 d0316ac:	10801817 	ldw	r2,96(r2)
 d0316b0:	e0bfea15 	stw	r2,-88(fp)
   if (len)
 d0316b4:	e0bff417 	ldw	r2,-48(fp)
 d0316b8:	1005003a 	cmpeq	r2,r2,zero
 d0316bc:	10006b1e 	bne	r2,zero,d03186c <tcp_output+0x624>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 d0316c0:	00000b06 	br	d0316f0 <tcp_output+0x4a8>
      {
         bufoff -= sendm->m_len;
 d0316c4:	e0ffe817 	ldw	r3,-96(fp)
 d0316c8:	e0bfea17 	ldw	r2,-88(fp)
 d0316cc:	10800217 	ldw	r2,8(r2)
 d0316d0:	1885c83a 	sub	r2,r3,r2
 d0316d4:	e0bfe815 	stw	r2,-96(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 d0316d8:	e0bfe817 	ldw	r2,-96(fp)
 d0316dc:	1004803a 	cmplt	r2,r2,zero
 d0316e0:	1000061e 	bne	r2,zero,d0316fc <tcp_output+0x4b4>
            break;
         sendm = sendm->m_next;
 d0316e4:	e0bfea17 	ldw	r2,-88(fp)
 d0316e8:	10800617 	ldw	r2,24(r2)
 d0316ec:	e0bfea15 	stw	r2,-88(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 d0316f0:	e0bfea17 	ldw	r2,-88(fp)
 d0316f4:	1004c03a 	cmpne	r2,r2,zero
 d0316f8:	103ff21e 	bne	r2,zero,d0316c4 <tcp_output+0x47c>
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 d0316fc:	e0bfea17 	ldw	r2,-88(fp)
 d031700:	1004c03a 	cmpne	r2,r2,zero
 d031704:	1000011e 	bne	r2,zero,d03170c <tcp_output+0x4c4>
 d031708:	d025a500 	call	d025a50 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 d03170c:	e0bfea17 	ldw	r2,-88(fp)
 d031710:	10c00217 	ldw	r3,8(r2)
 d031714:	e0bfe817 	ldw	r2,-96(fp)
 d031718:	1885883a 	add	r2,r3,r2
 d03171c:	e0bfe815 	stw	r2,-96(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 d031720:	e0bfea17 	ldw	r2,-88(fp)
 d031724:	10800617 	ldw	r2,24(r2)
 d031728:	1005003a 	cmpeq	r2,r2,zero
 d03172c:	10000b1e 	bne	r2,zero,d03175c <tcp_output+0x514>
 d031730:	e0bfea17 	ldw	r2,-88(fp)
 d031734:	10800217 	ldw	r2,8(r2)
 d031738:	1007883a 	mov	r3,r2
 d03173c:	e0bff417 	ldw	r2,-48(fp)
 d031740:	1880060e 	bge	r3,r2,d03175c <tcp_output+0x514>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 d031744:	e0fff117 	ldw	r3,-60(fp)
 d031748:	00bfff84 	movi	r2,-2
 d03174c:	1884703a 	and	r2,r3,r2
 d031750:	e0bff115 	stw	r2,-60(fp)
         sendalot = 1;     /* set to send more segments */
 d031754:	00800044 	movi	r2,1
 d031758:	e0bfeb15 	stw	r2,-84(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 d03175c:	e0bff117 	ldw	r2,-60(fp)
 d031760:	1080004c 	andi	r2,r2,1
 d031764:	10803fcc 	andi	r2,r2,255
 d031768:	1005003a 	cmpeq	r2,r2,zero
 d03176c:	1000081e 	bne	r2,zero,d031790 <tcp_output+0x548>
 d031770:	e0bff517 	ldw	r2,-44(fp)
 d031774:	10c01217 	ldw	r3,72(r2)
 d031778:	e0bff417 	ldw	r2,-48(fp)
 d03177c:	10c0042e 	bgeu	r2,r3,d031790 <tcp_output+0x548>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 d031780:	e0bff117 	ldw	r2,-60(fp)
 d031784:	00ffff84 	movi	r3,-2
 d031788:	10c4703a 	and	r2,r2,r3
 d03178c:	e0bff115 	stw	r2,-60(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 d031790:	e0bfea17 	ldw	r2,-88(fp)
 d031794:	10800217 	ldw	r2,8(r2)
 d031798:	e0fff417 	ldw	r3,-48(fp)
 d03179c:	e0fffd15 	stw	r3,-12(fp)
 d0317a0:	e0bffc15 	stw	r2,-16(fp)
 d0317a4:	e0bffd17 	ldw	r2,-12(fp)
 d0317a8:	e0fffc17 	ldw	r3,-16(fp)
 d0317ac:	10c0020e 	bge	r2,r3,d0317b8 <tcp_output+0x570>
 d0317b0:	e0bffd17 	ldw	r2,-12(fp)
 d0317b4:	e0bffc15 	stw	r2,-16(fp)
 d0317b8:	e0fffc17 	ldw	r3,-16(fp)
 d0317bc:	e0fff415 	stw	r3,-48(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 d0317c0:	e0bfe817 	ldw	r2,-96(fp)
 d0317c4:	1004c03a 	cmpne	r2,r2,zero
 d0317c8:	1000091e 	bne	r2,zero,d0317f0 <tcp_output+0x5a8>
 d0317cc:	e0bfea17 	ldw	r2,-88(fp)
 d0317d0:	10800317 	ldw	r2,12(r2)
 d0317d4:	1007883a 	mov	r3,r2
 d0317d8:	e0bfea17 	ldw	r2,-88(fp)
 d0317dc:	10800417 	ldw	r2,16(r2)
 d0317e0:	1885c83a 	sub	r2,r3,r2
 d0317e4:	108000cc 	andi	r2,r2,3
 d0317e8:	1005003a 	cmpeq	r2,r2,zero
 d0317ec:	10001f1e 	bne	r2,zero,d03186c <tcp_output+0x624>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 d0317f0:	e0bfea17 	ldw	r2,-88(fp)
 d0317f4:	10c00217 	ldw	r3,8(r2)
 d0317f8:	e0bfe817 	ldw	r2,-96(fp)
 d0317fc:	1885c83a 	sub	r2,r3,r2
 d031800:	e0fff417 	ldw	r3,-48(fp)
 d031804:	e0ffff15 	stw	r3,-4(fp)
 d031808:	e0bffe15 	stw	r2,-8(fp)
 d03180c:	e0bfff17 	ldw	r2,-4(fp)
 d031810:	e0fffe17 	ldw	r3,-8(fp)
 d031814:	10c0020e 	bge	r2,r3,d031820 <tcp_output+0x5d8>
 d031818:	e0bfff17 	ldw	r2,-4(fp)
 d03181c:	e0bffe15 	stw	r2,-8(fp)
 d031820:	e0fffe17 	ldw	r3,-8(fp)
 d031824:	e0fff415 	stw	r3,-48(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 d031828:	00834174 	movhi	r2,3333
 d03182c:	10925504 	addi	r2,r2,18772
 d031830:	10800017 	ldw	r2,0(r2)
 d031834:	10bff204 	addi	r2,r2,-56
 d031838:	1007883a 	mov	r3,r2
 d03183c:	e0bff417 	ldw	r2,-48(fp)
 d031840:	18800a0e 	bge	r3,r2,d03186c <tcp_output+0x624>
 d031844:	008341b4 	movhi	r2,3334
 d031848:	1083c104 	addi	r2,r2,3844
 d03184c:	10800217 	ldw	r2,8(r2)
 d031850:	10800088 	cmpgei	r2,r2,2
 d031854:	1000051e 	bne	r2,zero,d03186c <tcp_output+0x624>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 d031858:	00834174 	movhi	r2,3333
 d03185c:	10925504 	addi	r2,r2,18772
 d031860:	10800017 	ldw	r2,0(r2)
 d031864:	10bff204 	addi	r2,r2,-56
 d031868:	e0bff415 	stw	r2,-48(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 d03186c:	e0bff417 	ldw	r2,-48(fp)
 d031870:	1005003a 	cmpeq	r2,r2,zero
 d031874:	10003b1e 	bne	r2,zero,d031964 <tcp_output+0x71c>
 d031878:	e0bfe817 	ldw	r2,-96(fp)
 d03187c:	1004c03a 	cmpne	r2,r2,zero
 d031880:	1000381e 	bne	r2,zero,d031964 <tcp_output+0x71c>
 d031884:	e0bfea17 	ldw	r2,-88(fp)
 d031888:	10800117 	ldw	r2,4(r2)
 d03188c:	10800917 	ldw	r2,36(r2)
 d031890:	10800058 	cmpnei	r2,r2,1
 d031894:	1000331e 	bne	r2,zero,d031964 <tcp_output+0x71c>
 d031898:	e0bfea17 	ldw	r2,-88(fp)
 d03189c:	10800317 	ldw	r2,12(r2)
 d0318a0:	1007883a 	mov	r3,r2
 d0318a4:	e0bfea17 	ldw	r2,-88(fp)
 d0318a8:	10800417 	ldw	r2,16(r2)
 d0318ac:	1885c83a 	sub	r2,r3,r2
 d0318b0:	108000cc 	andi	r2,r2,3
 d0318b4:	1004c03a 	cmpne	r2,r2,zero
 d0318b8:	10002a1e 	bne	r2,zero,d031964 <tcp_output+0x71c>
 d0318bc:	e0bfed17 	ldw	r2,-76(fp)
 d0318c0:	1004c03a 	cmpne	r2,r2,zero
 d0318c4:	1000271e 	bne	r2,zero,d031964 <tcp_output+0x71c>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 d0318c8:	01000084 	movi	r4,2
 d0318cc:	000b883a 	mov	r5,zero
 d0318d0:	d0268740 	call	d026874 <m_getnbuf>
 d0318d4:	e0bfef15 	stw	r2,-68(fp)
      if (!m)
 d0318d8:	e0bfef17 	ldw	r2,-68(fp)
 d0318dc:	1004c03a 	cmpne	r2,r2,zero
 d0318e0:	1000041e 	bne	r2,zero,d0318f4 <tcp_output+0x6ac>
      {
         EXIT_CRIT_SECTION(tp);
 d0318e4:	d025cac0 	call	d025cac <irq_Unmask>
         return (ENOBUFS);
 d0318e8:	00801a44 	movi	r2,105
 d0318ec:	e0bff815 	stw	r2,-32(fp)
 d0318f0:	0002b206 	br	d0323bc <tcp_output+0x1174>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 d0318f4:	e0bfea17 	ldw	r2,-88(fp)
 d0318f8:	10c00117 	ldw	r3,4(r2)
 d0318fc:	e0bfef17 	ldw	r2,-68(fp)
 d031900:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 d031904:	e0bfef17 	ldw	r2,-68(fp)
 d031908:	10c00117 	ldw	r3,4(r2)
 d03190c:	18800917 	ldw	r2,36(r3)
 d031910:	10800044 	addi	r2,r2,1
 d031914:	18800915 	stw	r2,36(r3)
      m->m_base = sendm->m_base; /* clone mbuf members */
 d031918:	e0bfea17 	ldw	r2,-88(fp)
 d03191c:	10c00417 	ldw	r3,16(r2)
 d031920:	e0bfef17 	ldw	r2,-68(fp)
 d031924:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 d031928:	e0bfea17 	ldw	r2,-88(fp)
 d03192c:	10c00517 	ldw	r3,20(r2)
 d031930:	e0bfef17 	ldw	r2,-68(fp)
 d031934:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 d031938:	e0bff417 	ldw	r2,-48(fp)
 d03193c:	10800a04 	addi	r2,r2,40
 d031940:	1007883a 	mov	r3,r2
 d031944:	e0bfef17 	ldw	r2,-68(fp)
 d031948:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 d03194c:	e0bfea17 	ldw	r2,-88(fp)
 d031950:	10800317 	ldw	r2,12(r2)
 d031954:	10fff604 	addi	r3,r2,-40
 d031958:	e0bfef17 	ldw	r2,-68(fp)
 d03195c:	10c00315 	stw	r3,12(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 d031960:	00002e06 	br	d031a1c <tcp_output+0x7d4>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 d031964:	00834174 	movhi	r2,3333
 d031968:	109b1e04 	addi	r2,r2,27768
 d03196c:	10800017 	ldw	r2,0(r2)
 d031970:	11400a04 	addi	r5,r2,40
 d031974:	010000c4 	movi	r4,3
 d031978:	d0268740 	call	d026874 <m_getnbuf>
 d03197c:	e0bfef15 	stw	r2,-68(fp)
      if (m ==(struct mbuf *)NULL)
 d031980:	e0bfef17 	ldw	r2,-68(fp)
 d031984:	1004c03a 	cmpne	r2,r2,zero
 d031988:	1000041e 	bne	r2,zero,d03199c <tcp_output+0x754>
      {
         EXIT_CRIT_SECTION(tp);
 d03198c:	d025cac0 	call	d025cac <irq_Unmask>
         return ENOBUFS;
 d031990:	00c01a44 	movi	r3,105
 d031994:	e0fff815 	stw	r3,-32(fp)
 d031998:	00028806 	br	d0323bc <tcp_output+0x1174>
      }

      m->m_len = TCPIPHDRSZ;
 d03199c:	e0ffef17 	ldw	r3,-68(fp)
 d0319a0:	00800a04 	movi	r2,40
 d0319a4:	18800215 	stw	r2,8(r3)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 d0319a8:	e0bfef17 	ldw	r2,-68(fp)
 d0319ac:	10c00317 	ldw	r3,12(r2)
 d0319b0:	00834174 	movhi	r2,3333
 d0319b4:	109b1e04 	addi	r2,r2,27768
 d0319b8:	10800017 	ldw	r2,0(r2)
 d0319bc:	1887883a 	add	r3,r3,r2
 d0319c0:	e0bfef17 	ldw	r2,-68(fp)
 d0319c4:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 d0319c8:	e0bff417 	ldw	r2,-48(fp)
 d0319cc:	1005003a 	cmpeq	r2,r2,zero
 d0319d0:	1000121e 	bne	r2,zero,d031a1c <tcp_output+0x7d4>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 d0319d4:	e0bff517 	ldw	r2,-44(fp)
 d0319d8:	11001817 	ldw	r4,96(r2)
 d0319dc:	e17ff217 	ldw	r5,-56(fp)
 d0319e0:	e1bff417 	ldw	r6,-48(fp)
 d0319e4:	d026b940 	call	d026b94 <m_copy>
 d0319e8:	1007883a 	mov	r3,r2
 d0319ec:	e0bfef17 	ldw	r2,-68(fp)
 d0319f0:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 d0319f4:	e0bfef17 	ldw	r2,-68(fp)
 d0319f8:	10800617 	ldw	r2,24(r2)
 d0319fc:	1004c03a 	cmpne	r2,r2,zero
 d031a00:	1000061e 	bne	r2,zero,d031a1c <tcp_output+0x7d4>
         {
            m_freem(m);
 d031a04:	e13fef17 	ldw	r4,-68(fp)
 d031a08:	d026b500 	call	d026b50 <m_freem>
            EXIT_CRIT_SECTION(tp);
 d031a0c:	d025cac0 	call	d025cac <irq_Unmask>
            return ENOBUFS;
 d031a10:	00801a44 	movi	r2,105
 d031a14:	e0bff815 	stw	r2,-32(fp)
 d031a18:	00026806 	br	d0323bc <tcp_output+0x1174>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 d031a1c:	d025cac0 	call	d025cac <irq_Unmask>

   if (len) 
 d031a20:	e0bff417 	ldw	r2,-48(fp)
 d031a24:	1005003a 	cmpeq	r2,r2,zero
 d031a28:	1000391e 	bne	r2,zero,d031b10 <tcp_output+0x8c8>
   {
      if (tp->t_force && len == 1)
 d031a2c:	e0bff717 	ldw	r2,-36(fp)
 d031a30:	10800a83 	ldbu	r2,42(r2)
 d031a34:	10803fcc 	andi	r2,r2,255
 d031a38:	1080201c 	xori	r2,r2,128
 d031a3c:	10bfe004 	addi	r2,r2,-128
 d031a40:	1005003a 	cmpeq	r2,r2,zero
 d031a44:	10000b1e 	bne	r2,zero,d031a74 <tcp_output+0x82c>
 d031a48:	e0bff417 	ldw	r2,-48(fp)
 d031a4c:	10800058 	cmpnei	r2,r2,1
 d031a50:	1000081e 	bne	r2,zero,d031a74 <tcp_output+0x82c>
         tcpstat.tcps_sndprobe++;
 d031a54:	008341b4 	movhi	r2,3334
 d031a58:	10848a04 	addi	r2,r2,4648
 d031a5c:	10801517 	ldw	r2,84(r2)
 d031a60:	10c00044 	addi	r3,r2,1
 d031a64:	008341b4 	movhi	r2,3334
 d031a68:	10848a04 	addi	r2,r2,4648
 d031a6c:	10c01515 	stw	r3,84(r2)
   }
   EXIT_CRIT_SECTION(tp);

   if (len) 
   {
      if (tp->t_force && len == 1)
 d031a70:	00005806 	br	d031bd4 <tcp_output+0x98c>
         tcpstat.tcps_sndprobe++;
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 d031a74:	e0bff717 	ldw	r2,-36(fp)
 d031a78:	10c00f17 	ldw	r3,60(r2)
 d031a7c:	e0bff717 	ldw	r2,-36(fp)
 d031a80:	10801a17 	ldw	r2,104(r2)
 d031a84:	1885c83a 	sub	r2,r3,r2
 d031a88:	1004403a 	cmpge	r2,r2,zero
 d031a8c:	1000101e 	bne	r2,zero,d031ad0 <tcp_output+0x888>
      {
         tcpstat.tcps_sndrexmitpack++;
 d031a90:	008341b4 	movhi	r2,3334
 d031a94:	10848a04 	addi	r2,r2,4648
 d031a98:	10801217 	ldw	r2,72(r2)
 d031a9c:	10c00044 	addi	r3,r2,1
 d031aa0:	008341b4 	movhi	r2,3334
 d031aa4:	10848a04 	addi	r2,r2,4648
 d031aa8:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 d031aac:	008341b4 	movhi	r2,3334
 d031ab0:	10848a04 	addi	r2,r2,4648
 d031ab4:	10c01317 	ldw	r3,76(r2)
 d031ab8:	e0bff417 	ldw	r2,-48(fp)
 d031abc:	1887883a 	add	r3,r3,r2
 d031ac0:	008341b4 	movhi	r2,3334
 d031ac4:	10848a04 	addi	r2,r2,4648
 d031ac8:	10c01315 	stw	r3,76(r2)
 d031acc:	00004106 	br	d031bd4 <tcp_output+0x98c>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 d031ad0:	008341b4 	movhi	r2,3334
 d031ad4:	10848a04 	addi	r2,r2,4648
 d031ad8:	10801017 	ldw	r2,64(r2)
 d031adc:	10c00044 	addi	r3,r2,1
 d031ae0:	008341b4 	movhi	r2,3334
 d031ae4:	10848a04 	addi	r2,r2,4648
 d031ae8:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 d031aec:	008341b4 	movhi	r2,3334
 d031af0:	10848a04 	addi	r2,r2,4648
 d031af4:	10c01117 	ldw	r3,68(r2)
 d031af8:	e0bff417 	ldw	r2,-48(fp)
 d031afc:	1887883a 	add	r3,r3,r2
 d031b00:	008341b4 	movhi	r2,3334
 d031b04:	10848a04 	addi	r2,r2,4648
 d031b08:	10c01115 	stw	r3,68(r2)
 d031b0c:	00003106 	br	d031bd4 <tcp_output+0x98c>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 d031b10:	e0bff717 	ldw	r2,-36(fp)
 d031b14:	10800b0b 	ldhu	r2,44(r2)
 d031b18:	10bfffcc 	andi	r2,r2,65535
 d031b1c:	1080004c 	andi	r2,r2,1
 d031b20:	10803fcc 	andi	r2,r2,255
 d031b24:	1005003a 	cmpeq	r2,r2,zero
 d031b28:	1000081e 	bne	r2,zero,d031b4c <tcp_output+0x904>
   {
      tcpstat.tcps_sndacks++;
 d031b2c:	008341b4 	movhi	r2,3334
 d031b30:	10848a04 	addi	r2,r2,4648
 d031b34:	10801417 	ldw	r2,80(r2)
 d031b38:	10c00044 	addi	r3,r2,1
 d031b3c:	008341b4 	movhi	r2,3334
 d031b40:	10848a04 	addi	r2,r2,4648
 d031b44:	10c01415 	stw	r3,80(r2)
 d031b48:	00002206 	br	d031bd4 <tcp_output+0x98c>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 d031b4c:	e0bff117 	ldw	r2,-60(fp)
 d031b50:	108001cc 	andi	r2,r2,7
 d031b54:	1005003a 	cmpeq	r2,r2,zero
 d031b58:	1000081e 	bne	r2,zero,d031b7c <tcp_output+0x934>
      tcpstat.tcps_sndctrl++;
 d031b5c:	008341b4 	movhi	r2,3334
 d031b60:	10848a04 	addi	r2,r2,4648
 d031b64:	10801817 	ldw	r2,96(r2)
 d031b68:	10c00044 	addi	r3,r2,1
 d031b6c:	008341b4 	movhi	r2,3334
 d031b70:	10848a04 	addi	r2,r2,4648
 d031b74:	10c01815 	stw	r3,96(r2)
 d031b78:	00001606 	br	d031bd4 <tcp_output+0x98c>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 d031b7c:	e0bff717 	ldw	r2,-36(fp)
 d031b80:	10c01017 	ldw	r3,64(r2)
 d031b84:	e0bff717 	ldw	r2,-36(fp)
 d031b88:	10800e17 	ldw	r2,56(r2)
 d031b8c:	1885c83a 	sub	r2,r3,r2
 d031b90:	10800050 	cmplti	r2,r2,1
 d031b94:	1000081e 	bne	r2,zero,d031bb8 <tcp_output+0x970>
      tcpstat.tcps_sndurg++;
 d031b98:	008341b4 	movhi	r2,3334
 d031b9c:	10848a04 	addi	r2,r2,4648
 d031ba0:	10801617 	ldw	r2,88(r2)
 d031ba4:	10c00044 	addi	r3,r2,1
 d031ba8:	008341b4 	movhi	r2,3334
 d031bac:	10848a04 	addi	r2,r2,4648
 d031bb0:	10c01615 	stw	r3,88(r2)
 d031bb4:	00000706 	br	d031bd4 <tcp_output+0x98c>
   else
      tcpstat.tcps_sndwinup++;
 d031bb8:	008341b4 	movhi	r2,3334
 d031bbc:	10848a04 	addi	r2,r2,4648
 d031bc0:	10801717 	ldw	r2,92(r2)
 d031bc4:	10c00044 	addi	r3,r2,1
 d031bc8:	008341b4 	movhi	r2,3334
 d031bcc:	10848a04 	addi	r2,r2,4648
 d031bd0:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 d031bd4:	e0bfef17 	ldw	r2,-68(fp)
 d031bd8:	10800317 	ldw	r2,12(r2)
 d031bdc:	e0bfee15 	stw	r2,-72(fp)
   if ((char *)ti < m->pkt->nb_buff)
 d031be0:	e0bfef17 	ldw	r2,-68(fp)
 d031be4:	10800117 	ldw	r2,4(r2)
 d031be8:	10c00117 	ldw	r3,4(r2)
 d031bec:	e0bfee17 	ldw	r2,-72(fp)
 d031bf0:	10c0032e 	bgeu	r2,r3,d031c00 <tcp_output+0x9b8>
   {
      panic("tcp_out- packet ptr underflow\n");
 d031bf4:	01034174 	movhi	r4,3333
 d031bf8:	213eae04 	addi	r4,r4,-1352
 d031bfc:	d02093c0 	call	d02093c <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 d031c00:	e0bfef17 	ldw	r2,-68(fp)
 d031c04:	e0bfe915 	stw	r2,-92(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 d031c08:	e0bff717 	ldw	r2,-36(fp)
 d031c0c:	10800c17 	ldw	r2,48(r2)
 d031c10:	1004c03a 	cmpne	r2,r2,zero
 d031c14:	1000031e 	bne	r2,zero,d031c24 <tcp_output+0x9dc>
      panic("tcp_output");
 d031c18:	01034174 	movhi	r4,3333
 d031c1c:	213eb604 	addi	r4,r4,-1320
 d031c20:	d02093c0 	call	d02093c <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 d031c24:	e0ffee17 	ldw	r3,-72(fp)
 d031c28:	e0bff717 	ldw	r2,-36(fp)
 d031c2c:	10800c17 	ldw	r2,48(r2)
 d031c30:	1809883a 	mov	r4,r3
 d031c34:	100b883a 	mov	r5,r2
 d031c38:	01800a04 	movi	r6,40
 d031c3c:	d0026080 	call	d002608 <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 d031c40:	e0bff117 	ldw	r2,-60(fp)
 d031c44:	1080004c 	andi	r2,r2,1
 d031c48:	10803fcc 	andi	r2,r2,255
 d031c4c:	1005003a 	cmpeq	r2,r2,zero
 d031c50:	1000101e 	bne	r2,zero,d031c94 <tcp_output+0xa4c>
 d031c54:	e0bff717 	ldw	r2,-36(fp)
 d031c58:	10800b0b 	ldhu	r2,44(r2)
 d031c5c:	10bfffcc 	andi	r2,r2,65535
 d031c60:	1080040c 	andi	r2,r2,16
 d031c64:	1005003a 	cmpeq	r2,r2,zero
 d031c68:	10000a1e 	bne	r2,zero,d031c94 <tcp_output+0xa4c>
 d031c6c:	e0bff717 	ldw	r2,-36(fp)
 d031c70:	10c00f17 	ldw	r3,60(r2)
 d031c74:	e0bff717 	ldw	r2,-36(fp)
 d031c78:	10801a17 	ldw	r2,104(r2)
 d031c7c:	1880051e 	bne	r3,r2,d031c94 <tcp_output+0xa4c>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 d031c80:	e0bff717 	ldw	r2,-36(fp)
 d031c84:	10800f17 	ldw	r2,60(r2)
 d031c88:	10ffffc4 	addi	r3,r2,-1
 d031c8c:	e0bff717 	ldw	r2,-36(fp)
 d031c90:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 d031c94:	e0bff717 	ldw	r2,-36(fp)
 d031c98:	10800f17 	ldw	r2,60(r2)
 d031c9c:	1004d63a 	srli	r2,r2,24
 d031ca0:	10c03fcc 	andi	r3,r2,255
 d031ca4:	e0bff717 	ldw	r2,-36(fp)
 d031ca8:	10800f17 	ldw	r2,60(r2)
 d031cac:	1004d23a 	srli	r2,r2,8
 d031cb0:	10bfc00c 	andi	r2,r2,65280
 d031cb4:	1886b03a 	or	r3,r3,r2
 d031cb8:	e0bff717 	ldw	r2,-36(fp)
 d031cbc:	10800f17 	ldw	r2,60(r2)
 d031cc0:	10bfc00c 	andi	r2,r2,65280
 d031cc4:	1004923a 	slli	r2,r2,8
 d031cc8:	1886b03a 	or	r3,r3,r2
 d031ccc:	e0bff717 	ldw	r2,-36(fp)
 d031cd0:	10800f17 	ldw	r2,60(r2)
 d031cd4:	10803fcc 	andi	r2,r2,255
 d031cd8:	1004963a 	slli	r2,r2,24
 d031cdc:	1886b03a 	or	r3,r3,r2
 d031ce0:	e0bfee17 	ldw	r2,-72(fp)
 d031ce4:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 d031ce8:	e0bff717 	ldw	r2,-36(fp)
 d031cec:	10801617 	ldw	r2,88(r2)
 d031cf0:	1004d63a 	srli	r2,r2,24
 d031cf4:	10c03fcc 	andi	r3,r2,255
 d031cf8:	e0bff717 	ldw	r2,-36(fp)
 d031cfc:	10801617 	ldw	r2,88(r2)
 d031d00:	1004d23a 	srli	r2,r2,8
 d031d04:	10bfc00c 	andi	r2,r2,65280
 d031d08:	1886b03a 	or	r3,r3,r2
 d031d0c:	e0bff717 	ldw	r2,-36(fp)
 d031d10:	10801617 	ldw	r2,88(r2)
 d031d14:	10bfc00c 	andi	r2,r2,65280
 d031d18:	1004923a 	slli	r2,r2,8
 d031d1c:	1886b03a 	or	r3,r3,r2
 d031d20:	e0bff717 	ldw	r2,-36(fp)
 d031d24:	10801617 	ldw	r2,88(r2)
 d031d28:	10803fcc 	andi	r2,r2,255
 d031d2c:	1004963a 	slli	r2,r2,24
 d031d30:	1886b03a 	or	r3,r3,r2
 d031d34:	e0bfee17 	ldw	r2,-72(fp)
 d031d38:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 d031d3c:	e0bff117 	ldw	r2,-60(fp)
 d031d40:	1080008c 	andi	r2,r2,2
 d031d44:	1005003a 	cmpeq	r2,r2,zero
 d031d48:	1000221e 	bne	r2,zero,d031dd4 <tcp_output+0xb8c>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 d031d4c:	e0bff517 	ldw	r2,-44(fp)
 d031d50:	10800117 	ldw	r2,4(r2)
 d031d54:	e0bfe615 	stw	r2,-104(fp)

      switch(so->so_domain)
 d031d58:	e0bff517 	ldw	r2,-44(fp)
 d031d5c:	10800517 	ldw	r2,20(r2)
 d031d60:	108000a0 	cmpeqi	r2,r2,2
 d031d64:	1000011e 	bne	r2,zero,d031d6c <tcp_output+0xb24>
 d031d68:	00001906 	br	d031dd0 <tcp_output+0xb88>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 d031d6c:	e0bff117 	ldw	r2,-60(fp)
 d031d70:	1080040c 	andi	r2,r2,16
 d031d74:	1004c03a 	cmpne	r2,r2,zero
 d031d78:	1000161e 	bne	r2,zero,d031dd4 <tcp_output+0xb8c>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 d031d7c:	e0bfee17 	ldw	r2,-72(fp)
 d031d80:	11000417 	ldw	r4,16(r2)
 d031d84:	e17ff604 	addi	r5,fp,-40
 d031d88:	d0407680 	call	d040768 <iproute>
 d031d8c:	e0bfe515 	stw	r2,-108(fp)
               if(ifp)
 d031d90:	e0bfe517 	ldw	r2,-108(fp)
 d031d94:	1005003a 	cmpeq	r2,r2,zero
 d031d98:	1000091e 	bne	r2,zero,d031dc0 <tcp_output+0xb78>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 d031d9c:	e0bfe517 	ldw	r2,-108(fp)
 d031da0:	10c00917 	ldw	r3,36(r2)
 d031da4:	e0bfe517 	ldw	r2,-108(fp)
 d031da8:	10800817 	ldw	r2,32(r2)
 d031dac:	1885c83a 	sub	r2,r3,r2
 d031db0:	10fff604 	addi	r3,r2,-40
 d031db4:	e0bfe617 	ldw	r2,-104(fp)
 d031db8:	10c00615 	stw	r3,24(r2)
 d031dbc:	00000506 	br	d031dd4 <tcp_output+0xb8c>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 d031dc0:	e0ffe617 	ldw	r3,-104(fp)
 d031dc4:	00809104 	movi	r2,580
 d031dc8:	18800615 	stw	r2,24(r3)
            }
#endif   /* IP_PMTU */
         }
         break;
 d031dcc:	00000106 	br	d031dd4 <tcp_output+0xb8c>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 d031dd0:	d025a500 	call	d025a50 <dtrap>
      }
   }

   /* fill in options if any are set */
   if (optlen)
 d031dd4:	e0bfed17 	ldw	r2,-76(fp)
 d031dd8:	1005003a 	cmpeq	r2,r2,zero
 d031ddc:	10002f1e 	bne	r2,zero,d031e9c <tcp_output+0xc54>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 d031de0:	01000084 	movi	r4,2
 d031de4:	01404004 	movi	r5,256
 d031de8:	d0268740 	call	d026874 <m_getnbuf>
 d031dec:	e0bfe415 	stw	r2,-112(fp)
      if (mopt == NULL) 
 d031df0:	e0bfe417 	ldw	r2,-112(fp)
 d031df4:	1004c03a 	cmpne	r2,r2,zero
 d031df8:	1000051e 	bne	r2,zero,d031e10 <tcp_output+0xbc8>
      {
         m_freem(m);
 d031dfc:	e13fef17 	ldw	r4,-68(fp)
 d031e00:	d026b500 	call	d026b50 <m_freem>
         return (ENOBUFS);
 d031e04:	00c01a44 	movi	r3,105
 d031e08:	e0fff815 	stw	r3,-32(fp)
 d031e0c:	00016b06 	br	d0323bc <tcp_output+0x1174>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 d031e10:	e0bfe917 	ldw	r2,-92(fp)
 d031e14:	10c00617 	ldw	r3,24(r2)
 d031e18:	e0bfe417 	ldw	r2,-112(fp)
 d031e1c:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 d031e20:	e0ffe917 	ldw	r3,-92(fp)
 d031e24:	e0bfe417 	ldw	r2,-112(fp)
 d031e28:	18800615 	stw	r2,24(r3)

      /* extend options to aligned address */
      while(optlen & 0x03)
 d031e2c:	00000706 	br	d031e4c <tcp_output+0xc04>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 d031e30:	e0ffed17 	ldw	r3,-76(fp)
 d031e34:	d0a93104 	addi	r2,gp,-23356
 d031e38:	1885883a 	add	r2,r3,r2
 d031e3c:	10000005 	stb	zero,0(r2)
 d031e40:	e0bfed17 	ldw	r2,-76(fp)
 d031e44:	10800044 	addi	r2,r2,1
 d031e48:	e0bfed15 	stw	r2,-76(fp)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 d031e4c:	e0bfed17 	ldw	r2,-76(fp)
 d031e50:	108000cc 	andi	r2,r2,3
 d031e54:	1004c03a 	cmpne	r2,r2,zero
 d031e58:	103ff51e 	bne	r2,zero,d031e30 <tcp_output+0xbe8>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 d031e5c:	e0bfe417 	ldw	r2,-112(fp)
 d031e60:	10800317 	ldw	r2,12(r2)
 d031e64:	1009883a 	mov	r4,r2
 d031e68:	d1693104 	addi	r5,gp,-23356
 d031e6c:	e1bfed17 	ldw	r6,-76(fp)
 d031e70:	d0026080 	call	d002608 <memcpy>
      mopt->m_len = optlen;
 d031e74:	e0ffe417 	ldw	r3,-112(fp)
 d031e78:	e0bfed17 	ldw	r2,-76(fp)
 d031e7c:	18800215 	stw	r2,8(r3)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 d031e80:	e0bfed17 	ldw	r2,-76(fp)
 d031e84:	10800504 	addi	r2,r2,20
 d031e88:	1004d0ba 	srli	r2,r2,2
 d031e8c:	1004913a 	slli	r2,r2,4
 d031e90:	1007883a 	mov	r3,r2
 d031e94:	e0bfee17 	ldw	r2,-72(fp)
 d031e98:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 d031e9c:	e0bff117 	ldw	r2,-60(fp)
 d031ea0:	1007883a 	mov	r3,r2
 d031ea4:	e0bfee17 	ldw	r2,-72(fp)
 d031ea8:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 d031eac:	e0bff517 	ldw	r2,-44(fp)
 d031eb0:	10800b17 	ldw	r2,44(r2)
 d031eb4:	1004d0ba 	srli	r2,r2,2
 d031eb8:	1007883a 	mov	r3,r2
 d031ebc:	e0bff317 	ldw	r2,-52(fp)
 d031ec0:	10c0060e 	bge	r2,r3,d031edc <tcp_output+0xc94>
 d031ec4:	e0bff717 	ldw	r2,-36(fp)
 d031ec8:	10800a0b 	ldhu	r2,40(r2)
 d031ecc:	10ffffcc 	andi	r3,r2,65535
 d031ed0:	e0bff317 	ldw	r2,-52(fp)
 d031ed4:	10c0010e 	bge	r2,r3,d031edc <tcp_output+0xc94>
      win = 0;
 d031ed8:	e03ff315 	stw	zero,-52(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 d031edc:	e0bff717 	ldw	r2,-36(fp)
 d031ee0:	10c01917 	ldw	r3,100(r2)
 d031ee4:	e0bff717 	ldw	r2,-36(fp)
 d031ee8:	10801617 	ldw	r2,88(r2)
 d031eec:	1885c83a 	sub	r2,r3,r2
 d031ef0:	1007883a 	mov	r3,r2
 d031ef4:	e0bff317 	ldw	r2,-52(fp)
 d031ef8:	10c0060e 	bge	r2,r3,d031f14 <tcp_output+0xccc>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 d031efc:	e0bff717 	ldw	r2,-36(fp)
 d031f00:	10c01917 	ldw	r3,100(r2)
 d031f04:	e0bff717 	ldw	r2,-36(fp)
 d031f08:	10801617 	ldw	r2,88(r2)
 d031f0c:	1885c83a 	sub	r2,r3,r2
 d031f10:	e0bff315 	stw	r2,-52(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 d031f14:	008341b4 	movhi	r2,3334
 d031f18:	1083c104 	addi	r2,r2,3844
 d031f1c:	10800217 	ldw	r2,8(r2)
 d031f20:	1004c03a 	cmpne	r2,r2,zero
 d031f24:	1000021e 	bne	r2,zero,d031f30 <tcp_output+0xce8>
   {
      win = 0;
 d031f28:	e03ff315 	stw	zero,-52(fp)
 d031f2c:	00001606 	br	d031f88 <tcp_output+0xd40>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 d031f30:	008341b4 	movhi	r2,3334
 d031f34:	1083c104 	addi	r2,r2,3844
 d031f38:	10800217 	ldw	r2,8(r2)
 d031f3c:	113fffc4 	addi	r4,r2,-1
 d031f40:	00834174 	movhi	r2,3333
 d031f44:	10925704 	addi	r2,r2,18780
 d031f48:	10800017 	ldw	r2,0(r2)
 d031f4c:	100b883a 	mov	r5,r2
 d031f50:	d00235c0 	call	d00235c <__mulsi3>
 d031f54:	1007883a 	mov	r3,r2
 d031f58:	e0bff317 	ldw	r2,-52(fp)
 d031f5c:	18800a0e 	bge	r3,r2,d031f88 <tcp_output+0xd40>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 d031f60:	008341b4 	movhi	r2,3334
 d031f64:	1083c104 	addi	r2,r2,3844
 d031f68:	10800217 	ldw	r2,8(r2)
 d031f6c:	10bfffc4 	addi	r2,r2,-1
 d031f70:	1009883a 	mov	r4,r2
 d031f74:	00834174 	movhi	r2,3333
 d031f78:	10925704 	addi	r2,r2,18780
 d031f7c:	11400017 	ldw	r5,0(r2)
 d031f80:	d00235c0 	call	d00235c <__mulsi3>
 d031f84:	e0bff315 	stw	r2,-52(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 d031f88:	e0bff317 	ldw	r2,-52(fp)
 d031f8c:	10bfffcc 	andi	r2,r2,65535
 d031f90:	1004d23a 	srli	r2,r2,8
 d031f94:	10803fcc 	andi	r2,r2,255
 d031f98:	1009883a 	mov	r4,r2
 d031f9c:	e0bff317 	ldw	r2,-52(fp)
 d031fa0:	10bfffcc 	andi	r2,r2,65535
 d031fa4:	1004923a 	slli	r2,r2,8
 d031fa8:	1007883a 	mov	r3,r2
 d031fac:	00bfc004 	movi	r2,-256
 d031fb0:	1884703a 	and	r2,r3,r2
 d031fb4:	2084b03a 	or	r2,r4,r2
 d031fb8:	1007883a 	mov	r3,r2
 d031fbc:	e0bfee17 	ldw	r2,-72(fp)
 d031fc0:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 d031fc4:	e0bff717 	ldw	r2,-36(fp)
 d031fc8:	10c01017 	ldw	r3,64(r2)
 d031fcc:	e0bff717 	ldw	r2,-36(fp)
 d031fd0:	10800f17 	ldw	r2,60(r2)
 d031fd4:	1885c83a 	sub	r2,r3,r2
 d031fd8:	10800050 	cmplti	r2,r2,1
 d031fdc:	1000201e 	bne	r2,zero,d032060 <tcp_output+0xe18>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 d031fe0:	e0bff717 	ldw	r2,-36(fp)
 d031fe4:	10801017 	ldw	r2,64(r2)
 d031fe8:	1007883a 	mov	r3,r2
 d031fec:	e0bff717 	ldw	r2,-36(fp)
 d031ff0:	10800f17 	ldw	r2,60(r2)
 d031ff4:	1885c83a 	sub	r2,r3,r2
 d031ff8:	10bfffcc 	andi	r2,r2,65535
 d031ffc:	1004d23a 	srli	r2,r2,8
 d032000:	10803fcc 	andi	r2,r2,255
 d032004:	1009883a 	mov	r4,r2
 d032008:	e0bff717 	ldw	r2,-36(fp)
 d03200c:	10801017 	ldw	r2,64(r2)
 d032010:	1007883a 	mov	r3,r2
 d032014:	e0bff717 	ldw	r2,-36(fp)
 d032018:	10800f17 	ldw	r2,60(r2)
 d03201c:	1885c83a 	sub	r2,r3,r2
 d032020:	10bfffcc 	andi	r2,r2,65535
 d032024:	1004923a 	slli	r2,r2,8
 d032028:	1007883a 	mov	r3,r2
 d03202c:	00bfc004 	movi	r2,-256
 d032030:	1884703a 	and	r2,r3,r2
 d032034:	2084b03a 	or	r2,r4,r2
 d032038:	1007883a 	mov	r3,r2
 d03203c:	e0bfee17 	ldw	r2,-72(fp)
 d032040:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 d032044:	e0bfee17 	ldw	r2,-72(fp)
 d032048:	10800843 	ldbu	r2,33(r2)
 d03204c:	10800814 	ori	r2,r2,32
 d032050:	1007883a 	mov	r3,r2
 d032054:	e0bfee17 	ldw	r2,-72(fp)
 d032058:	10c00845 	stb	r3,33(r2)
 d03205c:	00000406 	br	d032070 <tcp_output+0xe28>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 d032060:	e0bff717 	ldw	r2,-36(fp)
 d032064:	10c00e17 	ldw	r3,56(r2)
 d032068:	e0bff717 	ldw	r2,-36(fp)
 d03206c:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 d032070:	e0bff417 	ldw	r2,-48(fp)
 d032074:	1005003a 	cmpeq	r2,r2,zero
 d032078:	10000c1e 	bne	r2,zero,d0320ac <tcp_output+0xe64>
 d03207c:	e0fff217 	ldw	r3,-56(fp)
 d032080:	e0bff417 	ldw	r2,-48(fp)
 d032084:	1887883a 	add	r3,r3,r2
 d032088:	e0bff517 	ldw	r2,-44(fp)
 d03208c:	10801217 	ldw	r2,72(r2)
 d032090:	1880061e 	bne	r3,r2,d0320ac <tcp_output+0xe64>
      ti->ti_flags |= TH_PUSH;
 d032094:	e0bfee17 	ldw	r2,-72(fp)
 d032098:	10800843 	ldbu	r2,33(r2)
 d03209c:	10800214 	ori	r2,r2,8
 d0320a0:	1007883a 	mov	r3,r2
 d0320a4:	e0bfee17 	ldw	r2,-72(fp)
 d0320a8:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 d0320ac:	e0bff717 	ldw	r2,-36(fp)
 d0320b0:	10800a83 	ldbu	r2,42(r2)
 d0320b4:	10803fcc 	andi	r2,r2,255
 d0320b8:	1080201c 	xori	r2,r2,128
 d0320bc:	10bfe004 	addi	r2,r2,-128
 d0320c0:	1005003a 	cmpeq	r2,r2,zero
 d0320c4:	1000041e 	bne	r2,zero,d0320d8 <tcp_output+0xe90>
 d0320c8:	e0bff717 	ldw	r2,-36(fp)
 d0320cc:	10800417 	ldw	r2,16(r2)
 d0320d0:	1004c03a 	cmpne	r2,r2,zero
 d0320d4:	1000561e 	bne	r2,zero,d032230 <tcp_output+0xfe8>
   {
      tcp_seq startseq = tp->snd_nxt;
 d0320d8:	e0bff717 	ldw	r2,-36(fp)
 d0320dc:	10800f17 	ldw	r2,60(r2)
 d0320e0:	e0bfe315 	stw	r2,-116(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 d0320e4:	e0bff117 	ldw	r2,-60(fp)
 d0320e8:	1080008c 	andi	r2,r2,2
 d0320ec:	1005003a 	cmpeq	r2,r2,zero
 d0320f0:	1000051e 	bne	r2,zero,d032108 <tcp_output+0xec0>
         tp->snd_nxt++;
 d0320f4:	e0bff717 	ldw	r2,-36(fp)
 d0320f8:	10800f17 	ldw	r2,60(r2)
 d0320fc:	10c00044 	addi	r3,r2,1
 d032100:	e0bff717 	ldw	r2,-36(fp)
 d032104:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 d032108:	e0bff117 	ldw	r2,-60(fp)
 d03210c:	1080004c 	andi	r2,r2,1
 d032110:	10803fcc 	andi	r2,r2,255
 d032114:	1005003a 	cmpeq	r2,r2,zero
 d032118:	10000b1e 	bne	r2,zero,d032148 <tcp_output+0xf00>
      {
         tp->snd_nxt++;
 d03211c:	e0bff717 	ldw	r2,-36(fp)
 d032120:	10800f17 	ldw	r2,60(r2)
 d032124:	10c00044 	addi	r3,r2,1
 d032128:	e0bff717 	ldw	r2,-36(fp)
 d03212c:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 d032130:	e0bff717 	ldw	r2,-36(fp)
 d032134:	10800b0b 	ldhu	r2,44(r2)
 d032138:	10800414 	ori	r2,r2,16
 d03213c:	1007883a 	mov	r3,r2
 d032140:	e0bff717 	ldw	r2,-36(fp)
 d032144:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 d032148:	e0bff717 	ldw	r2,-36(fp)
 d03214c:	10c00f17 	ldw	r3,60(r2)
 d032150:	e0bff417 	ldw	r2,-48(fp)
 d032154:	1887883a 	add	r3,r3,r2
 d032158:	e0bff717 	ldw	r2,-36(fp)
 d03215c:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 d032160:	e0bff717 	ldw	r2,-36(fp)
 d032164:	10c00f17 	ldw	r3,60(r2)
 d032168:	e0bff717 	ldw	r2,-36(fp)
 d03216c:	10801a17 	ldw	r2,104(r2)
 d032170:	1885c83a 	sub	r2,r3,r2
 d032174:	10800050 	cmplti	r2,r2,1
 d032178:	1000171e 	bne	r2,zero,d0321d8 <tcp_output+0xf90>
      {
         tp->snd_max = tp->snd_nxt;
 d03217c:	e0bff717 	ldw	r2,-36(fp)
 d032180:	10c00f17 	ldw	r3,60(r2)
 d032184:	e0bff717 	ldw	r2,-36(fp)
 d032188:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 d03218c:	e0bff717 	ldw	r2,-36(fp)
 d032190:	10801e17 	ldw	r2,120(r2)
 d032194:	1004c03a 	cmpne	r2,r2,zero
 d032198:	10000f1e 	bne	r2,zero,d0321d8 <tcp_output+0xf90>
         {
            tp->t_rttick = cticks;
 d03219c:	00834174 	movhi	r2,3333
 d0321a0:	109b4504 	addi	r2,r2,27924
 d0321a4:	10c00017 	ldw	r3,0(r2)
 d0321a8:	e0bff717 	ldw	r2,-36(fp)
 d0321ac:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 d0321b0:	e0fff717 	ldw	r3,-36(fp)
 d0321b4:	e0bfe317 	ldw	r2,-116(fp)
 d0321b8:	18801f15 	stw	r2,124(r3)
            tcpstat.tcps_segstimed++;
 d0321bc:	008341b4 	movhi	r2,3334
 d0321c0:	10848a04 	addi	r2,r2,4648
 d0321c4:	10800617 	ldw	r2,24(r2)
 d0321c8:	10c00044 	addi	r3,r2,1
 d0321cc:	008341b4 	movhi	r2,3334
 d0321d0:	10848a04 	addi	r2,r2,4648
 d0321d4:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 d0321d8:	e0bff717 	ldw	r2,-36(fp)
 d0321dc:	10800317 	ldw	r2,12(r2)
 d0321e0:	1004c03a 	cmpne	r2,r2,zero
 d0321e4:	1000211e 	bne	r2,zero,d03226c <tcp_output+0x1024>
 d0321e8:	e0bff717 	ldw	r2,-36(fp)
 d0321ec:	10c00f17 	ldw	r3,60(r2)
 d0321f0:	e0bff717 	ldw	r2,-36(fp)
 d0321f4:	10800e17 	ldw	r2,56(r2)
 d0321f8:	18801c26 	beq	r3,r2,d03226c <tcp_output+0x1024>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d0321fc:	e0bff717 	ldw	r2,-36(fp)
 d032200:	10c00817 	ldw	r3,32(r2)
 d032204:	e0bff717 	ldw	r2,-36(fp)
 d032208:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 d03220c:	e0bff717 	ldw	r2,-36(fp)
 d032210:	10800417 	ldw	r2,16(r2)
 d032214:	1005003a 	cmpeq	r2,r2,zero
 d032218:	1000141e 	bne	r2,zero,d03226c <tcp_output+0x1024>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 d03221c:	e0bff717 	ldw	r2,-36(fp)
 d032220:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 d032224:	e0bff717 	ldw	r2,-36(fp)
 d032228:	10000715 	stw	zero,28(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 d03222c:	00000f06 	br	d03226c <tcp_output+0x1024>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 d032230:	e0bff717 	ldw	r2,-36(fp)
 d032234:	10c00f17 	ldw	r3,60(r2)
 d032238:	e0bff417 	ldw	r2,-48(fp)
 d03223c:	1887883a 	add	r3,r3,r2
 d032240:	e0bff717 	ldw	r2,-36(fp)
 d032244:	10801a17 	ldw	r2,104(r2)
 d032248:	1885c83a 	sub	r2,r3,r2
 d03224c:	10800050 	cmplti	r2,r2,1
 d032250:	1000061e 	bne	r2,zero,d03226c <tcp_output+0x1024>
         tp->snd_max = tp->snd_nxt + len;
 d032254:	e0bff717 	ldw	r2,-36(fp)
 d032258:	10c00f17 	ldw	r3,60(r2)
 d03225c:	e0bff417 	ldw	r2,-48(fp)
 d032260:	1887883a 	add	r3,r3,r2
 d032264:	e0bff717 	ldw	r2,-36(fp)
 d032268:	10c01a15 	stw	r3,104(r2)
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 d03226c:	e03ff015 	stw	zero,-64(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 d032270:	e0bfef17 	ldw	r2,-68(fp)
 d032274:	10800317 	ldw	r2,12(r2)
 d032278:	e0bfe215 	stw	r2,-120(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 d03227c:	e0bfed17 	ldw	r2,-76(fp)
 d032280:	1007883a 	mov	r3,r2
 d032284:	e0bff417 	ldw	r2,-48(fp)
 d032288:	1885883a 	add	r2,r3,r2
 d03228c:	10800a04 	addi	r2,r2,40
 d032290:	1007883a 	mov	r3,r2
 d032294:	e0bfe217 	ldw	r2,-120(fp)
 d032298:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 d03229c:	e0bff517 	ldw	r2,-44(fp)
 d0322a0:	11401f17 	ldw	r5,124(r2)
 d0322a4:	e13fef17 	ldw	r4,-68(fp)
 d0322a8:	d0275840 	call	d027584 <ip_output>
 d0322ac:	e0bff015 	stw	r2,-64(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 d0322b0:	e0bff017 	ldw	r2,-64(fp)
 d0322b4:	1005003a 	cmpeq	r2,r2,zero
 d0322b8:	1000151e 	bne	r2,zero,d032310 <tcp_output+0x10c8>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 d0322bc:	e0bff017 	ldw	r2,-64(fp)
 d0322c0:	10801a58 	cmpnei	r2,r2,105
 d0322c4:	10000f1e 	bne	r2,zero,d032304 <tcp_output+0x10bc>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 d0322c8:	e0bfef17 	ldw	r2,-68(fp)
 d0322cc:	10800817 	ldw	r2,32(r2)
 d0322d0:	1004c03a 	cmpne	r2,r2,zero
 d0322d4:	1000031e 	bne	r2,zero,d0322e4 <tcp_output+0x109c>
            m = m->m_next;
 d0322d8:	e0bfef17 	ldw	r2,-68(fp)
 d0322dc:	10800617 	ldw	r2,24(r2)
 d0322e0:	e0bfef15 	stw	r2,-68(fp)
         m_freem(m); /* free the mbuf chain */
 d0322e4:	e13fef17 	ldw	r4,-68(fp)
 d0322e8:	d026b500 	call	d026b50 <m_freem>
         tcp_quench(tp->t_inpcb);
 d0322ec:	e0bff717 	ldw	r2,-36(fp)
 d0322f0:	11000d17 	ldw	r4,52(r2)
 d0322f4:	d032e5c0 	call	d032e5c <tcp_quench>
         return (error);
 d0322f8:	e0bff017 	ldw	r2,-64(fp)
 d0322fc:	e0bff815 	stw	r2,-32(fp)
 d032300:	00002e06 	br	d0323bc <tcp_output+0x1174>
      }
      return (error);
 d032304:	e0fff017 	ldw	r3,-64(fp)
 d032308:	e0fff815 	stw	r3,-32(fp)
 d03230c:	00002b06 	br	d0323bc <tcp_output+0x1174>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 d032310:	008341b4 	movhi	r2,3334
 d032314:	10845c04 	addi	r2,r2,4464
 d032318:	10800a17 	ldw	r2,40(r2)
 d03231c:	10c00044 	addi	r3,r2,1
 d032320:	008341b4 	movhi	r2,3334
 d032324:	10845c04 	addi	r2,r2,4464
 d032328:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 d03232c:	008341b4 	movhi	r2,3334
 d032330:	10848a04 	addi	r2,r2,4648
 d032334:	10800f17 	ldw	r2,60(r2)
 d032338:	10c00044 	addi	r3,r2,1
 d03233c:	008341b4 	movhi	r2,3334
 d032340:	10848a04 	addi	r2,r2,4648
 d032344:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 d032348:	e0bff317 	ldw	r2,-52(fp)
 d03234c:	10800050 	cmplti	r2,r2,1
 d032350:	10000f1e 	bne	r2,zero,d032390 <tcp_output+0x1148>
 d032354:	e0bff717 	ldw	r2,-36(fp)
 d032358:	10c01617 	ldw	r3,88(r2)
 d03235c:	e0bff317 	ldw	r2,-52(fp)
 d032360:	1887883a 	add	r3,r3,r2
 d032364:	e0bff717 	ldw	r2,-36(fp)
 d032368:	10801917 	ldw	r2,100(r2)
 d03236c:	1885c83a 	sub	r2,r3,r2
 d032370:	10800050 	cmplti	r2,r2,1
 d032374:	1000061e 	bne	r2,zero,d032390 <tcp_output+0x1148>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 d032378:	e0bff717 	ldw	r2,-36(fp)
 d03237c:	10c01617 	ldw	r3,88(r2)
 d032380:	e0bff317 	ldw	r2,-52(fp)
 d032384:	1887883a 	add	r3,r3,r2
 d032388:	e0bff717 	ldw	r2,-36(fp)
 d03238c:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 d032390:	e0bff717 	ldw	r2,-36(fp)
 d032394:	10c00b0b 	ldhu	r3,44(r2)
 d032398:	00bfef04 	movi	r2,-68
 d03239c:	1884703a 	and	r2,r3,r2
 d0323a0:	1007883a 	mov	r3,r2
 d0323a4:	e0bff717 	ldw	r2,-36(fp)
 d0323a8:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 d0323ac:	e0bfeb17 	ldw	r2,-84(fp)
 d0323b0:	1004c03a 	cmpne	r2,r2,zero
 d0323b4:	103bb41e 	bne	r2,zero,d031288 <tcp_output+0x40>
      goto again;
   return (0);
 d0323b8:	e03ff815 	stw	zero,-32(fp)
 d0323bc:	e0bff817 	ldw	r2,-32(fp)
}
 d0323c0:	e037883a 	mov	sp,fp
 d0323c4:	dfc00117 	ldw	ra,4(sp)
 d0323c8:	df000017 	ldw	fp,0(sp)
 d0323cc:	dec00204 	addi	sp,sp,8
 d0323d0:	f800283a 	ret

0d0323d4 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 d0323d4:	defffc04 	addi	sp,sp,-16
 d0323d8:	dfc00315 	stw	ra,12(sp)
 d0323dc:	df000215 	stw	fp,8(sp)
 d0323e0:	df000204 	addi	fp,sp,8
 d0323e4:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 d0323e8:	e0bfff17 	ldw	r2,-4(fp)
 d0323ec:	10802017 	ldw	r2,128(r2)
 d0323f0:	1007d0ba 	srai	r3,r2,2
 d0323f4:	e0bfff17 	ldw	r2,-4(fp)
 d0323f8:	10802117 	ldw	r2,132(r2)
 d0323fc:	1885883a 	add	r2,r3,r2
 d032400:	1005d07a 	srai	r2,r2,1
 d032404:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 d032408:	e0bfff17 	ldw	r2,-4(fp)
 d03240c:	10800317 	ldw	r2,12(r2)
 d032410:	1005003a 	cmpeq	r2,r2,zero
 d032414:	1000031e 	bne	r2,zero,d032424 <tcp_setpersist+0x50>
      panic("tcp_output REXMT");
 d032418:	01034174 	movhi	r4,3333
 d03241c:	213eb904 	addi	r4,r4,-1308
 d032420:	d02093c0 	call	d02093c <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 d032424:	e0bfff17 	ldw	r2,-4(fp)
 d032428:	10c00717 	ldw	r3,28(r2)
 d03242c:	00834174 	movhi	r2,3333
 d032430:	10914dc4 	addi	r2,r2,17719
 d032434:	10c5883a 	add	r2,r2,r3
 d032438:	10800003 	ldbu	r2,0(r2)
 d03243c:	11003fcc 	andi	r4,r2,255
 d032440:	e17ffe17 	ldw	r5,-8(fp)
 d032444:	d00235c0 	call	d00235c <__mulsi3>
 d032448:	10ffffcc 	andi	r3,r2,65535
 d03244c:	18e0001c 	xori	r3,r3,32768
 d032450:	18e00004 	addi	r3,r3,-32768
 d032454:	e0bfff17 	ldw	r2,-4(fp)
 d032458:	10c00415 	stw	r3,16(r2)
 d03245c:	e0bfff17 	ldw	r2,-4(fp)
 d032460:	10800417 	ldw	r2,16(r2)
 d032464:	10800288 	cmpgei	r2,r2,10
 d032468:	1000041e 	bne	r2,zero,d03247c <tcp_setpersist+0xa8>
 d03246c:	e0ffff17 	ldw	r3,-4(fp)
 d032470:	00800284 	movi	r2,10
 d032474:	18800415 	stw	r2,16(r3)
 d032478:	00000706 	br	d032498 <tcp_setpersist+0xc4>
 d03247c:	e0bfff17 	ldw	r2,-4(fp)
 d032480:	10800417 	ldw	r2,16(r2)
 d032484:	10801e50 	cmplti	r2,r2,121
 d032488:	1000031e 	bne	r2,zero,d032498 <tcp_setpersist+0xc4>
 d03248c:	e0ffff17 	ldw	r3,-4(fp)
 d032490:	00801e04 	movi	r2,120
 d032494:	18800415 	stw	r2,16(r3)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 d032498:	e0bfff17 	ldw	r2,-4(fp)
 d03249c:	10800717 	ldw	r2,28(r2)
 d0324a0:	10800308 	cmpgei	r2,r2,12
 d0324a4:	1000051e 	bne	r2,zero,d0324bc <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 d0324a8:	e0bfff17 	ldw	r2,-4(fp)
 d0324ac:	10800717 	ldw	r2,28(r2)
 d0324b0:	10c00044 	addi	r3,r2,1
 d0324b4:	e0bfff17 	ldw	r2,-4(fp)
 d0324b8:	10c00715 	stw	r3,28(r2)

}
 d0324bc:	e037883a 	mov	sp,fp
 d0324c0:	dfc00117 	ldw	ra,4(sp)
 d0324c4:	df000017 	ldw	fp,0(sp)
 d0324c8:	dec00204 	addi	sp,sp,8
 d0324cc:	f800283a 	ret

0d0324d0 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 d0324d0:	defff704 	addi	sp,sp,-36
 d0324d4:	dfc00815 	stw	ra,32(sp)
 d0324d8:	df000715 	stw	fp,28(sp)
 d0324dc:	df000704 	addi	fp,sp,28
 d0324e0:	e13ffb15 	stw	r4,-20(fp)
 d0324e4:	e17ffc15 	stw	r5,-16(fp)
 d0324e8:	e1bffd15 	stw	r6,-12(fp)
 d0324ec:	e1fffe15 	stw	r7,-8(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 d0324f0:	e0bffb17 	ldw	r2,-20(fp)
 d0324f4:	10800b0b 	ldhu	r2,44(r2)
 d0324f8:	10bfffcc 	andi	r2,r2,65535
 d0324fc:	1080020c 	andi	r2,r2,8
 d032500:	1005003a 	cmpeq	r2,r2,zero
 d032504:	1000021e 	bne	r2,zero,d032510 <bld_options+0x40>
      return 0;
 d032508:	e03fff15 	stw	zero,-4(fp)
 d03250c:	00002406 	br	d0325a0 <bld_options+0xd0>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 d032510:	e0bffd17 	ldw	r2,-12(fp)
 d032514:	1080008c 	andi	r2,r2,2
 d032518:	1005003a 	cmpeq	r2,r2,zero
 d03251c:	10001d1e 	bne	r2,zero,d032594 <bld_options+0xc4>
   {
      mss   =  (u_short)tcp_mss(so);
 d032520:	e13ffe17 	ldw	r4,-8(fp)
 d032524:	d03112c0 	call	d03112c <tcp_mss>
 d032528:	e0bff90d 	sth	r2,-28(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 d03252c:	e0fffc17 	ldw	r3,-16(fp)
 d032530:	00800084 	movi	r2,2
 d032534:	18800005 	stb	r2,0(r3)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 d032538:	e0bffc17 	ldw	r2,-16(fp)
 d03253c:	10c00044 	addi	r3,r2,1
 d032540:	00800104 	movi	r2,4
 d032544:	18800005 	stb	r2,0(r3)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 d032548:	e0bffc17 	ldw	r2,-16(fp)
 d03254c:	10c00084 	addi	r3,r2,2
 d032550:	e0bff90b 	ldhu	r2,-28(fp)
 d032554:	10bfc00c 	andi	r2,r2,65280
 d032558:	1005d23a 	srai	r2,r2,8
 d03255c:	18800005 	stb	r2,0(r3)
      *(cp + 3)  = (u_char) (mss & 0xff);
 d032560:	e0bffc17 	ldw	r2,-16(fp)
 d032564:	110000c4 	addi	r4,r2,3
 d032568:	e0bff90b 	ldhu	r2,-28(fp)
 d03256c:	1007883a 	mov	r3,r2
 d032570:	00bfffc4 	movi	r2,-1
 d032574:	1884703a 	and	r2,r3,r2
 d032578:	20800005 	stb	r2,0(r4)
      len = 4;
 d03257c:	00800104 	movi	r2,4
 d032580:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 d032584:	e0bffc17 	ldw	r2,-16(fp)
 d032588:	10800104 	addi	r2,r2,4
 d03258c:	e0bffc15 	stw	r2,-16(fp)
 d032590:	00000106 	br	d032598 <bld_options+0xc8>
   }
   else
      len = 0;
 d032594:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 d032598:	e0bffa17 	ldw	r2,-24(fp)
 d03259c:	e0bfff15 	stw	r2,-4(fp)
 d0325a0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0325a4:	e037883a 	mov	sp,fp
 d0325a8:	dfc00117 	ldw	ra,4(sp)
 d0325ac:	df000017 	ldw	fp,0(sp)
 d0325b0:	dec00204 	addi	sp,sp,8
 d0325b4:	f800283a 	ret

0d0325b8 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 d0325b8:	deffff04 	addi	sp,sp,-4
 d0325bc:	df000015 	stw	fp,0(sp)
 d0325c0:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 d0325c4:	00c34174 	movhi	r3,3333
 d0325c8:	18db5204 	addi	r3,r3,27976
 d0325cc:	00800044 	movi	r2,1
 d0325d0:	18800015 	stw	r2,0(r3)
   tcb.inp_next = tcb.inp_prev = &tcb;
 d0325d4:	00c341b4 	movhi	r3,3334
 d0325d8:	18c47f04 	addi	r3,r3,4604
 d0325dc:	008341b4 	movhi	r2,3334
 d0325e0:	10847f04 	addi	r2,r2,4604
 d0325e4:	18800115 	stw	r2,4(r3)
 d0325e8:	008341b4 	movhi	r2,3334
 d0325ec:	10847f04 	addi	r2,r2,4604
 d0325f0:	10c00117 	ldw	r3,4(r2)
 d0325f4:	008341b4 	movhi	r2,3334
 d0325f8:	10847f04 	addi	r2,r2,4604
 d0325fc:	10c00015 	stw	r3,0(r2)
}
 d032600:	e037883a 	mov	sp,fp
 d032604:	df000017 	ldw	fp,0(sp)
 d032608:	dec00104 	addi	sp,sp,4
 d03260c:	f800283a 	ret

0d032610 <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 d032610:	defffa04 	addi	sp,sp,-24
 d032614:	dfc00515 	stw	ra,20(sp)
 d032618:	df000415 	stw	fp,16(sp)
 d03261c:	df000404 	addi	fp,sp,16
 d032620:	e13ffe15 	stw	r4,-8(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 d032624:	e0bffe17 	ldw	r2,-8(fp)
 d032628:	10800d17 	ldw	r2,52(r2)
 d03262c:	e0bffd15 	stw	r2,-12(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 d032630:	e0bffe17 	ldw	r2,-8(fp)
 d032634:	10800c17 	ldw	r2,48(r2)
 d032638:	e0bffc15 	stw	r2,-16(fp)
 d03263c:	e0bffc17 	ldw	r2,-16(fp)
 d032640:	1004c03a 	cmpne	r2,r2,zero
 d032644:	1000081e 	bne	r2,zero,d032668 <tcp_template+0x58>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 d032648:	01000a04 	movi	r4,40
 d03264c:	d0264b80 	call	d0264b8 <npalloc>
 d032650:	e0bffc15 	stw	r2,-16(fp)
      if (n == NULL)
 d032654:	e0bffc17 	ldw	r2,-16(fp)
 d032658:	1004c03a 	cmpne	r2,r2,zero
 d03265c:	1000021e 	bne	r2,zero,d032668 <tcp_template+0x58>
         return (0);
 d032660:	e03fff15 	stw	zero,-4(fp)
 d032664:	00002a06 	br	d032710 <tcp_template+0x100>
   }
   n->ti_next = n->ti_prev = 0;
 d032668:	e0bffc17 	ldw	r2,-16(fp)
 d03266c:	10000115 	stw	zero,4(r2)
 d032670:	e0bffc17 	ldw	r2,-16(fp)
 d032674:	10c00117 	ldw	r3,4(r2)
 d032678:	e0bffc17 	ldw	r2,-16(fp)
 d03267c:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 d032680:	e0fffc17 	ldw	r3,-16(fp)
 d032684:	00850004 	movi	r2,5120
 d032688:	1880028d 	sth	r2,10(r3)
   n->ti_src = inp->inp_laddr;
 d03268c:	e0bffd17 	ldw	r2,-12(fp)
 d032690:	10c00417 	ldw	r3,16(r2)
 d032694:	e0bffc17 	ldw	r2,-16(fp)
 d032698:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 d03269c:	e0bffd17 	ldw	r2,-12(fp)
 d0326a0:	10c00317 	ldw	r3,12(r2)
 d0326a4:	e0bffc17 	ldw	r2,-16(fp)
 d0326a8:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 d0326ac:	e0bffd17 	ldw	r2,-12(fp)
 d0326b0:	10c0078b 	ldhu	r3,30(r2)
 d0326b4:	e0bffc17 	ldw	r2,-16(fp)
 d0326b8:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 d0326bc:	e0bffd17 	ldw	r2,-12(fp)
 d0326c0:	10c0070b 	ldhu	r3,28(r2)
 d0326c4:	e0bffc17 	ldw	r2,-16(fp)
 d0326c8:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 d0326cc:	e0bffc17 	ldw	r2,-16(fp)
 d0326d0:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 d0326d4:	e0bffc17 	ldw	r2,-16(fp)
 d0326d8:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 d0326dc:	e0fffc17 	ldw	r3,-16(fp)
 d0326e0:	00801404 	movi	r2,80
 d0326e4:	18800805 	stb	r2,32(r3)
   n->ti_flags = 0;
 d0326e8:	e0bffc17 	ldw	r2,-16(fp)
 d0326ec:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 d0326f0:	e0bffc17 	ldw	r2,-16(fp)
 d0326f4:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 d0326f8:	e0bffc17 	ldw	r2,-16(fp)
 d0326fc:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 d032700:	e0bffc17 	ldw	r2,-16(fp)
 d032704:	1000098d 	sth	zero,38(r2)
   return (n);
 d032708:	e0bffc17 	ldw	r2,-16(fp)
 d03270c:	e0bfff15 	stw	r2,-4(fp)
 d032710:	e0bfff17 	ldw	r2,-4(fp)
}
 d032714:	e037883a 	mov	sp,fp
 d032718:	dfc00117 	ldw	ra,4(sp)
 d03271c:	df000017 	ldw	fp,0(sp)
 d032720:	dec00204 	addi	sp,sp,8
 d032724:	f800283a 	ret

0d032728 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 d032728:	defff104 	addi	sp,sp,-60
 d03272c:	dfc00e15 	stw	ra,56(sp)
 d032730:	df000d15 	stw	fp,52(sp)
 d032734:	df000d04 	addi	fp,sp,52
 d032738:	e13ffb15 	stw	r4,-20(fp)
 d03273c:	e17ffc15 	stw	r5,-16(fp)
 d032740:	e1bffd15 	stw	r6,-12(fp)
 d032744:	e1fffe15 	stw	r7,-8(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 d032748:	e03ff815 	stw	zero,-32(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 d03274c:	e0bffb17 	ldw	r2,-20(fp)
 d032750:	1005003a 	cmpeq	r2,r2,zero
 d032754:	10001a1e 	bne	r2,zero,d0327c0 <tcp_respond+0x98>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 d032758:	e0bffb17 	ldw	r2,-20(fp)
 d03275c:	10800d17 	ldw	r2,52(r2)
 d032760:	10800817 	ldw	r2,32(r2)
 d032764:	10800b17 	ldw	r2,44(r2)
 d032768:	1007883a 	mov	r3,r2
 d03276c:	e0bffb17 	ldw	r2,-20(fp)
 d032770:	10800d17 	ldw	r2,52(r2)
 d032774:	10800817 	ldw	r2,32(r2)
 d032778:	10800a17 	ldw	r2,40(r2)
 d03277c:	1885c83a 	sub	r2,r3,r2
 d032780:	1004803a 	cmplt	r2,r2,zero
 d032784:	10000b1e 	bne	r2,zero,d0327b4 <tcp_respond+0x8c>
 d032788:	e0bffb17 	ldw	r2,-20(fp)
 d03278c:	10800d17 	ldw	r2,52(r2)
 d032790:	10800817 	ldw	r2,32(r2)
 d032794:	10c00b17 	ldw	r3,44(r2)
 d032798:	e0bffb17 	ldw	r2,-20(fp)
 d03279c:	10800d17 	ldw	r2,52(r2)
 d0327a0:	10800817 	ldw	r2,32(r2)
 d0327a4:	10800a17 	ldw	r2,40(r2)
 d0327a8:	1885c83a 	sub	r2,r3,r2
 d0327ac:	e0bfff15 	stw	r2,-4(fp)
 d0327b0:	00000106 	br	d0327b8 <tcp_respond+0x90>
 d0327b4:	e03fff15 	stw	zero,-4(fp)
 d0327b8:	e0bfff17 	ldw	r2,-4(fp)
 d0327bc:	e0bff815 	stw	r2,-32(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 d0327c0:	e0800217 	ldw	r2,8(fp)
 d0327c4:	1004c03a 	cmpne	r2,r2,zero
 d0327c8:	1000391e 	bne	r2,zero,d0328b0 <tcp_respond+0x188>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 d0327cc:	010000c4 	movi	r4,3
 d0327d0:	01401004 	movi	r5,64
 d0327d4:	d0268740 	call	d026874 <m_getnbuf>
 d0327d8:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 d0327dc:	e0bff717 	ldw	r2,-36(fp)
 d0327e0:	1005003a 	cmpeq	r2,r2,zero
 d0327e4:	1000ed1e 	bne	r2,zero,d032b9c <tcp_respond+0x474>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 d0327e8:	00800044 	movi	r2,1
 d0327ec:	e0bffa15 	stw	r2,-24(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 d0327f0:	e0bffa17 	ldw	r2,-24(fp)
 d0327f4:	10800a04 	addi	r2,r2,40
 d0327f8:	1007883a 	mov	r3,r2
 d0327fc:	e0bff717 	ldw	r2,-36(fp)
 d032800:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 d032804:	e0bff717 	ldw	r2,-36(fp)
 d032808:	10800317 	ldw	r2,12(r2)
 d03280c:	e0bff615 	stw	r2,-40(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 d032810:	e0bff717 	ldw	r2,-36(fp)
 d032814:	10800117 	ldw	r2,4(r2)
 d032818:	10c00117 	ldw	r3,4(r2)
 d03281c:	e0bff617 	ldw	r2,-40(fp)
 d032820:	10c0032e 	bgeu	r2,r3,d032830 <tcp_respond+0x108>
      {
         panic("tcp_respond- packet ptr underflow\n");
 d032824:	01034174 	movhi	r4,3333
 d032828:	213ebe04 	addi	r4,r4,-1288
 d03282c:	d02093c0 	call	d02093c <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 d032830:	e13ff617 	ldw	r4,-40(fp)
 d032834:	e0fffc17 	ldw	r3,-16(fp)
 d032838:	18800017 	ldw	r2,0(r3)
 d03283c:	20800015 	stw	r2,0(r4)
 d032840:	18800117 	ldw	r2,4(r3)
 d032844:	20800115 	stw	r2,4(r4)
 d032848:	18800217 	ldw	r2,8(r3)
 d03284c:	20800215 	stw	r2,8(r4)
 d032850:	18800317 	ldw	r2,12(r3)
 d032854:	20800315 	stw	r2,12(r4)
 d032858:	18800417 	ldw	r2,16(r3)
 d03285c:	20800415 	stw	r2,16(r4)
 d032860:	18800517 	ldw	r2,20(r3)
 d032864:	20800515 	stw	r2,20(r4)
 d032868:	18800617 	ldw	r2,24(r3)
 d03286c:	20800615 	stw	r2,24(r4)
 d032870:	18800717 	ldw	r2,28(r3)
 d032874:	20800715 	stw	r2,28(r4)
 d032878:	18800817 	ldw	r2,32(r3)
 d03287c:	20800815 	stw	r2,32(r4)
 d032880:	18800917 	ldw	r2,36(r3)
 d032884:	20800915 	stw	r2,36(r4)
      ti = tmp_thdr;
 d032888:	e0bff617 	ldw	r2,-40(fp)
 d03288c:	e0bffc15 	stw	r2,-16(fp)
      flags = TH_ACK;
 d032890:	00800404 	movi	r2,16
 d032894:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 d032898:	e0bffb17 	ldw	r2,-20(fp)
 d03289c:	10800d17 	ldw	r2,52(r2)
 d0328a0:	10800817 	ldw	r2,32(r2)
 d0328a4:	10800517 	ldw	r2,20(r2)
 d0328a8:	e0bff915 	stw	r2,-28(fp)
 d0328ac:	00003b06 	br	d03299c <tcp_respond+0x274>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 d0328b0:	e0800317 	ldw	r2,12(fp)
 d0328b4:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 d0328b8:	e0bff717 	ldw	r2,-36(fp)
 d0328bc:	10800117 	ldw	r2,4(r2)
 d0328c0:	1080080b 	ldhu	r2,32(r2)
 d0328c4:	10bfffcc 	andi	r2,r2,65535
 d0328c8:	10800218 	cmpnei	r2,r2,8
 d0328cc:	1000031e 	bne	r2,zero,d0328dc <tcp_respond+0x1b4>
         domain = AF_INET;
 d0328d0:	00800084 	movi	r2,2
 d0328d4:	e0bff915 	stw	r2,-28(fp)
 d0328d8:	00000206 	br	d0328e4 <tcp_respond+0x1bc>
      else
         domain = AF_INET6;
 d0328dc:	008000c4 	movi	r2,3
 d0328e0:	e0bff915 	stw	r2,-28(fp)

      m_freem(m->m_next);
 d0328e4:	e0bff717 	ldw	r2,-36(fp)
 d0328e8:	11000617 	ldw	r4,24(r2)
 d0328ec:	d026b500 	call	d026b50 <m_freem>
      m->m_next = 0;
 d0328f0:	e0bff717 	ldw	r2,-36(fp)
 d0328f4:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 d0328f8:	e03ffa15 	stw	zero,-24(fp)
      m->m_len = TCPIPHDRSZ;
 d0328fc:	e0fff717 	ldw	r3,-36(fp)
 d032900:	00800a04 	movi	r2,40
 d032904:	18800215 	stw	r2,8(r3)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 d032908:	e0bffc17 	ldw	r2,-16(fp)
 d03290c:	1080058b 	ldhu	r2,22(r2)
 d032910:	e0bff50d 	sth	r2,-44(fp)
 d032914:	e0bffc17 	ldw	r2,-16(fp)
 d032918:	10c0050b 	ldhu	r3,20(r2)
 d03291c:	e0bffc17 	ldw	r2,-16(fp)
 d032920:	10c0058d 	sth	r3,22(r2)
 d032924:	e0fffc17 	ldw	r3,-16(fp)
 d032928:	e0bff50b 	ldhu	r2,-44(fp)
 d03292c:	1880050d 	sth	r2,20(r3)
      if(m->pkt->type == IPTP)
 d032930:	e0bff717 	ldw	r2,-36(fp)
 d032934:	10800117 	ldw	r2,4(r2)
 d032938:	1080080b 	ldhu	r2,32(r2)
 d03293c:	10bfffcc 	andi	r2,r2,65535
 d032940:	10800218 	cmpnei	r2,r2,8
 d032944:	10000a1e 	bne	r2,zero,d032970 <tcp_respond+0x248>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 d032948:	e0bffc17 	ldw	r2,-16(fp)
 d03294c:	10800417 	ldw	r2,16(r2)
 d032950:	e0bff415 	stw	r2,-48(fp)
 d032954:	e0bffc17 	ldw	r2,-16(fp)
 d032958:	10c00317 	ldw	r3,12(r2)
 d03295c:	e0bffc17 	ldw	r2,-16(fp)
 d032960:	10c00415 	stw	r3,16(r2)
 d032964:	e0fffc17 	ldw	r3,-16(fp)
 d032968:	e0bff417 	ldw	r2,-48(fp)
 d03296c:	18800315 	stw	r2,12(r3)
      if (flags & TH_RST)  /* count resets in MIB */
 d032970:	e0800217 	ldw	r2,8(fp)
 d032974:	1080010c 	andi	r2,r2,4
 d032978:	1005003a 	cmpeq	r2,r2,zero
 d03297c:	1000071e 	bne	r2,zero,d03299c <tcp_respond+0x274>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 d032980:	008341b4 	movhi	r2,3334
 d032984:	10845c04 	addi	r2,r2,4464
 d032988:	10800e17 	ldw	r2,56(r2)
 d03298c:	10c00044 	addi	r3,r2,1
 d032990:	008341b4 	movhi	r2,3334
 d032994:	10845c04 	addi	r2,r2,4464
 d032998:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 d03299c:	e0bffe17 	ldw	r2,-8(fp)
 d0329a0:	1004d63a 	srli	r2,r2,24
 d0329a4:	10c03fcc 	andi	r3,r2,255
 d0329a8:	e0bffe17 	ldw	r2,-8(fp)
 d0329ac:	1004d23a 	srli	r2,r2,8
 d0329b0:	10bfc00c 	andi	r2,r2,65280
 d0329b4:	1886b03a 	or	r3,r3,r2
 d0329b8:	e0bffe17 	ldw	r2,-8(fp)
 d0329bc:	10bfc00c 	andi	r2,r2,65280
 d0329c0:	1004923a 	slli	r2,r2,8
 d0329c4:	1886b03a 	or	r3,r3,r2
 d0329c8:	e0bffe17 	ldw	r2,-8(fp)
 d0329cc:	10803fcc 	andi	r2,r2,255
 d0329d0:	1004963a 	slli	r2,r2,24
 d0329d4:	1886b03a 	or	r3,r3,r2
 d0329d8:	e0bffc17 	ldw	r2,-16(fp)
 d0329dc:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 d0329e0:	e0bffd17 	ldw	r2,-12(fp)
 d0329e4:	1004d63a 	srli	r2,r2,24
 d0329e8:	10c03fcc 	andi	r3,r2,255
 d0329ec:	e0bffd17 	ldw	r2,-12(fp)
 d0329f0:	1004d23a 	srli	r2,r2,8
 d0329f4:	10bfc00c 	andi	r2,r2,65280
 d0329f8:	1886b03a 	or	r3,r3,r2
 d0329fc:	e0bffd17 	ldw	r2,-12(fp)
 d032a00:	10bfc00c 	andi	r2,r2,65280
 d032a04:	1004923a 	slli	r2,r2,8
 d032a08:	1886b03a 	or	r3,r3,r2
 d032a0c:	e0bffd17 	ldw	r2,-12(fp)
 d032a10:	10803fcc 	andi	r2,r2,255
 d032a14:	1004963a 	slli	r2,r2,24
 d032a18:	1886b03a 	or	r3,r3,r2
 d032a1c:	e0bffc17 	ldw	r2,-16(fp)
 d032a20:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 d032a24:	e0fffc17 	ldw	r3,-16(fp)
 d032a28:	00801404 	movi	r2,80
 d032a2c:	18800805 	stb	r2,32(r3)
   ti->ti_flags = (u_char)flags;
 d032a30:	e0800217 	ldw	r2,8(fp)
 d032a34:	1007883a 	mov	r3,r2
 d032a38:	e0bffc17 	ldw	r2,-16(fp)
 d032a3c:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 d032a40:	e0bff817 	ldw	r2,-32(fp)
 d032a44:	10bfffcc 	andi	r2,r2,65535
 d032a48:	1004d23a 	srli	r2,r2,8
 d032a4c:	10803fcc 	andi	r2,r2,255
 d032a50:	1009883a 	mov	r4,r2
 d032a54:	e0bff817 	ldw	r2,-32(fp)
 d032a58:	10bfffcc 	andi	r2,r2,65535
 d032a5c:	1004923a 	slli	r2,r2,8
 d032a60:	1007883a 	mov	r3,r2
 d032a64:	00bfc004 	movi	r2,-256
 d032a68:	1884703a 	and	r2,r3,r2
 d032a6c:	2084b03a 	or	r2,r4,r2
 d032a70:	1007883a 	mov	r3,r2
 d032a74:	e0bffc17 	ldw	r2,-16(fp)
 d032a78:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 d032a7c:	e0bffc17 	ldw	r2,-16(fp)
 d032a80:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 d032a84:	e0bff917 	ldw	r2,-28(fp)
 d032a88:	108000a0 	cmpeqi	r2,r2,2
 d032a8c:	1000011e 	bne	r2,zero,d032a94 <tcp_respond+0x36c>
 d032a90:	00004106 	br	d032b98 <tcp_respond+0x470>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 d032a94:	e0bffc17 	ldw	r2,-16(fp)
 d032a98:	e0bff315 	stw	r2,-52(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 d032a9c:	e0bffa17 	ldw	r2,-24(fp)
 d032aa0:	10800a04 	addi	r2,r2,40
 d032aa4:	1007883a 	mov	r3,r2
 d032aa8:	e0bff317 	ldw	r2,-52(fp)
 d032aac:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 d032ab0:	e0bff717 	ldw	r2,-36(fp)
 d032ab4:	10800117 	ldw	r2,4(r2)
 d032ab8:	10c00117 	ldw	r3,4(r2)
 d032abc:	00834174 	movhi	r2,3333
 d032ac0:	109b1e04 	addi	r2,r2,27768
 d032ac4:	10800017 	ldw	r2,0(r2)
 d032ac8:	1885883a 	add	r2,r3,r2
 d032acc:	1007883a 	mov	r3,r2
 d032ad0:	e0bff317 	ldw	r2,-52(fp)
 d032ad4:	10c00436 	bltu	r2,r3,d032ae8 <tcp_respond+0x3c0>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 d032ad8:	e0fff317 	ldw	r3,-52(fp)
 d032adc:	e0bff717 	ldw	r2,-36(fp)
 d032ae0:	10c00315 	stw	r3,12(r2)
 d032ae4:	00001206 	br	d032b30 <tcp_respond+0x408>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 d032ae8:	e0bff717 	ldw	r2,-36(fp)
 d032aec:	11000117 	ldw	r4,4(r2)
 d032af0:	e0bff717 	ldw	r2,-36(fp)
 d032af4:	10800117 	ldw	r2,4(r2)
 d032af8:	10c00117 	ldw	r3,4(r2)
 d032afc:	00834174 	movhi	r2,3333
 d032b00:	109b1e04 	addi	r2,r2,27768
 d032b04:	10800017 	ldw	r2,0(r2)
 d032b08:	1885883a 	add	r2,r3,r2
 d032b0c:	20800315 	stw	r2,12(r4)
 d032b10:	20c00317 	ldw	r3,12(r4)
 d032b14:	e0bff717 	ldw	r2,-36(fp)
 d032b18:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 d032b1c:	e0bff717 	ldw	r2,-36(fp)
 d032b20:	11000317 	ldw	r4,12(r2)
 d032b24:	e17ff317 	ldw	r5,-52(fp)
 d032b28:	01800a04 	movi	r6,40
 d032b2c:	d0026a80 	call	d0026a8 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 d032b30:	e0bffb17 	ldw	r2,-20(fp)
 d032b34:	1004c03a 	cmpne	r2,r2,zero
 d032b38:	1000031e 	bne	r2,zero,d032b48 <tcp_respond+0x420>
              m_freem(m);
 d032b3c:	e13ff717 	ldw	r4,-36(fp)
 d032b40:	d026b500 	call	d026b50 <m_freem>
 d032b44:	00001506 	br	d032b9c <tcp_respond+0x474>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 d032b48:	e0bffb17 	ldw	r2,-20(fp)
 d032b4c:	10800d17 	ldw	r2,52(r2)
 d032b50:	1005003a 	cmpeq	r2,r2,zero
 d032b54:	10000c1e 	bne	r2,zero,d032b88 <tcp_respond+0x460>
 d032b58:	e0bffb17 	ldw	r2,-20(fp)
 d032b5c:	10800d17 	ldw	r2,52(r2)
 d032b60:	10800817 	ldw	r2,32(r2)
 d032b64:	1005003a 	cmpeq	r2,r2,zero
 d032b68:	1000071e 	bne	r2,zero,d032b88 <tcp_respond+0x460>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 d032b6c:	e0bffb17 	ldw	r2,-20(fp)
 d032b70:	10800d17 	ldw	r2,52(r2)
 d032b74:	10800817 	ldw	r2,32(r2)
 d032b78:	11401f17 	ldw	r5,124(r2)
 d032b7c:	e13ff717 	ldw	r4,-36(fp)
 d032b80:	d0275840 	call	d027584 <ip_output>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 d032b84:	00000506 	br	d032b9c <tcp_respond+0x474>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 d032b88:	e13ff717 	ldw	r4,-36(fp)
 d032b8c:	000b883a 	mov	r5,zero
 d032b90:	d0275840 	call	d027584 <ip_output>
		 }

         break;
 d032b94:	00000106 	br	d032b9c <tcp_respond+0x474>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 d032b98:	d025a500 	call	d025a50 <dtrap>
         break;
   }
   return;
}
 d032b9c:	e037883a 	mov	sp,fp
 d032ba0:	dfc00117 	ldw	ra,4(sp)
 d032ba4:	df000017 	ldw	fp,0(sp)
 d032ba8:	dec00204 	addi	sp,sp,8
 d032bac:	f800283a 	ret

0d032bb0 <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 d032bb0:	defffa04 	addi	sp,sp,-24
 d032bb4:	dfc00515 	stw	ra,20(sp)
 d032bb8:	df000415 	stw	fp,16(sp)
 d032bbc:	df000404 	addi	fp,sp,16
 d032bc0:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 d032bc4:	01002504 	movi	r4,148
 d032bc8:	d0264b80 	call	d0264b8 <npalloc>
 d032bcc:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 d032bd0:	e0bffd17 	ldw	r2,-12(fp)
 d032bd4:	1004c03a 	cmpne	r2,r2,zero
 d032bd8:	1000021e 	bne	r2,zero,d032be4 <tcp_newtcpcb+0x34>
      return (struct tcpcb *)NULL;
 d032bdc:	e03fff15 	stw	zero,-4(fp)
 d032be0:	00003306 	br	d032cb0 <tcp_newtcpcb+0x100>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 d032be4:	e0fffd17 	ldw	r3,-12(fp)
 d032be8:	e0bffd17 	ldw	r2,-12(fp)
 d032bec:	10c00115 	stw	r3,4(r2)
 d032bf0:	e0bffd17 	ldw	r2,-12(fp)
 d032bf4:	10c00117 	ldw	r3,4(r2)
 d032bf8:	e0bffd17 	ldw	r2,-12(fp)
 d032bfc:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 d032c00:	e0fffd17 	ldw	r3,-12(fp)
 d032c04:	00816d04 	movi	r2,1460
 d032c08:	18800a0d 	sth	r2,40(r3)
   tp->t_flags = 0;        /* sends options! */
 d032c0c:	e0bffd17 	ldw	r2,-12(fp)
 d032c10:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 d032c14:	e0fffd17 	ldw	r3,-12(fp)
 d032c18:	e0bffe17 	ldw	r2,-8(fp)
 d032c1c:	18800d15 	stw	r2,52(r3)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 d032c20:	e0bffd17 	ldw	r2,-12(fp)
 d032c24:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 d032c28:	e0fffd17 	ldw	r3,-12(fp)
 d032c2c:	00800604 	movi	r2,24
 d032c30:	18802115 	stw	r2,132(r3)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 d032c34:	00800304 	movi	r2,12
 d032c38:	e0bffc0d 	sth	r2,-16(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 d032c3c:	e0fffc0f 	ldh	r3,-16(fp)
 d032c40:	e0bffd17 	ldw	r2,-12(fp)
 d032c44:	10c00815 	stw	r3,32(r2)
 d032c48:	e0bffd17 	ldw	r2,-12(fp)
 d032c4c:	10800817 	ldw	r2,32(r2)
 d032c50:	10800088 	cmpgei	r2,r2,2
 d032c54:	1000041e 	bne	r2,zero,d032c68 <tcp_newtcpcb+0xb8>
 d032c58:	e0fffd17 	ldw	r3,-12(fp)
 d032c5c:	00800084 	movi	r2,2
 d032c60:	18800815 	stw	r2,32(r3)
 d032c64:	00000706 	br	d032c84 <tcp_newtcpcb+0xd4>
 d032c68:	e0bffd17 	ldw	r2,-12(fp)
 d032c6c:	10800817 	ldw	r2,32(r2)
 d032c70:	10802050 	cmplti	r2,r2,129
 d032c74:	1000031e 	bne	r2,zero,d032c84 <tcp_newtcpcb+0xd4>
 d032c78:	e0fffd17 	ldw	r3,-12(fp)
 d032c7c:	00802004 	movi	r2,128
 d032c80:	18800815 	stw	r2,32(r3)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 d032c84:	e0fffd17 	ldw	r3,-12(fp)
 d032c88:	0082da04 	movi	r2,2920
 d032c8c:	18801b15 	stw	r2,108(r3)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 d032c90:	e0fffd17 	ldw	r3,-12(fp)
 d032c94:	00bfffd4 	movui	r2,65535
 d032c98:	18801c15 	stw	r2,112(r3)

   inp->inp_ppcb = (char *)tp;
 d032c9c:	e0fffd17 	ldw	r3,-12(fp)
 d032ca0:	e0bffe17 	ldw	r2,-8(fp)
 d032ca4:	10c00915 	stw	r3,36(r2)
   return (tp);
 d032ca8:	e0bffd17 	ldw	r2,-12(fp)
 d032cac:	e0bfff15 	stw	r2,-4(fp)
 d032cb0:	e0bfff17 	ldw	r2,-4(fp)
}
 d032cb4:	e037883a 	mov	sp,fp
 d032cb8:	dfc00117 	ldw	ra,4(sp)
 d032cbc:	df000017 	ldw	fp,0(sp)
 d032cc0:	dec00204 	addi	sp,sp,8
 d032cc4:	f800283a 	ret

0d032cc8 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 d032cc8:	defffb04 	addi	sp,sp,-20
 d032ccc:	dfc00415 	stw	ra,16(sp)
 d032cd0:	df000315 	stw	fp,12(sp)
 d032cd4:	df000304 	addi	fp,sp,12
 d032cd8:	e13ffe15 	stw	r4,-8(fp)
 d032cdc:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d032ce0:	e0bffe17 	ldw	r2,-8(fp)
 d032ce4:	10800d17 	ldw	r2,52(r2)
 d032ce8:	10800817 	ldw	r2,32(r2)
 d032cec:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 d032cf0:	e0bffe17 	ldw	r2,-8(fp)
 d032cf4:	10800217 	ldw	r2,8(r2)
 d032cf8:	108000d0 	cmplti	r2,r2,3
 d032cfc:	10000c1e 	bne	r2,zero,d032d30 <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 d032d00:	e0bffe17 	ldw	r2,-8(fp)
 d032d04:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 d032d08:	e13ffe17 	ldw	r4,-8(fp)
 d032d0c:	d0312480 	call	d031248 <tcp_output>
      tcpstat.tcps_drops++;
 d032d10:	008341b4 	movhi	r2,3334
 d032d14:	10848a04 	addi	r2,r2,4648
 d032d18:	10800317 	ldw	r2,12(r2)
 d032d1c:	10c00044 	addi	r3,r2,1
 d032d20:	008341b4 	movhi	r2,3334
 d032d24:	10848a04 	addi	r2,r2,4648
 d032d28:	10c00315 	stw	r3,12(r2)
 d032d2c:	00000706 	br	d032d4c <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 d032d30:	008341b4 	movhi	r2,3334
 d032d34:	10848a04 	addi	r2,r2,4648
 d032d38:	10800417 	ldw	r2,16(r2)
 d032d3c:	10c00044 	addi	r3,r2,1
 d032d40:	008341b4 	movhi	r2,3334
 d032d44:	10848a04 	addi	r2,r2,4648
 d032d48:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 d032d4c:	e0fffd17 	ldw	r3,-12(fp)
 d032d50:	e0bfff17 	ldw	r2,-4(fp)
 d032d54:	18800615 	stw	r2,24(r3)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 d032d58:	e13ffe17 	ldw	r4,-8(fp)
 d032d5c:	d032d740 	call	d032d74 <tcp_close>
}
 d032d60:	e037883a 	mov	sp,fp
 d032d64:	dfc00117 	ldw	ra,4(sp)
 d032d68:	df000017 	ldw	fp,0(sp)
 d032d6c:	dec00204 	addi	sp,sp,8
 d032d70:	f800283a 	ret

0d032d74 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 d032d74:	defff904 	addi	sp,sp,-28
 d032d78:	dfc00615 	stw	ra,24(sp)
 d032d7c:	df000515 	stw	fp,20(sp)
 d032d80:	df000504 	addi	fp,sp,20
 d032d84:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 d032d88:	e0bfff17 	ldw	r2,-4(fp)
 d032d8c:	10800d17 	ldw	r2,52(r2)
 d032d90:	e0bffd15 	stw	r2,-12(fp)
   struct socket *   so =  inp->inp_socket;
 d032d94:	e0bffd17 	ldw	r2,-12(fp)
 d032d98:	10800817 	ldw	r2,32(r2)
 d032d9c:	e0bffc15 	stw	r2,-16(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 d032da0:	e0bfff17 	ldw	r2,-4(fp)
 d032da4:	10800017 	ldw	r2,0(r2)
 d032da8:	e0bffe15 	stw	r2,-8(fp)
   while (t != (struct tcpiphdr *)tp) 
 d032dac:	00000c06 	br	d032de0 <tcp_close+0x6c>
   {
      t = (struct tcpiphdr *)t->ti_next;
 d032db0:	e0bffe17 	ldw	r2,-8(fp)
 d032db4:	10800017 	ldw	r2,0(r2)
 d032db8:	e0bffe15 	stw	r2,-8(fp)
      m = dtom(t->ti_prev);
 d032dbc:	e0bffe17 	ldw	r2,-8(fp)
 d032dc0:	11000117 	ldw	r4,4(r2)
 d032dc4:	d0270e00 	call	d0270e0 <dtom>
 d032dc8:	e0bffb15 	stw	r2,-20(fp)
      remque(t->ti_prev);
 d032dcc:	e0bffe17 	ldw	r2,-8(fp)
 d032dd0:	11000117 	ldw	r4,4(r2)
 d032dd4:	d0271880 	call	d027188 <remque>
      m_freem (m);
 d032dd8:	e13ffb17 	ldw	r4,-20(fp)
 d032ddc:	d026b500 	call	d026b50 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 d032de0:	e0ffff17 	ldw	r3,-4(fp)
 d032de4:	e0bffe17 	ldw	r2,-8(fp)
 d032de8:	10fff11e 	bne	r2,r3,d032db0 <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 d032dec:	e0bfff17 	ldw	r2,-4(fp)
 d032df0:	10800c17 	ldw	r2,48(r2)
 d032df4:	1005003a 	cmpeq	r2,r2,zero
 d032df8:	1000031e 	bne	r2,zero,d032e08 <tcp_close+0x94>
      TPH_FREE (tp->t_template);
 d032dfc:	e0bfff17 	ldw	r2,-4(fp)
 d032e00:	11000c17 	ldw	r4,48(r2)
 d032e04:	d0265ac0 	call	d0265ac <npfree>
   TCB_FREE (tp);
 d032e08:	e13fff17 	ldw	r4,-4(fp)
 d032e0c:	d0265ac0 	call	d0265ac <npfree>
   inp->inp_ppcb = 0;
 d032e10:	e0bffd17 	ldw	r2,-12(fp)
 d032e14:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 d032e18:	e13ffc17 	ldw	r4,-16(fp)
 d032e1c:	d02c8180 	call	d02c818 <soisdisconnected>
   in_pcbdetach(inp);
 d032e20:	e13ffd17 	ldw	r4,-12(fp)
 d032e24:	d0481c40 	call	d0481c4 <in_pcbdetach>
   tcpstat.tcps_closed++;
 d032e28:	008341b4 	movhi	r2,3334
 d032e2c:	10848a04 	addi	r2,r2,4648
 d032e30:	10800517 	ldw	r2,20(r2)
 d032e34:	10c00044 	addi	r3,r2,1
 d032e38:	008341b4 	movhi	r2,3334
 d032e3c:	10848a04 	addi	r2,r2,4648
 d032e40:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 d032e44:	0005883a 	mov	r2,zero
}
 d032e48:	e037883a 	mov	sp,fp
 d032e4c:	dfc00117 	ldw	ra,4(sp)
 d032e50:	df000017 	ldw	fp,0(sp)
 d032e54:	dec00204 	addi	sp,sp,8
 d032e58:	f800283a 	ret

0d032e5c <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 d032e5c:	defffd04 	addi	sp,sp,-12
 d032e60:	df000215 	stw	fp,8(sp)
 d032e64:	df000204 	addi	fp,sp,8
 d032e68:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 d032e6c:	e0bfff17 	ldw	r2,-4(fp)
 d032e70:	10800917 	ldw	r2,36(r2)
 d032e74:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 d032e78:	e0bffe17 	ldw	r2,-8(fp)
 d032e7c:	1005003a 	cmpeq	r2,r2,zero
 d032e80:	1000051e 	bne	r2,zero,d032e98 <tcp_quench+0x3c>
      tp->snd_cwnd = tp->t_maxseg;
 d032e84:	e0bffe17 	ldw	r2,-8(fp)
 d032e88:	10800a0b 	ldhu	r2,40(r2)
 d032e8c:	10ffffcc 	andi	r3,r2,65535
 d032e90:	e0bffe17 	ldw	r2,-8(fp)
 d032e94:	10c01b15 	stw	r3,108(r2)
}
 d032e98:	e037883a 	mov	sp,fp
 d032e9c:	df000017 	ldw	fp,0(sp)
 d032ea0:	dec00104 	addi	sp,sp,4
 d032ea4:	f800283a 	ret

0d032ea8 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 d032ea8:	defffc04 	addi	sp,sp,-16
 d032eac:	df000315 	stw	fp,12(sp)
 d032eb0:	df000304 	addi	fp,sp,12
 d032eb4:	e13ffe15 	stw	r4,-8(fp)
 d032eb8:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 d032ebc:	e0bffe17 	ldw	r2,-8(fp)
 d032ec0:	108000c4 	addi	r2,r2,3
 d032ec4:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 d032ec8:	e03ffd15 	stw	zero,-12(fp)
 d032ecc:	00000d06 	br	d032f04 <tcp_putseq+0x5c>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 d032ed0:	e0bfff17 	ldw	r2,-4(fp)
 d032ed4:	1007883a 	mov	r3,r2
 d032ed8:	e0bffe17 	ldw	r2,-8(fp)
 d032edc:	10c00005 	stb	r3,0(r2)
 d032ee0:	e0bffe17 	ldw	r2,-8(fp)
 d032ee4:	10bfffc4 	addi	r2,r2,-1
 d032ee8:	e0bffe15 	stw	r2,-8(fp)
      seq >>= 8;
 d032eec:	e0bfff17 	ldw	r2,-4(fp)
 d032ef0:	1004d23a 	srli	r2,r2,8
 d032ef4:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 d032ef8:	e0bffd17 	ldw	r2,-12(fp)
 d032efc:	10800044 	addi	r2,r2,1
 d032f00:	e0bffd15 	stw	r2,-12(fp)
 d032f04:	e0bffd17 	ldw	r2,-12(fp)
 d032f08:	10800110 	cmplti	r2,r2,4
 d032f0c:	103ff01e 	bne	r2,zero,d032ed0 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 d032f10:	e0bffe17 	ldw	r2,-8(fp)
 d032f14:	10800144 	addi	r2,r2,5
}
 d032f18:	e037883a 	mov	sp,fp
 d032f1c:	df000017 	ldw	fp,0(sp)
 d032f20:	dec00104 	addi	sp,sp,4
 d032f24:	f800283a 	ret

0d032f28 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 d032f28:	defffc04 	addi	sp,sp,-16
 d032f2c:	df000315 	stw	fp,12(sp)
 d032f30:	df000304 	addi	fp,sp,12
 d032f34:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 d032f38:	e03ffd15 	stw	zero,-12(fp)

   for(i = 0; i < 4; i++)
 d032f3c:	e03ffe15 	stw	zero,-8(fp)
 d032f40:	00000f06 	br	d032f80 <tcp_getseq+0x58>
   {
      seq <<= 8;
 d032f44:	e0bffd17 	ldw	r2,-12(fp)
 d032f48:	1004923a 	slli	r2,r2,8
 d032f4c:	e0bffd15 	stw	r2,-12(fp)
      seq += (u_long)*(cp++);
 d032f50:	e0bfff17 	ldw	r2,-4(fp)
 d032f54:	10800003 	ldbu	r2,0(r2)
 d032f58:	10c03fcc 	andi	r3,r2,255
 d032f5c:	e0bffd17 	ldw	r2,-12(fp)
 d032f60:	10c5883a 	add	r2,r2,r3
 d032f64:	e0bffd15 	stw	r2,-12(fp)
 d032f68:	e0bfff17 	ldw	r2,-4(fp)
 d032f6c:	10800044 	addi	r2,r2,1
 d032f70:	e0bfff15 	stw	r2,-4(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 d032f74:	e0bffe17 	ldw	r2,-8(fp)
 d032f78:	10800044 	addi	r2,r2,1
 d032f7c:	e0bffe15 	stw	r2,-8(fp)
 d032f80:	e0bffe17 	ldw	r2,-8(fp)
 d032f84:	10800110 	cmplti	r2,r2,4
 d032f88:	103fee1e 	bne	r2,zero,d032f44 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 d032f8c:	e0bffd17 	ldw	r2,-12(fp)
}
 d032f90:	e037883a 	mov	sp,fp
 d032f94:	df000017 	ldw	fp,0(sp)
 d032f98:	dec00104 	addi	sp,sp,4
 d032f9c:	f800283a 	ret

0d032fa0 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 d032fa0:	defff704 	addi	sp,sp,-36
 d032fa4:	dfc00815 	stw	ra,32(sp)
 d032fa8:	df000715 	stw	fp,28(sp)
 d032fac:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 d032fb0:	d0a03e17 	ldw	r2,-32520(gp)
 d032fb4:	100490fa 	slli	r2,r2,3
 d032fb8:	d0a93215 	stw	r2,-23352(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 d032fbc:	008341b4 	movhi	r2,3334
 d032fc0:	10845704 	addi	r2,r2,4444
 d032fc4:	10800017 	ldw	r2,0(r2)
 d032fc8:	e0bffb15 	stw	r2,-20(fp)
 d032fcc:	00008306 	br	d0331dc <tcp_slowtimo+0x23c>
   {
      sonext = so->next;
 d032fd0:	e0bffb17 	ldw	r2,-20(fp)
 d032fd4:	10800017 	ldw	r2,0(r2)
 d032fd8:	e0bffa15 	stw	r2,-24(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 d032fdc:	e0bffb17 	ldw	r2,-20(fp)
 d032fe0:	10800983 	ldbu	r2,38(r2)
 d032fe4:	10803fcc 	andi	r2,r2,255
 d032fe8:	1080201c 	xori	r2,r2,128
 d032fec:	10bfe004 	addi	r2,r2,-128
 d032ff0:	10800058 	cmpnei	r2,r2,1
 d032ff4:	1000471e 	bne	r2,zero,d033114 <tcp_slowtimo+0x174>
      {
         ip = so->so_pcb;
 d032ff8:	e0bffb17 	ldw	r2,-20(fp)
 d032ffc:	10800117 	ldw	r2,4(r2)
 d033000:	e0bfff15 	stw	r2,-4(fp)
         if (!ip)
 d033004:	e0bfff17 	ldw	r2,-4(fp)
 d033008:	1005003a 	cmpeq	r2,r2,zero
 d03300c:	1000711e 	bne	r2,zero,d0331d4 <tcp_slowtimo+0x234>
            continue;
         ipnxt = ip->inp_next;
 d033010:	e0bfff17 	ldw	r2,-4(fp)
 d033014:	10800017 	ldw	r2,0(r2)
 d033018:	e0bffe15 	stw	r2,-8(fp)

         tp = intotcpcb(so->so_pcb);
 d03301c:	e0bffb17 	ldw	r2,-20(fp)
 d033020:	10800117 	ldw	r2,4(r2)
 d033024:	10800917 	ldw	r2,36(r2)
 d033028:	e0bffd15 	stw	r2,-12(fp)
         if (!tp)
 d03302c:	e0bffd17 	ldw	r2,-12(fp)
 d033030:	1005003a 	cmpeq	r2,r2,zero
 d033034:	1000671e 	bne	r2,zero,d0331d4 <tcp_slowtimo+0x234>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 d033038:	e03ffc15 	stw	zero,-16(fp)
 d03303c:	00002d06 	br	d0330f4 <tcp_slowtimo+0x154>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 d033040:	e0bffc17 	ldw	r2,-16(fp)
 d033044:	e0fffd17 	ldw	r3,-12(fp)
 d033048:	1085883a 	add	r2,r2,r2
 d03304c:	1085883a 	add	r2,r2,r2
 d033050:	10c5883a 	add	r2,r2,r3
 d033054:	10800304 	addi	r2,r2,12
 d033058:	10800017 	ldw	r2,0(r2)
 d03305c:	1005003a 	cmpeq	r2,r2,zero
 d033060:	1000211e 	bne	r2,zero,d0330e8 <tcp_slowtimo+0x148>
 d033064:	e0fffc17 	ldw	r3,-16(fp)
 d033068:	e13ffd17 	ldw	r4,-12(fp)
 d03306c:	18c5883a 	add	r2,r3,r3
 d033070:	1085883a 	add	r2,r2,r2
 d033074:	1105883a 	add	r2,r2,r4
 d033078:	10800304 	addi	r2,r2,12
 d03307c:	10800017 	ldw	r2,0(r2)
 d033080:	117fffc4 	addi	r5,r2,-1
 d033084:	e13ffd17 	ldw	r4,-12(fp)
 d033088:	18c5883a 	add	r2,r3,r3
 d03308c:	1085883a 	add	r2,r2,r2
 d033090:	1105883a 	add	r2,r2,r4
 d033094:	10800304 	addi	r2,r2,12
 d033098:	11400015 	stw	r5,0(r2)
 d03309c:	e13ffd17 	ldw	r4,-12(fp)
 d0330a0:	18c5883a 	add	r2,r3,r3
 d0330a4:	1085883a 	add	r2,r2,r2
 d0330a8:	1105883a 	add	r2,r2,r4
 d0330ac:	10800304 	addi	r2,r2,12
 d0330b0:	10800017 	ldw	r2,0(r2)
 d0330b4:	1004c03a 	cmpne	r2,r2,zero
 d0330b8:	10000b1e 	bne	r2,zero,d0330e8 <tcp_slowtimo+0x148>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 d0330bc:	e0fffb17 	ldw	r3,-20(fp)
 d0330c0:	008004c4 	movi	r2,19
 d0330c4:	18800715 	stw	r2,28(r3)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 d0330c8:	e1bffc17 	ldw	r6,-16(fp)
 d0330cc:	e13ffb17 	ldw	r4,-20(fp)
 d0330d0:	000b883a 	mov	r5,zero
 d0330d4:	d0337380 	call	d033738 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 d0330d8:	e0bffe17 	ldw	r2,-8(fp)
 d0330dc:	10c00117 	ldw	r3,4(r2)
 d0330e0:	e0bfff17 	ldw	r2,-4(fp)
 d0330e4:	18803b1e 	bne	r3,r2,d0331d4 <tcp_slowtimo+0x234>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 d0330e8:	e0bffc17 	ldw	r2,-16(fp)
 d0330ec:	10800044 	addi	r2,r2,1
 d0330f0:	e0bffc15 	stw	r2,-16(fp)
 d0330f4:	e0bffc17 	ldw	r2,-16(fp)
 d0330f8:	10800110 	cmplti	r2,r2,4
 d0330fc:	103fd01e 	bne	r2,zero,d033040 <tcp_slowtimo+0xa0>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 d033100:	e0bffd17 	ldw	r2,-12(fp)
 d033104:	10801d17 	ldw	r2,116(r2)
 d033108:	10c00044 	addi	r3,r2,1
 d03310c:	e0bffd17 	ldw	r2,-12(fp)
 d033110:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 d033114:	e0bffb17 	ldw	r2,-20(fp)
 d033118:	10800a04 	addi	r2,r2,40
 d03311c:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 d033120:	e0bff917 	ldw	r2,-28(fp)
 d033124:	1080070b 	ldhu	r2,28(r2)
 d033128:	10bfffcc 	andi	r2,r2,65535
 d03312c:	1080020c 	andi	r2,r2,8
 d033130:	1005003a 	cmpeq	r2,r2,zero
 d033134:	10000d1e 	bne	r2,zero,d03316c <tcp_slowtimo+0x1cc>
      {
         select_wait = 0;
 d033138:	00834174 	movhi	r2,3333
 d03313c:	109b4d04 	addi	r2,r2,27956
 d033140:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 d033144:	01034174 	movhi	r4,3333
 d033148:	211b4d04 	addi	r4,r4,27956
 d03314c:	d02147c0 	call	d02147c <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 d033150:	e0bff917 	ldw	r2,-28(fp)
 d033154:	10c0070b 	ldhu	r3,28(r2)
 d033158:	00bffdc4 	movi	r2,-9
 d03315c:	1884703a 	and	r2,r3,r2
 d033160:	1007883a 	mov	r3,r2
 d033164:	e0bff917 	ldw	r2,-28(fp)
 d033168:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 d03316c:	e0bffb17 	ldw	r2,-20(fp)
 d033170:	10801204 	addi	r2,r2,72
 d033174:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 d033178:	e0bff917 	ldw	r2,-28(fp)
 d03317c:	1080070b 	ldhu	r2,28(r2)
 d033180:	10bfffcc 	andi	r2,r2,65535
 d033184:	1080020c 	andi	r2,r2,8
 d033188:	1005003a 	cmpeq	r2,r2,zero
 d03318c:	10000d1e 	bne	r2,zero,d0331c4 <tcp_slowtimo+0x224>
      {
         select_wait = 0;         
 d033190:	00834174 	movhi	r2,3333
 d033194:	109b4d04 	addi	r2,r2,27956
 d033198:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 d03319c:	01034174 	movhi	r4,3333
 d0331a0:	211b4d04 	addi	r4,r4,27956
 d0331a4:	d02147c0 	call	d02147c <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 d0331a8:	e0bff917 	ldw	r2,-28(fp)
 d0331ac:	10c0070b 	ldhu	r3,28(r2)
 d0331b0:	00bffdc4 	movi	r2,-9
 d0331b4:	1884703a 	and	r2,r3,r2
 d0331b8:	1007883a 	mov	r3,r2
 d0331bc:	e0bff917 	ldw	r2,-28(fp)
 d0331c0:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 d0331c4:	e0bffb17 	ldw	r2,-20(fp)
 d0331c8:	10800904 	addi	r2,r2,36
 d0331cc:	1009883a 	mov	r4,r2
 d0331d0:	d02147c0 	call	d02147c <tcp_wakeup>
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 d0331d4:	e0bffa17 	ldw	r2,-24(fp)
 d0331d8:	e0bffb15 	stw	r2,-20(fp)
 d0331dc:	e0bffb17 	ldw	r2,-20(fp)
 d0331e0:	1004c03a 	cmpne	r2,r2,zero
 d0331e4:	103f7a1e 	bne	r2,zero,d032fd0 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 d0331e8:	00834174 	movhi	r2,3333
 d0331ec:	109b5204 	addi	r2,r2,27976
 d0331f0:	10c00017 	ldw	r3,0(r2)
 d0331f4:	00be9fd4 	movui	r2,64127
 d0331f8:	1887883a 	add	r3,r3,r2
 d0331fc:	00834174 	movhi	r2,3333
 d033200:	109b5204 	addi	r2,r2,27976
 d033204:	10c00015 	stw	r3,0(r2)

   if (tcp_iss & 0xff000000)
 d033208:	00834174 	movhi	r2,3333
 d03320c:	109b5204 	addi	r2,r2,27976
 d033210:	10800017 	ldw	r2,0(r2)
 d033214:	10bfc02c 	andhi	r2,r2,65280
 d033218:	1005003a 	cmpeq	r2,r2,zero
 d03321c:	1000031e 	bne	r2,zero,d03322c <tcp_slowtimo+0x28c>
      tcp_iss = 0L;
 d033220:	00834174 	movhi	r2,3333
 d033224:	109b5204 	addi	r2,r2,27976
 d033228:	10000015 	stw	zero,0(r2)
}
 d03322c:	e037883a 	mov	sp,fp
 d033230:	dfc00117 	ldw	ra,4(sp)
 d033234:	df000017 	ldw	fp,0(sp)
 d033238:	dec00204 	addi	sp,sp,8
 d03323c:	f800283a 	ret

0d033240 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 d033240:	defffd04 	addi	sp,sp,-12
 d033244:	df000215 	stw	fp,8(sp)
 d033248:	df000204 	addi	fp,sp,8
 d03324c:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 d033250:	e03ffe15 	stw	zero,-8(fp)
 d033254:	00000a06 	br	d033280 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 d033258:	e0bffe17 	ldw	r2,-8(fp)
 d03325c:	e0ffff17 	ldw	r3,-4(fp)
 d033260:	1085883a 	add	r2,r2,r2
 d033264:	1085883a 	add	r2,r2,r2
 d033268:	10c5883a 	add	r2,r2,r3
 d03326c:	10800304 	addi	r2,r2,12
 d033270:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 d033274:	e0bffe17 	ldw	r2,-8(fp)
 d033278:	10800044 	addi	r2,r2,1
 d03327c:	e0bffe15 	stw	r2,-8(fp)
 d033280:	e0bffe17 	ldw	r2,-8(fp)
 d033284:	10800110 	cmplti	r2,r2,4
 d033288:	103ff31e 	bne	r2,zero,d033258 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 d03328c:	e037883a 	mov	sp,fp
 d033290:	df000017 	ldw	fp,0(sp)
 d033294:	dec00104 	addi	sp,sp,4
 d033298:	f800283a 	ret

0d03329c <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 d03329c:	defff504 	addi	sp,sp,-44
 d0332a0:	dfc00a15 	stw	ra,40(sp)
 d0332a4:	df000915 	stw	fp,36(sp)
 d0332a8:	df000904 	addi	fp,sp,36
 d0332ac:	e13ffb15 	stw	r4,-20(fp)
 d0332b0:	e17ffc15 	stw	r5,-16(fp)
   int   rexmt;

   switch (timer) 
 d0332b4:	e0bffc17 	ldw	r2,-16(fp)
 d0332b8:	e0bffe15 	stw	r2,-8(fp)
 d0332bc:	e0fffe17 	ldw	r3,-8(fp)
 d0332c0:	18800060 	cmpeqi	r2,r3,1
 d0332c4:	1000bd1e 	bne	r2,zero,d0335bc <tcp_timers+0x320>
 d0332c8:	e0fffe17 	ldw	r3,-8(fp)
 d0332cc:	18800088 	cmpgei	r2,r3,2
 d0332d0:	1000041e 	bne	r2,zero,d0332e4 <tcp_timers+0x48>
 d0332d4:	e0fffe17 	ldw	r3,-8(fp)
 d0332d8:	1805003a 	cmpeq	r2,r3,zero
 d0332dc:	10001b1e 	bne	r2,zero,d03334c <tcp_timers+0xb0>
 d0332e0:	00010f06 	br	d033720 <tcp_timers+0x484>
 d0332e4:	e0fffe17 	ldw	r3,-8(fp)
 d0332e8:	188000a0 	cmpeqi	r2,r3,2
 d0332ec:	1000c41e 	bne	r2,zero,d033600 <tcp_timers+0x364>
 d0332f0:	e0fffe17 	ldw	r3,-8(fp)
 d0332f4:	188000e0 	cmpeqi	r2,r3,3
 d0332f8:	1000011e 	bne	r2,zero,d033300 <tcp_timers+0x64>
 d0332fc:	00010806 	br	d033720 <tcp_timers+0x484>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 d033300:	e0bffb17 	ldw	r2,-20(fp)
 d033304:	10800217 	ldw	r2,8(r2)
 d033308:	108002a0 	cmpeqi	r2,r2,10
 d03330c:	10000b1e 	bne	r2,zero,d03333c <tcp_timers+0xa0>
 d033310:	e0bffb17 	ldw	r2,-20(fp)
 d033314:	10c01d17 	ldw	r3,116(r2)
 d033318:	d0a93217 	ldw	r2,-23352(gp)
 d03331c:	10c00716 	blt	r2,r3,d03333c <tcp_timers+0xa0>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 d033320:	d0a03e17 	ldw	r2,-32520(gp)
 d033324:	10ffffcc 	andi	r3,r2,65535
 d033328:	18e0001c 	xori	r3,r3,32768
 d03332c:	18e00004 	addi	r3,r3,-32768
 d033330:	e0bffb17 	ldw	r2,-20(fp)
 d033334:	10c00615 	stw	r3,24(r2)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 d033338:	0000f906 	br	d033720 <tcp_timers+0x484>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 d03333c:	e13ffb17 	ldw	r4,-20(fp)
 d033340:	d032d740 	call	d032d74 <tcp_close>
 d033344:	e0bffb15 	stw	r2,-20(fp)
      break;
 d033348:	0000f506 	br	d033720 <tcp_timers+0x484>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 d03334c:	008341b4 	movhi	r2,3334
 d033350:	10845c04 	addi	r2,r2,4464
 d033354:	10800b17 	ldw	r2,44(r2)
 d033358:	10c00044 	addi	r3,r2,1
 d03335c:	008341b4 	movhi	r2,3334
 d033360:	10845c04 	addi	r2,r2,4464
 d033364:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 d033368:	e0bffb17 	ldw	r2,-20(fp)
 d03336c:	10800717 	ldw	r2,28(r2)
 d033370:	10c00044 	addi	r3,r2,1
 d033374:	e0bffb17 	ldw	r2,-20(fp)
 d033378:	10c00715 	stw	r3,28(r2)
 d03337c:	e0bffb17 	ldw	r2,-20(fp)
 d033380:	10800717 	ldw	r2,28(r2)
 d033384:	10800350 	cmplti	r2,r2,13
 d033388:	10000f1e 	bne	r2,zero,d0333c8 <tcp_timers+0x12c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 d03338c:	e0fffb17 	ldw	r3,-20(fp)
 d033390:	00800304 	movi	r2,12
 d033394:	18800715 	stw	r2,28(r3)
         tcpstat.tcps_timeoutdrop++;
 d033398:	008341b4 	movhi	r2,3334
 d03339c:	10848a04 	addi	r2,r2,4648
 d0333a0:	10800917 	ldw	r2,36(r2)
 d0333a4:	10c00044 	addi	r3,r2,1
 d0333a8:	008341b4 	movhi	r2,3334
 d0333ac:	10848a04 	addi	r2,r2,4648
 d0333b0:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 d0333b4:	e13ffb17 	ldw	r4,-20(fp)
 d0333b8:	01401d04 	movi	r5,116
 d0333bc:	d032cc80 	call	d032cc8 <tcp_drop>
 d0333c0:	e0bffb15 	stw	r2,-20(fp)
         break;
 d0333c4:	0000d606 	br	d033720 <tcp_timers+0x484>
      }
      tcpstat.tcps_rexmttimeo++;
 d0333c8:	008341b4 	movhi	r2,3334
 d0333cc:	10848a04 	addi	r2,r2,4648
 d0333d0:	10800a17 	ldw	r2,40(r2)
 d0333d4:	10c00044 	addi	r3,r2,1
 d0333d8:	008341b4 	movhi	r2,3334
 d0333dc:	10848a04 	addi	r2,r2,4648
 d0333e0:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 d0333e4:	e0bffb17 	ldw	r2,-20(fp)
 d0333e8:	10802017 	ldw	r2,128(r2)
 d0333ec:	1007d0ba 	srai	r3,r2,2
 d0333f0:	e0bffb17 	ldw	r2,-20(fp)
 d0333f4:	10802117 	ldw	r2,132(r2)
 d0333f8:	1885883a 	add	r2,r3,r2
 d0333fc:	1005d07a 	srai	r2,r2,1
 d033400:	e0bffa15 	stw	r2,-24(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 d033404:	e0bffb17 	ldw	r2,-20(fp)
 d033408:	10c00717 	ldw	r3,28(r2)
 d03340c:	00834174 	movhi	r2,3333
 d033410:	10914dc4 	addi	r2,r2,17719
 d033414:	10c5883a 	add	r2,r2,r3
 d033418:	10800003 	ldbu	r2,0(r2)
 d03341c:	11403fcc 	andi	r5,r2,255
 d033420:	e13ffa17 	ldw	r4,-24(fp)
 d033424:	d00235c0 	call	d00235c <__mulsi3>
 d033428:	e0bffa15 	stw	r2,-24(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 d03342c:	e0bffa17 	ldw	r2,-24(fp)
 d033430:	10ffffcc 	andi	r3,r2,65535
 d033434:	18e0001c 	xori	r3,r3,32768
 d033438:	18e00004 	addi	r3,r3,-32768
 d03343c:	e0bffb17 	ldw	r2,-20(fp)
 d033440:	10c00815 	stw	r3,32(r2)
 d033444:	e0bffb17 	ldw	r2,-20(fp)
 d033448:	10800817 	ldw	r2,32(r2)
 d03344c:	10800088 	cmpgei	r2,r2,2
 d033450:	1000041e 	bne	r2,zero,d033464 <tcp_timers+0x1c8>
 d033454:	e0fffb17 	ldw	r3,-20(fp)
 d033458:	00800084 	movi	r2,2
 d03345c:	18800815 	stw	r2,32(r3)
 d033460:	00000706 	br	d033480 <tcp_timers+0x1e4>
 d033464:	e0bffb17 	ldw	r2,-20(fp)
 d033468:	10800817 	ldw	r2,32(r2)
 d03346c:	10802050 	cmplti	r2,r2,129
 d033470:	1000031e 	bne	r2,zero,d033480 <tcp_timers+0x1e4>
 d033474:	e0fffb17 	ldw	r3,-20(fp)
 d033478:	00802004 	movi	r2,128
 d03347c:	18800815 	stw	r2,32(r3)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d033480:	e0bffb17 	ldw	r2,-20(fp)
 d033484:	10c00817 	ldw	r3,32(r2)
 d033488:	e0bffb17 	ldw	r2,-20(fp)
 d03348c:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 d033490:	e0bffb17 	ldw	r2,-20(fp)
 d033494:	10800717 	ldw	r2,28(r2)
 d033498:	10800110 	cmplti	r2,r2,4
 d03349c:	1000101e 	bne	r2,zero,d0334e0 <tcp_timers+0x244>
 d0334a0:	e0bffb17 	ldw	r2,-20(fp)
 d0334a4:	10800b0b 	ldhu	r2,44(r2)
 d0334a8:	10bfffcc 	andi	r2,r2,65535
 d0334ac:	1080400c 	andi	r2,r2,256
 d0334b0:	1004c03a 	cmpne	r2,r2,zero
 d0334b4:	10000a1e 	bne	r2,zero,d0334e0 <tcp_timers+0x244>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 d0334b8:	e0bffb17 	ldw	r2,-20(fp)
 d0334bc:	10c02117 	ldw	r3,132(r2)
 d0334c0:	e0bffb17 	ldw	r2,-20(fp)
 d0334c4:	10802017 	ldw	r2,128(r2)
 d0334c8:	1005d0ba 	srai	r2,r2,2
 d0334cc:	1887883a 	add	r3,r3,r2
 d0334d0:	e0bffb17 	ldw	r2,-20(fp)
 d0334d4:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 d0334d8:	e0bffb17 	ldw	r2,-20(fp)
 d0334dc:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 d0334e0:	e0bffb17 	ldw	r2,-20(fp)
 d0334e4:	10c00e17 	ldw	r3,56(r2)
 d0334e8:	e0bffb17 	ldw	r2,-20(fp)
 d0334ec:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 d0334f0:	e0bffb17 	ldw	r2,-20(fp)
 d0334f4:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 d0334f8:	e0bffb17 	ldw	r2,-20(fp)
 d0334fc:	10800d17 	ldw	r2,52(r2)
 d033500:	10800817 	ldw	r2,32(r2)
 d033504:	10800417 	ldw	r2,16(r2)
 d033508:	1090000c 	andi	r2,r2,16384
 d03350c:	1004c03a 	cmpne	r2,r2,zero
 d033510:	1000271e 	bne	r2,zero,d0335b0 <tcp_timers+0x314>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 d033514:	e0bffb17 	ldw	r2,-20(fp)
 d033518:	10c01417 	ldw	r3,80(r2)
 d03351c:	e0bffb17 	ldw	r2,-20(fp)
 d033520:	10801b17 	ldw	r2,108(r2)
 d033524:	e0bffd15 	stw	r2,-12(fp)
 d033528:	e0ffff15 	stw	r3,-4(fp)
 d03352c:	e0bffd17 	ldw	r2,-12(fp)
 d033530:	e0ffff17 	ldw	r3,-4(fp)
 d033534:	10c0022e 	bgeu	r2,r3,d033540 <tcp_timers+0x2a4>
 d033538:	e0bffd17 	ldw	r2,-12(fp)
 d03353c:	e0bfff15 	stw	r2,-4(fp)
 d033540:	e0ffff17 	ldw	r3,-4(fp)
 d033544:	e0fff915 	stw	r3,-28(fp)
         win = win / 2 / tp->t_maxseg;
 d033548:	e0bff917 	ldw	r2,-28(fp)
 d03354c:	1008d07a 	srli	r4,r2,1
 d033550:	e0bffb17 	ldw	r2,-20(fp)
 d033554:	10800a0b 	ldhu	r2,40(r2)
 d033558:	117fffcc 	andi	r5,r2,65535
 d03355c:	d00c90c0 	call	d00c90c <__udivsi3>
 d033560:	e0bff915 	stw	r2,-28(fp)
         if (win < 2)
 d033564:	e0bff917 	ldw	r2,-28(fp)
 d033568:	108000a8 	cmpgeui	r2,r2,2
 d03356c:	1000021e 	bne	r2,zero,d033578 <tcp_timers+0x2dc>
            win = 2;
 d033570:	00800084 	movi	r2,2
 d033574:	e0bff915 	stw	r2,-28(fp)
         tp->snd_cwnd = tp->t_maxseg;
 d033578:	e0bffb17 	ldw	r2,-20(fp)
 d03357c:	10800a0b 	ldhu	r2,40(r2)
 d033580:	10ffffcc 	andi	r3,r2,65535
 d033584:	e0bffb17 	ldw	r2,-20(fp)
 d033588:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 d03358c:	e0bff917 	ldw	r2,-28(fp)
 d033590:	113fffcc 	andi	r4,r2,65535
 d033594:	e0bffb17 	ldw	r2,-20(fp)
 d033598:	10800a0b 	ldhu	r2,40(r2)
 d03359c:	117fffcc 	andi	r5,r2,65535
 d0335a0:	d00235c0 	call	d00235c <__mulsi3>
 d0335a4:	1007883a 	mov	r3,r2
 d0335a8:	e0bffb17 	ldw	r2,-20(fp)
 d0335ac:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 d0335b0:	e13ffb17 	ldw	r4,-20(fp)
 d0335b4:	d0312480 	call	d031248 <tcp_output>
      break;
 d0335b8:	00005906 	br	d033720 <tcp_timers+0x484>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 d0335bc:	008341b4 	movhi	r2,3334
 d0335c0:	10848a04 	addi	r2,r2,4648
 d0335c4:	10800b17 	ldw	r2,44(r2)
 d0335c8:	10c00044 	addi	r3,r2,1
 d0335cc:	008341b4 	movhi	r2,3334
 d0335d0:	10848a04 	addi	r2,r2,4648
 d0335d4:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 d0335d8:	e13ffb17 	ldw	r4,-20(fp)
 d0335dc:	d0323d40 	call	d0323d4 <tcp_setpersist>
      tp->t_force = 1;
 d0335e0:	e0fffb17 	ldw	r3,-20(fp)
 d0335e4:	00800044 	movi	r2,1
 d0335e8:	18800a85 	stb	r2,42(r3)
      (void) tcp_output(tp);
 d0335ec:	e13ffb17 	ldw	r4,-20(fp)
 d0335f0:	d0312480 	call	d031248 <tcp_output>
      tp->t_force = 0;
 d0335f4:	e0bffb17 	ldw	r2,-20(fp)
 d0335f8:	10000a85 	stb	zero,42(r2)
      break;
 d0335fc:	00004806 	br	d033720 <tcp_timers+0x484>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 d033600:	008341b4 	movhi	r2,3334
 d033604:	10848a04 	addi	r2,r2,4648
 d033608:	10800c17 	ldw	r2,48(r2)
 d03360c:	10c00044 	addi	r3,r2,1
 d033610:	008341b4 	movhi	r2,3334
 d033614:	10848a04 	addi	r2,r2,4648
 d033618:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 d03361c:	e0bffb17 	ldw	r2,-20(fp)
 d033620:	10800217 	ldw	r2,8(r2)
 d033624:	10800110 	cmplti	r2,r2,4
 d033628:	1000321e 	bne	r2,zero,d0336f4 <tcp_timers+0x458>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 d03362c:	e0bffb17 	ldw	r2,-20(fp)
 d033630:	10800d17 	ldw	r2,52(r2)
 d033634:	10800817 	ldw	r2,32(r2)
 d033638:	10800417 	ldw	r2,16(r2)
 d03363c:	1080020c 	andi	r2,r2,8
 d033640:	1005003a 	cmpeq	r2,r2,zero
 d033644:	1000241e 	bne	r2,zero,d0336d8 <tcp_timers+0x43c>
 d033648:	e0bffb17 	ldw	r2,-20(fp)
 d03364c:	10800217 	ldw	r2,8(r2)
 d033650:	10800188 	cmpgei	r2,r2,6
 d033654:	1000201e 	bne	r2,zero,d0336d8 <tcp_timers+0x43c>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 d033658:	e0bffb17 	ldw	r2,-20(fp)
 d03365c:	11001d17 	ldw	r4,116(r2)
 d033660:	d0e03d17 	ldw	r3,-32524(gp)
 d033664:	d0a93217 	ldw	r2,-23352(gp)
 d033668:	1885883a 	add	r2,r3,r2
 d03366c:	2080210e 	bge	r4,r2,d0336f4 <tcp_timers+0x458>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 d033670:	008341b4 	movhi	r2,3334
 d033674:	10848a04 	addi	r2,r2,4648
 d033678:	10800d17 	ldw	r2,52(r2)
 d03367c:	10c00044 	addi	r3,r2,1
 d033680:	008341b4 	movhi	r2,3334
 d033684:	10848a04 	addi	r2,r2,4648
 d033688:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 d03368c:	e0bffb17 	ldw	r2,-20(fp)
 d033690:	11400c17 	ldw	r5,48(r2)
 d033694:	e0bffb17 	ldw	r2,-20(fp)
 d033698:	10801617 	ldw	r2,88(r2)
 d03369c:	11bfffc4 	addi	r6,r2,-1
 d0336a0:	e0bffb17 	ldw	r2,-20(fp)
 d0336a4:	10800e17 	ldw	r2,56(r2)
 d0336a8:	11ffffc4 	addi	r7,r2,-1
 d0336ac:	d8000015 	stw	zero,0(sp)
 d0336b0:	d8000115 	stw	zero,4(sp)
 d0336b4:	e13ffb17 	ldw	r4,-20(fp)
 d0336b8:	d0327280 	call	d032728 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 d0336bc:	d0a03e17 	ldw	r2,-32520(gp)
 d0336c0:	10ffffcc 	andi	r3,r2,65535
 d0336c4:	18e0001c 	xori	r3,r3,32768
 d0336c8:	18e00004 	addi	r3,r3,-32768
 d0336cc:	e0bffb17 	ldw	r2,-20(fp)
 d0336d0:	10c00515 	stw	r3,20(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 d0336d4:	00001206 	br	d033720 <tcp_timers+0x484>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 d0336d8:	d0a03d17 	ldw	r2,-32524(gp)
 d0336dc:	10ffffcc 	andi	r3,r2,65535
 d0336e0:	18e0001c 	xori	r3,r3,32768
 d0336e4:	18e00004 	addi	r3,r3,-32768
 d0336e8:	e0bffb17 	ldw	r2,-20(fp)
 d0336ec:	10c00515 	stw	r3,20(r2)
      break;
 d0336f0:	00000b06 	br	d033720 <tcp_timers+0x484>
      dropit:
      tcpstat.tcps_keepdrops++;
 d0336f4:	008341b4 	movhi	r2,3334
 d0336f8:	10848a04 	addi	r2,r2,4648
 d0336fc:	10800e17 	ldw	r2,56(r2)
 d033700:	10c00044 	addi	r3,r2,1
 d033704:	008341b4 	movhi	r2,3334
 d033708:	10848a04 	addi	r2,r2,4648
 d03370c:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 d033710:	e13ffb17 	ldw	r4,-20(fp)
 d033714:	01401d04 	movi	r5,116
 d033718:	d032cc80 	call	d032cc8 <tcp_drop>
 d03371c:	e0bffb15 	stw	r2,-20(fp)
      break;
   }
   return tp;
 d033720:	e0bffb17 	ldw	r2,-20(fp)
}
 d033724:	e037883a 	mov	sp,fp
 d033728:	dfc00117 	ldw	ra,4(sp)
 d03372c:	df000017 	ldw	fp,0(sp)
 d033730:	dec00204 	addi	sp,sp,8
 d033734:	f800283a 	ret

0d033738 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 d033738:	defff504 	addi	sp,sp,-44
 d03373c:	dfc00a15 	stw	ra,40(sp)
 d033740:	df000915 	stw	fp,36(sp)
 d033744:	df000904 	addi	fp,sp,36
 d033748:	e13ffc15 	stw	r4,-16(fp)
 d03374c:	e17ffd15 	stw	r5,-12(fp)
 d033750:	e1bffe15 	stw	r6,-8(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 d033754:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 d033758:	e0bffc17 	ldw	r2,-16(fp)
 d03375c:	10800717 	ldw	r2,28(r2)
 d033760:	e0bff815 	stw	r2,-32(fp)
   inp = sotoinpcb(so);
 d033764:	e0bffc17 	ldw	r2,-16(fp)
 d033768:	10800117 	ldw	r2,4(r2)
 d03376c:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 d033770:	e0bffb17 	ldw	r2,-20(fp)
 d033774:	1004c03a 	cmpne	r2,r2,zero
 d033778:	1000061e 	bne	r2,zero,d033794 <tcp_usrreq+0x5c>
 d03377c:	e0bff817 	ldw	r2,-32(fp)
 d033780:	1005003a 	cmpeq	r2,r2,zero
 d033784:	1000031e 	bne	r2,zero,d033794 <tcp_usrreq+0x5c>
   {
      return (EINVAL);
 d033788:	00800584 	movi	r2,22
 d03378c:	e0bfff15 	stw	r2,-4(fp)
 d033790:	0001a406 	br	d033e24 <tcp_usrreq+0x6ec>
   }

   if (inp)
 d033794:	e0bffb17 	ldw	r2,-20(fp)
 d033798:	1005003a 	cmpeq	r2,r2,zero
 d03379c:	1000041e 	bne	r2,zero,d0337b0 <tcp_usrreq+0x78>
      tp = intotcpcb(inp);
 d0337a0:	e0bffb17 	ldw	r2,-20(fp)
 d0337a4:	10800917 	ldw	r2,36(r2)
 d0337a8:	e0bffa15 	stw	r2,-24(fp)
 d0337ac:	00000906 	br	d0337d4 <tcp_usrreq+0x9c>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 d0337b0:	e0bff817 	ldw	r2,-32(fp)
 d0337b4:	1004c03a 	cmpne	r2,r2,zero
 d0337b8:	1000021e 	bne	r2,zero,d0337c4 <tcp_usrreq+0x8c>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 d0337bc:	e03ffa15 	stw	zero,-24(fp)
 d0337c0:	00000406 	br	d0337d4 <tcp_usrreq+0x9c>
      else
      {
         dtrap(); /* programming error? */
 d0337c4:	d025a500 	call	d025a50 <dtrap>
         return EINVAL;
 d0337c8:	00800584 	movi	r2,22
 d0337cc:	e0bfff15 	stw	r2,-4(fp)
 d0337d0:	00019406 	br	d033e24 <tcp_usrreq+0x6ec>
      }
   }

   switch (req) 
 d0337d4:	e0bff817 	ldw	r2,-32(fp)
 d0337d8:	10800528 	cmpgeui	r2,r2,20
 d0337dc:	10018c1e 	bne	r2,zero,d033e10 <tcp_usrreq+0x6d8>
 d0337e0:	e0bff817 	ldw	r2,-32(fp)
 d0337e4:	1085883a 	add	r2,r2,r2
 d0337e8:	1087883a 	add	r3,r2,r2
 d0337ec:	008340f4 	movhi	r2,3331
 d0337f0:	108e0004 	addi	r2,r2,14336
 d0337f4:	1885883a 	add	r2,r3,r2
 d0337f8:	10800017 	ldw	r2,0(r2)
 d0337fc:	1000683a 	jmp	r2
 d033800:	0d033850 	cmplti	r20,at,3297
 d033804:	0d0338c0 	call	d0338c <__ram_exceptions_end+0xc83190>
 d033808:	0d0338e8 	cmpgeui	r20,at,3299
 d03380c:	0d033920 	cmpeqi	r20,at,3300
 d033810:	0d033960 	cmpeqi	r20,at,3301
 d033814:	0d033ae4 	muli	r20,at,3307
 d033818:	0d033ad8 	cmpnei	r20,at,3307
 d03381c:	0d033b90 	cmplti	r20,at,3310
 d033820:	0d033bc0 	call	d033bc <__ram_exceptions_end+0xc831c0>
 d033824:	0d033bcc 	andi	r20,at,3311
 d033828:	0d033c24 	muli	r20,at,3312
 d03382c:	0d033e10 	cmplti	r20,at,3320
 d033830:	0d033c34 	orhi	r20,at,3312
 d033834:	0d033c40 	call	d033c4 <__ram_exceptions_end+0xc831c8>
 d033838:	0d033d10 	cmplti	r20,at,3316
 d03383c:	0d033de0 	cmpeqi	r20,at,3319
 d033840:	0d033df0 	cmpltui	r20,at,3319
 d033844:	0d033acc 	andi	r20,at,3307
 d033848:	0d033e10 	cmplti	r20,at,3320
 d03384c:	0d033e00 	call	d033e0 <__ram_exceptions_end+0xc831e4>
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 d033850:	e0bffb17 	ldw	r2,-20(fp)
 d033854:	1005003a 	cmpeq	r2,r2,zero
 d033858:	1000031e 	bne	r2,zero,d033868 <tcp_usrreq+0x130>
      {
         error = EISCONN;
 d03385c:	00801fc4 	movi	r2,127
 d033860:	e0bff915 	stw	r2,-28(fp)
         break;
 d033864:	00016d06 	br	d033e1c <tcp_usrreq+0x6e4>
      }
      error = tcp_attach(so);
 d033868:	e13ffc17 	ldw	r4,-16(fp)
 d03386c:	d033e3c0 	call	d033e3c <tcp_attach>
 d033870:	e0bff915 	stw	r2,-28(fp)
      if (error)
 d033874:	e0bff917 	ldw	r2,-28(fp)
 d033878:	1004c03a 	cmpne	r2,r2,zero
 d03387c:	1001671e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 d033880:	e0bffc17 	ldw	r2,-16(fp)
 d033884:	10800417 	ldw	r2,16(r2)
 d033888:	1080200c 	andi	r2,r2,128
 d03388c:	1005003a 	cmpeq	r2,r2,zero
 d033890:	1001621e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
 d033894:	e0bffc17 	ldw	r2,-16(fp)
 d033898:	1080080b 	ldhu	r2,32(r2)
 d03389c:	10bfffcc 	andi	r2,r2,65535
 d0338a0:	10a0001c 	xori	r2,r2,32768
 d0338a4:	10a00004 	addi	r2,r2,-32768
 d0338a8:	1004c03a 	cmpne	r2,r2,zero
 d0338ac:	10015b1e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         so->so_linger = TCP_LINGERTIME;
 d0338b0:	e0fffc17 	ldw	r3,-16(fp)
 d0338b4:	00801e04 	movi	r2,120
 d0338b8:	1880080d 	sth	r2,32(r3)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 d0338bc:	00015706 	br	d033e1c <tcp_usrreq+0x6e4>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 d0338c0:	e0bffa17 	ldw	r2,-24(fp)
 d0338c4:	10800217 	ldw	r2,8(r2)
 d0338c8:	10800090 	cmplti	r2,r2,2
 d0338cc:	1000031e 	bne	r2,zero,d0338dc <tcp_usrreq+0x1a4>
         SETTP(tp, tcp_disconnect(tp));
 d0338d0:	e13ffa17 	ldw	r4,-24(fp)
 d0338d4:	d033f700 	call	d033f70 <tcp_disconnect>
 d0338d8:	00015006 	br	d033e1c <tcp_usrreq+0x6e4>
      else
         SETTP(tp, tcp_close(tp));
 d0338dc:	e13ffa17 	ldw	r4,-24(fp)
 d0338e0:	d032d740 	call	d032d74 <tcp_close>
      break;
 d0338e4:	00014d06 	br	d033e1c <tcp_usrreq+0x6e4>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 d0338e8:	e0bffb17 	ldw	r2,-20(fp)
 d0338ec:	10800817 	ldw	r2,32(r2)
 d0338f0:	10800517 	ldw	r2,20(r2)
 d0338f4:	10800098 	cmpnei	r2,r2,2
 d0338f8:	1000051e 	bne	r2,zero,d033910 <tcp_usrreq+0x1d8>
      {
         error = in_pcbbind(inp, nam);
 d0338fc:	e13ffb17 	ldw	r4,-20(fp)
 d033900:	e17ffe17 	ldw	r5,-8(fp)
 d033904:	d0482180 	call	d048218 <in_pcbbind>
 d033908:	e0bff915 	stw	r2,-28(fp)
         break;
 d03390c:	00014306 	br	d033e1c <tcp_usrreq+0x6e4>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 d033910:	d025a500 	call	d025a50 <dtrap>
      error = EINVAL;
 d033914:	00800584 	movi	r2,22
 d033918:	e0bff915 	stw	r2,-28(fp)
      break;
 d03391c:	00013f06 	br	d033e1c <tcp_usrreq+0x6e4>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 d033920:	e0bffb17 	ldw	r2,-20(fp)
 d033924:	1080078b 	ldhu	r2,30(r2)
 d033928:	10bfffcc 	andi	r2,r2,65535
 d03392c:	1004c03a 	cmpne	r2,r2,zero
 d033930:	1000041e 	bne	r2,zero,d033944 <tcp_usrreq+0x20c>
         error = in_pcbbind(inp, (struct mbuf *)0);
 d033934:	e13ffb17 	ldw	r4,-20(fp)
 d033938:	000b883a 	mov	r5,zero
 d03393c:	d0482180 	call	d048218 <in_pcbbind>
 d033940:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 d033944:	e0bff917 	ldw	r2,-28(fp)
 d033948:	1004c03a 	cmpne	r2,r2,zero
 d03394c:	1001331e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         tp->t_state = TCPS_LISTEN;
 d033950:	e0fffa17 	ldw	r3,-24(fp)
 d033954:	00800044 	movi	r2,1
 d033958:	18800215 	stw	r2,8(r3)
      break;
 d03395c:	00012f06 	br	d033e1c <tcp_usrreq+0x6e4>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 d033960:	e0bffb17 	ldw	r2,-20(fp)
 d033964:	1080078b 	ldhu	r2,30(r2)
 d033968:	10bfffcc 	andi	r2,r2,65535
 d03396c:	1004c03a 	cmpne	r2,r2,zero
 d033970:	1000071e 	bne	r2,zero,d033990 <tcp_usrreq+0x258>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 d033974:	e13ffb17 	ldw	r4,-20(fp)
 d033978:	000b883a 	mov	r5,zero
 d03397c:	d0482180 	call	d048218 <in_pcbbind>
 d033980:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 d033984:	e0bff917 	ldw	r2,-28(fp)
 d033988:	1004c03a 	cmpne	r2,r2,zero
 d03398c:	1001231e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 d033990:	e13ffb17 	ldw	r4,-20(fp)
 d033994:	e17ffe17 	ldw	r5,-8(fp)
 d033998:	d04846c0 	call	d04846c <in_pcbconnect>
 d03399c:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 d0339a0:	e0bff917 	ldw	r2,-28(fp)
 d0339a4:	1004c03a 	cmpne	r2,r2,zero
 d0339a8:	10011c1e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         break;
      tp->t_template = tcp_template(tp);
 d0339ac:	e13ffa17 	ldw	r4,-24(fp)
 d0339b0:	d0326100 	call	d032610 <tcp_template>
 d0339b4:	1007883a 	mov	r3,r2
 d0339b8:	e0bffa17 	ldw	r2,-24(fp)
 d0339bc:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 d0339c0:	e0bffa17 	ldw	r2,-24(fp)
 d0339c4:	10800c17 	ldw	r2,48(r2)
 d0339c8:	1004c03a 	cmpne	r2,r2,zero
 d0339cc:	1000051e 	bne	r2,zero,d0339e4 <tcp_usrreq+0x2ac>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 d0339d0:	e13ffb17 	ldw	r4,-20(fp)
 d0339d4:	d04867c0 	call	d04867c <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 d0339d8:	00801a44 	movi	r2,105
 d0339dc:	e0bff915 	stw	r2,-28(fp)
         break;
 d0339e0:	00010e06 	br	d033e1c <tcp_usrreq+0x6e4>
      }

      soisconnecting(so);
 d0339e4:	e13ffc17 	ldw	r4,-16(fp)
 d0339e8:	d02c6240 	call	d02c624 <soisconnecting>
      tcpstat.tcps_connattempt++;
 d0339ec:	008341b4 	movhi	r2,3334
 d0339f0:	10848a04 	addi	r2,r2,4648
 d0339f4:	10800017 	ldw	r2,0(r2)
 d0339f8:	10c00044 	addi	r3,r2,1
 d0339fc:	008341b4 	movhi	r2,3334
 d033a00:	10848a04 	addi	r2,r2,4648
 d033a04:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 d033a08:	e0fffa17 	ldw	r3,-24(fp)
 d033a0c:	00800084 	movi	r2,2
 d033a10:	18800215 	stw	r2,8(r3)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 d033a14:	e0fffa17 	ldw	r3,-24(fp)
 d033a18:	00802584 	movi	r2,150
 d033a1c:	18800515 	stw	r2,20(r3)
      tp->iss = tcp_iss; 
 d033a20:	00834174 	movhi	r2,3333
 d033a24:	109b5204 	addi	r2,r2,27976
 d033a28:	10c00017 	ldw	r3,0(r2)
 d033a2c:	e0bffa17 	ldw	r2,-24(fp)
 d033a30:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 d033a34:	00834174 	movhi	r2,3333
 d033a38:	109b5204 	addi	r2,r2,27976
 d033a3c:	10c00017 	ldw	r3,0(r2)
 d033a40:	00be9fd4 	movui	r2,64127
 d033a44:	1887883a 	add	r3,r3,r2
 d033a48:	00834174 	movhi	r2,3333
 d033a4c:	109b5204 	addi	r2,r2,27976
 d033a50:	10c00015 	stw	r3,0(r2)
      tcp_sendseqinit(tp);
 d033a54:	e0bffa17 	ldw	r2,-24(fp)
 d033a58:	10c01317 	ldw	r3,76(r2)
 d033a5c:	e0bffa17 	ldw	r2,-24(fp)
 d033a60:	10c01015 	stw	r3,64(r2)
 d033a64:	e0bffa17 	ldw	r2,-24(fp)
 d033a68:	10c01017 	ldw	r3,64(r2)
 d033a6c:	e0bffa17 	ldw	r2,-24(fp)
 d033a70:	10c01a15 	stw	r3,104(r2)
 d033a74:	e0bffa17 	ldw	r2,-24(fp)
 d033a78:	10c01a17 	ldw	r3,104(r2)
 d033a7c:	e0bffa17 	ldw	r2,-24(fp)
 d033a80:	10c00f15 	stw	r3,60(r2)
 d033a84:	e0bffa17 	ldw	r2,-24(fp)
 d033a88:	10c00f17 	ldw	r3,60(r2)
 d033a8c:	e0bffa17 	ldw	r2,-24(fp)
 d033a90:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 d033a94:	e13ffa17 	ldw	r4,-24(fp)
 d033a98:	d0312480 	call	d031248 <tcp_output>
 d033a9c:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 d033aa0:	e0bff917 	ldw	r2,-28(fp)
 d033aa4:	1004c03a 	cmpne	r2,r2,zero
 d033aa8:	1000dc1e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 d033aac:	008341b4 	movhi	r2,3334
 d033ab0:	10845c04 	addi	r2,r2,4464
 d033ab4:	10800417 	ldw	r2,16(r2)
 d033ab8:	10c00044 	addi	r3,r2,1
 d033abc:	008341b4 	movhi	r2,3334
 d033ac0:	10845c04 	addi	r2,r2,4464
 d033ac4:	10c00415 	stw	r3,16(r2)
      break;
 d033ac8:	0000d406 	br	d033e1c <tcp_usrreq+0x6e4>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 d033acc:	008017c4 	movi	r2,95
 d033ad0:	e0bff915 	stw	r2,-28(fp)
      break;
 d033ad4:	0000d106 	br	d033e1c <tcp_usrreq+0x6e4>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 d033ad8:	e13ffa17 	ldw	r4,-24(fp)
 d033adc:	d033f700 	call	d033f70 <tcp_disconnect>
      break;
 d033ae0:	0000ce06 	br	d033e1c <tcp_usrreq+0x6e4>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 d033ae4:	e0bffe17 	ldw	r2,-8(fp)
 d033ae8:	10800317 	ldw	r2,12(r2)
 d033aec:	e0bff715 	stw	r2,-36(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 d033af0:	e0bffc17 	ldw	r2,-16(fp)
 d033af4:	10800517 	ldw	r2,20(r2)
 d033af8:	10800098 	cmpnei	r2,r2,2
 d033afc:	10000e1e 	bne	r2,zero,d033b38 <tcp_usrreq+0x400>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 d033b00:	e0fffe17 	ldw	r3,-8(fp)
 d033b04:	00800404 	movi	r2,16
 d033b08:	18800215 	stw	r2,8(r3)
            sin->sin_family = AF_INET;
 d033b0c:	e0fff717 	ldw	r3,-36(fp)
 d033b10:	00800084 	movi	r2,2
 d033b14:	1880000d 	sth	r2,0(r3)
            sin->sin_port = inp->inp_fport;
 d033b18:	e0bffb17 	ldw	r2,-20(fp)
 d033b1c:	10c0070b 	ldhu	r3,28(r2)
 d033b20:	e0bff717 	ldw	r2,-36(fp)
 d033b24:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 d033b28:	e0bffb17 	ldw	r2,-20(fp)
 d033b2c:	10c00317 	ldw	r3,12(r2)
 d033b30:	e0bff717 	ldw	r2,-36(fp)
 d033b34:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 d033b38:	e0bffc17 	ldw	r2,-16(fp)
 d033b3c:	10800517 	ldw	r2,20(r2)
 d033b40:	108000a0 	cmpeqi	r2,r2,2
 d033b44:	10000a1e 	bne	r2,zero,d033b70 <tcp_usrreq+0x438>
 d033b48:	e0bffc17 	ldw	r2,-16(fp)
 d033b4c:	10800517 	ldw	r2,20(r2)
 d033b50:	108000e0 	cmpeqi	r2,r2,3
 d033b54:	1000061e 	bne	r2,zero,d033b70 <tcp_usrreq+0x438>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 d033b58:	e0bffc17 	ldw	r2,-16(fp)
 d033b5c:	11400517 	ldw	r5,20(r2)
 d033b60:	01034174 	movhi	r4,3333
 d033b64:	213ec704 	addi	r4,r4,-1252
 d033b68:	d0028a00 	call	d0028a0 <printf>
            dtrap();
 d033b6c:	d025a500 	call	d025a50 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 d033b70:	008341b4 	movhi	r2,3334
 d033b74:	10845c04 	addi	r2,r2,4464
 d033b78:	10800517 	ldw	r2,20(r2)
 d033b7c:	10c00044 	addi	r3,r2,1
 d033b80:	008341b4 	movhi	r2,3334
 d033b84:	10845c04 	addi	r2,r2,4464
 d033b88:	10c00515 	stw	r3,20(r2)
         break;
 d033b8c:	0000a306 	br	d033e1c <tcp_usrreq+0x6e4>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 d033b90:	e13ffc17 	ldw	r4,-16(fp)
 d033b94:	d02ccbc0 	call	d02ccbc <socantsendmore>
      tp = tcp_usrclosed(tp);
 d033b98:	e13ffa17 	ldw	r4,-24(fp)
 d033b9c:	d0340440 	call	d034044 <tcp_usrclosed>
 d033ba0:	e0bffa15 	stw	r2,-24(fp)
      if (tp)
 d033ba4:	e0bffa17 	ldw	r2,-24(fp)
 d033ba8:	1005003a 	cmpeq	r2,r2,zero
 d033bac:	10009b1e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         error = tcp_output(tp);
 d033bb0:	e13ffa17 	ldw	r4,-24(fp)
 d033bb4:	d0312480 	call	d031248 <tcp_output>
 d033bb8:	e0bff915 	stw	r2,-28(fp)
      break;
 d033bbc:	00009706 	br	d033e1c <tcp_usrreq+0x6e4>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 d033bc0:	e13ffa17 	ldw	r4,-24(fp)
 d033bc4:	d0312480 	call	d031248 <tcp_output>
      break;
 d033bc8:	00009406 	br	d033e1c <tcp_usrreq+0x6e4>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 d033bcc:	e0bffc17 	ldw	r2,-16(fp)
 d033bd0:	10800117 	ldw	r2,4(r2)
 d033bd4:	1004c03a 	cmpne	r2,r2,zero
 d033bd8:	1000031e 	bne	r2,zero,d033be8 <tcp_usrreq+0x4b0>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 d033bdc:	00800804 	movi	r2,32
 d033be0:	e0bff915 	stw	r2,-28(fp)
         break;
 d033be4:	00008d06 	br	d033e1c <tcp_usrreq+0x6e4>
      }
      sbappend(&so->so_snd, m);
 d033be8:	e0bffc17 	ldw	r2,-16(fp)
 d033bec:	11001204 	addi	r4,r2,72
 d033bf0:	e17ffd17 	ldw	r5,-12(fp)
 d033bf4:	d02cfc00 	call	d02cfc0 <sbappend>
      error = tcp_output(tp);
 d033bf8:	e13ffa17 	ldw	r4,-24(fp)
 d033bfc:	d0312480 	call	d031248 <tcp_output>
 d033c00:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 d033c04:	e0bff917 	ldw	r2,-28(fp)
 d033c08:	10801a58 	cmpnei	r2,r2,105
 d033c0c:	1000831e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 d033c10:	e0bffc17 	ldw	r2,-16(fp)
 d033c14:	11001204 	addi	r4,r2,72
 d033c18:	e17ffd17 	ldw	r5,-12(fp)
 d033c1c:	d02d7980 	call	d02d798 <sbdropend>
      break;
 d033c20:	00007e06 	br	d033e1c <tcp_usrreq+0x6e4>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 d033c24:	e13ffa17 	ldw	r4,-24(fp)
 d033c28:	01401c44 	movi	r5,113
 d033c2c:	d032cc80 	call	d032cc8 <tcp_drop>
      break;
 d033c30:	00007a06 	br	d033e1c <tcp_usrreq+0x6e4>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 d033c34:	d025a500 	call	d025a50 <dtrap>
      return (0);
 d033c38:	e03fff15 	stw	zero,-4(fp)
 d033c3c:	00007906 	br	d033e24 <tcp_usrreq+0x6ec>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 d033c40:	e0bffc17 	ldw	r2,-16(fp)
 d033c44:	10801a17 	ldw	r2,104(r2)
 d033c48:	1004c03a 	cmpne	r2,r2,zero
 d033c4c:	1000061e 	bne	r2,zero,d033c68 <tcp_usrreq+0x530>
 d033c50:	e0bffc17 	ldw	r2,-16(fp)
 d033c54:	1080088b 	ldhu	r2,34(r2)
 d033c58:	10bfffcc 	andi	r2,r2,65535
 d033c5c:	1080100c 	andi	r2,r2,64
 d033c60:	1005003a 	cmpeq	r2,r2,zero
 d033c64:	10000b1e 	bne	r2,zero,d033c94 <tcp_usrreq+0x55c>
 d033c68:	e0bffc17 	ldw	r2,-16(fp)
 d033c6c:	10800417 	ldw	r2,16(r2)
 d033c70:	1080400c 	andi	r2,r2,256
 d033c74:	1004c03a 	cmpne	r2,r2,zero
 d033c78:	1000061e 	bne	r2,zero,d033c94 <tcp_usrreq+0x55c>
 d033c7c:	e0bffa17 	ldw	r2,-24(fp)
 d033c80:	10802403 	ldbu	r2,144(r2)
 d033c84:	10803fcc 	andi	r2,r2,255
 d033c88:	1080008c 	andi	r2,r2,2
 d033c8c:	1005003a 	cmpeq	r2,r2,zero
 d033c90:	1000031e 	bne	r2,zero,d033ca0 <tcp_usrreq+0x568>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 d033c94:	00800584 	movi	r2,22
 d033c98:	e0bff915 	stw	r2,-28(fp)
         break;
 d033c9c:	00005f06 	br	d033e1c <tcp_usrreq+0x6e4>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 d033ca0:	e0bffa17 	ldw	r2,-24(fp)
 d033ca4:	10802403 	ldbu	r2,144(r2)
 d033ca8:	10803fcc 	andi	r2,r2,255
 d033cac:	1080004c 	andi	r2,r2,1
 d033cb0:	1004c03a 	cmpne	r2,r2,zero
 d033cb4:	1000031e 	bne	r2,zero,d033cc4 <tcp_usrreq+0x58c>
      {
         error = EWOULDBLOCK;
 d033cb8:	008002c4 	movi	r2,11
 d033cbc:	e0bff915 	stw	r2,-28(fp)
         break;
 d033cc0:	00005606 	br	d033e1c <tcp_usrreq+0x6e4>
      }
      m->m_len = 1;
 d033cc4:	e0fffd17 	ldw	r3,-12(fp)
 d033cc8:	00800044 	movi	r2,1
 d033ccc:	18800215 	stw	r2,8(r3)
      *mtod(m, char *) = tp->t_iobc;
 d033cd0:	e0bffd17 	ldw	r2,-12(fp)
 d033cd4:	10c00317 	ldw	r3,12(r2)
 d033cd8:	e0bffa17 	ldw	r2,-24(fp)
 d033cdc:	10802443 	ldbu	r2,145(r2)
 d033ce0:	18800005 	stb	r2,0(r3)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 d033ce4:	e0bffe17 	ldw	r2,-8(fp)
 d033ce8:	1080008c 	andi	r2,r2,2
 d033cec:	1004c03a 	cmpne	r2,r2,zero
 d033cf0:	10004a1e 	bne	r2,zero,d033e1c <tcp_usrreq+0x6e4>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 d033cf4:	e0bffa17 	ldw	r2,-24(fp)
 d033cf8:	10802403 	ldbu	r2,144(r2)
 d033cfc:	108000dc 	xori	r2,r2,3
 d033d00:	1007883a 	mov	r3,r2
 d033d04:	e0bffa17 	ldw	r2,-24(fp)
 d033d08:	10c02405 	stb	r3,144(r2)
      break;
 d033d0c:	00004306 	br	d033e1c <tcp_usrreq+0x6e4>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 d033d10:	e0bffc17 	ldw	r2,-16(fp)
 d033d14:	10800117 	ldw	r2,4(r2)
 d033d18:	1004c03a 	cmpne	r2,r2,zero
 d033d1c:	1000031e 	bne	r2,zero,d033d2c <tcp_usrreq+0x5f4>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 d033d20:	00800804 	movi	r2,32
 d033d24:	e0bff915 	stw	r2,-28(fp)
         break;
 d033d28:	00003c06 	br	d033e1c <tcp_usrreq+0x6e4>
      }
      if (sbspace(&so->so_snd) == 0) 
 d033d2c:	e0bffc17 	ldw	r2,-16(fp)
 d033d30:	10801317 	ldw	r2,76(r2)
 d033d34:	1007883a 	mov	r3,r2
 d033d38:	e0bffc17 	ldw	r2,-16(fp)
 d033d3c:	10801217 	ldw	r2,72(r2)
 d033d40:	1885c83a 	sub	r2,r3,r2
 d033d44:	1004803a 	cmplt	r2,r2,zero
 d033d48:	1000051e 	bne	r2,zero,d033d60 <tcp_usrreq+0x628>
 d033d4c:	e0bffc17 	ldw	r2,-16(fp)
 d033d50:	10c01317 	ldw	r3,76(r2)
 d033d54:	e0bffc17 	ldw	r2,-16(fp)
 d033d58:	10801217 	ldw	r2,72(r2)
 d033d5c:	1880051e 	bne	r3,r2,d033d74 <tcp_usrreq+0x63c>
      {
         m_freem(m);
 d033d60:	e13ffd17 	ldw	r4,-12(fp)
 d033d64:	d026b500 	call	d026b50 <m_freem>
         error = ENOBUFS;
 d033d68:	00801a44 	movi	r2,105
 d033d6c:	e0bff915 	stw	r2,-28(fp)
         break;
 d033d70:	00002a06 	br	d033e1c <tcp_usrreq+0x6e4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 d033d74:	e0bffc17 	ldw	r2,-16(fp)
 d033d78:	11001204 	addi	r4,r2,72
 d033d7c:	e17ffd17 	ldw	r5,-12(fp)
 d033d80:	d02cfc00 	call	d02cfc0 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 d033d84:	e0bffa17 	ldw	r2,-24(fp)
 d033d88:	10c00e17 	ldw	r3,56(r2)
 d033d8c:	e0bffc17 	ldw	r2,-16(fp)
 d033d90:	10801217 	ldw	r2,72(r2)
 d033d94:	1887883a 	add	r3,r3,r2
 d033d98:	e0bffa17 	ldw	r2,-24(fp)
 d033d9c:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 d033da0:	e0fffa17 	ldw	r3,-24(fp)
 d033da4:	00800044 	movi	r2,1
 d033da8:	18800a85 	stb	r2,42(r3)
      error = tcp_output(tp);
 d033dac:	e13ffa17 	ldw	r4,-24(fp)
 d033db0:	d0312480 	call	d031248 <tcp_output>
 d033db4:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 d033db8:	e0bff917 	ldw	r2,-28(fp)
 d033dbc:	10801a58 	cmpnei	r2,r2,105
 d033dc0:	1000041e 	bne	r2,zero,d033dd4 <tcp_usrreq+0x69c>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 d033dc4:	e0bffc17 	ldw	r2,-16(fp)
 d033dc8:	11001204 	addi	r4,r2,72
 d033dcc:	e17ffd17 	ldw	r5,-12(fp)
 d033dd0:	d02d7980 	call	d02d798 <sbdropend>
      tp->t_force = 0;
 d033dd4:	e0bffa17 	ldw	r2,-24(fp)
 d033dd8:	10000a85 	stb	zero,42(r2)
      break;
 d033ddc:	00000f06 	br	d033e1c <tcp_usrreq+0x6e4>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 d033de0:	e13ffb17 	ldw	r4,-20(fp)
 d033de4:	e17ffe17 	ldw	r5,-8(fp)
 d033de8:	d0486dc0 	call	d0486dc <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 d033dec:	00000b06 	br	d033e1c <tcp_usrreq+0x6e4>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 d033df0:	e13ffb17 	ldw	r4,-20(fp)
 d033df4:	e17ffe17 	ldw	r5,-8(fp)
 d033df8:	d0487580 	call	d048758 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 d033dfc:	00000706 	br	d033e1c <tcp_usrreq+0x6e4>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 d033e00:	e17ffe17 	ldw	r5,-8(fp)
 d033e04:	e13ffa17 	ldw	r4,-24(fp)
 d033e08:	d03329c0 	call	d03329c <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 d033e0c:	00000306 	br	d033e1c <tcp_usrreq+0x6e4>

      default:
      panic("tcp_usrreq");
 d033e10:	01034174 	movhi	r4,3333
 d033e14:	213ecf04 	addi	r4,r4,-1220
 d033e18:	d02093c0 	call	d02093c <panic>
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 d033e1c:	e0bff917 	ldw	r2,-28(fp)
 d033e20:	e0bfff15 	stw	r2,-4(fp)
 d033e24:	e0bfff17 	ldw	r2,-4(fp)
}
 d033e28:	e037883a 	mov	sp,fp
 d033e2c:	dfc00117 	ldw	ra,4(sp)
 d033e30:	df000017 	ldw	fp,0(sp)
 d033e34:	dec00204 	addi	sp,sp,8
 d033e38:	f800283a 	ret

0d033e3c <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 d033e3c:	defff804 	addi	sp,sp,-32
 d033e40:	dfc00715 	stw	ra,28(sp)
 d033e44:	df000615 	stw	fp,24(sp)
 d033e48:	df000604 	addi	fp,sp,24
 d033e4c:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 d033e50:	e0bffe17 	ldw	r2,-8(fp)
 d033e54:	10801317 	ldw	r2,76(r2)
 d033e58:	1005003a 	cmpeq	r2,r2,zero
 d033e5c:	1000041e 	bne	r2,zero,d033e70 <tcp_attach+0x34>
 d033e60:	e0bffe17 	ldw	r2,-8(fp)
 d033e64:	10800b17 	ldw	r2,44(r2)
 d033e68:	1004c03a 	cmpne	r2,r2,zero
 d033e6c:	10000b1e 	bne	r2,zero,d033e9c <tcp_attach+0x60>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 d033e70:	d1603f17 	ldw	r5,-32516(gp)
 d033e74:	d1a04017 	ldw	r6,-32512(gp)
 d033e78:	e13ffe17 	ldw	r4,-8(fp)
 d033e7c:	d02ce980 	call	d02ce98 <soreserve>
 d033e80:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 d033e84:	e0bffb17 	ldw	r2,-20(fp)
 d033e88:	1005003a 	cmpeq	r2,r2,zero
 d033e8c:	1000031e 	bne	r2,zero,d033e9c <tcp_attach+0x60>
         return (error);
 d033e90:	e0bffb17 	ldw	r2,-20(fp)
 d033e94:	e0bfff15 	stw	r2,-4(fp)
 d033e98:	00002f06 	br	d033f58 <tcp_attach+0x11c>
   }
   error = in_pcballoc(so, &tcb);
 d033e9c:	e13ffe17 	ldw	r4,-8(fp)
 d033ea0:	014341b4 	movhi	r5,3334
 d033ea4:	29447f04 	addi	r5,r5,4604
 d033ea8:	d0481300 	call	d048130 <in_pcballoc>
 d033eac:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 d033eb0:	e0bffb17 	ldw	r2,-20(fp)
 d033eb4:	1005003a 	cmpeq	r2,r2,zero
 d033eb8:	1000031e 	bne	r2,zero,d033ec8 <tcp_attach+0x8c>
      return (error);
 d033ebc:	e0bffb17 	ldw	r2,-20(fp)
 d033ec0:	e0bfff15 	stw	r2,-4(fp)
 d033ec4:	00002406 	br	d033f58 <tcp_attach+0x11c>
   inp = sotoinpcb(so);
 d033ec8:	e0bffe17 	ldw	r2,-8(fp)
 d033ecc:	10800117 	ldw	r2,4(r2)
 d033ed0:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 d033ed4:	e13ffc17 	ldw	r4,-16(fp)
 d033ed8:	d032bb00 	call	d032bb0 <tcp_newtcpcb>
 d033edc:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 d033ee0:	e0bffd17 	ldw	r2,-12(fp)
 d033ee4:	1004c03a 	cmpne	r2,r2,zero
 d033ee8:	1000181e 	bne	r2,zero,d033f4c <tcp_attach+0x110>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 d033eec:	e0bffe17 	ldw	r2,-8(fp)
 d033ef0:	1080088b 	ldhu	r2,34(r2)
 d033ef4:	10bfffcc 	andi	r2,r2,65535
 d033ef8:	1080004c 	andi	r2,r2,1
 d033efc:	e0bffa15 	stw	r2,-24(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 d033f00:	e0bffe17 	ldw	r2,-8(fp)
 d033f04:	10c0088b 	ldhu	r3,34(r2)
 d033f08:	00bfff84 	movi	r2,-2
 d033f0c:	1884703a 	and	r2,r3,r2
 d033f10:	1007883a 	mov	r3,r2
 d033f14:	e0bffe17 	ldw	r2,-8(fp)
 d033f18:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 d033f1c:	e13ffc17 	ldw	r4,-16(fp)
 d033f20:	d0481c40 	call	d0481c4 <in_pcbdetach>
      so->so_state |= nofd;
 d033f24:	e0bffe17 	ldw	r2,-8(fp)
 d033f28:	10c0088b 	ldhu	r3,34(r2)
 d033f2c:	e0bffa17 	ldw	r2,-24(fp)
 d033f30:	1884b03a 	or	r2,r3,r2
 d033f34:	1007883a 	mov	r3,r2
 d033f38:	e0bffe17 	ldw	r2,-8(fp)
 d033f3c:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 d033f40:	00801a44 	movi	r2,105
 d033f44:	e0bfff15 	stw	r2,-4(fp)
 d033f48:	00000306 	br	d033f58 <tcp_attach+0x11c>
   }
   tp->t_state = TCPS_CLOSED;
 d033f4c:	e0bffd17 	ldw	r2,-12(fp)
 d033f50:	10000215 	stw	zero,8(r2)
   return (0);
 d033f54:	e03fff15 	stw	zero,-4(fp)
 d033f58:	e0bfff17 	ldw	r2,-4(fp)
}
 d033f5c:	e037883a 	mov	sp,fp
 d033f60:	dfc00117 	ldw	ra,4(sp)
 d033f64:	df000017 	ldw	fp,0(sp)
 d033f68:	dec00204 	addi	sp,sp,8
 d033f6c:	f800283a 	ret

0d033f70 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 d033f70:	defffc04 	addi	sp,sp,-16
 d033f74:	dfc00315 	stw	ra,12(sp)
 d033f78:	df000215 	stw	fp,8(sp)
 d033f7c:	df000204 	addi	fp,sp,8
 d033f80:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d033f84:	e0bfff17 	ldw	r2,-4(fp)
 d033f88:	10800d17 	ldw	r2,52(r2)
 d033f8c:	10800817 	ldw	r2,32(r2)
 d033f90:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 d033f94:	e0bfff17 	ldw	r2,-4(fp)
 d033f98:	10800217 	ldw	r2,8(r2)
 d033f9c:	10800108 	cmpgei	r2,r2,4
 d033fa0:	1000041e 	bne	r2,zero,d033fb4 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 d033fa4:	e13fff17 	ldw	r4,-4(fp)
 d033fa8:	d032d740 	call	d032d74 <tcp_close>
 d033fac:	e0bfff15 	stw	r2,-4(fp)
 d033fb0:	00001e06 	br	d03402c <tcp_disconnect+0xbc>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 d033fb4:	e0bffe17 	ldw	r2,-8(fp)
 d033fb8:	10800417 	ldw	r2,16(r2)
 d033fbc:	1080200c 	andi	r2,r2,128
 d033fc0:	1005003a 	cmpeq	r2,r2,zero
 d033fc4:	10000c1e 	bne	r2,zero,d033ff8 <tcp_disconnect+0x88>
 d033fc8:	e0bffe17 	ldw	r2,-8(fp)
 d033fcc:	1080080b 	ldhu	r2,32(r2)
 d033fd0:	10bfffcc 	andi	r2,r2,65535
 d033fd4:	10a0001c 	xori	r2,r2,32768
 d033fd8:	10a00004 	addi	r2,r2,-32768
 d033fdc:	1004c03a 	cmpne	r2,r2,zero
 d033fe0:	1000051e 	bne	r2,zero,d033ff8 <tcp_disconnect+0x88>
      tp = tcp_drop(tp, 0);
 d033fe4:	e13fff17 	ldw	r4,-4(fp)
 d033fe8:	000b883a 	mov	r5,zero
 d033fec:	d032cc80 	call	d032cc8 <tcp_drop>
 d033ff0:	e0bfff15 	stw	r2,-4(fp)
{
   struct socket *   so =  tp->t_inpcb->inp_socket;

   if (tp->t_state < TCPS_ESTABLISHED)
      tp = tcp_close(tp);
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 d033ff4:	00000d06 	br	d03402c <tcp_disconnect+0xbc>
      tp = tcp_drop(tp, 0);
   else 
   {
      soisdisconnecting(so);
 d033ff8:	e13ffe17 	ldw	r4,-8(fp)
 d033ffc:	d02c78c0 	call	d02c78c <soisdisconnecting>
      sbflush(&so->so_rcv);
 d034000:	e0bffe17 	ldw	r2,-8(fp)
 d034004:	11000a04 	addi	r4,r2,40
 d034008:	d02d5380 	call	d02d538 <sbflush>
      tp = tcp_usrclosed(tp);
 d03400c:	e13fff17 	ldw	r4,-4(fp)
 d034010:	d0340440 	call	d034044 <tcp_usrclosed>
 d034014:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 d034018:	e0bfff17 	ldw	r2,-4(fp)
 d03401c:	1005003a 	cmpeq	r2,r2,zero
 d034020:	1000021e 	bne	r2,zero,d03402c <tcp_disconnect+0xbc>
         (void) tcp_output(tp);
 d034024:	e13fff17 	ldw	r4,-4(fp)
 d034028:	d0312480 	call	d031248 <tcp_output>
   }
   return (tp);
 d03402c:	e0bfff17 	ldw	r2,-4(fp)
}
 d034030:	e037883a 	mov	sp,fp
 d034034:	dfc00117 	ldw	ra,4(sp)
 d034038:	df000017 	ldw	fp,0(sp)
 d03403c:	dec00204 	addi	sp,sp,8
 d034040:	f800283a 	ret

0d034044 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 d034044:	defffc04 	addi	sp,sp,-16
 d034048:	dfc00315 	stw	ra,12(sp)
 d03404c:	df000215 	stw	fp,8(sp)
 d034050:	df000204 	addi	fp,sp,8
 d034054:	e13ffe15 	stw	r4,-8(fp)

   switch (tp->t_state) 
 d034058:	e0bffe17 	ldw	r2,-8(fp)
 d03405c:	10800217 	ldw	r2,8(r2)
 d034060:	e0bfff15 	stw	r2,-4(fp)
 d034064:	e0ffff17 	ldw	r3,-4(fp)
 d034068:	188001a8 	cmpgeui	r2,r3,6
 d03406c:	10001c1e 	bne	r2,zero,d0340e0 <tcp_usrclosed+0x9c>
 d034070:	e13fff17 	ldw	r4,-4(fp)
 d034074:	e13fff17 	ldw	r4,-4(fp)
 d034078:	2105883a 	add	r2,r4,r4
 d03407c:	1087883a 	add	r3,r2,r2
 d034080:	008340f4 	movhi	r2,3331
 d034084:	10902504 	addi	r2,r2,16532
 d034088:	1885883a 	add	r2,r3,r2
 d03408c:	10800017 	ldw	r2,0(r2)
 d034090:	1000683a 	jmp	r2
 d034094:	0d0340ac 	andhi	r20,at,3330
 d034098:	0d0340ac 	andhi	r20,at,3330
 d03409c:	0d0340ac 	andhi	r20,at,3330
 d0340a0:	0d0340c4 	addi	r20,at,3331
 d0340a4:	0d0340c4 	addi	r20,at,3331
 d0340a8:	0d0340d4 	ori	r20,at,3331
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 d0340ac:	e0bffe17 	ldw	r2,-8(fp)
 d0340b0:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 d0340b4:	e13ffe17 	ldw	r4,-8(fp)
 d0340b8:	d032d740 	call	d032d74 <tcp_close>
 d0340bc:	e0bffe15 	stw	r2,-8(fp)
      break;
 d0340c0:	00000706 	br	d0340e0 <tcp_usrclosed+0x9c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 d0340c4:	e0fffe17 	ldw	r3,-8(fp)
 d0340c8:	00800184 	movi	r2,6
 d0340cc:	18800215 	stw	r2,8(r3)
      break;
 d0340d0:	00000306 	br	d0340e0 <tcp_usrclosed+0x9c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 d0340d4:	e0fffe17 	ldw	r3,-8(fp)
 d0340d8:	00800204 	movi	r2,8
 d0340dc:	18800215 	stw	r2,8(r3)
      break;
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 d0340e0:	e0bffe17 	ldw	r2,-8(fp)
 d0340e4:	1005003a 	cmpeq	r2,r2,zero
 d0340e8:	1000081e 	bne	r2,zero,d03410c <tcp_usrclosed+0xc8>
 d0340ec:	e0bffe17 	ldw	r2,-8(fp)
 d0340f0:	10800217 	ldw	r2,8(r2)
 d0340f4:	10800250 	cmplti	r2,r2,9
 d0340f8:	1000041e 	bne	r2,zero,d03410c <tcp_usrclosed+0xc8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 d0340fc:	e0bffe17 	ldw	r2,-8(fp)
 d034100:	10800d17 	ldw	r2,52(r2)
 d034104:	11000817 	ldw	r4,32(r2)
 d034108:	d02c8180 	call	d02c818 <soisdisconnected>
   return (tp);
 d03410c:	e0bffe17 	ldw	r2,-8(fp)
}
 d034110:	e037883a 	mov	sp,fp
 d034114:	dfc00117 	ldw	ra,4(sp)
 d034118:	df000017 	ldw	fp,0(sp)
 d03411c:	dec00204 	addi	sp,sp,8
 d034120:	f800283a 	ret

0d034124 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 d034124:	defffc04 	addi	sp,sp,-16
 d034128:	dfc00315 	stw	ra,12(sp)
 d03412c:	df000215 	stw	fp,8(sp)
 d034130:	df000204 	addi	fp,sp,8
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 d034134:	d0272740 	call	d027274 <nptcp_init>
 d034138:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d03413c:	e0bffe17 	ldw	r2,-8(fp)
 d034140:	1005003a 	cmpeq	r2,r2,zero
 d034144:	1000031e 	bne	r2,zero,d034154 <tcpinit+0x30>
      return e;
 d034148:	e0bffe17 	ldw	r2,-8(fp)
 d03414c:	e0bfff15 	stw	r2,-4(fp)
 d034150:	00000106 	br	d034158 <tcpinit+0x34>

   return 0;   /* good return */
 d034154:	e03fff15 	stw	zero,-4(fp)
 d034158:	e0bfff17 	ldw	r2,-4(fp)
}
 d03415c:	e037883a 	mov	sp,fp
 d034160:	dfc00117 	ldw	ra,4(sp)
 d034164:	df000017 	ldw	fp,0(sp)
 d034168:	dec00204 	addi	sp,sp,8
 d03416c:	f800283a 	ret

0d034170 <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 d034170:	defffc04 	addi	sp,sp,-16
 d034174:	df000315 	stw	fp,12(sp)
 d034178:	df000304 	addi	fp,sp,12
 d03417c:	e13ffe15 	stw	r4,-8(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d034180:	00834174 	movhi	r2,3333
 d034184:	109b3904 	addi	r2,r2,27876
 d034188:	10800017 	ldw	r2,0(r2)
 d03418c:	e0bffd15 	stw	r2,-12(fp)
 d034190:	00000a06 	br	d0341bc <udp_lookup+0x4c>
      if (tmp->u_data == (void*)so)
 d034194:	e0bffd17 	ldw	r2,-12(fp)
 d034198:	10c00617 	ldw	r3,24(r2)
 d03419c:	e0bffe17 	ldw	r2,-8(fp)
 d0341a0:	1880031e 	bne	r3,r2,d0341b0 <udp_lookup+0x40>
      return (tmp);
 d0341a4:	e0bffd17 	ldw	r2,-12(fp)
 d0341a8:	e0bfff15 	stw	r2,-4(fp)
 d0341ac:	00000706 	br	d0341cc <udp_lookup+0x5c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d0341b0:	e0bffd17 	ldw	r2,-12(fp)
 d0341b4:	10800017 	ldw	r2,0(r2)
 d0341b8:	e0bffd15 	stw	r2,-12(fp)
 d0341bc:	e0bffd17 	ldw	r2,-12(fp)
 d0341c0:	1004c03a 	cmpne	r2,r2,zero
 d0341c4:	103ff31e 	bne	r2,zero,d034194 <udp_lookup+0x24>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 d0341c8:	e03fff15 	stw	zero,-4(fp)
 d0341cc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0341d0:	e037883a 	mov	sp,fp
 d0341d4:	df000017 	ldw	fp,0(sp)
 d0341d8:	dec00104 	addi	sp,sp,4
 d0341dc:	f800283a 	ret

0d0341e0 <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 d0341e0:	defff404 	addi	sp,sp,-48
 d0341e4:	dfc00b15 	stw	ra,44(sp)
 d0341e8:	df000a15 	stw	fp,40(sp)
 d0341ec:	df000a04 	addi	fp,sp,40
 d0341f0:	e13ffd15 	stw	r4,-12(fp)
 d0341f4:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 d0341f8:	e0bffe17 	ldw	r2,-8(fp)
 d0341fc:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 d034200:	0009883a 	mov	r4,zero
 d034204:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 d034208:	e0bff717 	ldw	r2,-36(fp)
 d03420c:	10c00a17 	ldw	r3,40(r2)
 d034210:	e0bffd17 	ldw	r2,-12(fp)
 d034214:	10800417 	ldw	r2,16(r2)
 d034218:	1887883a 	add	r3,r3,r2
 d03421c:	e0bff717 	ldw	r2,-36(fp)
 d034220:	10800b17 	ldw	r2,44(r2)
 d034224:	18800536 	bltu	r3,r2,d03423c <udp_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d034228:	0009883a 	mov	r4,zero
 d03422c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d034230:	00801a44 	movi	r2,105
 d034234:	e0bfff15 	stw	r2,-4(fp)
 d034238:	00005106 	br	d034380 <udp_soinput+0x1a0>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 d03423c:	01000044 	movi	r4,1
 d034240:	000b883a 	mov	r5,zero
 d034244:	d0268740 	call	d026874 <m_getnbuf>
 d034248:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 d03424c:	e0bff817 	ldw	r2,-32(fp)
 d034250:	1004c03a 	cmpne	r2,r2,zero
 d034254:	1000051e 	bne	r2,zero,d03426c <udp_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d034258:	0009883a 	mov	r4,zero
 d03425c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d034260:	00801a44 	movi	r2,105
 d034264:	e0bfff15 	stw	r2,-4(fp)
 d034268:	00004506 	br	d034380 <udp_soinput+0x1a0>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 d03426c:	e0fff817 	ldw	r3,-32(fp)
 d034270:	e0bffd17 	ldw	r2,-12(fp)
 d034274:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 d034278:	e0bffd17 	ldw	r2,-12(fp)
 d03427c:	10c00317 	ldw	r3,12(r2)
 d034280:	e0bff817 	ldw	r2,-32(fp)
 d034284:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 d034288:	e0bffd17 	ldw	r2,-12(fp)
 d03428c:	10c00417 	ldw	r3,16(r2)
 d034290:	e0bff817 	ldw	r2,-32(fp)
 d034294:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 d034298:	e0bffd17 	ldw	r2,-12(fp)
 d03429c:	10c00117 	ldw	r3,4(r2)
 d0342a0:	e0bff817 	ldw	r2,-32(fp)
 d0342a4:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 d0342a8:	e0bffd17 	ldw	r2,-12(fp)
 d0342ac:	10c00217 	ldw	r3,8(r2)
 d0342b0:	e0bff817 	ldw	r2,-32(fp)
 d0342b4:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 d0342b8:	e0bffd17 	ldw	r2,-12(fp)
 d0342bc:	10800717 	ldw	r2,28(r2)
 d0342c0:	e0bffa15 	stw	r2,-24(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 d0342c4:	e0bffd17 	ldw	r2,-12(fp)
 d0342c8:	10800317 	ldw	r2,12(r2)
 d0342cc:	10bffe04 	addi	r2,r2,-8
 d0342d0:	e0bff615 	stw	r2,-40(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 d0342d4:	e0bff617 	ldw	r2,-40(fp)
 d0342d8:	1080000b 	ldhu	r2,0(r2)
 d0342dc:	10bfffcc 	andi	r2,r2,65535
 d0342e0:	1004d23a 	srli	r2,r2,8
 d0342e4:	10803fcc 	andi	r2,r2,255
 d0342e8:	1009883a 	mov	r4,r2
 d0342ec:	e0bff617 	ldw	r2,-40(fp)
 d0342f0:	1080000b 	ldhu	r2,0(r2)
 d0342f4:	10bfffcc 	andi	r2,r2,65535
 d0342f8:	1004923a 	slli	r2,r2,8
 d0342fc:	1007883a 	mov	r3,r2
 d034300:	00bfc004 	movi	r2,-256
 d034304:	1884703a 	and	r2,r3,r2
 d034308:	2084b03a 	or	r2,r4,r2
 d03430c:	e0bff98d 	sth	r2,-26(fp)
   sin.sin_family = AF_INET;
 d034310:	00800084 	movi	r2,2
 d034314:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 d034318:	e0bff717 	ldw	r2,-36(fp)
 d03431c:	11000a04 	addi	r4,r2,40
 d034320:	e17ff904 	addi	r5,fp,-28
 d034324:	e1bff817 	ldw	r6,-32(fp)
 d034328:	d02d1480 	call	d02d148 <sbappendaddr>
 d03432c:	1004c03a 	cmpne	r2,r2,zero
 d034330:	1000091e 	bne	r2,zero,d034358 <udp_soinput+0x178>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 d034334:	e0bff817 	ldw	r2,-32(fp)
 d034338:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 d03433c:	e13ff817 	ldw	r4,-32(fp)
 d034340:	d026a1c0 	call	d026a1c <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d034344:	0009883a 	mov	r4,zero
 d034348:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d03434c:	00801a44 	movi	r2,105
 d034350:	e0bfff15 	stw	r2,-4(fp)
 d034354:	00000a06 	br	d034380 <udp_soinput+0x1a0>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 d034358:	e0bff717 	ldw	r2,-36(fp)
 d03435c:	11000a04 	addi	r4,r2,40
 d034360:	d02147c0 	call	d02147c <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 d034364:	e0bff717 	ldw	r2,-36(fp)
 d034368:	11400a04 	addi	r5,r2,40
 d03436c:	e13ff717 	ldw	r4,-36(fp)
 d034370:	d02cdfc0 	call	d02cdfc <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d034374:	0009883a 	mov	r4,zero
 d034378:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return 0;
 d03437c:	e03fff15 	stw	zero,-4(fp)
 d034380:	e0bfff17 	ldw	r2,-4(fp)
}
 d034384:	e037883a 	mov	sp,fp
 d034388:	dfc00117 	ldw	ra,4(sp)
 d03438c:	df000017 	ldw	fp,0(sp)
 d034390:	dec00204 	addi	sp,sp,8
 d034394:	f800283a 	ret

0d034398 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 d034398:	defff704 	addi	sp,sp,-36
 d03439c:	dfc00815 	stw	ra,32(sp)
 d0343a0:	df000715 	stw	fp,28(sp)
 d0343a4:	df000704 	addi	fp,sp,28
 d0343a8:	e13ffc15 	stw	r4,-16(fp)
 d0343ac:	e17ffd15 	stw	r5,-12(fp)
 d0343b0:	e1bffe15 	stw	r6,-8(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 d0343b4:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 d0343b8:	e0bffc17 	ldw	r2,-16(fp)
 d0343bc:	10800717 	ldw	r2,28(r2)
 d0343c0:	e0bffa15 	stw	r2,-24(fp)

   switch (req) 
 d0343c4:	e0bffa17 	ldw	r2,-24(fp)
 d0343c8:	10800468 	cmpgeui	r2,r2,17
 d0343cc:	10008b1e 	bne	r2,zero,d0345fc <udp_usrreq+0x264>
 d0343d0:	e0bffa17 	ldw	r2,-24(fp)
 d0343d4:	1085883a 	add	r2,r2,r2
 d0343d8:	1087883a 	add	r3,r2,r2
 d0343dc:	008340f4 	movhi	r2,3331
 d0343e0:	1090fc04 	addi	r2,r2,17392
 d0343e4:	1885883a 	add	r2,r3,r2
 d0343e8:	10800017 	ldw	r2,0(r2)
 d0343ec:	1000683a 	jmp	r2
 d0343f0:	0d034434 	orhi	r20,at,3344
 d0343f4:	0d0344bc 	xorhi	r20,at,3346
 d0343f8:	0d034500 	call	d03450 <__ram_exceptions_end+0xc83254>
 d0343fc:	0d0345fc 	xorhi	r20,at,3351
 d034400:	0d034500 	call	d03450 <__ram_exceptions_end+0xc83254>
 d034404:	0d0345fc 	xorhi	r20,at,3351
 d034408:	0d0345f0 	cmpltui	r20,at,3351
 d03440c:	0d0345fc 	xorhi	r20,at,3351
 d034410:	0d0345f0 	cmpltui	r20,at,3351
 d034414:	0d034550 	cmplti	r20,at,3349
 d034418:	0d0345fc 	xorhi	r20,at,3351
 d03441c:	0d0345fc 	xorhi	r20,at,3351
 d034420:	0d0345fc 	xorhi	r20,at,3351
 d034424:	0d0345fc 	xorhi	r20,at,3351
 d034428:	0d0345fc 	xorhi	r20,at,3351
 d03442c:	0d0345a0 	cmpeqi	r20,at,3350
 d034430:	0d0345a0 	cmpeqi	r20,at,3350
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 d034434:	d0454dc0 	call	d0454dc <udp_maxalloc>
 d034438:	1007883a 	mov	r3,r2
 d03443c:	e0bffc17 	ldw	r2,-16(fp)
 d034440:	10c01315 	stw	r3,76(r2)
 d034444:	e0bffc17 	ldw	r2,-16(fp)
 d034448:	10c01317 	ldw	r3,76(r2)
 d03444c:	e0bffc17 	ldw	r2,-16(fp)
 d034450:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 d034454:	e0bffc17 	ldw	r2,-16(fp)
 d034458:	10800517 	ldw	r2,20(r2)
 d03445c:	10800098 	cmpnei	r2,r2,2
 d034460:	10000e1e 	bne	r2,zero,d03449c <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 d034464:	0009883a 	mov	r4,zero
 d034468:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 d03446c:	d04534c0 	call	d04534c <udp_socket>
 d034470:	11bfffcc 	andi	r6,r2,65535
 d034474:	e0bffc17 	ldw	r2,-16(fp)
 d034478:	d8800015 	stw	r2,0(sp)
 d03447c:	0009883a 	mov	r4,zero
 d034480:	000b883a 	mov	r5,zero
 d034484:	01c340f4 	movhi	r7,3331
 d034488:	39d07804 	addi	r7,r7,16864
 d03448c:	d0255a00 	call	d0255a0 <udp_open>
 d034490:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 d034494:	0009883a 	mov	r4,zero
 d034498:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 d03449c:	e0bffb17 	ldw	r2,-20(fp)
 d0344a0:	1004c03a 	cmpne	r2,r2,zero
 d0344a4:	1000031e 	bne	r2,zero,d0344b4 <udp_usrreq+0x11c>
         return(EINVAL);
 d0344a8:	00800584 	movi	r2,22
 d0344ac:	e0bfff15 	stw	r2,-4(fp)
 d0344b0:	00005406 	br	d034604 <udp_usrreq+0x26c>
      return 0;
 d0344b4:	e03fff15 	stw	zero,-4(fp)
 d0344b8:	00005206 	br	d034604 <udp_usrreq+0x26c>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 d0344bc:	e13ffc17 	ldw	r4,-16(fp)
 d0344c0:	d0341700 	call	d034170 <udp_lookup>
 d0344c4:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 d0344c8:	e0bffb17 	ldw	r2,-20(fp)
 d0344cc:	1004c03a 	cmpne	r2,r2,zero
 d0344d0:	1000031e 	bne	r2,zero,d0344e0 <udp_usrreq+0x148>
         return(EINVAL);
 d0344d4:	00800584 	movi	r2,22
 d0344d8:	e0bfff15 	stw	r2,-4(fp)
 d0344dc:	00004906 	br	d034604 <udp_usrreq+0x26c>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d0344e0:	0009883a 	mov	r4,zero
 d0344e4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 d0344e8:	e13ffb17 	ldw	r4,-20(fp)
 d0344ec:	d0257d80 	call	d0257d8 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 d0344f0:	0009883a 	mov	r4,zero
 d0344f4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      return 0;
 d0344f8:	e03fff15 	stw	zero,-4(fp)
 d0344fc:	00004106 	br	d034604 <udp_usrreq+0x26c>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 d034500:	e0bffe17 	ldw	r2,-8(fp)
 d034504:	1004c03a 	cmpne	r2,r2,zero
 d034508:	1000031e 	bne	r2,zero,d034518 <udp_usrreq+0x180>
         return(EINVAL);
 d03450c:	00800584 	movi	r2,22
 d034510:	e0bfff15 	stw	r2,-4(fp)
 d034514:	00003b06 	br	d034604 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 d034518:	e0bffc17 	ldw	r2,-16(fp)
 d03451c:	10800517 	ldw	r2,20(r2)
 d034520:	10800098 	cmpnei	r2,r2,2
 d034524:	1000061e 	bne	r2,zero,d034540 <udp_usrreq+0x1a8>
        return udp4_sockbind(so, nam, req );
 d034528:	e13ffc17 	ldw	r4,-16(fp)
 d03452c:	e17ffe17 	ldw	r5,-8(fp)
 d034530:	e1bffa17 	ldw	r6,-24(fp)
 d034534:	d03461c0 	call	d03461c <udp4_sockbind>
 d034538:	e0bfff15 	stw	r2,-4(fp)
 d03453c:	00003106 	br	d034604 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 d034540:	d025a500 	call	d025a50 <dtrap>
      return EINVAL;
 d034544:	00800584 	movi	r2,22
 d034548:	e0bfff15 	stw	r2,-4(fp)
 d03454c:	00002d06 	br	d034604 <udp_usrreq+0x26c>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 d034550:	e0bffd17 	ldw	r2,-12(fp)
 d034554:	1004c03a 	cmpne	r2,r2,zero
 d034558:	1000031e 	bne	r2,zero,d034568 <udp_usrreq+0x1d0>
         return(EINVAL);
 d03455c:	00800584 	movi	r2,22
 d034560:	e0bfff15 	stw	r2,-4(fp)
 d034564:	00002706 	br	d034604 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 d034568:	e0bffc17 	ldw	r2,-16(fp)
 d03456c:	10800517 	ldw	r2,20(r2)
 d034570:	10800098 	cmpnei	r2,r2,2
 d034574:	1000061e 	bne	r2,zero,d034590 <udp_usrreq+0x1f8>
        return udp4_socksend(so, m, nam );
 d034578:	e13ffc17 	ldw	r4,-16(fp)
 d03457c:	e17ffd17 	ldw	r5,-12(fp)
 d034580:	e1bffe17 	ldw	r6,-8(fp)
 d034584:	d0349580 	call	d034958 <udp4_socksend>
 d034588:	e0bfff15 	stw	r2,-4(fp)
 d03458c:	00001d06 	br	d034604 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 d034590:	d025a500 	call	d025a50 <dtrap>
      return EINVAL;
 d034594:	00800584 	movi	r2,22
 d034598:	e0bfff15 	stw	r2,-4(fp)
 d03459c:	00001906 	br	d034604 <udp_usrreq+0x26c>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 d0345a0:	e0bffe17 	ldw	r2,-8(fp)
 d0345a4:	1004c03a 	cmpne	r2,r2,zero
 d0345a8:	1000031e 	bne	r2,zero,d0345b8 <udp_usrreq+0x220>
         return(EINVAL);
 d0345ac:	00800584 	movi	r2,22
 d0345b0:	e0bfff15 	stw	r2,-4(fp)
 d0345b4:	00001306 	br	d034604 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 d0345b8:	e0bffc17 	ldw	r2,-16(fp)
 d0345bc:	10800517 	ldw	r2,20(r2)
 d0345c0:	10800098 	cmpnei	r2,r2,2
 d0345c4:	1000061e 	bne	r2,zero,d0345e0 <udp_usrreq+0x248>
        return udp4_sockaddr(so, nam, req );
 d0345c8:	e13ffc17 	ldw	r4,-16(fp)
 d0345cc:	e17ffe17 	ldw	r5,-8(fp)
 d0345d0:	e1bffa17 	ldw	r6,-24(fp)
 d0345d4:	d034d340 	call	d034d34 <udp4_sockaddr>
 d0345d8:	e0bfff15 	stw	r2,-4(fp)
 d0345dc:	00000906 	br	d034604 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 d0345e0:	d025a500 	call	d025a50 <dtrap>
      return EINVAL;
 d0345e4:	00800584 	movi	r2,22
 d0345e8:	e0bfff15 	stw	r2,-4(fp)
 d0345ec:	00000506 	br	d034604 <udp_usrreq+0x26c>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 d0345f0:	d025a500 	call	d025a50 <dtrap>
      return 0;
 d0345f4:	e03fff15 	stw	zero,-4(fp)
 d0345f8:	00000206 	br	d034604 <udp_usrreq+0x26c>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 d0345fc:	008017c4 	movi	r2,95
 d034600:	e0bfff15 	stw	r2,-4(fp)
 d034604:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d034608:	e037883a 	mov	sp,fp
 d03460c:	dfc00117 	ldw	ra,4(sp)
 d034610:	df000017 	ldw	fp,0(sp)
 d034614:	dec00204 	addi	sp,sp,8
 d034618:	f800283a 	ret

0d03461c <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 d03461c:	defff304 	addi	sp,sp,-52
 d034620:	dfc00c15 	stw	ra,48(sp)
 d034624:	df000b15 	stw	fp,44(sp)
 d034628:	df000b04 	addi	fp,sp,44
 d03462c:	e13ffc15 	stw	r4,-16(fp)
 d034630:	e17ffd15 	stw	r5,-12(fp)
 d034634:	e1bffe15 	stw	r6,-8(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 d034638:	e0bffd17 	ldw	r2,-12(fp)
 d03463c:	10800317 	ldw	r2,12(r2)
 d034640:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 d034644:	e0bffb17 	ldw	r2,-20(fp)
 d034648:	1004c03a 	cmpne	r2,r2,zero
 d03464c:	1000031e 	bne	r2,zero,d03465c <udp4_sockbind+0x40>
    return(EINVAL);
 d034650:	00800584 	movi	r2,22
 d034654:	e0bfff15 	stw	r2,-4(fp)
 d034658:	0000b906 	br	d034940 <udp4_sockbind+0x324>
  if (nam->m_len != sizeof (*sin))
 d03465c:	e0bffd17 	ldw	r2,-12(fp)
 d034660:	10800217 	ldw	r2,8(r2)
 d034664:	10800420 	cmpeqi	r2,r2,16
 d034668:	1000031e 	bne	r2,zero,d034678 <udp4_sockbind+0x5c>
    return(EINVAL);
 d03466c:	00800584 	movi	r2,22
 d034670:	e0bfff15 	stw	r2,-4(fp)
 d034674:	0000b206 	br	d034940 <udp4_sockbind+0x324>
  udpconn = udp_lookup(so);
 d034678:	e13ffc17 	ldw	r4,-16(fp)
 d03467c:	d0341700 	call	d034170 <udp_lookup>
 d034680:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 d034684:	e0bffa17 	ldw	r2,-24(fp)
 d034688:	1004c03a 	cmpne	r2,r2,zero
 d03468c:	1000031e 	bne	r2,zero,d03469c <udp4_sockbind+0x80>
     return(EINVAL);
 d034690:	00800584 	movi	r2,22
 d034694:	e0bfff15 	stw	r2,-4(fp)
 d034698:	0000a906 	br	d034940 <udp4_sockbind+0x324>
  if (req == PRU_BIND)
 d03469c:	e0bffe17 	ldw	r2,-8(fp)
 d0346a0:	10800098 	cmpnei	r2,r2,2
 d0346a4:	1000601e 	bne	r2,zero,d034828 <udp4_sockbind+0x20c>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 d0346a8:	e0bffb17 	ldw	r2,-20(fp)
 d0346ac:	1080008b 	ldhu	r2,2(r2)
 d0346b0:	10bfffcc 	andi	r2,r2,65535
 d0346b4:	1004c03a 	cmpne	r2,r2,zero
 d0346b8:	10000c1e 	bne	r2,zero,d0346ec <udp4_sockbind+0xd0>
    {
      if (udpconn->u_lport != 0)
 d0346bc:	e0bffa17 	ldw	r2,-24(fp)
 d0346c0:	1080018b 	ldhu	r2,6(r2)
 d0346c4:	10bfffcc 	andi	r2,r2,65535
 d0346c8:	1005003a 	cmpeq	r2,r2,zero
 d0346cc:	1000041e 	bne	r2,zero,d0346e0 <udp4_sockbind+0xc4>
        lport = udpconn->u_lport;
 d0346d0:	e0bffa17 	ldw	r2,-24(fp)
 d0346d4:	1080018b 	ldhu	r2,6(r2)
 d0346d8:	e0bff80d 	sth	r2,-32(fp)
 d0346dc:	00001206 	br	d034728 <udp4_sockbind+0x10c>
      else
        lport = udp_socket();
 d0346e0:	d04534c0 	call	d04534c <udp_socket>
 d0346e4:	e0bff80d 	sth	r2,-32(fp)
 d0346e8:	00000f06 	br	d034728 <udp4_sockbind+0x10c>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 d0346ec:	e0bffb17 	ldw	r2,-20(fp)
 d0346f0:	1080008b 	ldhu	r2,2(r2)
 d0346f4:	10bfffcc 	andi	r2,r2,65535
 d0346f8:	1004d23a 	srli	r2,r2,8
 d0346fc:	10803fcc 	andi	r2,r2,255
 d034700:	1009883a 	mov	r4,r2
 d034704:	e0bffb17 	ldw	r2,-20(fp)
 d034708:	1080008b 	ldhu	r2,2(r2)
 d03470c:	10bfffcc 	andi	r2,r2,65535
 d034710:	1004923a 	slli	r2,r2,8
 d034714:	1007883a 	mov	r3,r2
 d034718:	00bfc004 	movi	r2,-256
 d03471c:	1884703a 	and	r2,r3,r2
 d034720:	2084b03a 	or	r2,r4,r2
 d034724:	e0bff80d 	sth	r2,-32(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 d034728:	e0bffb17 	ldw	r2,-20(fp)
 d03472c:	10800117 	ldw	r2,4(r2)
 d034730:	1004c03a 	cmpne	r2,r2,zero
 d034734:	1000021e 	bne	r2,zero,d034740 <udp4_sockbind+0x124>
    {
      lhost = 0L;
 d034738:	e03ff615 	stw	zero,-40(fp)
 d03473c:	00001806 	br	d0347a0 <udp4_sockbind+0x184>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 d034740:	e0bffb17 	ldw	r2,-20(fp)
 d034744:	10800117 	ldw	r2,4(r2)
 d034748:	e0bff615 	stw	r2,-40(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03474c:	008341b4 	movhi	r2,3334
 d034750:	10856304 	addi	r2,r2,5516
 d034754:	10800017 	ldw	r2,0(r2)
 d034758:	e0bff515 	stw	r2,-44(fp)
 d03475c:	00000706 	br	d03477c <udp4_sockbind+0x160>
        if (ifp->n_ipaddr == lhost)
 d034760:	e0bff517 	ldw	r2,-44(fp)
 d034764:	10c00a17 	ldw	r3,40(r2)
 d034768:	e0bff617 	ldw	r2,-40(fp)
 d03476c:	18800626 	beq	r3,r2,d034788 <udp4_sockbind+0x16c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d034770:	e0bff517 	ldw	r2,-44(fp)
 d034774:	10800017 	ldw	r2,0(r2)
 d034778:	e0bff515 	stw	r2,-44(fp)
 d03477c:	e0bff517 	ldw	r2,-44(fp)
 d034780:	1004c03a 	cmpne	r2,r2,zero
 d034784:	103ff61e 	bne	r2,zero,d034760 <udp4_sockbind+0x144>
        if (ifp->n_ipaddr == lhost)
          break;
      if (ifp == NULL)
 d034788:	e0bff517 	ldw	r2,-44(fp)
 d03478c:	1004c03a 	cmpne	r2,r2,zero
 d034790:	1000031e 	bne	r2,zero,d0347a0 <udp4_sockbind+0x184>
        return(EADDRNOTAVAIL);
 d034794:	00801f44 	movi	r2,125
 d034798:	e0bfff15 	stw	r2,-4(fp)
 d03479c:	00006806 	br	d034940 <udp4_sockbind+0x324>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 d0347a0:	e0bffc17 	ldw	r2,-16(fp)
 d0347a4:	10800417 	ldw	r2,16(r2)
 d0347a8:	1080010c 	andi	r2,r2,4
 d0347ac:	1004c03a 	cmpne	r2,r2,zero
 d0347b0:	1000161e 	bne	r2,zero,d03480c <udp4_sockbind+0x1f0>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 d0347b4:	00834174 	movhi	r2,3333
 d0347b8:	109b3904 	addi	r2,r2,27876
 d0347bc:	10800017 	ldw	r2,0(r2)
 d0347c0:	e0bff915 	stw	r2,-28(fp)
 d0347c4:	00000e06 	br	d034800 <udp4_sockbind+0x1e4>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 d0347c8:	e0bff917 	ldw	r2,-28(fp)
 d0347cc:	1080018b 	ldhu	r2,6(r2)
 d0347d0:	10ffffcc 	andi	r3,r2,65535
 d0347d4:	e0bff80b 	ldhu	r2,-32(fp)
 d0347d8:	1880061e 	bne	r3,r2,d0347f4 <udp4_sockbind+0x1d8>
 d0347dc:	e0fff917 	ldw	r3,-28(fp)
 d0347e0:	e0bffa17 	ldw	r2,-24(fp)
 d0347e4:	18800326 	beq	r3,r2,d0347f4 <udp4_sockbind+0x1d8>
          return(EADDRINUSE);
 d0347e8:	00801c04 	movi	r2,112
 d0347ec:	e0bfff15 	stw	r2,-4(fp)
 d0347f0:	00005306 	br	d034940 <udp4_sockbind+0x324>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 d0347f4:	e0bff917 	ldw	r2,-28(fp)
 d0347f8:	10800017 	ldw	r2,0(r2)
 d0347fc:	e0bff915 	stw	r2,-28(fp)
 d034800:	e0bff917 	ldw	r2,-28(fp)
 d034804:	1004c03a 	cmpne	r2,r2,zero
 d034808:	103fef1e 	bne	r2,zero,d0347c8 <udp4_sockbind+0x1ac>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 d03480c:	e0fffa17 	ldw	r3,-24(fp)
 d034810:	e0bff80b 	ldhu	r2,-32(fp)
 d034814:	1880018d 	sth	r2,6(r3)
    udpconn->u_lhost = lhost;
 d034818:	e0fffa17 	ldw	r3,-24(fp)
 d03481c:	e0bff617 	ldw	r2,-40(fp)
 d034820:	18800315 	stw	r2,12(r3)
 d034824:	00004506 	br	d03493c <udp4_sockbind+0x320>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 d034828:	e0bffb17 	ldw	r2,-20(fp)
 d03482c:	1080008b 	ldhu	r2,2(r2)
 d034830:	10bfffcc 	andi	r2,r2,65535
 d034834:	1004d23a 	srli	r2,r2,8
 d034838:	10803fcc 	andi	r2,r2,255
 d03483c:	1009883a 	mov	r4,r2
 d034840:	e0bffb17 	ldw	r2,-20(fp)
 d034844:	1080008b 	ldhu	r2,2(r2)
 d034848:	10bfffcc 	andi	r2,r2,65535
 d03484c:	1004923a 	slli	r2,r2,8
 d034850:	1007883a 	mov	r3,r2
 d034854:	00bfc004 	movi	r2,-256
 d034858:	1884703a 	and	r2,r3,r2
 d03485c:	2084b03a 	or	r2,r4,r2
 d034860:	e0bff88d 	sth	r2,-30(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 d034864:	e0bffb17 	ldw	r2,-20(fp)
 d034868:	10800117 	ldw	r2,4(r2)
 d03486c:	1004c03a 	cmpne	r2,r2,zero
 d034870:	1000021e 	bne	r2,zero,d03487c <udp4_sockbind+0x260>
      fhost = 0L;
 d034874:	e03ff715 	stw	zero,-36(fp)
 d034878:	00000306 	br	d034888 <udp4_sockbind+0x26c>
    else
      fhost = sin->sin_addr.s_addr;
 d03487c:	e0bffb17 	ldw	r2,-20(fp)
 d034880:	10800117 	ldw	r2,4(r2)
 d034884:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 d034888:	e13ff717 	ldw	r4,-36(fp)
 d03488c:	d0404040 	call	d040404 <ip_mymach>
 d034890:	e0bff615 	stw	r2,-40(fp)
    if (lhost == 0)
 d034894:	e0bff617 	ldw	r2,-40(fp)
 d034898:	1004c03a 	cmpne	r2,r2,zero
 d03489c:	1000031e 	bne	r2,zero,d0348ac <udp4_sockbind+0x290>
      return(ENETUNREACH);
 d0348a0:	00801c84 	movi	r2,114
 d0348a4:	e0bfff15 	stw	r2,-4(fp)
 d0348a8:	00002506 	br	d034940 <udp4_sockbind+0x324>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 d0348ac:	e0bffa17 	ldw	r2,-24(fp)
 d0348b0:	1080018b 	ldhu	r2,6(r2)
 d0348b4:	e0bff80d 	sth	r2,-32(fp)
    if (lport == 0)
 d0348b8:	e0bff80b 	ldhu	r2,-32(fp)
 d0348bc:	1004c03a 	cmpne	r2,r2,zero
 d0348c0:	1000021e 	bne	r2,zero,d0348cc <udp4_sockbind+0x2b0>
      lport = udp_socket();
 d0348c4:	d04534c0 	call	d04534c <udp_socket>
 d0348c8:	e0bff80d 	sth	r2,-32(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 d0348cc:	e0fffa17 	ldw	r3,-24(fp)
 d0348d0:	e0bff617 	ldw	r2,-40(fp)
 d0348d4:	18800315 	stw	r2,12(r3)
    udpconn->u_lport = lport;
 d0348d8:	e0fffa17 	ldw	r3,-24(fp)
 d0348dc:	e0bff80b 	ldhu	r2,-32(fp)
 d0348e0:	1880018d 	sth	r2,6(r3)
    udpconn->u_fhost = fhost;
 d0348e4:	e0fffa17 	ldw	r3,-24(fp)
 d0348e8:	e0bff717 	ldw	r2,-36(fp)
 d0348ec:	18800415 	stw	r2,16(r3)
    udpconn->u_fport = fport;
 d0348f0:	e0fffa17 	ldw	r3,-24(fp)
 d0348f4:	e0bff88b 	ldhu	r2,-30(fp)
 d0348f8:	1880020d 	sth	r2,8(r3)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 d0348fc:	e0bffc17 	ldw	r2,-16(fp)
 d034900:	10c0088b 	ldhu	r3,34(r2)
 d034904:	00bffcc4 	movi	r2,-13
 d034908:	1884703a 	and	r2,r3,r2
 d03490c:	1007883a 	mov	r3,r2
 d034910:	e0bffc17 	ldw	r2,-16(fp)
 d034914:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 d034918:	e0bffc17 	ldw	r2,-16(fp)
 d03491c:	1080088b 	ldhu	r2,34(r2)
 d034920:	10800094 	ori	r2,r2,2
 d034924:	1007883a 	mov	r3,r2
 d034928:	e0bffc17 	ldw	r2,-16(fp)
 d03492c:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 d034930:	e0bffc17 	ldw	r2,-16(fp)
 d034934:	11000a04 	addi	r4,r2,40
 d034938:	d02d5380 	call	d02d538 <sbflush>
  }
  return 0;
 d03493c:	e03fff15 	stw	zero,-4(fp)
 d034940:	e0bfff17 	ldw	r2,-4(fp)
}
 d034944:	e037883a 	mov	sp,fp
 d034948:	dfc00117 	ldw	ra,4(sp)
 d03494c:	df000017 	ldw	fp,0(sp)
 d034950:	dec00204 	addi	sp,sp,8
 d034954:	f800283a 	ret

0d034958 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 d034958:	defff204 	addi	sp,sp,-56
 d03495c:	dfc00d15 	stw	ra,52(sp)
 d034960:	df000c15 	stw	fp,48(sp)
 d034964:	dc000b15 	stw	r16,44(sp)
 d034968:	df000b04 	addi	fp,sp,44
 d03496c:	e13ffc15 	stw	r4,-16(fp)
 d034970:	e17ffd15 	stw	r5,-12(fp)
 d034974:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 d034978:	e13ffc17 	ldw	r4,-16(fp)
 d03497c:	d0341700 	call	d034170 <udp_lookup>
 d034980:	e0bff915 	stw	r2,-28(fp)
  if (!udpconn)
 d034984:	e0bff917 	ldw	r2,-28(fp)
 d034988:	1004c03a 	cmpne	r2,r2,zero
 d03498c:	1000051e 	bne	r2,zero,d0349a4 <udp4_socksend+0x4c>
  {
    m_free(m);
 d034990:	e13ffd17 	ldw	r4,-12(fp)
 d034994:	d026a1c0 	call	d026a1c <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 d034998:	00801bc4 	movi	r2,111
 d03499c:	e0bfff15 	stw	r2,-4(fp)
 d0349a0:	0000dd06 	br	d034d18 <udp4_socksend+0x3c0>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 d0349a4:	e0bffe17 	ldw	r2,-8(fp)
 d0349a8:	1004c03a 	cmpne	r2,r2,zero
 d0349ac:	1000101e 	bne	r2,zero,d0349f0 <udp4_socksend+0x98>
  { 
    if (so->so_state & SS_ISCONNECTED)
 d0349b0:	e0bffc17 	ldw	r2,-16(fp)
 d0349b4:	1080088b 	ldhu	r2,34(r2)
 d0349b8:	10bfffcc 	andi	r2,r2,65535
 d0349bc:	1080008c 	andi	r2,r2,2
 d0349c0:	1005003a 	cmpeq	r2,r2,zero
 d0349c4:	1000071e 	bne	r2,zero,d0349e4 <udp4_socksend+0x8c>
    {
      fport = udpconn->u_fport;
 d0349c8:	e0bff917 	ldw	r2,-28(fp)
 d0349cc:	1080020b 	ldhu	r2,8(r2)
 d0349d0:	e0bff80d 	sth	r2,-32(fp)
      fhost = udpconn->u_fhost;
 d0349d4:	e0bff917 	ldw	r2,-28(fp)
 d0349d8:	10800417 	ldw	r2,16(r2)
 d0349dc:	e0bff715 	stw	r2,-36(fp)
 d0349e0:	00003106 	br	d034aa8 <udp4_socksend+0x150>
    }
    else
      return (EINVAL);
 d0349e4:	00800584 	movi	r2,22
 d0349e8:	e0bfff15 	stw	r2,-4(fp)
 d0349ec:	0000ca06 	br	d034d18 <udp4_socksend+0x3c0>
  }
  else if(nam->m_len != sizeof (*sin))
 d0349f0:	e0bffe17 	ldw	r2,-8(fp)
 d0349f4:	10800217 	ldw	r2,8(r2)
 d0349f8:	10800420 	cmpeqi	r2,r2,16
 d0349fc:	1000041e 	bne	r2,zero,d034a10 <udp4_socksend+0xb8>
  {
    dtrap();
 d034a00:	d025a500 	call	d025a50 <dtrap>
    return (EINVAL);
 d034a04:	00800584 	movi	r2,22
 d034a08:	e0bfff15 	stw	r2,-4(fp)
 d034a0c:	0000c206 	br	d034d18 <udp4_socksend+0x3c0>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 d034a10:	e0bffe17 	ldw	r2,-8(fp)
 d034a14:	10800317 	ldw	r2,12(r2)
 d034a18:	e0bffa15 	stw	r2,-24(fp)
    fhost = sin->sin_addr.s_addr;
 d034a1c:	e0bffa17 	ldw	r2,-24(fp)
 d034a20:	10800117 	ldw	r2,4(r2)
 d034a24:	e0bff715 	stw	r2,-36(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 d034a28:	e0bffa17 	ldw	r2,-24(fp)
 d034a2c:	1080008b 	ldhu	r2,2(r2)
 d034a30:	10bfffcc 	andi	r2,r2,65535
 d034a34:	1005003a 	cmpeq	r2,r2,zero
 d034a38:	1000101e 	bne	r2,zero,d034a7c <udp4_socksend+0x124>
      fport = ntohs(sin->sin_port);
 d034a3c:	e0bffa17 	ldw	r2,-24(fp)
 d034a40:	1080008b 	ldhu	r2,2(r2)
 d034a44:	10bfffcc 	andi	r2,r2,65535
 d034a48:	1004d23a 	srli	r2,r2,8
 d034a4c:	10803fcc 	andi	r2,r2,255
 d034a50:	1009883a 	mov	r4,r2
 d034a54:	e0bffa17 	ldw	r2,-24(fp)
 d034a58:	1080008b 	ldhu	r2,2(r2)
 d034a5c:	10bfffcc 	andi	r2,r2,65535
 d034a60:	1004923a 	slli	r2,r2,8
 d034a64:	1007883a 	mov	r3,r2
 d034a68:	00bfc004 	movi	r2,-256
 d034a6c:	1884703a 	and	r2,r3,r2
 d034a70:	2084b03a 	or	r2,r4,r2
 d034a74:	e0bff80d 	sth	r2,-32(fp)
 d034a78:	00000b06 	br	d034aa8 <udp4_socksend+0x150>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 d034a7c:	e0bff917 	ldw	r2,-28(fp)
 d034a80:	1080020b 	ldhu	r2,8(r2)
 d034a84:	10bfffcc 	andi	r2,r2,65535
 d034a88:	1004c03a 	cmpne	r2,r2,zero
 d034a8c:	1000031e 	bne	r2,zero,d034a9c <udp4_socksend+0x144>
        return (EINVAL);
 d034a90:	00800584 	movi	r2,22
 d034a94:	e0bfff15 	stw	r2,-4(fp)
 d034a98:	00009f06 	br	d034d18 <udp4_socksend+0x3c0>
      fport = udpconn->u_fport;
 d034a9c:	e0bff917 	ldw	r2,-28(fp)
 d034aa0:	1080020b 	ldhu	r2,8(r2)
 d034aa4:	e0bff80d 	sth	r2,-32(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 d034aa8:	e0bffd17 	ldw	r2,-12(fp)
 d034aac:	14000217 	ldw	r16,8(r2)
 d034ab0:	d0454dc0 	call	d0454dc <udp_maxalloc>
 d034ab4:	1400042e 	bgeu	r2,r16,d034ac8 <udp4_socksend+0x170>
  {
    dtrap(); /* should never happen */
 d034ab8:	d025a500 	call	d025a50 <dtrap>
    return EMSGSIZE;  /* try to recover */
 d034abc:	00801e84 	movi	r2,122
 d034ac0:	e0bfff15 	stw	r2,-4(fp)
 d034ac4:	00009406 	br	d034d18 <udp4_socksend+0x3c0>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 d034ac8:	e0bffd17 	ldw	r2,-12(fp)
 d034acc:	10800217 	ldw	r2,8(r2)
 d034ad0:	1009883a 	mov	r4,r2
 d034ad4:	000b883a 	mov	r5,zero
 d034ad8:	d04541c0 	call	d04541c <udp_alloc>
 d034adc:	e0bff615 	stw	r2,-40(fp)
  if (!pkt)
 d034ae0:	e0bff617 	ldw	r2,-40(fp)
 d034ae4:	1004c03a 	cmpne	r2,r2,zero
 d034ae8:	1000051e 	bne	r2,zero,d034b00 <udp4_socksend+0x1a8>
  {
    m_free(m);
 d034aec:	e13ffd17 	ldw	r4,-12(fp)
 d034af0:	d026a1c0 	call	d026a1c <m_free>
    return ENOBUFS;   /* report buffer shortages */
 d034af4:	00801a44 	movi	r2,105
 d034af8:	e0bfff15 	stw	r2,-4(fp)
 d034afc:	00008606 	br	d034d18 <udp4_socksend+0x3c0>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 d034b00:	e0bff617 	ldw	r2,-40(fp)
 d034b04:	10c00317 	ldw	r3,12(r2)
 d034b08:	e0bffd17 	ldw	r2,-12(fp)
 d034b0c:	11400317 	ldw	r5,12(r2)
 d034b10:	e0bffd17 	ldw	r2,-12(fp)
 d034b14:	10800217 	ldw	r2,8(r2)
 d034b18:	1809883a 	mov	r4,r3
 d034b1c:	100d883a 	mov	r6,r2
 d034b20:	d0026080 	call	d002608 <memcpy>
  pkt->nb_plen = m->m_len;
 d034b24:	e0bffd17 	ldw	r2,-12(fp)
 d034b28:	10c00217 	ldw	r3,8(r2)
 d034b2c:	e0bff617 	ldw	r2,-40(fp)
 d034b30:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 d034b34:	e13ffd17 	ldw	r4,-12(fp)
 d034b38:	d026a1c0 	call	d026a1c <m_free>
  pkt->fhost = fhost;
 d034b3c:	e0fff617 	ldw	r3,-40(fp)
 d034b40:	e0bff717 	ldw	r2,-36(fp)
 d034b44:	18800715 	stw	r2,28(r3)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 d034b48:	e0bff717 	ldw	r2,-36(fp)
 d034b4c:	10bfffd8 	cmpnei	r2,r2,-1
 d034b50:	10004f1e 	bne	r2,zero,d034c90 <udp4_socksend+0x338>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 d034b54:	e0bff917 	ldw	r2,-28(fp)
 d034b58:	10800317 	ldw	r2,12(r2)
 d034b5c:	1005003a 	cmpeq	r2,r2,zero
 d034b60:	1000111e 	bne	r2,zero,d034ba8 <udp4_socksend+0x250>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d034b64:	008341b4 	movhi	r2,3334
 d034b68:	10856304 	addi	r2,r2,5516
 d034b6c:	10800017 	ldw	r2,0(r2)
 d034b70:	e0bff515 	stw	r2,-44(fp)
 d034b74:	00000806 	br	d034b98 <udp4_socksend+0x240>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 d034b78:	e0bff517 	ldw	r2,-44(fp)
 d034b7c:	10c00a17 	ldw	r3,40(r2)
 d034b80:	e0bff917 	ldw	r2,-28(fp)
 d034b84:	10800317 	ldw	r2,12(r2)
 d034b88:	18802126 	beq	r3,r2,d034c10 <udp4_socksend+0x2b8>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d034b8c:	e0bff517 	ldw	r2,-44(fp)
 d034b90:	10800017 	ldw	r2,0(r2)
 d034b94:	e0bff515 	stw	r2,-44(fp)
 d034b98:	e0bff517 	ldw	r2,-44(fp)
 d034b9c:	1004c03a 	cmpne	r2,r2,zero
 d034ba0:	103ff51e 	bne	r2,zero,d034b78 <udp4_socksend+0x220>
 d034ba4:	00001a06 	br	d034c10 <udp4_socksend+0x2b8>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d034ba8:	008341b4 	movhi	r2,3334
 d034bac:	10856304 	addi	r2,r2,5516
 d034bb0:	10800017 	ldw	r2,0(r2)
 d034bb4:	e0bff515 	stw	r2,-44(fp)
 d034bb8:	00001206 	br	d034c04 <udp4_socksend+0x2ac>
        if ((ifp->n_flags & NF_BCAST) &&
 d034bbc:	e0bff517 	ldw	r2,-44(fp)
 d034bc0:	10802a17 	ldw	r2,168(r2)
 d034bc4:	1080004c 	andi	r2,r2,1
 d034bc8:	10803fcc 	andi	r2,r2,255
 d034bcc:	1005003a 	cmpeq	r2,r2,zero
 d034bd0:	1000091e 	bne	r2,zero,d034bf8 <udp4_socksend+0x2a0>
 d034bd4:	e0bff517 	ldw	r2,-44(fp)
 d034bd8:	10802717 	ldw	r2,156(r2)
 d034bdc:	1005003a 	cmpeq	r2,r2,zero
 d034be0:	1000051e 	bne	r2,zero,d034bf8 <udp4_socksend+0x2a0>
 d034be4:	e0bff517 	ldw	r2,-44(fp)
 d034be8:	10802717 	ldw	r2,156(r2)
 d034bec:	10800617 	ldw	r2,24(r2)
 d034bf0:	10800060 	cmpeqi	r2,r2,1
 d034bf4:	1000061e 	bne	r2,zero,d034c10 <udp4_socksend+0x2b8>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d034bf8:	e0bff517 	ldw	r2,-44(fp)
 d034bfc:	10800017 	ldw	r2,0(r2)
 d034c00:	e0bff515 	stw	r2,-44(fp)
 d034c04:	e0bff517 	ldw	r2,-44(fp)
 d034c08:	1004c03a 	cmpne	r2,r2,zero
 d034c0c:	103feb1e 	bne	r2,zero,d034bbc <udp4_socksend+0x264>
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
 d034c10:	e0bff517 	ldw	r2,-44(fp)
 d034c14:	1004c03a 	cmpne	r2,r2,zero
 d034c18:	10001a1e 	bne	r2,zero,d034c84 <udp4_socksend+0x32c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d034c1c:	008341b4 	movhi	r2,3334
 d034c20:	10856304 	addi	r2,r2,5516
 d034c24:	10800017 	ldw	r2,0(r2)
 d034c28:	e0bff515 	stw	r2,-44(fp)
 d034c2c:	00000c06 	br	d034c60 <udp4_socksend+0x308>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 d034c30:	e0bff517 	ldw	r2,-44(fp)
 d034c34:	10802717 	ldw	r2,156(r2)
 d034c38:	1005003a 	cmpeq	r2,r2,zero
 d034c3c:	1000051e 	bne	r2,zero,d034c54 <udp4_socksend+0x2fc>
 d034c40:	e0bff517 	ldw	r2,-44(fp)
 d034c44:	10802717 	ldw	r2,156(r2)
 d034c48:	10800617 	ldw	r2,24(r2)
 d034c4c:	10800060 	cmpeqi	r2,r2,1
 d034c50:	1000061e 	bne	r2,zero,d034c6c <udp4_socksend+0x314>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d034c54:	e0bff517 	ldw	r2,-44(fp)
 d034c58:	10800017 	ldw	r2,0(r2)
 d034c5c:	e0bff515 	stw	r2,-44(fp)
 d034c60:	e0bff517 	ldw	r2,-44(fp)
 d034c64:	1004c03a 	cmpne	r2,r2,zero
 d034c68:	103ff11e 	bne	r2,zero,d034c30 <udp4_socksend+0x2d8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
      if (ifp == NULL)
 d034c6c:	e0bff517 	ldw	r2,-44(fp)
 d034c70:	1004c03a 	cmpne	r2,r2,zero
 d034c74:	1000031e 	bne	r2,zero,d034c84 <udp4_socksend+0x32c>
        return(EADDRNOTAVAIL);
 d034c78:	00801f44 	movi	r2,125
 d034c7c:	e0bfff15 	stw	r2,-4(fp)
 d034c80:	00002506 	br	d034d18 <udp4_socksend+0x3c0>
    }
    pkt->net = ifp;
 d034c84:	e0fff617 	ldw	r3,-40(fp)
 d034c88:	e0bff517 	ldw	r2,-44(fp)
 d034c8c:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 d034c90:	e0bffc17 	ldw	r2,-16(fp)
 d034c94:	10800317 	ldw	r2,12(r2)
 d034c98:	1005003a 	cmpeq	r2,r2,zero
 d034c9c:	1000041e 	bne	r2,zero,d034cb0 <udp4_socksend+0x358>
     pkt->imo = so->inp_moptions;
 d034ca0:	e0bffc17 	ldw	r2,-16(fp)
 d034ca4:	10c00317 	ldw	r3,12(r2)
 d034ca8:	e0bff617 	ldw	r2,-40(fp)
 d034cac:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 d034cb0:	e0bffc17 	ldw	r2,-16(fp)
 d034cb4:	10801f17 	ldw	r2,124(r2)
 d034cb8:	1005003a 	cmpeq	r2,r2,zero
 d034cbc:	1000041e 	bne	r2,zero,d034cd0 <udp4_socksend+0x378>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 d034cc0:	e0bffc17 	ldw	r2,-16(fp)
 d034cc4:	10c01f17 	ldw	r3,124(r2)
 d034cc8:	e0bff617 	ldw	r2,-40(fp)
 d034ccc:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 d034cd0:	0009883a 	mov	r4,zero
 d034cd4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 d034cd8:	e13ff80b 	ldhu	r4,-32(fp)
 d034cdc:	e0bff917 	ldw	r2,-28(fp)
 d034ce0:	1080018b 	ldhu	r2,6(r2)
 d034ce4:	117fffcc 	andi	r5,r2,65535
 d034ce8:	e1bff617 	ldw	r6,-40(fp)
 d034cec:	d044f640 	call	d044f64 <udp_send>
 d034cf0:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 d034cf4:	0009883a 	mov	r4,zero
 d034cf8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
  if (e < 0) 
 d034cfc:	e0bffb17 	ldw	r2,-20(fp)
 d034d00:	1004403a 	cmpge	r2,r2,zero
 d034d04:	1000031e 	bne	r2,zero,d034d14 <udp4_socksend+0x3bc>
     return(e);
 d034d08:	e0bffb17 	ldw	r2,-20(fp)
 d034d0c:	e0bfff15 	stw	r2,-4(fp)
 d034d10:	00000106 	br	d034d18 <udp4_socksend+0x3c0>
  return 0;
 d034d14:	e03fff15 	stw	zero,-4(fp)
 d034d18:	e0bfff17 	ldw	r2,-4(fp)
}
 d034d1c:	e037883a 	mov	sp,fp
 d034d20:	dfc00217 	ldw	ra,8(sp)
 d034d24:	df000117 	ldw	fp,4(sp)
 d034d28:	dc000017 	ldw	r16,0(sp)
 d034d2c:	dec00304 	addi	sp,sp,12
 d034d30:	f800283a 	ret

0d034d34 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 d034d34:	defff804 	addi	sp,sp,-32
 d034d38:	dfc00715 	stw	ra,28(sp)
 d034d3c:	df000615 	stw	fp,24(sp)
 d034d40:	df000604 	addi	fp,sp,24
 d034d44:	e13ffc15 	stw	r4,-16(fp)
 d034d48:	e17ffd15 	stw	r5,-12(fp)
 d034d4c:	e1bffe15 	stw	r6,-8(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 d034d50:	e0bffd17 	ldw	r2,-12(fp)
 d034d54:	10800317 	ldw	r2,12(r2)
 d034d58:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 d034d5c:	e0bffb17 	ldw	r2,-20(fp)
 d034d60:	1004c03a 	cmpne	r2,r2,zero
 d034d64:	1000031e 	bne	r2,zero,d034d74 <udp4_sockaddr+0x40>
     return(EINVAL);
 d034d68:	00800584 	movi	r2,22
 d034d6c:	e0bfff15 	stw	r2,-4(fp)
 d034d70:	00004106 	br	d034e78 <udp4_sockaddr+0x144>
  udpconn = udp_lookup(so);
 d034d74:	e13ffc17 	ldw	r4,-16(fp)
 d034d78:	d0341700 	call	d034170 <udp_lookup>
 d034d7c:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 d034d80:	e0bffa17 	ldw	r2,-24(fp)
 d034d84:	1004c03a 	cmpne	r2,r2,zero
 d034d88:	1000031e 	bne	r2,zero,d034d98 <udp4_sockaddr+0x64>
     return(EINVAL);
 d034d8c:	00800584 	movi	r2,22
 d034d90:	e0bfff15 	stw	r2,-4(fp)
 d034d94:	00003806 	br	d034e78 <udp4_sockaddr+0x144>
  nam->m_len = sizeof(*sin);
 d034d98:	e0fffd17 	ldw	r3,-12(fp)
 d034d9c:	00800404 	movi	r2,16
 d034da0:	18800215 	stw	r2,8(r3)
  if (req == PRU_SOCKADDR)
 d034da4:	e0bffe17 	ldw	r2,-8(fp)
 d034da8:	108003d8 	cmpnei	r2,r2,15
 d034dac:	1000191e 	bne	r2,zero,d034e14 <udp4_sockaddr+0xe0>
  {
     sin->sin_family = AF_INET;
 d034db0:	e0fffb17 	ldw	r3,-20(fp)
 d034db4:	00800084 	movi	r2,2
 d034db8:	1880000d 	sth	r2,0(r3)
     sin->sin_port = htons(udpconn->u_lport);
 d034dbc:	e0bffa17 	ldw	r2,-24(fp)
 d034dc0:	1080018b 	ldhu	r2,6(r2)
 d034dc4:	10bfffcc 	andi	r2,r2,65535
 d034dc8:	1004d23a 	srli	r2,r2,8
 d034dcc:	10803fcc 	andi	r2,r2,255
 d034dd0:	1009883a 	mov	r4,r2
 d034dd4:	e0bffa17 	ldw	r2,-24(fp)
 d034dd8:	1080018b 	ldhu	r2,6(r2)
 d034ddc:	10bfffcc 	andi	r2,r2,65535
 d034de0:	1004923a 	slli	r2,r2,8
 d034de4:	1007883a 	mov	r3,r2
 d034de8:	00bfc004 	movi	r2,-256
 d034dec:	1884703a 	and	r2,r3,r2
 d034df0:	2084b03a 	or	r2,r4,r2
 d034df4:	1007883a 	mov	r3,r2
 d034df8:	e0bffb17 	ldw	r2,-20(fp)
 d034dfc:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 d034e00:	e0bffa17 	ldw	r2,-24(fp)
 d034e04:	10c00317 	ldw	r3,12(r2)
 d034e08:	e0bffb17 	ldw	r2,-20(fp)
 d034e0c:	10c00115 	stw	r3,4(r2)
 d034e10:	00001806 	br	d034e74 <udp4_sockaddr+0x140>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 d034e14:	e0fffb17 	ldw	r3,-20(fp)
 d034e18:	00800084 	movi	r2,2
 d034e1c:	1880000d 	sth	r2,0(r3)
    sin->sin_port = htons(udpconn->u_fport);
 d034e20:	e0bffa17 	ldw	r2,-24(fp)
 d034e24:	1080020b 	ldhu	r2,8(r2)
 d034e28:	10bfffcc 	andi	r2,r2,65535
 d034e2c:	1004d23a 	srli	r2,r2,8
 d034e30:	10803fcc 	andi	r2,r2,255
 d034e34:	1009883a 	mov	r4,r2
 d034e38:	e0bffa17 	ldw	r2,-24(fp)
 d034e3c:	1080020b 	ldhu	r2,8(r2)
 d034e40:	10bfffcc 	andi	r2,r2,65535
 d034e44:	1004923a 	slli	r2,r2,8
 d034e48:	1007883a 	mov	r3,r2
 d034e4c:	00bfc004 	movi	r2,-256
 d034e50:	1884703a 	and	r2,r3,r2
 d034e54:	2084b03a 	or	r2,r4,r2
 d034e58:	1007883a 	mov	r3,r2
 d034e5c:	e0bffb17 	ldw	r2,-20(fp)
 d034e60:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 d034e64:	e0bffa17 	ldw	r2,-24(fp)
 d034e68:	10c00417 	ldw	r3,16(r2)
 d034e6c:	e0bffb17 	ldw	r2,-20(fp)
 d034e70:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 d034e74:	e03fff15 	stw	zero,-4(fp)
 d034e78:	e0bfff17 	ldw	r2,-4(fp)
}
 d034e7c:	e037883a 	mov	sp,fp
 d034e80:	dfc00117 	ldw	ra,4(sp)
 d034e84:	df000017 	ldw	fp,0(sp)
 d034e88:	dec00204 	addi	sp,sp,8
 d034e8c:	f800283a 	ret

0d034e90 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 d034e90:	defff404 	addi	sp,sp,-48
 d034e94:	df000b15 	stw	fp,44(sp)
 d034e98:	df000b04 	addi	fp,sp,44
 d034e9c:	e13ffb15 	stw	r4,-20(fp)
 d034ea0:	e17ffc15 	stw	r5,-16(fp)
 d034ea4:	e1bffd15 	stw	r6,-12(fp)
 d034ea8:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 d034eac:	e03ff915 	stw	zero,-28(fp)
 d034eb0:	00834174 	movhi	r2,3333
 d034eb4:	109b5504 	addi	r2,r2,27988
 d034eb8:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 d034ebc:	1005003a 	cmpeq	r2,r2,zero
 d034ec0:	1000411e 	bne	r2,zero,d034fc8 <alt_alarm_start+0x138>
  {
    if (alarm)
 d034ec4:	e0bffb17 	ldw	r2,-20(fp)
 d034ec8:	1005003a 	cmpeq	r2,r2,zero
 d034ecc:	10003b1e 	bne	r2,zero,d034fbc <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 d034ed0:	e0fffb17 	ldw	r3,-20(fp)
 d034ed4:	e0bffd17 	ldw	r2,-12(fp)
 d034ed8:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 d034edc:	e0fffb17 	ldw	r3,-20(fp)
 d034ee0:	e0bffe17 	ldw	r2,-8(fp)
 d034ee4:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d034ee8:	0005303a 	rdctl	r2,status
 d034eec:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d034ef0:	e0fff817 	ldw	r3,-32(fp)
 d034ef4:	00bfff84 	movi	r2,-2
 d034ef8:	1884703a 	and	r2,r3,r2
 d034efc:	1001703a 	wrctl	status,r2
  
  return context;
 d034f00:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 d034f04:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 d034f08:	00834174 	movhi	r2,3333
 d034f0c:	109b5604 	addi	r2,r2,27992
 d034f10:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 d034f14:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 d034f18:	e0fffc17 	ldw	r3,-16(fp)
 d034f1c:	e0bff917 	ldw	r2,-28(fp)
 d034f20:	1885883a 	add	r2,r3,r2
 d034f24:	10c00044 	addi	r3,r2,1
 d034f28:	e0bffb17 	ldw	r2,-20(fp)
 d034f2c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 d034f30:	e0bffb17 	ldw	r2,-20(fp)
 d034f34:	10c00217 	ldw	r3,8(r2)
 d034f38:	e0bff917 	ldw	r2,-28(fp)
 d034f3c:	1880042e 	bgeu	r3,r2,d034f50 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 d034f40:	e0fffb17 	ldw	r3,-20(fp)
 d034f44:	00800044 	movi	r2,1
 d034f48:	18800405 	stb	r2,16(r3)
 d034f4c:	00000206 	br	d034f58 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 d034f50:	e0bffb17 	ldw	r2,-20(fp)
 d034f54:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 d034f58:	e0fffb17 	ldw	r3,-20(fp)
 d034f5c:	00834174 	movhi	r2,3333
 d034f60:	10926704 	addi	r2,r2,18844
 d034f64:	e0bff615 	stw	r2,-40(fp)
 d034f68:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 d034f6c:	e0fff717 	ldw	r3,-36(fp)
 d034f70:	e0bff617 	ldw	r2,-40(fp)
 d034f74:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 d034f78:	e0bff617 	ldw	r2,-40(fp)
 d034f7c:	10c00017 	ldw	r3,0(r2)
 d034f80:	e0bff717 	ldw	r2,-36(fp)
 d034f84:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 d034f88:	e0bff617 	ldw	r2,-40(fp)
 d034f8c:	10c00017 	ldw	r3,0(r2)
 d034f90:	e0bff717 	ldw	r2,-36(fp)
 d034f94:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 d034f98:	e0fff617 	ldw	r3,-40(fp)
 d034f9c:	e0bff717 	ldw	r2,-36(fp)
 d034fa0:	18800015 	stw	r2,0(r3)
 d034fa4:	e0bffa17 	ldw	r2,-24(fp)
 d034fa8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d034fac:	e0bff517 	ldw	r2,-44(fp)
 d034fb0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 d034fb4:	e03fff15 	stw	zero,-4(fp)
 d034fb8:	00000506 	br	d034fd0 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 d034fbc:	00bffa84 	movi	r2,-22
 d034fc0:	e0bfff15 	stw	r2,-4(fp)
 d034fc4:	00000206 	br	d034fd0 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 d034fc8:	00bfde84 	movi	r2,-134
 d034fcc:	e0bfff15 	stw	r2,-4(fp)
 d034fd0:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 d034fd4:	e037883a 	mov	sp,fp
 d034fd8:	df000017 	ldw	fp,0(sp)
 d034fdc:	dec00104 	addi	sp,sp,4
 d034fe0:	f800283a 	ret

0d034fe4 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 d034fe4:	defff804 	addi	sp,sp,-32
 d034fe8:	dfc00715 	stw	ra,28(sp)
 d034fec:	df000615 	stw	fp,24(sp)
 d034ff0:	df000604 	addi	fp,sp,24
 d034ff4:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 d034ff8:	e0bffc17 	ldw	r2,-16(fp)
 d034ffc:	1004803a 	cmplt	r2,r2,zero
 d035000:	1000091e 	bne	r2,zero,d035028 <alt_close+0x44>
 d035004:	e13ffc17 	ldw	r4,-16(fp)
 d035008:	01400304 	movi	r5,12
 d03500c:	d00235c0 	call	d00235c <__mulsi3>
 d035010:	1007883a 	mov	r3,r2
 d035014:	00834174 	movhi	r2,3333
 d035018:	10915b04 	addi	r2,r2,17772
 d03501c:	1887883a 	add	r3,r3,r2
 d035020:	e0ffff15 	stw	r3,-4(fp)
 d035024:	00000106 	br	d03502c <alt_close+0x48>
 d035028:	e03fff15 	stw	zero,-4(fp)
 d03502c:	e0bfff17 	ldw	r2,-4(fp)
 d035030:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 d035034:	e0bffb17 	ldw	r2,-20(fp)
 d035038:	1005003a 	cmpeq	r2,r2,zero
 d03503c:	10001d1e 	bne	r2,zero,d0350b4 <alt_close+0xd0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 d035040:	e0bffb17 	ldw	r2,-20(fp)
 d035044:	10800017 	ldw	r2,0(r2)
 d035048:	10800417 	ldw	r2,16(r2)
 d03504c:	1005003a 	cmpeq	r2,r2,zero
 d035050:	1000071e 	bne	r2,zero,d035070 <alt_close+0x8c>
 d035054:	e0bffb17 	ldw	r2,-20(fp)
 d035058:	10800017 	ldw	r2,0(r2)
 d03505c:	10800417 	ldw	r2,16(r2)
 d035060:	e13ffb17 	ldw	r4,-20(fp)
 d035064:	103ee83a 	callr	r2
 d035068:	e0bffe15 	stw	r2,-8(fp)
 d03506c:	00000106 	br	d035074 <alt_close+0x90>
 d035070:	e03ffe15 	stw	zero,-8(fp)
 d035074:	e0bffe17 	ldw	r2,-8(fp)
 d035078:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 d03507c:	e13ffc17 	ldw	r4,-16(fp)
 d035080:	d035cd40 	call	d035cd4 <alt_release_fd>
    if (rval < 0)
 d035084:	e0bffa17 	ldw	r2,-24(fp)
 d035088:	1004403a 	cmpge	r2,r2,zero
 d03508c:	1000071e 	bne	r2,zero,d0350ac <alt_close+0xc8>
    {
      ALT_ERRNO = -rval;
 d035090:	d0350e40 	call	d0350e4 <alt_get_errno>
 d035094:	e0fffa17 	ldw	r3,-24(fp)
 d035098:	00c7c83a 	sub	r3,zero,r3
 d03509c:	10c00015 	stw	r3,0(r2)
      return -1;
 d0350a0:	00bfffc4 	movi	r2,-1
 d0350a4:	e0bffd15 	stw	r2,-12(fp)
 d0350a8:	00000806 	br	d0350cc <alt_close+0xe8>
    }
    return 0;
 d0350ac:	e03ffd15 	stw	zero,-12(fp)
 d0350b0:	00000606 	br	d0350cc <alt_close+0xe8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 d0350b4:	d0350e40 	call	d0350e4 <alt_get_errno>
 d0350b8:	1007883a 	mov	r3,r2
 d0350bc:	00801444 	movi	r2,81
 d0350c0:	18800015 	stw	r2,0(r3)
    return -1;
 d0350c4:	00bfffc4 	movi	r2,-1
 d0350c8:	e0bffd15 	stw	r2,-12(fp)
 d0350cc:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 d0350d0:	e037883a 	mov	sp,fp
 d0350d4:	dfc00117 	ldw	ra,4(sp)
 d0350d8:	df000017 	ldw	fp,0(sp)
 d0350dc:	dec00204 	addi	sp,sp,8
 d0350e0:	f800283a 	ret

0d0350e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d0350e4:	defffd04 	addi	sp,sp,-12
 d0350e8:	dfc00215 	stw	ra,8(sp)
 d0350ec:	df000115 	stw	fp,4(sp)
 d0350f0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d0350f4:	00834174 	movhi	r2,3333
 d0350f8:	10926504 	addi	r2,r2,18836
 d0350fc:	10800017 	ldw	r2,0(r2)
 d035100:	1005003a 	cmpeq	r2,r2,zero
 d035104:	1000061e 	bne	r2,zero,d035120 <alt_get_errno+0x3c>
 d035108:	00834174 	movhi	r2,3333
 d03510c:	10926504 	addi	r2,r2,18836
 d035110:	10800017 	ldw	r2,0(r2)
 d035114:	103ee83a 	callr	r2
 d035118:	e0bfff15 	stw	r2,-4(fp)
 d03511c:	00000306 	br	d03512c <alt_get_errno+0x48>
 d035120:	00834174 	movhi	r2,3333
 d035124:	109b0104 	addi	r2,r2,27652
 d035128:	e0bfff15 	stw	r2,-4(fp)
 d03512c:	e0bfff17 	ldw	r2,-4(fp)
}
 d035130:	e037883a 	mov	sp,fp
 d035134:	dfc00117 	ldw	ra,4(sp)
 d035138:	df000017 	ldw	fp,0(sp)
 d03513c:	dec00204 	addi	sp,sp,8
 d035140:	f800283a 	ret

0d035144 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 d035144:	defffd04 	addi	sp,sp,-12
 d035148:	df000215 	stw	fp,8(sp)
 d03514c:	df000204 	addi	fp,sp,8
 d035150:	e13ffe15 	stw	r4,-8(fp)
 d035154:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 d035158:	e037883a 	mov	sp,fp
 d03515c:	df000017 	ldw	fp,0(sp)
 d035160:	dec00104 	addi	sp,sp,4
 d035164:	f800283a 	ret

0d035168 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 d035168:	deffff04 	addi	sp,sp,-4
 d03516c:	df000015 	stw	fp,0(sp)
 d035170:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 d035174:	e037883a 	mov	sp,fp
 d035178:	df000017 	ldw	fp,0(sp)
 d03517c:	dec00104 	addi	sp,sp,4
 d035180:	f800283a 	ret

0d035184 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 d035184:	defffc04 	addi	sp,sp,-16
 d035188:	df000315 	stw	fp,12(sp)
 d03518c:	df000304 	addi	fp,sp,12
 d035190:	e13ffd15 	stw	r4,-12(fp)
 d035194:	e17ffe15 	stw	r5,-8(fp)
 d035198:	e1bfff15 	stw	r6,-4(fp)
  return len;
 d03519c:	e0bfff17 	ldw	r2,-4(fp)
}
 d0351a0:	e037883a 	mov	sp,fp
 d0351a4:	df000017 	ldw	fp,0(sp)
 d0351a8:	dec00104 	addi	sp,sp,4
 d0351ac:	f800283a 	ret

0d0351b0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 d0351b0:	defff904 	addi	sp,sp,-28
 d0351b4:	dfc00615 	stw	ra,24(sp)
 d0351b8:	df000515 	stw	fp,20(sp)
 d0351bc:	df000504 	addi	fp,sp,20
 d0351c0:	e13ffd15 	stw	r4,-12(fp)
 d0351c4:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 d0351c8:	e0bffd17 	ldw	r2,-12(fp)
 d0351cc:	1005003a 	cmpeq	r2,r2,zero
 d0351d0:	1000041e 	bne	r2,zero,d0351e4 <alt_dev_llist_insert+0x34>
 d0351d4:	e0bffd17 	ldw	r2,-12(fp)
 d0351d8:	10800217 	ldw	r2,8(r2)
 d0351dc:	1004c03a 	cmpne	r2,r2,zero
 d0351e0:	1000071e 	bne	r2,zero,d035200 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 d0351e4:	d0352640 	call	d035264 <alt_get_errno>
 d0351e8:	1007883a 	mov	r3,r2
 d0351ec:	00800584 	movi	r2,22
 d0351f0:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 d0351f4:	00bffa84 	movi	r2,-22
 d0351f8:	e0bfff15 	stw	r2,-4(fp)
 d0351fc:	00001306 	br	d03524c <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 d035200:	e0fffd17 	ldw	r3,-12(fp)
 d035204:	e0bffe17 	ldw	r2,-8(fp)
 d035208:	e0bffb15 	stw	r2,-20(fp)
 d03520c:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 d035210:	e0fffc17 	ldw	r3,-16(fp)
 d035214:	e0bffb17 	ldw	r2,-20(fp)
 d035218:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 d03521c:	e0bffb17 	ldw	r2,-20(fp)
 d035220:	10c00017 	ldw	r3,0(r2)
 d035224:	e0bffc17 	ldw	r2,-16(fp)
 d035228:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 d03522c:	e0bffb17 	ldw	r2,-20(fp)
 d035230:	10c00017 	ldw	r3,0(r2)
 d035234:	e0bffc17 	ldw	r2,-16(fp)
 d035238:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 d03523c:	e0fffb17 	ldw	r3,-20(fp)
 d035240:	e0bffc17 	ldw	r2,-16(fp)
 d035244:	18800015 	stw	r2,0(r3)

  return 0;  
 d035248:	e03fff15 	stw	zero,-4(fp)
 d03524c:	e0bfff17 	ldw	r2,-4(fp)
}
 d035250:	e037883a 	mov	sp,fp
 d035254:	dfc00117 	ldw	ra,4(sp)
 d035258:	df000017 	ldw	fp,0(sp)
 d03525c:	dec00204 	addi	sp,sp,8
 d035260:	f800283a 	ret

0d035264 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d035264:	defffd04 	addi	sp,sp,-12
 d035268:	dfc00215 	stw	ra,8(sp)
 d03526c:	df000115 	stw	fp,4(sp)
 d035270:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d035274:	00834174 	movhi	r2,3333
 d035278:	10926504 	addi	r2,r2,18836
 d03527c:	10800017 	ldw	r2,0(r2)
 d035280:	1005003a 	cmpeq	r2,r2,zero
 d035284:	1000061e 	bne	r2,zero,d0352a0 <alt_get_errno+0x3c>
 d035288:	00834174 	movhi	r2,3333
 d03528c:	10926504 	addi	r2,r2,18836
 d035290:	10800017 	ldw	r2,0(r2)
 d035294:	103ee83a 	callr	r2
 d035298:	e0bfff15 	stw	r2,-4(fp)
 d03529c:	00000306 	br	d0352ac <alt_get_errno+0x48>
 d0352a0:	00834174 	movhi	r2,3333
 d0352a4:	109b0104 	addi	r2,r2,27652
 d0352a8:	e0bfff15 	stw	r2,-4(fp)
 d0352ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d0352b0:	e037883a 	mov	sp,fp
 d0352b4:	dfc00117 	ldw	ra,4(sp)
 d0352b8:	df000017 	ldw	fp,0(sp)
 d0352bc:	dec00204 	addi	sp,sp,8
 d0352c0:	f800283a 	ret

0d0352c4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 d0352c4:	defffd04 	addi	sp,sp,-12
 d0352c8:	dfc00215 	stw	ra,8(sp)
 d0352cc:	df000115 	stw	fp,4(sp)
 d0352d0:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 d0352d4:	00bfff04 	movi	r2,-4
 d0352d8:	00c34174 	movhi	r3,3333
 d0352dc:	18f1d904 	addi	r3,r3,-14492
 d0352e0:	1885883a 	add	r2,r3,r2
 d0352e4:	e0bfff15 	stw	r2,-4(fp)
 d0352e8:	00000606 	br	d035304 <_do_ctors+0x40>
        (*ctor) (); 
 d0352ec:	e0bfff17 	ldw	r2,-4(fp)
 d0352f0:	10800017 	ldw	r2,0(r2)
 d0352f4:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 d0352f8:	e0bfff17 	ldw	r2,-4(fp)
 d0352fc:	10bfff04 	addi	r2,r2,-4
 d035300:	e0bfff15 	stw	r2,-4(fp)
 d035304:	e0ffff17 	ldw	r3,-4(fp)
 d035308:	00834174 	movhi	r2,3333
 d03530c:	10b1d804 	addi	r2,r2,-14496
 d035310:	18bff62e 	bgeu	r3,r2,d0352ec <_do_ctors+0x28>
        (*ctor) (); 
}
 d035314:	e037883a 	mov	sp,fp
 d035318:	dfc00117 	ldw	ra,4(sp)
 d03531c:	df000017 	ldw	fp,0(sp)
 d035320:	dec00204 	addi	sp,sp,8
 d035324:	f800283a 	ret

0d035328 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 d035328:	defffd04 	addi	sp,sp,-12
 d03532c:	dfc00215 	stw	ra,8(sp)
 d035330:	df000115 	stw	fp,4(sp)
 d035334:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 d035338:	00bfff04 	movi	r2,-4
 d03533c:	00c34174 	movhi	r3,3333
 d035340:	18f1d904 	addi	r3,r3,-14492
 d035344:	1885883a 	add	r2,r3,r2
 d035348:	e0bfff15 	stw	r2,-4(fp)
 d03534c:	00000606 	br	d035368 <_do_dtors+0x40>
        (*dtor) (); 
 d035350:	e0bfff17 	ldw	r2,-4(fp)
 d035354:	10800017 	ldw	r2,0(r2)
 d035358:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 d03535c:	e0bfff17 	ldw	r2,-4(fp)
 d035360:	10bfff04 	addi	r2,r2,-4
 d035364:	e0bfff15 	stw	r2,-4(fp)
 d035368:	e0ffff17 	ldw	r3,-4(fp)
 d03536c:	00834174 	movhi	r2,3333
 d035370:	10b1d904 	addi	r2,r2,-14492
 d035374:	18bff62e 	bgeu	r3,r2,d035350 <_do_dtors+0x28>
        (*dtor) (); 
}
 d035378:	e037883a 	mov	sp,fp
 d03537c:	dfc00117 	ldw	ra,4(sp)
 d035380:	df000017 	ldw	fp,0(sp)
 d035384:	dec00204 	addi	sp,sp,8
 d035388:	f800283a 	ret

0d03538c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 d03538c:	defff904 	addi	sp,sp,-28
 d035390:	dfc00615 	stw	ra,24(sp)
 d035394:	df000515 	stw	fp,20(sp)
 d035398:	df000504 	addi	fp,sp,20
 d03539c:	e13ffd15 	stw	r4,-12(fp)
 d0353a0:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 d0353a4:	e0bffe17 	ldw	r2,-8(fp)
 d0353a8:	10800017 	ldw	r2,0(r2)
 d0353ac:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 d0353b0:	e13ffd17 	ldw	r4,-12(fp)
 d0353b4:	d0034640 	call	d003464 <strlen>
 d0353b8:	10800044 	addi	r2,r2,1
 d0353bc:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 d0353c0:	00000d06 	br	d0353f8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 d0353c4:	e0bffc17 	ldw	r2,-16(fp)
 d0353c8:	11000217 	ldw	r4,8(r2)
 d0353cc:	e1bffb17 	ldw	r6,-20(fp)
 d0353d0:	e17ffd17 	ldw	r5,-12(fp)
 d0353d4:	d04be440 	call	d04be44 <memcmp>
 d0353d8:	1004c03a 	cmpne	r2,r2,zero
 d0353dc:	1000031e 	bne	r2,zero,d0353ec <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 d0353e0:	e0bffc17 	ldw	r2,-16(fp)
 d0353e4:	e0bfff15 	stw	r2,-4(fp)
 d0353e8:	00000706 	br	d035408 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 d0353ec:	e0bffc17 	ldw	r2,-16(fp)
 d0353f0:	10800017 	ldw	r2,0(r2)
 d0353f4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 d0353f8:	e0fffe17 	ldw	r3,-8(fp)
 d0353fc:	e0bffc17 	ldw	r2,-16(fp)
 d035400:	10fff01e 	bne	r2,r3,d0353c4 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 d035404:	e03fff15 	stw	zero,-4(fp)
 d035408:	e0bfff17 	ldw	r2,-4(fp)
}
 d03540c:	e037883a 	mov	sp,fp
 d035410:	dfc00117 	ldw	ra,4(sp)
 d035414:	df000017 	ldw	fp,0(sp)
 d035418:	dec00204 	addi	sp,sp,8
 d03541c:	f800283a 	ret

0d035420 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 d035420:	defffe04 	addi	sp,sp,-8
 d035424:	dfc00115 	stw	ra,4(sp)
 d035428:	df000015 	stw	fp,0(sp)
 d03542c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 d035430:	0009883a 	mov	r4,zero
 d035434:	01408004 	movi	r5,512
 d035438:	d04aa000 	call	d04aa00 <alt_icache_flush>
#endif
}
 d03543c:	e037883a 	mov	sp,fp
 d035440:	dfc00117 	ldw	ra,4(sp)
 d035444:	df000017 	ldw	fp,0(sp)
 d035448:	dec00204 	addi	sp,sp,8
 d03544c:	f800283a 	ret

0d035450 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 d035450:	defff904 	addi	sp,sp,-28
 d035454:	dfc00615 	stw	ra,24(sp)
 d035458:	df000515 	stw	fp,20(sp)
 d03545c:	df000504 	addi	fp,sp,20
 d035460:	e13ffc15 	stw	r4,-16(fp)
 d035464:	e17ffd15 	stw	r5,-12(fp)
 d035468:	e1bffe15 	stw	r6,-8(fp)
 d03546c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 d035470:	e0800217 	ldw	r2,8(fp)
 d035474:	d8800015 	stw	r2,0(sp)
 d035478:	e13ffc17 	ldw	r4,-16(fp)
 d03547c:	e17ffd17 	ldw	r5,-12(fp)
 d035480:	e1bffe17 	ldw	r6,-8(fp)
 d035484:	e1ffff17 	ldw	r7,-4(fp)
 d035488:	d0356240 	call	d035624 <alt_iic_isr_register>
}  
 d03548c:	e037883a 	mov	sp,fp
 d035490:	dfc00117 	ldw	ra,4(sp)
 d035494:	df000017 	ldw	fp,0(sp)
 d035498:	dec00204 	addi	sp,sp,8
 d03549c:	f800283a 	ret

0d0354a0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 d0354a0:	defff904 	addi	sp,sp,-28
 d0354a4:	df000615 	stw	fp,24(sp)
 d0354a8:	df000604 	addi	fp,sp,24
 d0354ac:	e13ffe15 	stw	r4,-8(fp)
 d0354b0:	e17fff15 	stw	r5,-4(fp)
 d0354b4:	e0bfff17 	ldw	r2,-4(fp)
 d0354b8:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0354bc:	0005303a 	rdctl	r2,status
 d0354c0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0354c4:	e0fffb17 	ldw	r3,-20(fp)
 d0354c8:	00bfff84 	movi	r2,-2
 d0354cc:	1884703a 	and	r2,r3,r2
 d0354d0:	1001703a 	wrctl	status,r2
  
  return context;
 d0354d4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 d0354d8:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 d0354dc:	e0fffc17 	ldw	r3,-16(fp)
 d0354e0:	00800044 	movi	r2,1
 d0354e4:	10c4983a 	sll	r2,r2,r3
 d0354e8:	1007883a 	mov	r3,r2
 d0354ec:	00834174 	movhi	r2,3333
 d0354f0:	109b5404 	addi	r2,r2,27984
 d0354f4:	10800017 	ldw	r2,0(r2)
 d0354f8:	1886b03a 	or	r3,r3,r2
 d0354fc:	00834174 	movhi	r2,3333
 d035500:	109b5404 	addi	r2,r2,27984
 d035504:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 d035508:	00834174 	movhi	r2,3333
 d03550c:	109b5404 	addi	r2,r2,27984
 d035510:	10800017 	ldw	r2,0(r2)
 d035514:	100170fa 	wrctl	ienable,r2
 d035518:	e0bffd17 	ldw	r2,-12(fp)
 d03551c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d035520:	e0bffa17 	ldw	r2,-24(fp)
 d035524:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 d035528:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 d03552c:	e037883a 	mov	sp,fp
 d035530:	df000017 	ldw	fp,0(sp)
 d035534:	dec00104 	addi	sp,sp,4
 d035538:	f800283a 	ret

0d03553c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 d03553c:	defff904 	addi	sp,sp,-28
 d035540:	df000615 	stw	fp,24(sp)
 d035544:	df000604 	addi	fp,sp,24
 d035548:	e13ffe15 	stw	r4,-8(fp)
 d03554c:	e17fff15 	stw	r5,-4(fp)
 d035550:	e0bfff17 	ldw	r2,-4(fp)
 d035554:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d035558:	0005303a 	rdctl	r2,status
 d03555c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d035560:	e0fffb17 	ldw	r3,-20(fp)
 d035564:	00bfff84 	movi	r2,-2
 d035568:	1884703a 	and	r2,r3,r2
 d03556c:	1001703a 	wrctl	status,r2
  
  return context;
 d035570:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 d035574:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 d035578:	e0fffc17 	ldw	r3,-16(fp)
 d03557c:	00800044 	movi	r2,1
 d035580:	10c4983a 	sll	r2,r2,r3
 d035584:	0084303a 	nor	r2,zero,r2
 d035588:	1007883a 	mov	r3,r2
 d03558c:	00834174 	movhi	r2,3333
 d035590:	109b5404 	addi	r2,r2,27984
 d035594:	10800017 	ldw	r2,0(r2)
 d035598:	1886703a 	and	r3,r3,r2
 d03559c:	00834174 	movhi	r2,3333
 d0355a0:	109b5404 	addi	r2,r2,27984
 d0355a4:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 d0355a8:	00834174 	movhi	r2,3333
 d0355ac:	109b5404 	addi	r2,r2,27984
 d0355b0:	10800017 	ldw	r2,0(r2)
 d0355b4:	100170fa 	wrctl	ienable,r2
 d0355b8:	e0bffd17 	ldw	r2,-12(fp)
 d0355bc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0355c0:	e0bffa17 	ldw	r2,-24(fp)
 d0355c4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 d0355c8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 d0355cc:	e037883a 	mov	sp,fp
 d0355d0:	df000017 	ldw	fp,0(sp)
 d0355d4:	dec00104 	addi	sp,sp,4
 d0355d8:	f800283a 	ret

0d0355dc <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 d0355dc:	defffc04 	addi	sp,sp,-16
 d0355e0:	df000315 	stw	fp,12(sp)
 d0355e4:	df000304 	addi	fp,sp,12
 d0355e8:	e13ffe15 	stw	r4,-8(fp)
 d0355ec:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 d0355f0:	000530fa 	rdctl	r2,ienable
 d0355f4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 d0355f8:	e0ffff17 	ldw	r3,-4(fp)
 d0355fc:	00800044 	movi	r2,1
 d035600:	10c4983a 	sll	r2,r2,r3
 d035604:	1007883a 	mov	r3,r2
 d035608:	e0bffd17 	ldw	r2,-12(fp)
 d03560c:	1884703a 	and	r2,r3,r2
 d035610:	1004c03a 	cmpne	r2,r2,zero
}
 d035614:	e037883a 	mov	sp,fp
 d035618:	df000017 	ldw	fp,0(sp)
 d03561c:	dec00104 	addi	sp,sp,4
 d035620:	f800283a 	ret

0d035624 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 d035624:	defff404 	addi	sp,sp,-48
 d035628:	dfc00b15 	stw	ra,44(sp)
 d03562c:	df000a15 	stw	fp,40(sp)
 d035630:	df000a04 	addi	fp,sp,40
 d035634:	e13ffb15 	stw	r4,-20(fp)
 d035638:	e17ffc15 	stw	r5,-16(fp)
 d03563c:	e1bffd15 	stw	r6,-12(fp)
 d035640:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 d035644:	00bffa84 	movi	r2,-22
 d035648:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 d03564c:	e0bffc17 	ldw	r2,-16(fp)
 d035650:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 d035654:	e0bff917 	ldw	r2,-28(fp)
 d035658:	10800808 	cmpgei	r2,r2,32
 d03565c:	1000291e 	bne	r2,zero,d035704 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d035660:	0005303a 	rdctl	r2,status
 d035664:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d035668:	e0fff717 	ldw	r3,-36(fp)
 d03566c:	00bfff84 	movi	r2,-2
 d035670:	1884703a 	and	r2,r3,r2
 d035674:	1001703a 	wrctl	status,r2
  
  return context;
 d035678:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 d03567c:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 d035680:	e0bff917 	ldw	r2,-28(fp)
 d035684:	00c341b4 	movhi	r3,3334
 d035688:	18c4c204 	addi	r3,r3,4872
 d03568c:	100490fa 	slli	r2,r2,3
 d035690:	10c7883a 	add	r3,r2,r3
 d035694:	e0bffd17 	ldw	r2,-12(fp)
 d035698:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 d03569c:	e0bff917 	ldw	r2,-28(fp)
 d0356a0:	00c341b4 	movhi	r3,3334
 d0356a4:	18c4c204 	addi	r3,r3,4872
 d0356a8:	100490fa 	slli	r2,r2,3
 d0356ac:	10c5883a 	add	r2,r2,r3
 d0356b0:	10c00104 	addi	r3,r2,4
 d0356b4:	e0bffe17 	ldw	r2,-8(fp)
 d0356b8:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 d0356bc:	e0bffd17 	ldw	r2,-12(fp)
 d0356c0:	1005003a 	cmpeq	r2,r2,zero
 d0356c4:	1000051e 	bne	r2,zero,d0356dc <alt_iic_isr_register+0xb8>
 d0356c8:	e17ff917 	ldw	r5,-28(fp)
 d0356cc:	e13ffb17 	ldw	r4,-20(fp)
 d0356d0:	d0354a00 	call	d0354a0 <alt_ic_irq_enable>
 d0356d4:	e0bfff15 	stw	r2,-4(fp)
 d0356d8:	00000406 	br	d0356ec <alt_iic_isr_register+0xc8>
 d0356dc:	e17ff917 	ldw	r5,-28(fp)
 d0356e0:	e13ffb17 	ldw	r4,-20(fp)
 d0356e4:	d03553c0 	call	d03553c <alt_ic_irq_disable>
 d0356e8:	e0bfff15 	stw	r2,-4(fp)
 d0356ec:	e0bfff17 	ldw	r2,-4(fp)
 d0356f0:	e0bffa15 	stw	r2,-24(fp)
 d0356f4:	e0bff817 	ldw	r2,-32(fp)
 d0356f8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0356fc:	e0bff617 	ldw	r2,-40(fp)
 d035700:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 d035704:	e0bffa17 	ldw	r2,-24(fp)
}
 d035708:	e037883a 	mov	sp,fp
 d03570c:	dfc00117 	ldw	ra,4(sp)
 d035710:	df000017 	ldw	fp,0(sp)
 d035714:	dec00204 	addi	sp,sp,8
 d035718:	f800283a 	ret

0d03571c <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 d03571c:	defff804 	addi	sp,sp,-32
 d035720:	dfc00715 	stw	ra,28(sp)
 d035724:	df000615 	stw	fp,24(sp)
 d035728:	dc000515 	stw	r16,20(sp)
 d03572c:	df000504 	addi	fp,sp,20
 d035730:	e13ffc15 	stw	r4,-16(fp)
 d035734:	e17ffd15 	stw	r5,-12(fp)
 d035738:	e1bffe15 	stw	r6,-8(fp)
 d03573c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 d035740:	e13ffd17 	ldw	r4,-12(fp)
 d035744:	e17ffe17 	ldw	r5,-8(fp)
 d035748:	e1bfff17 	ldw	r6,-4(fp)
 d03574c:	d0359640 	call	d035964 <open>
 d035750:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 d035754:	e0bffb17 	ldw	r2,-20(fp)
 d035758:	1004803a 	cmplt	r2,r2,zero
 d03575c:	10001f1e 	bne	r2,zero,d0357dc <alt_open_fd+0xc0>
  {
    fd->dev      = alt_fd_list[old].dev;
 d035760:	e13ffb17 	ldw	r4,-20(fp)
 d035764:	04034174 	movhi	r16,3333
 d035768:	84115b04 	addi	r16,r16,17772
 d03576c:	01400304 	movi	r5,12
 d035770:	d00235c0 	call	d00235c <__mulsi3>
 d035774:	1405883a 	add	r2,r2,r16
 d035778:	10c00017 	ldw	r3,0(r2)
 d03577c:	e0bffc17 	ldw	r2,-16(fp)
 d035780:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 d035784:	e13ffb17 	ldw	r4,-20(fp)
 d035788:	04034174 	movhi	r16,3333
 d03578c:	84115b04 	addi	r16,r16,17772
 d035790:	01400304 	movi	r5,12
 d035794:	d00235c0 	call	d00235c <__mulsi3>
 d035798:	1405883a 	add	r2,r2,r16
 d03579c:	10800104 	addi	r2,r2,4
 d0357a0:	10c00017 	ldw	r3,0(r2)
 d0357a4:	e0bffc17 	ldw	r2,-16(fp)
 d0357a8:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 d0357ac:	e13ffb17 	ldw	r4,-20(fp)
 d0357b0:	04034174 	movhi	r16,3333
 d0357b4:	84115b04 	addi	r16,r16,17772
 d0357b8:	01400304 	movi	r5,12
 d0357bc:	d00235c0 	call	d00235c <__mulsi3>
 d0357c0:	1405883a 	add	r2,r2,r16
 d0357c4:	10800204 	addi	r2,r2,8
 d0357c8:	10c00017 	ldw	r3,0(r2)
 d0357cc:	e0bffc17 	ldw	r2,-16(fp)
 d0357d0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 d0357d4:	e13ffb17 	ldw	r4,-20(fp)
 d0357d8:	d035cd40 	call	d035cd4 <alt_release_fd>
  }
} 
 d0357dc:	e037883a 	mov	sp,fp
 d0357e0:	dfc00217 	ldw	ra,8(sp)
 d0357e4:	df000117 	ldw	fp,4(sp)
 d0357e8:	dc000017 	ldw	r16,0(sp)
 d0357ec:	dec00304 	addi	sp,sp,12
 d0357f0:	f800283a 	ret

0d0357f4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 d0357f4:	defffb04 	addi	sp,sp,-20
 d0357f8:	dfc00415 	stw	ra,16(sp)
 d0357fc:	df000315 	stw	fp,12(sp)
 d035800:	df000304 	addi	fp,sp,12
 d035804:	e13ffd15 	stw	r4,-12(fp)
 d035808:	e17ffe15 	stw	r5,-8(fp)
 d03580c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 d035810:	01034174 	movhi	r4,3333
 d035814:	21115e04 	addi	r4,r4,17784
 d035818:	e17ffd17 	ldw	r5,-12(fp)
 d03581c:	01800044 	movi	r6,1
 d035820:	01c07fc4 	movi	r7,511
 d035824:	d03571c0 	call	d03571c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 d035828:	01034174 	movhi	r4,3333
 d03582c:	21115b04 	addi	r4,r4,17772
 d035830:	e17ffe17 	ldw	r5,-8(fp)
 d035834:	000d883a 	mov	r6,zero
 d035838:	01c07fc4 	movi	r7,511
 d03583c:	d03571c0 	call	d03571c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 d035840:	01034174 	movhi	r4,3333
 d035844:	21116104 	addi	r4,r4,17796
 d035848:	e17fff17 	ldw	r5,-4(fp)
 d03584c:	01800044 	movi	r6,1
 d035850:	01c07fc4 	movi	r7,511
 d035854:	d03571c0 	call	d03571c <alt_open_fd>
}  
 d035858:	e037883a 	mov	sp,fp
 d03585c:	dfc00117 	ldw	ra,4(sp)
 d035860:	df000017 	ldw	fp,0(sp)
 d035864:	dec00204 	addi	sp,sp,8
 d035868:	f800283a 	ret

0d03586c <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 d03586c:	defffa04 	addi	sp,sp,-24
 d035870:	dfc00515 	stw	ra,20(sp)
 d035874:	df000415 	stw	fp,16(sp)
 d035878:	dc000315 	stw	r16,12(sp)
 d03587c:	df000304 	addi	fp,sp,12
 d035880:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 d035884:	e0bffe17 	ldw	r2,-8(fp)
 d035888:	10800217 	ldw	r2,8(r2)
 d03588c:	10d00034 	orhi	r3,r2,16384
 d035890:	e0bffe17 	ldw	r2,-8(fp)
 d035894:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 d035898:	e03ffd15 	stw	zero,-12(fp)
 d03589c:	00002306 	br	d03592c <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 d0358a0:	e13ffd17 	ldw	r4,-12(fp)
 d0358a4:	04034174 	movhi	r16,3333
 d0358a8:	84115b04 	addi	r16,r16,17772
 d0358ac:	01400304 	movi	r5,12
 d0358b0:	d00235c0 	call	d00235c <__mulsi3>
 d0358b4:	1405883a 	add	r2,r2,r16
 d0358b8:	10c00017 	ldw	r3,0(r2)
 d0358bc:	e0bffe17 	ldw	r2,-8(fp)
 d0358c0:	10800017 	ldw	r2,0(r2)
 d0358c4:	1880161e 	bne	r3,r2,d035920 <alt_file_locked+0xb4>
 d0358c8:	e13ffd17 	ldw	r4,-12(fp)
 d0358cc:	04034174 	movhi	r16,3333
 d0358d0:	84115b04 	addi	r16,r16,17772
 d0358d4:	01400304 	movi	r5,12
 d0358d8:	d00235c0 	call	d00235c <__mulsi3>
 d0358dc:	1405883a 	add	r2,r2,r16
 d0358e0:	10800204 	addi	r2,r2,8
 d0358e4:	10800017 	ldw	r2,0(r2)
 d0358e8:	1004403a 	cmpge	r2,r2,zero
 d0358ec:	10000c1e 	bne	r2,zero,d035920 <alt_file_locked+0xb4>
 d0358f0:	e13ffd17 	ldw	r4,-12(fp)
 d0358f4:	01400304 	movi	r5,12
 d0358f8:	d00235c0 	call	d00235c <__mulsi3>
 d0358fc:	1007883a 	mov	r3,r2
 d035900:	00834174 	movhi	r2,3333
 d035904:	10915b04 	addi	r2,r2,17772
 d035908:	1887883a 	add	r3,r3,r2
 d03590c:	e0bffe17 	ldw	r2,-8(fp)
 d035910:	18800326 	beq	r3,r2,d035920 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 d035914:	00bffcc4 	movi	r2,-13
 d035918:	e0bfff15 	stw	r2,-4(fp)
 d03591c:	00000a06 	br	d035948 <alt_file_locked+0xdc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 d035920:	e0bffd17 	ldw	r2,-12(fp)
 d035924:	10800044 	addi	r2,r2,1
 d035928:	e0bffd15 	stw	r2,-12(fp)
 d03592c:	00834174 	movhi	r2,3333
 d035930:	10926404 	addi	r2,r2,18832
 d035934:	10800017 	ldw	r2,0(r2)
 d035938:	1007883a 	mov	r3,r2
 d03593c:	e0bffd17 	ldw	r2,-12(fp)
 d035940:	18bfd72e 	bgeu	r3,r2,d0358a0 <alt_file_locked+0x34>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 d035944:	e03fff15 	stw	zero,-4(fp)
 d035948:	e0bfff17 	ldw	r2,-4(fp)
}
 d03594c:	e037883a 	mov	sp,fp
 d035950:	dfc00217 	ldw	ra,8(sp)
 d035954:	df000117 	ldw	fp,4(sp)
 d035958:	dc000017 	ldw	r16,0(sp)
 d03595c:	dec00304 	addi	sp,sp,12
 d035960:	f800283a 	ret

0d035964 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 d035964:	defff404 	addi	sp,sp,-48
 d035968:	dfc00b15 	stw	ra,44(sp)
 d03596c:	df000a15 	stw	fp,40(sp)
 d035970:	df000a04 	addi	fp,sp,40
 d035974:	e13ffb15 	stw	r4,-20(fp)
 d035978:	e17ffc15 	stw	r5,-16(fp)
 d03597c:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 d035980:	00bfffc4 	movi	r2,-1
 d035984:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 d035988:	00bffb44 	movi	r2,-19
 d03598c:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 d035990:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 d035994:	e13ffb17 	ldw	r4,-20(fp)
 d035998:	01434174 	movhi	r5,3333
 d03599c:	29526204 	addi	r5,r5,18824
 d0359a0:	d03538c0 	call	d03538c <alt_find_dev>
 d0359a4:	e0bffa15 	stw	r2,-24(fp)
 d0359a8:	e0bffa17 	ldw	r2,-24(fp)
 d0359ac:	1004c03a 	cmpne	r2,r2,zero
 d0359b0:	1000051e 	bne	r2,zero,d0359c8 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 d0359b4:	e13ffb17 	ldw	r4,-20(fp)
 d0359b8:	d04a7dc0 	call	d04a7dc <alt_find_file>
 d0359bc:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 d0359c0:	00800044 	movi	r2,1
 d0359c4:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 d0359c8:	e0bffa17 	ldw	r2,-24(fp)
 d0359cc:	1005003a 	cmpeq	r2,r2,zero
 d0359d0:	1000311e 	bne	r2,zero,d035a98 <open+0x134>
  {
    if ((index = alt_get_fd (dev)) < 0)
 d0359d4:	e13ffa17 	ldw	r4,-24(fp)
 d0359d8:	d04a8fc0 	call	d04a8fc <alt_get_fd>
 d0359dc:	e0bff815 	stw	r2,-32(fp)
 d0359e0:	e0bff817 	ldw	r2,-32(fp)
 d0359e4:	1004403a 	cmpge	r2,r2,zero
 d0359e8:	1000031e 	bne	r2,zero,d0359f8 <open+0x94>
    {
      status = index;
 d0359ec:	e0bff817 	ldw	r2,-32(fp)
 d0359f0:	e0bff715 	stw	r2,-36(fp)
 d0359f4:	00002a06 	br	d035aa0 <open+0x13c>
    }
    else
    {
      fd = &alt_fd_list[index];
 d0359f8:	e13ff817 	ldw	r4,-32(fp)
 d0359fc:	01400304 	movi	r5,12
 d035a00:	d00235c0 	call	d00235c <__mulsi3>
 d035a04:	1007883a 	mov	r3,r2
 d035a08:	00834174 	movhi	r2,3333
 d035a0c:	10915b04 	addi	r2,r2,17772
 d035a10:	1885883a 	add	r2,r3,r2
 d035a14:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 d035a18:	e0fffc17 	ldw	r3,-16(fp)
 d035a1c:	00900034 	movhi	r2,16384
 d035a20:	10bfffc4 	addi	r2,r2,-1
 d035a24:	1886703a 	and	r3,r3,r2
 d035a28:	e0bff917 	ldw	r2,-28(fp)
 d035a2c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 d035a30:	e0bff617 	ldw	r2,-40(fp)
 d035a34:	1004c03a 	cmpne	r2,r2,zero
 d035a38:	1000061e 	bne	r2,zero,d035a54 <open+0xf0>
 d035a3c:	e13ff917 	ldw	r4,-28(fp)
 d035a40:	d03586c0 	call	d03586c <alt_file_locked>
 d035a44:	e0bff715 	stw	r2,-36(fp)
 d035a48:	e0bff717 	ldw	r2,-36(fp)
 d035a4c:	1004803a 	cmplt	r2,r2,zero
 d035a50:	1000131e 	bne	r2,zero,d035aa0 <open+0x13c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 d035a54:	e0bffa17 	ldw	r2,-24(fp)
 d035a58:	10800317 	ldw	r2,12(r2)
 d035a5c:	1005003a 	cmpeq	r2,r2,zero
 d035a60:	1000091e 	bne	r2,zero,d035a88 <open+0x124>
 d035a64:	e0bffa17 	ldw	r2,-24(fp)
 d035a68:	10800317 	ldw	r2,12(r2)
 d035a6c:	e13ff917 	ldw	r4,-28(fp)
 d035a70:	e17ffb17 	ldw	r5,-20(fp)
 d035a74:	e1bffc17 	ldw	r6,-16(fp)
 d035a78:	e1fffd17 	ldw	r7,-12(fp)
 d035a7c:	103ee83a 	callr	r2
 d035a80:	e0bfff15 	stw	r2,-4(fp)
 d035a84:	00000106 	br	d035a8c <open+0x128>
 d035a88:	e03fff15 	stw	zero,-4(fp)
 d035a8c:	e0bfff17 	ldw	r2,-4(fp)
 d035a90:	e0bff715 	stw	r2,-36(fp)
 d035a94:	00000206 	br	d035aa0 <open+0x13c>
      }
    }
  }
  else
  {
    status = -ENODEV;
 d035a98:	00bffb44 	movi	r2,-19
 d035a9c:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 d035aa0:	e0bff717 	ldw	r2,-36(fp)
 d035aa4:	1004403a 	cmpge	r2,r2,zero
 d035aa8:	1000091e 	bne	r2,zero,d035ad0 <open+0x16c>
  {
    alt_release_fd (index);  
 d035aac:	e13ff817 	ldw	r4,-32(fp)
 d035ab0:	d035cd40 	call	d035cd4 <alt_release_fd>
    ALT_ERRNO = -status;
 d035ab4:	d035af00 	call	d035af0 <alt_get_errno>
 d035ab8:	e0fff717 	ldw	r3,-36(fp)
 d035abc:	00c7c83a 	sub	r3,zero,r3
 d035ac0:	10c00015 	stw	r3,0(r2)
    return -1;
 d035ac4:	00bfffc4 	movi	r2,-1
 d035ac8:	e0bffe15 	stw	r2,-8(fp)
 d035acc:	00000206 	br	d035ad8 <open+0x174>
  }
  
  /* return the reference upon success */

  return index;
 d035ad0:	e0bff817 	ldw	r2,-32(fp)
 d035ad4:	e0bffe15 	stw	r2,-8(fp)
 d035ad8:	e0bffe17 	ldw	r2,-8(fp)
}
 d035adc:	e037883a 	mov	sp,fp
 d035ae0:	dfc00117 	ldw	ra,4(sp)
 d035ae4:	df000017 	ldw	fp,0(sp)
 d035ae8:	dec00204 	addi	sp,sp,8
 d035aec:	f800283a 	ret

0d035af0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d035af0:	defffd04 	addi	sp,sp,-12
 d035af4:	dfc00215 	stw	ra,8(sp)
 d035af8:	df000115 	stw	fp,4(sp)
 d035afc:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d035b00:	00834174 	movhi	r2,3333
 d035b04:	10926504 	addi	r2,r2,18836
 d035b08:	10800017 	ldw	r2,0(r2)
 d035b0c:	1005003a 	cmpeq	r2,r2,zero
 d035b10:	1000061e 	bne	r2,zero,d035b2c <alt_get_errno+0x3c>
 d035b14:	00834174 	movhi	r2,3333
 d035b18:	10926504 	addi	r2,r2,18836
 d035b1c:	10800017 	ldw	r2,0(r2)
 d035b20:	103ee83a 	callr	r2
 d035b24:	e0bfff15 	stw	r2,-4(fp)
 d035b28:	00000306 	br	d035b38 <alt_get_errno+0x48>
 d035b2c:	00834174 	movhi	r2,3333
 d035b30:	109b0104 	addi	r2,r2,27652
 d035b34:	e0bfff15 	stw	r2,-4(fp)
 d035b38:	e0bfff17 	ldw	r2,-4(fp)
}
 d035b3c:	e037883a 	mov	sp,fp
 d035b40:	dfc00117 	ldw	ra,4(sp)
 d035b44:	df000017 	ldw	fp,0(sp)
 d035b48:	dec00204 	addi	sp,sp,8
 d035b4c:	f800283a 	ret

0d035b50 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 d035b50:	defff704 	addi	sp,sp,-36
 d035b54:	dfc00815 	stw	ra,32(sp)
 d035b58:	df000715 	stw	fp,28(sp)
 d035b5c:	df000704 	addi	fp,sp,28
 d035b60:	e13ffb15 	stw	r4,-20(fp)
 d035b64:	e17ffc15 	stw	r5,-16(fp)
 d035b68:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d035b6c:	e0bffb17 	ldw	r2,-20(fp)
 d035b70:	1004803a 	cmplt	r2,r2,zero
 d035b74:	1000091e 	bne	r2,zero,d035b9c <alt_read+0x4c>
 d035b78:	e13ffb17 	ldw	r4,-20(fp)
 d035b7c:	01400304 	movi	r5,12
 d035b80:	d00235c0 	call	d00235c <__mulsi3>
 d035b84:	1007883a 	mov	r3,r2
 d035b88:	00834174 	movhi	r2,3333
 d035b8c:	10915b04 	addi	r2,r2,17772
 d035b90:	1887883a 	add	r3,r3,r2
 d035b94:	e0ffff15 	stw	r3,-4(fp)
 d035b98:	00000106 	br	d035ba0 <alt_read+0x50>
 d035b9c:	e03fff15 	stw	zero,-4(fp)
 d035ba0:	e0bfff17 	ldw	r2,-4(fp)
 d035ba4:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 d035ba8:	e0bffa17 	ldw	r2,-24(fp)
 d035bac:	1005003a 	cmpeq	r2,r2,zero
 d035bb0:	1000241e 	bne	r2,zero,d035c44 <alt_read+0xf4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 d035bb4:	e0bffa17 	ldw	r2,-24(fp)
 d035bb8:	10800217 	ldw	r2,8(r2)
 d035bbc:	108000cc 	andi	r2,r2,3
 d035bc0:	10800060 	cmpeqi	r2,r2,1
 d035bc4:	10001a1e 	bne	r2,zero,d035c30 <alt_read+0xe0>
 d035bc8:	e0bffa17 	ldw	r2,-24(fp)
 d035bcc:	10800017 	ldw	r2,0(r2)
 d035bd0:	10800517 	ldw	r2,20(r2)
 d035bd4:	1005003a 	cmpeq	r2,r2,zero
 d035bd8:	1000151e 	bne	r2,zero,d035c30 <alt_read+0xe0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 d035bdc:	e0bffa17 	ldw	r2,-24(fp)
 d035be0:	10800017 	ldw	r2,0(r2)
 d035be4:	10800517 	ldw	r2,20(r2)
 d035be8:	e17ffc17 	ldw	r5,-16(fp)
 d035bec:	e1bffd17 	ldw	r6,-12(fp)
 d035bf0:	e13ffa17 	ldw	r4,-24(fp)
 d035bf4:	103ee83a 	callr	r2
 d035bf8:	e0bff915 	stw	r2,-28(fp)
 d035bfc:	e0bff917 	ldw	r2,-28(fp)
 d035c00:	1004403a 	cmpge	r2,r2,zero
 d035c04:	1000071e 	bne	r2,zero,d035c24 <alt_read+0xd4>
        {
          ALT_ERRNO = -rval;
 d035c08:	d035c740 	call	d035c74 <alt_get_errno>
 d035c0c:	e0fff917 	ldw	r3,-28(fp)
 d035c10:	00c7c83a 	sub	r3,zero,r3
 d035c14:	10c00015 	stw	r3,0(r2)
          return -1;
 d035c18:	00bfffc4 	movi	r2,-1
 d035c1c:	e0bffe15 	stw	r2,-8(fp)
 d035c20:	00000e06 	br	d035c5c <alt_read+0x10c>
        }
        return rval;
 d035c24:	e0bff917 	ldw	r2,-28(fp)
 d035c28:	e0bffe15 	stw	r2,-8(fp)
 d035c2c:	00000b06 	br	d035c5c <alt_read+0x10c>
      }
      else
      {
        ALT_ERRNO = EACCES;
 d035c30:	d035c740 	call	d035c74 <alt_get_errno>
 d035c34:	1007883a 	mov	r3,r2
 d035c38:	00800344 	movi	r2,13
 d035c3c:	18800015 	stw	r2,0(r3)
 d035c40:	00000406 	br	d035c54 <alt_read+0x104>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 d035c44:	d035c740 	call	d035c74 <alt_get_errno>
 d035c48:	1007883a 	mov	r3,r2
 d035c4c:	00801444 	movi	r2,81
 d035c50:	18800015 	stw	r2,0(r3)
  }
  return -1;
 d035c54:	00bfffc4 	movi	r2,-1
 d035c58:	e0bffe15 	stw	r2,-8(fp)
 d035c5c:	e0bffe17 	ldw	r2,-8(fp)
}
 d035c60:	e037883a 	mov	sp,fp
 d035c64:	dfc00117 	ldw	ra,4(sp)
 d035c68:	df000017 	ldw	fp,0(sp)
 d035c6c:	dec00204 	addi	sp,sp,8
 d035c70:	f800283a 	ret

0d035c74 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d035c74:	defffd04 	addi	sp,sp,-12
 d035c78:	dfc00215 	stw	ra,8(sp)
 d035c7c:	df000115 	stw	fp,4(sp)
 d035c80:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d035c84:	00834174 	movhi	r2,3333
 d035c88:	10926504 	addi	r2,r2,18836
 d035c8c:	10800017 	ldw	r2,0(r2)
 d035c90:	1005003a 	cmpeq	r2,r2,zero
 d035c94:	1000061e 	bne	r2,zero,d035cb0 <alt_get_errno+0x3c>
 d035c98:	00834174 	movhi	r2,3333
 d035c9c:	10926504 	addi	r2,r2,18836
 d035ca0:	10800017 	ldw	r2,0(r2)
 d035ca4:	103ee83a 	callr	r2
 d035ca8:	e0bfff15 	stw	r2,-4(fp)
 d035cac:	00000306 	br	d035cbc <alt_get_errno+0x48>
 d035cb0:	00834174 	movhi	r2,3333
 d035cb4:	109b0104 	addi	r2,r2,27652
 d035cb8:	e0bfff15 	stw	r2,-4(fp)
 d035cbc:	e0bfff17 	ldw	r2,-4(fp)
}
 d035cc0:	e037883a 	mov	sp,fp
 d035cc4:	dfc00117 	ldw	ra,4(sp)
 d035cc8:	df000017 	ldw	fp,0(sp)
 d035ccc:	dec00204 	addi	sp,sp,8
 d035cd0:	f800283a 	ret

0d035cd4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 d035cd4:	defffc04 	addi	sp,sp,-16
 d035cd8:	dfc00315 	stw	ra,12(sp)
 d035cdc:	df000215 	stw	fp,8(sp)
 d035ce0:	dc000115 	stw	r16,4(sp)
 d035ce4:	df000104 	addi	fp,sp,4
 d035ce8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 d035cec:	e0bfff17 	ldw	r2,-4(fp)
 d035cf0:	108000d0 	cmplti	r2,r2,3
 d035cf4:	10000f1e 	bne	r2,zero,d035d34 <alt_release_fd+0x60>
  {
    alt_fd_list[fd].fd_flags = 0;
 d035cf8:	e13fff17 	ldw	r4,-4(fp)
 d035cfc:	04034174 	movhi	r16,3333
 d035d00:	84115b04 	addi	r16,r16,17772
 d035d04:	01400304 	movi	r5,12
 d035d08:	d00235c0 	call	d00235c <__mulsi3>
 d035d0c:	1405883a 	add	r2,r2,r16
 d035d10:	10800204 	addi	r2,r2,8
 d035d14:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 d035d18:	e13fff17 	ldw	r4,-4(fp)
 d035d1c:	04034174 	movhi	r16,3333
 d035d20:	84115b04 	addi	r16,r16,17772
 d035d24:	01400304 	movi	r5,12
 d035d28:	d00235c0 	call	d00235c <__mulsi3>
 d035d2c:	1405883a 	add	r2,r2,r16
 d035d30:	10000015 	stw	zero,0(r2)
  }
}
 d035d34:	e037883a 	mov	sp,fp
 d035d38:	dfc00217 	ldw	ra,8(sp)
 d035d3c:	df000117 	ldw	fp,4(sp)
 d035d40:	dc000017 	ldw	r16,0(sp)
 d035d44:	dec00304 	addi	sp,sp,12
 d035d48:	f800283a 	ret

0d035d4c <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 d035d4c:	defffd04 	addi	sp,sp,-12
 d035d50:	df000215 	stw	fp,8(sp)
 d035d54:	df000204 	addi	fp,sp,8
 d035d58:	e13ffe15 	stw	r4,-8(fp)
 d035d5c:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 d035d60:	e0bffe17 	ldw	r2,-8(fp)
 d035d64:	1007883a 	mov	r3,r2
 d035d68:	00a00034 	movhi	r2,32768
 d035d6c:	10bfffc4 	addi	r2,r2,-1
 d035d70:	1884703a 	and	r2,r3,r2
}
 d035d74:	e037883a 	mov	sp,fp
 d035d78:	df000017 	ldw	fp,0(sp)
 d035d7c:	dec00104 	addi	sp,sp,4
 d035d80:	f800283a 	ret

0d035d84 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 d035d84:	defffc04 	addi	sp,sp,-16
 d035d88:	dfc00315 	stw	ra,12(sp)
 d035d8c:	df000215 	stw	fp,8(sp)
 d035d90:	df000204 	addi	fp,sp,8
 d035d94:	e13ffe15 	stw	r4,-8(fp)
 d035d98:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 d035d9c:	e13ffe17 	ldw	r4,-8(fp)
 d035da0:	e17fff17 	ldw	r5,-4(fp)
 d035da4:	d0351440 	call	d035144 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 d035da8:	e0bffe17 	ldw	r2,-8(fp)
 d035dac:	10a00034 	orhi	r2,r2,32768
}
 d035db0:	e037883a 	mov	sp,fp
 d035db4:	dfc00117 	ldw	ra,4(sp)
 d035db8:	df000017 	ldw	fp,0(sp)
 d035dbc:	dec00204 	addi	sp,sp,8
 d035dc0:	f800283a 	ret

0d035dc4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 d035dc4:	defffa04 	addi	sp,sp,-24
 d035dc8:	df000515 	stw	fp,20(sp)
 d035dcc:	df000504 	addi	fp,sp,20
 d035dd0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d035dd4:	0005303a 	rdctl	r2,status
 d035dd8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d035ddc:	e0fffd17 	ldw	r3,-12(fp)
 d035de0:	00bfff84 	movi	r2,-2
 d035de4:	1884703a 	and	r2,r3,r2
 d035de8:	1001703a 	wrctl	status,r2
  
  return context;
 d035dec:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 d035df0:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 d035df4:	e0bfff17 	ldw	r2,-4(fp)
 d035df8:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 d035dfc:	e0bffc17 	ldw	r2,-16(fp)
 d035e00:	10c00017 	ldw	r3,0(r2)
 d035e04:	e0bffc17 	ldw	r2,-16(fp)
 d035e08:	10800117 	ldw	r2,4(r2)
 d035e0c:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 d035e10:	e0bffc17 	ldw	r2,-16(fp)
 d035e14:	10c00117 	ldw	r3,4(r2)
 d035e18:	e0bffc17 	ldw	r2,-16(fp)
 d035e1c:	10800017 	ldw	r2,0(r2)
 d035e20:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 d035e24:	e0fffc17 	ldw	r3,-16(fp)
 d035e28:	e0bffc17 	ldw	r2,-16(fp)
 d035e2c:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 d035e30:	e0fffc17 	ldw	r3,-16(fp)
 d035e34:	e0bffc17 	ldw	r2,-16(fp)
 d035e38:	18800015 	stw	r2,0(r3)
 d035e3c:	e0bffe17 	ldw	r2,-8(fp)
 d035e40:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d035e44:	e0bffb17 	ldw	r2,-20(fp)
 d035e48:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 d035e4c:	e037883a 	mov	sp,fp
 d035e50:	df000017 	ldw	fp,0(sp)
 d035e54:	dec00104 	addi	sp,sp,4
 d035e58:	f800283a 	ret

0d035e5c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 d035e5c:	defffb04 	addi	sp,sp,-20
 d035e60:	dfc00415 	stw	ra,16(sp)
 d035e64:	df000315 	stw	fp,12(sp)
 d035e68:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 d035e6c:	d0a04817 	ldw	r2,-32480(gp)
 d035e70:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 d035e74:	d0a93717 	ldw	r2,-23332(gp)
 d035e78:	10800044 	addi	r2,r2,1
 d035e7c:	d0a93715 	stw	r2,-23332(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 d035e80:	00003106 	br	d035f48 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 d035e84:	e0bffe17 	ldw	r2,-8(fp)
 d035e88:	10800017 	ldw	r2,0(r2)
 d035e8c:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 d035e90:	e0bffe17 	ldw	r2,-8(fp)
 d035e94:	10800403 	ldbu	r2,16(r2)
 d035e98:	10803fcc 	andi	r2,r2,255
 d035e9c:	1005003a 	cmpeq	r2,r2,zero
 d035ea0:	1000051e 	bne	r2,zero,d035eb8 <alt_tick+0x5c>
 d035ea4:	d0a93717 	ldw	r2,-23332(gp)
 d035ea8:	1004c03a 	cmpne	r2,r2,zero
 d035eac:	1000021e 	bne	r2,zero,d035eb8 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 d035eb0:	e0bffe17 	ldw	r2,-8(fp)
 d035eb4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 d035eb8:	e0bffe17 	ldw	r2,-8(fp)
 d035ebc:	10c00217 	ldw	r3,8(r2)
 d035ec0:	d0a93717 	ldw	r2,-23332(gp)
 d035ec4:	10c01e36 	bltu	r2,r3,d035f40 <alt_tick+0xe4>
 d035ec8:	e0bffe17 	ldw	r2,-8(fp)
 d035ecc:	10800403 	ldbu	r2,16(r2)
 d035ed0:	10803fcc 	andi	r2,r2,255
 d035ed4:	1004c03a 	cmpne	r2,r2,zero
 d035ed8:	1000191e 	bne	r2,zero,d035f40 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 d035edc:	e0bffe17 	ldw	r2,-8(fp)
 d035ee0:	10c00317 	ldw	r3,12(r2)
 d035ee4:	e0bffe17 	ldw	r2,-8(fp)
 d035ee8:	11000517 	ldw	r4,20(r2)
 d035eec:	183ee83a 	callr	r3
 d035ef0:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 d035ef4:	e0bffd17 	ldw	r2,-12(fp)
 d035ef8:	1004c03a 	cmpne	r2,r2,zero
 d035efc:	1000031e 	bne	r2,zero,d035f0c <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 d035f00:	e13ffe17 	ldw	r4,-8(fp)
 d035f04:	d035dc40 	call	d035dc4 <alt_alarm_stop>
 d035f08:	00000d06 	br	d035f40 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 d035f0c:	e0bffe17 	ldw	r2,-8(fp)
 d035f10:	10c00217 	ldw	r3,8(r2)
 d035f14:	e0bffd17 	ldw	r2,-12(fp)
 d035f18:	1887883a 	add	r3,r3,r2
 d035f1c:	e0bffe17 	ldw	r2,-8(fp)
 d035f20:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 d035f24:	e0bffe17 	ldw	r2,-8(fp)
 d035f28:	10c00217 	ldw	r3,8(r2)
 d035f2c:	d0a93717 	ldw	r2,-23332(gp)
 d035f30:	1880032e 	bgeu	r3,r2,d035f40 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 d035f34:	e0fffe17 	ldw	r3,-8(fp)
 d035f38:	00800044 	movi	r2,1
 d035f3c:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 d035f40:	e0bfff17 	ldw	r2,-4(fp)
 d035f44:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 d035f48:	d0e04804 	addi	r3,gp,-32480
 d035f4c:	e0bffe17 	ldw	r2,-8(fp)
 d035f50:	10ffcc1e 	bne	r2,r3,d035e84 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 d035f54:	d00e7280 	call	d00e728 <OSTimeTick>
}
 d035f58:	e037883a 	mov	sp,fp
 d035f5c:	dfc00117 	ldw	ra,4(sp)
 d035f60:	df000017 	ldw	fp,0(sp)
 d035f64:	dec00204 	addi	sp,sp,8
 d035f68:	f800283a 	ret

0d035f6c <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 d035f6c:	defffb04 	addi	sp,sp,-20
 d035f70:	dfc00415 	stw	ra,16(sp)
 d035f74:	df000315 	stw	fp,12(sp)
 d035f78:	df000304 	addi	fp,sp,12
 d035f7c:	e13ffe15 	stw	r4,-8(fp)
  void* ptr;

  ptr = malloc (size);
 d035f80:	e13ffe17 	ldw	r4,-8(fp)
 d035f84:	d04be300 	call	d04be30 <malloc>
 d035f88:	e0bffd15 	stw	r2,-12(fp)

  alt_dcache_flush (ptr, size);
 d035f8c:	e13ffd17 	ldw	r4,-12(fp)
 d035f90:	e17ffe17 	ldw	r5,-8(fp)
 d035f94:	d0351440 	call	d035144 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 d035f98:	e0bffd17 	ldw	r2,-12(fp)
 d035f9c:	1005003a 	cmpeq	r2,r2,zero
 d035fa0:	1000041e 	bne	r2,zero,d035fb4 <alt_uncached_malloc+0x48>
 d035fa4:	e0bffd17 	ldw	r2,-12(fp)
 d035fa8:	10a00034 	orhi	r2,r2,32768
 d035fac:	e0bfff15 	stw	r2,-4(fp)
 d035fb0:	00000106 	br	d035fb8 <alt_uncached_malloc+0x4c>
 d035fb4:	e03fff15 	stw	zero,-4(fp)
 d035fb8:	e0bfff17 	ldw	r2,-4(fp)
}
 d035fbc:	e037883a 	mov	sp,fp
 d035fc0:	dfc00117 	ldw	ra,4(sp)
 d035fc4:	df000017 	ldw	fp,0(sp)
 d035fc8:	dec00204 	addi	sp,sp,8
 d035fcc:	f800283a 	ret

0d035fd0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 d035fd0:	defff904 	addi	sp,sp,-28
 d035fd4:	dfc00615 	stw	ra,24(sp)
 d035fd8:	df000515 	stw	fp,20(sp)
 d035fdc:	dc000415 	stw	r16,16(sp)
 d035fe0:	df000404 	addi	fp,sp,16
 d035fe4:	e13ffe15 	stw	r4,-8(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 d035fe8:	00834174 	movhi	r2,3333
 d035fec:	109b0944 	addi	r2,r2,27685
 d035ff0:	10800003 	ldbu	r2,0(r2)
 d035ff4:	10803fcc 	andi	r2,r2,255
 d035ff8:	1004c03a 	cmpne	r2,r2,zero
 d035ffc:	1000041e 	bne	r2,zero,d036010 <usleep+0x40>
  {
    return alt_busy_sleep (us);
 d036000:	e13ffe17 	ldw	r4,-8(fp)
 d036004:	d04a4c80 	call	d04a4c8 <alt_busy_sleep>
 d036008:	e0bfff15 	stw	r2,-4(fp)
 d03600c:	00003106 	br	d0360d4 <usleep+0x104>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 d036010:	00834174 	movhi	r2,3333
 d036014:	109b5504 	addi	r2,r2,27988
 d036018:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 d03601c:	e0bffc15 	stw	r2,-16(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 d036020:	e13ffe17 	ldw	r4,-8(fp)
 d036024:	014003f4 	movhi	r5,15
 d036028:	29509004 	addi	r5,r5,16960
 d03602c:	d00c90c0 	call	d00c90c <__udivsi3>
 d036030:	1009883a 	mov	r4,r2
 d036034:	e17ffc17 	ldw	r5,-16(fp)
 d036038:	d00235c0 	call	d00235c <__mulsi3>
 d03603c:	1021883a 	mov	r16,r2
 d036040:	e13ffe17 	ldw	r4,-8(fp)
 d036044:	014003f4 	movhi	r5,15
 d036048:	29509004 	addi	r5,r5,16960
 d03604c:	d00c9140 	call	d00c914 <__umodsi3>
 d036050:	1009883a 	mov	r4,r2
 d036054:	e17ffc17 	ldw	r5,-16(fp)
 d036058:	d00235c0 	call	d00235c <__mulsi3>
 d03605c:	1009883a 	mov	r4,r2
 d036060:	014003f4 	movhi	r5,15
 d036064:	29509004 	addi	r5,r5,16960
 d036068:	d00c90c0 	call	d00c90c <__udivsi3>
 d03606c:	8085883a 	add	r2,r16,r2
 d036070:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 d036074:	00000706 	br	d036094 <usleep+0xc4>
  {
    OSTimeDly(0xffff);
 d036078:	013fffd4 	movui	r4,65535
 d03607c:	d0156dc0 	call	d0156dc <OSTimeDly>
    ticks -= 0xffff;
 d036080:	e0bffd17 	ldw	r2,-12(fp)
 d036084:	00fffff4 	movhi	r3,65535
 d036088:	18c00044 	addi	r3,r3,1
 d03608c:	10c5883a 	add	r2,r2,r3
 d036090:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 d036094:	e0fffd17 	ldw	r3,-12(fp)
 d036098:	00bfffd4 	movui	r2,65535
 d03609c:	10fff636 	bltu	r2,r3,d036078 <usleep+0xa8>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 d0360a0:	e0bffd17 	ldw	r2,-12(fp)
 d0360a4:	113fffcc 	andi	r4,r2,65535
 d0360a8:	d0156dc0 	call	d0156dc <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 d0360ac:	010003f4 	movhi	r4,15
 d0360b0:	21109004 	addi	r4,r4,16960
 d0360b4:	e17ffc17 	ldw	r5,-16(fp)
 d0360b8:	d00c90c0 	call	d00c90c <__udivsi3>
 d0360bc:	100b883a 	mov	r5,r2
 d0360c0:	e13ffe17 	ldw	r4,-8(fp)
 d0360c4:	d00c9140 	call	d00c914 <__umodsi3>
 d0360c8:	1009883a 	mov	r4,r2
 d0360cc:	d04a4c80 	call	d04a4c8 <alt_busy_sleep>

  return 0;  
 d0360d0:	e03fff15 	stw	zero,-4(fp)
 d0360d4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0360d8:	e037883a 	mov	sp,fp
 d0360dc:	dfc00217 	ldw	ra,8(sp)
 d0360e0:	df000117 	ldw	fp,4(sp)
 d0360e4:	dc000017 	ldw	r16,0(sp)
 d0360e8:	dec00304 	addi	sp,sp,12
 d0360ec:	f800283a 	ret

0d0360f0 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 d0360f0:	defff704 	addi	sp,sp,-36
 d0360f4:	dfc00815 	stw	ra,32(sp)
 d0360f8:	df000715 	stw	fp,28(sp)
 d0360fc:	df000704 	addi	fp,sp,28
 d036100:	e13ffb15 	stw	r4,-20(fp)
 d036104:	e17ffc15 	stw	r5,-16(fp)
 d036108:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d03610c:	e0bffb17 	ldw	r2,-20(fp)
 d036110:	1004803a 	cmplt	r2,r2,zero
 d036114:	1000091e 	bne	r2,zero,d03613c <alt_write+0x4c>
 d036118:	e13ffb17 	ldw	r4,-20(fp)
 d03611c:	01400304 	movi	r5,12
 d036120:	d00235c0 	call	d00235c <__mulsi3>
 d036124:	1007883a 	mov	r3,r2
 d036128:	00834174 	movhi	r2,3333
 d03612c:	10915b04 	addi	r2,r2,17772
 d036130:	1887883a 	add	r3,r3,r2
 d036134:	e0ffff15 	stw	r3,-4(fp)
 d036138:	00000106 	br	d036140 <alt_write+0x50>
 d03613c:	e03fff15 	stw	zero,-4(fp)
 d036140:	e0bfff17 	ldw	r2,-4(fp)
 d036144:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 d036148:	e0bffa17 	ldw	r2,-24(fp)
 d03614c:	1005003a 	cmpeq	r2,r2,zero
 d036150:	1000241e 	bne	r2,zero,d0361e4 <alt_write+0xf4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 d036154:	e0bffa17 	ldw	r2,-24(fp)
 d036158:	10800217 	ldw	r2,8(r2)
 d03615c:	108000cc 	andi	r2,r2,3
 d036160:	1005003a 	cmpeq	r2,r2,zero
 d036164:	10001a1e 	bne	r2,zero,d0361d0 <alt_write+0xe0>
 d036168:	e0bffa17 	ldw	r2,-24(fp)
 d03616c:	10800017 	ldw	r2,0(r2)
 d036170:	10800617 	ldw	r2,24(r2)
 d036174:	1005003a 	cmpeq	r2,r2,zero
 d036178:	1000151e 	bne	r2,zero,d0361d0 <alt_write+0xe0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 d03617c:	e0bffa17 	ldw	r2,-24(fp)
 d036180:	10800017 	ldw	r2,0(r2)
 d036184:	10800617 	ldw	r2,24(r2)
 d036188:	e17ffc17 	ldw	r5,-16(fp)
 d03618c:	e1bffd17 	ldw	r6,-12(fp)
 d036190:	e13ffa17 	ldw	r4,-24(fp)
 d036194:	103ee83a 	callr	r2
 d036198:	e0bff915 	stw	r2,-28(fp)
 d03619c:	e0bff917 	ldw	r2,-28(fp)
 d0361a0:	1004403a 	cmpge	r2,r2,zero
 d0361a4:	1000071e 	bne	r2,zero,d0361c4 <alt_write+0xd4>
      {
        ALT_ERRNO = -rval;
 d0361a8:	d0362140 	call	d036214 <alt_get_errno>
 d0361ac:	e0fff917 	ldw	r3,-28(fp)
 d0361b0:	00c7c83a 	sub	r3,zero,r3
 d0361b4:	10c00015 	stw	r3,0(r2)
        return -1;
 d0361b8:	00bfffc4 	movi	r2,-1
 d0361bc:	e0bffe15 	stw	r2,-8(fp)
 d0361c0:	00000e06 	br	d0361fc <alt_write+0x10c>
      }
      return rval;
 d0361c4:	e0bff917 	ldw	r2,-28(fp)
 d0361c8:	e0bffe15 	stw	r2,-8(fp)
 d0361cc:	00000b06 	br	d0361fc <alt_write+0x10c>
    }
    else
    {
      ALT_ERRNO = EACCES;
 d0361d0:	d0362140 	call	d036214 <alt_get_errno>
 d0361d4:	1007883a 	mov	r3,r2
 d0361d8:	00800344 	movi	r2,13
 d0361dc:	18800015 	stw	r2,0(r3)
 d0361e0:	00000406 	br	d0361f4 <alt_write+0x104>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 d0361e4:	d0362140 	call	d036214 <alt_get_errno>
 d0361e8:	1007883a 	mov	r3,r2
 d0361ec:	00801444 	movi	r2,81
 d0361f0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 d0361f4:	00bfffc4 	movi	r2,-1
 d0361f8:	e0bffe15 	stw	r2,-8(fp)
 d0361fc:	e0bffe17 	ldw	r2,-8(fp)
}
 d036200:	e037883a 	mov	sp,fp
 d036204:	dfc00117 	ldw	ra,4(sp)
 d036208:	df000017 	ldw	fp,0(sp)
 d03620c:	dec00204 	addi	sp,sp,8
 d036210:	f800283a 	ret

0d036214 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d036214:	defffd04 	addi	sp,sp,-12
 d036218:	dfc00215 	stw	ra,8(sp)
 d03621c:	df000115 	stw	fp,4(sp)
 d036220:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d036224:	00834174 	movhi	r2,3333
 d036228:	10926504 	addi	r2,r2,18836
 d03622c:	10800017 	ldw	r2,0(r2)
 d036230:	1005003a 	cmpeq	r2,r2,zero
 d036234:	1000061e 	bne	r2,zero,d036250 <alt_get_errno+0x3c>
 d036238:	00834174 	movhi	r2,3333
 d03623c:	10926504 	addi	r2,r2,18836
 d036240:	10800017 	ldw	r2,0(r2)
 d036244:	103ee83a 	callr	r2
 d036248:	e0bfff15 	stw	r2,-4(fp)
 d03624c:	00000306 	br	d03625c <alt_get_errno+0x48>
 d036250:	00834174 	movhi	r2,3333
 d036254:	109b0104 	addi	r2,r2,27652
 d036258:	e0bfff15 	stw	r2,-4(fp)
 d03625c:	e0bfff17 	ldw	r2,-4(fp)
}
 d036260:	e037883a 	mov	sp,fp
 d036264:	dfc00117 	ldw	ra,4(sp)
 d036268:	df000017 	ldw	fp,0(sp)
 d03626c:	dec00204 	addi	sp,sp,8
 d036270:	f800283a 	ret

0d036274 <altera_nios2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_irq_init(void) 
{
 d036274:	deffff04 	addi	sp,sp,-4
 d036278:	df000015 	stw	fp,0(sp)
 d03627c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 d036280:	000170fa 	wrctl	ienable,zero
}
 d036284:	e037883a 	mov	sp,fp
 d036288:	df000017 	ldw	fp,0(sp)
 d03628c:	dec00104 	addi	sp,sp,4
 d036290:	f800283a 	ret

0d036294 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 d036294:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 d036298:	d0e00117 	ldw	r3,-32764(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 d03629c:	d128f917 	ldw	r4,-23580(gp)

      stw ra,  0(sp)
 d0362a0:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 d0362a4:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 d0362a8:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 d0362ac:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 d0362b0:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 d0362b4:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 d0362b8:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 d0362bc:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 d0362c0:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 d0362c4:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 d0362c8:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 d0362cc:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 d0362d0:	d0366b40 	call	d0366b4 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 d0362d4:	d128f417 	ldw	r4,-23600(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 d0362d8:	d168ec07 	ldb	r5,-23632(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 d0362dc:	d128f915 	stw	r4,-23580(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 d0362e0:	d168ec45 	stb	r5,-23631(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 d0362e4:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 d0362e8:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 d0362ec:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 d0362f0:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 d0362f4:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 d0362f8:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 d0362fc:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 d036300:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 d036304:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 d036308:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 d03630c:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 d036310:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 d036314:	d0e00115 	stw	r3,-32764(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 d036318:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 d03631c:	f800283a 	ret

0d036320 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 d036320:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 d036324:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 d036328:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 d03632c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 d036330:	d0366b40 	call	d0366b4 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 d036334:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 d036338:	d4a8ea45 	stb	r18,-23639(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 d03633c:	003fe506 	br	d0362d4 <OSCtxSw+0x40>

0d036340 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 d036340:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 d036344:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 d036348:	10800054 	ori	r2,r2,1
      wrctl status, r2
 d03634c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 d036350:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 d036354:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 d036358:	dec00204 	addi	sp,sp,8

      callr r2
 d03635c:	103ee83a 	callr	r2

      nop
 d036360:	0001883a 	nop

0d036364 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 d036364:	defff704 	addi	sp,sp,-36
 d036368:	dfc00815 	stw	ra,32(sp)
 d03636c:	df000715 	stw	fp,28(sp)
 d036370:	df000704 	addi	fp,sp,28
 d036374:	e13ffc15 	stw	r4,-16(fp)
 d036378:	e17ffd15 	stw	r5,-12(fp)
 d03637c:	e1bffe15 	stw	r6,-8(fp)
 d036380:	e1ffff0d 	sth	r7,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 d036384:	e0bffe17 	ldw	r2,-8(fp)
 d036388:	1007883a 	mov	r3,r2
 d03638c:	00bfff04 	movi	r2,-4
 d036390:	1884703a 	and	r2,r3,r2
 d036394:	10bf0004 	addi	r2,r2,-1024
 d036398:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 d03639c:	e0bff917 	ldw	r2,-28(fp)
 d0363a0:	10000015 	stw	zero,0(r2)
 d0363a4:	e0bff917 	ldw	r2,-28(fp)
 d0363a8:	10c0bb04 	addi	r3,r2,748
 d0363ac:	e0bff917 	ldw	r2,-28(fp)
 d0363b0:	10c00115 	stw	r3,4(r2)
 d0363b4:	e0bff917 	ldw	r2,-28(fp)
 d0363b8:	1080bb04 	addi	r2,r2,748
 d0363bc:	10c01704 	addi	r3,r2,92
 d0363c0:	e0bff917 	ldw	r2,-28(fp)
 d0363c4:	10c00215 	stw	r3,8(r2)
 d0363c8:	e0bff917 	ldw	r2,-28(fp)
 d0363cc:	1080bb04 	addi	r2,r2,748
 d0363d0:	10c02e04 	addi	r3,r2,184
 d0363d4:	e0bff917 	ldw	r2,-28(fp)
 d0363d8:	10c00315 	stw	r3,12(r2)
 d0363dc:	e0bff917 	ldw	r2,-28(fp)
 d0363e0:	10000415 	stw	zero,16(r2)
 d0363e4:	e0bff917 	ldw	r2,-28(fp)
 d0363e8:	10800504 	addi	r2,r2,20
 d0363ec:	1009883a 	mov	r4,r2
 d0363f0:	01800644 	movi	r6,25
 d0363f4:	000b883a 	mov	r5,zero
 d0363f8:	d0027880 	call	d002788 <memset>
 d0363fc:	e0bff917 	ldw	r2,-28(fp)
 d036400:	10000c15 	stw	zero,48(r2)
 d036404:	e0fff917 	ldw	r3,-28(fp)
 d036408:	00834174 	movhi	r2,3333
 d03640c:	10bed504 	addi	r2,r2,-1196
 d036410:	18800d15 	stw	r2,52(r3)
 d036414:	e0bff917 	ldw	r2,-28(fp)
 d036418:	10000e15 	stw	zero,56(r2)
 d03641c:	e0bff917 	ldw	r2,-28(fp)
 d036420:	10000f15 	stw	zero,60(r2)
 d036424:	e0bff917 	ldw	r2,-28(fp)
 d036428:	10001015 	stw	zero,64(r2)
 d03642c:	e0bff917 	ldw	r2,-28(fp)
 d036430:	10001115 	stw	zero,68(r2)
 d036434:	e0bff917 	ldw	r2,-28(fp)
 d036438:	10001215 	stw	zero,72(r2)
 d03643c:	e0bff917 	ldw	r2,-28(fp)
 d036440:	10001315 	stw	zero,76(r2)
 d036444:	e0bff917 	ldw	r2,-28(fp)
 d036448:	10001415 	stw	zero,80(r2)
 d03644c:	e0bff917 	ldw	r2,-28(fp)
 d036450:	10001515 	stw	zero,84(r2)
 d036454:	e0bff917 	ldw	r2,-28(fp)
 d036458:	10001615 	stw	zero,88(r2)
 d03645c:	e0bff917 	ldw	r2,-28(fp)
 d036460:	10001715 	stw	zero,92(r2)
 d036464:	e0bff917 	ldw	r2,-28(fp)
 d036468:	10001805 	stb	zero,96(r2)
 d03646c:	e0bff917 	ldw	r2,-28(fp)
 d036470:	10801f04 	addi	r2,r2,124
 d036474:	10000015 	stw	zero,0(r2)
 d036478:	10000115 	stw	zero,4(r2)
 d03647c:	10000215 	stw	zero,8(r2)
 d036480:	10000315 	stw	zero,12(r2)
 d036484:	10000415 	stw	zero,16(r2)
 d036488:	10000515 	stw	zero,20(r2)
 d03648c:	10000615 	stw	zero,24(r2)
 d036490:	10000715 	stw	zero,28(r2)
 d036494:	10000815 	stw	zero,32(r2)
 d036498:	e0bff917 	ldw	r2,-28(fp)
 d03649c:	10002815 	stw	zero,160(r2)
 d0364a0:	e0fff917 	ldw	r3,-28(fp)
 d0364a4:	00800044 	movi	r2,1
 d0364a8:	18802915 	stw	r2,164(r3)
 d0364ac:	18002a15 	stw	zero,168(r3)
 d0364b0:	e0fff917 	ldw	r3,-28(fp)
 d0364b4:	008cc384 	movi	r2,13070
 d0364b8:	18802b0d 	sth	r2,172(r3)
 d0364bc:	e0fff917 	ldw	r3,-28(fp)
 d0364c0:	00aaf344 	movi	r2,-21555
 d0364c4:	18802b8d 	sth	r2,174(r3)
 d0364c8:	e0fff917 	ldw	r3,-28(fp)
 d0364cc:	00848d04 	movi	r2,4660
 d0364d0:	18802c0d 	sth	r2,176(r3)
 d0364d4:	e0fff917 	ldw	r3,-28(fp)
 d0364d8:	00b99b44 	movi	r2,-6547
 d0364dc:	18802c8d 	sth	r2,178(r3)
 d0364e0:	e0fff917 	ldw	r3,-28(fp)
 d0364e4:	00b7bb04 	movi	r2,-8468
 d0364e8:	18802d0d 	sth	r2,180(r3)
 d0364ec:	e0fff917 	ldw	r3,-28(fp)
 d0364f0:	00800144 	movi	r2,5
 d0364f4:	18802d8d 	sth	r2,182(r3)
 d0364f8:	e0fff917 	ldw	r3,-28(fp)
 d0364fc:	008002c4 	movi	r2,11
 d036500:	18802e0d 	sth	r2,184(r3)
 d036504:	e0bff917 	ldw	r2,-28(fp)
 d036508:	10002f15 	stw	zero,188(r2)
 d03650c:	e0bff917 	ldw	r2,-28(fp)
 d036510:	10003015 	stw	zero,192(r2)
 d036514:	e0bff917 	ldw	r2,-28(fp)
 d036518:	10003115 	stw	zero,196(r2)
 d03651c:	e0bff917 	ldw	r2,-28(fp)
 d036520:	10003215 	stw	zero,200(r2)
 d036524:	e0bff917 	ldw	r2,-28(fp)
 d036528:	10003315 	stw	zero,204(r2)
 d03652c:	e0bff917 	ldw	r2,-28(fp)
 d036530:	10003415 	stw	zero,208(r2)
 d036534:	e0bff917 	ldw	r2,-28(fp)
 d036538:	10003e15 	stw	zero,248(r2)
 d03653c:	e0bff917 	ldw	r2,-28(fp)
 d036540:	10003f15 	stw	zero,252(r2)
 d036544:	e0bff917 	ldw	r2,-28(fp)
 d036548:	10004015 	stw	zero,256(r2)
 d03654c:	e0bff917 	ldw	r2,-28(fp)
 d036550:	10004115 	stw	zero,260(r2)
 d036554:	e0bff917 	ldw	r2,-28(fp)
 d036558:	10004215 	stw	zero,264(r2)
 d03655c:	e0bff917 	ldw	r2,-28(fp)
 d036560:	10004315 	stw	zero,268(r2)
 d036564:	e0bff917 	ldw	r2,-28(fp)
 d036568:	10004415 	stw	zero,272(r2)
 d03656c:	e0bff917 	ldw	r2,-28(fp)
 d036570:	10004515 	stw	zero,276(r2)
 d036574:	e0bff917 	ldw	r2,-28(fp)
 d036578:	10004615 	stw	zero,280(r2)
 d03657c:	e0bff917 	ldw	r2,-28(fp)
 d036580:	10004715 	stw	zero,284(r2)
 d036584:	e0bff917 	ldw	r2,-28(fp)
 d036588:	10003505 	stb	zero,212(r2)
 d03658c:	e0bff917 	ldw	r2,-28(fp)
 d036590:	10003705 	stb	zero,220(r2)
 d036594:	e0bff917 	ldw	r2,-28(fp)
 d036598:	10003d15 	stw	zero,244(r2)
 d03659c:	e0bff917 	ldw	r2,-28(fp)
 d0365a0:	10005215 	stw	zero,328(r2)
 d0365a4:	e0bff917 	ldw	r2,-28(fp)
 d0365a8:	10005315 	stw	zero,332(r2)
 d0365ac:	e0bff917 	ldw	r2,-28(fp)
 d0365b0:	10005415 	stw	zero,336(r2)
 d0365b4:	e0bff917 	ldw	r2,-28(fp)
 d0365b8:	10005515 	stw	zero,340(r2)
 d0365bc:	e0bff917 	ldw	r2,-28(fp)
 d0365c0:	1000b515 	stw	zero,724(r2)
 d0365c4:	e0bff917 	ldw	r2,-28(fp)
 d0365c8:	10007515 	stw	zero,468(r2)
 d0365cc:	e0bff917 	ldw	r2,-28(fp)
 d0365d0:	1000b715 	stw	zero,732(r2)
 d0365d4:	e0bff917 	ldw	r2,-28(fp)
 d0365d8:	1000b815 	stw	zero,736(r2)
 d0365dc:	e0bff917 	ldw	r2,-28(fp)
 d0365e0:	1000b915 	stw	zero,740(r2)
 d0365e4:	e0bff917 	ldw	r2,-28(fp)
 d0365e8:	1000ba15 	stw	zero,744(r2)
 d0365ec:	e0bff917 	ldw	r2,-28(fp)
 d0365f0:	1080bb04 	addi	r2,r2,748
 d0365f4:	1009883a 	mov	r4,r2
 d0365f8:	01804504 	movi	r6,276
 d0365fc:	000b883a 	mov	r5,zero
 d036600:	d0027880 	call	d002788 <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 d036604:	e0bff917 	ldw	r2,-28(fp)
 d036608:	e0bffb15 	stw	r2,-20(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 d03660c:	e0bffb17 	ldw	r2,-20(fp)
 d036610:	10bff304 	addi	r2,r2,-52
 d036614:	e0bffa15 	stw	r2,-24(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 d036618:	e0bffa17 	ldw	r2,-24(fp)
 d03661c:	10c00c04 	addi	r3,r2,48
 d036620:	e0bffc17 	ldw	r2,-16(fp)
 d036624:	18800015 	stw	r2,0(r3)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 d036628:	e0bffa17 	ldw	r2,-24(fp)
 d03662c:	10c00b04 	addi	r3,r2,44
 d036630:	e0bffd17 	ldw	r2,-12(fp)
 d036634:	18800015 	stw	r2,0(r3)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 d036638:	e0bffa17 	ldw	r2,-24(fp)
 d03663c:	10c00a04 	addi	r3,r2,40
 d036640:	e0bff917 	ldw	r2,-28(fp)
 d036644:	18800015 	stw	r2,0(r3)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 d036648:	008340f4 	movhi	r2,3331
 d03664c:	1098d004 	addi	r2,r2,25408
 d036650:	10c00104 	addi	r3,r2,4
 d036654:	e0bffa17 	ldw	r2,-24(fp)
 d036658:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 d03665c:	e0bffa17 	ldw	r2,-24(fp)
}
 d036660:	e037883a 	mov	sp,fp
 d036664:	dfc00117 	ldw	ra,4(sp)
 d036668:	df000017 	ldw	fp,0(sp)
 d03666c:	dec00204 	addi	sp,sp,8
 d036670:	f800283a 	ret

0d036674 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 d036674:	defffe04 	addi	sp,sp,-8
 d036678:	df000115 	stw	fp,4(sp)
 d03667c:	df000104 	addi	fp,sp,4
 d036680:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 d036684:	e037883a 	mov	sp,fp
 d036688:	df000017 	ldw	fp,0(sp)
 d03668c:	dec00104 	addi	sp,sp,4
 d036690:	f800283a 	ret

0d036694 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 d036694:	defffe04 	addi	sp,sp,-8
 d036698:	df000115 	stw	fp,4(sp)
 d03669c:	df000104 	addi	fp,sp,4
 d0366a0:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 d0366a4:	e037883a 	mov	sp,fp
 d0366a8:	df000017 	ldw	fp,0(sp)
 d0366ac:	dec00104 	addi	sp,sp,4
 d0366b0:	f800283a 	ret

0d0366b4 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 d0366b4:	deffff04 	addi	sp,sp,-4
 d0366b8:	df000015 	stw	fp,0(sp)
 d0366bc:	d839883a 	mov	fp,sp
}
 d0366c0:	e037883a 	mov	sp,fp
 d0366c4:	df000017 	ldw	fp,0(sp)
 d0366c8:	dec00104 	addi	sp,sp,4
 d0366cc:	f800283a 	ret

0d0366d0 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 d0366d0:	deffff04 	addi	sp,sp,-4
 d0366d4:	df000015 	stw	fp,0(sp)
 d0366d8:	d839883a 	mov	fp,sp
}
 d0366dc:	e037883a 	mov	sp,fp
 d0366e0:	df000017 	ldw	fp,0(sp)
 d0366e4:	dec00104 	addi	sp,sp,4
 d0366e8:	f800283a 	ret

0d0366ec <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 d0366ec:	defffe04 	addi	sp,sp,-8
 d0366f0:	dfc00115 	stw	ra,4(sp)
 d0366f4:	df000015 	stw	fp,0(sp)
 d0366f8:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 d0366fc:	d025be40 	call	d025be4 <cticks_hook>
#endif
}
 d036700:	e037883a 	mov	sp,fp
 d036704:	dfc00117 	ldw	ra,4(sp)
 d036708:	df000017 	ldw	fp,0(sp)
 d03670c:	dec00204 	addi	sp,sp,8
 d036710:	f800283a 	ret

0d036714 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 d036714:	deffff04 	addi	sp,sp,-4
 d036718:	df000015 	stw	fp,0(sp)
 d03671c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 d036720:	e037883a 	mov	sp,fp
 d036724:	df000017 	ldw	fp,0(sp)
 d036728:	dec00104 	addi	sp,sp,4
 d03672c:	f800283a 	ret

0d036730 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 d036730:	deffff04 	addi	sp,sp,-4
 d036734:	df000015 	stw	fp,0(sp)
 d036738:	d839883a 	mov	fp,sp
}
 d03673c:	e037883a 	mov	sp,fp
 d036740:	df000017 	ldw	fp,0(sp)
 d036744:	dec00104 	addi	sp,sp,4
 d036748:	f800283a 	ret

0d03674c <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 d03674c:	deffff04 	addi	sp,sp,-4
 d036750:	df000015 	stw	fp,0(sp)
 d036754:	d839883a 	mov	fp,sp
}
 d036758:	e037883a 	mov	sp,fp
 d03675c:	df000017 	ldw	fp,0(sp)
 d036760:	dec00104 	addi	sp,sp,4
 d036764:	f800283a 	ret

0d036768 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 d036768:	defffe04 	addi	sp,sp,-8
 d03676c:	df000115 	stw	fp,4(sp)
 d036770:	df000104 	addi	fp,sp,4
 d036774:	e13fff15 	stw	r4,-4(fp)
}
 d036778:	e037883a 	mov	sp,fp
 d03677c:	df000017 	ldw	fp,0(sp)
 d036780:	dec00104 	addi	sp,sp,4
 d036784:	f800283a 	ret

0d036788 <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 d036788:	defff704 	addi	sp,sp,-36
 d03678c:	dfc00815 	stw	ra,32(sp)
 d036790:	df000715 	stw	fp,28(sp)
 d036794:	df000704 	addi	fp,sp,28
 d036798:	e13ffc15 	stw	r4,-16(fp)
 d03679c:	e17ffd15 	stw	r5,-12(fp)
 d0367a0:	e1bffe15 	stw	r6,-8(fp)
 d0367a4:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 d0367a8:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d0367ac:	e0bffc17 	ldw	r2,-16(fp)
 d0367b0:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 d0367b4:	e1bfff17 	ldw	r6,-4(fp)
 d0367b8:	008340f4 	movhi	r2,3331
 d0367bc:	109acc04 	addi	r2,r2,27440
 d0367c0:	d8800015 	stw	r2,0(sp)
 d0367c4:	e13ffa17 	ldw	r4,-24(fp)
 d0367c8:	e17ffe17 	ldw	r5,-8(fp)
 d0367cc:	e1c00217 	ldw	r7,8(fp)
 d0367d0:	d0165ac0 	call	d0165ac <alt_flash_program_block>
 d0367d4:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 d0367d8:	e0bffb17 	ldw	r2,-20(fp)
}
 d0367dc:	e037883a 	mov	sp,fp
 d0367e0:	dfc00117 	ldw	ra,4(sp)
 d0367e4:	df000017 	ldw	fp,0(sp)
 d0367e8:	dec00204 	addi	sp,sp,8
 d0367ec:	f800283a 	ret

0d0367f0 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 d0367f0:	defff804 	addi	sp,sp,-32
 d0367f4:	dfc00715 	stw	ra,28(sp)
 d0367f8:	df000615 	stw	fp,24(sp)
 d0367fc:	df000604 	addi	fp,sp,24
 d036800:	e13ffe15 	stw	r4,-8(fp)
 d036804:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 d036808:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d03680c:	e0bffe17 	ldw	r2,-8(fp)
 d036810:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 d036814:	e0bffa17 	ldw	r2,-24(fp)
 d036818:	10c03317 	ldw	r3,204(r2)
 d03681c:	e0bffa17 	ldw	r2,-24(fp)
 d036820:	11000a17 	ldw	r4,40(r2)
 d036824:	01415544 	movi	r5,1365
 d036828:	01802a84 	movi	r6,170
 d03682c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 d036830:	e0bffa17 	ldw	r2,-24(fp)
 d036834:	10c03317 	ldw	r3,204(r2)
 d036838:	e0bffa17 	ldw	r2,-24(fp)
 d03683c:	11000a17 	ldw	r4,40(r2)
 d036840:	0140aa84 	movi	r5,682
 d036844:	01801544 	movi	r6,85
 d036848:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 d03684c:	e0bffa17 	ldw	r2,-24(fp)
 d036850:	10c03317 	ldw	r3,204(r2)
 d036854:	e0bffa17 	ldw	r2,-24(fp)
 d036858:	11000a17 	ldw	r4,40(r2)
 d03685c:	01415544 	movi	r5,1365
 d036860:	01802004 	movi	r6,128
 d036864:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 d036868:	e0bffa17 	ldw	r2,-24(fp)
 d03686c:	10c03317 	ldw	r3,204(r2)
 d036870:	e0bffa17 	ldw	r2,-24(fp)
 d036874:	11000a17 	ldw	r4,40(r2)
 d036878:	01415544 	movi	r5,1365
 d03687c:	01802a84 	movi	r6,170
 d036880:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 d036884:	e0bffa17 	ldw	r2,-24(fp)
 d036888:	10c03317 	ldw	r3,204(r2)
 d03688c:	e0bffa17 	ldw	r2,-24(fp)
 d036890:	11000a17 	ldw	r4,40(r2)
 d036894:	0140aa84 	movi	r5,682
 d036898:	01801544 	movi	r6,85
 d03689c:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 d0368a0:	e0bffa17 	ldw	r2,-24(fp)
 d0368a4:	11803517 	ldw	r6,212(r2)
 d0368a8:	e0bffa17 	ldw	r2,-24(fp)
 d0368ac:	10800a17 	ldw	r2,40(r2)
 d0368b0:	1007883a 	mov	r3,r2
 d0368b4:	e0bfff17 	ldw	r2,-4(fp)
 d0368b8:	1889883a 	add	r4,r3,r2
 d0368bc:	01400c04 	movi	r5,48
 d0368c0:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 d0368c4:	0109c404 	movi	r4,10000
 d0368c8:	d035fd00 	call	d035fd0 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 d0368cc:	00800c84 	movi	r2,50
 d0368d0:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 d0368d4:	e0bffa17 	ldw	r2,-24(fp)
 d0368d8:	10800a17 	ldw	r2,40(r2)
 d0368dc:	1007883a 	mov	r3,r2
 d0368e0:	e0bfff17 	ldw	r2,-4(fp)
 d0368e4:	1885883a 	add	r2,r3,r2
 d0368e8:	10800023 	ldbuio	r2,0(r2)
 d0368ec:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 d0368f0:	0100fa04 	movi	r4,1000
 d0368f4:	d035fd00 	call	d035fd0 <usleep>
    timeout--;
 d0368f8:	e0bffb17 	ldw	r2,-20(fp)
 d0368fc:	10bfffc4 	addi	r2,r2,-1
 d036900:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 d036904:	e0bffd03 	ldbu	r2,-12(fp)
 d036908:	10803fcc 	andi	r2,r2,255
 d03690c:	1080020c 	andi	r2,r2,8
 d036910:	1004c03a 	cmpne	r2,r2,zero
 d036914:	1000031e 	bne	r2,zero,d036924 <alt_erase_block_amd+0x134>
 d036918:	e0bffb17 	ldw	r2,-20(fp)
 d03691c:	10800048 	cmpgei	r2,r2,1
 d036920:	103fec1e 	bne	r2,zero,d0368d4 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 d036924:	e0bffa17 	ldw	r2,-24(fp)
 d036928:	10803117 	ldw	r2,196(r2)
 d03692c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 d036930:	00001706 	br	d036990 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 d036934:	e0bffa17 	ldw	r2,-24(fp)
 d036938:	10800a17 	ldw	r2,40(r2)
 d03693c:	1007883a 	mov	r3,r2
 d036940:	e0bfff17 	ldw	r2,-4(fp)
 d036944:	1885883a 	add	r2,r3,r2
 d036948:	10800023 	ldbuio	r2,0(r2)
 d03694c:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 d036950:	e0bffd03 	ldbu	r2,-12(fp)
 d036954:	10803fcc 	andi	r2,r2,255
 d036958:	1080201c 	xori	r2,r2,128
 d03695c:	10bfe004 	addi	r2,r2,-128
 d036960:	1004803a 	cmplt	r2,r2,zero
 d036964:	10000d1e 	bne	r2,zero,d03699c <alt_erase_block_amd+0x1ac>
 d036968:	e0bffd03 	ldbu	r2,-12(fp)
 d03696c:	10803fcc 	andi	r2,r2,255
 d036970:	1080080c 	andi	r2,r2,32
 d036974:	1004c03a 	cmpne	r2,r2,zero
 d036978:	1000081e 	bne	r2,zero,d03699c <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 d03697c:	0100fa04 	movi	r4,1000
 d036980:	d035fd00 	call	d035fd0 <usleep>
    timeout -= 1000;
 d036984:	e0bffb17 	ldw	r2,-20(fp)
 d036988:	10bf0604 	addi	r2,r2,-1000
 d03698c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 d036990:	e0bffb17 	ldw	r2,-20(fp)
 d036994:	10800048 	cmpgei	r2,r2,1
 d036998:	103fe61e 	bne	r2,zero,d036934 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 d03699c:	e0bffb17 	ldw	r2,-20(fp)
 d0369a0:	10800048 	cmpgei	r2,r2,1
 d0369a4:	1000031e 	bne	r2,zero,d0369b4 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 d0369a8:	00bfe304 	movi	r2,-116
 d0369ac:	e0bffc15 	stw	r2,-16(fp)
 d0369b0:	00000f06 	br	d0369f0 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 d0369b4:	e0bffa17 	ldw	r2,-24(fp)
 d0369b8:	10800a17 	ldw	r2,40(r2)
 d0369bc:	1007883a 	mov	r3,r2
 d0369c0:	e0bfff17 	ldw	r2,-4(fp)
 d0369c4:	1885883a 	add	r2,r3,r2
 d0369c8:	10800023 	ldbuio	r2,0(r2)
 d0369cc:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 d0369d0:	e0bffd03 	ldbu	r2,-12(fp)
 d0369d4:	10803fcc 	andi	r2,r2,255
 d0369d8:	1080201c 	xori	r2,r2,128
 d0369dc:	10bfe004 	addi	r2,r2,-128
 d0369e0:	1004803a 	cmplt	r2,r2,zero
 d0369e4:	1000021e 	bne	r2,zero,d0369f0 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 d0369e8:	00bffec4 	movi	r2,-5
 d0369ec:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 d0369f0:	e0bffc17 	ldw	r2,-16(fp)
}
 d0369f4:	e037883a 	mov	sp,fp
 d0369f8:	dfc00117 	ldw	ra,4(sp)
 d0369fc:	df000017 	ldw	fp,0(sp)
 d036a00:	dec00204 	addi	sp,sp,8
 d036a04:	f800283a 	ret

0d036a08 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 d036a08:	defff804 	addi	sp,sp,-32
 d036a0c:	dfc00715 	stw	ra,28(sp)
 d036a10:	df000615 	stw	fp,24(sp)
 d036a14:	df000604 	addi	fp,sp,24
 d036a18:	e13ffd15 	stw	r4,-12(fp)
 d036a1c:	e17ffe15 	stw	r5,-8(fp)
 d036a20:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 d036a24:	e0bffd17 	ldw	r2,-12(fp)
 d036a28:	11003017 	ldw	r4,192(r2)
 d036a2c:	01401904 	movi	r5,100
 d036a30:	d00235c0 	call	d00235c <__mulsi3>
 d036a34:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 d036a38:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 d036a3c:	e0bffd17 	ldw	r2,-12(fp)
 d036a40:	10800a17 	ldw	r2,40(r2)
 d036a44:	1007883a 	mov	r3,r2
 d036a48:	e0bffe17 	ldw	r2,-8(fp)
 d036a4c:	1885883a 	add	r2,r3,r2
 d036a50:	10800023 	ldbuio	r2,0(r2)
 d036a54:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 d036a58:	00001706 	br	d036ab8 <alt_wait_for_command_to_complete_amd+0xb0>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 d036a5c:	e0bffc03 	ldbu	r2,-16(fp)
 d036a60:	10803fcc 	andi	r2,r2,255
 d036a64:	10c0200c 	andi	r3,r2,128
 d036a68:	e0bfff03 	ldbu	r2,-4(fp)
 d036a6c:	1080200c 	andi	r2,r2,128
 d036a70:	18801426 	beq	r3,r2,d036ac4 <alt_wait_for_command_to_complete_amd+0xbc>
 d036a74:	e0bffc03 	ldbu	r2,-16(fp)
 d036a78:	10803fcc 	andi	r2,r2,255
 d036a7c:	1080080c 	andi	r2,r2,32
 d036a80:	1004c03a 	cmpne	r2,r2,zero
 d036a84:	10000f1e 	bne	r2,zero,d036ac4 <alt_wait_for_command_to_complete_amd+0xbc>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 d036a88:	01000044 	movi	r4,1
 d036a8c:	d035fd00 	call	d035fd0 <usleep>
    timeout--;
 d036a90:	e0bffb17 	ldw	r2,-20(fp)
 d036a94:	10bfffc4 	addi	r2,r2,-1
 d036a98:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 d036a9c:	e0bffd17 	ldw	r2,-12(fp)
 d036aa0:	10800a17 	ldw	r2,40(r2)
 d036aa4:	1007883a 	mov	r3,r2
 d036aa8:	e0bffe17 	ldw	r2,-8(fp)
 d036aac:	1885883a 	add	r2,r3,r2
 d036ab0:	10800023 	ldbuio	r2,0(r2)
 d036ab4:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 d036ab8:	e0bffb17 	ldw	r2,-20(fp)
 d036abc:	10800048 	cmpgei	r2,r2,1
 d036ac0:	103fe61e 	bne	r2,zero,d036a5c <alt_wait_for_command_to_complete_amd+0x54>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 d036ac4:	e0bffb17 	ldw	r2,-20(fp)
 d036ac8:	1004c03a 	cmpne	r2,r2,zero
 d036acc:	1000031e 	bne	r2,zero,d036adc <alt_wait_for_command_to_complete_amd+0xd4>
  {
    ret_code = -ETIMEDOUT;
 d036ad0:	00bfe304 	movi	r2,-116
 d036ad4:	e0bffa15 	stw	r2,-24(fp)
 d036ad8:	00000f06 	br	d036b18 <alt_wait_for_command_to_complete_amd+0x110>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 d036adc:	e0bffd17 	ldw	r2,-12(fp)
 d036ae0:	10800a17 	ldw	r2,40(r2)
 d036ae4:	1007883a 	mov	r3,r2
 d036ae8:	e0bffe17 	ldw	r2,-8(fp)
 d036aec:	1885883a 	add	r2,r3,r2
 d036af0:	10800023 	ldbuio	r2,0(r2)
 d036af4:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 d036af8:	e0bffc03 	ldbu	r2,-16(fp)
 d036afc:	10803fcc 	andi	r2,r2,255
 d036b00:	10c0200c 	andi	r3,r2,128
 d036b04:	e0bfff03 	ldbu	r2,-4(fp)
 d036b08:	1080200c 	andi	r2,r2,128
 d036b0c:	18800226 	beq	r3,r2,d036b18 <alt_wait_for_command_to_complete_amd+0x110>
    {
      ret_code = -EIO;
 d036b10:	00bffec4 	movi	r2,-5
 d036b14:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 d036b18:	e0bffa17 	ldw	r2,-24(fp)
}
 d036b1c:	e037883a 	mov	sp,fp
 d036b20:	dfc00117 	ldw	ra,4(sp)
 d036b24:	df000017 	ldw	fp,0(sp)
 d036b28:	dec00204 	addi	sp,sp,8
 d036b2c:	f800283a 	ret

0d036b30 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 d036b30:	defff904 	addi	sp,sp,-28
 d036b34:	dfc00615 	stw	ra,24(sp)
 d036b38:	df000515 	stw	fp,20(sp)
 d036b3c:	df000504 	addi	fp,sp,20
 d036b40:	e13ffd15 	stw	r4,-12(fp)
 d036b44:	e17ffe15 	stw	r5,-8(fp)
 d036b48:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 d036b4c:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 d036b50:	e0bffd17 	ldw	r2,-12(fp)
 d036b54:	10c03317 	ldw	r3,204(r2)
 d036b58:	e0bffd17 	ldw	r2,-12(fp)
 d036b5c:	11000a17 	ldw	r4,40(r2)
 d036b60:	01415544 	movi	r5,1365
 d036b64:	01802a84 	movi	r6,170
 d036b68:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 d036b6c:	e0bffd17 	ldw	r2,-12(fp)
 d036b70:	10c03317 	ldw	r3,204(r2)
 d036b74:	e0bffd17 	ldw	r2,-12(fp)
 d036b78:	11000a17 	ldw	r4,40(r2)
 d036b7c:	0140aa84 	movi	r5,682
 d036b80:	01801544 	movi	r6,85
 d036b84:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 d036b88:	e0bffd17 	ldw	r2,-12(fp)
 d036b8c:	10c03317 	ldw	r3,204(r2)
 d036b90:	e0bffd17 	ldw	r2,-12(fp)
 d036b94:	11000a17 	ldw	r4,40(r2)
 d036b98:	01415544 	movi	r5,1365
 d036b9c:	01802804 	movi	r6,160
 d036ba0:	183ee83a 	callr	r3
  
  value = *src_addr;
 d036ba4:	e0bfff17 	ldw	r2,-4(fp)
 d036ba8:	10800003 	ldbu	r2,0(r2)
 d036bac:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 d036bb0:	e13ffd17 	ldw	r4,-12(fp)
 d036bb4:	e17ffe17 	ldw	r5,-8(fp)
 d036bb8:	e1bfff17 	ldw	r6,-4(fp)
 d036bbc:	d0164480 	call	d016448 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 d036bc0:	e1bffb03 	ldbu	r6,-20(fp)
 d036bc4:	e13ffd17 	ldw	r4,-12(fp)
 d036bc8:	e17ffe17 	ldw	r5,-8(fp)
 d036bcc:	d036a080 	call	d036a08 <alt_wait_for_command_to_complete_amd>
 d036bd0:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 d036bd4:	e0bffc17 	ldw	r2,-16(fp)
  
}
 d036bd8:	e037883a 	mov	sp,fp
 d036bdc:	dfc00117 	ldw	ra,4(sp)
 d036be0:	df000017 	ldw	fp,0(sp)
 d036be4:	dec00204 	addi	sp,sp,8
 d036be8:	f800283a 	ret

0d036bec <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 d036bec:	defff704 	addi	sp,sp,-36
 d036bf0:	dfc00815 	stw	ra,32(sp)
 d036bf4:	df000715 	stw	fp,28(sp)
 d036bf8:	df000704 	addi	fp,sp,28
 d036bfc:	e13ffc15 	stw	r4,-16(fp)
 d036c00:	e17ffd15 	stw	r5,-12(fp)
 d036c04:	e1bffe15 	stw	r6,-8(fp)
 d036c08:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 d036c0c:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d036c10:	e0bffc17 	ldw	r2,-16(fp)
 d036c14:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 d036c18:	e13ffa17 	ldw	r4,-24(fp)
 d036c1c:	e17ffd17 	ldw	r5,-12(fp)
 d036c20:	d036de40 	call	d036de4 <alt_unlock_block_intel>
 d036c24:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 d036c28:	e0bffb17 	ldw	r2,-20(fp)
 d036c2c:	1004c03a 	cmpne	r2,r2,zero
 d036c30:	1000091e 	bne	r2,zero,d036c58 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 d036c34:	e1bfff17 	ldw	r6,-4(fp)
 d036c38:	008340f4 	movhi	r2,3331
 d036c3c:	109bdd04 	addi	r2,r2,28532
 d036c40:	d8800015 	stw	r2,0(sp)
 d036c44:	e13ffa17 	ldw	r4,-24(fp)
 d036c48:	e17ffe17 	ldw	r5,-8(fp)
 d036c4c:	e1c00217 	ldw	r7,8(fp)
 d036c50:	d0165ac0 	call	d0165ac <alt_flash_program_block>
 d036c54:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 d036c58:	e0bffb17 	ldw	r2,-20(fp)
}
 d036c5c:	e037883a 	mov	sp,fp
 d036c60:	dfc00117 	ldw	ra,4(sp)
 d036c64:	df000017 	ldw	fp,0(sp)
 d036c68:	dec00204 	addi	sp,sp,8
 d036c6c:	f800283a 	ret

0d036c70 <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 d036c70:	defff804 	addi	sp,sp,-32
 d036c74:	dfc00715 	stw	ra,28(sp)
 d036c78:	df000615 	stw	fp,24(sp)
 d036c7c:	df000604 	addi	fp,sp,24
 d036c80:	e13ffe15 	stw	r4,-8(fp)
 d036c84:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 d036c88:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d036c8c:	e0bffe17 	ldw	r2,-8(fp)
 d036c90:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 d036c94:	e0bffb17 	ldw	r2,-20(fp)
 d036c98:	10803117 	ldw	r2,196(r2)
 d036c9c:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 d036ca0:	e13ffb17 	ldw	r4,-20(fp)
 d036ca4:	e17fff17 	ldw	r5,-4(fp)
 d036ca8:	d036de40 	call	d036de4 <alt_unlock_block_intel>
 d036cac:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 d036cb0:	e0bffc17 	ldw	r2,-16(fp)
 d036cb4:	1004c03a 	cmpne	r2,r2,zero
 d036cb8:	1000441e 	bne	r2,zero,d036dcc <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 d036cbc:	e0bffb17 	ldw	r2,-20(fp)
 d036cc0:	11803517 	ldw	r6,212(r2)
 d036cc4:	e0bffb17 	ldw	r2,-20(fp)
 d036cc8:	10800a17 	ldw	r2,40(r2)
 d036ccc:	1007883a 	mov	r3,r2
 d036cd0:	e0bfff17 	ldw	r2,-4(fp)
 d036cd4:	1889883a 	add	r4,r3,r2
 d036cd8:	01400804 	movi	r5,32
 d036cdc:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 d036ce0:	e0bffb17 	ldw	r2,-20(fp)
 d036ce4:	11803517 	ldw	r6,212(r2)
 d036ce8:	e0bffb17 	ldw	r2,-20(fp)
 d036cec:	10800a17 	ldw	r2,40(r2)
 d036cf0:	1007883a 	mov	r3,r2
 d036cf4:	e0bfff17 	ldw	r2,-4(fp)
 d036cf8:	1889883a 	add	r4,r3,r2
 d036cfc:	01403404 	movi	r5,208
 d036d00:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 d036d04:	e0bffb17 	ldw	r2,-20(fp)
 d036d08:	10800a17 	ldw	r2,40(r2)
 d036d0c:	1007883a 	mov	r3,r2
 d036d10:	e0bfff17 	ldw	r2,-4(fp)
 d036d14:	1885883a 	add	r2,r3,r2
 d036d18:	10800023 	ldbuio	r2,0(r2)
 d036d1c:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 d036d20:	e0bffd03 	ldbu	r2,-12(fp)
 d036d24:	10803fcc 	andi	r2,r2,255
 d036d28:	1080201c 	xori	r2,r2,128
 d036d2c:	10bfe004 	addi	r2,r2,-128
 d036d30:	1004803a 	cmplt	r2,r2,zero
 d036d34:	1000081e 	bne	r2,zero,d036d58 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 d036d38:	0100fa04 	movi	r4,1000
 d036d3c:	d035fd00 	call	d035fd0 <usleep>
      timeout -= 1000;
 d036d40:	e0bffa17 	ldw	r2,-24(fp)
 d036d44:	10bf0604 	addi	r2,r2,-1000
 d036d48:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 d036d4c:	e0bffa17 	ldw	r2,-24(fp)
 d036d50:	10800048 	cmpgei	r2,r2,1
 d036d54:	103feb1e 	bne	r2,zero,d036d04 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 d036d58:	e0bffa17 	ldw	r2,-24(fp)
 d036d5c:	10800048 	cmpgei	r2,r2,1
 d036d60:	1000031e 	bne	r2,zero,d036d70 <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 d036d64:	00bfe304 	movi	r2,-116
 d036d68:	e0bffc15 	stw	r2,-16(fp)
 d036d6c:	00000e06 	br	d036da8 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 d036d70:	e0bffd03 	ldbu	r2,-12(fp)
 d036d74:	10803fcc 	andi	r2,r2,255
 d036d78:	10801fcc 	andi	r2,r2,127
 d036d7c:	1005003a 	cmpeq	r2,r2,zero
 d036d80:	1000091e 	bne	r2,zero,d036da8 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 d036d84:	00bffec4 	movi	r2,-5
 d036d88:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 d036d8c:	e0bffb17 	ldw	r2,-20(fp)
 d036d90:	10800a17 	ldw	r2,40(r2)
 d036d94:	1007883a 	mov	r3,r2
 d036d98:	e0bfff17 	ldw	r2,-4(fp)
 d036d9c:	1885883a 	add	r2,r3,r2
 d036da0:	10800023 	ldbuio	r2,0(r2)
 d036da4:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 d036da8:	e0bffb17 	ldw	r2,-20(fp)
 d036dac:	11803517 	ldw	r6,212(r2)
 d036db0:	e0bffb17 	ldw	r2,-20(fp)
 d036db4:	10800a17 	ldw	r2,40(r2)
 d036db8:	1007883a 	mov	r3,r2
 d036dbc:	e0bfff17 	ldw	r2,-4(fp)
 d036dc0:	1889883a 	add	r4,r3,r2
 d036dc4:	01403fc4 	movi	r5,255
 d036dc8:	303ee83a 	callr	r6
  }
  
  return ret_code;
 d036dcc:	e0bffc17 	ldw	r2,-16(fp)
}
 d036dd0:	e037883a 	mov	sp,fp
 d036dd4:	dfc00117 	ldw	ra,4(sp)
 d036dd8:	df000017 	ldw	fp,0(sp)
 d036ddc:	dec00204 	addi	sp,sp,8
 d036de0:	f800283a 	ret

0d036de4 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 d036de4:	defff904 	addi	sp,sp,-28
 d036de8:	dfc00615 	stw	ra,24(sp)
 d036dec:	df000515 	stw	fp,20(sp)
 d036df0:	df000504 	addi	fp,sp,20
 d036df4:	e13ffe15 	stw	r4,-8(fp)
 d036df8:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 d036dfc:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 d036e00:	e0bffe17 	ldw	r2,-8(fp)
 d036e04:	11003017 	ldw	r4,192(r2)
 d036e08:	01401904 	movi	r5,100
 d036e0c:	d00235c0 	call	d00235c <__mulsi3>
 d036e10:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 d036e14:	e0bffe17 	ldw	r2,-8(fp)
 d036e18:	11803517 	ldw	r6,212(r2)
 d036e1c:	e0bffe17 	ldw	r2,-8(fp)
 d036e20:	10800a17 	ldw	r2,40(r2)
 d036e24:	1007883a 	mov	r3,r2
 d036e28:	e0bfff17 	ldw	r2,-4(fp)
 d036e2c:	1889883a 	add	r4,r3,r2
 d036e30:	01402404 	movi	r5,144
 d036e34:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 d036e38:	e0bffe17 	ldw	r2,-8(fp)
 d036e3c:	10800a17 	ldw	r2,40(r2)
 d036e40:	1007883a 	mov	r3,r2
 d036e44:	e0bfff17 	ldw	r2,-4(fp)
 d036e48:	1885883a 	add	r2,r3,r2
 d036e4c:	10800104 	addi	r2,r2,4
 d036e50:	10800023 	ldbuio	r2,0(r2)
 d036e54:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 d036e58:	e0bffd43 	ldbu	r2,-11(fp)
 d036e5c:	1080004c 	andi	r2,r2,1
 d036e60:	10803fcc 	andi	r2,r2,255
 d036e64:	1005003a 	cmpeq	r2,r2,zero
 d036e68:	1000331e 	bne	r2,zero,d036f38 <alt_unlock_block_intel+0x154>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 d036e6c:	e0bffe17 	ldw	r2,-8(fp)
 d036e70:	11803517 	ldw	r6,212(r2)
 d036e74:	e0bffe17 	ldw	r2,-8(fp)
 d036e78:	10800a17 	ldw	r2,40(r2)
 d036e7c:	1007883a 	mov	r3,r2
 d036e80:	e0bfff17 	ldw	r2,-4(fp)
 d036e84:	1889883a 	add	r4,r3,r2
 d036e88:	01401804 	movi	r5,96
 d036e8c:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 d036e90:	e0bffe17 	ldw	r2,-8(fp)
 d036e94:	11803517 	ldw	r6,212(r2)
 d036e98:	e0bffe17 	ldw	r2,-8(fp)
 d036e9c:	10800a17 	ldw	r2,40(r2)
 d036ea0:	1007883a 	mov	r3,r2
 d036ea4:	e0bfff17 	ldw	r2,-4(fp)
 d036ea8:	1889883a 	add	r4,r3,r2
 d036eac:	01403404 	movi	r5,208
 d036eb0:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 d036eb4:	e0bffe17 	ldw	r2,-8(fp)
 d036eb8:	10800a17 	ldw	r2,40(r2)
 d036ebc:	1007883a 	mov	r3,r2
 d036ec0:	e0bfff17 	ldw	r2,-4(fp)
 d036ec4:	1885883a 	add	r2,r3,r2
 d036ec8:	10800023 	ldbuio	r2,0(r2)
 d036ecc:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 d036ed0:	e0bffd03 	ldbu	r2,-12(fp)
 d036ed4:	10803fcc 	andi	r2,r2,255
 d036ed8:	1080201c 	xori	r2,r2,128
 d036edc:	10bfe004 	addi	r2,r2,-128
 d036ee0:	1004803a 	cmplt	r2,r2,zero
 d036ee4:	1000081e 	bne	r2,zero,d036f08 <alt_unlock_block_intel+0x124>
      {
        break;
      }
      timeout--;
 d036ee8:	e0bffb17 	ldw	r2,-20(fp)
 d036eec:	10bfffc4 	addi	r2,r2,-1
 d036ef0:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 d036ef4:	01000044 	movi	r4,1
 d036ef8:	d035fd00 	call	d035fd0 <usleep>
    }while(timeout > 0);
 d036efc:	e0bffb17 	ldw	r2,-20(fp)
 d036f00:	10800048 	cmpgei	r2,r2,1
 d036f04:	103feb1e 	bne	r2,zero,d036eb4 <alt_unlock_block_intel+0xd0>

    if (timeout == 0)
 d036f08:	e0bffb17 	ldw	r2,-20(fp)
 d036f0c:	1004c03a 	cmpne	r2,r2,zero
 d036f10:	1000031e 	bne	r2,zero,d036f20 <alt_unlock_block_intel+0x13c>
    {
      ret_code = -ETIMEDOUT;
 d036f14:	00bfe304 	movi	r2,-116
 d036f18:	e0bffc15 	stw	r2,-16(fp)
 d036f1c:	00000606 	br	d036f38 <alt_unlock_block_intel+0x154>
    }
    else if (status & 0x7f)
 d036f20:	e0bffd03 	ldbu	r2,-12(fp)
 d036f24:	10801fcc 	andi	r2,r2,127
 d036f28:	1005003a 	cmpeq	r2,r2,zero
 d036f2c:	1000021e 	bne	r2,zero,d036f38 <alt_unlock_block_intel+0x154>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 d036f30:	00bffec4 	movi	r2,-5
 d036f34:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 d036f38:	e0bffe17 	ldw	r2,-8(fp)
 d036f3c:	11803517 	ldw	r6,212(r2)
 d036f40:	e0bffe17 	ldw	r2,-8(fp)
 d036f44:	10800a17 	ldw	r2,40(r2)
 d036f48:	1007883a 	mov	r3,r2
 d036f4c:	e0bfff17 	ldw	r2,-4(fp)
 d036f50:	1889883a 	add	r4,r3,r2
 d036f54:	01403fc4 	movi	r5,255
 d036f58:	303ee83a 	callr	r6

  return ret_code;
 d036f5c:	e0bffc17 	ldw	r2,-16(fp)
}
 d036f60:	e037883a 	mov	sp,fp
 d036f64:	dfc00117 	ldw	ra,4(sp)
 d036f68:	df000017 	ldw	fp,0(sp)
 d036f6c:	dec00204 	addi	sp,sp,8
 d036f70:	f800283a 	ret

0d036f74 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 d036f74:	defff904 	addi	sp,sp,-28
 d036f78:	dfc00615 	stw	ra,24(sp)
 d036f7c:	df000515 	stw	fp,20(sp)
 d036f80:	df000504 	addi	fp,sp,20
 d036f84:	e13ffd15 	stw	r4,-12(fp)
 d036f88:	e17ffe15 	stw	r5,-8(fp)
 d036f8c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 d036f90:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 d036f94:	e0bffd17 	ldw	r2,-12(fp)
 d036f98:	11803517 	ldw	r6,212(r2)
 d036f9c:	e0bffd17 	ldw	r2,-12(fp)
 d036fa0:	10800a17 	ldw	r2,40(r2)
 d036fa4:	1007883a 	mov	r3,r2
 d036fa8:	e0bffe17 	ldw	r2,-8(fp)
 d036fac:	1889883a 	add	r4,r3,r2
 d036fb0:	01401004 	movi	r5,64
 d036fb4:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 d036fb8:	e13ffd17 	ldw	r4,-12(fp)
 d036fbc:	e17ffe17 	ldw	r5,-8(fp)
 d036fc0:	e1bfff17 	ldw	r6,-4(fp)
 d036fc4:	d0164480 	call	d016448 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 d036fc8:	e0bffd17 	ldw	r2,-12(fp)
 d036fcc:	10800a17 	ldw	r2,40(r2)
 d036fd0:	1007883a 	mov	r3,r2
 d036fd4:	e0bffe17 	ldw	r2,-8(fp)
 d036fd8:	1885883a 	add	r2,r3,r2
 d036fdc:	10800023 	ldbuio	r2,0(r2)
 d036fe0:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 d036fe4:	e0bffb03 	ldbu	r2,-20(fp)
 d036fe8:	10803fcc 	andi	r2,r2,255
 d036fec:	1080201c 	xori	r2,r2,128
 d036ff0:	10bfe004 	addi	r2,r2,-128
 d036ff4:	1004403a 	cmpge	r2,r2,zero
 d036ff8:	103ff31e 	bne	r2,zero,d036fc8 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 d036ffc:	e0bffb03 	ldbu	r2,-20(fp)
 d037000:	10801fcc 	andi	r2,r2,127
 d037004:	1005003a 	cmpeq	r2,r2,zero
 d037008:	1000021e 	bne	r2,zero,d037014 <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 d03700c:	00bffec4 	movi	r2,-5
 d037010:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 d037014:	e0bffd17 	ldw	r2,-12(fp)
 d037018:	11803517 	ldw	r6,212(r2)
 d03701c:	e0bffd17 	ldw	r2,-12(fp)
 d037020:	10800a17 	ldw	r2,40(r2)
 d037024:	1007883a 	mov	r3,r2
 d037028:	e0bffe17 	ldw	r2,-8(fp)
 d03702c:	1889883a 	add	r4,r3,r2
 d037030:	01403fc4 	movi	r5,255
 d037034:	303ee83a 	callr	r6
  
  return ret_code;
 d037038:	e0bffc17 	ldw	r2,-16(fp)
}
 d03703c:	e037883a 	mov	sp,fp
 d037040:	dfc00117 	ldw	ra,4(sp)
 d037044:	df000017 	ldw	fp,0(sp)
 d037048:	dec00204 	addi	sp,sp,8
 d03704c:	f800283a 	ret

0d037050 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 d037050:	defff404 	addi	sp,sp,-48
 d037054:	df000b15 	stw	fp,44(sp)
 d037058:	df000b04 	addi	fp,sp,44
 d03705c:	e13ffc15 	stw	r4,-16(fp)
 d037060:	e17ffd15 	stw	r5,-12(fp)
 d037064:	e1bffe15 	stw	r6,-8(fp)
 d037068:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
 d03706c:	e0fffe17 	ldw	r3,-8(fp)
 d037070:	e0bfff17 	ldw	r2,-4(fp)
 d037074:	10c5883a 	add	r2,r2,r3
 d037078:	e0bffb15 	stw	r2,-20(fp)
  alt_u8 * read_end = read_data + read_length;
 d03707c:	e0c00117 	ldw	r3,4(fp)
 d037080:	e0800217 	ldw	r2,8(fp)
 d037084:	10c5883a 	add	r2,r2,r3
 d037088:	e0bffa15 	stw	r2,-24(fp)

  alt_u32 write_zeros = read_length;
 d03708c:	e0800117 	ldw	r2,4(fp)
 d037090:	e0bff915 	stw	r2,-28(fp)
  alt_u32 read_ignore = write_length;
 d037094:	e0bffe17 	ldw	r2,-8(fp)
 d037098:	e0bff815 	stw	r2,-32(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 d03709c:	00800044 	movi	r2,1
 d0370a0:	e0bff615 	stw	r2,-40(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 d0370a4:	e0bffc17 	ldw	r2,-16(fp)
 d0370a8:	11000504 	addi	r4,r2,20
 d0370ac:	e0fffd17 	ldw	r3,-12(fp)
 d0370b0:	00800044 	movi	r2,1
 d0370b4:	10c6983a 	sll	r3,r2,r3
 d0370b8:	2005883a 	mov	r2,r4
 d0370bc:	10c00035 	stwio	r3,0(r2)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 d0370c0:	e0800317 	ldw	r2,12(fp)
 d0370c4:	1080008c 	andi	r2,r2,2
 d0370c8:	1004c03a 	cmpne	r2,r2,zero
 d0370cc:	1000051e 	bne	r2,zero,d0370e4 <alt_avalon_spi_command+0x94>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 d0370d0:	e0bffc17 	ldw	r2,-16(fp)
 d0370d4:	10800304 	addi	r2,r2,12
 d0370d8:	1007883a 	mov	r3,r2
 d0370dc:	00810004 	movi	r2,1024
 d0370e0:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 d0370e4:	e0bffc17 	ldw	r2,-16(fp)
 d0370e8:	10800037 	ldwio	r2,0(r2)
 d0370ec:	00000006 	br	d0370f0 <alt_avalon_spi_command+0xa0>
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 d0370f0:	e0bffc17 	ldw	r2,-16(fp)
 d0370f4:	10800204 	addi	r2,r2,8
 d0370f8:	10800037 	ldwio	r2,0(r2)
 d0370fc:	e0bff715 	stw	r2,-36(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 d037100:	e0bff717 	ldw	r2,-36(fp)
 d037104:	1080100c 	andi	r2,r2,64
 d037108:	1005003a 	cmpeq	r2,r2,zero
 d03710c:	1000031e 	bne	r2,zero,d03711c <alt_avalon_spi_command+0xcc>
 d037110:	e0bff617 	ldw	r2,-40(fp)
 d037114:	1004c03a 	cmpne	r2,r2,zero
 d037118:	1000041e 	bne	r2,zero,d03712c <alt_avalon_spi_command+0xdc>
 d03711c:	e0bff717 	ldw	r2,-36(fp)
 d037120:	1080200c 	andi	r2,r2,128
 d037124:	1005003a 	cmpeq	r2,r2,zero
 d037128:	103ff11e 	bne	r2,zero,d0370f0 <alt_avalon_spi_command+0xa0>

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 d03712c:	e0bff717 	ldw	r2,-36(fp)
 d037130:	1080100c 	andi	r2,r2,64
 d037134:	1005003a 	cmpeq	r2,r2,zero
 d037138:	1000201e 	bne	r2,zero,d0371bc <alt_avalon_spi_command+0x16c>
 d03713c:	e0bff617 	ldw	r2,-40(fp)
 d037140:	10800050 	cmplti	r2,r2,1
 d037144:	10001d1e 	bne	r2,zero,d0371bc <alt_avalon_spi_command+0x16c>
    {
      credits--;
 d037148:	e0bff617 	ldw	r2,-40(fp)
 d03714c:	10bfffc4 	addi	r2,r2,-1
 d037150:	e0bff615 	stw	r2,-40(fp)

      if (write_data < write_end)
 d037154:	e0ffff17 	ldw	r3,-4(fp)
 d037158:	e0bffb17 	ldw	r2,-20(fp)
 d03715c:	18800b2e 	bgeu	r3,r2,d03718c <alt_avalon_spi_command+0x13c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 d037160:	e0bffc17 	ldw	r2,-16(fp)
 d037164:	11000104 	addi	r4,r2,4
 d037168:	e0bfff17 	ldw	r2,-4(fp)
 d03716c:	10800003 	ldbu	r2,0(r2)
 d037170:	10c03fcc 	andi	r3,r2,255
 d037174:	e0bfff17 	ldw	r2,-4(fp)
 d037178:	10800044 	addi	r2,r2,1
 d03717c:	e0bfff15 	stw	r2,-4(fp)
 d037180:	2005883a 	mov	r2,r4
 d037184:	10c00035 	stwio	r3,0(r2)
 d037188:	00000c06 	br	d0371bc <alt_avalon_spi_command+0x16c>
      else if (write_zeros > 0)
 d03718c:	e0bff917 	ldw	r2,-28(fp)
 d037190:	1005003a 	cmpeq	r2,r2,zero
 d037194:	1000071e 	bne	r2,zero,d0371b4 <alt_avalon_spi_command+0x164>
      {
        write_zeros--;
 d037198:	e0bff917 	ldw	r2,-28(fp)
 d03719c:	10bfffc4 	addi	r2,r2,-1
 d0371a0:	e0bff915 	stw	r2,-28(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 d0371a4:	e0bffc17 	ldw	r2,-16(fp)
 d0371a8:	10800104 	addi	r2,r2,4
 d0371ac:	10000035 	stwio	zero,0(r2)
 d0371b0:	00000206 	br	d0371bc <alt_avalon_spi_command+0x16c>
      }
      else
        credits = -1024;
 d0371b4:	00bf0004 	movi	r2,-1024
 d0371b8:	e0bff615 	stw	r2,-40(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 d0371bc:	e0bff717 	ldw	r2,-36(fp)
 d0371c0:	1080200c 	andi	r2,r2,128
 d0371c4:	1005003a 	cmpeq	r2,r2,zero
 d0371c8:	103fc91e 	bne	r2,zero,d0370f0 <alt_avalon_spi_command+0xa0>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 d0371cc:	e0bffc17 	ldw	r2,-16(fp)
 d0371d0:	10800037 	ldwio	r2,0(r2)
 d0371d4:	e0bff515 	stw	r2,-44(fp)

      if (read_ignore > 0)
 d0371d8:	e0bff817 	ldw	r2,-32(fp)
 d0371dc:	1005003a 	cmpeq	r2,r2,zero
 d0371e0:	1000041e 	bne	r2,zero,d0371f4 <alt_avalon_spi_command+0x1a4>
        read_ignore--;
 d0371e4:	e0bff817 	ldw	r2,-32(fp)
 d0371e8:	10bfffc4 	addi	r2,r2,-1
 d0371ec:	e0bff815 	stw	r2,-32(fp)
 d0371f0:	00000706 	br	d037210 <alt_avalon_spi_command+0x1c0>
      else
        *read_data++ = (alt_u8)rxdata;
 d0371f4:	e0bff517 	ldw	r2,-44(fp)
 d0371f8:	1007883a 	mov	r3,r2
 d0371fc:	e0800217 	ldw	r2,8(fp)
 d037200:	10c00005 	stb	r3,0(r2)
 d037204:	e0800217 	ldw	r2,8(fp)
 d037208:	10800044 	addi	r2,r2,1
 d03720c:	e0800215 	stw	r2,8(fp)
      credits++;
 d037210:	e0bff617 	ldw	r2,-40(fp)
 d037214:	10800044 	addi	r2,r2,1
 d037218:	e0bff615 	stw	r2,-40(fp)

      if (read_ignore == 0 && read_data == read_end)
 d03721c:	e0bff817 	ldw	r2,-32(fp)
 d037220:	1004c03a 	cmpne	r2,r2,zero
 d037224:	103fb21e 	bne	r2,zero,d0370f0 <alt_avalon_spi_command+0xa0>
 d037228:	e0c00217 	ldw	r3,8(fp)
 d03722c:	e0bffa17 	ldw	r2,-24(fp)
 d037230:	18800126 	beq	r3,r2,d037238 <alt_avalon_spi_command+0x1e8>
        break;
    }
    
  }
 d037234:	003fae06 	br	d0370f0 <alt_avalon_spi_command+0xa0>

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 d037238:	e0bffc17 	ldw	r2,-16(fp)
 d03723c:	10800204 	addi	r2,r2,8
 d037240:	10800037 	ldwio	r2,0(r2)
 d037244:	e0bff715 	stw	r2,-36(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 d037248:	e0bff717 	ldw	r2,-36(fp)
 d03724c:	1080080c 	andi	r2,r2,32
 d037250:	1005003a 	cmpeq	r2,r2,zero
 d037254:	103ff81e 	bne	r2,zero,d037238 <alt_avalon_spi_command+0x1e8>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 d037258:	e0800317 	ldw	r2,12(fp)
 d03725c:	1080004c 	andi	r2,r2,1
 d037260:	1004c03a 	cmpne	r2,r2,zero
 d037264:	1000031e 	bne	r2,zero,d037274 <alt_avalon_spi_command+0x224>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 d037268:	e0bffc17 	ldw	r2,-16(fp)
 d03726c:	10800304 	addi	r2,r2,12
 d037270:	10000035 	stwio	zero,0(r2)

  return read_length;
 d037274:	e0800117 	ldw	r2,4(fp)
}
 d037278:	e037883a 	mov	sp,fp
 d03727c:	df000017 	ldw	fp,0(sp)
 d037280:	dec00104 	addi	sp,sp,4
 d037284:	f800283a 	ret

0d037288 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 d037288:	defffb04 	addi	sp,sp,-20
 d03728c:	df000115 	stw	fp,4(sp)
 d037290:	df000104 	addi	fp,sp,4
 d037294:	e1400115 	stw	r5,4(fp)
 d037298:	e1800215 	stw	r6,8(fp)
 d03729c:	e1c00315 	stw	r7,12(fp)
 d0372a0:	e13fff15 	stw	r4,-4(fp)
 d0372a4:	e037883a 	mov	sp,fp
 d0372a8:	df000017 	ldw	fp,0(sp)
 d0372ac:	dec00404 	addi	sp,sp,16
 d0372b0:	f800283a 	ret

0d0372b4 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 d0372b4:	defffb04 	addi	sp,sp,-20
 d0372b8:	df000415 	stw	fp,16(sp)
 d0372bc:	df000404 	addi	fp,sp,16
 d0372c0:	e13ffc15 	stw	r4,-16(fp)
 d0372c4:	e17ffd15 	stw	r5,-12(fp)
 d0372c8:	e1bffe15 	stw	r6,-8(fp)
 d0372cc:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 d0372d0:	e0fffd17 	ldw	r3,-12(fp)
 d0372d4:	e0bffc17 	ldw	r2,-16(fp)
 d0372d8:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 d0372dc:	e0fffe17 	ldw	r3,-8(fp)
 d0372e0:	e0bffc17 	ldw	r2,-16(fp)
 d0372e4:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 d0372e8:	e0ffff17 	ldw	r3,-4(fp)
 d0372ec:	e0bffc17 	ldw	r2,-16(fp)
 d0372f0:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 d0372f4:	e0c00117 	ldw	r3,4(fp)
 d0372f8:	e0bffc17 	ldw	r2,-16(fp)
 d0372fc:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 d037300:	0005883a 	mov	r2,zero
}
 d037304:	e037883a 	mov	sp,fp
 d037308:	df000017 	ldw	fp,0(sp)
 d03730c:	dec00104 	addi	sp,sp,4
 d037310:	f800283a 	ret

0d037314 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 d037314:	defff904 	addi	sp,sp,-28
 d037318:	dfc00615 	stw	ra,24(sp)
 d03731c:	df000515 	stw	fp,20(sp)
 d037320:	df000504 	addi	fp,sp,20
 d037324:	e13ffd15 	stw	r4,-12(fp)
 d037328:	e17ffe15 	stw	r5,-8(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 d03732c:	e03ffb85 	stb	zero,-18(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 d037330:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 d037334:	00000d06 	br	d03736c <tse_mac_sTxWrite+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 d037338:	e0bffc17 	ldw	r2,-16(fp)
 d03733c:	10800044 	addi	r2,r2,1
 d037340:	e0bffc15 	stw	r2,-16(fp)
 d037344:	e0fffc17 	ldw	r3,-16(fp)
 d037348:	008003f4 	movhi	r2,15
 d03734c:	10909044 	addi	r2,r2,16961
 d037350:	1880061e 	bne	r3,r2,d03736c <tse_mac_sTxWrite+0x58>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 d037354:	01034174 	movhi	r4,3333
 d037358:	213ed604 	addi	r4,r4,-1192
 d03735c:	d002bc80 	call	d002bc8 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 d037360:	00bffa84 	movi	r2,-22
 d037364:	e0bfff15 	stw	r2,-4(fp)
 d037368:	00002006 	br	d0373ec <tse_mac_sTxWrite+0xd8>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 d03736c:	e0bffd17 	ldw	r2,-12(fp)
 d037370:	10800117 	ldw	r2,4(r2)
 d037374:	10800317 	ldw	r2,12(r2)
 d037378:	10800037 	ldwio	r2,0(r2)
 d03737c:	1080040c 	andi	r2,r2,16
 d037380:	1004c03a 	cmpne	r2,r2,zero
 d037384:	103fec1e 	bne	r2,zero,d037338 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 d037388:	e0bffd17 	ldw	r2,-12(fp)
 d03738c:	10800117 	ldw	r2,4(r2)
 d037390:	10800317 	ldw	r2,12(r2)
 d037394:	10800404 	addi	r2,r2,16
 d037398:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 d03739c:	e0bffd17 	ldw	r2,-12(fp)
 d0373a0:	10800117 	ldw	r2,4(r2)
 d0373a4:	10800317 	ldw	r2,12(r2)
 d0373a8:	1007883a 	mov	r3,r2
 d0373ac:	00803fc4 	movi	r2,255
 d0373b0:	18800035 	stwio	r2,0(r3)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 d0373b4:	e0bffd17 	ldw	r2,-12(fp)
 d0373b8:	11000117 	ldw	r4,4(r2)
 d0373bc:	e17ffe17 	ldw	r5,-8(fp)
 d0373c0:	d0195b40 	call	d0195b4 <alt_avalon_sgdma_do_sync_transfer>
 d0373c4:	e0bffb85 	stb	r2,-18(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 d0373c8:	e0bffe17 	ldw	r2,-8(fp)
 d0373cc:	10800704 	addi	r2,r2,28
 d0373d0:	10800037 	ldwio	r2,0(r2)
 d0373d4:	1007883a 	mov	r3,r2
 d0373d8:	00bfffc4 	movi	r2,-1
 d0373dc:	1884703a 	and	r2,r3,r2
 d0373e0:	e0bffb0d 	sth	r2,-20(fp)

  return actualBytesTransferred;
 d0373e4:	e0bffb0b 	ldhu	r2,-20(fp)
 d0373e8:	e0bfff15 	stw	r2,-4(fp)
 d0373ec:	e0bfff17 	ldw	r2,-4(fp)
}
 d0373f0:	e037883a 	mov	sp,fp
 d0373f4:	dfc00117 	ldw	ra,4(sp)
 d0373f8:	df000017 	ldw	fp,0(sp)
 d0373fc:	dec00204 	addi	sp,sp,8
 d037400:	f800283a 	ret

0d037404 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 d037404:	defff904 	addi	sp,sp,-28
 d037408:	dfc00615 	stw	ra,24(sp)
 d03740c:	df000515 	stw	fp,20(sp)
 d037410:	df000504 	addi	fp,sp,20
 d037414:	e13ffd15 	stw	r4,-12(fp)
 d037418:	e17ffe15 	stw	r5,-8(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 d03741c:	e03ffb05 	stb	zero,-20(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 d037420:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 d037424:	00000d06 	br	d03745c <tse_mac_aRxRead+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 d037428:	e0bffc17 	ldw	r2,-16(fp)
 d03742c:	10800044 	addi	r2,r2,1
 d037430:	e0bffc15 	stw	r2,-16(fp)
 d037434:	e0fffc17 	ldw	r3,-16(fp)
 d037438:	008003f4 	movhi	r2,15
 d03743c:	10909044 	addi	r2,r2,16961
 d037440:	1880061e 	bne	r3,r2,d03745c <tse_mac_aRxRead+0x58>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 d037444:	01034174 	movhi	r4,3333
 d037448:	213edd04 	addi	r4,r4,-1164
 d03744c:	d002bc80 	call	d002bc8 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 d037450:	00bffa84 	movi	r2,-22
 d037454:	e0bfff15 	stw	r2,-4(fp)
 d037458:	00000d06 	br	d037490 <tse_mac_aRxRead+0x8c>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 d03745c:	e0bffd17 	ldw	r2,-12(fp)
 d037460:	10800217 	ldw	r2,8(r2)
 d037464:	10800317 	ldw	r2,12(r2)
 d037468:	10800037 	ldwio	r2,0(r2)
 d03746c:	1080040c 	andi	r2,r2,16
 d037470:	1004c03a 	cmpne	r2,r2,zero
 d037474:	103fec1e 	bne	r2,zero,d037428 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 d037478:	e0bffd17 	ldw	r2,-12(fp)
 d03747c:	11000217 	ldw	r4,8(r2)
 d037480:	e17ffe17 	ldw	r5,-8(fp)
 d037484:	d0194780 	call	d019478 <alt_avalon_sgdma_do_async_transfer>
 d037488:	e0bffb05 	stb	r2,-20(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
 d03748c:	e03fff15 	stw	zero,-4(fp)
 d037490:	e0bfff17 	ldw	r2,-4(fp)
}
 d037494:	e037883a 	mov	sp,fp
 d037498:	dfc00117 	ldw	ra,4(sp)
 d03749c:	df000017 	ldw	fp,0(sp)
 d0374a0:	dec00204 	addi	sp,sp,8
 d0374a4:	f800283a 	ret

0d0374a8 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 d0374a8:	defffc04 	addi	sp,sp,-16
 d0374ac:	df000315 	stw	fp,12(sp)
 d0374b0:	df000304 	addi	fp,sp,12
 d0374b4:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d0374b8:	e0bfff17 	ldw	r2,-4(fp)
 d0374bc:	10800204 	addi	r2,r2,8
 d0374c0:	10800037 	ldwio	r2,0(r2)
 d0374c4:	e0bffd15 	stw	r2,-12(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 d0374c8:	e0bfff17 	ldw	r2,-4(fp)
 d0374cc:	10800204 	addi	r2,r2,8
 d0374d0:	1007883a 	mov	r3,r2
 d0374d4:	00880204 	movi	r2,8200
 d0374d8:	18800035 	stwio	r2,0(r3)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 d0374dc:	e03ffe15 	stw	zero,-8(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 d0374e0:	00000306 	br	d0374f0 <tse_mac_SwReset+0x48>
 d0374e4:	e0bffe17 	ldw	r2,-8(fp)
 d0374e8:	10800044 	addi	r2,r2,1
 d0374ec:	e0bffe15 	stw	r2,-8(fp)
 d0374f0:	e0bfff17 	ldw	r2,-4(fp)
 d0374f4:	10800204 	addi	r2,r2,8
 d0374f8:	10800037 	ldwio	r2,0(r2)
 d0374fc:	1088000c 	andi	r2,r2,8192
 d037500:	1005003a 	cmpeq	r2,r2,zero
 d037504:	1000031e 	bne	r2,zero,d037514 <tse_mac_SwReset+0x6c>
 d037508:	e0bffe17 	ldw	r2,-8(fp)
 d03750c:	1089c410 	cmplti	r2,r2,10000
 d037510:	103ff41e 	bne	r2,zero,d0374e4 <tse_mac_SwReset+0x3c>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 d037514:	e0bfff17 	ldw	r2,-4(fp)
 d037518:	10800204 	addi	r2,r2,8
 d03751c:	1007883a 	mov	r3,r2
 d037520:	e0bffd17 	ldw	r2,-12(fp)
 d037524:	18800035 	stwio	r2,0(r3)
    return SUCCESS;
 d037528:	0005883a 	mov	r2,zero
}
 d03752c:	e037883a 	mov	sp,fp
 d037530:	df000017 	ldw	fp,0(sp)
 d037534:	dec00104 	addi	sp,sp,4
 d037538:	f800283a 	ret

0d03753c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 d03753c:	defffd04 	addi	sp,sp,-12
 d037540:	df000215 	stw	fp,8(sp)
 d037544:	df000204 	addi	fp,sp,8
 d037548:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d03754c:	e0bfff17 	ldw	r2,-4(fp)
 d037550:	10800204 	addi	r2,r2,8
 d037554:	10800037 	ldwio	r2,0(r2)
 d037558:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 d03755c:	e0fffe17 	ldw	r3,-8(fp)
 d037560:	00bffdc4 	movi	r2,-9
 d037564:	1884703a 	and	r2,r3,r2
 d037568:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 d03756c:	e0bfff17 	ldw	r2,-4(fp)
 d037570:	10800204 	addi	r2,r2,8
 d037574:	1007883a 	mov	r3,r2
 d037578:	e0bffe17 	ldw	r2,-8(fp)
 d03757c:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d037580:	0005883a 	mov	r2,zero
}
 d037584:	e037883a 	mov	sp,fp
 d037588:	df000017 	ldw	fp,0(sp)
 d03758c:	dec00104 	addi	sp,sp,4
 d037590:	f800283a 	ret

0d037594 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 d037594:	defffd04 	addi	sp,sp,-12
 d037598:	df000215 	stw	fp,8(sp)
 d03759c:	df000204 	addi	fp,sp,8
 d0375a0:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d0375a4:	e0bfff17 	ldw	r2,-4(fp)
 d0375a8:	10800204 	addi	r2,r2,8
 d0375ac:	10800037 	ldwio	r2,0(r2)
 d0375b0:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d0375b4:	e0bffe17 	ldw	r2,-8(fp)
 d0375b8:	10800214 	ori	r2,r2,8
 d0375bc:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 d0375c0:	e0bfff17 	ldw	r2,-4(fp)
 d0375c4:	10800204 	addi	r2,r2,8
 d0375c8:	1007883a 	mov	r3,r2
 d0375cc:	e0bffe17 	ldw	r2,-8(fp)
 d0375d0:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d0375d4:	0005883a 	mov	r2,zero
}
 d0375d8:	e037883a 	mov	sp,fp
 d0375dc:	df000017 	ldw	fp,0(sp)
 d0375e0:	dec00104 	addi	sp,sp,4
 d0375e4:	f800283a 	ret

0d0375e8 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 d0375e8:	defffa04 	addi	sp,sp,-24
 d0375ec:	dfc00515 	stw	ra,20(sp)
 d0375f0:	df000415 	stw	fp,16(sp)
 d0375f4:	dc000315 	stw	r16,12(sp)
 d0375f8:	df000304 	addi	fp,sp,12
 d0375fc:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 d037600:	e03ffd15 	stw	zero,-12(fp)
 d037604:	00002706 	br	d0376a4 <alt_tse_phy_add_profile+0xbc>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 d037608:	e0bffd17 	ldw	r2,-12(fp)
 d03760c:	00c341b4 	movhi	r3,3334
 d037610:	18c50604 	addi	r3,r3,5144
 d037614:	1085883a 	add	r2,r2,r2
 d037618:	1085883a 	add	r2,r2,r2
 d03761c:	10c5883a 	add	r2,r2,r3
 d037620:	10800017 	ldw	r2,0(r2)
 d037624:	10c01417 	ldw	r3,80(r2)
 d037628:	e0bffe17 	ldw	r2,-8(fp)
 d03762c:	10801417 	ldw	r2,80(r2)
 d037630:	1880191e 	bne	r3,r2,d037698 <alt_tse_phy_add_profile+0xb0>
 d037634:	e0bffd17 	ldw	r2,-12(fp)
 d037638:	00c341b4 	movhi	r3,3334
 d03763c:	18c50604 	addi	r3,r3,5144
 d037640:	1085883a 	add	r2,r2,r2
 d037644:	1085883a 	add	r2,r2,r2
 d037648:	10c5883a 	add	r2,r2,r3
 d03764c:	10800017 	ldw	r2,0(r2)
 d037650:	10c01503 	ldbu	r3,84(r2)
 d037654:	e0bffe17 	ldw	r2,-8(fp)
 d037658:	10801503 	ldbu	r2,84(r2)
 d03765c:	18c03fcc 	andi	r3,r3,255
 d037660:	10803fcc 	andi	r2,r2,255
 d037664:	18800c1e 	bne	r3,r2,d037698 <alt_tse_phy_add_profile+0xb0>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 d037668:	e0bffe17 	ldw	r2,-8(fp)
 d03766c:	10801417 	ldw	r2,80(r2)
 d037670:	100b883a 	mov	r5,r2
 d037674:	e0bffe17 	ldw	r2,-8(fp)
 d037678:	10801503 	ldbu	r2,84(r2)
 d03767c:	11803fcc 	andi	r6,r2,255
 d037680:	01034174 	movhi	r4,3333
 d037684:	213ee404 	addi	r4,r4,-1136
 d037688:	d0028a00 	call	d0028a0 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 d03768c:	01034174 	movhi	r4,3333
 d037690:	213ef804 	addi	r4,r4,-1056
 d037694:	d002bc80 	call	d002bc8 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 d037698:	e0bffd17 	ldw	r2,-12(fp)
 d03769c:	10800044 	addi	r2,r2,1
 d0376a0:	e0bffd15 	stw	r2,-12(fp)
 d0376a4:	d0a93803 	ldbu	r2,-23328(gp)
 d0376a8:	10c03fcc 	andi	r3,r2,255
 d0376ac:	e0bffd17 	ldw	r2,-12(fp)
 d0376b0:	10ffd516 	blt	r2,r3,d037608 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 d0376b4:	d0a93803 	ldbu	r2,-23328(gp)
 d0376b8:	14003fcc 	andi	r16,r2,255
 d0376bc:	01001904 	movi	r4,100
 d0376c0:	d04be300 	call	d04be30 <malloc>
 d0376c4:	1009883a 	mov	r4,r2
 d0376c8:	00c341b4 	movhi	r3,3334
 d0376cc:	18c50604 	addi	r3,r3,5144
 d0376d0:	8405883a 	add	r2,r16,r16
 d0376d4:	1085883a 	add	r2,r2,r2
 d0376d8:	10c5883a 	add	r2,r2,r3
 d0376dc:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 d0376e0:	d0a93803 	ldbu	r2,-23328(gp)
 d0376e4:	10803fcc 	andi	r2,r2,255
 d0376e8:	00c341b4 	movhi	r3,3334
 d0376ec:	18c50604 	addi	r3,r3,5144
 d0376f0:	1085883a 	add	r2,r2,r2
 d0376f4:	1085883a 	add	r2,r2,r2
 d0376f8:	10c5883a 	add	r2,r2,r3
 d0376fc:	10800017 	ldw	r2,0(r2)
 d037700:	1004c03a 	cmpne	r2,r2,zero
 d037704:	1000081e 	bne	r2,zero,d037728 <alt_tse_phy_add_profile+0x140>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 d037708:	d0a93803 	ldbu	r2,-23328(gp)
 d03770c:	11403fcc 	andi	r5,r2,255
 d037710:	01034174 	movhi	r4,3333
 d037714:	213f1004 	addi	r4,r4,-960
 d037718:	d0028a00 	call	d0028a0 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 d03771c:	00bfffc4 	movi	r2,-1
 d037720:	e0bfff15 	stw	r2,-4(fp)
 d037724:	00001f06 	br	d0377a4 <alt_tse_phy_add_profile+0x1bc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 d037728:	d0a93803 	ldbu	r2,-23328(gp)
 d03772c:	10803fcc 	andi	r2,r2,255
 d037730:	00c341b4 	movhi	r3,3334
 d037734:	18c50604 	addi	r3,r3,5144
 d037738:	1085883a 	add	r2,r2,r2
 d03773c:	1085883a 	add	r2,r2,r2
 d037740:	10c5883a 	add	r2,r2,r3
 d037744:	10800017 	ldw	r2,0(r2)
 d037748:	e0fffe17 	ldw	r3,-8(fp)
 d03774c:	1009883a 	mov	r4,r2
 d037750:	180b883a 	mov	r5,r3
 d037754:	01801904 	movi	r6,100
 d037758:	d0026080 	call	d002608 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 d03775c:	d0a93803 	ldbu	r2,-23328(gp)
 d037760:	10803fcc 	andi	r2,r2,255
 d037764:	00c341b4 	movhi	r3,3334
 d037768:	18c50604 	addi	r3,r3,5144
 d03776c:	1085883a 	add	r2,r2,r2
 d037770:	1085883a 	add	r2,r2,r2
 d037774:	10c5883a 	add	r2,r2,r3
 d037778:	10800017 	ldw	r2,0(r2)
 d03777c:	1009883a 	mov	r4,r2
 d037780:	e17ffe17 	ldw	r5,-8(fp)
 d037784:	d04beb80 	call	d04beb8 <strcpy>
    
    phy_profile_count++;
 d037788:	d0a93803 	ldbu	r2,-23328(gp)
 d03778c:	10800044 	addi	r2,r2,1
 d037790:	d0a93805 	stb	r2,-23328(gp)
    
    return phy_profile_count - 1;
 d037794:	d0a93803 	ldbu	r2,-23328(gp)
 d037798:	10803fcc 	andi	r2,r2,255
 d03779c:	10bfffc4 	addi	r2,r2,-1
 d0377a0:	e0bfff15 	stw	r2,-4(fp)
 d0377a4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0377a8:	e037883a 	mov	sp,fp
 d0377ac:	dfc00217 	ldw	ra,8(sp)
 d0377b0:	df000117 	ldw	fp,4(sp)
 d0377b4:	dc000017 	ldw	r16,0(sp)
 d0377b8:	dec00304 	addi	sp,sp,12
 d0377bc:	f800283a 	ret

0d0377c0 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 d0377c0:	deffef04 	addi	sp,sp,-68
 d0377c4:	dfc01015 	stw	ra,64(sp)
 d0377c8:	df000f15 	stw	fp,60(sp)
 d0377cc:	dc800e15 	stw	r18,56(sp)
 d0377d0:	dc400d15 	stw	r17,52(sp)
 d0377d4:	dc000c15 	stw	r16,48(sp)
 d0377d8:	df000c04 	addi	fp,sp,48
 d0377dc:	e13ffb15 	stw	r4,-20(fp)
 d0377e0:	e17ffc15 	stw	r5,-16(fp)
 d0377e4:	e1bffd15 	stw	r6,-12(fp)
 d0377e8:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 d0377ec:	e0bffb17 	ldw	r2,-20(fp)
 d0377f0:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 d0377f4:	e0bffc17 	ldw	r2,-16(fp)
 d0377f8:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 d0377fc:	e0bffd17 	ldw	r2,-12(fp)
 d037800:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 d037804:	e0bffe17 	ldw	r2,-8(fp)
 d037808:	e0bff515 	stw	r2,-44(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 d03780c:	e0800517 	ldw	r2,20(fp)
 d037810:	e0bff415 	stw	r2,-48(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 d037814:	e0bff817 	ldw	r2,-32(fp)
 d037818:	10800303 	ldbu	r2,12(r2)
 d03781c:	10803fcc 	andi	r2,r2,255
 d037820:	1004c03a 	cmpne	r2,r2,zero
 d037824:	1000031e 	bne	r2,zero,d037834 <alt_tse_system_add_sys+0x74>
		loop_end = 1;
 d037828:	00800044 	movi	r2,1
 d03782c:	e0bff915 	stw	r2,-28(fp)
 d037830:	00001006 	br	d037874 <alt_tse_system_add_sys+0xb4>
	}
	else if(pmac->tse_num_of_channel > 0) {
 d037834:	e0bff817 	ldw	r2,-32(fp)
 d037838:	10800303 	ldbu	r2,12(r2)
 d03783c:	10803fcc 	andi	r2,r2,255
 d037840:	1005003a 	cmpeq	r2,r2,zero
 d037844:	1000051e 	bne	r2,zero,d03785c <alt_tse_system_add_sys+0x9c>
		loop_end = pmac->tse_num_of_channel; 
 d037848:	e0bff817 	ldw	r2,-32(fp)
 d03784c:	10800303 	ldbu	r2,12(r2)
 d037850:	10803fcc 	andi	r2,r2,255
 d037854:	e0bff915 	stw	r2,-28(fp)
 d037858:	00000606 	br	d037874 <alt_tse_system_add_sys+0xb4>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 d03785c:	01034174 	movhi	r4,3333
 d037860:	213f1f04 	addi	r4,r4,-900
 d037864:	d002bc80 	call	d002bc8 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d037868:	00bfffc4 	movi	r2,-1
 d03786c:	e0bfff15 	stw	r2,-4(fp)
 d037870:	00027e06 	br	d03826c <alt_tse_system_add_sys+0xaac>
	}

	for(i = 0; i < loop_end; i++) {
 d037874:	e03ffa15 	stw	zero,-24(fp)
 d037878:	00027806 	br	d03825c <alt_tse_system_add_sys+0xa9c>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 d03787c:	d0a93883 	ldbu	r2,-23326(gp)
 d037880:	10803fcc 	andi	r2,r2,255
 d037884:	1080201c 	xori	r2,r2,128
 d037888:	10bfe004 	addi	r2,r2,-128
 d03788c:	10800110 	cmplti	r2,r2,4
 d037890:	10000b1e 	bne	r2,zero,d0378c0 <alt_tse_system_add_sys+0x100>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 d037894:	01034174 	movhi	r4,3333
 d037898:	213f2b04 	addi	r4,r4,-852
 d03789c:	d002bc80 	call	d002bc8 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 d0378a0:	d0a93883 	ldbu	r2,-23326(gp)
 d0378a4:	11803fcc 	andi	r6,r2,255
 d0378a8:	3180201c 	xori	r6,r6,128
 d0378ac:	31bfe004 	addi	r6,r6,-128
 d0378b0:	01034174 	movhi	r4,3333
 d0378b4:	213f3b04 	addi	r4,r4,-788
 d0378b8:	01400104 	movi	r5,4
 d0378bc:	d0028a00 	call	d0028a0 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 d0378c0:	e0bff817 	ldw	r2,-32(fp)
 d0378c4:	1004c03a 	cmpne	r2,r2,zero
 d0378c8:	1000091e 	bne	r2,zero,d0378f0 <alt_tse_system_add_sys+0x130>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 d0378cc:	01034174 	movhi	r4,3333
 d0378d0:	213f4a04 	addi	r4,r4,-728
 d0378d4:	d002bc80 	call	d002bc8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 d0378d8:	01034174 	movhi	r4,3333
 d0378dc:	213f5404 	addi	r4,r4,-688
 d0378e0:	d002bc80 	call	d002bc8 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d0378e4:	00bfffc4 	movi	r2,-1
 d0378e8:	e0bfff15 	stw	r2,-4(fp)
 d0378ec:	00025f06 	br	d03826c <alt_tse_system_add_sys+0xaac>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 d0378f0:	d0a93883 	ldbu	r2,-23326(gp)
 d0378f4:	11003fcc 	andi	r4,r2,255
 d0378f8:	2100201c 	xori	r4,r4,128
 d0378fc:	213fe004 	addi	r4,r4,-128
 d037900:	e0bff817 	ldw	r2,-32(fp)
 d037904:	10c00017 	ldw	r3,0(r2)
 d037908:	e0bffa17 	ldw	r2,-24(fp)
 d03790c:	100492ba 	slli	r2,r2,10
 d037910:	18a3883a 	add	r17,r3,r2
 d037914:	04034174 	movhi	r16,3333
 d037918:	8409fc04 	addi	r16,r16,10224
 d03791c:	01401204 	movi	r5,72
 d037920:	d00235c0 	call	d00235c <__mulsi3>
 d037924:	1405883a 	add	r2,r2,r16
 d037928:	14400015 	stw	r17,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 d03792c:	d0a93883 	ldbu	r2,-23326(gp)
 d037930:	11003fcc 	andi	r4,r2,255
 d037934:	2100201c 	xori	r4,r4,128
 d037938:	213fe004 	addi	r4,r4,-128
 d03793c:	e0bff817 	ldw	r2,-32(fp)
 d037940:	1440010b 	ldhu	r17,4(r2)
 d037944:	04034174 	movhi	r16,3333
 d037948:	8409fc04 	addi	r16,r16,10224
 d03794c:	01401204 	movi	r5,72
 d037950:	d00235c0 	call	d00235c <__mulsi3>
 d037954:	1405883a 	add	r2,r2,r16
 d037958:	10800104 	addi	r2,r2,4
 d03795c:	1440000d 	sth	r17,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 d037960:	d0a93883 	ldbu	r2,-23326(gp)
 d037964:	11003fcc 	andi	r4,r2,255
 d037968:	2100201c 	xori	r4,r4,128
 d03796c:	213fe004 	addi	r4,r4,-128
 d037970:	e0bff817 	ldw	r2,-32(fp)
 d037974:	1440018b 	ldhu	r17,6(r2)
 d037978:	04034174 	movhi	r16,3333
 d03797c:	8409fc04 	addi	r16,r16,10224
 d037980:	01401204 	movi	r5,72
 d037984:	d00235c0 	call	d00235c <__mulsi3>
 d037988:	1405883a 	add	r2,r2,r16
 d03798c:	10800104 	addi	r2,r2,4
 d037990:	1440008d 	sth	r17,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 d037994:	d0a93883 	ldbu	r2,-23326(gp)
 d037998:	11003fcc 	andi	r4,r2,255
 d03799c:	2100201c 	xori	r4,r4,128
 d0379a0:	213fe004 	addi	r4,r4,-128
 d0379a4:	e0bff817 	ldw	r2,-32(fp)
 d0379a8:	14400203 	ldbu	r17,8(r2)
 d0379ac:	04034174 	movhi	r16,3333
 d0379b0:	8409fc04 	addi	r16,r16,10224
 d0379b4:	01401204 	movi	r5,72
 d0379b8:	d00235c0 	call	d00235c <__mulsi3>
 d0379bc:	1405883a 	add	r2,r2,r16
 d0379c0:	10800204 	addi	r2,r2,8
 d0379c4:	14400005 	stb	r17,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 d0379c8:	d0a93883 	ldbu	r2,-23326(gp)
 d0379cc:	11003fcc 	andi	r4,r2,255
 d0379d0:	2100201c 	xori	r4,r4,128
 d0379d4:	213fe004 	addi	r4,r4,-128
 d0379d8:	e0bff817 	ldw	r2,-32(fp)
 d0379dc:	14400243 	ldbu	r17,9(r2)
 d0379e0:	04034174 	movhi	r16,3333
 d0379e4:	8409fc04 	addi	r16,r16,10224
 d0379e8:	01401204 	movi	r5,72
 d0379ec:	d00235c0 	call	d00235c <__mulsi3>
 d0379f0:	1405883a 	add	r2,r2,r16
 d0379f4:	10800204 	addi	r2,r2,8
 d0379f8:	14400045 	stb	r17,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 d0379fc:	d0a93883 	ldbu	r2,-23326(gp)
 d037a00:	11003fcc 	andi	r4,r2,255
 d037a04:	2100201c 	xori	r4,r4,128
 d037a08:	213fe004 	addi	r4,r4,-128
 d037a0c:	e0bff817 	ldw	r2,-32(fp)
 d037a10:	14400283 	ldbu	r17,10(r2)
 d037a14:	04034174 	movhi	r16,3333
 d037a18:	8409fc04 	addi	r16,r16,10224
 d037a1c:	01401204 	movi	r5,72
 d037a20:	d00235c0 	call	d00235c <__mulsi3>
 d037a24:	1405883a 	add	r2,r2,r16
 d037a28:	10800204 	addi	r2,r2,8
 d037a2c:	14400085 	stb	r17,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 d037a30:	d0a93883 	ldbu	r2,-23326(gp)
 d037a34:	11003fcc 	andi	r4,r2,255
 d037a38:	2100201c 	xori	r4,r4,128
 d037a3c:	213fe004 	addi	r4,r4,-128
 d037a40:	e0bff817 	ldw	r2,-32(fp)
 d037a44:	144002c3 	ldbu	r17,11(r2)
 d037a48:	04034174 	movhi	r16,3333
 d037a4c:	8409fc04 	addi	r16,r16,10224
 d037a50:	01401204 	movi	r5,72
 d037a54:	d00235c0 	call	d00235c <__mulsi3>
 d037a58:	1405883a 	add	r2,r2,r16
 d037a5c:	10800204 	addi	r2,r2,8
 d037a60:	144000c5 	stb	r17,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 d037a64:	d0a93883 	ldbu	r2,-23326(gp)
 d037a68:	11003fcc 	andi	r4,r2,255
 d037a6c:	2100201c 	xori	r4,r4,128
 d037a70:	213fe004 	addi	r4,r4,-128
 d037a74:	e0bff817 	ldw	r2,-32(fp)
 d037a78:	14400303 	ldbu	r17,12(r2)
 d037a7c:	04034174 	movhi	r16,3333
 d037a80:	8409fc04 	addi	r16,r16,10224
 d037a84:	01401204 	movi	r5,72
 d037a88:	d00235c0 	call	d00235c <__mulsi3>
 d037a8c:	1405883a 	add	r2,r2,r16
 d037a90:	10800304 	addi	r2,r2,12
 d037a94:	14400005 	stb	r17,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 d037a98:	d0a93883 	ldbu	r2,-23326(gp)
 d037a9c:	11003fcc 	andi	r4,r2,255
 d037aa0:	2100201c 	xori	r4,r4,128
 d037aa4:	213fe004 	addi	r4,r4,-128
 d037aa8:	e0bff817 	ldw	r2,-32(fp)
 d037aac:	14400343 	ldbu	r17,13(r2)
 d037ab0:	04034174 	movhi	r16,3333
 d037ab4:	8409fc04 	addi	r16,r16,10224
 d037ab8:	01401204 	movi	r5,72
 d037abc:	d00235c0 	call	d00235c <__mulsi3>
 d037ac0:	1405883a 	add	r2,r2,r16
 d037ac4:	10800304 	addi	r2,r2,12
 d037ac8:	14400045 	stb	r17,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 d037acc:	d0a93883 	ldbu	r2,-23326(gp)
 d037ad0:	11003fcc 	andi	r4,r2,255
 d037ad4:	2100201c 	xori	r4,r4,128
 d037ad8:	213fe004 	addi	r4,r4,-128
 d037adc:	e0bff817 	ldw	r2,-32(fp)
 d037ae0:	14400383 	ldbu	r17,14(r2)
 d037ae4:	04034174 	movhi	r16,3333
 d037ae8:	8409fc04 	addi	r16,r16,10224
 d037aec:	01401204 	movi	r5,72
 d037af0:	d00235c0 	call	d00235c <__mulsi3>
 d037af4:	1405883a 	add	r2,r2,r16
 d037af8:	10800304 	addi	r2,r2,12
 d037afc:	14400085 	stb	r17,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 d037b00:	d0a93883 	ldbu	r2,-23326(gp)
 d037b04:	11003fcc 	andi	r4,r2,255
 d037b08:	2100201c 	xori	r4,r4,128
 d037b0c:	213fe004 	addi	r4,r4,-128
 d037b10:	e0bff817 	ldw	r2,-32(fp)
 d037b14:	144003c3 	ldbu	r17,15(r2)
 d037b18:	04034174 	movhi	r16,3333
 d037b1c:	8409fc04 	addi	r16,r16,10224
 d037b20:	01401204 	movi	r5,72
 d037b24:	d00235c0 	call	d00235c <__mulsi3>
 d037b28:	1405883a 	add	r2,r2,r16
 d037b2c:	10800304 	addi	r2,r2,12
 d037b30:	144000c5 	stb	r17,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 d037b34:	d0a93883 	ldbu	r2,-23326(gp)
 d037b38:	11003fcc 	andi	r4,r2,255
 d037b3c:	2100201c 	xori	r4,r4,128
 d037b40:	213fe004 	addi	r4,r4,-128
 d037b44:	e0bff817 	ldw	r2,-32(fp)
 d037b48:	14400403 	ldbu	r17,16(r2)
 d037b4c:	04034174 	movhi	r16,3333
 d037b50:	8409fc04 	addi	r16,r16,10224
 d037b54:	01401204 	movi	r5,72
 d037b58:	d00235c0 	call	d00235c <__mulsi3>
 d037b5c:	1405883a 	add	r2,r2,r16
 d037b60:	10800404 	addi	r2,r2,16
 d037b64:	14400005 	stb	r17,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 d037b68:	e0bff717 	ldw	r2,-36(fp)
 d037b6c:	1004c03a 	cmpne	r2,r2,zero
 d037b70:	10000d1e 	bne	r2,zero,d037ba8 <alt_tse_system_add_sys+0x3e8>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 d037b74:	01034174 	movhi	r4,3333
 d037b78:	213f6604 	addi	r4,r4,-616
 d037b7c:	d002bc80 	call	d002bc8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 d037b80:	d0a93883 	ldbu	r2,-23326(gp)
 d037b84:	11403fcc 	andi	r5,r2,255
 d037b88:	2940201c 	xori	r5,r5,128
 d037b8c:	297fe004 	addi	r5,r5,-128
 d037b90:	01034174 	movhi	r4,3333
 d037b94:	213f7104 	addi	r4,r4,-572
 d037b98:	d0028a00 	call	d0028a0 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d037b9c:	00bfffc4 	movi	r2,-1
 d037ba0:	e0bfff15 	stw	r2,-4(fp)
 d037ba4:	0001b106 	br	d03826c <alt_tse_system_add_sys+0xaac>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 d037ba8:	d0a93883 	ldbu	r2,-23326(gp)
 d037bac:	14803fcc 	andi	r18,r2,255
 d037bb0:	9480201c 	xori	r18,r18,128
 d037bb4:	94bfe004 	addi	r18,r18,-128
 d037bb8:	e0bff717 	ldw	r2,-36(fp)
 d037bbc:	11000017 	ldw	r4,0(r2)
 d037bc0:	d0034640 	call	d003464 <strlen>
 d037bc4:	11000044 	addi	r4,r2,1
 d037bc8:	d04be300 	call	d04be30 <malloc>
 d037bcc:	1023883a 	mov	r17,r2
 d037bd0:	04034174 	movhi	r16,3333
 d037bd4:	8409fc04 	addi	r16,r16,10224
 d037bd8:	9009883a 	mov	r4,r18
 d037bdc:	01401204 	movi	r5,72
 d037be0:	d00235c0 	call	d00235c <__mulsi3>
 d037be4:	1405883a 	add	r2,r2,r16
 d037be8:	10800504 	addi	r2,r2,20
 d037bec:	14400015 	stw	r17,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 d037bf0:	d0a93883 	ldbu	r2,-23326(gp)
 d037bf4:	11003fcc 	andi	r4,r2,255
 d037bf8:	2100201c 	xori	r4,r4,128
 d037bfc:	213fe004 	addi	r4,r4,-128
 d037c00:	04034174 	movhi	r16,3333
 d037c04:	8409fc04 	addi	r16,r16,10224
 d037c08:	01401204 	movi	r5,72
 d037c0c:	d00235c0 	call	d00235c <__mulsi3>
 d037c10:	1405883a 	add	r2,r2,r16
 d037c14:	10800504 	addi	r2,r2,20
 d037c18:	10800017 	ldw	r2,0(r2)
 d037c1c:	1004c03a 	cmpne	r2,r2,zero
 d037c20:	10000a1e 	bne	r2,zero,d037c4c <alt_tse_system_add_sys+0x48c>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 d037c24:	d0a93883 	ldbu	r2,-23326(gp)
 d037c28:	11403fcc 	andi	r5,r2,255
 d037c2c:	2940201c 	xori	r5,r5,128
 d037c30:	297fe004 	addi	r5,r5,-128
 d037c34:	01034174 	movhi	r4,3333
 d037c38:	213f8904 	addi	r4,r4,-476
 d037c3c:	d0028a00 	call	d0028a0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 d037c40:	00bfffc4 	movi	r2,-1
 d037c44:	e0bfff15 	stw	r2,-4(fp)
 d037c48:	00018806 	br	d03826c <alt_tse_system_add_sys+0xaac>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 d037c4c:	d0a93883 	ldbu	r2,-23326(gp)
 d037c50:	11003fcc 	andi	r4,r2,255
 d037c54:	2100201c 	xori	r4,r4,128
 d037c58:	213fe004 	addi	r4,r4,-128
 d037c5c:	04034174 	movhi	r16,3333
 d037c60:	8409fc04 	addi	r16,r16,10224
 d037c64:	01401204 	movi	r5,72
 d037c68:	d00235c0 	call	d00235c <__mulsi3>
 d037c6c:	1405883a 	add	r2,r2,r16
 d037c70:	10800504 	addi	r2,r2,20
 d037c74:	11000017 	ldw	r4,0(r2)
 d037c78:	e0bff717 	ldw	r2,-36(fp)
 d037c7c:	11400017 	ldw	r5,0(r2)
 d037c80:	d04beb80 	call	d04beb8 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 d037c84:	d0a93883 	ldbu	r2,-23326(gp)
 d037c88:	14803fcc 	andi	r18,r2,255
 d037c8c:	9480201c 	xori	r18,r18,128
 d037c90:	94bfe004 	addi	r18,r18,-128
 d037c94:	e0bff717 	ldw	r2,-36(fp)
 d037c98:	11000117 	ldw	r4,4(r2)
 d037c9c:	d0034640 	call	d003464 <strlen>
 d037ca0:	11000044 	addi	r4,r2,1
 d037ca4:	d04be300 	call	d04be30 <malloc>
 d037ca8:	1023883a 	mov	r17,r2
 d037cac:	04034174 	movhi	r16,3333
 d037cb0:	8409fc04 	addi	r16,r16,10224
 d037cb4:	9009883a 	mov	r4,r18
 d037cb8:	01401204 	movi	r5,72
 d037cbc:	d00235c0 	call	d00235c <__mulsi3>
 d037cc0:	1405883a 	add	r2,r2,r16
 d037cc4:	10800604 	addi	r2,r2,24
 d037cc8:	14400015 	stw	r17,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 d037ccc:	d0a93883 	ldbu	r2,-23326(gp)
 d037cd0:	11003fcc 	andi	r4,r2,255
 d037cd4:	2100201c 	xori	r4,r4,128
 d037cd8:	213fe004 	addi	r4,r4,-128
 d037cdc:	04034174 	movhi	r16,3333
 d037ce0:	8409fc04 	addi	r16,r16,10224
 d037ce4:	01401204 	movi	r5,72
 d037ce8:	d00235c0 	call	d00235c <__mulsi3>
 d037cec:	1405883a 	add	r2,r2,r16
 d037cf0:	10800604 	addi	r2,r2,24
 d037cf4:	10800017 	ldw	r2,0(r2)
 d037cf8:	1004c03a 	cmpne	r2,r2,zero
 d037cfc:	10000a1e 	bne	r2,zero,d037d28 <alt_tse_system_add_sys+0x568>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 d037d00:	d0a93883 	ldbu	r2,-23326(gp)
 d037d04:	11403fcc 	andi	r5,r2,255
 d037d08:	2940201c 	xori	r5,r5,128
 d037d0c:	297fe004 	addi	r5,r5,-128
 d037d10:	01034174 	movhi	r4,3333
 d037d14:	213f9c04 	addi	r4,r4,-400
 d037d18:	d0028a00 	call	d0028a0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 d037d1c:	00bfffc4 	movi	r2,-1
 d037d20:	e0bfff15 	stw	r2,-4(fp)
 d037d24:	00015106 	br	d03826c <alt_tse_system_add_sys+0xaac>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 d037d28:	d0a93883 	ldbu	r2,-23326(gp)
 d037d2c:	11003fcc 	andi	r4,r2,255
 d037d30:	2100201c 	xori	r4,r4,128
 d037d34:	213fe004 	addi	r4,r4,-128
 d037d38:	04034174 	movhi	r16,3333
 d037d3c:	8409fc04 	addi	r16,r16,10224
 d037d40:	01401204 	movi	r5,72
 d037d44:	d00235c0 	call	d00235c <__mulsi3>
 d037d48:	1405883a 	add	r2,r2,r16
 d037d4c:	10800604 	addi	r2,r2,24
 d037d50:	11000017 	ldw	r4,0(r2)
 d037d54:	e0bff717 	ldw	r2,-36(fp)
 d037d58:	11400117 	ldw	r5,4(r2)
 d037d5c:	d04beb80 	call	d04beb8 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 d037d60:	d0a93883 	ldbu	r2,-23326(gp)
 d037d64:	11003fcc 	andi	r4,r2,255
 d037d68:	2100201c 	xori	r4,r4,128
 d037d6c:	213fe004 	addi	r4,r4,-128
 d037d70:	e0bff717 	ldw	r2,-36(fp)
 d037d74:	1440020b 	ldhu	r17,8(r2)
 d037d78:	04034174 	movhi	r16,3333
 d037d7c:	8409fc04 	addi	r16,r16,10224
 d037d80:	01401204 	movi	r5,72
 d037d84:	d00235c0 	call	d00235c <__mulsi3>
 d037d88:	1405883a 	add	r2,r2,r16
 d037d8c:	10800704 	addi	r2,r2,28
 d037d90:	1440000d 	sth	r17,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 d037d94:	e0bff617 	ldw	r2,-40(fp)
 d037d98:	1004c03a 	cmpne	r2,r2,zero
 d037d9c:	1000171e 	bne	r2,zero,d037dfc <alt_tse_system_add_sys+0x63c>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 d037da0:	d0a93883 	ldbu	r2,-23326(gp)
 d037da4:	11003fcc 	andi	r4,r2,255
 d037da8:	2100201c 	xori	r4,r4,128
 d037dac:	213fe004 	addi	r4,r4,-128
 d037db0:	04034174 	movhi	r16,3333
 d037db4:	8409fc04 	addi	r16,r16,10224
 d037db8:	01401204 	movi	r5,72
 d037dbc:	d00235c0 	call	d00235c <__mulsi3>
 d037dc0:	1405883a 	add	r2,r2,r16
 d037dc4:	10800704 	addi	r2,r2,28
 d037dc8:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 d037dcc:	d0a93883 	ldbu	r2,-23326(gp)
 d037dd0:	11003fcc 	andi	r4,r2,255
 d037dd4:	2100201c 	xori	r4,r4,128
 d037dd8:	213fe004 	addi	r4,r4,-128
 d037ddc:	04034174 	movhi	r16,3333
 d037de0:	8409fc04 	addi	r16,r16,10224
 d037de4:	01401204 	movi	r5,72
 d037de8:	d00235c0 	call	d00235c <__mulsi3>
 d037dec:	1405883a 	add	r2,r2,r16
 d037df0:	10800804 	addi	r2,r2,32
 d037df4:	10000015 	stw	zero,0(r2)
 d037df8:	00001a06 	br	d037e64 <alt_tse_system_add_sys+0x6a4>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 d037dfc:	d0a93883 	ldbu	r2,-23326(gp)
 d037e00:	11003fcc 	andi	r4,r2,255
 d037e04:	2100201c 	xori	r4,r4,128
 d037e08:	213fe004 	addi	r4,r4,-128
 d037e0c:	e0bff617 	ldw	r2,-40(fp)
 d037e10:	14400003 	ldbu	r17,0(r2)
 d037e14:	04034174 	movhi	r16,3333
 d037e18:	8409fc04 	addi	r16,r16,10224
 d037e1c:	01401204 	movi	r5,72
 d037e20:	d00235c0 	call	d00235c <__mulsi3>
 d037e24:	1405883a 	add	r2,r2,r16
 d037e28:	10800704 	addi	r2,r2,28
 d037e2c:	14400085 	stb	r17,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 d037e30:	d0a93883 	ldbu	r2,-23326(gp)
 d037e34:	11003fcc 	andi	r4,r2,255
 d037e38:	2100201c 	xori	r4,r4,128
 d037e3c:	213fe004 	addi	r4,r4,-128
 d037e40:	e0bff617 	ldw	r2,-40(fp)
 d037e44:	14400117 	ldw	r17,4(r2)
 d037e48:	04034174 	movhi	r16,3333
 d037e4c:	8409fc04 	addi	r16,r16,10224
 d037e50:	01401204 	movi	r5,72
 d037e54:	d00235c0 	call	d00235c <__mulsi3>
 d037e58:	1405883a 	add	r2,r2,r16
 d037e5c:	10800804 	addi	r2,r2,32
 d037e60:	14400015 	stw	r17,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 d037e64:	e0bff517 	ldw	r2,-44(fp)
 d037e68:	1004c03a 	cmpne	r2,r2,zero
 d037e6c:	10004e1e 	bne	r2,zero,d037fa8 <alt_tse_system_add_sys+0x7e8>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 d037e70:	d0a93883 	ldbu	r2,-23326(gp)
 d037e74:	11003fcc 	andi	r4,r2,255
 d037e78:	2100201c 	xori	r4,r4,128
 d037e7c:	213fe004 	addi	r4,r4,-128
 d037e80:	04034174 	movhi	r16,3333
 d037e84:	8409fc04 	addi	r16,r16,10224
 d037e88:	01401204 	movi	r5,72
 d037e8c:	d00235c0 	call	d00235c <__mulsi3>
 d037e90:	1405883a 	add	r2,r2,r16
 d037e94:	10800904 	addi	r2,r2,36
 d037e98:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 d037e9c:	d0a93883 	ldbu	r2,-23326(gp)
 d037ea0:	11003fcc 	andi	r4,r2,255
 d037ea4:	2100201c 	xori	r4,r4,128
 d037ea8:	213fe004 	addi	r4,r4,-128
 d037eac:	04034174 	movhi	r16,3333
 d037eb0:	8409fc04 	addi	r16,r16,10224
 d037eb4:	01401204 	movi	r5,72
 d037eb8:	d00235c0 	call	d00235c <__mulsi3>
 d037ebc:	1405883a 	add	r2,r2,r16
 d037ec0:	10800a04 	addi	r2,r2,40
 d037ec4:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 d037ec8:	d0a93883 	ldbu	r2,-23326(gp)
 d037ecc:	11003fcc 	andi	r4,r2,255
 d037ed0:	2100201c 	xori	r4,r4,128
 d037ed4:	213fe004 	addi	r4,r4,-128
 d037ed8:	04034174 	movhi	r16,3333
 d037edc:	8409fc04 	addi	r16,r16,10224
 d037ee0:	01401204 	movi	r5,72
 d037ee4:	d00235c0 	call	d00235c <__mulsi3>
 d037ee8:	1405883a 	add	r2,r2,r16
 d037eec:	10800b04 	addi	r2,r2,44
 d037ef0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 d037ef4:	d0a93883 	ldbu	r2,-23326(gp)
 d037ef8:	11003fcc 	andi	r4,r2,255
 d037efc:	2100201c 	xori	r4,r4,128
 d037f00:	213fe004 	addi	r4,r4,-128
 d037f04:	04034174 	movhi	r16,3333
 d037f08:	8409fc04 	addi	r16,r16,10224
 d037f0c:	01401204 	movi	r5,72
 d037f10:	d00235c0 	call	d00235c <__mulsi3>
 d037f14:	1405883a 	add	r2,r2,r16
 d037f18:	10800c04 	addi	r2,r2,48
 d037f1c:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 d037f20:	d0a93883 	ldbu	r2,-23326(gp)
 d037f24:	11003fcc 	andi	r4,r2,255
 d037f28:	2100201c 	xori	r4,r4,128
 d037f2c:	213fe004 	addi	r4,r4,-128
 d037f30:	04034174 	movhi	r16,3333
 d037f34:	8409fc04 	addi	r16,r16,10224
 d037f38:	01401204 	movi	r5,72
 d037f3c:	d00235c0 	call	d00235c <__mulsi3>
 d037f40:	1405883a 	add	r2,r2,r16
 d037f44:	10800d04 	addi	r2,r2,52
 d037f48:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 d037f4c:	d0a93883 	ldbu	r2,-23326(gp)
 d037f50:	11003fcc 	andi	r4,r2,255
 d037f54:	2100201c 	xori	r4,r4,128
 d037f58:	213fe004 	addi	r4,r4,-128
 d037f5c:	04034174 	movhi	r16,3333
 d037f60:	8409fc04 	addi	r16,r16,10224
 d037f64:	01401204 	movi	r5,72
 d037f68:	d00235c0 	call	d00235c <__mulsi3>
 d037f6c:	1405883a 	add	r2,r2,r16
 d037f70:	10800e04 	addi	r2,r2,56
 d037f74:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 d037f78:	d0a93883 	ldbu	r2,-23326(gp)
 d037f7c:	11003fcc 	andi	r4,r2,255
 d037f80:	2100201c 	xori	r4,r4,128
 d037f84:	213fe004 	addi	r4,r4,-128
 d037f88:	04034174 	movhi	r16,3333
 d037f8c:	8409fc04 	addi	r16,r16,10224
 d037f90:	01401204 	movi	r5,72
 d037f94:	d00235c0 	call	d00235c <__mulsi3>
 d037f98:	1405883a 	add	r2,r2,r16
 d037f9c:	10800f04 	addi	r2,r2,60
 d037fa0:	10000015 	stw	zero,0(r2)
 d037fa4:	00005b06 	br	d038114 <alt_tse_system_add_sys+0x954>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 d037fa8:	d0a93883 	ldbu	r2,-23326(gp)
 d037fac:	11003fcc 	andi	r4,r2,255
 d037fb0:	2100201c 	xori	r4,r4,128
 d037fb4:	213fe004 	addi	r4,r4,-128
 d037fb8:	e0bff517 	ldw	r2,-44(fp)
 d037fbc:	14400003 	ldbu	r17,0(r2)
 d037fc0:	04034174 	movhi	r16,3333
 d037fc4:	8409fc04 	addi	r16,r16,10224
 d037fc8:	01401204 	movi	r5,72
 d037fcc:	d00235c0 	call	d00235c <__mulsi3>
 d037fd0:	1405883a 	add	r2,r2,r16
 d037fd4:	10800904 	addi	r2,r2,36
 d037fd8:	14400005 	stb	r17,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 d037fdc:	d0a93883 	ldbu	r2,-23326(gp)
 d037fe0:	11003fcc 	andi	r4,r2,255
 d037fe4:	2100201c 	xori	r4,r4,128
 d037fe8:	213fe004 	addi	r4,r4,-128
 d037fec:	e0bff517 	ldw	r2,-44(fp)
 d037ff0:	14400117 	ldw	r17,4(r2)
 d037ff4:	04034174 	movhi	r16,3333
 d037ff8:	8409fc04 	addi	r16,r16,10224
 d037ffc:	01401204 	movi	r5,72
 d038000:	d00235c0 	call	d00235c <__mulsi3>
 d038004:	1405883a 	add	r2,r2,r16
 d038008:	10800a04 	addi	r2,r2,40
 d03800c:	14400015 	stw	r17,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 d038010:	d0a93883 	ldbu	r2,-23326(gp)
 d038014:	11003fcc 	andi	r4,r2,255
 d038018:	2100201c 	xori	r4,r4,128
 d03801c:	213fe004 	addi	r4,r4,-128
 d038020:	e0bff517 	ldw	r2,-44(fp)
 d038024:	14400217 	ldw	r17,8(r2)
 d038028:	04034174 	movhi	r16,3333
 d03802c:	8409fc04 	addi	r16,r16,10224
 d038030:	01401204 	movi	r5,72
 d038034:	d00235c0 	call	d00235c <__mulsi3>
 d038038:	1405883a 	add	r2,r2,r16
 d03803c:	10800b04 	addi	r2,r2,44
 d038040:	14400015 	stw	r17,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 d038044:	d0a93883 	ldbu	r2,-23326(gp)
 d038048:	11003fcc 	andi	r4,r2,255
 d03804c:	2100201c 	xori	r4,r4,128
 d038050:	213fe004 	addi	r4,r4,-128
 d038054:	e0bff517 	ldw	r2,-44(fp)
 d038058:	14400317 	ldw	r17,12(r2)
 d03805c:	04034174 	movhi	r16,3333
 d038060:	8409fc04 	addi	r16,r16,10224
 d038064:	01401204 	movi	r5,72
 d038068:	d00235c0 	call	d00235c <__mulsi3>
 d03806c:	1405883a 	add	r2,r2,r16
 d038070:	10800c04 	addi	r2,r2,48
 d038074:	14400015 	stw	r17,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 d038078:	d0a93883 	ldbu	r2,-23326(gp)
 d03807c:	11003fcc 	andi	r4,r2,255
 d038080:	2100201c 	xori	r4,r4,128
 d038084:	213fe004 	addi	r4,r4,-128
 d038088:	e0bff517 	ldw	r2,-44(fp)
 d03808c:	14400417 	ldw	r17,16(r2)
 d038090:	04034174 	movhi	r16,3333
 d038094:	8409fc04 	addi	r16,r16,10224
 d038098:	01401204 	movi	r5,72
 d03809c:	d00235c0 	call	d00235c <__mulsi3>
 d0380a0:	1405883a 	add	r2,r2,r16
 d0380a4:	10800d04 	addi	r2,r2,52
 d0380a8:	14400015 	stw	r17,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 d0380ac:	d0a93883 	ldbu	r2,-23326(gp)
 d0380b0:	11003fcc 	andi	r4,r2,255
 d0380b4:	2100201c 	xori	r4,r4,128
 d0380b8:	213fe004 	addi	r4,r4,-128
 d0380bc:	e0bff517 	ldw	r2,-44(fp)
 d0380c0:	14400517 	ldw	r17,20(r2)
 d0380c4:	04034174 	movhi	r16,3333
 d0380c8:	8409fc04 	addi	r16,r16,10224
 d0380cc:	01401204 	movi	r5,72
 d0380d0:	d00235c0 	call	d00235c <__mulsi3>
 d0380d4:	1405883a 	add	r2,r2,r16
 d0380d8:	10800e04 	addi	r2,r2,56
 d0380dc:	14400015 	stw	r17,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 d0380e0:	d0a93883 	ldbu	r2,-23326(gp)
 d0380e4:	11003fcc 	andi	r4,r2,255
 d0380e8:	2100201c 	xori	r4,r4,128
 d0380ec:	213fe004 	addi	r4,r4,-128
 d0380f0:	e0bff517 	ldw	r2,-44(fp)
 d0380f4:	14400617 	ldw	r17,24(r2)
 d0380f8:	04034174 	movhi	r16,3333
 d0380fc:	8409fc04 	addi	r16,r16,10224
 d038100:	01401204 	movi	r5,72
 d038104:	d00235c0 	call	d00235c <__mulsi3>
 d038108:	1405883a 	add	r2,r2,r16
 d03810c:	10800f04 	addi	r2,r2,60
 d038110:	14400015 	stw	r17,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 d038114:	e0bff417 	ldw	r2,-48(fp)
 d038118:	1004c03a 	cmpne	r2,r2,zero
 d03811c:	1000181e 	bne	r2,zero,d038180 <alt_tse_system_add_sys+0x9c0>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 d038120:	d0a93883 	ldbu	r2,-23326(gp)
 d038124:	11003fcc 	andi	r4,r2,255
 d038128:	2100201c 	xori	r4,r4,128
 d03812c:	213fe004 	addi	r4,r4,-128
 d038130:	04034174 	movhi	r16,3333
 d038134:	8409fc04 	addi	r16,r16,10224
 d038138:	01401204 	movi	r5,72
 d03813c:	d00235c0 	call	d00235c <__mulsi3>
 d038140:	1405883a 	add	r2,r2,r16
 d038144:	10c01004 	addi	r3,r2,64
 d038148:	00bfffc4 	movi	r2,-1
 d03814c:	18800015 	stw	r2,0(r3)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 d038150:	d0a93883 	ldbu	r2,-23326(gp)
 d038154:	11003fcc 	andi	r4,r2,255
 d038158:	2100201c 	xori	r4,r4,128
 d03815c:	213fe004 	addi	r4,r4,-128
 d038160:	04034174 	movhi	r16,3333
 d038164:	8409fc04 	addi	r16,r16,10224
 d038168:	01401204 	movi	r5,72
 d03816c:	d00235c0 	call	d00235c <__mulsi3>
 d038170:	1405883a 	add	r2,r2,r16
 d038174:	10801104 	addi	r2,r2,68
 d038178:	10000015 	stw	zero,0(r2)
 d03817c:	00001a06 	br	d0381e8 <alt_tse_system_add_sys+0xa28>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 d038180:	d0a93883 	ldbu	r2,-23326(gp)
 d038184:	11003fcc 	andi	r4,r2,255
 d038188:	2100201c 	xori	r4,r4,128
 d03818c:	213fe004 	addi	r4,r4,-128
 d038190:	e0bff417 	ldw	r2,-48(fp)
 d038194:	14400017 	ldw	r17,0(r2)
 d038198:	04034174 	movhi	r16,3333
 d03819c:	8409fc04 	addi	r16,r16,10224
 d0381a0:	01401204 	movi	r5,72
 d0381a4:	d00235c0 	call	d00235c <__mulsi3>
 d0381a8:	1405883a 	add	r2,r2,r16
 d0381ac:	10801004 	addi	r2,r2,64
 d0381b0:	14400015 	stw	r17,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 d0381b4:	d0a93883 	ldbu	r2,-23326(gp)
 d0381b8:	11003fcc 	andi	r4,r2,255
 d0381bc:	2100201c 	xori	r4,r4,128
 d0381c0:	213fe004 	addi	r4,r4,-128
 d0381c4:	e0bff417 	ldw	r2,-48(fp)
 d0381c8:	14400117 	ldw	r17,4(r2)
 d0381cc:	04034174 	movhi	r16,3333
 d0381d0:	8409fc04 	addi	r16,r16,10224
 d0381d4:	01401204 	movi	r5,72
 d0381d8:	d00235c0 	call	d00235c <__mulsi3>
 d0381dc:	1405883a 	add	r2,r2,r16
 d0381e0:	10801104 	addi	r2,r2,68
 d0381e4:	14400015 	stw	r17,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 d0381e8:	e0bff717 	ldw	r2,-36(fp)
 d0381ec:	10800304 	addi	r2,r2,12
 d0381f0:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
 d0381f4:	e0bff617 	ldw	r2,-40(fp)
 d0381f8:	1005003a 	cmpeq	r2,r2,zero
 d0381fc:	1000031e 	bne	r2,zero,d03820c <alt_tse_system_add_sys+0xa4c>
 d038200:	e0bff617 	ldw	r2,-40(fp)
 d038204:	10800204 	addi	r2,r2,8
 d038208:	e0bff615 	stw	r2,-40(fp)
		if(pfifo) pfifo++;
 d03820c:	e0bff517 	ldw	r2,-44(fp)
 d038210:	1005003a 	cmpeq	r2,r2,zero
 d038214:	1000031e 	bne	r2,zero,d038224 <alt_tse_system_add_sys+0xa64>
 d038218:	e0bff517 	ldw	r2,-44(fp)
 d03821c:	10800704 	addi	r2,r2,28
 d038220:	e0bff515 	stw	r2,-44(fp)
		if(pphy) pphy++;
 d038224:	e0bff417 	ldw	r2,-48(fp)
 d038228:	1005003a 	cmpeq	r2,r2,zero
 d03822c:	1000031e 	bne	r2,zero,d03823c <alt_tse_system_add_sys+0xa7c>
 d038230:	e0bff417 	ldw	r2,-48(fp)
 d038234:	10800204 	addi	r2,r2,8
 d038238:	e0bff415 	stw	r2,-48(fp)
		
		tse_system_count++;
 d03823c:	d0a93883 	ldbu	r2,-23326(gp)
 d038240:	10800044 	addi	r2,r2,1
 d038244:	d0a93885 	stb	r2,-23326(gp)
		max_mac_system = tse_system_count;
 d038248:	d0a93883 	ldbu	r2,-23326(gp)
 d03824c:	d0a04a05 	stb	r2,-32472(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 d038250:	e0bffa17 	ldw	r2,-24(fp)
 d038254:	10800044 	addi	r2,r2,1
 d038258:	e0bffa15 	stw	r2,-24(fp)
 d03825c:	e0fffa17 	ldw	r3,-24(fp)
 d038260:	e0bff917 	ldw	r2,-28(fp)
 d038264:	18bd8516 	blt	r3,r2,d03787c <alt_tse_system_add_sys+0xbc>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 d038268:	e03fff15 	stw	zero,-4(fp)
 d03826c:	e0bfff17 	ldw	r2,-4(fp)
	
}
 d038270:	e037883a 	mov	sp,fp
 d038274:	dfc00417 	ldw	ra,16(sp)
 d038278:	df000317 	ldw	fp,12(sp)
 d03827c:	dc800217 	ldw	r18,8(sp)
 d038280:	dc400117 	ldw	r17,4(sp)
 d038284:	dc000017 	ldw	r16,0(sp)
 d038288:	dec00504 	addi	sp,sp,20
 d03828c:	f800283a 	ret

0d038290 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 d038290:	defff604 	addi	sp,sp,-40
 d038294:	dfc00915 	stw	ra,36(sp)
 d038298:	df000815 	stw	fp,32(sp)
 d03829c:	dc400715 	stw	r17,28(sp)
 d0382a0:	dc000615 	stw	r16,24(sp)
 d0382a4:	df000604 	addi	fp,sp,24
 d0382a8:	e13ffd15 	stw	r4,-12(fp)
 d0382ac:	e17ffe05 	stb	r5,-8(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 d0382b0:	e03ffc15 	stw	zero,-16(fp)
 d0382b4:	00005006 	br	d0383f8 <alt_tse_sys_enable_mdio_sharing+0x168>
		psys_mac = psys_mac_list[i];
 d0382b8:	e0bffc17 	ldw	r2,-16(fp)
 d0382bc:	1085883a 	add	r2,r2,r2
 d0382c0:	1085883a 	add	r2,r2,r2
 d0382c4:	1007883a 	mov	r3,r2
 d0382c8:	e0bffd17 	ldw	r2,-12(fp)
 d0382cc:	1885883a 	add	r2,r3,r2
 d0382d0:	10800017 	ldw	r2,0(r2)
 d0382d4:	e0bffa15 	stw	r2,-24(fp)
		
		if(psys_mac == 0) {
 d0382d8:	e0bffa17 	ldw	r2,-24(fp)
 d0382dc:	1004c03a 	cmpne	r2,r2,zero
 d0382e0:	1000091e 	bne	r2,zero,d038308 <alt_tse_sys_enable_mdio_sharing+0x78>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 d0382e4:	01034174 	movhi	r4,3333
 d0382e8:	213f4a04 	addi	r4,r4,-728
 d0382ec:	d002bc80 	call	d002bc8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 d0382f0:	01034174 	movhi	r4,3333
 d0382f4:	213faf04 	addi	r4,r4,-324
 d0382f8:	d002bc80 	call	d002bc8 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d0382fc:	00bfffc4 	movi	r2,-1
 d038300:	e0bfff15 	stw	r2,-4(fp)
 d038304:	00004006 	br	d038408 <alt_tse_sys_enable_mdio_sharing+0x178>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 d038308:	e03ffb15 	stw	zero,-20(fp)
 d03830c:	00003306 	br	d0383dc <alt_tse_sys_enable_mdio_sharing+0x14c>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 d038310:	e0bffa17 	ldw	r2,-24(fp)
 d038314:	14400017 	ldw	r17,0(r2)
 d038318:	e13ffb17 	ldw	r4,-20(fp)
 d03831c:	04034174 	movhi	r16,3333
 d038320:	8409fc04 	addi	r16,r16,10224
 d038324:	01401204 	movi	r5,72
 d038328:	d00235c0 	call	d00235c <__mulsi3>
 d03832c:	1405883a 	add	r2,r2,r16
 d038330:	10800017 	ldw	r2,0(r2)
 d038334:	8880261e 	bne	r17,r2,d0383d0 <alt_tse_sys_enable_mdio_sharing+0x140>
				if(tse_mac_device[j].tse_multichannel_mac) {
 d038338:	e13ffb17 	ldw	r4,-20(fp)
 d03833c:	04034174 	movhi	r16,3333
 d038340:	8409fc04 	addi	r16,r16,10224
 d038344:	01401204 	movi	r5,72
 d038348:	d00235c0 	call	d00235c <__mulsi3>
 d03834c:	1405883a 	add	r2,r2,r16
 d038350:	10800204 	addi	r2,r2,8
 d038354:	108000c3 	ldbu	r2,3(r2)
 d038358:	10803fcc 	andi	r2,r2,255
 d03835c:	1005003a 	cmpeq	r2,r2,zero
 d038360:	1000091e 	bne	r2,zero,d038388 <alt_tse_sys_enable_mdio_sharing+0xf8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 d038364:	01034174 	movhi	r4,3333
 d038368:	213fc304 	addi	r4,r4,-244
 d03836c:	d002bc80 	call	d002bc8 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 d038370:	01034174 	movhi	r4,3333
 d038374:	213fd404 	addi	r4,r4,-176
 d038378:	d002bc80 	call	d002bc8 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d03837c:	00bfffc4 	movi	r2,-1
 d038380:	e0bfff15 	stw	r2,-4(fp)
 d038384:	00002006 	br	d038408 <alt_tse_sys_enable_mdio_sharing+0x178>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 d038388:	e13ffb17 	ldw	r4,-20(fp)
 d03838c:	04034174 	movhi	r16,3333
 d038390:	8409fc04 	addi	r16,r16,10224
 d038394:	01401204 	movi	r5,72
 d038398:	d00235c0 	call	d00235c <__mulsi3>
 d03839c:	1405883a 	add	r2,r2,r16
 d0383a0:	10c00304 	addi	r3,r2,12
 d0383a4:	00800044 	movi	r2,1
 d0383a8:	18800045 	stb	r2,1(r3)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 d0383ac:	e13ffb17 	ldw	r4,-20(fp)
 d0383b0:	04034174 	movhi	r16,3333
 d0383b4:	8409fc04 	addi	r16,r16,10224
 d0383b8:	01401204 	movi	r5,72
 d0383bc:	d00235c0 	call	d00235c <__mulsi3>
 d0383c0:	1405883a 	add	r2,r2,r16
 d0383c4:	10c00304 	addi	r3,r2,12
 d0383c8:	e0bffe03 	ldbu	r2,-8(fp)
 d0383cc:	18800085 	stb	r2,2(r3)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 d0383d0:	e0bffb17 	ldw	r2,-20(fp)
 d0383d4:	10800044 	addi	r2,r2,1
 d0383d8:	e0bffb15 	stw	r2,-20(fp)
 d0383dc:	d0a04a03 	ldbu	r2,-32472(gp)
 d0383e0:	10c03fcc 	andi	r3,r2,255
 d0383e4:	e0bffb17 	ldw	r2,-20(fp)
 d0383e8:	10ffc916 	blt	r2,r3,d038310 <alt_tse_sys_enable_mdio_sharing+0x80>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 d0383ec:	e0bffc17 	ldw	r2,-16(fp)
 d0383f0:	10800044 	addi	r2,r2,1
 d0383f4:	e0bffc15 	stw	r2,-16(fp)
 d0383f8:	e0fffe03 	ldbu	r3,-8(fp)
 d0383fc:	e0bffc17 	ldw	r2,-16(fp)
 d038400:	10ffad16 	blt	r2,r3,d0382b8 <alt_tse_sys_enable_mdio_sharing+0x28>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 d038404:	e03fff15 	stw	zero,-4(fp)
 d038408:	e0bfff17 	ldw	r2,-4(fp)
}
 d03840c:	e037883a 	mov	sp,fp
 d038410:	dfc00317 	ldw	ra,12(sp)
 d038414:	df000217 	ldw	fp,8(sp)
 d038418:	dc400117 	ldw	r17,4(sp)
 d03841c:	dc000017 	ldw	r16,0(sp)
 d038420:	dec00404 	addi	sp,sp,16
 d038424:	f800283a 	ret

0d038428 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 d038428:	defffc04 	addi	sp,sp,-16
 d03842c:	dfc00315 	stw	ra,12(sp)
 d038430:	df000215 	stw	fp,8(sp)
 d038434:	df000204 	addi	fp,sp,8
 d038438:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 d03843c:	e13fff17 	ldw	r4,-4(fp)
 d038440:	d0386440 	call	d038644 <alt_tse_get_mac_info>
 d038444:	10800317 	ldw	r2,12(r2)
 d038448:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 d03844c:	e13ffe17 	ldw	r4,-8(fp)
 d038450:	d03baac0 	call	d03baac <alt_tse_phy_get_common_speed>
}
 d038454:	e037883a 	mov	sp,fp
 d038458:	dfc00117 	ldw	ra,4(sp)
 d03845c:	df000017 	ldw	fp,0(sp)
 d038460:	dec00204 	addi	sp,sp,8
 d038464:	f800283a 	ret

0d038468 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 d038468:	defffb04 	addi	sp,sp,-20
 d03846c:	dfc00415 	stw	ra,16(sp)
 d038470:	df000315 	stw	fp,12(sp)
 d038474:	df000304 	addi	fp,sp,12
 d038478:	e13ffe15 	stw	r4,-8(fp)
 d03847c:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 d038480:	e13ffe17 	ldw	r4,-8(fp)
 d038484:	d0386440 	call	d038644 <alt_tse_get_mac_info>
 d038488:	10800317 	ldw	r2,12(r2)
 d03848c:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 d038490:	e13ffd17 	ldw	r4,-12(fp)
 d038494:	e17fff17 	ldw	r5,-4(fp)
 d038498:	d03bdc80 	call	d03bdc8 <alt_tse_phy_set_common_speed>
}
 d03849c:	e037883a 	mov	sp,fp
 d0384a0:	dfc00117 	ldw	ra,4(sp)
 d0384a4:	df000017 	ldw	fp,0(sp)
 d0384a8:	dec00204 	addi	sp,sp,8
 d0384ac:	f800283a 	ret

0d0384b0 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 d0384b0:	defffb04 	addi	sp,sp,-20
 d0384b4:	dfc00415 	stw	ra,16(sp)
 d0384b8:	df000315 	stw	fp,12(sp)
 d0384bc:	df000304 	addi	fp,sp,12
 d0384c0:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 d0384c4:	e03ffd15 	stw	zero,-12(fp)
 d0384c8:	00000f06 	br	d038508 <alt_tse_get_system_index+0x58>
        if(psys_info == &tse_mac_device[i]) {
 d0384cc:	e13ffd17 	ldw	r4,-12(fp)
 d0384d0:	01401204 	movi	r5,72
 d0384d4:	d00235c0 	call	d00235c <__mulsi3>
 d0384d8:	1007883a 	mov	r3,r2
 d0384dc:	00834174 	movhi	r2,3333
 d0384e0:	1089fc04 	addi	r2,r2,10224
 d0384e4:	1887883a 	add	r3,r3,r2
 d0384e8:	e0bffe17 	ldw	r2,-8(fp)
 d0384ec:	1880031e 	bne	r3,r2,d0384fc <alt_tse_get_system_index+0x4c>
            return i;
 d0384f0:	e0bffd17 	ldw	r2,-12(fp)
 d0384f4:	e0bfff15 	stw	r2,-4(fp)
 d0384f8:	00000906 	br	d038520 <alt_tse_get_system_index+0x70>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 d0384fc:	e0bffd17 	ldw	r2,-12(fp)
 d038500:	10800044 	addi	r2,r2,1
 d038504:	e0bffd15 	stw	r2,-12(fp)
 d038508:	d0a04a03 	ldbu	r2,-32472(gp)
 d03850c:	10c03fcc 	andi	r3,r2,255
 d038510:	e0bffd17 	ldw	r2,-12(fp)
 d038514:	10ffed16 	blt	r2,r3,d0384cc <alt_tse_get_system_index+0x1c>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 d038518:	00bfffc4 	movi	r2,-1
 d03851c:	e0bfff15 	stw	r2,-4(fp)
 d038520:	e0bfff17 	ldw	r2,-4(fp)
}
 d038524:	e037883a 	mov	sp,fp
 d038528:	dfc00117 	ldw	ra,4(sp)
 d03852c:	df000017 	ldw	fp,0(sp)
 d038530:	dec00204 	addi	sp,sp,8
 d038534:	f800283a 	ret

0d038538 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 d038538:	defffc04 	addi	sp,sp,-16
 d03853c:	df000315 	stw	fp,12(sp)
 d038540:	df000304 	addi	fp,sp,12
 d038544:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 d038548:	e03ffd15 	stw	zero,-12(fp)
 d03854c:	00000f06 	br	d03858c <alt_tse_get_mac_group_index+0x54>
        if(pmac_group == pmac_groups[i]) {
 d038550:	e0bffd17 	ldw	r2,-12(fp)
 d038554:	00c341b4 	movhi	r3,3334
 d038558:	18c50204 	addi	r3,r3,5128
 d03855c:	1085883a 	add	r2,r2,r2
 d038560:	1085883a 	add	r2,r2,r2
 d038564:	10c5883a 	add	r2,r2,r3
 d038568:	10c00017 	ldw	r3,0(r2)
 d03856c:	e0bffe17 	ldw	r2,-8(fp)
 d038570:	1880031e 	bne	r3,r2,d038580 <alt_tse_get_mac_group_index+0x48>
            return i;
 d038574:	e0bffd17 	ldw	r2,-12(fp)
 d038578:	e0bfff15 	stw	r2,-4(fp)
 d03857c:	00000906 	br	d0385a4 <alt_tse_get_mac_group_index+0x6c>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 d038580:	e0bffd17 	ldw	r2,-12(fp)
 d038584:	10800044 	addi	r2,r2,1
 d038588:	e0bffd15 	stw	r2,-12(fp)
 d03858c:	d0a93843 	ldbu	r2,-23327(gp)
 d038590:	10c03fcc 	andi	r3,r2,255
 d038594:	e0bffd17 	ldw	r2,-12(fp)
 d038598:	10ffed16 	blt	r2,r3,d038550 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 d03859c:	00bfffc4 	movi	r2,-1
 d0385a0:	e0bfff15 	stw	r2,-4(fp)
 d0385a4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0385a8:	e037883a 	mov	sp,fp
 d0385ac:	df000017 	ldw	fp,0(sp)
 d0385b0:	dec00104 	addi	sp,sp,4
 d0385b4:	f800283a 	ret

0d0385b8 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 d0385b8:	defffc04 	addi	sp,sp,-16
 d0385bc:	df000315 	stw	fp,12(sp)
 d0385c0:	df000304 	addi	fp,sp,12
 d0385c4:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 d0385c8:	e03ffd15 	stw	zero,-12(fp)
 d0385cc:	00001006 	br	d038610 <alt_tse_get_mac_info_index+0x58>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 d0385d0:	e0bffe17 	ldw	r2,-8(fp)
 d0385d4:	10c00317 	ldw	r3,12(r2)
 d0385d8:	e0bffd17 	ldw	r2,-12(fp)
 d0385dc:	1085883a 	add	r2,r2,r2
 d0385e0:	1085883a 	add	r2,r2,r2
 d0385e4:	10c5883a 	add	r2,r2,r3
 d0385e8:	10800104 	addi	r2,r2,4
 d0385ec:	10c00017 	ldw	r3,0(r2)
 d0385f0:	e0bffe17 	ldw	r2,-8(fp)
 d0385f4:	1880031e 	bne	r3,r2,d038604 <alt_tse_get_mac_info_index+0x4c>
            return i;
 d0385f8:	e0bffd17 	ldw	r2,-12(fp)
 d0385fc:	e0bfff15 	stw	r2,-4(fp)
 d038600:	00000b06 	br	d038630 <alt_tse_get_mac_info_index+0x78>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 d038604:	e0bffd17 	ldw	r2,-12(fp)
 d038608:	10800044 	addi	r2,r2,1
 d03860c:	e0bffd15 	stw	r2,-12(fp)
 d038610:	e0bffe17 	ldw	r2,-8(fp)
 d038614:	10800317 	ldw	r2,12(r2)
 d038618:	10800003 	ldbu	r2,0(r2)
 d03861c:	10c03fcc 	andi	r3,r2,255
 d038620:	e0bffd17 	ldw	r2,-12(fp)
 d038624:	10ffea16 	blt	r2,r3,d0385d0 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 d038628:	00bfffc4 	movi	r2,-1
 d03862c:	e0bfff15 	stw	r2,-4(fp)
 d038630:	e0bfff17 	ldw	r2,-4(fp)
}
 d038634:	e037883a 	mov	sp,fp
 d038638:	df000017 	ldw	fp,0(sp)
 d03863c:	dec00104 	addi	sp,sp,4
 d038640:	f800283a 	ret

0d038644 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 d038644:	defff904 	addi	sp,sp,-28
 d038648:	df000615 	stw	fp,24(sp)
 d03864c:	df000604 	addi	fp,sp,24
 d038650:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 d038654:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 d038658:	e03ffa15 	stw	zero,-24(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 d03865c:	e03ffd15 	stw	zero,-12(fp)
 d038660:	00002606 	br	d0386fc <alt_tse_get_mac_info+0xb8>
        pmac_group = pmac_groups[i];
 d038664:	e0bffd17 	ldw	r2,-12(fp)
 d038668:	00c341b4 	movhi	r3,3334
 d03866c:	18c50204 	addi	r3,r3,5128
 d038670:	1085883a 	add	r2,r2,r2
 d038674:	1085883a 	add	r2,r2,r2
 d038678:	10c5883a 	add	r2,r2,r3
 d03867c:	10800017 	ldw	r2,0(r2)
 d038680:	e0bffb15 	stw	r2,-20(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 d038684:	e03ffc15 	stw	zero,-16(fp)
 d038688:	00001406 	br	d0386dc <alt_tse_get_mac_info+0x98>
            pmac_info = pmac_group->pmac_info[j];
 d03868c:	e0bffc17 	ldw	r2,-16(fp)
 d038690:	e0fffb17 	ldw	r3,-20(fp)
 d038694:	1085883a 	add	r2,r2,r2
 d038698:	1085883a 	add	r2,r2,r2
 d03869c:	10c5883a 	add	r2,r2,r3
 d0386a0:	10800104 	addi	r2,r2,4
 d0386a4:	10800017 	ldw	r2,0(r2)
 d0386a8:	e0bffa15 	stw	r2,-24(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 d0386ac:	e0bffa17 	ldw	r2,-24(fp)
 d0386b0:	10800217 	ldw	r2,8(r2)
 d0386b4:	10800017 	ldw	r2,0(r2)
 d0386b8:	1007883a 	mov	r3,r2
 d0386bc:	e0bffe17 	ldw	r2,-8(fp)
 d0386c0:	1880031e 	bne	r3,r2,d0386d0 <alt_tse_get_mac_info+0x8c>
                return pmac_info;
 d0386c4:	e0bffa17 	ldw	r2,-24(fp)
 d0386c8:	e0bfff15 	stw	r2,-4(fp)
 d0386cc:	00001006 	br	d038710 <alt_tse_get_mac_info+0xcc>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 d0386d0:	e0bffc17 	ldw	r2,-16(fp)
 d0386d4:	10800044 	addi	r2,r2,1
 d0386d8:	e0bffc15 	stw	r2,-16(fp)
 d0386dc:	e0bffb17 	ldw	r2,-20(fp)
 d0386e0:	10800003 	ldbu	r2,0(r2)
 d0386e4:	10c03fcc 	andi	r3,r2,255
 d0386e8:	e0bffc17 	ldw	r2,-16(fp)
 d0386ec:	10ffe716 	blt	r2,r3,d03868c <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 d0386f0:	e0bffd17 	ldw	r2,-12(fp)
 d0386f4:	10800044 	addi	r2,r2,1
 d0386f8:	e0bffd15 	stw	r2,-12(fp)
 d0386fc:	d0a93843 	ldbu	r2,-23327(gp)
 d038700:	10c03fcc 	andi	r3,r2,255
 d038704:	e0bffd17 	ldw	r2,-12(fp)
 d038708:	10ffd616 	blt	r2,r3,d038664 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 d03870c:	e03fff15 	stw	zero,-4(fp)
 d038710:	e0bfff17 	ldw	r2,-4(fp)
}
 d038714:	e037883a 	mov	sp,fp
 d038718:	df000017 	ldw	fp,0(sp)
 d03871c:	dec00104 	addi	sp,sp,4
 d038720:	f800283a 	ret

0d038724 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 d038724:	defffb04 	addi	sp,sp,-20
 d038728:	df000415 	stw	fp,16(sp)
 d03872c:	df000404 	addi	fp,sp,16
 d038730:	e13ffd15 	stw	r4,-12(fp)
 d038734:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d038738:	e0bffd17 	ldw	r2,-12(fp)
 d03873c:	10800204 	addi	r2,r2,8
 d038740:	10800037 	ldwio	r2,0(r2)
 d038744:	e0bffc15 	stw	r2,-16(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 d038748:	e0bffe03 	ldbu	r2,-8(fp)
 d03874c:	10800098 	cmpnei	r2,r2,2
 d038750:	1000091e 	bne	r2,zero,d038778 <alt_tse_mac_set_speed+0x54>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d038754:	e0bffc17 	ldw	r2,-16(fp)
 d038758:	10800214 	ori	r2,r2,8
 d03875c:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d038760:	e0fffc17 	ldw	r3,-16(fp)
 d038764:	00bf8034 	movhi	r2,65024
 d038768:	10bfffc4 	addi	r2,r2,-1
 d03876c:	1884703a 	and	r2,r3,r2
 d038770:	e0bffc15 	stw	r2,-16(fp)
 d038774:	00001b06 	br	d0387e4 <alt_tse_mac_set_speed+0xc0>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 d038778:	e0bffe03 	ldbu	r2,-8(fp)
 d03877c:	10800058 	cmpnei	r2,r2,1
 d038780:	10000a1e 	bne	r2,zero,d0387ac <alt_tse_mac_set_speed+0x88>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d038784:	e0fffc17 	ldw	r3,-16(fp)
 d038788:	00bffdc4 	movi	r2,-9
 d03878c:	1884703a 	and	r2,r3,r2
 d038790:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d038794:	e0fffc17 	ldw	r3,-16(fp)
 d038798:	00bf8034 	movhi	r2,65024
 d03879c:	10bfffc4 	addi	r2,r2,-1
 d0387a0:	1884703a 	and	r2,r3,r2
 d0387a4:	e0bffc15 	stw	r2,-16(fp)
 d0387a8:	00000e06 	br	d0387e4 <alt_tse_mac_set_speed+0xc0>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 d0387ac:	e0bffe03 	ldbu	r2,-8(fp)
 d0387b0:	1004c03a 	cmpne	r2,r2,zero
 d0387b4:	1000081e 	bne	r2,zero,d0387d8 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d0387b8:	e0fffc17 	ldw	r3,-16(fp)
 d0387bc:	00bffdc4 	movi	r2,-9
 d0387c0:	1884703a 	and	r2,r3,r2
 d0387c4:	e0bffc15 	stw	r2,-16(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d0387c8:	e0bffc17 	ldw	r2,-16(fp)
 d0387cc:	10808034 	orhi	r2,r2,512
 d0387d0:	e0bffc15 	stw	r2,-16(fp)
 d0387d4:	00000306 	br	d0387e4 <alt_tse_mac_set_speed+0xc0>
  }  
  else {
    return ENP_PARAM;
 d0387d8:	00bffd84 	movi	r2,-10
 d0387dc:	e0bfff15 	stw	r2,-4(fp)
 d0387e0:	00000606 	br	d0387fc <alt_tse_mac_set_speed+0xd8>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 d0387e4:	e0bffd17 	ldw	r2,-12(fp)
 d0387e8:	10800204 	addi	r2,r2,8
 d0387ec:	1007883a 	mov	r3,r2
 d0387f0:	e0bffc17 	ldw	r2,-16(fp)
 d0387f4:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d0387f8:	e03fff15 	stw	zero,-4(fp)
 d0387fc:	e0bfff17 	ldw	r2,-4(fp)
}
 d038800:	e037883a 	mov	sp,fp
 d038804:	df000017 	ldw	fp,0(sp)
 d038808:	dec00104 	addi	sp,sp,4
 d03880c:	f800283a 	ret

0d038810 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 d038810:	defffb04 	addi	sp,sp,-20
 d038814:	df000415 	stw	fp,16(sp)
 d038818:	df000404 	addi	fp,sp,16
 d03881c:	e13ffd15 	stw	r4,-12(fp)
 d038820:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d038824:	e0bffd17 	ldw	r2,-12(fp)
 d038828:	10800204 	addi	r2,r2,8
 d03882c:	10800037 	ldwio	r2,0(r2)
 d038830:	e0bffc15 	stw	r2,-16(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 d038834:	e0bffe03 	ldbu	r2,-8(fp)
 d038838:	1004c03a 	cmpne	r2,r2,zero
 d03883c:	1000041e 	bne	r2,zero,d038850 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d038840:	e0bffc17 	ldw	r2,-16(fp)
 d038844:	10810014 	ori	r2,r2,1024
 d038848:	e0bffc15 	stw	r2,-16(fp)
 d03884c:	00000b06 	br	d03887c <alt_tse_mac_set_duplex+0x6c>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 d038850:	e0bffe03 	ldbu	r2,-8(fp)
 d038854:	10800058 	cmpnei	r2,r2,1
 d038858:	1000051e 	bne	r2,zero,d038870 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d03885c:	e0bffc17 	ldw	r2,-16(fp)
 d038860:	00feffc4 	movi	r3,-1025
 d038864:	10c4703a 	and	r2,r2,r3
 d038868:	e0bffc15 	stw	r2,-16(fp)
 d03886c:	00000306 	br	d03887c <alt_tse_mac_set_duplex+0x6c>
  }
  else {
    return ENP_PARAM;
 d038870:	00bffd84 	movi	r2,-10
 d038874:	e0bfff15 	stw	r2,-4(fp)
 d038878:	00000606 	br	d038894 <alt_tse_mac_set_duplex+0x84>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 d03887c:	e0bffd17 	ldw	r2,-12(fp)
 d038880:	10800204 	addi	r2,r2,8
 d038884:	1007883a 	mov	r3,r2
 d038888:	e0bffc17 	ldw	r2,-16(fp)
 d03888c:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d038890:	e03fff15 	stw	zero,-4(fp)
 d038894:	e0bfff17 	ldw	r2,-4(fp)

}
 d038898:	e037883a 	mov	sp,fp
 d03889c:	df000017 	ldw	fp,0(sp)
 d0388a0:	dec00104 	addi	sp,sp,4
 d0388a4:	f800283a 	ret

0d0388a8 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 d0388a8:	deff9704 	addi	sp,sp,-420
 d0388ac:	dfc06815 	stw	ra,416(sp)
 d0388b0:	df006715 	stw	fp,412(sp)
 d0388b4:	df006704 	addi	fp,sp,412
 d0388b8:	e13fa215 	stw	r4,-376(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d0388bc:	00800044 	movi	r2,1
 d0388c0:	e0bfa145 	stb	r2,-379(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 d0388c4:	00800044 	movi	r2,1
 d0388c8:	e0bfa105 	stb	r2,-380(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 d0388cc:	e0bfa103 	ldbu	r2,-380(fp)
 d0388d0:	1080004c 	andi	r2,r2,1
 d0388d4:	e0bfff15 	stw	r2,-4(fp)
 d0388d8:	e0bfa143 	ldbu	r2,-379(fp)
 d0388dc:	10800098 	cmpnei	r2,r2,2
 d0388e0:	1000031e 	bne	r2,zero,d0388f0 <getPHYSpeed+0x48>
 d0388e4:	00800084 	movi	r2,2
 d0388e8:	e0bffe15 	stw	r2,-8(fp)
 d0388ec:	00000106 	br	d0388f4 <getPHYSpeed+0x4c>
 d0388f0:	e03ffe15 	stw	zero,-8(fp)
 d0388f4:	e0ffff17 	ldw	r3,-4(fp)
 d0388f8:	e13ffe17 	ldw	r4,-8(fp)
 d0388fc:	1906b03a 	or	r3,r3,r4
 d038900:	e0fffd15 	stw	r3,-12(fp)
 d038904:	e0bfa143 	ldbu	r2,-379(fp)
 d038908:	10800058 	cmpnei	r2,r2,1
 d03890c:	1000031e 	bne	r2,zero,d03891c <getPHYSpeed+0x74>
 d038910:	00800104 	movi	r2,4
 d038914:	e0bffc15 	stw	r2,-16(fp)
 d038918:	00000106 	br	d038920 <getPHYSpeed+0x78>
 d03891c:	e03ffc15 	stw	zero,-16(fp)
 d038920:	e0fffd17 	ldw	r3,-12(fp)
 d038924:	e13ffc17 	ldw	r4,-16(fp)
 d038928:	1906b03a 	or	r3,r3,r4
 d03892c:	e0fffb15 	stw	r3,-20(fp)
 d038930:	e0bfa143 	ldbu	r2,-379(fp)
 d038934:	1004c03a 	cmpne	r2,r2,zero
 d038938:	1000031e 	bne	r2,zero,d038948 <getPHYSpeed+0xa0>
 d03893c:	00800204 	movi	r2,8
 d038940:	e0bffa15 	stw	r2,-24(fp)
 d038944:	00000106 	br	d03894c <getPHYSpeed+0xa4>
 d038948:	e03ffa15 	stw	zero,-24(fp)
 d03894c:	e0fffb17 	ldw	r3,-20(fp)
 d038950:	e13ffa17 	ldw	r4,-24(fp)
 d038954:	1906b03a 	or	r3,r3,r4
 d038958:	e0fff915 	stw	r3,-28(fp)
 d03895c:	e0bfa143 	ldbu	r2,-379(fp)
 d038960:	108000d8 	cmpnei	r2,r2,3
 d038964:	1000031e 	bne	r2,zero,d038974 <getPHYSpeed+0xcc>
 d038968:	00800074 	movhi	r2,1
 d03896c:	e0bff815 	stw	r2,-32(fp)
 d038970:	00000106 	br	d038978 <getPHYSpeed+0xd0>
 d038974:	e03ff815 	stw	zero,-32(fp)
 d038978:	e0fff917 	ldw	r3,-28(fp)
 d03897c:	e13ff817 	ldw	r4,-32(fp)
 d038980:	1904b03a 	or	r2,r3,r4
 d038984:	e0bfa015 	stw	r2,-384(fp)
    
    alt_tse_phy_info *pphy = 0;
 d038988:	e03f9f15 	stw	zero,-388(fp)
    alt_tse_mac_info *pmac_info = 0;
 d03898c:	e03f9e15 	stw	zero,-392(fp)
    alt_tse_mac_group *pmac_group = 0;
 d038990:	e03f9d15 	stw	zero,-396(fp)
    alt_tse_system_info *psys = 0;
 d038994:	e03f9c15 	stw	zero,-400(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 d038998:	e03f9b45 	stb	zero,-403(fp)
    alt_8 mac_group_index = 0;
 d03899c:	e03f9b05 	stb	zero,-404(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 d0389a0:	d0a938c3 	ldbu	r2,-23325(gp)
 d0389a4:	10803fcc 	andi	r2,r2,255
 d0389a8:	1004c03a 	cmpne	r2,r2,zero
 d0389ac:	1000031e 	bne	r2,zero,d0389bc <getPHYSpeed+0x114>
        alt_tse_phy_init();
 d0389b0:	d03ac280 	call	d03ac28 <alt_tse_phy_init>
        is_init = 1;
 d0389b4:	00800044 	movi	r2,1
 d0389b8:	d0a938c5 	stb	r2,-23325(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 d0389bc:	e13fa217 	ldw	r4,-376(fp)
 d0389c0:	d0386440 	call	d038644 <alt_tse_get_mac_info>
 d0389c4:	e0bf9e15 	stw	r2,-392(fp)
    
    if(pmac_info == 0) {
 d0389c8:	e0bf9e17 	ldw	r2,-392(fp)
 d0389cc:	1004c03a 	cmpne	r2,r2,zero
 d0389d0:	1000651e 	bne	r2,zero,d038b68 <getPHYSpeed+0x2c0>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d0389d4:	00800044 	movi	r2,1
 d0389d8:	e0bfa145 	stb	r2,-379(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d0389dc:	00800044 	movi	r2,1
 d0389e0:	e0bfa105 	stb	r2,-380(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 d0389e4:	e0bfa103 	ldbu	r2,-380(fp)
 d0389e8:	1080004c 	andi	r2,r2,1
 d0389ec:	e0bff715 	stw	r2,-36(fp)
 d0389f0:	e0bfa143 	ldbu	r2,-379(fp)
 d0389f4:	10800098 	cmpnei	r2,r2,2
 d0389f8:	1000031e 	bne	r2,zero,d038a08 <getPHYSpeed+0x160>
 d0389fc:	00800084 	movi	r2,2
 d038a00:	e0bff615 	stw	r2,-40(fp)
 d038a04:	00000106 	br	d038a0c <getPHYSpeed+0x164>
 d038a08:	e03ff615 	stw	zero,-40(fp)
 d038a0c:	e0fff717 	ldw	r3,-36(fp)
 d038a10:	e13ff617 	ldw	r4,-40(fp)
 d038a14:	1906b03a 	or	r3,r3,r4
 d038a18:	e0fff515 	stw	r3,-44(fp)
 d038a1c:	e0bfa143 	ldbu	r2,-379(fp)
 d038a20:	10800058 	cmpnei	r2,r2,1
 d038a24:	1000031e 	bne	r2,zero,d038a34 <getPHYSpeed+0x18c>
 d038a28:	00800104 	movi	r2,4
 d038a2c:	e0bff415 	stw	r2,-48(fp)
 d038a30:	00000106 	br	d038a38 <getPHYSpeed+0x190>
 d038a34:	e03ff415 	stw	zero,-48(fp)
 d038a38:	e0fff517 	ldw	r3,-44(fp)
 d038a3c:	e13ff417 	ldw	r4,-48(fp)
 d038a40:	1906b03a 	or	r3,r3,r4
 d038a44:	e0fff315 	stw	r3,-52(fp)
 d038a48:	e0bfa143 	ldbu	r2,-379(fp)
 d038a4c:	1004c03a 	cmpne	r2,r2,zero
 d038a50:	1000031e 	bne	r2,zero,d038a60 <getPHYSpeed+0x1b8>
 d038a54:	00800204 	movi	r2,8
 d038a58:	e0bff215 	stw	r2,-56(fp)
 d038a5c:	00000106 	br	d038a64 <getPHYSpeed+0x1bc>
 d038a60:	e03ff215 	stw	zero,-56(fp)
 d038a64:	e0fff317 	ldw	r3,-52(fp)
 d038a68:	e13ff217 	ldw	r4,-56(fp)
 d038a6c:	1906b03a 	or	r3,r3,r4
 d038a70:	e0fff115 	stw	r3,-60(fp)
 d038a74:	e0bfa143 	ldbu	r2,-379(fp)
 d038a78:	108000d8 	cmpnei	r2,r2,3
 d038a7c:	1000031e 	bne	r2,zero,d038a8c <getPHYSpeed+0x1e4>
 d038a80:	00800074 	movhi	r2,1
 d038a84:	e0bff015 	stw	r2,-64(fp)
 d038a88:	00000106 	br	d038a90 <getPHYSpeed+0x1e8>
 d038a8c:	e03ff015 	stw	zero,-64(fp)
 d038a90:	e0fff117 	ldw	r3,-60(fp)
 d038a94:	e13ff017 	ldw	r4,-64(fp)
 d038a98:	1904b03a 	or	r2,r3,r4
 d038a9c:	10802034 	orhi	r2,r2,128
 d038aa0:	e0bfa015 	stw	r2,-384(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 d038aa4:	e0bfa143 	ldbu	r2,-379(fp)
 d038aa8:	108000a0 	cmpeqi	r2,r2,2
 d038aac:	1000161e 	bne	r2,zero,d038b08 <getPHYSpeed+0x260>
 d038ab0:	e0bfa143 	ldbu	r2,-379(fp)
 d038ab4:	10800060 	cmpeqi	r2,r2,1
 d038ab8:	10000d1e 	bne	r2,zero,d038af0 <getPHYSpeed+0x248>
 d038abc:	e0bfa143 	ldbu	r2,-379(fp)
 d038ac0:	1004c03a 	cmpne	r2,r2,zero
 d038ac4:	1000041e 	bne	r2,zero,d038ad8 <getPHYSpeed+0x230>
 d038ac8:	00834174 	movhi	r2,3333
 d038acc:	10bfe304 	addi	r2,r2,-116
 d038ad0:	e0bfed15 	stw	r2,-76(fp)
 d038ad4:	00000306 	br	d038ae4 <getPHYSpeed+0x23c>
 d038ad8:	00c34174 	movhi	r3,3333
 d038adc:	18ffe404 	addi	r3,r3,-112
 d038ae0:	e0ffed15 	stw	r3,-76(fp)
 d038ae4:	e13fed17 	ldw	r4,-76(fp)
 d038ae8:	e13fee15 	stw	r4,-72(fp)
 d038aec:	00000306 	br	d038afc <getPHYSpeed+0x254>
 d038af0:	00834174 	movhi	r2,3333
 d038af4:	10bfe604 	addi	r2,r2,-104
 d038af8:	e0bfee15 	stw	r2,-72(fp)
 d038afc:	e0ffee17 	ldw	r3,-72(fp)
 d038b00:	e0ffef15 	stw	r3,-68(fp)
 d038b04:	00000306 	br	d038b14 <getPHYSpeed+0x26c>
 d038b08:	01034174 	movhi	r4,3333
 d038b0c:	213fe704 	addi	r4,r4,-100
 d038b10:	e13fef15 	stw	r4,-68(fp)
 d038b14:	e0bfa103 	ldbu	r2,-380(fp)
 d038b18:	10800058 	cmpnei	r2,r2,1
 d038b1c:	1000041e 	bne	r2,zero,d038b30 <getPHYSpeed+0x288>
 d038b20:	00834174 	movhi	r2,3333
 d038b24:	10bfe904 	addi	r2,r2,-92
 d038b28:	e0bfec15 	stw	r2,-80(fp)
 d038b2c:	00000306 	br	d038b3c <getPHYSpeed+0x294>
 d038b30:	00c34174 	movhi	r3,3333
 d038b34:	18ffeb04 	addi	r3,r3,-84
 d038b38:	e0ffec15 	stw	r3,-80(fp)
 d038b3c:	01034174 	movhi	r4,3333
 d038b40:	213fed04 	addi	r4,r4,-76
 d038b44:	e17fef17 	ldw	r5,-68(fp)
 d038b48:	e1bfec17 	ldw	r6,-80(fp)
 d038b4c:	d0028a00 	call	d0028a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 d038b50:	01034174 	movhi	r4,3333
 d038b54:	21000504 	addi	r4,r4,20
 d038b58:	d002bc80 	call	d002bc8 <puts>
        return result;
 d038b5c:	e13fa017 	ldw	r4,-384(fp)
 d038b60:	e13feb15 	stw	r4,-84(fp)
 d038b64:	0002cc06 	br	d039698 <getPHYSpeed+0xdf0>
    }
    
    pphy = pmac_info->pphy_info;
 d038b68:	e0bf9e17 	ldw	r2,-392(fp)
 d038b6c:	10800117 	ldw	r2,4(r2)
 d038b70:	e0bf9f15 	stw	r2,-388(fp)
    pmac_group = pmac_info->pmac_group;
 d038b74:	e0bf9e17 	ldw	r2,-392(fp)
 d038b78:	10800317 	ldw	r2,12(r2)
 d038b7c:	e0bf9d15 	stw	r2,-396(fp)
    psys = pmac_info->psys_info;
 d038b80:	e0bf9e17 	ldw	r2,-392(fp)
 d038b84:	10800217 	ldw	r2,8(r2)
 d038b88:	e0bf9c15 	stw	r2,-400(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d038b8c:	e13f9e17 	ldw	r4,-392(fp)
 d038b90:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d038b94:	e0bf9b45 	stb	r2,-403(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d038b98:	e13f9d17 	ldw	r4,-396(fp)
 d038b9c:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d038ba0:	e0bf9b05 	stb	r2,-404(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 d038ba4:	e0bf9d17 	ldw	r2,-396(fp)
 d038ba8:	10800117 	ldw	r2,4(r2)
 d038bac:	10800217 	ldw	r2,8(r2)
 d038bb0:	10800203 	ldbu	r2,8(r2)
 d038bb4:	10803fcc 	andi	r2,r2,255
 d038bb8:	1004c03a 	cmpne	r2,r2,zero
 d038bbc:	1000771e 	bne	r2,zero,d038d9c <getPHYSpeed+0x4f4>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d038bc0:	00800044 	movi	r2,1
 d038bc4:	e0bfa145 	stb	r2,-379(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d038bc8:	00800044 	movi	r2,1
 d038bcc:	e0bfa105 	stb	r2,-380(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 d038bd0:	e0bfa103 	ldbu	r2,-380(fp)
 d038bd4:	1080004c 	andi	r2,r2,1
 d038bd8:	e0bfea15 	stw	r2,-88(fp)
 d038bdc:	e0bfa143 	ldbu	r2,-379(fp)
 d038be0:	10800098 	cmpnei	r2,r2,2
 d038be4:	1000031e 	bne	r2,zero,d038bf4 <getPHYSpeed+0x34c>
 d038be8:	00800084 	movi	r2,2
 d038bec:	e0bfe915 	stw	r2,-92(fp)
 d038bf0:	00000106 	br	d038bf8 <getPHYSpeed+0x350>
 d038bf4:	e03fe915 	stw	zero,-92(fp)
 d038bf8:	e0ffea17 	ldw	r3,-88(fp)
 d038bfc:	e13fe917 	ldw	r4,-92(fp)
 d038c00:	1906b03a 	or	r3,r3,r4
 d038c04:	e0ffe815 	stw	r3,-96(fp)
 d038c08:	e0bfa143 	ldbu	r2,-379(fp)
 d038c0c:	10800058 	cmpnei	r2,r2,1
 d038c10:	1000031e 	bne	r2,zero,d038c20 <getPHYSpeed+0x378>
 d038c14:	00800104 	movi	r2,4
 d038c18:	e0bfe715 	stw	r2,-100(fp)
 d038c1c:	00000106 	br	d038c24 <getPHYSpeed+0x37c>
 d038c20:	e03fe715 	stw	zero,-100(fp)
 d038c24:	e0ffe817 	ldw	r3,-96(fp)
 d038c28:	e13fe717 	ldw	r4,-100(fp)
 d038c2c:	1906b03a 	or	r3,r3,r4
 d038c30:	e0ffe615 	stw	r3,-104(fp)
 d038c34:	e0bfa143 	ldbu	r2,-379(fp)
 d038c38:	1004c03a 	cmpne	r2,r2,zero
 d038c3c:	1000031e 	bne	r2,zero,d038c4c <getPHYSpeed+0x3a4>
 d038c40:	00800204 	movi	r2,8
 d038c44:	e0bfe515 	stw	r2,-108(fp)
 d038c48:	00000106 	br	d038c50 <getPHYSpeed+0x3a8>
 d038c4c:	e03fe515 	stw	zero,-108(fp)
 d038c50:	e0ffe617 	ldw	r3,-104(fp)
 d038c54:	e13fe517 	ldw	r4,-108(fp)
 d038c58:	1906b03a 	or	r3,r3,r4
 d038c5c:	e0ffe415 	stw	r3,-112(fp)
 d038c60:	e0bfa143 	ldbu	r2,-379(fp)
 d038c64:	108000d8 	cmpnei	r2,r2,3
 d038c68:	1000031e 	bne	r2,zero,d038c78 <getPHYSpeed+0x3d0>
 d038c6c:	00800074 	movhi	r2,1
 d038c70:	e0bfe315 	stw	r2,-116(fp)
 d038c74:	00000106 	br	d038c7c <getPHYSpeed+0x3d4>
 d038c78:	e03fe315 	stw	zero,-116(fp)
 d038c7c:	e0ffe417 	ldw	r3,-112(fp)
 d038c80:	e13fe317 	ldw	r4,-116(fp)
 d038c84:	1904b03a 	or	r2,r3,r4
 d038c88:	10801034 	orhi	r2,r2,64
 d038c8c:	e0bfa015 	stw	r2,-384(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 d038c90:	010003f4 	movhi	r4,15
 d038c94:	21109004 	addi	r4,r4,16960
 d038c98:	d035fd00 	call	d035fd0 <usleep>
        if(psys->tse_phy_cfg) {
 d038c9c:	e0bf9c17 	ldw	r2,-400(fp)
 d038ca0:	10801117 	ldw	r2,68(r2)
 d038ca4:	1005003a 	cmpeq	r2,r2,zero
 d038ca8:	10000b1e 	bne	r2,zero,d038cd8 <getPHYSpeed+0x430>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 d038cac:	e17f9b07 	ldb	r5,-404(fp)
 d038cb0:	e1bf9b47 	ldb	r6,-403(fp)
 d038cb4:	01034174 	movhi	r4,3333
 d038cb8:	21001604 	addi	r4,r4,88
 d038cbc:	d0028a00 	call	d0028a0 <printf>
        	result = psys->tse_phy_cfg(pmac);
 d038cc0:	e0bf9c17 	ldw	r2,-400(fp)
 d038cc4:	10801117 	ldw	r2,68(r2)
 d038cc8:	e13fa217 	ldw	r4,-376(fp)
 d038ccc:	103ee83a 	callr	r2
 d038cd0:	e0bfa015 	stw	r2,-384(fp)
 d038cd4:	00002e06 	br	d038d90 <getPHYSpeed+0x4e8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d038cd8:	e0bf9b07 	ldb	r2,-404(fp)
 d038cdc:	e0bfe215 	stw	r2,-120(fp)
 d038ce0:	e0bfa143 	ldbu	r2,-379(fp)
 d038ce4:	108000a0 	cmpeqi	r2,r2,2
 d038ce8:	1000161e 	bne	r2,zero,d038d44 <getPHYSpeed+0x49c>
 d038cec:	e0bfa143 	ldbu	r2,-379(fp)
 d038cf0:	10800060 	cmpeqi	r2,r2,1
 d038cf4:	10000d1e 	bne	r2,zero,d038d2c <getPHYSpeed+0x484>
 d038cf8:	e0bfa143 	ldbu	r2,-379(fp)
 d038cfc:	1004c03a 	cmpne	r2,r2,zero
 d038d00:	1000041e 	bne	r2,zero,d038d14 <getPHYSpeed+0x46c>
 d038d04:	00c34174 	movhi	r3,3333
 d038d08:	18ffe304 	addi	r3,r3,-116
 d038d0c:	e0ffdf15 	stw	r3,-132(fp)
 d038d10:	00000306 	br	d038d20 <getPHYSpeed+0x478>
 d038d14:	01034174 	movhi	r4,3333
 d038d18:	213fe404 	addi	r4,r4,-112
 d038d1c:	e13fdf15 	stw	r4,-132(fp)
 d038d20:	e0bfdf17 	ldw	r2,-132(fp)
 d038d24:	e0bfe015 	stw	r2,-128(fp)
 d038d28:	00000306 	br	d038d38 <getPHYSpeed+0x490>
 d038d2c:	00c34174 	movhi	r3,3333
 d038d30:	18ffe604 	addi	r3,r3,-104
 d038d34:	e0ffe015 	stw	r3,-128(fp)
 d038d38:	e13fe017 	ldw	r4,-128(fp)
 d038d3c:	e13fe115 	stw	r4,-124(fp)
 d038d40:	00000306 	br	d038d50 <getPHYSpeed+0x4a8>
 d038d44:	00834174 	movhi	r2,3333
 d038d48:	10bfe704 	addi	r2,r2,-100
 d038d4c:	e0bfe115 	stw	r2,-124(fp)
 d038d50:	e0bfa103 	ldbu	r2,-380(fp)
 d038d54:	10800058 	cmpnei	r2,r2,1
 d038d58:	1000041e 	bne	r2,zero,d038d6c <getPHYSpeed+0x4c4>
 d038d5c:	00c34174 	movhi	r3,3333
 d038d60:	18ffe904 	addi	r3,r3,-92
 d038d64:	e0ffde15 	stw	r3,-136(fp)
 d038d68:	00000306 	br	d038d78 <getPHYSpeed+0x4d0>
 d038d6c:	01034174 	movhi	r4,3333
 d038d70:	213feb04 	addi	r4,r4,-84
 d038d74:	e13fde15 	stw	r4,-136(fp)
 d038d78:	01034174 	movhi	r4,3333
 d038d7c:	21002804 	addi	r4,r4,160
 d038d80:	e17fe217 	ldw	r5,-120(fp)
 d038d84:	e1bfe117 	ldw	r6,-124(fp)
 d038d88:	e1ffde17 	ldw	r7,-136(fp)
 d038d8c:	d0028a00 	call	d0028a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 d038d90:	e0bfa017 	ldw	r2,-384(fp)
 d038d94:	e0bfeb15 	stw	r2,-84(fp)
 d038d98:	00023f06 	br	d039698 <getPHYSpeed+0xdf0>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d038d9c:	e0bf9d17 	ldw	r2,-396(fp)
 d038da0:	10800117 	ldw	r2,4(r2)
 d038da4:	10800217 	ldw	r2,8(r2)
 d038da8:	10800017 	ldw	r2,0(r2)
 d038dac:	e0bf9a15 	stw	r2,-408(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 d038db0:	e0bf9f17 	ldw	r2,-388(fp)
 d038db4:	1004c03a 	cmpne	r2,r2,zero
 d038db8:	1000691e 	bne	r2,zero,d038f60 <getPHYSpeed+0x6b8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d038dbc:	00800044 	movi	r2,1
 d038dc0:	e0bfa145 	stb	r2,-379(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d038dc4:	00800044 	movi	r2,1
 d038dc8:	e0bfa105 	stb	r2,-380(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 d038dcc:	e0bfa103 	ldbu	r2,-380(fp)
 d038dd0:	1080004c 	andi	r2,r2,1
 d038dd4:	e0bfdd15 	stw	r2,-140(fp)
 d038dd8:	e0bfa143 	ldbu	r2,-379(fp)
 d038ddc:	10800098 	cmpnei	r2,r2,2
 d038de0:	1000031e 	bne	r2,zero,d038df0 <getPHYSpeed+0x548>
 d038de4:	00c00084 	movi	r3,2
 d038de8:	e0ffdc15 	stw	r3,-144(fp)
 d038dec:	00000106 	br	d038df4 <getPHYSpeed+0x54c>
 d038df0:	e03fdc15 	stw	zero,-144(fp)
 d038df4:	e13fdd17 	ldw	r4,-140(fp)
 d038df8:	e0bfdc17 	ldw	r2,-144(fp)
 d038dfc:	2088b03a 	or	r4,r4,r2
 d038e00:	e13fdb15 	stw	r4,-148(fp)
 d038e04:	e0bfa143 	ldbu	r2,-379(fp)
 d038e08:	10800058 	cmpnei	r2,r2,1
 d038e0c:	1000031e 	bne	r2,zero,d038e1c <getPHYSpeed+0x574>
 d038e10:	00c00104 	movi	r3,4
 d038e14:	e0ffda15 	stw	r3,-152(fp)
 d038e18:	00000106 	br	d038e20 <getPHYSpeed+0x578>
 d038e1c:	e03fda15 	stw	zero,-152(fp)
 d038e20:	e13fdb17 	ldw	r4,-148(fp)
 d038e24:	e0bfda17 	ldw	r2,-152(fp)
 d038e28:	2088b03a 	or	r4,r4,r2
 d038e2c:	e13fd915 	stw	r4,-156(fp)
 d038e30:	e0bfa143 	ldbu	r2,-379(fp)
 d038e34:	1004c03a 	cmpne	r2,r2,zero
 d038e38:	1000031e 	bne	r2,zero,d038e48 <getPHYSpeed+0x5a0>
 d038e3c:	00c00204 	movi	r3,8
 d038e40:	e0ffd815 	stw	r3,-160(fp)
 d038e44:	00000106 	br	d038e4c <getPHYSpeed+0x5a4>
 d038e48:	e03fd815 	stw	zero,-160(fp)
 d038e4c:	e13fd917 	ldw	r4,-156(fp)
 d038e50:	e0bfd817 	ldw	r2,-160(fp)
 d038e54:	2088b03a 	or	r4,r4,r2
 d038e58:	e13fd715 	stw	r4,-164(fp)
 d038e5c:	e0bfa143 	ldbu	r2,-379(fp)
 d038e60:	108000d8 	cmpnei	r2,r2,3
 d038e64:	1000031e 	bne	r2,zero,d038e74 <getPHYSpeed+0x5cc>
 d038e68:	00c00074 	movhi	r3,1
 d038e6c:	e0ffd615 	stw	r3,-168(fp)
 d038e70:	00000106 	br	d038e78 <getPHYSpeed+0x5d0>
 d038e74:	e03fd615 	stw	zero,-168(fp)
 d038e78:	e13fd717 	ldw	r4,-164(fp)
 d038e7c:	e0ffd617 	ldw	r3,-168(fp)
 d038e80:	20c4b03a 	or	r2,r4,r3
 d038e84:	10800834 	orhi	r2,r2,32
 d038e88:	e0bfa015 	stw	r2,-384(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d038e8c:	e13f9b07 	ldb	r4,-404(fp)
 d038e90:	e13fd515 	stw	r4,-172(fp)
 d038e94:	e0bf9b47 	ldb	r2,-403(fp)
 d038e98:	e0bfd415 	stw	r2,-176(fp)
 d038e9c:	e0bfa143 	ldbu	r2,-379(fp)
 d038ea0:	108000a0 	cmpeqi	r2,r2,2
 d038ea4:	1000161e 	bne	r2,zero,d038f00 <getPHYSpeed+0x658>
 d038ea8:	e0bfa143 	ldbu	r2,-379(fp)
 d038eac:	10800060 	cmpeqi	r2,r2,1
 d038eb0:	10000d1e 	bne	r2,zero,d038ee8 <getPHYSpeed+0x640>
 d038eb4:	e0bfa143 	ldbu	r2,-379(fp)
 d038eb8:	1004c03a 	cmpne	r2,r2,zero
 d038ebc:	1000041e 	bne	r2,zero,d038ed0 <getPHYSpeed+0x628>
 d038ec0:	00c34174 	movhi	r3,3333
 d038ec4:	18ffe304 	addi	r3,r3,-116
 d038ec8:	e0ffd115 	stw	r3,-188(fp)
 d038ecc:	00000306 	br	d038edc <getPHYSpeed+0x634>
 d038ed0:	01034174 	movhi	r4,3333
 d038ed4:	213fe404 	addi	r4,r4,-112
 d038ed8:	e13fd115 	stw	r4,-188(fp)
 d038edc:	e0bfd117 	ldw	r2,-188(fp)
 d038ee0:	e0bfd215 	stw	r2,-184(fp)
 d038ee4:	00000306 	br	d038ef4 <getPHYSpeed+0x64c>
 d038ee8:	00c34174 	movhi	r3,3333
 d038eec:	18ffe604 	addi	r3,r3,-104
 d038ef0:	e0ffd215 	stw	r3,-184(fp)
 d038ef4:	e13fd217 	ldw	r4,-184(fp)
 d038ef8:	e13fd315 	stw	r4,-180(fp)
 d038efc:	00000306 	br	d038f0c <getPHYSpeed+0x664>
 d038f00:	00834174 	movhi	r2,3333
 d038f04:	10bfe704 	addi	r2,r2,-100
 d038f08:	e0bfd315 	stw	r2,-180(fp)
 d038f0c:	e0bfa103 	ldbu	r2,-380(fp)
 d038f10:	10800058 	cmpnei	r2,r2,1
 d038f14:	1000041e 	bne	r2,zero,d038f28 <getPHYSpeed+0x680>
 d038f18:	00c34174 	movhi	r3,3333
 d038f1c:	18ffe904 	addi	r3,r3,-92
 d038f20:	e0ffd015 	stw	r3,-192(fp)
 d038f24:	00000306 	br	d038f34 <getPHYSpeed+0x68c>
 d038f28:	01034174 	movhi	r4,3333
 d038f2c:	213feb04 	addi	r4,r4,-84
 d038f30:	e13fd015 	stw	r4,-192(fp)
 d038f34:	e0bfd017 	ldw	r2,-192(fp)
 d038f38:	d8800015 	stw	r2,0(sp)
 d038f3c:	01034174 	movhi	r4,3333
 d038f40:	21003a04 	addi	r4,r4,232
 d038f44:	e17fd517 	ldw	r5,-172(fp)
 d038f48:	e1bfd417 	ldw	r6,-176(fp)
 d038f4c:	e1ffd317 	ldw	r7,-180(fp)
 d038f50:	d0028a00 	call	d0028a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 d038f54:	e0ffa017 	ldw	r3,-384(fp)
 d038f58:	e0ffeb15 	stw	r3,-84(fp)
 d038f5c:	0001ce06 	br	d039698 <getPHYSpeed+0xdf0>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 d038f60:	e0bf9e17 	ldw	r2,-392(fp)
 d038f64:	10800003 	ldbu	r2,0(r2)
 d038f68:	10803fcc 	andi	r2,r2,255
 d038f6c:	10800058 	cmpnei	r2,r2,1
 d038f70:	1000081e 	bne	r2,zero,d038f94 <getPHYSpeed+0x6ec>
			alt_tse_phy_set_adv_1000(pphy, 0);
 d038f74:	e13f9f17 	ldw	r4,-388(fp)
 d038f78:	000b883a 	mov	r5,zero
 d038f7c:	d03b5700 	call	d03b570 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d038f80:	e13f9f17 	ldw	r4,-388(fp)
 d038f84:	01400134 	movhi	r5,4
 d038f88:	29742404 	addi	r5,r5,-12144
 d038f8c:	d03ad3c0 	call	d03ad3c <alt_tse_phy_restart_an>
 d038f90:	00000f06 	br	d038fd0 <getPHYSpeed+0x728>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 d038f94:	e0bf9e17 	ldw	r2,-392(fp)
 d038f98:	10800003 	ldbu	r2,0(r2)
 d038f9c:	10803fcc 	andi	r2,r2,255
 d038fa0:	10800098 	cmpnei	r2,r2,2
 d038fa4:	10000a1e 	bne	r2,zero,d038fd0 <getPHYSpeed+0x728>
			alt_tse_phy_set_adv_100(pphy, 0);
 d038fa8:	e13f9f17 	ldw	r4,-388(fp)
 d038fac:	000b883a 	mov	r5,zero
 d038fb0:	d03b7040 	call	d03b704 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 d038fb4:	e13f9f17 	ldw	r4,-388(fp)
 d038fb8:	000b883a 	mov	r5,zero
 d038fbc:	d03b9140 	call	d03b914 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d038fc0:	e13f9f17 	ldw	r4,-388(fp)
 d038fc4:	01400134 	movhi	r5,4
 d038fc8:	29742404 	addi	r5,r5,-12144
 d038fcc:	d03ad3c0 	call	d03ad3c <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 d038fd0:	e13f9f17 	ldw	r4,-388(fp)
 d038fd4:	01400134 	movhi	r5,4
 d038fd8:	29742404 	addi	r5,r5,-12144
 d038fdc:	d03aeec0 	call	d03aeec <alt_tse_phy_check_link>
 d038fe0:	10bfffd8 	cmpnei	r2,r2,-1
 d038fe4:	1000691e 	bne	r2,zero,d03918c <getPHYSpeed+0x8e4>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d038fe8:	00800044 	movi	r2,1
 d038fec:	e0bfa145 	stb	r2,-379(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d038ff0:	00800044 	movi	r2,1
 d038ff4:	e0bfa105 	stb	r2,-380(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 d038ff8:	e0bfa103 	ldbu	r2,-380(fp)
 d038ffc:	1080004c 	andi	r2,r2,1
 d039000:	e0bfcf15 	stw	r2,-196(fp)
 d039004:	e0bfa143 	ldbu	r2,-379(fp)
 d039008:	10800098 	cmpnei	r2,r2,2
 d03900c:	1000031e 	bne	r2,zero,d03901c <getPHYSpeed+0x774>
 d039010:	01000084 	movi	r4,2
 d039014:	e13fce15 	stw	r4,-200(fp)
 d039018:	00000106 	br	d039020 <getPHYSpeed+0x778>
 d03901c:	e03fce15 	stw	zero,-200(fp)
 d039020:	e0bfcf17 	ldw	r2,-196(fp)
 d039024:	e0ffce17 	ldw	r3,-200(fp)
 d039028:	10c4b03a 	or	r2,r2,r3
 d03902c:	e0bfcd15 	stw	r2,-204(fp)
 d039030:	e0bfa143 	ldbu	r2,-379(fp)
 d039034:	10800058 	cmpnei	r2,r2,1
 d039038:	1000031e 	bne	r2,zero,d039048 <getPHYSpeed+0x7a0>
 d03903c:	01000104 	movi	r4,4
 d039040:	e13fcc15 	stw	r4,-208(fp)
 d039044:	00000106 	br	d03904c <getPHYSpeed+0x7a4>
 d039048:	e03fcc15 	stw	zero,-208(fp)
 d03904c:	e0bfcd17 	ldw	r2,-204(fp)
 d039050:	e0ffcc17 	ldw	r3,-208(fp)
 d039054:	10c4b03a 	or	r2,r2,r3
 d039058:	e0bfcb15 	stw	r2,-212(fp)
 d03905c:	e0bfa143 	ldbu	r2,-379(fp)
 d039060:	1004c03a 	cmpne	r2,r2,zero
 d039064:	1000031e 	bne	r2,zero,d039074 <getPHYSpeed+0x7cc>
 d039068:	01000204 	movi	r4,8
 d03906c:	e13fca15 	stw	r4,-216(fp)
 d039070:	00000106 	br	d039078 <getPHYSpeed+0x7d0>
 d039074:	e03fca15 	stw	zero,-216(fp)
 d039078:	e0bfcb17 	ldw	r2,-212(fp)
 d03907c:	e0ffca17 	ldw	r3,-216(fp)
 d039080:	10c4b03a 	or	r2,r2,r3
 d039084:	e0bfc915 	stw	r2,-220(fp)
 d039088:	e0bfa143 	ldbu	r2,-379(fp)
 d03908c:	108000d8 	cmpnei	r2,r2,3
 d039090:	1000031e 	bne	r2,zero,d0390a0 <getPHYSpeed+0x7f8>
 d039094:	01000074 	movhi	r4,1
 d039098:	e13fc815 	stw	r4,-224(fp)
 d03909c:	00000106 	br	d0390a4 <getPHYSpeed+0x7fc>
 d0390a0:	e03fc815 	stw	zero,-224(fp)
 d0390a4:	e0ffc917 	ldw	r3,-220(fp)
 d0390a8:	e13fc817 	ldw	r4,-224(fp)
 d0390ac:	1904b03a 	or	r2,r3,r4
 d0390b0:	10800234 	orhi	r2,r2,8
 d0390b4:	e0bfa015 	stw	r2,-384(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d0390b8:	e0bf9b07 	ldb	r2,-404(fp)
 d0390bc:	e0bfc715 	stw	r2,-228(fp)
 d0390c0:	e0ff9b47 	ldb	r3,-403(fp)
 d0390c4:	e0ffc615 	stw	r3,-232(fp)
 d0390c8:	e0bfa143 	ldbu	r2,-379(fp)
 d0390cc:	108000a0 	cmpeqi	r2,r2,2
 d0390d0:	1000161e 	bne	r2,zero,d03912c <getPHYSpeed+0x884>
 d0390d4:	e0bfa143 	ldbu	r2,-379(fp)
 d0390d8:	10800060 	cmpeqi	r2,r2,1
 d0390dc:	10000d1e 	bne	r2,zero,d039114 <getPHYSpeed+0x86c>
 d0390e0:	e0bfa143 	ldbu	r2,-379(fp)
 d0390e4:	1004c03a 	cmpne	r2,r2,zero
 d0390e8:	1000041e 	bne	r2,zero,d0390fc <getPHYSpeed+0x854>
 d0390ec:	01034174 	movhi	r4,3333
 d0390f0:	213fe304 	addi	r4,r4,-116
 d0390f4:	e13fc315 	stw	r4,-244(fp)
 d0390f8:	00000306 	br	d039108 <getPHYSpeed+0x860>
 d0390fc:	00834174 	movhi	r2,3333
 d039100:	10bfe404 	addi	r2,r2,-112
 d039104:	e0bfc315 	stw	r2,-244(fp)
 d039108:	e0ffc317 	ldw	r3,-244(fp)
 d03910c:	e0ffc415 	stw	r3,-240(fp)
 d039110:	00000306 	br	d039120 <getPHYSpeed+0x878>
 d039114:	01034174 	movhi	r4,3333
 d039118:	213fe604 	addi	r4,r4,-104
 d03911c:	e13fc415 	stw	r4,-240(fp)
 d039120:	e0bfc417 	ldw	r2,-240(fp)
 d039124:	e0bfc515 	stw	r2,-236(fp)
 d039128:	00000306 	br	d039138 <getPHYSpeed+0x890>
 d03912c:	00c34174 	movhi	r3,3333
 d039130:	18ffe704 	addi	r3,r3,-100
 d039134:	e0ffc515 	stw	r3,-236(fp)
 d039138:	e0bfa103 	ldbu	r2,-380(fp)
 d03913c:	10800058 	cmpnei	r2,r2,1
 d039140:	1000041e 	bne	r2,zero,d039154 <getPHYSpeed+0x8ac>
 d039144:	01034174 	movhi	r4,3333
 d039148:	213fe904 	addi	r4,r4,-92
 d03914c:	e13fc215 	stw	r4,-248(fp)
 d039150:	00000306 	br	d039160 <getPHYSpeed+0x8b8>
 d039154:	00834174 	movhi	r2,3333
 d039158:	10bfeb04 	addi	r2,r2,-84
 d03915c:	e0bfc215 	stw	r2,-248(fp)
 d039160:	e0ffc217 	ldw	r3,-248(fp)
 d039164:	d8c00015 	stw	r3,0(sp)
 d039168:	01034174 	movhi	r4,3333
 d03916c:	21004b04 	addi	r4,r4,300
 d039170:	e17fc717 	ldw	r5,-228(fp)
 d039174:	e1bfc617 	ldw	r6,-232(fp)
 d039178:	e1ffc517 	ldw	r7,-236(fp)
 d03917c:	d0028a00 	call	d0028a0 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 d039180:	e13fa017 	ldw	r4,-384(fp)
 d039184:	e13feb15 	stw	r4,-84(fp)
 d039188:	00014306 	br	d039698 <getPHYSpeed+0xdf0>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 d03918c:	e0bf9a17 	ldw	r2,-408(fp)
 d039190:	10801004 	addi	r2,r2,64
 d039194:	1009883a 	mov	r4,r2
 d039198:	e0bf9f17 	ldw	r2,-388(fp)
 d03919c:	10800003 	ldbu	r2,0(r2)
 d0391a0:	10c03fcc 	andi	r3,r2,255
 d0391a4:	2005883a 	mov	r2,r4
 d0391a8:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 d0391ac:	d8000015 	stw	zero,0(sp)
 d0391b0:	e13f9f17 	ldw	r4,-388(fp)
 d0391b4:	000b883a 	mov	r5,zero
 d0391b8:	01800384 	movi	r6,14
 d0391bc:	01c00044 	movi	r7,1
 d0391c0:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 d0391c4:	e0bf9f17 	ldw	r2,-388(fp)
 d0391c8:	10800517 	ldw	r2,20(r2)
 d0391cc:	1004c03a 	cmpne	r2,r2,zero
 d0391d0:	10003a1e 	bne	r2,zero,d0392bc <getPHYSpeed+0xa14>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 d0391d4:	e17f9b07 	ldb	r5,-404(fp)
 d0391d8:	e1bf9b47 	ldb	r6,-403(fp)
 d0391dc:	01034174 	movhi	r4,3333
 d0391e0:	21005f04 	addi	r4,r4,380
 d0391e4:	d0028a00 	call	d0028a0 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d0391e8:	00800044 	movi	r2,1
 d0391ec:	e0bfa145 	stb	r2,-379(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d0391f0:	00800044 	movi	r2,1
 d0391f4:	e0bfa105 	stb	r2,-380(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 d0391f8:	e0bfa103 	ldbu	r2,-380(fp)
 d0391fc:	1080004c 	andi	r2,r2,1
 d039200:	e0bfc115 	stw	r2,-252(fp)
 d039204:	e0bfa143 	ldbu	r2,-379(fp)
 d039208:	10800098 	cmpnei	r2,r2,2
 d03920c:	1000031e 	bne	r2,zero,d03921c <getPHYSpeed+0x974>
 d039210:	00800084 	movi	r2,2
 d039214:	e0bfc015 	stw	r2,-256(fp)
 d039218:	00000106 	br	d039220 <getPHYSpeed+0x978>
 d03921c:	e03fc015 	stw	zero,-256(fp)
 d039220:	e0ffc117 	ldw	r3,-252(fp)
 d039224:	e13fc017 	ldw	r4,-256(fp)
 d039228:	1906b03a 	or	r3,r3,r4
 d03922c:	e0ffbf15 	stw	r3,-260(fp)
 d039230:	e0bfa143 	ldbu	r2,-379(fp)
 d039234:	10800058 	cmpnei	r2,r2,1
 d039238:	1000031e 	bne	r2,zero,d039248 <getPHYSpeed+0x9a0>
 d03923c:	00800104 	movi	r2,4
 d039240:	e0bfbe15 	stw	r2,-264(fp)
 d039244:	00000106 	br	d03924c <getPHYSpeed+0x9a4>
 d039248:	e03fbe15 	stw	zero,-264(fp)
 d03924c:	e0ffbf17 	ldw	r3,-260(fp)
 d039250:	e13fbe17 	ldw	r4,-264(fp)
 d039254:	1906b03a 	or	r3,r3,r4
 d039258:	e0ffbd15 	stw	r3,-268(fp)
 d03925c:	e0bfa143 	ldbu	r2,-379(fp)
 d039260:	1004c03a 	cmpne	r2,r2,zero
 d039264:	1000031e 	bne	r2,zero,d039274 <getPHYSpeed+0x9cc>
 d039268:	00800204 	movi	r2,8
 d03926c:	e0bfbc15 	stw	r2,-272(fp)
 d039270:	00000106 	br	d039278 <getPHYSpeed+0x9d0>
 d039274:	e03fbc15 	stw	zero,-272(fp)
 d039278:	e0ffbd17 	ldw	r3,-268(fp)
 d03927c:	e13fbc17 	ldw	r4,-272(fp)
 d039280:	1906b03a 	or	r3,r3,r4
 d039284:	e0ffbb15 	stw	r3,-276(fp)
 d039288:	e0bfa143 	ldbu	r2,-379(fp)
 d03928c:	108000d8 	cmpnei	r2,r2,3
 d039290:	1000031e 	bne	r2,zero,d0392a0 <getPHYSpeed+0x9f8>
 d039294:	00800074 	movhi	r2,1
 d039298:	e0bfba15 	stw	r2,-280(fp)
 d03929c:	00000106 	br	d0392a4 <getPHYSpeed+0x9fc>
 d0392a0:	e03fba15 	stw	zero,-280(fp)
 d0392a4:	e0ffbb17 	ldw	r3,-276(fp)
 d0392a8:	e13fba17 	ldw	r4,-280(fp)
 d0392ac:	1904b03a 	or	r2,r3,r4
 d0392b0:	10800134 	orhi	r2,r2,4
 d0392b4:	e0bfa015 	stw	r2,-384(fp)
 d0392b8:	0000c306 	br	d0395c8 <getPHYSpeed+0xd20>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 d0392bc:	e0bf9f17 	ldw	r2,-388(fp)
 d0392c0:	10800517 	ldw	r2,20(r2)
 d0392c4:	10801817 	ldw	r2,96(r2)
 d0392c8:	1005003a 	cmpeq	r2,r2,zero
 d0392cc:	1000371e 	bne	r2,zero,d0393ac <getPHYSpeed+0xb04>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 d0392d0:	e0bf9f17 	ldw	r2,-388(fp)
 d0392d4:	10800517 	ldw	r2,20(r2)
 d0392d8:	10801817 	ldw	r2,96(r2)
 d0392dc:	e13f9a17 	ldw	r4,-408(fp)
 d0392e0:	103ee83a 	callr	r2
 d0392e4:	e0bfa015 	stw	r2,-384(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 d0392e8:	e0bfa017 	ldw	r2,-384(fp)
 d0392ec:	1080008c 	andi	r2,r2,2
 d0392f0:	1004c03a 	cmpne	r2,r2,zero
 d0392f4:	1000141e 	bne	r2,zero,d039348 <getPHYSpeed+0xaa0>
 d0392f8:	e0bfa017 	ldw	r2,-384(fp)
 d0392fc:	1080010c 	andi	r2,r2,4
 d039300:	1004c03a 	cmpne	r2,r2,zero
 d039304:	10000b1e 	bne	r2,zero,d039334 <getPHYSpeed+0xa8c>
 d039308:	e0bfa017 	ldw	r2,-384(fp)
 d03930c:	1080020c 	andi	r2,r2,8
 d039310:	1005003a 	cmpeq	r2,r2,zero
 d039314:	1000021e 	bne	r2,zero,d039320 <getPHYSpeed+0xa78>
 d039318:	e03fb945 	stb	zero,-283(fp)
 d03931c:	00000206 	br	d039328 <getPHYSpeed+0xa80>
 d039320:	008000c4 	movi	r2,3
 d039324:	e0bfb945 	stb	r2,-283(fp)
 d039328:	e0ffb943 	ldbu	r3,-283(fp)
 d03932c:	e0ffb985 	stb	r3,-282(fp)
 d039330:	00000206 	br	d03933c <getPHYSpeed+0xa94>
 d039334:	01000044 	movi	r4,1
 d039338:	e13fb985 	stb	r4,-282(fp)
 d03933c:	e0bfb983 	ldbu	r2,-282(fp)
 d039340:	e0bfb9c5 	stb	r2,-281(fp)
 d039344:	00000206 	br	d039350 <getPHYSpeed+0xaa8>
 d039348:	00c00084 	movi	r3,2
 d03934c:	e0ffb9c5 	stb	r3,-281(fp)
 d039350:	e13fb9c3 	ldbu	r4,-281(fp)
 d039354:	e13fa145 	stb	r4,-379(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 d039358:	e0bfa017 	ldw	r2,-384(fp)
 d03935c:	1080004c 	andi	r2,r2,1
 d039360:	10803fcc 	andi	r2,r2,255
 d039364:	1005003a 	cmpeq	r2,r2,zero
 d039368:	1000031e 	bne	r2,zero,d039378 <getPHYSpeed+0xad0>
 d03936c:	00800044 	movi	r2,1
 d039370:	e0bfb905 	stb	r2,-284(fp)
 d039374:	00000106 	br	d03937c <getPHYSpeed+0xad4>
 d039378:	e03fb905 	stb	zero,-284(fp)
 d03937c:	e0ffb903 	ldbu	r3,-284(fp)
 d039380:	e0ffa105 	stb	r3,-380(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 d039384:	e0bfa017 	ldw	r2,-384(fp)
 d039388:	1080006c 	andhi	r2,r2,1
 d03938c:	1005003a 	cmpeq	r2,r2,zero
 d039390:	10008d1e 	bne	r2,zero,d0395c8 <getPHYSpeed+0xd20>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 d039394:	e17f9b07 	ldb	r5,-404(fp)
 d039398:	e1bf9b47 	ldb	r6,-403(fp)
 d03939c:	01034174 	movhi	r4,3333
 d0393a0:	21006d04 	addi	r4,r4,436
 d0393a4:	d0028a00 	call	d0028a0 <printf>
 d0393a8:	00008706 	br	d0395c8 <getPHYSpeed+0xd20>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 d0393ac:	e0bf9f17 	ldw	r2,-388(fp)
 d0393b0:	10800517 	ldw	r2,20(r2)
 d0393b4:	10801583 	ldbu	r2,86(r2)
 d0393b8:	10803fcc 	andi	r2,r2,255
 d0393bc:	1004c03a 	cmpne	r2,r2,zero
 d0393c0:	10003a1e 	bne	r2,zero,d0394ac <getPHYSpeed+0xc04>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 d0393c4:	e17f9b07 	ldb	r5,-404(fp)
 d0393c8:	e1bf9b47 	ldb	r6,-403(fp)
 d0393cc:	01034174 	movhi	r4,3333
 d0393d0:	21007a04 	addi	r4,r4,488
 d0393d4:	d0028a00 	call	d0028a0 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d0393d8:	00800044 	movi	r2,1
 d0393dc:	e0bfa145 	stb	r2,-379(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d0393e0:	00800044 	movi	r2,1
 d0393e4:	e0bfa105 	stb	r2,-380(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 d0393e8:	e0bfa103 	ldbu	r2,-380(fp)
 d0393ec:	1080004c 	andi	r2,r2,1
 d0393f0:	e0bfb815 	stw	r2,-288(fp)
 d0393f4:	e0bfa143 	ldbu	r2,-379(fp)
 d0393f8:	10800098 	cmpnei	r2,r2,2
 d0393fc:	1000031e 	bne	r2,zero,d03940c <getPHYSpeed+0xb64>
 d039400:	01000084 	movi	r4,2
 d039404:	e13fb715 	stw	r4,-292(fp)
 d039408:	00000106 	br	d039410 <getPHYSpeed+0xb68>
 d03940c:	e03fb715 	stw	zero,-292(fp)
 d039410:	e0bfb817 	ldw	r2,-288(fp)
 d039414:	e0ffb717 	ldw	r3,-292(fp)
 d039418:	10c4b03a 	or	r2,r2,r3
 d03941c:	e0bfb615 	stw	r2,-296(fp)
 d039420:	e0bfa143 	ldbu	r2,-379(fp)
 d039424:	10800058 	cmpnei	r2,r2,1
 d039428:	1000031e 	bne	r2,zero,d039438 <getPHYSpeed+0xb90>
 d03942c:	01000104 	movi	r4,4
 d039430:	e13fb515 	stw	r4,-300(fp)
 d039434:	00000106 	br	d03943c <getPHYSpeed+0xb94>
 d039438:	e03fb515 	stw	zero,-300(fp)
 d03943c:	e0bfb617 	ldw	r2,-296(fp)
 d039440:	e0ffb517 	ldw	r3,-300(fp)
 d039444:	10c4b03a 	or	r2,r2,r3
 d039448:	e0bfb415 	stw	r2,-304(fp)
 d03944c:	e0bfa143 	ldbu	r2,-379(fp)
 d039450:	1004c03a 	cmpne	r2,r2,zero
 d039454:	1000031e 	bne	r2,zero,d039464 <getPHYSpeed+0xbbc>
 d039458:	01000204 	movi	r4,8
 d03945c:	e13fb315 	stw	r4,-308(fp)
 d039460:	00000106 	br	d039468 <getPHYSpeed+0xbc0>
 d039464:	e03fb315 	stw	zero,-308(fp)
 d039468:	e0bfb417 	ldw	r2,-304(fp)
 d03946c:	e0ffb317 	ldw	r3,-308(fp)
 d039470:	10c4b03a 	or	r2,r2,r3
 d039474:	e0bfb215 	stw	r2,-312(fp)
 d039478:	e0bfa143 	ldbu	r2,-379(fp)
 d03947c:	108000d8 	cmpnei	r2,r2,3
 d039480:	1000031e 	bne	r2,zero,d039490 <getPHYSpeed+0xbe8>
 d039484:	01000074 	movhi	r4,1
 d039488:	e13fb115 	stw	r4,-316(fp)
 d03948c:	00000106 	br	d039494 <getPHYSpeed+0xbec>
 d039490:	e03fb115 	stw	zero,-316(fp)
 d039494:	e0ffb217 	ldw	r3,-312(fp)
 d039498:	e13fb117 	ldw	r4,-316(fp)
 d03949c:	1904b03a 	or	r2,r3,r4
 d0394a0:	108000b4 	orhi	r2,r2,2
 d0394a4:	e0bfa015 	stw	r2,-384(fp)
 d0394a8:	00004706 	br	d0395c8 <getPHYSpeed+0xd20>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 d0394ac:	e0bf9f17 	ldw	r2,-388(fp)
 d0394b0:	10800517 	ldw	r2,20(r2)
 d0394b4:	10801583 	ldbu	r2,86(r2)
 d0394b8:	11403fcc 	andi	r5,r2,255
 d0394bc:	e0bf9f17 	ldw	r2,-388(fp)
 d0394c0:	10800517 	ldw	r2,20(r2)
 d0394c4:	108015c3 	ldbu	r2,87(r2)
 d0394c8:	11803fcc 	andi	r6,r2,255
 d0394cc:	e13f9f17 	ldw	r4,-388(fp)
 d0394d0:	01c00084 	movi	r7,2
 d0394d4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d0394d8:	e0bfa145 	stb	r2,-379(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 d0394dc:	e0bf9f17 	ldw	r2,-388(fp)
 d0394e0:	10800517 	ldw	r2,20(r2)
 d0394e4:	10801583 	ldbu	r2,86(r2)
 d0394e8:	11403fcc 	andi	r5,r2,255
 d0394ec:	e0bf9f17 	ldw	r2,-388(fp)
 d0394f0:	10800517 	ldw	r2,20(r2)
 d0394f4:	10801603 	ldbu	r2,88(r2)
 d0394f8:	11803fcc 	andi	r6,r2,255
 d0394fc:	e13f9f17 	ldw	r4,-388(fp)
 d039500:	01c00044 	movi	r7,1
 d039504:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d039508:	e0bfa105 	stb	r2,-380(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 d03950c:	e0bfa103 	ldbu	r2,-380(fp)
 d039510:	1080004c 	andi	r2,r2,1
 d039514:	e0bfb015 	stw	r2,-320(fp)
 d039518:	e0bfa143 	ldbu	r2,-379(fp)
 d03951c:	10800098 	cmpnei	r2,r2,2
 d039520:	1000031e 	bne	r2,zero,d039530 <getPHYSpeed+0xc88>
 d039524:	00800084 	movi	r2,2
 d039528:	e0bfaf15 	stw	r2,-324(fp)
 d03952c:	00000106 	br	d039534 <getPHYSpeed+0xc8c>
 d039530:	e03faf15 	stw	zero,-324(fp)
 d039534:	e0ffb017 	ldw	r3,-320(fp)
 d039538:	e13faf17 	ldw	r4,-324(fp)
 d03953c:	1906b03a 	or	r3,r3,r4
 d039540:	e0ffae15 	stw	r3,-328(fp)
 d039544:	e0bfa143 	ldbu	r2,-379(fp)
 d039548:	10800058 	cmpnei	r2,r2,1
 d03954c:	1000031e 	bne	r2,zero,d03955c <getPHYSpeed+0xcb4>
 d039550:	00800104 	movi	r2,4
 d039554:	e0bfad15 	stw	r2,-332(fp)
 d039558:	00000106 	br	d039560 <getPHYSpeed+0xcb8>
 d03955c:	e03fad15 	stw	zero,-332(fp)
 d039560:	e0ffae17 	ldw	r3,-328(fp)
 d039564:	e13fad17 	ldw	r4,-332(fp)
 d039568:	1906b03a 	or	r3,r3,r4
 d03956c:	e0ffac15 	stw	r3,-336(fp)
 d039570:	e0bfa143 	ldbu	r2,-379(fp)
 d039574:	1004c03a 	cmpne	r2,r2,zero
 d039578:	1000031e 	bne	r2,zero,d039588 <getPHYSpeed+0xce0>
 d03957c:	00800204 	movi	r2,8
 d039580:	e0bfab15 	stw	r2,-340(fp)
 d039584:	00000106 	br	d03958c <getPHYSpeed+0xce4>
 d039588:	e03fab15 	stw	zero,-340(fp)
 d03958c:	e0ffac17 	ldw	r3,-336(fp)
 d039590:	e13fab17 	ldw	r4,-340(fp)
 d039594:	1906b03a 	or	r3,r3,r4
 d039598:	e0ffaa15 	stw	r3,-344(fp)
 d03959c:	e0bfa143 	ldbu	r2,-379(fp)
 d0395a0:	108000d8 	cmpnei	r2,r2,3
 d0395a4:	1000031e 	bne	r2,zero,d0395b4 <getPHYSpeed+0xd0c>
 d0395a8:	00800074 	movhi	r2,1
 d0395ac:	e0bfa915 	stw	r2,-348(fp)
 d0395b0:	00000106 	br	d0395b8 <getPHYSpeed+0xd10>
 d0395b4:	e03fa915 	stw	zero,-348(fp)
 d0395b8:	e0ffaa17 	ldw	r3,-344(fp)
 d0395bc:	e13fa917 	ldw	r4,-348(fp)
 d0395c0:	1904b03a 	or	r2,r3,r4
 d0395c4:	e0bfa015 	stw	r2,-384(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d0395c8:	e0bf9b07 	ldb	r2,-404(fp)
 d0395cc:	e0bfa815 	stw	r2,-352(fp)
 d0395d0:	e0ff9b47 	ldb	r3,-403(fp)
 d0395d4:	e0ffa715 	stw	r3,-356(fp)
 d0395d8:	e0bfa143 	ldbu	r2,-379(fp)
 d0395dc:	108000a0 	cmpeqi	r2,r2,2
 d0395e0:	1000161e 	bne	r2,zero,d03963c <getPHYSpeed+0xd94>
 d0395e4:	e0bfa143 	ldbu	r2,-379(fp)
 d0395e8:	10800060 	cmpeqi	r2,r2,1
 d0395ec:	10000d1e 	bne	r2,zero,d039624 <getPHYSpeed+0xd7c>
 d0395f0:	e0bfa143 	ldbu	r2,-379(fp)
 d0395f4:	1004c03a 	cmpne	r2,r2,zero
 d0395f8:	1000041e 	bne	r2,zero,d03960c <getPHYSpeed+0xd64>
 d0395fc:	01034174 	movhi	r4,3333
 d039600:	213fe304 	addi	r4,r4,-116
 d039604:	e13fa415 	stw	r4,-368(fp)
 d039608:	00000306 	br	d039618 <getPHYSpeed+0xd70>
 d03960c:	00834174 	movhi	r2,3333
 d039610:	10bfe404 	addi	r2,r2,-112
 d039614:	e0bfa415 	stw	r2,-368(fp)
 d039618:	e0ffa417 	ldw	r3,-368(fp)
 d03961c:	e0ffa515 	stw	r3,-364(fp)
 d039620:	00000306 	br	d039630 <getPHYSpeed+0xd88>
 d039624:	01034174 	movhi	r4,3333
 d039628:	213fe604 	addi	r4,r4,-104
 d03962c:	e13fa515 	stw	r4,-364(fp)
 d039630:	e0bfa517 	ldw	r2,-364(fp)
 d039634:	e0bfa615 	stw	r2,-360(fp)
 d039638:	00000306 	br	d039648 <getPHYSpeed+0xda0>
 d03963c:	00c34174 	movhi	r3,3333
 d039640:	18ffe704 	addi	r3,r3,-100
 d039644:	e0ffa615 	stw	r3,-360(fp)
 d039648:	e0bfa103 	ldbu	r2,-380(fp)
 d03964c:	10800058 	cmpnei	r2,r2,1
 d039650:	1000041e 	bne	r2,zero,d039664 <getPHYSpeed+0xdbc>
 d039654:	01034174 	movhi	r4,3333
 d039658:	213fe904 	addi	r4,r4,-92
 d03965c:	e13fa315 	stw	r4,-372(fp)
 d039660:	00000306 	br	d039670 <getPHYSpeed+0xdc8>
 d039664:	00834174 	movhi	r2,3333
 d039668:	10bfeb04 	addi	r2,r2,-84
 d03966c:	e0bfa315 	stw	r2,-372(fp)
 d039670:	e0ffa317 	ldw	r3,-372(fp)
 d039674:	d8c00015 	stw	r3,0(sp)
 d039678:	01034174 	movhi	r4,3333
 d03967c:	21009104 	addi	r4,r4,580
 d039680:	e17fa817 	ldw	r5,-352(fp)
 d039684:	e1bfa717 	ldw	r6,-356(fp)
 d039688:	e1ffa617 	ldw	r7,-360(fp)
 d03968c:	d0028a00 	call	d0028a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 d039690:	e13fa017 	ldw	r4,-384(fp)
 d039694:	e13feb15 	stw	r4,-84(fp)
 d039698:	e0bfeb17 	ldw	r2,-84(fp)
}
 d03969c:	e037883a 	mov	sp,fp
 d0396a0:	dfc00117 	ldw	ra,4(sp)
 d0396a4:	df000017 	ldw	fp,0(sp)
 d0396a8:	dec00204 	addi	sp,sp,8
 d0396ac:	f800283a 	ret

0d0396b0 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 d0396b0:	defffd04 	addi	sp,sp,-12
 d0396b4:	df000215 	stw	fp,8(sp)
 d0396b8:	df000204 	addi	fp,sp,8
 d0396bc:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d0396c0:	e0bfff17 	ldw	r2,-4(fp)
 d0396c4:	10800617 	ldw	r2,24(r2)
 d0396c8:	10800317 	ldw	r2,12(r2)
 d0396cc:	10800117 	ldw	r2,4(r2)
 d0396d0:	10800217 	ldw	r2,8(r2)
 d0396d4:	10800017 	ldw	r2,0(r2)
 d0396d8:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 d0396dc:	e0bffe17 	ldw	r2,-8(fp)
 d0396e0:	10801004 	addi	r2,r2,64
 d0396e4:	10800037 	ldwio	r2,0(r2)
}
 d0396e8:	e037883a 	mov	sp,fp
 d0396ec:	df000017 	ldw	fp,0(sp)
 d0396f0:	dec00104 	addi	sp,sp,4
 d0396f4:	f800283a 	ret

0d0396f8 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 d0396f8:	defffc04 	addi	sp,sp,-16
 d0396fc:	df000315 	stw	fp,12(sp)
 d039700:	df000304 	addi	fp,sp,12
 d039704:	e13ffe15 	stw	r4,-8(fp)
 d039708:	e17fff05 	stb	r5,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d03970c:	e0bffe17 	ldw	r2,-8(fp)
 d039710:	10800617 	ldw	r2,24(r2)
 d039714:	10800317 	ldw	r2,12(r2)
 d039718:	10800117 	ldw	r2,4(r2)
 d03971c:	10800217 	ldw	r2,8(r2)
 d039720:	10800017 	ldw	r2,0(r2)
 d039724:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 d039728:	e0bffd17 	ldw	r2,-12(fp)
 d03972c:	10801004 	addi	r2,r2,64
 d039730:	e0ffff03 	ldbu	r3,-4(fp)
 d039734:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 d039738:	0005883a 	mov	r2,zero
}
 d03973c:	e037883a 	mov	sp,fp
 d039740:	df000017 	ldw	fp,0(sp)
 d039744:	dec00104 	addi	sp,sp,4
 d039748:	f800283a 	ret

0d03974c <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 d03974c:	defff704 	addi	sp,sp,-36
 d039750:	df000815 	stw	fp,32(sp)
 d039754:	df000804 	addi	fp,sp,32
 d039758:	e13ffb15 	stw	r4,-20(fp)
 d03975c:	e0800117 	ldw	r2,4(fp)
 d039760:	e17ffc05 	stb	r5,-16(fp)
 d039764:	e1bffd05 	stb	r6,-12(fp)
 d039768:	e1fffe05 	stb	r7,-8(fp)
 d03976c:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d039770:	e0bffb17 	ldw	r2,-20(fp)
 d039774:	10800617 	ldw	r2,24(r2)
 d039778:	10800317 	ldw	r2,12(r2)
 d03977c:	10800117 	ldw	r2,4(r2)
 d039780:	10800217 	ldw	r2,8(r2)
 d039784:	10800017 	ldw	r2,0(r2)
 d039788:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 d03978c:	e03ffa0d 	sth	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d039790:	e03ff915 	stw	zero,-28(fp)
 d039794:	00000906 	br	d0397bc <alt_tse_phy_wr_mdio_reg+0x70>
    {
        bit_mask <<= 1;
 d039798:	e0bffa0b 	ldhu	r2,-24(fp)
 d03979c:	1085883a 	add	r2,r2,r2
 d0397a0:	e0bffa0d 	sth	r2,-24(fp)
        bit_mask |= 0x01;        
 d0397a4:	e0bffa0b 	ldhu	r2,-24(fp)
 d0397a8:	10800054 	ori	r2,r2,1
 d0397ac:	e0bffa0d 	sth	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d0397b0:	e0bff917 	ldw	r2,-28(fp)
 d0397b4:	10800044 	addi	r2,r2,1
 d0397b8:	e0bff915 	stw	r2,-28(fp)
 d0397bc:	e0fffe03 	ldbu	r3,-8(fp)
 d0397c0:	e0bff917 	ldw	r2,-28(fp)
 d0397c4:	10fff416 	blt	r2,r3,d039798 <alt_tse_phy_wr_mdio_reg+0x4c>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 d0397c8:	e0fffa0b 	ldhu	r3,-24(fp)
 d0397cc:	e0bffd03 	ldbu	r2,-12(fp)
 d0397d0:	1884983a 	sll	r2,r3,r2
 d0397d4:	e0bffa0d 	sth	r2,-24(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 d0397d8:	e0bff817 	ldw	r2,-32(fp)
 d0397dc:	1080a004 	addi	r2,r2,640
 d0397e0:	1007883a 	mov	r3,r2
 d0397e4:	e0bffc03 	ldbu	r2,-16(fp)
 d0397e8:	1085883a 	add	r2,r2,r2
 d0397ec:	1085883a 	add	r2,r2,r2
 d0397f0:	1885883a 	add	r2,r3,r2
 d0397f4:	10800037 	ldwio	r2,0(r2)
 d0397f8:	e0bffa8d 	sth	r2,-22(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 d0397fc:	e0bffa0b 	ldhu	r2,-24(fp)
 d039800:	0084303a 	nor	r2,zero,r2
 d039804:	1007883a 	mov	r3,r2
 d039808:	e0bffa8b 	ldhu	r2,-22(fp)
 d03980c:	1884703a 	and	r2,r3,r2
 d039810:	e0bffa8d 	sth	r2,-22(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 d039814:	e0ffff0b 	ldhu	r3,-4(fp)
 d039818:	e0bffd03 	ldbu	r2,-12(fp)
 d03981c:	1884983a 	sll	r2,r3,r2
 d039820:	1007883a 	mov	r3,r2
 d039824:	e0bffa0b 	ldhu	r2,-24(fp)
 d039828:	1884703a 	and	r2,r3,r2
 d03982c:	1007883a 	mov	r3,r2
 d039830:	e0bffa8b 	ldhu	r2,-22(fp)
 d039834:	1884b03a 	or	r2,r3,r2
 d039838:	e0bffa8d 	sth	r2,-22(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 d03983c:	e0bff817 	ldw	r2,-32(fp)
 d039840:	1080a004 	addi	r2,r2,640
 d039844:	1007883a 	mov	r3,r2
 d039848:	e0bffc03 	ldbu	r2,-16(fp)
 d03984c:	1085883a 	add	r2,r2,r2
 d039850:	1085883a 	add	r2,r2,r2
 d039854:	1885883a 	add	r2,r3,r2
 d039858:	e0fffa8b 	ldhu	r3,-22(fp)
 d03985c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 d039860:	0005883a 	mov	r2,zero
    
}
 d039864:	e037883a 	mov	sp,fp
 d039868:	df000017 	ldw	fp,0(sp)
 d03986c:	dec00104 	addi	sp,sp,4
 d039870:	f800283a 	ret

0d039874 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 d039874:	defff704 	addi	sp,sp,-36
 d039878:	df000815 	stw	fp,32(sp)
 d03987c:	df000804 	addi	fp,sp,32
 d039880:	e13ffc15 	stw	r4,-16(fp)
 d039884:	e17ffd05 	stb	r5,-12(fp)
 d039888:	e1bffe05 	stb	r6,-8(fp)
 d03988c:	e1ffff05 	stb	r7,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d039890:	e0bffc17 	ldw	r2,-16(fp)
 d039894:	10800617 	ldw	r2,24(r2)
 d039898:	10800317 	ldw	r2,12(r2)
 d03989c:	10800117 	ldw	r2,4(r2)
 d0398a0:	10800217 	ldw	r2,8(r2)
 d0398a4:	10800017 	ldw	r2,0(r2)
 d0398a8:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 d0398ac:	e03ffa15 	stw	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d0398b0:	e03ff915 	stw	zero,-28(fp)
 d0398b4:	00000906 	br	d0398dc <alt_tse_phy_rd_mdio_reg+0x68>
    {
        bit_mask <<= 1;
 d0398b8:	e0bffa17 	ldw	r2,-24(fp)
 d0398bc:	1085883a 	add	r2,r2,r2
 d0398c0:	e0bffa15 	stw	r2,-24(fp)
        bit_mask |= 0x01;        
 d0398c4:	e0bffa17 	ldw	r2,-24(fp)
 d0398c8:	10800054 	ori	r2,r2,1
 d0398cc:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d0398d0:	e0bff917 	ldw	r2,-28(fp)
 d0398d4:	10800044 	addi	r2,r2,1
 d0398d8:	e0bff915 	stw	r2,-28(fp)
 d0398dc:	e0ffff03 	ldbu	r3,-4(fp)
 d0398e0:	e0bff917 	ldw	r2,-28(fp)
 d0398e4:	10fff416 	blt	r2,r3,d0398b8 <alt_tse_phy_rd_mdio_reg+0x44>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 d0398e8:	e0bff817 	ldw	r2,-32(fp)
 d0398ec:	1080a004 	addi	r2,r2,640
 d0398f0:	1007883a 	mov	r3,r2
 d0398f4:	e0bffd03 	ldbu	r2,-12(fp)
 d0398f8:	1085883a 	add	r2,r2,r2
 d0398fc:	1085883a 	add	r2,r2,r2
 d039900:	1885883a 	add	r2,r3,r2
 d039904:	10800037 	ldwio	r2,0(r2)
 d039908:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 d03990c:	e0fffb0b 	ldhu	r3,-20(fp)
 d039910:	e0bffe03 	ldbu	r2,-8(fp)
 d039914:	1885d83a 	sra	r2,r3,r2
 d039918:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 d03991c:	e0fffb0b 	ldhu	r3,-20(fp)
 d039920:	e0bffa17 	ldw	r2,-24(fp)
 d039924:	1884703a 	and	r2,r3,r2
}
 d039928:	e037883a 	mov	sp,fp
 d03992c:	df000017 	ldw	fp,0(sp)
 d039930:	dec00104 	addi	sp,sp,4
 d039934:	f800283a 	ret

0d039938 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 d039938:	deff9a04 	addi	sp,sp,-408
 d03993c:	dfc06515 	stw	ra,404(sp)
 d039940:	df006415 	stw	fp,400(sp)
 d039944:	df006404 	addi	fp,sp,400
                            0x11,                   /* Location of Status Register                                   */
                            14,                     /* Location of Speed Status                                      */
                            13,                     /* Location of Duplex Status                                     */
                            10,                     /* Location of Link Status                                       */
                            &marvell_phy_cfg        /* Function pointer to configure Marvell PHY                     */
                           };
 d039948:	e13f9c04 	addi	r4,fp,-400
 d03994c:	01801904 	movi	r6,100
 d039950:	000b883a 	mov	r5,zero
 d039954:	d0027880 	call	d002788 <memset>
 d039958:	00c34174 	movhi	r3,3333
 d03995c:	18c09d04 	addi	r3,r3,628
 d039960:	18800017 	ldw	r2,0(r3)
 d039964:	e0bf9c15 	stw	r2,-400(fp)
 d039968:	18800117 	ldw	r2,4(r3)
 d03996c:	e0bf9d15 	stw	r2,-396(fp)
 d039970:	18800217 	ldw	r2,8(r3)
 d039974:	e0bf9e15 	stw	r2,-392(fp)
 d039978:	18800317 	ldw	r2,12(r3)
 d03997c:	e0bf9f15 	stw	r2,-388(fp)
 d039980:	e13fa004 	addi	r4,fp,-384
 d039984:	01801004 	movi	r6,64
 d039988:	000b883a 	mov	r5,zero
 d03998c:	d0027880 	call	d002788 <memset>
 d039990:	009410c4 	movi	r2,20547
 d039994:	e0bfb015 	stw	r2,-320(fp)
 d039998:	00800304 	movi	r2,12
 d03999c:	e0bfb105 	stb	r2,-316(fp)
 d0399a0:	00800084 	movi	r2,2
 d0399a4:	e0bfb145 	stb	r2,-315(fp)
 d0399a8:	00800444 	movi	r2,17
 d0399ac:	e0bfb185 	stb	r2,-314(fp)
 d0399b0:	00800384 	movi	r2,14
 d0399b4:	e0bfb1c5 	stb	r2,-313(fp)
 d0399b8:	00800344 	movi	r2,13
 d0399bc:	e0bfb205 	stb	r2,-312(fp)
 d0399c0:	00800284 	movi	r2,10
 d0399c4:	e0bfb245 	stb	r2,-311(fp)
 d0399c8:	00834134 	movhi	r2,3332
 d0399cc:	10b0ab04 	addi	r2,r2,-15700
 d0399d0:	e0bfb315 	stw	r2,-308(fp)
                            0x11,                            /* Location of Status Register                                   */
                            14,                              /* Location of Speed Status                                      */
                            13,                              /* Location of Duplex Status                                     */
                            10,                              /* Location of Link Status                                       */
                            &marvell_phy_cfg                 /* Function pointer to configure Marvell PHY                     */
                           };
 d0399d4:	e13fb504 	addi	r4,fp,-300
 d0399d8:	01801904 	movi	r6,100
 d0399dc:	000b883a 	mov	r5,zero
 d0399e0:	d0027880 	call	d002788 <memset>
 d0399e4:	00c34174 	movhi	r3,3333
 d0399e8:	18c0b104 	addi	r3,r3,708
 d0399ec:	18800017 	ldw	r2,0(r3)
 d0399f0:	e0bfb515 	stw	r2,-300(fp)
 d0399f4:	18800117 	ldw	r2,4(r3)
 d0399f8:	e0bfb615 	stw	r2,-296(fp)
 d0399fc:	18800217 	ldw	r2,8(r3)
 d039a00:	e0bfb715 	stw	r2,-292(fp)
 d039a04:	18800317 	ldw	r2,12(r3)
 d039a08:	e0bfb815 	stw	r2,-288(fp)
 d039a0c:	18800417 	ldw	r2,16(r3)
 d039a10:	e0bfb915 	stw	r2,-284(fp)
 d039a14:	18800517 	ldw	r2,20(r3)
 d039a18:	e0bfba15 	stw	r2,-280(fp)
 d039a1c:	18800603 	ldbu	r2,24(r3)
 d039a20:	e0bfbb05 	stb	r2,-276(fp)
 d039a24:	e13fbb44 	addi	r4,fp,-275
 d039a28:	01800dc4 	movi	r6,55
 d039a2c:	000b883a 	mov	r5,zero
 d039a30:	d0027880 	call	d002788 <memset>
 d039a34:	009410c4 	movi	r2,20547
 d039a38:	e0bfc915 	stw	r2,-220(fp)
 d039a3c:	00800344 	movi	r2,13
 d039a40:	e0bfca05 	stb	r2,-216(fp)
 d039a44:	00800084 	movi	r2,2
 d039a48:	e0bfca45 	stb	r2,-215(fp)
 d039a4c:	00800444 	movi	r2,17
 d039a50:	e0bfca85 	stb	r2,-214(fp)
 d039a54:	00800384 	movi	r2,14
 d039a58:	e0bfcac5 	stb	r2,-213(fp)
 d039a5c:	00800344 	movi	r2,13
 d039a60:	e0bfcb05 	stb	r2,-212(fp)
 d039a64:	00800284 	movi	r2,10
 d039a68:	e0bfcb45 	stb	r2,-211(fp)
 d039a6c:	00834134 	movhi	r2,3332
 d039a70:	10b0ab04 	addi	r2,r2,-15700
 d039a74:	e0bfcc15 	stw	r2,-208(fp)
                          DP83865_REV,            /* Model Revision Number                            */
                          0x11,                   /* Location of Status Register                      */
                          3,                      /* Location of Speed Status                         */
                          1,                      /* Location of Duplex Status                        */
                          2                       /* Location of Link Status                          */
                         };
 d039a78:	e13fce04 	addi	r4,fp,-200
 d039a7c:	01801904 	movi	r6,100
 d039a80:	000b883a 	mov	r5,zero
 d039a84:	d0027880 	call	d002788 <memset>
 d039a88:	00c34174 	movhi	r3,3333
 d039a8c:	18c0c504 	addi	r3,r3,788
 d039a90:	18800017 	ldw	r2,0(r3)
 d039a94:	e0bfce15 	stw	r2,-200(fp)
 d039a98:	18800117 	ldw	r2,4(r3)
 d039a9c:	e0bfcf15 	stw	r2,-196(fp)
 d039aa0:	18800217 	ldw	r2,8(r3)
 d039aa4:	e0bfd015 	stw	r2,-192(fp)
 d039aa8:	18800317 	ldw	r2,12(r3)
 d039aac:	e0bfd115 	stw	r2,-188(fp)
 d039ab0:	18800403 	ldbu	r2,16(r3)
 d039ab4:	e0bfd205 	stb	r2,-184(fp)
 d039ab8:	e13fd244 	addi	r4,fp,-183
 d039abc:	01800fc4 	movi	r6,63
 d039ac0:	000b883a 	mov	r5,zero
 d039ac4:	d0027880 	call	d002788 <memset>
 d039ac8:	00800234 	movhi	r2,8
 d039acc:	108005c4 	addi	r2,r2,23
 d039ad0:	e0bfe215 	stw	r2,-120(fp)
 d039ad4:	008001c4 	movi	r2,7
 d039ad8:	e0bfe305 	stb	r2,-116(fp)
 d039adc:	00800284 	movi	r2,10
 d039ae0:	e0bfe345 	stb	r2,-115(fp)
 d039ae4:	00800444 	movi	r2,17
 d039ae8:	e0bfe385 	stb	r2,-114(fp)
 d039aec:	008000c4 	movi	r2,3
 d039af0:	e0bfe3c5 	stb	r2,-113(fp)
 d039af4:	00800044 	movi	r2,1
 d039af8:	e0bfe405 	stb	r2,-112(fp)
 d039afc:	00800084 	movi	r2,2
 d039b00:	e0bfe445 	stb	r2,-111(fp)
                           0,                              /* Location of Speed Status    (ignored)                      */
                           0,                              /* Location of Duplex Status   (ignored)                      */
                           0,                              /* Location of Link Status     (ignored)                      */
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
 d039b04:	e13fe704 	addi	r4,fp,-100
 d039b08:	01801904 	movi	r6,100
 d039b0c:	000b883a 	mov	r5,zero
 d039b10:	d0027880 	call	d002788 <memset>
 d039b14:	00c34174 	movhi	r3,3333
 d039b18:	18c0d904 	addi	r3,r3,868
 d039b1c:	18800017 	ldw	r2,0(r3)
 d039b20:	e0bfe715 	stw	r2,-100(fp)
 d039b24:	18800117 	ldw	r2,4(r3)
 d039b28:	e0bfe815 	stw	r2,-96(fp)
 d039b2c:	18800217 	ldw	r2,8(r3)
 d039b30:	e0bfe915 	stw	r2,-92(fp)
 d039b34:	18800317 	ldw	r2,12(r3)
 d039b38:	e0bfea15 	stw	r2,-88(fp)
 d039b3c:	1880040b 	ldhu	r2,16(r3)
 d039b40:	e0bfeb0d 	sth	r2,-84(fp)
 d039b44:	e13feb84 	addi	r4,fp,-82
 d039b48:	01800f84 	movi	r6,62
 d039b4c:	000b883a 	mov	r5,zero
 d039b50:	d0027880 	call	d002788 <memset>
 d039b54:	00800234 	movhi	r2,8
 d039b58:	108005c4 	addi	r2,r2,23
 d039b5c:	e0bffb15 	stw	r2,-20(fp)
 d039b60:	00800244 	movi	r2,9
 d039b64:	e0bffc05 	stb	r2,-16(fp)
 d039b68:	00834134 	movhi	r2,3332
 d039b6c:	10b18f04 	addi	r2,r2,-14788
 d039b70:	e0bfff15 	stw	r2,-4(fp)
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 d039b74:	e13f9c04 	addi	r4,fp,-400
 d039b78:	d0375e80 	call	d0375e8 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 d039b7c:	e13fb504 	addi	r4,fp,-300
 d039b80:	d0375e80 	call	d0375e8 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 d039b84:	e13fce04 	addi	r4,fp,-200
 d039b88:	d0375e80 	call	d0375e8 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 d039b8c:	e13fe704 	addi	r4,fp,-100
 d039b90:	d0375e80 	call	d0375e8 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 d039b94:	d0a93803 	ldbu	r2,-23328(gp)
 d039b98:	10803fcc 	andi	r2,r2,255
}
 d039b9c:	e037883a 	mov	sp,fp
 d039ba0:	dfc00117 	ldw	ra,4(sp)
 d039ba4:	df000017 	ldw	fp,0(sp)
 d039ba8:	dec00204 	addi	sp,sp,8
 d039bac:	f800283a 	ret

0d039bb0 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 d039bb0:	defffd04 	addi	sp,sp,-12
 d039bb4:	dfc00215 	stw	ra,8(sp)
 d039bb8:	df000115 	stw	fp,4(sp)
 d039bbc:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 d039bc0:	d0a93803 	ldbu	r2,-23328(gp)
 d039bc4:	11403fcc 	andi	r5,r2,255
 d039bc8:	01034174 	movhi	r4,3333
 d039bcc:	2100ed04 	addi	r4,r4,948
 d039bd0:	d0372880 	call	d037288 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 d039bd4:	e03fff05 	stb	zero,-4(fp)
 d039bd8:	00006606 	br	d039d74 <alt_tse_phy_print_profile+0x1c4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 d039bdc:	e17fff07 	ldb	r5,-4(fp)
 d039be0:	01034174 	movhi	r4,3333
 d039be4:	2100fc04 	addi	r4,r4,1008
 d039be8:	d0372880 	call	d037288 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 d039bec:	e0bfff07 	ldb	r2,-4(fp)
 d039bf0:	00c341b4 	movhi	r3,3334
 d039bf4:	18c50604 	addi	r3,r3,5144
 d039bf8:	1085883a 	add	r2,r2,r2
 d039bfc:	1085883a 	add	r2,r2,r2
 d039c00:	10c5883a 	add	r2,r2,r3
 d039c04:	10800017 	ldw	r2,0(r2)
 d039c08:	100b883a 	mov	r5,r2
 d039c0c:	01034174 	movhi	r4,3333
 d039c10:	21010104 	addi	r4,r4,1028
 d039c14:	d0372880 	call	d037288 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 d039c18:	e0bfff07 	ldb	r2,-4(fp)
 d039c1c:	00c341b4 	movhi	r3,3334
 d039c20:	18c50604 	addi	r3,r3,5144
 d039c24:	1085883a 	add	r2,r2,r2
 d039c28:	1085883a 	add	r2,r2,r2
 d039c2c:	10c5883a 	add	r2,r2,r3
 d039c30:	10800017 	ldw	r2,0(r2)
 d039c34:	10801417 	ldw	r2,80(r2)
 d039c38:	100b883a 	mov	r5,r2
 d039c3c:	01034174 	movhi	r4,3333
 d039c40:	21010704 	addi	r4,r4,1052
 d039c44:	d0372880 	call	d037288 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 d039c48:	e0bfff07 	ldb	r2,-4(fp)
 d039c4c:	00c341b4 	movhi	r3,3334
 d039c50:	18c50604 	addi	r3,r3,5144
 d039c54:	1085883a 	add	r2,r2,r2
 d039c58:	1085883a 	add	r2,r2,r2
 d039c5c:	10c5883a 	add	r2,r2,r3
 d039c60:	10800017 	ldw	r2,0(r2)
 d039c64:	10801503 	ldbu	r2,84(r2)
 d039c68:	11403fcc 	andi	r5,r2,255
 d039c6c:	01034174 	movhi	r4,3333
 d039c70:	21010e04 	addi	r4,r4,1080
 d039c74:	d0372880 	call	d037288 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 d039c78:	e0bfff07 	ldb	r2,-4(fp)
 d039c7c:	00c341b4 	movhi	r3,3334
 d039c80:	18c50604 	addi	r3,r3,5144
 d039c84:	1085883a 	add	r2,r2,r2
 d039c88:	1085883a 	add	r2,r2,r2
 d039c8c:	10c5883a 	add	r2,r2,r3
 d039c90:	10800017 	ldw	r2,0(r2)
 d039c94:	10801543 	ldbu	r2,85(r2)
 d039c98:	11403fcc 	andi	r5,r2,255
 d039c9c:	01034174 	movhi	r4,3333
 d039ca0:	21011504 	addi	r4,r4,1108
 d039ca4:	d0372880 	call	d037288 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 d039ca8:	e0bfff07 	ldb	r2,-4(fp)
 d039cac:	00c341b4 	movhi	r3,3334
 d039cb0:	18c50604 	addi	r3,r3,5144
 d039cb4:	1085883a 	add	r2,r2,r2
 d039cb8:	1085883a 	add	r2,r2,r2
 d039cbc:	10c5883a 	add	r2,r2,r3
 d039cc0:	10800017 	ldw	r2,0(r2)
 d039cc4:	10801583 	ldbu	r2,86(r2)
 d039cc8:	11403fcc 	andi	r5,r2,255
 d039ccc:	01034174 	movhi	r4,3333
 d039cd0:	21011c04 	addi	r4,r4,1136
 d039cd4:	d0372880 	call	d037288 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 d039cd8:	e0bfff07 	ldb	r2,-4(fp)
 d039cdc:	00c341b4 	movhi	r3,3334
 d039ce0:	18c50604 	addi	r3,r3,5144
 d039ce4:	1085883a 	add	r2,r2,r2
 d039ce8:	1085883a 	add	r2,r2,r2
 d039cec:	10c5883a 	add	r2,r2,r3
 d039cf0:	10800017 	ldw	r2,0(r2)
 d039cf4:	108015c3 	ldbu	r2,87(r2)
 d039cf8:	11403fcc 	andi	r5,r2,255
 d039cfc:	01034174 	movhi	r4,3333
 d039d00:	21012304 	addi	r4,r4,1164
 d039d04:	d0372880 	call	d037288 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 d039d08:	e0bfff07 	ldb	r2,-4(fp)
 d039d0c:	00c341b4 	movhi	r3,3334
 d039d10:	18c50604 	addi	r3,r3,5144
 d039d14:	1085883a 	add	r2,r2,r2
 d039d18:	1085883a 	add	r2,r2,r2
 d039d1c:	10c5883a 	add	r2,r2,r3
 d039d20:	10800017 	ldw	r2,0(r2)
 d039d24:	10801603 	ldbu	r2,88(r2)
 d039d28:	11403fcc 	andi	r5,r2,255
 d039d2c:	01034174 	movhi	r4,3333
 d039d30:	21012904 	addi	r4,r4,1188
 d039d34:	d0372880 	call	d037288 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 d039d38:	e0bfff07 	ldb	r2,-4(fp)
 d039d3c:	00c341b4 	movhi	r3,3334
 d039d40:	18c50604 	addi	r3,r3,5144
 d039d44:	1085883a 	add	r2,r2,r2
 d039d48:	1085883a 	add	r2,r2,r2
 d039d4c:	10c5883a 	add	r2,r2,r3
 d039d50:	10800017 	ldw	r2,0(r2)
 d039d54:	10801643 	ldbu	r2,89(r2)
 d039d58:	11403fcc 	andi	r5,r2,255
 d039d5c:	01034174 	movhi	r4,3333
 d039d60:	21012f04 	addi	r4,r4,1212
 d039d64:	d0372880 	call	d037288 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 d039d68:	e0bfff03 	ldbu	r2,-4(fp)
 d039d6c:	10800044 	addi	r2,r2,1
 d039d70:	e0bfff05 	stb	r2,-4(fp)
 d039d74:	e0bfff07 	ldb	r2,-4(fp)
 d039d78:	d0e93803 	ldbu	r3,-23328(gp)
 d039d7c:	18c03fcc 	andi	r3,r3,255
 d039d80:	10ff9616 	blt	r2,r3,d039bdc <alt_tse_phy_print_profile+0x2c>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 d039d84:	d0a93803 	ldbu	r2,-23328(gp)
 d039d88:	10803fcc 	andi	r2,r2,255
}
 d039d8c:	e037883a 	mov	sp,fp
 d039d90:	dfc00117 	ldw	ra,4(sp)
 d039d94:	df000017 	ldw	fp,0(sp)
 d039d98:	dec00204 	addi	sp,sp,8
 d039d9c:	f800283a 	ret

0d039da0 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 d039da0:	defff104 	addi	sp,sp,-60
 d039da4:	dfc00e15 	stw	ra,56(sp)
 d039da8:	df000d15 	stw	fp,52(sp)
 d039dac:	df000d04 	addi	fp,sp,52
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 d039db0:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 d039db4:	e03ff415 	stw	zero,-48(fp)
    alt_tse_system_info *psys = 0;
 d039db8:	e03ff315 	stw	zero,-52(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 d039dbc:	d0293845 	stb	zero,-23327(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 d039dc0:	e03ff645 	stb	zero,-39(fp)
 d039dc4:	0001b106 	br	d03a48c <alt_tse_mac_group_init+0x6ec>
        psys = &tse_mac_device[i];
 d039dc8:	e13ff647 	ldb	r4,-39(fp)
 d039dcc:	01401204 	movi	r5,72
 d039dd0:	d00235c0 	call	d00235c <__mulsi3>
 d039dd4:	1007883a 	mov	r3,r2
 d039dd8:	00834174 	movhi	r2,3333
 d039ddc:	1089fc04 	addi	r2,r2,10224
 d039de0:	1885883a 	add	r2,r3,r2
 d039de4:	e0bff315 	stw	r2,-52(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 d039de8:	e0bff317 	ldw	r2,-52(fp)
 d039dec:	10800517 	ldw	r2,20(r2)
 d039df0:	1005003a 	cmpeq	r2,r2,zero
 d039df4:	1001a21e 	bne	r2,zero,d03a480 <alt_tse_mac_group_init+0x6e0>
 d039df8:	e0bff317 	ldw	r2,-52(fp)
 d039dfc:	10800617 	ldw	r2,24(r2)
 d039e00:	1005003a 	cmpeq	r2,r2,zero
 d039e04:	10019e1e 	bne	r2,zero,d03a480 <alt_tse_mac_group_init+0x6e0>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 d039e08:	d0a93843 	ldbu	r2,-23327(gp)
 d039e0c:	11403fcc 	andi	r5,r2,255
 d039e10:	e0bff317 	ldw	r2,-52(fp)
 d039e14:	10800017 	ldw	r2,0(r2)
 d039e18:	100d883a 	mov	r6,r2
 d039e1c:	01034174 	movhi	r4,3333
 d039e20:	21013504 	addi	r4,r4,1236
 d039e24:	d0028a00 	call	d0028a0 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 d039e28:	01000504 	movi	r4,20
 d039e2c:	d04be300 	call	d04be30 <malloc>
 d039e30:	e0bff515 	stw	r2,-44(fp)
            if(!pmac_group) {
 d039e34:	e0bff517 	ldw	r2,-44(fp)
 d039e38:	1004c03a 	cmpne	r2,r2,zero
 d039e3c:	1000081e 	bne	r2,zero,d039e60 <alt_tse_mac_group_init+0xc0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 d039e40:	d0a93843 	ldbu	r2,-23327(gp)
 d039e44:	11403fcc 	andi	r5,r2,255
 d039e48:	01034174 	movhi	r4,3333
 d039e4c:	21014104 	addi	r4,r4,1284
 d039e50:	d0028a00 	call	d0028a0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 d039e54:	00bfffc4 	movi	r2,-1
 d039e58:	e0bfff15 	stw	r2,-4(fp)
 d039e5c:	00019006 	br	d03a4a0 <alt_tse_mac_group_init+0x700>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 d039e60:	e0bff317 	ldw	r2,-52(fp)
 d039e64:	108002c3 	ldbu	r2,11(r2)
 d039e68:	10803fcc 	andi	r2,r2,255
 d039e6c:	1005003a 	cmpeq	r2,r2,zero
 d039e70:	1000111e 	bne	r2,zero,d039eb8 <alt_tse_mac_group_init+0x118>
                pmac_group->channel = psys->tse_num_of_channel;
 d039e74:	e0bff317 	ldw	r2,-52(fp)
 d039e78:	10c00303 	ldbu	r3,12(r2)
 d039e7c:	e0bff517 	ldw	r2,-44(fp)
 d039e80:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 d039e84:	01034174 	movhi	r4,3333
 d039e88:	21014f04 	addi	r4,r4,1340
 d039e8c:	d0372880 	call	d037288 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 d039e90:	e0bff517 	ldw	r2,-44(fp)
 d039e94:	10800003 	ldbu	r2,0(r2)
 d039e98:	11403fcc 	andi	r5,r2,255
 d039e9c:	01034174 	movhi	r4,3333
 d039ea0:	21015a04 	addi	r4,r4,1384
 d039ea4:	d0372880 	call	d037288 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 d039ea8:	01034174 	movhi	r4,3333
 d039eac:	21016504 	addi	r4,r4,1428
 d039eb0:	d0372880 	call	d037288 <no_printf>
 d039eb4:	00001f06 	br	d039f34 <alt_tse_mac_group_init+0x194>
            }
            else if(psys->tse_mdio_shared) {
 d039eb8:	e0bff317 	ldw	r2,-52(fp)
 d039ebc:	10800343 	ldbu	r2,13(r2)
 d039ec0:	10803fcc 	andi	r2,r2,255
 d039ec4:	1005003a 	cmpeq	r2,r2,zero
 d039ec8:	1000111e 	bne	r2,zero,d039f10 <alt_tse_mac_group_init+0x170>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 d039ecc:	e0bff317 	ldw	r2,-52(fp)
 d039ed0:	10c00383 	ldbu	r3,14(r2)
 d039ed4:	e0bff517 	ldw	r2,-44(fp)
 d039ed8:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 d039edc:	01034174 	movhi	r4,3333
 d039ee0:	21017004 	addi	r4,r4,1472
 d039ee4:	d0372880 	call	d037288 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 d039ee8:	01034174 	movhi	r4,3333
 d039eec:	21016504 	addi	r4,r4,1428
 d039ef0:	d0372880 	call	d037288 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 d039ef4:	e0bff517 	ldw	r2,-44(fp)
 d039ef8:	10800003 	ldbu	r2,0(r2)
 d039efc:	11403fcc 	andi	r5,r2,255
 d039f00:	01034174 	movhi	r4,3333
 d039f04:	21017b04 	addi	r4,r4,1516
 d039f08:	d0372880 	call	d037288 <no_printf>
 d039f0c:	00000906 	br	d039f34 <alt_tse_mac_group_init+0x194>
            }
            else {
                pmac_group->channel = 1;
 d039f10:	e0fff517 	ldw	r3,-44(fp)
 d039f14:	00800044 	movi	r2,1
 d039f18:	18800005 	stb	r2,0(r3)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 d039f1c:	01034174 	movhi	r4,3333
 d039f20:	21017004 	addi	r4,r4,1472
 d039f24:	d0372880 	call	d037288 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 d039f28:	01034174 	movhi	r4,3333
 d039f2c:	21018604 	addi	r4,r4,1560
 d039f30:	d0372880 	call	d037288 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 d039f34:	e03ff605 	stb	zero,-40(fp)
 d039f38:	00013a06 	br	d03a424 <alt_tse_mac_group_init+0x684>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 d039f3c:	01000404 	movi	r4,16
 d039f40:	d04be300 	call	d04be30 <malloc>
 d039f44:	e0bff415 	stw	r2,-48(fp)
                if(!pmac_info) {
 d039f48:	e0bff417 	ldw	r2,-48(fp)
 d039f4c:	1004c03a 	cmpne	r2,r2,zero
 d039f50:	1000091e 	bne	r2,zero,d039f78 <alt_tse_mac_group_init+0x1d8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 d039f54:	d0a93843 	ldbu	r2,-23327(gp)
 d039f58:	11403fcc 	andi	r5,r2,255
 d039f5c:	e1bff607 	ldb	r6,-40(fp)
 d039f60:	01034174 	movhi	r4,3333
 d039f64:	21019104 	addi	r4,r4,1604
 d039f68:	d0028a00 	call	d0028a0 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 d039f6c:	00ffffc4 	movi	r3,-1
 d039f70:	e0ffff15 	stw	r3,-4(fp)
 d039f74:	00014a06 	br	d03a4a0 <alt_tse_mac_group_init+0x700>
                }
                
                pmac_info->pmac_group = pmac_group;
 d039f78:	e0fff417 	ldw	r3,-48(fp)
 d039f7c:	e0bff517 	ldw	r2,-44(fp)
 d039f80:	18800315 	stw	r2,12(r3)
                
                pmac_info->pphy_info = 0;
 d039f84:	e0bff417 	ldw	r2,-48(fp)
 d039f88:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 d039f8c:	e0fff647 	ldb	r3,-39(fp)
 d039f90:	e0bff607 	ldb	r2,-40(fp)
 d039f94:	1885883a 	add	r2,r3,r2
 d039f98:	1009883a 	mov	r4,r2
 d039f9c:	01401204 	movi	r5,72
 d039fa0:	d00235c0 	call	d00235c <__mulsi3>
 d039fa4:	1007883a 	mov	r3,r2
 d039fa8:	00834174 	movhi	r2,3333
 d039fac:	1089fc04 	addi	r2,r2,10224
 d039fb0:	1887883a 	add	r3,r3,r2
 d039fb4:	e0bff417 	ldw	r2,-48(fp)
 d039fb8:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 d039fbc:	e0bff417 	ldw	r2,-48(fp)
 d039fc0:	10800217 	ldw	r2,8(r2)
 d039fc4:	10800517 	ldw	r2,20(r2)
 d039fc8:	1005003a 	cmpeq	r2,r2,zero
 d039fcc:	1000051e 	bne	r2,zero,d039fe4 <alt_tse_mac_group_init+0x244>
 d039fd0:	e0bff417 	ldw	r2,-48(fp)
 d039fd4:	10800217 	ldw	r2,8(r2)
 d039fd8:	10800617 	ldw	r2,24(r2)
 d039fdc:	1004c03a 	cmpne	r2,r2,zero
 d039fe0:	1000091e 	bne	r2,zero,d03a008 <alt_tse_mac_group_init+0x268>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 d039fe4:	e0bff647 	ldb	r2,-39(fp)
 d039fe8:	e0fff607 	ldb	r3,-40(fp)
 d039fec:	10cb883a 	add	r5,r2,r3
 d039ff0:	01034174 	movhi	r4,3333
 d039ff4:	2101a304 	addi	r4,r4,1676
 d039ff8:	d0028a00 	call	d0028a0 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d039ffc:	00bfffc4 	movi	r2,-1
 d03a000:	e0bfff15 	stw	r2,-4(fp)
 d03a004:	00012606 	br	d03a4a0 <alt_tse_mac_group_init+0x700>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 d03a008:	e0bff417 	ldw	r2,-48(fp)
 d03a00c:	10800217 	ldw	r2,8(r2)
 d03a010:	10800243 	ldbu	r2,9(r2)
 d03a014:	10803fcc 	andi	r2,r2,255
 d03a018:	1005003a 	cmpeq	r2,r2,zero
 d03a01c:	10000e1e 	bne	r2,zero,d03a058 <alt_tse_mac_group_init+0x2b8>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 d03a020:	e0bff417 	ldw	r2,-48(fp)
 d03a024:	10800217 	ldw	r2,8(r2)
 d03a028:	10800283 	ldbu	r2,10(r2)
 d03a02c:	10803fcc 	andi	r2,r2,255
 d03a030:	1005003a 	cmpeq	r2,r2,zero
 d03a034:	1000041e 	bne	r2,zero,d03a048 <alt_tse_mac_group_init+0x2a8>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 d03a038:	e0fff417 	ldw	r3,-48(fp)
 d03a03c:	00800084 	movi	r2,2
 d03a040:	18800005 	stb	r2,0(r3)
 d03a044:	00000606 	br	d03a060 <alt_tse_mac_group_init+0x2c0>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 d03a048:	e0fff417 	ldw	r3,-48(fp)
 d03a04c:	00800044 	movi	r2,1
 d03a050:	18800005 	stb	r2,0(r3)
 d03a054:	00000206 	br	d03a060 <alt_tse_mac_group_init+0x2c0>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 d03a058:	e0bff417 	ldw	r2,-48(fp)
 d03a05c:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 d03a060:	e0bff417 	ldw	r2,-48(fp)
 d03a064:	10800217 	ldw	r2,8(r2)
 d03a068:	10800343 	ldbu	r2,13(r2)
 d03a06c:	10803fcc 	andi	r2,r2,255
 d03a070:	1005003a 	cmpeq	r2,r2,zero
 d03a074:	10006d1e 	bne	r2,zero,d03a22c <alt_tse_mac_group_init+0x48c>
 d03a078:	e0bff417 	ldw	r2,-48(fp)
 d03a07c:	10800217 	ldw	r2,8(r2)
 d03a080:	108002c3 	ldbu	r2,11(r2)
 d03a084:	10803fcc 	andi	r2,r2,255
 d03a088:	1004c03a 	cmpne	r2,r2,zero
 d03a08c:	1000671e 	bne	r2,zero,d03a22c <alt_tse_mac_group_init+0x48c>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 d03a090:	e17ff607 	ldb	r5,-40(fp)
 d03a094:	e0bff417 	ldw	r2,-48(fp)
 d03a098:	10800217 	ldw	r2,8(r2)
 d03a09c:	10800017 	ldw	r2,0(r2)
 d03a0a0:	100d883a 	mov	r6,r2
 d03a0a4:	01034174 	movhi	r4,3333
 d03a0a8:	2101b204 	addi	r4,r4,1736
 d03a0ac:	d0372880 	call	d037288 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 d03a0b0:	e17ff607 	ldb	r5,-40(fp)
 d03a0b4:	e0fff647 	ldb	r3,-39(fp)
 d03a0b8:	e0bff607 	ldb	r2,-40(fp)
 d03a0bc:	188d883a 	add	r6,r3,r2
 d03a0c0:	01034174 	movhi	r4,3333
 d03a0c4:	2101be04 	addi	r4,r4,1784
 d03a0c8:	d0372880 	call	d037288 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 d03a0cc:	e0bff417 	ldw	r2,-48(fp)
 d03a0d0:	10800003 	ldbu	r2,0(r2)
 d03a0d4:	10803fcc 	andi	r2,r2,255
 d03a0d8:	e0bffe15 	stw	r2,-8(fp)
 d03a0dc:	e0fffe17 	ldw	r3,-8(fp)
 d03a0e0:	18800060 	cmpeqi	r2,r3,1
 d03a0e4:	10000e1e 	bne	r2,zero,d03a120 <alt_tse_mac_group_init+0x380>
 d03a0e8:	e0fffe17 	ldw	r3,-8(fp)
 d03a0ec:	188000a0 	cmpeqi	r2,r3,2
 d03a0f0:	1000041e 	bne	r2,zero,d03a104 <alt_tse_mac_group_init+0x364>
 d03a0f4:	e0fffe17 	ldw	r3,-8(fp)
 d03a0f8:	1805003a 	cmpeq	r2,r3,zero
 d03a0fc:	10000f1e 	bne	r2,zero,d03a13c <alt_tse_mac_group_init+0x39c>
 d03a100:	00001506 	br	d03a158 <alt_tse_mac_group_init+0x3b8>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 d03a104:	e17ff607 	ldb	r5,-40(fp)
 d03a108:	01034174 	movhi	r4,3333
 d03a10c:	2101cd04 	addi	r4,r4,1844
 d03a110:	01834174 	movhi	r6,3333
 d03a114:	3181d804 	addi	r6,r6,1888
 d03a118:	d0372880 	call	d037288 <no_printf>
                            break;
 d03a11c:	00001406 	br	d03a170 <alt_tse_mac_group_init+0x3d0>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 d03a120:	e17ff607 	ldb	r5,-40(fp)
 d03a124:	01034174 	movhi	r4,3333
 d03a128:	2101cd04 	addi	r4,r4,1844
 d03a12c:	01834174 	movhi	r6,3333
 d03a130:	3181dd04 	addi	r6,r6,1908
 d03a134:	d0372880 	call	d037288 <no_printf>
                            break;
 d03a138:	00000d06 	br	d03a170 <alt_tse_mac_group_init+0x3d0>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 d03a13c:	e17ff607 	ldb	r5,-40(fp)
 d03a140:	01034174 	movhi	r4,3333
 d03a144:	2101cd04 	addi	r4,r4,1844
 d03a148:	01834174 	movhi	r6,3333
 d03a14c:	3181e304 	addi	r6,r6,1932
 d03a150:	d0372880 	call	d037288 <no_printf>
                            break;
 d03a154:	00000606 	br	d03a170 <alt_tse_mac_group_init+0x3d0>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 d03a158:	e17ff607 	ldb	r5,-40(fp)
 d03a15c:	01034174 	movhi	r4,3333
 d03a160:	2101cd04 	addi	r4,r4,1844
 d03a164:	01834174 	movhi	r6,3333
 d03a168:	31bfe404 	addi	r6,r6,-112
 d03a16c:	d0372880 	call	d037288 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 d03a170:	e0bff417 	ldw	r2,-48(fp)
 d03a174:	10800217 	ldw	r2,8(r2)
 d03a178:	108003c3 	ldbu	r2,15(r2)
 d03a17c:	10803fcc 	andi	r2,r2,255
 d03a180:	1005003a 	cmpeq	r2,r2,zero
 d03a184:	10009c1e 	bne	r2,zero,d03a3f8 <alt_tse_mac_group_init+0x658>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 d03a188:	e0bff607 	ldb	r2,-40(fp)
 d03a18c:	e0bffd15 	stw	r2,-12(fp)
 d03a190:	e0bff417 	ldw	r2,-48(fp)
 d03a194:	10800217 	ldw	r2,8(r2)
 d03a198:	108003c3 	ldbu	r2,15(r2)
 d03a19c:	10803fcc 	andi	r2,r2,255
 d03a1a0:	1005003a 	cmpeq	r2,r2,zero
 d03a1a4:	1000041e 	bne	r2,zero,d03a1b8 <alt_tse_mac_group_init+0x418>
 d03a1a8:	00c34174 	movhi	r3,3333
 d03a1ac:	18c1ea04 	addi	r3,r3,1960
 d03a1b0:	e0fffc15 	stw	r3,-16(fp)
 d03a1b4:	00000306 	br	d03a1c4 <alt_tse_mac_group_init+0x424>
 d03a1b8:	00834174 	movhi	r2,3333
 d03a1bc:	1081eb04 	addi	r2,r2,1964
 d03a1c0:	e0bffc15 	stw	r2,-16(fp)
 d03a1c4:	01034174 	movhi	r4,3333
 d03a1c8:	2101ec04 	addi	r4,r4,1968
 d03a1cc:	e17ffd17 	ldw	r5,-12(fp)
 d03a1d0:	e1bffc17 	ldw	r6,-16(fp)
 d03a1d4:	d0372880 	call	d037288 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 d03a1d8:	e0fff607 	ldb	r3,-40(fp)
 d03a1dc:	e0fffb15 	stw	r3,-20(fp)
 d03a1e0:	e0bff417 	ldw	r2,-48(fp)
 d03a1e4:	10800217 	ldw	r2,8(r2)
 d03a1e8:	10800403 	ldbu	r2,16(r2)
 d03a1ec:	10803fcc 	andi	r2,r2,255
 d03a1f0:	1005003a 	cmpeq	r2,r2,zero
 d03a1f4:	1000041e 	bne	r2,zero,d03a208 <alt_tse_mac_group_init+0x468>
 d03a1f8:	00834174 	movhi	r2,3333
 d03a1fc:	1081ea04 	addi	r2,r2,1960
 d03a200:	e0bffa15 	stw	r2,-24(fp)
 d03a204:	00000306 	br	d03a214 <alt_tse_mac_group_init+0x474>
 d03a208:	00c34174 	movhi	r3,3333
 d03a20c:	18c1eb04 	addi	r3,r3,1964
 d03a210:	e0fffa15 	stw	r3,-24(fp)
 d03a214:	01034174 	movhi	r4,3333
 d03a218:	2101f704 	addi	r4,r4,2012
 d03a21c:	e17ffb17 	ldw	r5,-20(fp)
 d03a220:	e1bffa17 	ldw	r6,-24(fp)
 d03a224:	d0372880 	call	d037288 <no_printf>
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 d03a228:	00007306 	br	d03a3f8 <alt_tse_mac_group_init+0x658>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 d03a22c:	e0bff607 	ldb	r2,-40(fp)
 d03a230:	1004c03a 	cmpne	r2,r2,zero
 d03a234:	10004d1e 	bne	r2,zero,d03a36c <alt_tse_mac_group_init+0x5cc>
	                    switch(pmac_info->mac_type) {
 d03a238:	e0bff417 	ldw	r2,-48(fp)
 d03a23c:	10800003 	ldbu	r2,0(r2)
 d03a240:	10803fcc 	andi	r2,r2,255
 d03a244:	e0bff915 	stw	r2,-28(fp)
 d03a248:	e0fff917 	ldw	r3,-28(fp)
 d03a24c:	18800060 	cmpeqi	r2,r3,1
 d03a250:	10000d1e 	bne	r2,zero,d03a288 <alt_tse_mac_group_init+0x4e8>
 d03a254:	e0fff917 	ldw	r3,-28(fp)
 d03a258:	188000a0 	cmpeqi	r2,r3,2
 d03a25c:	1000041e 	bne	r2,zero,d03a270 <alt_tse_mac_group_init+0x4d0>
 d03a260:	e0fff917 	ldw	r3,-28(fp)
 d03a264:	1805003a 	cmpeq	r2,r3,zero
 d03a268:	10000d1e 	bne	r2,zero,d03a2a0 <alt_tse_mac_group_init+0x500>
 d03a26c:	00001206 	br	d03a2b8 <alt_tse_mac_group_init+0x518>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 d03a270:	01034174 	movhi	r4,3333
 d03a274:	21020204 	addi	r4,r4,2056
 d03a278:	01434174 	movhi	r5,3333
 d03a27c:	2941d804 	addi	r5,r5,1888
 d03a280:	d0372880 	call	d037288 <no_printf>
	                            break;
 d03a284:	00001106 	br	d03a2cc <alt_tse_mac_group_init+0x52c>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 d03a288:	01034174 	movhi	r4,3333
 d03a28c:	21020204 	addi	r4,r4,2056
 d03a290:	01434174 	movhi	r5,3333
 d03a294:	2941dd04 	addi	r5,r5,1908
 d03a298:	d0372880 	call	d037288 <no_printf>
	                            break;
 d03a29c:	00000b06 	br	d03a2cc <alt_tse_mac_group_init+0x52c>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 d03a2a0:	01034174 	movhi	r4,3333
 d03a2a4:	21020204 	addi	r4,r4,2056
 d03a2a8:	01434174 	movhi	r5,3333
 d03a2ac:	2941e304 	addi	r5,r5,1932
 d03a2b0:	d0372880 	call	d037288 <no_printf>
	                            break;
 d03a2b4:	00000506 	br	d03a2cc <alt_tse_mac_group_init+0x52c>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 d03a2b8:	01034174 	movhi	r4,3333
 d03a2bc:	21020204 	addi	r4,r4,2056
 d03a2c0:	01434174 	movhi	r5,3333
 d03a2c4:	297fe404 	addi	r5,r5,-112
 d03a2c8:	d0372880 	call	d037288 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 d03a2cc:	e0bff417 	ldw	r2,-48(fp)
 d03a2d0:	10800217 	ldw	r2,8(r2)
 d03a2d4:	108003c3 	ldbu	r2,15(r2)
 d03a2d8:	10803fcc 	andi	r2,r2,255
 d03a2dc:	1005003a 	cmpeq	r2,r2,zero
 d03a2e0:	1000221e 	bne	r2,zero,d03a36c <alt_tse_mac_group_init+0x5cc>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 d03a2e4:	e0bff417 	ldw	r2,-48(fp)
 d03a2e8:	10800217 	ldw	r2,8(r2)
 d03a2ec:	108003c3 	ldbu	r2,15(r2)
 d03a2f0:	10803fcc 	andi	r2,r2,255
 d03a2f4:	1005003a 	cmpeq	r2,r2,zero
 d03a2f8:	1000041e 	bne	r2,zero,d03a30c <alt_tse_mac_group_init+0x56c>
 d03a2fc:	00834174 	movhi	r2,3333
 d03a300:	1081ea04 	addi	r2,r2,1960
 d03a304:	e0bff815 	stw	r2,-32(fp)
 d03a308:	00000306 	br	d03a318 <alt_tse_mac_group_init+0x578>
 d03a30c:	00c34174 	movhi	r3,3333
 d03a310:	18c1eb04 	addi	r3,r3,1964
 d03a314:	e0fff815 	stw	r3,-32(fp)
 d03a318:	01034174 	movhi	r4,3333
 d03a31c:	21020d04 	addi	r4,r4,2100
 d03a320:	e17ff817 	ldw	r5,-32(fp)
 d03a324:	d0372880 	call	d037288 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 d03a328:	e0bff417 	ldw	r2,-48(fp)
 d03a32c:	10800217 	ldw	r2,8(r2)
 d03a330:	10800403 	ldbu	r2,16(r2)
 d03a334:	10803fcc 	andi	r2,r2,255
 d03a338:	1005003a 	cmpeq	r2,r2,zero
 d03a33c:	1000041e 	bne	r2,zero,d03a350 <alt_tse_mac_group_init+0x5b0>
 d03a340:	00834174 	movhi	r2,3333
 d03a344:	1081ea04 	addi	r2,r2,1960
 d03a348:	e0bff715 	stw	r2,-36(fp)
 d03a34c:	00000306 	br	d03a35c <alt_tse_mac_group_init+0x5bc>
 d03a350:	00c34174 	movhi	r3,3333
 d03a354:	18c1eb04 	addi	r3,r3,1964
 d03a358:	e0fff715 	stw	r3,-36(fp)
 d03a35c:	01034174 	movhi	r4,3333
 d03a360:	21021804 	addi	r4,r4,2144
 d03a364:	e17ff717 	ldw	r5,-36(fp)
 d03a368:	d0372880 	call	d037288 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 d03a36c:	e0bff417 	ldw	r2,-48(fp)
 d03a370:	10800217 	ldw	r2,8(r2)
 d03a374:	108002c3 	ldbu	r2,11(r2)
 d03a378:	10803fcc 	andi	r2,r2,255
 d03a37c:	1005003a 	cmpeq	r2,r2,zero
 d03a380:	1000101e 	bne	r2,zero,d03a3c4 <alt_tse_mac_group_init+0x624>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 d03a384:	e17ff607 	ldb	r5,-40(fp)
 d03a388:	e0bff417 	ldw	r2,-48(fp)
 d03a38c:	10800217 	ldw	r2,8(r2)
 d03a390:	10800017 	ldw	r2,0(r2)
 d03a394:	100d883a 	mov	r6,r2
 d03a398:	01034174 	movhi	r4,3333
 d03a39c:	21022304 	addi	r4,r4,2188
 d03a3a0:	d0372880 	call	d037288 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 d03a3a4:	e17ff607 	ldb	r5,-40(fp)
 d03a3a8:	e0fff647 	ldb	r3,-39(fp)
 d03a3ac:	e0bff607 	ldb	r2,-40(fp)
 d03a3b0:	188d883a 	add	r6,r3,r2
 d03a3b4:	01034174 	movhi	r4,3333
 d03a3b8:	21022f04 	addi	r4,r4,2236
 d03a3bc:	d0372880 	call	d037288 <no_printf>
 d03a3c0:	00000d06 	br	d03a3f8 <alt_tse_mac_group_init+0x658>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 d03a3c4:	e0bff417 	ldw	r2,-48(fp)
 d03a3c8:	10800217 	ldw	r2,8(r2)
 d03a3cc:	10800017 	ldw	r2,0(r2)
 d03a3d0:	100b883a 	mov	r5,r2
 d03a3d4:	01034174 	movhi	r4,3333
 d03a3d8:	21023e04 	addi	r4,r4,2296
 d03a3dc:	d0372880 	call	d037288 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 d03a3e0:	e0fff647 	ldb	r3,-39(fp)
 d03a3e4:	e0bff607 	ldb	r2,-40(fp)
 d03a3e8:	188b883a 	add	r5,r3,r2
 d03a3ec:	01034174 	movhi	r4,3333
 d03a3f0:	21024a04 	addi	r4,r4,2344
 d03a3f4:	d0372880 	call	d037288 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 d03a3f8:	e0bff607 	ldb	r2,-40(fp)
 d03a3fc:	e0fff517 	ldw	r3,-44(fp)
 d03a400:	1085883a 	add	r2,r2,r2
 d03a404:	1085883a 	add	r2,r2,r2
 d03a408:	10c5883a 	add	r2,r2,r3
 d03a40c:	10c00104 	addi	r3,r2,4
 d03a410:	e0bff417 	ldw	r2,-48(fp)
 d03a414:	18800015 	stw	r2,0(r3)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 d03a418:	e0bff603 	ldbu	r2,-40(fp)
 d03a41c:	10800044 	addi	r2,r2,1
 d03a420:	e0bff605 	stb	r2,-40(fp)
 d03a424:	e0fff607 	ldb	r3,-40(fp)
 d03a428:	e0bff517 	ldw	r2,-44(fp)
 d03a42c:	10800003 	ldbu	r2,0(r2)
 d03a430:	10803fcc 	andi	r2,r2,255
 d03a434:	18bec116 	blt	r3,r2,d039f3c <alt_tse_mac_group_init+0x19c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 d03a438:	d0a93843 	ldbu	r2,-23327(gp)
 d03a43c:	10803fcc 	andi	r2,r2,255
 d03a440:	00c341b4 	movhi	r3,3334
 d03a444:	18c50204 	addi	r3,r3,5128
 d03a448:	1085883a 	add	r2,r2,r2
 d03a44c:	1085883a 	add	r2,r2,r2
 d03a450:	10c7883a 	add	r3,r2,r3
 d03a454:	e0bff517 	ldw	r2,-44(fp)
 d03a458:	18800015 	stw	r2,0(r3)
            
            mac_group_count++;
 d03a45c:	d0a93843 	ldbu	r2,-23327(gp)
 d03a460:	10800044 	addi	r2,r2,1
 d03a464:	d0a93845 	stb	r2,-23327(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 d03a468:	e0bff517 	ldw	r2,-44(fp)
 d03a46c:	10c00003 	ldbu	r3,0(r2)
 d03a470:	e0bff643 	ldbu	r2,-39(fp)
 d03a474:	1885883a 	add	r2,r3,r2
 d03a478:	10bfffc4 	addi	r2,r2,-1
 d03a47c:	e0bff645 	stb	r2,-39(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 d03a480:	e0bff643 	ldbu	r2,-39(fp)
 d03a484:	10800044 	addi	r2,r2,1
 d03a488:	e0bff645 	stb	r2,-39(fp)
 d03a48c:	e0bff647 	ldb	r2,-39(fp)
 d03a490:	d0e04a03 	ldbu	r3,-32472(gp)
 d03a494:	18c03fcc 	andi	r3,r3,255
 d03a498:	10fe4b16 	blt	r2,r3,d039dc8 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 d03a49c:	e03fff15 	stw	zero,-4(fp)
 d03a4a0:	e0bfff17 	ldw	r2,-4(fp)
}
 d03a4a4:	e037883a 	mov	sp,fp
 d03a4a8:	dfc00117 	ldw	ra,4(sp)
 d03a4ac:	df000017 	ldw	fp,0(sp)
 d03a4b0:	dec00204 	addi	sp,sp,8
 d03a4b4:	f800283a 	ret

0d03a4b8 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 d03a4b8:	deffec04 	addi	sp,sp,-80
 d03a4bc:	dfc01315 	stw	ra,76(sp)
 d03a4c0:	df001215 	stw	fp,72(sp)
 d03a4c4:	df001204 	addi	fp,sp,72
 d03a4c8:	e13ffe15 	stw	r4,-8(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 d03a4cc:	e03ffc15 	stw	zero,-16(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 d03a4d0:	e03ff615 	stw	zero,-40(fp)
    
    alt_8 phy_info_count = 0;
 d03a4d4:	e03ff505 	stb	zero,-44(fp)
    
    alt_tse_phy_info *pphy = 0;
 d03a4d8:	e03ff415 	stw	zero,-48(fp)
    alt_tse_mac_info *pmac_info = 0;
 d03a4dc:	e03ff315 	stw	zero,-52(fp)
    alt_tse_system_info *psys = 0;
 d03a4e0:	e03ff215 	stw	zero,-56(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d03a4e4:	e0bffe17 	ldw	r2,-8(fp)
 d03a4e8:	10800117 	ldw	r2,4(r2)
 d03a4ec:	10800217 	ldw	r2,8(r2)
 d03a4f0:	10800017 	ldw	r2,0(r2)
 d03a4f4:	e0bff115 	stw	r2,-60(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 d03a4f8:	e0bff117 	ldw	r2,-60(fp)
 d03a4fc:	10801004 	addi	r2,r2,64
 d03a500:	10800037 	ldwio	r2,0(r2)
 d03a504:	e0bff015 	stw	r2,-64(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03a508:	e13ffe17 	ldw	r4,-8(fp)
 d03a50c:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03a510:	e0bfef05 	stb	r2,-68(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 d03a514:	e03ffb05 	stb	zero,-20(fp)
 d03a518:	0000c806 	br	d03a83c <alt_tse_mac_get_phy+0x384>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 d03a51c:	e0bff117 	ldw	r2,-60(fp)
 d03a520:	10801004 	addi	r2,r2,64
 d03a524:	e0fffb03 	ldbu	r3,-20(fp)
 d03a528:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 d03a52c:	e0bff117 	ldw	r2,-60(fp)
 d03a530:	1080a204 	addi	r2,r2,648
 d03a534:	10800037 	ldwio	r2,0(r2)
 d03a538:	e0bffd15 	stw	r2,-12(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 d03a53c:	e0bff117 	ldw	r2,-60(fp)
 d03a540:	1080a304 	addi	r2,r2,652
 d03a544:	10800037 	ldwio	r2,0(r2)
 d03a548:	e0bffc15 	stw	r2,-16(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 d03a54c:	e0fffd17 	ldw	r3,-12(fp)
 d03a550:	e0bffc17 	ldw	r2,-16(fp)
 d03a554:	1880b626 	beq	r3,r2,d03a830 <alt_tse_mac_get_phy+0x378>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 d03a558:	01000704 	movi	r4,28
 d03a55c:	d04be300 	call	d04be30 <malloc>
 d03a560:	e0bff415 	stw	r2,-48(fp)
            if(!pphy) {
 d03a564:	e0bff417 	ldw	r2,-48(fp)
 d03a568:	1004c03a 	cmpne	r2,r2,zero
 d03a56c:	1000081e 	bne	r2,zero,d03a590 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 d03a570:	e17fef07 	ldb	r5,-68(fp)
 d03a574:	e1bff507 	ldb	r6,-44(fp)
 d03a578:	01034174 	movhi	r4,3333
 d03a57c:	21025904 	addi	r4,r4,2404
 d03a580:	d0028a00 	call	d0028a0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 d03a584:	00bfffc4 	movi	r2,-1
 d03a588:	e0bfff15 	stw	r2,-4(fp)
 d03a58c:	0000ca06 	br	d03a8b8 <alt_tse_mac_get_phy+0x400>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 d03a590:	e0fff417 	ldw	r3,-48(fp)
 d03a594:	e0bffb03 	ldbu	r2,-20(fp)
 d03a598:	18800005 	stb	r2,0(r3)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 d03a59c:	e0bffd17 	ldw	r2,-12(fp)
 d03a5a0:	100691ba 	slli	r3,r2,6
 d03a5a4:	e0bffc17 	ldw	r2,-16(fp)
 d03a5a8:	1005d2ba 	srai	r2,r2,10
 d03a5ac:	10800fcc 	andi	r2,r2,63
 d03a5b0:	1884b03a 	or	r2,r3,r2
 d03a5b4:	e0bffa15 	stw	r2,-24(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 d03a5b8:	e0bffc17 	ldw	r2,-16(fp)
 d03a5bc:	1005d13a 	srai	r2,r2,4
 d03a5c0:	10800fcc 	andi	r2,r2,63
 d03a5c4:	e0bff945 	stb	r2,-27(fp)
            revision_number = phyid2 & 0x0f;
 d03a5c8:	e0bffc17 	ldw	r2,-16(fp)
 d03a5cc:	108003cc 	andi	r2,r2,15
 d03a5d0:	e0bff905 	stb	r2,-28(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 d03a5d4:	e03ff705 	stb	zero,-36(fp)
            for(i = 0; i < phy_profile_count; i++) {
 d03a5d8:	e03ff815 	stw	zero,-32(fp)
 d03a5dc:	00003106 	br	d03a6a4 <alt_tse_mac_get_phy+0x1ec>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 d03a5e0:	e0bff817 	ldw	r2,-32(fp)
 d03a5e4:	00c341b4 	movhi	r3,3334
 d03a5e8:	18c50604 	addi	r3,r3,5144
 d03a5ec:	1085883a 	add	r2,r2,r2
 d03a5f0:	1085883a 	add	r2,r2,r2
 d03a5f4:	10c5883a 	add	r2,r2,r3
 d03a5f8:	10800017 	ldw	r2,0(r2)
 d03a5fc:	10c01417 	ldw	r3,80(r2)
 d03a600:	e0bffa17 	ldw	r2,-24(fp)
 d03a604:	1880241e 	bne	r3,r2,d03a698 <alt_tse_mac_get_phy+0x1e0>
 d03a608:	e0bff817 	ldw	r2,-32(fp)
 d03a60c:	00c341b4 	movhi	r3,3334
 d03a610:	18c50604 	addi	r3,r3,5144
 d03a614:	1085883a 	add	r2,r2,r2
 d03a618:	1085883a 	add	r2,r2,r2
 d03a61c:	10c5883a 	add	r2,r2,r3
 d03a620:	10800017 	ldw	r2,0(r2)
 d03a624:	10801503 	ldbu	r2,84(r2)
 d03a628:	10c03fcc 	andi	r3,r2,255
 d03a62c:	e0bff943 	ldbu	r2,-27(fp)
 d03a630:	1880191e 	bne	r3,r2,d03a698 <alt_tse_mac_get_phy+0x1e0>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 d03a634:	e0bff817 	ldw	r2,-32(fp)
 d03a638:	00c341b4 	movhi	r3,3334
 d03a63c:	18c50604 	addi	r3,r3,5144
 d03a640:	1085883a 	add	r2,r2,r2
 d03a644:	1085883a 	add	r2,r2,r2
 d03a648:	10c5883a 	add	r2,r2,r3
 d03a64c:	10c00017 	ldw	r3,0(r2)
 d03a650:	e0bff417 	ldw	r2,-48(fp)
 d03a654:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 d03a658:	e0bff817 	ldw	r2,-32(fp)
 d03a65c:	00c341b4 	movhi	r3,3334
 d03a660:	18c50604 	addi	r3,r3,5144
 d03a664:	1085883a 	add	r2,r2,r2
 d03a668:	1085883a 	add	r2,r2,r2
 d03a66c:	10c5883a 	add	r2,r2,r3
 d03a670:	10800017 	ldw	r2,0(r2)
 d03a674:	100b883a 	mov	r5,r2
 d03a678:	e1bffb03 	ldbu	r6,-20(fp)
 d03a67c:	e1ffef07 	ldb	r7,-68(fp)
 d03a680:	01034174 	movhi	r4,3333
 d03a684:	21026804 	addi	r4,r4,2464
 d03a688:	d0028a00 	call	d0028a0 <printf>
                    is_phy_in_profile = 1;
 d03a68c:	00800044 	movi	r2,1
 d03a690:	e0bff705 	stb	r2,-36(fp)
                    break;
 d03a694:	00000706 	br	d03a6b4 <alt_tse_mac_get_phy+0x1fc>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 d03a698:	e0bff817 	ldw	r2,-32(fp)
 d03a69c:	10800044 	addi	r2,r2,1
 d03a6a0:	e0bff815 	stw	r2,-32(fp)
 d03a6a4:	d0a93803 	ldbu	r2,-23328(gp)
 d03a6a8:	10c03fcc 	andi	r3,r2,255
 d03a6ac:	e0bff817 	ldw	r2,-32(fp)
 d03a6b0:	10ffcb16 	blt	r2,r3,d03a5e0 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 d03a6b4:	e0bff703 	ldbu	r2,-36(fp)
 d03a6b8:	1004c03a 	cmpne	r2,r2,zero
 d03a6bc:	10000d1e 	bne	r2,zero,d03a6f4 <alt_tse_mac_get_phy+0x23c>
                pphy->pphy_profile = 0;
 d03a6c0:	e0bff417 	ldw	r2,-48(fp)
 d03a6c4:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 d03a6c8:	e17ffb03 	ldbu	r5,-20(fp)
 d03a6cc:	e1bfef07 	ldb	r6,-68(fp)
 d03a6d0:	01034174 	movhi	r4,3333
 d03a6d4:	21027804 	addi	r4,r4,2528
 d03a6d8:	d0028a00 	call	d0028a0 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 d03a6dc:	01034174 	movhi	r4,3333
 d03a6e0:	21028904 	addi	r4,r4,2596
 d03a6e4:	d002bc80 	call	d002bc8 <puts>
                return_value++;
 d03a6e8:	e0bff617 	ldw	r2,-40(fp)
 d03a6ec:	10800044 	addi	r2,r2,1
 d03a6f0:	e0bff615 	stw	r2,-40(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 d03a6f4:	e17ffa17 	ldw	r5,-24(fp)
 d03a6f8:	01034174 	movhi	r4,3333
 d03a6fc:	21029604 	addi	r4,r4,2648
 d03a700:	d0372880 	call	d037288 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 d03a704:	e17ff943 	ldbu	r5,-27(fp)
 d03a708:	01034174 	movhi	r4,3333
 d03a70c:	2102a104 	addi	r4,r4,2692
 d03a710:	d0372880 	call	d037288 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 d03a714:	e17ff903 	ldbu	r5,-28(fp)
 d03a718:	01034174 	movhi	r4,3333
 d03a71c:	2102ac04 	addi	r4,r4,2736
 d03a720:	d0372880 	call	d037288 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 d03a724:	e13ffe17 	ldw	r4,-8(fp)
 d03a728:	e17ff417 	ldw	r5,-48(fp)
 d03a72c:	d03a8d00 	call	d03a8d0 <alt_tse_mac_associate_phy>
 d03a730:	1004c03a 	cmpne	r2,r2,zero
 d03a734:	1000381e 	bne	r2,zero,d03a818 <alt_tse_mac_get_phy+0x360>
            	
            	pmac_info = pphy->pmac_info;
 d03a738:	e0bff417 	ldw	r2,-48(fp)
 d03a73c:	10800617 	ldw	r2,24(r2)
 d03a740:	e0bff315 	stw	r2,-52(fp)
            	psys = pmac_info->psys_info;
 d03a744:	e0bff317 	ldw	r2,-52(fp)
 d03a748:	10800217 	ldw	r2,8(r2)
 d03a74c:	e0bff215 	stw	r2,-56(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 d03a750:	d8000015 	stw	zero,0(sp)
 d03a754:	e13ff417 	ldw	r4,-48(fp)
 d03a758:	000b883a 	mov	r5,zero
 d03a75c:	01800384 	movi	r6,14
 d03a760:	01c00044 	movi	r7,1
 d03a764:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 d03a768:	e13ff417 	ldw	r4,-48(fp)
 d03a76c:	01400044 	movi	r5,1
 d03a770:	d03b5700 	call	d03b570 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 d03a774:	e13ff417 	ldw	r4,-48(fp)
 d03a778:	01400044 	movi	r5,1
 d03a77c:	d03b7040 	call	d03b704 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 d03a780:	e13ff417 	ldw	r4,-48(fp)
 d03a784:	01400044 	movi	r5,1
 d03a788:	d03b9140 	call	d03b914 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 d03a78c:	e13ff417 	ldw	r4,-48(fp)
 d03a790:	014003f4 	movhi	r5,15
 d03a794:	29509004 	addi	r5,r5,16960
 d03a798:	d03ad3c0 	call	d03ad3c <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 d03a79c:	e0bff417 	ldw	r2,-48(fp)
 d03a7a0:	10800517 	ldw	r2,20(r2)
 d03a7a4:	1005003a 	cmpeq	r2,r2,zero
 d03a7a8:	1000101e 	bne	r2,zero,d03a7ec <alt_tse_mac_get_phy+0x334>
		            if(pphy->pphy_profile->phy_cfg) {
 d03a7ac:	e0bff417 	ldw	r2,-48(fp)
 d03a7b0:	10800517 	ldw	r2,20(r2)
 d03a7b4:	10801717 	ldw	r2,92(r2)
 d03a7b8:	1005003a 	cmpeq	r2,r2,zero
 d03a7bc:	10000b1e 	bne	r2,zero,d03a7ec <alt_tse_mac_get_phy+0x334>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 d03a7c0:	e0bff417 	ldw	r2,-48(fp)
 d03a7c4:	10800517 	ldw	r2,20(r2)
 d03a7c8:	100b883a 	mov	r5,r2
 d03a7cc:	01034174 	movhi	r4,3333
 d03a7d0:	2102b704 	addi	r4,r4,2780
 d03a7d4:	d0372880 	call	d037288 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 d03a7d8:	e0bff417 	ldw	r2,-48(fp)
 d03a7dc:	10800517 	ldw	r2,20(r2)
 d03a7e0:	10801717 	ldw	r2,92(r2)
 d03a7e4:	e13ff117 	ldw	r4,-60(fp)
 d03a7e8:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 d03a7ec:	e0bff217 	ldw	r2,-56(fp)
 d03a7f0:	10801117 	ldw	r2,68(r2)
 d03a7f4:	1005003a 	cmpeq	r2,r2,zero
 d03a7f8:	1000071e 	bne	r2,zero,d03a818 <alt_tse_mac_get_phy+0x360>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 d03a7fc:	01034174 	movhi	r4,3333
 d03a800:	2102c504 	addi	r4,r4,2836
 d03a804:	d0372880 	call	d037288 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 d03a808:	e0bff217 	ldw	r2,-56(fp)
 d03a80c:	10801117 	ldw	r2,68(r2)
 d03a810:	e13ff117 	ldw	r4,-60(fp)
 d03a814:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 d03a818:	01034174 	movhi	r4,3333
 d03a81c:	2102d304 	addi	r4,r4,2892
 d03a820:	d0372880 	call	d037288 <no_printf>
	            
            phy_info_count++;
 d03a824:	e0bff503 	ldbu	r2,-44(fp)
 d03a828:	10800044 	addi	r2,r2,1
 d03a82c:	e0bff505 	stb	r2,-44(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 d03a830:	e0bffb03 	ldbu	r2,-20(fp)
 d03a834:	10800044 	addi	r2,r2,1
 d03a838:	e0bffb05 	stb	r2,-20(fp)
 d03a83c:	e0bffb03 	ldbu	r2,-20(fp)
 d03a840:	10800830 	cmpltui	r2,r2,32
 d03a844:	103f351e 	bne	r2,zero,d03a51c <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 d03a848:	e0bffe17 	ldw	r2,-8(fp)
 d03a84c:	10800003 	ldbu	r2,0(r2)
 d03a850:	10c03fcc 	andi	r3,r2,255
 d03a854:	e0bff507 	ldb	r2,-44(fp)
 d03a858:	18801026 	beq	r3,r2,d03a89c <alt_tse_mac_get_phy+0x3e4>
        if(phy_info_count == 0) {
 d03a85c:	e0bff507 	ldb	r2,-44(fp)
 d03a860:	1004c03a 	cmpne	r2,r2,zero
 d03a864:	1000051e 	bne	r2,zero,d03a87c <alt_tse_mac_get_phy+0x3c4>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 d03a868:	e17fef07 	ldb	r5,-68(fp)
 d03a86c:	01034174 	movhi	r4,3333
 d03a870:	2102d404 	addi	r4,r4,2896
 d03a874:	d0028a00 	call	d0028a0 <printf>
 d03a878:	00000806 	br	d03a89c <alt_tse_mac_get_phy+0x3e4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 d03a87c:	e17fef07 	ldb	r5,-68(fp)
 d03a880:	e1bff507 	ldb	r6,-44(fp)
 d03a884:	e0bffe17 	ldw	r2,-8(fp)
 d03a888:	10800003 	ldbu	r2,0(r2)
 d03a88c:	11c03fcc 	andi	r7,r2,255
 d03a890:	01034174 	movhi	r4,3333
 d03a894:	2102e004 	addi	r4,r4,2944
 d03a898:	d0028a00 	call	d0028a0 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d03a89c:	e0bff117 	ldw	r2,-60(fp)
 d03a8a0:	10801004 	addi	r2,r2,64
 d03a8a4:	1007883a 	mov	r3,r2
 d03a8a8:	e0bff017 	ldw	r2,-64(fp)
 d03a8ac:	18800035 	stwio	r2,0(r3)
    
    return return_value;
 d03a8b0:	e0bff617 	ldw	r2,-40(fp)
 d03a8b4:	e0bfff15 	stw	r2,-4(fp)
 d03a8b8:	e0bfff17 	ldw	r2,-4(fp)
}
 d03a8bc:	e037883a 	mov	sp,fp
 d03a8c0:	dfc00117 	ldw	ra,4(sp)
 d03a8c4:	df000017 	ldw	fp,0(sp)
 d03a8c8:	dec00204 	addi	sp,sp,8
 d03a8cc:	f800283a 	ret

0d03a8d0 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 d03a8d0:	defff604 	addi	sp,sp,-40
 d03a8d4:	dfc00915 	stw	ra,36(sp)
 d03a8d8:	df000815 	stw	fp,32(sp)
 d03a8dc:	df000804 	addi	fp,sp,32
 d03a8e0:	e13ffe15 	stw	r4,-8(fp)
 d03a8e4:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 d03a8e8:	e03ffc15 	stw	zero,-16(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 d03a8ec:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_info *pmac_info = 0;
 d03a8f0:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 d03a8f4:	e03ff885 	stb	zero,-30(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03a8f8:	e13ffe17 	ldw	r4,-8(fp)
 d03a8fc:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03a900:	e0bff845 	stb	r2,-31(fp)
    alt_8 sys_info_index = 0;
 d03a904:	e03ff805 	stb	zero,-32(fp)
    
    is_mapped = 0;
 d03a908:	e03ffb05 	stb	zero,-20(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 d03a90c:	e03ffd15 	stw	zero,-12(fp)
 d03a910:	00002906 	br	d03a9b8 <alt_tse_mac_associate_phy+0xe8>
        pmac_info = pmac_group->pmac_info[i];
 d03a914:	e0bffd17 	ldw	r2,-12(fp)
 d03a918:	e0fffe17 	ldw	r3,-8(fp)
 d03a91c:	1085883a 	add	r2,r2,r2
 d03a920:	1085883a 	add	r2,r2,r2
 d03a924:	10c5883a 	add	r2,r2,r3
 d03a928:	10800104 	addi	r2,r2,4
 d03a92c:	10800017 	ldw	r2,0(r2)
 d03a930:	e0bff915 	stw	r2,-28(fp)
        psys = pmac_info->psys_info;
 d03a934:	e0bff917 	ldw	r2,-28(fp)
 d03a938:	10800217 	ldw	r2,8(r2)
 d03a93c:	e0bffa15 	stw	r2,-24(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 d03a940:	e0bffa17 	ldw	r2,-24(fp)
 d03a944:	10c01017 	ldw	r3,64(r2)
 d03a948:	e0bfff17 	ldw	r2,-4(fp)
 d03a94c:	10800003 	ldbu	r2,0(r2)
 d03a950:	10803fcc 	andi	r2,r2,255
 d03a954:	1880151e 	bne	r3,r2,d03a9ac <alt_tse_mac_associate_phy+0xdc>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03a958:	e13ff917 	ldw	r4,-28(fp)
 d03a95c:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03a960:	e0bff885 	stb	r2,-30(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 d03a964:	e13ffa17 	ldw	r4,-24(fp)
 d03a968:	d0384b00 	call	d0384b0 <alt_tse_get_system_index>
 d03a96c:	e0bff805 	stb	r2,-32(fp)
	        
            pmac_info->pphy_info = pphy;
 d03a970:	e0fff917 	ldw	r3,-28(fp)
 d03a974:	e0bfff17 	ldw	r2,-4(fp)
 d03a978:	18800115 	stw	r2,4(r3)
            pphy->pmac_info = pmac_info;
 d03a97c:	e0ffff17 	ldw	r3,-4(fp)
 d03a980:	e0bff917 	ldw	r2,-28(fp)
 d03a984:	18800615 	stw	r2,24(r3)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 d03a988:	e17ff847 	ldb	r5,-31(fp)
 d03a98c:	e1bff887 	ldb	r6,-30(fp)
 d03a990:	e1fff807 	ldb	r7,-32(fp)
 d03a994:	01034174 	movhi	r4,3333
 d03a998:	2102ff04 	addi	r4,r4,3068
 d03a99c:	d0028a00 	call	d0028a0 <printf>
            is_mapped = 1;
 d03a9a0:	00800044 	movi	r2,1
 d03a9a4:	e0bffb05 	stb	r2,-20(fp)
            break;
 d03a9a8:	00000806 	br	d03a9cc <alt_tse_mac_associate_phy+0xfc>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 d03a9ac:	e0bffd17 	ldw	r2,-12(fp)
 d03a9b0:	10800044 	addi	r2,r2,1
 d03a9b4:	e0bffd15 	stw	r2,-12(fp)
 d03a9b8:	e0bffe17 	ldw	r2,-8(fp)
 d03a9bc:	10800003 	ldbu	r2,0(r2)
 d03a9c0:	10c03fcc 	andi	r3,r2,255
 d03a9c4:	e0bffd17 	ldw	r2,-12(fp)
 d03a9c8:	10ffd216 	blt	r2,r3,d03a914 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 d03a9cc:	e0bffb03 	ldbu	r2,-20(fp)
 d03a9d0:	1004c03a 	cmpne	r2,r2,zero
 d03a9d4:	10003b1e 	bne	r2,zero,d03aac4 <alt_tse_mac_associate_phy+0x1f4>
        for(i = 0; i < pmac_group->channel; i++) {
 d03a9d8:	e03ffd15 	stw	zero,-12(fp)
 d03a9dc:	00003406 	br	d03aab0 <alt_tse_mac_associate_phy+0x1e0>
            pmac_info = pmac_group->pmac_info[i];
 d03a9e0:	e0bffd17 	ldw	r2,-12(fp)
 d03a9e4:	e0fffe17 	ldw	r3,-8(fp)
 d03a9e8:	1085883a 	add	r2,r2,r2
 d03a9ec:	1085883a 	add	r2,r2,r2
 d03a9f0:	10c5883a 	add	r2,r2,r3
 d03a9f4:	10800104 	addi	r2,r2,4
 d03a9f8:	10800017 	ldw	r2,0(r2)
 d03a9fc:	e0bff915 	stw	r2,-28(fp)
            psys = pmac_info->psys_info;
 d03aa00:	e0bff917 	ldw	r2,-28(fp)
 d03aa04:	10800217 	ldw	r2,8(r2)
 d03aa08:	e0bffa15 	stw	r2,-24(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 d03aa0c:	e0bffa17 	ldw	r2,-24(fp)
 d03aa10:	10800517 	ldw	r2,20(r2)
 d03aa14:	1005003a 	cmpeq	r2,r2,zero
 d03aa18:	1000221e 	bne	r2,zero,d03aaa4 <alt_tse_mac_associate_phy+0x1d4>
 d03aa1c:	e0bffa17 	ldw	r2,-24(fp)
 d03aa20:	10800617 	ldw	r2,24(r2)
 d03aa24:	1005003a 	cmpeq	r2,r2,zero
 d03aa28:	10001e1e 	bne	r2,zero,d03aaa4 <alt_tse_mac_associate_phy+0x1d4>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 d03aa2c:	e0bffa17 	ldw	r2,-24(fp)
 d03aa30:	10801017 	ldw	r2,64(r2)
 d03aa34:	10bfffd8 	cmpnei	r2,r2,-1
 d03aa38:	10001a1e 	bne	r2,zero,d03aaa4 <alt_tse_mac_associate_phy+0x1d4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03aa3c:	e13ff917 	ldw	r4,-28(fp)
 d03aa40:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03aa44:	e0bff885 	stb	r2,-30(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 d03aa48:	e13ffa17 	ldw	r4,-24(fp)
 d03aa4c:	d0384b00 	call	d0384b0 <alt_tse_get_system_index>
 d03aa50:	e0bff805 	stb	r2,-32(fp)
                
                pmac_info->pphy_info = pphy;
 d03aa54:	e0fff917 	ldw	r3,-28(fp)
 d03aa58:	e0bfff17 	ldw	r2,-4(fp)
 d03aa5c:	18800115 	stw	r2,4(r3)
                pphy->pmac_info = pmac_info;
 d03aa60:	e0ffff17 	ldw	r3,-4(fp)
 d03aa64:	e0bff917 	ldw	r2,-28(fp)
 d03aa68:	18800615 	stw	r2,24(r3)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 d03aa6c:	e0bfff17 	ldw	r2,-4(fp)
 d03aa70:	10800003 	ldbu	r2,0(r2)
 d03aa74:	10c03fcc 	andi	r3,r2,255
 d03aa78:	e0bffa17 	ldw	r2,-24(fp)
 d03aa7c:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 d03aa80:	e17ff847 	ldb	r5,-31(fp)
 d03aa84:	e1bff887 	ldb	r6,-30(fp)
 d03aa88:	e1fff807 	ldb	r7,-32(fp)
 d03aa8c:	01034174 	movhi	r4,3333
 d03aa90:	21030f04 	addi	r4,r4,3132
 d03aa94:	d0028a00 	call	d0028a0 <printf>
                is_mapped = 1;
 d03aa98:	00800044 	movi	r2,1
 d03aa9c:	e0bffb05 	stb	r2,-20(fp)
                break;
 d03aaa0:	00000806 	br	d03aac4 <alt_tse_mac_associate_phy+0x1f4>
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 d03aaa4:	e0bffd17 	ldw	r2,-12(fp)
 d03aaa8:	10800044 	addi	r2,r2,1
 d03aaac:	e0bffd15 	stw	r2,-12(fp)
 d03aab0:	e0bffe17 	ldw	r2,-8(fp)
 d03aab4:	10800003 	ldbu	r2,0(r2)
 d03aab8:	10c03fcc 	andi	r3,r2,255
 d03aabc:	e0bffd17 	ldw	r2,-12(fp)
 d03aac0:	10ffc716 	blt	r2,r3,d03a9e0 <alt_tse_mac_associate_phy+0x110>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 d03aac4:	e0bffb03 	ldbu	r2,-20(fp)
 d03aac8:	1004c03a 	cmpne	r2,r2,zero
 d03aacc:	1000081e 	bne	r2,zero,d03aaf0 <alt_tse_mac_associate_phy+0x220>
    	pphy->pmac_info = 0;
 d03aad0:	e0bfff17 	ldw	r2,-4(fp)
 d03aad4:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 d03aad8:	e17ff847 	ldb	r5,-31(fp)
 d03aadc:	01034174 	movhi	r4,3333
 d03aae0:	21032004 	addi	r4,r4,3200
 d03aae4:	d0028a00 	call	d0028a0 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 d03aae8:	00bfffc4 	movi	r2,-1
 d03aaec:	e0bffc15 	stw	r2,-16(fp)
    }
    
    return return_value;
 d03aaf0:	e0bffc17 	ldw	r2,-16(fp)
}
 d03aaf4:	e037883a 	mov	sp,fp
 d03aaf8:	dfc00117 	ldw	ra,4(sp)
 d03aafc:	df000017 	ldw	fp,0(sp)
 d03ab00:	dec00204 	addi	sp,sp,8
 d03ab04:	f800283a 	ret

0d03ab08 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 d03ab08:	defff804 	addi	sp,sp,-32
 d03ab0c:	dfc00715 	stw	ra,28(sp)
 d03ab10:	df000615 	stw	fp,24(sp)
 d03ab14:	df000604 	addi	fp,sp,24
 d03ab18:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 d03ab1c:	e0bfff17 	ldw	r2,-4(fp)
 d03ab20:	10800217 	ldw	r2,8(r2)
 d03ab24:	e0bffe15 	stw	r2,-8(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 d03ab28:	e0bffe17 	ldw	r2,-8(fp)
 d03ab2c:	10800017 	ldw	r2,0(r2)
 d03ab30:	e0bffd15 	stw	r2,-12(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d03ab34:	e0bfff17 	ldw	r2,-4(fp)
 d03ab38:	10800317 	ldw	r2,12(r2)
 d03ab3c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03ab40:	e13fff17 	ldw	r4,-4(fp)
 d03ab44:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03ab48:	e0bffb45 	stb	r2,-19(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03ab4c:	e13ffc17 	ldw	r4,-16(fp)
 d03ab50:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03ab54:	e0bffb05 	stb	r2,-20(fp)

    if(psys->tse_pcs_ena) {
 d03ab58:	e0bffe17 	ldw	r2,-8(fp)
 d03ab5c:	108003c3 	ldbu	r2,15(r2)
 d03ab60:	10803fcc 	andi	r2,r2,255
 d03ab64:	1005003a 	cmpeq	r2,r2,zero
 d03ab68:	1000291e 	bne	r2,zero,d03ac10 <alt_tse_phy_cfg_pcs+0x108>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 d03ab6c:	e17ffb07 	ldb	r5,-20(fp)
 d03ab70:	e1bffb47 	ldb	r6,-19(fp)
 d03ab74:	01034174 	movhi	r4,3333
 d03ab78:	21035104 	addi	r4,r4,3396
 d03ab7c:	d0028a00 	call	d0028a0 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 d03ab80:	e0bffd17 	ldw	r2,-12(fp)
 d03ab84:	10808004 	addi	r2,r2,512
 d03ab88:	10801404 	addi	r2,r2,80
 d03ab8c:	10800037 	ldwio	r2,0(r2)
 d03ab90:	e0bffa15 	stw	r2,-24(fp)
        
        if(psys->tse_pcs_sgmii) {
 d03ab94:	e0bffe17 	ldw	r2,-8(fp)
 d03ab98:	10800403 	ldbu	r2,16(r2)
 d03ab9c:	10803fcc 	andi	r2,r2,255
 d03aba0:	1005003a 	cmpeq	r2,r2,zero
 d03aba4:	10000d1e 	bne	r2,zero,d03abdc <alt_tse_phy_cfg_pcs+0xd4>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 d03aba8:	e17ffb07 	ldb	r5,-20(fp)
 d03abac:	e1bffb47 	ldb	r6,-19(fp)
 d03abb0:	01034174 	movhi	r4,3333
 d03abb4:	21035f04 	addi	r4,r4,3452
 d03abb8:	d0028a00 	call	d0028a0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 d03abbc:	e0bffd17 	ldw	r2,-12(fp)
 d03abc0:	10808004 	addi	r2,r2,512
 d03abc4:	11001404 	addi	r4,r2,80
 d03abc8:	e0bffa17 	ldw	r2,-24(fp)
 d03abcc:	10c000d4 	ori	r3,r2,3
 d03abd0:	2005883a 	mov	r2,r4
 d03abd4:	10c00035 	stwio	r3,0(r2)
 d03abd8:	00000d06 	br	d03ac10 <alt_tse_phy_cfg_pcs+0x108>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 d03abdc:	e17ffb07 	ldb	r5,-20(fp)
 d03abe0:	e1bffb47 	ldb	r6,-19(fp)
 d03abe4:	01034174 	movhi	r4,3333
 d03abe8:	21036b04 	addi	r4,r4,3500
 d03abec:	d0028a00 	call	d0028a0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 d03abf0:	e0bffd17 	ldw	r2,-12(fp)
 d03abf4:	10808004 	addi	r2,r2,512
 d03abf8:	11001404 	addi	r4,r2,80
 d03abfc:	e0fffa17 	ldw	r3,-24(fp)
 d03ac00:	00bfff04 	movi	r2,-4
 d03ac04:	1886703a 	and	r3,r3,r2
 d03ac08:	2005883a 	mov	r2,r4
 d03ac0c:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 d03ac10:	0005883a 	mov	r2,zero
}
 d03ac14:	e037883a 	mov	sp,fp
 d03ac18:	dfc00117 	ldw	ra,4(sp)
 d03ac1c:	df000017 	ldw	fp,0(sp)
 d03ac20:	dec00204 	addi	sp,sp,8
 d03ac24:	f800283a 	ret

0d03ac28 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 d03ac28:	defffb04 	addi	sp,sp,-20
 d03ac2c:	dfc00415 	stw	ra,16(sp)
 d03ac30:	df000315 	stw	fp,12(sp)
 d03ac34:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 d03ac38:	e03fff45 	stb	zero,-3(fp)
	alt_8 j = 0;
 d03ac3c:	e03fff05 	stb	zero,-4(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 d03ac40:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 d03ac44:	e03ffd15 	stw	zero,-12(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 d03ac48:	d0399380 	call	d039938 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 d03ac4c:	d039bb00 	call	d039bb0 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 d03ac50:	d039da00 	call	d039da0 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 d03ac54:	e03fff45 	stb	zero,-3(fp)
 d03ac58:	00002e06 	br	d03ad14 <alt_tse_phy_init+0xec>
        pmac_group = pmac_groups[i];
 d03ac5c:	e0bfff47 	ldb	r2,-3(fp)
 d03ac60:	00c341b4 	movhi	r3,3334
 d03ac64:	18c50204 	addi	r3,r3,5128
 d03ac68:	1085883a 	add	r2,r2,r2
 d03ac6c:	1085883a 	add	r2,r2,r2
 d03ac70:	10c5883a 	add	r2,r2,r3
 d03ac74:	10800017 	ldw	r2,0(r2)
 d03ac78:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 d03ac7c:	e0bffe17 	ldw	r2,-8(fp)
 d03ac80:	10800117 	ldw	r2,4(r2)
 d03ac84:	10800217 	ldw	r2,8(r2)
 d03ac88:	10800203 	ldbu	r2,8(r2)
 d03ac8c:	10803fcc 	andi	r2,r2,255
 d03ac90:	1005003a 	cmpeq	r2,r2,zero
 d03ac94:	1000031e 	bne	r2,zero,d03aca4 <alt_tse_phy_init+0x7c>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 d03ac98:	e13ffe17 	ldw	r4,-8(fp)
 d03ac9c:	d03a4b80 	call	d03a4b8 <alt_tse_mac_get_phy>
 d03aca0:	00000506 	br	d03acb8 <alt_tse_phy_init+0x90>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 d03aca4:	e17fff47 	ldb	r5,-3(fp)
 d03aca8:	e1bfff07 	ldb	r6,-4(fp)
 d03acac:	01034174 	movhi	r4,3333
 d03acb0:	21037704 	addi	r4,r4,3548
 d03acb4:	d0028a00 	call	d0028a0 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 d03acb8:	e03fff05 	stb	zero,-4(fp)
 d03acbc:	00000d06 	br	d03acf4 <alt_tse_phy_init+0xcc>
            pmac_info = pmac_group->pmac_info[j];
 d03acc0:	e0bfff07 	ldb	r2,-4(fp)
 d03acc4:	e0fffe17 	ldw	r3,-8(fp)
 d03acc8:	1085883a 	add	r2,r2,r2
 d03accc:	1085883a 	add	r2,r2,r2
 d03acd0:	10c5883a 	add	r2,r2,r3
 d03acd4:	10800104 	addi	r2,r2,4
 d03acd8:	10800017 	ldw	r2,0(r2)
 d03acdc:	e0bffd15 	stw	r2,-12(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 d03ace0:	e13ffd17 	ldw	r4,-12(fp)
 d03ace4:	d03ab080 	call	d03ab08 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 d03ace8:	e0bfff03 	ldbu	r2,-4(fp)
 d03acec:	10800044 	addi	r2,r2,1
 d03acf0:	e0bfff05 	stb	r2,-4(fp)
 d03acf4:	e0ffff07 	ldb	r3,-4(fp)
 d03acf8:	e0bffe17 	ldw	r2,-8(fp)
 d03acfc:	10800003 	ldbu	r2,0(r2)
 d03ad00:	10803fcc 	andi	r2,r2,255
 d03ad04:	18bfee16 	blt	r3,r2,d03acc0 <alt_tse_phy_init+0x98>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 d03ad08:	e0bfff43 	ldbu	r2,-3(fp)
 d03ad0c:	10800044 	addi	r2,r2,1
 d03ad10:	e0bfff45 	stb	r2,-3(fp)
 d03ad14:	e0bfff47 	ldb	r2,-3(fp)
 d03ad18:	d0e93843 	ldbu	r3,-23327(gp)
 d03ad1c:	18c03fcc 	andi	r3,r3,255
 d03ad20:	10ffce16 	blt	r2,r3,d03ac5c <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 d03ad24:	0005883a 	mov	r2,zero
}
 d03ad28:	e037883a 	mov	sp,fp
 d03ad2c:	dfc00117 	ldw	ra,4(sp)
 d03ad30:	df000017 	ldw	fp,0(sp)
 d03ad34:	dec00204 	addi	sp,sp,8
 d03ad38:	f800283a 	ret

0d03ad3c <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 d03ad3c:	defff604 	addi	sp,sp,-40
 d03ad40:	dfc00915 	stw	ra,36(sp)
 d03ad44:	df000815 	stw	fp,32(sp)
 d03ad48:	df000804 	addi	fp,sp,32
 d03ad4c:	e13ffd15 	stw	r4,-12(fp)
 d03ad50:	e17ffe15 	stw	r5,-8(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d03ad54:	e0bffd17 	ldw	r2,-12(fp)
 d03ad58:	10800617 	ldw	r2,24(r2)
 d03ad5c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d03ad60:	e0bffc17 	ldw	r2,-16(fp)
 d03ad64:	10800317 	ldw	r2,12(r2)
 d03ad68:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03ad6c:	e13ffc17 	ldw	r4,-16(fp)
 d03ad70:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03ad74:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03ad78:	e13ffb17 	ldw	r4,-20(fp)
 d03ad7c:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03ad80:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d03ad84:	e13ffd17 	ldw	r4,-12(fp)
 d03ad88:	d0396b00 	call	d0396b0 <alt_tse_phy_rd_mdio_addr>
 d03ad8c:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d03ad90:	e0bffd17 	ldw	r2,-12(fp)
 d03ad94:	10800003 	ldbu	r2,0(r2)
 d03ad98:	11403fcc 	andi	r5,r2,255
 d03ad9c:	e13ffd17 	ldw	r4,-12(fp)
 d03ada0:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 d03ada4:	e13ffd17 	ldw	r4,-12(fp)
 d03ada8:	01400044 	movi	r5,1
 d03adac:	018000c4 	movi	r6,3
 d03adb0:	01c00044 	movi	r7,1
 d03adb4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03adb8:	1004c03a 	cmpne	r2,r2,zero
 d03adbc:	10000b1e 	bne	r2,zero,d03adec <alt_tse_phy_restart_an+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 d03adc0:	e17ffa47 	ldb	r5,-23(fp)
 d03adc4:	e1bffa87 	ldb	r6,-22(fp)
 d03adc8:	01034174 	movhi	r4,3333
 d03adcc:	21038d04 	addi	r4,r4,3636
 d03add0:	d0028a00 	call	d0028a0 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03add4:	e17ffa03 	ldbu	r5,-24(fp)
 d03add8:	e13ffd17 	ldw	r4,-12(fp)
 d03addc:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 d03ade0:	00bfff84 	movi	r2,-2
 d03ade4:	e0bfff15 	stw	r2,-4(fp)
 d03ade8:	00003a06 	br	d03aed4 <alt_tse_phy_restart_an+0x198>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 d03adec:	00800044 	movi	r2,1
 d03adf0:	d8800015 	stw	r2,0(sp)
 d03adf4:	e13ffd17 	ldw	r4,-12(fp)
 d03adf8:	000b883a 	mov	r5,zero
 d03adfc:	01800304 	movi	r6,12
 d03ae00:	01c00044 	movi	r7,1
 d03ae04:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 d03ae08:	00800044 	movi	r2,1
 d03ae0c:	d8800015 	stw	r2,0(sp)
 d03ae10:	e13ffd17 	ldw	r4,-12(fp)
 d03ae14:	000b883a 	mov	r5,zero
 d03ae18:	01800244 	movi	r6,9
 d03ae1c:	01c00044 	movi	r7,1
 d03ae20:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 d03ae24:	e17ffa47 	ldb	r5,-23(fp)
 d03ae28:	e1bffa87 	ldb	r6,-22(fp)
 d03ae2c:	01034174 	movhi	r4,3333
 d03ae30:	21039d04 	addi	r4,r4,3700
 d03ae34:	d0028a00 	call	d0028a0 <printf>
    
    alt_32 timeout = 0;
 d03ae38:	e03ff915 	stw	zero,-28(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 d03ae3c:	00001506 	br	d03ae94 <alt_tse_phy_restart_an+0x158>
        if(timeout++ > timeout_threshold) {
 d03ae40:	e0fff917 	ldw	r3,-28(fp)
 d03ae44:	e0bffe17 	ldw	r2,-8(fp)
 d03ae48:	10c5803a 	cmpltu	r2,r2,r3
 d03ae4c:	1007883a 	mov	r3,r2
 d03ae50:	e0bff917 	ldw	r2,-28(fp)
 d03ae54:	10800044 	addi	r2,r2,1
 d03ae58:	e0bff915 	stw	r2,-28(fp)
 d03ae5c:	18803fcc 	andi	r2,r3,255
 d03ae60:	1005003a 	cmpeq	r2,r2,zero
 d03ae64:	10000b1e 	bne	r2,zero,d03ae94 <alt_tse_phy_restart_an+0x158>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 d03ae68:	e17ffa47 	ldb	r5,-23(fp)
 d03ae6c:	e1bffa87 	ldb	r6,-22(fp)
 d03ae70:	01034174 	movhi	r4,3333
 d03ae74:	2103af04 	addi	r4,r4,3772
 d03ae78:	d0028a00 	call	d0028a0 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03ae7c:	e17ffa03 	ldbu	r5,-24(fp)
 d03ae80:	e13ffd17 	ldw	r4,-12(fp)
 d03ae84:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 d03ae88:	00bfffc4 	movi	r2,-1
 d03ae8c:	e0bfff15 	stw	r2,-4(fp)
 d03ae90:	00001006 	br	d03aed4 <alt_tse_phy_restart_an+0x198>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 d03ae94:	e13ffd17 	ldw	r4,-12(fp)
 d03ae98:	01400044 	movi	r5,1
 d03ae9c:	01800144 	movi	r6,5
 d03aea0:	01c00044 	movi	r7,1
 d03aea4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03aea8:	1005003a 	cmpeq	r2,r2,zero
 d03aeac:	103fe41e 	bne	r2,zero,d03ae40 <alt_tse_phy_restart_an+0x104>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 d03aeb0:	e17ffa47 	ldb	r5,-23(fp)
 d03aeb4:	e1bffa87 	ldb	r6,-22(fp)
 d03aeb8:	01034174 	movhi	r4,3333
 d03aebc:	2103bb04 	addi	r4,r4,3820
 d03aec0:	d0028a00 	call	d0028a0 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03aec4:	e17ffa03 	ldbu	r5,-24(fp)
 d03aec8:	e13ffd17 	ldw	r4,-12(fp)
 d03aecc:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 d03aed0:	e03fff15 	stw	zero,-4(fp)
 d03aed4:	e0bfff17 	ldw	r2,-4(fp)
}
 d03aed8:	e037883a 	mov	sp,fp
 d03aedc:	dfc00117 	ldw	ra,4(sp)
 d03aee0:	df000017 	ldw	fp,0(sp)
 d03aee4:	dec00204 	addi	sp,sp,8
 d03aee8:	f800283a 	ret

0d03aeec <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 d03aeec:	defff804 	addi	sp,sp,-32
 d03aef0:	dfc00715 	stw	ra,28(sp)
 d03aef4:	df000615 	stw	fp,24(sp)
 d03aef8:	df000604 	addi	fp,sp,24
 d03aefc:	e13ffd15 	stw	r4,-12(fp)
 d03af00:	e17ffe15 	stw	r5,-8(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d03af04:	e0bffd17 	ldw	r2,-12(fp)
 d03af08:	10800617 	ldw	r2,24(r2)
 d03af0c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d03af10:	e0bffc17 	ldw	r2,-16(fp)
 d03af14:	10800317 	ldw	r2,12(r2)
 d03af18:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03af1c:	e13ffc17 	ldw	r4,-16(fp)
 d03af20:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03af24:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 d03af28:	e13ffb17 	ldw	r4,-20(fp)
 d03af2c:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03af30:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d03af34:	e13ffd17 	ldw	r4,-12(fp)
 d03af38:	d0396b00 	call	d0396b0 <alt_tse_phy_rd_mdio_addr>
 d03af3c:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d03af40:	e0bffd17 	ldw	r2,-12(fp)
 d03af44:	10800003 	ldbu	r2,0(r2)
 d03af48:	11403fcc 	andi	r5,r2,255
 d03af4c:	e13ffd17 	ldw	r4,-12(fp)
 d03af50:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 d03af54:	e17ffa47 	ldb	r5,-23(fp)
 d03af58:	e1bffa87 	ldb	r6,-22(fp)
 d03af5c:	01034174 	movhi	r4,3333
 d03af60:	2103c704 	addi	r4,r4,3868
 d03af64:	d0028a00 	call	d0028a0 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 d03af68:	e13ffd17 	ldw	r4,-12(fp)
 d03af6c:	000b883a 	mov	r5,zero
 d03af70:	01800384 	movi	r6,14
 d03af74:	01c00044 	movi	r7,1
 d03af78:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03af7c:	1004c03a 	cmpne	r2,r2,zero
 d03af80:	1000071e 	bne	r2,zero,d03afa0 <alt_tse_phy_check_link+0xb4>
 d03af84:	e13ffd17 	ldw	r4,-12(fp)
 d03af88:	01400044 	movi	r5,1
 d03af8c:	01800144 	movi	r6,5
 d03af90:	01c00044 	movi	r7,1
 d03af94:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03af98:	1004c03a 	cmpne	r2,r2,zero
 d03af9c:	1000151e 	bne	r2,zero,d03aff4 <alt_tse_phy_check_link+0x108>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 d03afa0:	e17ffa47 	ldb	r5,-23(fp)
 d03afa4:	e1bffa87 	ldb	r6,-22(fp)
 d03afa8:	01034174 	movhi	r4,3333
 d03afac:	2103d204 	addi	r4,r4,3912
 d03afb0:	d0028a00 	call	d0028a0 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 d03afb4:	e13ffd17 	ldw	r4,-12(fp)
 d03afb8:	e17ffe17 	ldw	r5,-8(fp)
 d03afbc:	d03ad3c0 	call	d03ad3c <alt_tse_phy_restart_an>
 d03afc0:	10bfffd8 	cmpnei	r2,r2,-1
 d03afc4:	10000b1e 	bne	r2,zero,d03aff4 <alt_tse_phy_check_link+0x108>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 d03afc8:	e17ffa47 	ldb	r5,-23(fp)
 d03afcc:	e1bffa87 	ldb	r6,-22(fp)
 d03afd0:	01034174 	movhi	r4,3333
 d03afd4:	2103e604 	addi	r4,r4,3992
 d03afd8:	d0028a00 	call	d0028a0 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03afdc:	e17ffa03 	ldbu	r5,-24(fp)
 d03afe0:	e13ffd17 	ldw	r4,-12(fp)
 d03afe4:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 d03afe8:	00bfffc4 	movi	r2,-1
 d03afec:	e0bfff15 	stw	r2,-4(fp)
 d03aff0:	00000906 	br	d03b018 <alt_tse_phy_check_link+0x12c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 d03aff4:	e17ffa47 	ldb	r5,-23(fp)
 d03aff8:	e1bffa87 	ldb	r6,-22(fp)
 d03affc:	01034174 	movhi	r4,3333
 d03b000:	2103f304 	addi	r4,r4,4044
 d03b004:	d0028a00 	call	d0028a0 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03b008:	e17ffa03 	ldbu	r5,-24(fp)
 d03b00c:	e13ffd17 	ldw	r4,-12(fp)
 d03b010:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 d03b014:	e03fff15 	stw	zero,-4(fp)
 d03b018:	e0bfff17 	ldw	r2,-4(fp)
}
 d03b01c:	e037883a 	mov	sp,fp
 d03b020:	dfc00117 	ldw	ra,4(sp)
 d03b024:	df000017 	ldw	fp,0(sp)
 d03b028:	dec00204 	addi	sp,sp,8
 d03b02c:	f800283a 	ret

0d03b030 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 d03b030:	defff804 	addi	sp,sp,-32
 d03b034:	dfc00715 	stw	ra,28(sp)
 d03b038:	df000615 	stw	fp,24(sp)
 d03b03c:	df000604 	addi	fp,sp,24
 d03b040:	e13ffe15 	stw	r4,-8(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 d03b044:	e03ffd15 	stw	zero,-12(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d03b048:	e0bffe17 	ldw	r2,-8(fp)
 d03b04c:	10800617 	ldw	r2,24(r2)
 d03b050:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d03b054:	e0bffc17 	ldw	r2,-16(fp)
 d03b058:	10800317 	ldw	r2,12(r2)
 d03b05c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03b060:	e13ffc17 	ldw	r4,-16(fp)
 d03b064:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03b068:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 d03b06c:	e13ffb17 	ldw	r4,-20(fp)
 d03b070:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03b074:	e0bffa45 	stb	r2,-23(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d03b078:	e13ffe17 	ldw	r4,-8(fp)
 d03b07c:	d0396b00 	call	d0396b0 <alt_tse_phy_rd_mdio_addr>
 d03b080:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d03b084:	e0bffe17 	ldw	r2,-8(fp)
 d03b088:	10800003 	ldbu	r2,0(r2)
 d03b08c:	11403fcc 	andi	r5,r2,255
 d03b090:	e13ffe17 	ldw	r4,-8(fp)
 d03b094:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 d03b098:	e13ffe17 	ldw	r4,-8(fp)
 d03b09c:	01400044 	movi	r5,1
 d03b0a0:	018000c4 	movi	r6,3
 d03b0a4:	01c00044 	movi	r7,1
 d03b0a8:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b0ac:	1004c03a 	cmpne	r2,r2,zero
 d03b0b0:	10000b1e 	bne	r2,zero,d03b0e0 <alt_tse_phy_get_cap+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 d03b0b4:	e17ffa47 	ldb	r5,-23(fp)
 d03b0b8:	e1bffa87 	ldb	r6,-22(fp)
 d03b0bc:	01034174 	movhi	r4,3333
 d03b0c0:	21038d04 	addi	r4,r4,3636
 d03b0c4:	d0028a00 	call	d0028a0 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03b0c8:	e17ffa03 	ldbu	r5,-24(fp)
 d03b0cc:	e13ffe17 	ldw	r4,-8(fp)
 d03b0d0:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 d03b0d4:	00bfff84 	movi	r2,-2
 d03b0d8:	e0bfff15 	stw	r2,-4(fp)
 d03b0dc:	00011e06 	br	d03b558 <alt_tse_phy_get_cap+0x528>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d03b0e0:	e13ffe17 	ldw	r4,-8(fp)
 d03b0e4:	01400134 	movhi	r5,4
 d03b0e8:	29742404 	addi	r5,r5,-12144
 d03b0ec:	d03ad3c0 	call	d03ad3c <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 d03b0f0:	e13ffe17 	ldw	r4,-8(fp)
 d03b0f4:	01400044 	movi	r5,1
 d03b0f8:	01800144 	movi	r6,5
 d03b0fc:	01c00044 	movi	r7,1
 d03b100:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b104:	1004c03a 	cmpne	r2,r2,zero
 d03b108:	1000021e 	bne	r2,zero,d03b114 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 d03b10c:	00bfffc4 	movi	r2,-1
 d03b110:	e0bffd15 	stw	r2,-12(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 d03b114:	e13ffe17 	ldw	r4,-8(fp)
 d03b118:	014003c4 	movi	r5,15
 d03b11c:	018003c4 	movi	r6,15
 d03b120:	01c00044 	movi	r7,1
 d03b124:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b128:	1007883a 	mov	r3,r2
 d03b12c:	e0bffe17 	ldw	r2,-8(fp)
 d03b130:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 d03b134:	e13ffe17 	ldw	r4,-8(fp)
 d03b138:	014003c4 	movi	r5,15
 d03b13c:	01800384 	movi	r6,14
 d03b140:	01c00044 	movi	r7,1
 d03b144:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b148:	1007883a 	mov	r3,r2
 d03b14c:	e0bffe17 	ldw	r2,-8(fp)
 d03b150:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 d03b154:	e13ffe17 	ldw	r4,-8(fp)
 d03b158:	014003c4 	movi	r5,15
 d03b15c:	01800344 	movi	r6,13
 d03b160:	01c00044 	movi	r7,1
 d03b164:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b168:	1007883a 	mov	r3,r2
 d03b16c:	e0bffe17 	ldw	r2,-8(fp)
 d03b170:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 d03b174:	e13ffe17 	ldw	r4,-8(fp)
 d03b178:	014003c4 	movi	r5,15
 d03b17c:	01800304 	movi	r6,12
 d03b180:	01c00044 	movi	r7,1
 d03b184:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b188:	1007883a 	mov	r3,r2
 d03b18c:	e0bffe17 	ldw	r2,-8(fp)
 d03b190:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 d03b194:	e13ffe17 	ldw	r4,-8(fp)
 d03b198:	01400044 	movi	r5,1
 d03b19c:	018003c4 	movi	r6,15
 d03b1a0:	01c00044 	movi	r7,1
 d03b1a4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b1a8:	1007883a 	mov	r3,r2
 d03b1ac:	e0bffe17 	ldw	r2,-8(fp)
 d03b1b0:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 d03b1b4:	e13ffe17 	ldw	r4,-8(fp)
 d03b1b8:	01400044 	movi	r5,1
 d03b1bc:	01800384 	movi	r6,14
 d03b1c0:	01c00044 	movi	r7,1
 d03b1c4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b1c8:	1007883a 	mov	r3,r2
 d03b1cc:	e0bffe17 	ldw	r2,-8(fp)
 d03b1d0:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 d03b1d4:	e13ffe17 	ldw	r4,-8(fp)
 d03b1d8:	01400044 	movi	r5,1
 d03b1dc:	01800344 	movi	r6,13
 d03b1e0:	01c00044 	movi	r7,1
 d03b1e4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b1e8:	1007883a 	mov	r3,r2
 d03b1ec:	e0bffe17 	ldw	r2,-8(fp)
 d03b1f0:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 d03b1f4:	e13ffe17 	ldw	r4,-8(fp)
 d03b1f8:	01400044 	movi	r5,1
 d03b1fc:	01800284 	movi	r6,10
 d03b200:	01c00044 	movi	r7,1
 d03b204:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b208:	1007883a 	mov	r3,r2
 d03b20c:	e0bffe17 	ldw	r2,-8(fp)
 d03b210:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 d03b214:	e13ffe17 	ldw	r4,-8(fp)
 d03b218:	01400044 	movi	r5,1
 d03b21c:	01800244 	movi	r6,9
 d03b220:	01c00044 	movi	r7,1
 d03b224:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b228:	1007883a 	mov	r3,r2
 d03b22c:	e0bffe17 	ldw	r2,-8(fp)
 d03b230:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 d03b234:	e13ffe17 	ldw	r4,-8(fp)
 d03b238:	01400044 	movi	r5,1
 d03b23c:	01800304 	movi	r6,12
 d03b240:	01c00044 	movi	r7,1
 d03b244:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b248:	1007883a 	mov	r3,r2
 d03b24c:	e0bffe17 	ldw	r2,-8(fp)
 d03b250:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 d03b254:	e13ffe17 	ldw	r4,-8(fp)
 d03b258:	01400044 	movi	r5,1
 d03b25c:	018002c4 	movi	r6,11
 d03b260:	01c00044 	movi	r7,1
 d03b264:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b268:	1007883a 	mov	r3,r2
 d03b26c:	e0bffe17 	ldw	r2,-8(fp)
 d03b270:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 d03b274:	e13ffe17 	ldw	r4,-8(fp)
 d03b278:	01400284 	movi	r5,10
 d03b27c:	018002c4 	movi	r6,11
 d03b280:	01c00044 	movi	r7,1
 d03b284:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b288:	1007883a 	mov	r3,r2
 d03b28c:	e0bffe17 	ldw	r2,-8(fp)
 d03b290:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 d03b294:	e13ffe17 	ldw	r4,-8(fp)
 d03b298:	01400284 	movi	r5,10
 d03b29c:	01800284 	movi	r6,10
 d03b2a0:	01c00044 	movi	r7,1
 d03b2a4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b2a8:	1007883a 	mov	r3,r2
 d03b2ac:	e0bffe17 	ldw	r2,-8(fp)
 d03b2b0:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 d03b2b4:	e13ffe17 	ldw	r4,-8(fp)
 d03b2b8:	01400144 	movi	r5,5
 d03b2bc:	01800244 	movi	r6,9
 d03b2c0:	01c00044 	movi	r7,1
 d03b2c4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b2c8:	1007883a 	mov	r3,r2
 d03b2cc:	e0bffe17 	ldw	r2,-8(fp)
 d03b2d0:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 d03b2d4:	e13ffe17 	ldw	r4,-8(fp)
 d03b2d8:	01400144 	movi	r5,5
 d03b2dc:	01800204 	movi	r6,8
 d03b2e0:	01c00044 	movi	r7,1
 d03b2e4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b2e8:	1007883a 	mov	r3,r2
 d03b2ec:	e0bffe17 	ldw	r2,-8(fp)
 d03b2f0:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 d03b2f4:	e13ffe17 	ldw	r4,-8(fp)
 d03b2f8:	01400144 	movi	r5,5
 d03b2fc:	018001c4 	movi	r6,7
 d03b300:	01c00044 	movi	r7,1
 d03b304:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b308:	1007883a 	mov	r3,r2
 d03b30c:	e0bffe17 	ldw	r2,-8(fp)
 d03b310:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 d03b314:	e13ffe17 	ldw	r4,-8(fp)
 d03b318:	01400144 	movi	r5,5
 d03b31c:	01800184 	movi	r6,6
 d03b320:	01c00044 	movi	r7,1
 d03b324:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b328:	1007883a 	mov	r3,r2
 d03b32c:	e0bffe17 	ldw	r2,-8(fp)
 d03b330:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 d03b334:	e13ffe17 	ldw	r4,-8(fp)
 d03b338:	01400144 	movi	r5,5
 d03b33c:	01800144 	movi	r6,5
 d03b340:	01c00044 	movi	r7,1
 d03b344:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b348:	1007883a 	mov	r3,r2
 d03b34c:	e0bffe17 	ldw	r2,-8(fp)
 d03b350:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 d03b354:	e17ffa47 	ldb	r5,-23(fp)
 d03b358:	e1bffa87 	ldb	r6,-22(fp)
 d03b35c:	01034174 	movhi	r4,3333
 d03b360:	2103fe04 	addi	r4,r4,4088
 d03b364:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 d03b368:	e0bffe17 	ldw	r2,-8(fp)
 d03b36c:	10800043 	ldbu	r2,1(r2)
 d03b370:	11403fcc 	andi	r5,r2,255
 d03b374:	01034174 	movhi	r4,3333
 d03b378:	21040904 	addi	r4,r4,4132
 d03b37c:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 d03b380:	e0bffe17 	ldw	r2,-8(fp)
 d03b384:	10800083 	ldbu	r2,2(r2)
 d03b388:	11403fcc 	andi	r5,r2,255
 d03b38c:	01034174 	movhi	r4,3333
 d03b390:	21041304 	addi	r4,r4,4172
 d03b394:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 d03b398:	e0bffe17 	ldw	r2,-8(fp)
 d03b39c:	108000c3 	ldbu	r2,3(r2)
 d03b3a0:	11403fcc 	andi	r5,r2,255
 d03b3a4:	01034174 	movhi	r4,3333
 d03b3a8:	21041d04 	addi	r4,r4,4212
 d03b3ac:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 d03b3b0:	e0bffe17 	ldw	r2,-8(fp)
 d03b3b4:	10800103 	ldbu	r2,4(r2)
 d03b3b8:	11403fcc 	andi	r5,r2,255
 d03b3bc:	01034174 	movhi	r4,3333
 d03b3c0:	21042704 	addi	r4,r4,4252
 d03b3c4:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 d03b3c8:	e0bffe17 	ldw	r2,-8(fp)
 d03b3cc:	10800143 	ldbu	r2,5(r2)
 d03b3d0:	11403fcc 	andi	r5,r2,255
 d03b3d4:	01034174 	movhi	r4,3333
 d03b3d8:	21043104 	addi	r4,r4,4292
 d03b3dc:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 d03b3e0:	e0bffe17 	ldw	r2,-8(fp)
 d03b3e4:	10800183 	ldbu	r2,6(r2)
 d03b3e8:	11403fcc 	andi	r5,r2,255
 d03b3ec:	01034174 	movhi	r4,3333
 d03b3f0:	21043b04 	addi	r4,r4,4332
 d03b3f4:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 d03b3f8:	e0bffe17 	ldw	r2,-8(fp)
 d03b3fc:	108001c3 	ldbu	r2,7(r2)
 d03b400:	11403fcc 	andi	r5,r2,255
 d03b404:	01034174 	movhi	r4,3333
 d03b408:	21044504 	addi	r4,r4,4372
 d03b40c:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 d03b410:	e0bffe17 	ldw	r2,-8(fp)
 d03b414:	10800203 	ldbu	r2,8(r2)
 d03b418:	11403fcc 	andi	r5,r2,255
 d03b41c:	01034174 	movhi	r4,3333
 d03b420:	21044f04 	addi	r4,r4,4412
 d03b424:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 d03b428:	e0bffe17 	ldw	r2,-8(fp)
 d03b42c:	10800243 	ldbu	r2,9(r2)
 d03b430:	11403fcc 	andi	r5,r2,255
 d03b434:	01034174 	movhi	r4,3333
 d03b438:	21045904 	addi	r4,r4,4452
 d03b43c:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 d03b440:	e0bffe17 	ldw	r2,-8(fp)
 d03b444:	10800283 	ldbu	r2,10(r2)
 d03b448:	11403fcc 	andi	r5,r2,255
 d03b44c:	01034174 	movhi	r4,3333
 d03b450:	21046304 	addi	r4,r4,4492
 d03b454:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 d03b458:	e0bffe17 	ldw	r2,-8(fp)
 d03b45c:	108002c3 	ldbu	r2,11(r2)
 d03b460:	11403fcc 	andi	r5,r2,255
 d03b464:	01034174 	movhi	r4,3333
 d03b468:	21046d04 	addi	r4,r4,4532
 d03b46c:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "\n");
 d03b470:	01034174 	movhi	r4,3333
 d03b474:	2102d304 	addi	r4,r4,2892
 d03b478:	d0372880 	call	d037288 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 d03b47c:	e17ffa47 	ldb	r5,-23(fp)
 d03b480:	e1bffa87 	ldb	r6,-22(fp)
 d03b484:	01034174 	movhi	r4,3333
 d03b488:	21047704 	addi	r4,r4,4572
 d03b48c:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 d03b490:	e0bffe17 	ldw	r2,-8(fp)
 d03b494:	10800303 	ldbu	r2,12(r2)
 d03b498:	11403fcc 	andi	r5,r2,255
 d03b49c:	01034174 	movhi	r4,3333
 d03b4a0:	21041d04 	addi	r4,r4,4212
 d03b4a4:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 d03b4a8:	e0bffe17 	ldw	r2,-8(fp)
 d03b4ac:	10800343 	ldbu	r2,13(r2)
 d03b4b0:	11403fcc 	andi	r5,r2,255
 d03b4b4:	01034174 	movhi	r4,3333
 d03b4b8:	21042704 	addi	r4,r4,4252
 d03b4bc:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 d03b4c0:	e0bffe17 	ldw	r2,-8(fp)
 d03b4c4:	10800383 	ldbu	r2,14(r2)
 d03b4c8:	11403fcc 	andi	r5,r2,255
 d03b4cc:	01034174 	movhi	r4,3333
 d03b4d0:	21043104 	addi	r4,r4,4292
 d03b4d4:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 d03b4d8:	e0bffe17 	ldw	r2,-8(fp)
 d03b4dc:	108003c3 	ldbu	r2,15(r2)
 d03b4e0:	11403fcc 	andi	r5,r2,255
 d03b4e4:	01034174 	movhi	r4,3333
 d03b4e8:	21048404 	addi	r4,r4,4624
 d03b4ec:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 d03b4f0:	e0bffe17 	ldw	r2,-8(fp)
 d03b4f4:	10800403 	ldbu	r2,16(r2)
 d03b4f8:	11403fcc 	andi	r5,r2,255
 d03b4fc:	01034174 	movhi	r4,3333
 d03b500:	21048e04 	addi	r4,r4,4664
 d03b504:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 d03b508:	e0bffe17 	ldw	r2,-8(fp)
 d03b50c:	10800443 	ldbu	r2,17(r2)
 d03b510:	11403fcc 	andi	r5,r2,255
 d03b514:	01034174 	movhi	r4,3333
 d03b518:	21049804 	addi	r4,r4,4704
 d03b51c:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 d03b520:	e0bffe17 	ldw	r2,-8(fp)
 d03b524:	10800483 	ldbu	r2,18(r2)
 d03b528:	11403fcc 	andi	r5,r2,255
 d03b52c:	01034174 	movhi	r4,3333
 d03b530:	2104a204 	addi	r4,r4,4744
 d03b534:	d0372880 	call	d037288 <no_printf>
    tse_dprintf(6, "\n");
 d03b538:	01034174 	movhi	r4,3333
 d03b53c:	2102d304 	addi	r4,r4,2892
 d03b540:	d0372880 	call	d037288 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03b544:	e17ffa03 	ldbu	r5,-24(fp)
 d03b548:	e13ffe17 	ldw	r4,-8(fp)
 d03b54c:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 d03b550:	e0bffd17 	ldw	r2,-12(fp)
 d03b554:	e0bfff15 	stw	r2,-4(fp)
 d03b558:	e0bfff17 	ldw	r2,-4(fp)
    
}
 d03b55c:	e037883a 	mov	sp,fp
 d03b560:	dfc00117 	ldw	ra,4(sp)
 d03b564:	df000017 	ldw	fp,0(sp)
 d03b568:	dec00204 	addi	sp,sp,8
 d03b56c:	f800283a 	ret

0d03b570 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 d03b570:	defff704 	addi	sp,sp,-36
 d03b574:	dfc00815 	stw	ra,32(sp)
 d03b578:	df000715 	stw	fp,28(sp)
 d03b57c:	df000704 	addi	fp,sp,28
 d03b580:	e13ffe15 	stw	r4,-8(fp)
 d03b584:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d03b588:	e0bffe17 	ldw	r2,-8(fp)
 d03b58c:	10800617 	ldw	r2,24(r2)
 d03b590:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d03b594:	e0bffc17 	ldw	r2,-16(fp)
 d03b598:	10800317 	ldw	r2,12(r2)
 d03b59c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03b5a0:	e13ffc17 	ldw	r4,-16(fp)
 d03b5a4:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03b5a8:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03b5ac:	e13ffb17 	ldw	r4,-20(fp)
 d03b5b0:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03b5b4:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d03b5b8:	e13ffe17 	ldw	r4,-8(fp)
 d03b5bc:	d0396b00 	call	d0396b0 <alt_tse_phy_rd_mdio_addr>
 d03b5c0:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d03b5c4:	e0bffe17 	ldw	r2,-8(fp)
 d03b5c8:	10800003 	ldbu	r2,0(r2)
 d03b5cc:	11403fcc 	andi	r5,r2,255
 d03b5d0:	e13ffe17 	ldw	r4,-8(fp)
 d03b5d4:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 d03b5d8:	e0bfff03 	ldbu	r2,-4(fp)
 d03b5dc:	1005003a 	cmpeq	r2,r2,zero
 d03b5e0:	1000271e 	bne	r2,zero,d03b680 <alt_tse_phy_set_adv_1000+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 d03b5e4:	e13ffe17 	ldw	r4,-8(fp)
 d03b5e8:	014003c4 	movi	r5,15
 d03b5ec:	01800344 	movi	r6,13
 d03b5f0:	01c00044 	movi	r7,1
 d03b5f4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b5f8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 d03b5fc:	e0bffd03 	ldbu	r2,-12(fp)
 d03b600:	d8800015 	stw	r2,0(sp)
 d03b604:	e13ffe17 	ldw	r4,-8(fp)
 d03b608:	01400244 	movi	r5,9
 d03b60c:	01800244 	movi	r6,9
 d03b610:	01c00044 	movi	r7,1
 d03b614:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d03b618:	e17ffa47 	ldb	r5,-23(fp)
 d03b61c:	e1bffa87 	ldb	r6,-22(fp)
 d03b620:	e1fffd03 	ldbu	r7,-12(fp)
 d03b624:	01034174 	movhi	r4,3333
 d03b628:	2104ac04 	addi	r4,r4,4784
 d03b62c:	d0372880 	call	d037288 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 d03b630:	e13ffe17 	ldw	r4,-8(fp)
 d03b634:	014003c4 	movi	r5,15
 d03b638:	01800304 	movi	r6,12
 d03b63c:	01c00044 	movi	r7,1
 d03b640:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b644:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 d03b648:	e0bffd03 	ldbu	r2,-12(fp)
 d03b64c:	d8800015 	stw	r2,0(sp)
 d03b650:	e13ffe17 	ldw	r4,-8(fp)
 d03b654:	01400244 	movi	r5,9
 d03b658:	01800204 	movi	r6,8
 d03b65c:	01c00044 	movi	r7,1
 d03b660:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d03b664:	e17ffa47 	ldb	r5,-23(fp)
 d03b668:	e1bffa87 	ldb	r6,-22(fp)
 d03b66c:	e1fffd03 	ldbu	r7,-12(fp)
 d03b670:	01034174 	movhi	r4,3333
 d03b674:	2104bf04 	addi	r4,r4,4860
 d03b678:	d0372880 	call	d037288 <no_printf>
 d03b67c:	00001806 	br	d03b6e0 <alt_tse_phy_set_adv_1000+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 d03b680:	d8000015 	stw	zero,0(sp)
 d03b684:	e13ffe17 	ldw	r4,-8(fp)
 d03b688:	01400244 	movi	r5,9
 d03b68c:	01800244 	movi	r6,9
 d03b690:	01c00044 	movi	r7,1
 d03b694:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d03b698:	e17ffa47 	ldb	r5,-23(fp)
 d03b69c:	e1bffa87 	ldb	r6,-22(fp)
 d03b6a0:	01034174 	movhi	r4,3333
 d03b6a4:	2104ac04 	addi	r4,r4,4784
 d03b6a8:	000f883a 	mov	r7,zero
 d03b6ac:	d0372880 	call	d037288 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 d03b6b0:	d8000015 	stw	zero,0(sp)
 d03b6b4:	e13ffe17 	ldw	r4,-8(fp)
 d03b6b8:	01400244 	movi	r5,9
 d03b6bc:	01800204 	movi	r6,8
 d03b6c0:	01c00044 	movi	r7,1
 d03b6c4:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d03b6c8:	e17ffa47 	ldb	r5,-23(fp)
 d03b6cc:	e1bffa87 	ldb	r6,-22(fp)
 d03b6d0:	01034174 	movhi	r4,3333
 d03b6d4:	2104d204 	addi	r4,r4,4936
 d03b6d8:	000f883a 	mov	r7,zero
 d03b6dc:	d0372880 	call	d037288 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 d03b6e0:	e17ffa03 	ldbu	r5,-24(fp)
 d03b6e4:	e13ffe17 	ldw	r4,-8(fp)
 d03b6e8:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 d03b6ec:	0005883a 	mov	r2,zero
}
 d03b6f0:	e037883a 	mov	sp,fp
 d03b6f4:	dfc00117 	ldw	ra,4(sp)
 d03b6f8:	df000017 	ldw	fp,0(sp)
 d03b6fc:	dec00204 	addi	sp,sp,8
 d03b700:	f800283a 	ret

0d03b704 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 d03b704:	defff704 	addi	sp,sp,-36
 d03b708:	dfc00815 	stw	ra,32(sp)
 d03b70c:	df000715 	stw	fp,28(sp)
 d03b710:	df000704 	addi	fp,sp,28
 d03b714:	e13ffe15 	stw	r4,-8(fp)
 d03b718:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d03b71c:	e0bffe17 	ldw	r2,-8(fp)
 d03b720:	10800617 	ldw	r2,24(r2)
 d03b724:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d03b728:	e0bffc17 	ldw	r2,-16(fp)
 d03b72c:	10800317 	ldw	r2,12(r2)
 d03b730:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03b734:	e13ffc17 	ldw	r4,-16(fp)
 d03b738:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03b73c:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03b740:	e13ffb17 	ldw	r4,-20(fp)
 d03b744:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03b748:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d03b74c:	e13ffe17 	ldw	r4,-8(fp)
 d03b750:	d0396b00 	call	d0396b0 <alt_tse_phy_rd_mdio_addr>
 d03b754:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d03b758:	e0bffe17 	ldw	r2,-8(fp)
 d03b75c:	10800003 	ldbu	r2,0(r2)
 d03b760:	11403fcc 	andi	r5,r2,255
 d03b764:	e13ffe17 	ldw	r4,-8(fp)
 d03b768:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 d03b76c:	e0bfff03 	ldbu	r2,-4(fp)
 d03b770:	1005003a 	cmpeq	r2,r2,zero
 d03b774:	10003a1e 	bne	r2,zero,d03b860 <alt_tse_phy_set_adv_100+0x15c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 d03b778:	e13ffe17 	ldw	r4,-8(fp)
 d03b77c:	01400044 	movi	r5,1
 d03b780:	018003c4 	movi	r6,15
 d03b784:	01c00044 	movi	r7,1
 d03b788:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b78c:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 d03b790:	e0bffd03 	ldbu	r2,-12(fp)
 d03b794:	d8800015 	stw	r2,0(sp)
 d03b798:	e13ffe17 	ldw	r4,-8(fp)
 d03b79c:	01400104 	movi	r5,4
 d03b7a0:	01800244 	movi	r6,9
 d03b7a4:	01c00044 	movi	r7,1
 d03b7a8:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 d03b7ac:	e17ffa47 	ldb	r5,-23(fp)
 d03b7b0:	e1bffa87 	ldb	r6,-22(fp)
 d03b7b4:	e1fffd03 	ldbu	r7,-12(fp)
 d03b7b8:	01034174 	movhi	r4,3333
 d03b7bc:	2104e404 	addi	r4,r4,5008
 d03b7c0:	d0372880 	call	d037288 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 d03b7c4:	e13ffe17 	ldw	r4,-8(fp)
 d03b7c8:	01400044 	movi	r5,1
 d03b7cc:	01800384 	movi	r6,14
 d03b7d0:	01c00044 	movi	r7,1
 d03b7d4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b7d8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 d03b7dc:	e0bffd03 	ldbu	r2,-12(fp)
 d03b7e0:	d8800015 	stw	r2,0(sp)
 d03b7e4:	e13ffe17 	ldw	r4,-8(fp)
 d03b7e8:	01400104 	movi	r5,4
 d03b7ec:	01800204 	movi	r6,8
 d03b7f0:	01c00044 	movi	r7,1
 d03b7f4:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d03b7f8:	e17ffa47 	ldb	r5,-23(fp)
 d03b7fc:	e1bffa87 	ldb	r6,-22(fp)
 d03b800:	e1fffd03 	ldbu	r7,-12(fp)
 d03b804:	01034174 	movhi	r4,3333
 d03b808:	2104f404 	addi	r4,r4,5072
 d03b80c:	d0372880 	call	d037288 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 d03b810:	e13ffe17 	ldw	r4,-8(fp)
 d03b814:	01400044 	movi	r5,1
 d03b818:	01800344 	movi	r6,13
 d03b81c:	01c00044 	movi	r7,1
 d03b820:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b824:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 d03b828:	e0bffd03 	ldbu	r2,-12(fp)
 d03b82c:	d8800015 	stw	r2,0(sp)
 d03b830:	e13ffe17 	ldw	r4,-8(fp)
 d03b834:	01400104 	movi	r5,4
 d03b838:	018001c4 	movi	r6,7
 d03b83c:	01c00044 	movi	r7,1
 d03b840:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d03b844:	e17ffa47 	ldb	r5,-23(fp)
 d03b848:	e1bffa87 	ldb	r6,-22(fp)
 d03b84c:	e1fffd03 	ldbu	r7,-12(fp)
 d03b850:	01034174 	movhi	r4,3333
 d03b854:	21050704 	addi	r4,r4,5148
 d03b858:	d0372880 	call	d037288 <no_printf>
 d03b85c:	00002406 	br	d03b8f0 <alt_tse_phy_set_adv_100+0x1ec>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 d03b860:	d8000015 	stw	zero,0(sp)
 d03b864:	e13ffe17 	ldw	r4,-8(fp)
 d03b868:	01400104 	movi	r5,4
 d03b86c:	01800244 	movi	r6,9
 d03b870:	01c00044 	movi	r7,1
 d03b874:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 d03b878:	e17ffa47 	ldb	r5,-23(fp)
 d03b87c:	e1bffa87 	ldb	r6,-22(fp)
 d03b880:	01034174 	movhi	r4,3333
 d03b884:	2104e404 	addi	r4,r4,5008
 d03b888:	000f883a 	mov	r7,zero
 d03b88c:	d0372880 	call	d037288 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 d03b890:	d8000015 	stw	zero,0(sp)
 d03b894:	e13ffe17 	ldw	r4,-8(fp)
 d03b898:	01400104 	movi	r5,4
 d03b89c:	01800204 	movi	r6,8
 d03b8a0:	01c00044 	movi	r7,1
 d03b8a4:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d03b8a8:	e17ffa47 	ldb	r5,-23(fp)
 d03b8ac:	e1bffa87 	ldb	r6,-22(fp)
 d03b8b0:	01034174 	movhi	r4,3333
 d03b8b4:	2104f404 	addi	r4,r4,5072
 d03b8b8:	000f883a 	mov	r7,zero
 d03b8bc:	d0372880 	call	d037288 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 d03b8c0:	d8000015 	stw	zero,0(sp)
 d03b8c4:	e13ffe17 	ldw	r4,-8(fp)
 d03b8c8:	01400104 	movi	r5,4
 d03b8cc:	018001c4 	movi	r6,7
 d03b8d0:	01c00044 	movi	r7,1
 d03b8d4:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d03b8d8:	e17ffa47 	ldb	r5,-23(fp)
 d03b8dc:	e1bffa87 	ldb	r6,-22(fp)
 d03b8e0:	01034174 	movhi	r4,3333
 d03b8e4:	21050704 	addi	r4,r4,5148
 d03b8e8:	000f883a 	mov	r7,zero
 d03b8ec:	d0372880 	call	d037288 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 d03b8f0:	e17ffa03 	ldbu	r5,-24(fp)
 d03b8f4:	e13ffe17 	ldw	r4,-8(fp)
 d03b8f8:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 d03b8fc:	0005883a 	mov	r2,zero
}
 d03b900:	e037883a 	mov	sp,fp
 d03b904:	dfc00117 	ldw	ra,4(sp)
 d03b908:	df000017 	ldw	fp,0(sp)
 d03b90c:	dec00204 	addi	sp,sp,8
 d03b910:	f800283a 	ret

0d03b914 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 d03b914:	defff504 	addi	sp,sp,-44
 d03b918:	dfc00a15 	stw	ra,40(sp)
 d03b91c:	df000915 	stw	fp,36(sp)
 d03b920:	df000904 	addi	fp,sp,36
 d03b924:	e13ffe15 	stw	r4,-8(fp)
 d03b928:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d03b92c:	e0bffe17 	ldw	r2,-8(fp)
 d03b930:	10800617 	ldw	r2,24(r2)
 d03b934:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d03b938:	e0bffc17 	ldw	r2,-16(fp)
 d03b93c:	10800317 	ldw	r2,12(r2)
 d03b940:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03b944:	e13ffc17 	ldw	r4,-16(fp)
 d03b948:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03b94c:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03b950:	e13ffb17 	ldw	r4,-20(fp)
 d03b954:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03b958:	e0bff915 	stw	r2,-28(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d03b95c:	e13ffe17 	ldw	r4,-8(fp)
 d03b960:	d0396b00 	call	d0396b0 <alt_tse_phy_rd_mdio_addr>
 d03b964:	e0bff815 	stw	r2,-32(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d03b968:	e0bffe17 	ldw	r2,-8(fp)
 d03b96c:	10800003 	ldbu	r2,0(r2)
 d03b970:	11403fcc 	andi	r5,r2,255
 d03b974:	e13ffe17 	ldw	r4,-8(fp)
 d03b978:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 d03b97c:	e0bfff03 	ldbu	r2,-4(fp)
 d03b980:	1005003a 	cmpeq	r2,r2,zero
 d03b984:	1000271e 	bne	r2,zero,d03ba24 <alt_tse_phy_set_adv_10+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 d03b988:	e13ffe17 	ldw	r4,-8(fp)
 d03b98c:	01400044 	movi	r5,1
 d03b990:	01800304 	movi	r6,12
 d03b994:	01c00044 	movi	r7,1
 d03b998:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b99c:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 d03b9a0:	e0bffd03 	ldbu	r2,-12(fp)
 d03b9a4:	d8800015 	stw	r2,0(sp)
 d03b9a8:	e13ffe17 	ldw	r4,-8(fp)
 d03b9ac:	01400104 	movi	r5,4
 d03b9b0:	01800184 	movi	r6,6
 d03b9b4:	01c00044 	movi	r7,1
 d03b9b8:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d03b9bc:	e1fffd03 	ldbu	r7,-12(fp)
 d03b9c0:	01034174 	movhi	r4,3333
 d03b9c4:	21051a04 	addi	r4,r4,5224
 d03b9c8:	e17ff917 	ldw	r5,-28(fp)
 d03b9cc:	e1bffa17 	ldw	r6,-24(fp)
 d03b9d0:	d0372880 	call	d037288 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 d03b9d4:	e13ffe17 	ldw	r4,-8(fp)
 d03b9d8:	01400044 	movi	r5,1
 d03b9dc:	018002c4 	movi	r6,11
 d03b9e0:	01c00044 	movi	r7,1
 d03b9e4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03b9e8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 d03b9ec:	e0bffd03 	ldbu	r2,-12(fp)
 d03b9f0:	d8800015 	stw	r2,0(sp)
 d03b9f4:	e13ffe17 	ldw	r4,-8(fp)
 d03b9f8:	01400104 	movi	r5,4
 d03b9fc:	01800144 	movi	r6,5
 d03ba00:	01c00044 	movi	r7,1
 d03ba04:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d03ba08:	e1fffd03 	ldbu	r7,-12(fp)
 d03ba0c:	01034174 	movhi	r4,3333
 d03ba10:	21052d04 	addi	r4,r4,5300
 d03ba14:	e17ff917 	ldw	r5,-28(fp)
 d03ba18:	e1bffa17 	ldw	r6,-24(fp)
 d03ba1c:	d0372880 	call	d037288 <no_printf>
 d03ba20:	00001806 	br	d03ba84 <alt_tse_phy_set_adv_10+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 d03ba24:	d8000015 	stw	zero,0(sp)
 d03ba28:	e13ffe17 	ldw	r4,-8(fp)
 d03ba2c:	01400104 	movi	r5,4
 d03ba30:	01800184 	movi	r6,6
 d03ba34:	01c00044 	movi	r7,1
 d03ba38:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d03ba3c:	01034174 	movhi	r4,3333
 d03ba40:	21051a04 	addi	r4,r4,5224
 d03ba44:	e17ff917 	ldw	r5,-28(fp)
 d03ba48:	e1bffa17 	ldw	r6,-24(fp)
 d03ba4c:	000f883a 	mov	r7,zero
 d03ba50:	d0372880 	call	d037288 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 d03ba54:	d8000015 	stw	zero,0(sp)
 d03ba58:	e13ffe17 	ldw	r4,-8(fp)
 d03ba5c:	01400104 	movi	r5,4
 d03ba60:	01800144 	movi	r6,5
 d03ba64:	01c00044 	movi	r7,1
 d03ba68:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d03ba6c:	01034174 	movhi	r4,3333
 d03ba70:	21052d04 	addi	r4,r4,5300
 d03ba74:	e17ff917 	ldw	r5,-28(fp)
 d03ba78:	e1bffa17 	ldw	r6,-24(fp)
 d03ba7c:	000f883a 	mov	r7,zero
 d03ba80:	d0372880 	call	d037288 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d03ba84:	e0bff817 	ldw	r2,-32(fp)
 d03ba88:	11403fcc 	andi	r5,r2,255
 d03ba8c:	e13ffe17 	ldw	r4,-8(fp)
 d03ba90:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 d03ba94:	0005883a 	mov	r2,zero
}
 d03ba98:	e037883a 	mov	sp,fp
 d03ba9c:	dfc00117 	ldw	ra,4(sp)
 d03baa0:	df000017 	ldw	fp,0(sp)
 d03baa4:	dec00204 	addi	sp,sp,8
 d03baa8:	f800283a 	ret

0d03baac <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 d03baac:	defff604 	addi	sp,sp,-40
 d03bab0:	dfc00915 	stw	ra,36(sp)
 d03bab4:	df000815 	stw	fp,32(sp)
 d03bab8:	df000804 	addi	fp,sp,32
 d03babc:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 d03bac0:	00800044 	movi	r2,1
 d03bac4:	e0bffd85 	stb	r2,-10(fp)
	alt_u8 common_100 = 1;
 d03bac8:	00800044 	movi	r2,1
 d03bacc:	e0bffd45 	stb	r2,-11(fp)
	alt_u8 common_10 = 1;
 d03bad0:	00800044 	movi	r2,1
 d03bad4:	e0bffd05 	stb	r2,-12(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 d03bad8:	00800044 	movi	r2,1
 d03badc:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 d03bae0:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_phy_info *pphy = 0;
 d03bae4:	e03ff915 	stw	zero,-28(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03bae8:	e13fff17 	ldw	r4,-4(fp)
 d03baec:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03baf0:	e0bff805 	stb	r2,-32(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 d03baf4:	e03ffe15 	stw	zero,-8(fp)
 d03baf8:	00001d06 	br	d03bb70 <alt_tse_phy_get_common_speed+0xc4>
        pmac_info = pmac_group->pmac_info[i];
 d03bafc:	e0bffe17 	ldw	r2,-8(fp)
 d03bb00:	e0ffff17 	ldw	r3,-4(fp)
 d03bb04:	1085883a 	add	r2,r2,r2
 d03bb08:	1085883a 	add	r2,r2,r2
 d03bb0c:	10c5883a 	add	r2,r2,r3
 d03bb10:	10800104 	addi	r2,r2,4
 d03bb14:	10800017 	ldw	r2,0(r2)
 d03bb18:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 d03bb1c:	e0bffa17 	ldw	r2,-24(fp)
 d03bb20:	10800117 	ldw	r2,4(r2)
 d03bb24:	e0bff915 	stw	r2,-28(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 d03bb28:	e0bff917 	ldw	r2,-28(fp)
 d03bb2c:	1005003a 	cmpeq	r2,r2,zero
 d03bb30:	1000091e 	bne	r2,zero,d03bb58 <alt_tse_phy_get_common_speed+0xac>
            alt_tse_phy_set_adv_1000(pphy, 1);
 d03bb34:	e13ff917 	ldw	r4,-28(fp)
 d03bb38:	01400044 	movi	r5,1
 d03bb3c:	d03b5700 	call	d03b570 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 d03bb40:	e13ff917 	ldw	r4,-28(fp)
 d03bb44:	01400044 	movi	r5,1
 d03bb48:	d03b7040 	call	d03b704 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d03bb4c:	e13ff917 	ldw	r4,-28(fp)
 d03bb50:	01400044 	movi	r5,1
 d03bb54:	d03b9140 	call	d03b914 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 d03bb58:	01034174 	movhi	r4,3333
 d03bb5c:	2102d304 	addi	r4,r4,2892
 d03bb60:	d0372880 	call	d037288 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 d03bb64:	e0bffe17 	ldw	r2,-8(fp)
 d03bb68:	10800044 	addi	r2,r2,1
 d03bb6c:	e0bffe15 	stw	r2,-8(fp)
 d03bb70:	e0bfff17 	ldw	r2,-4(fp)
 d03bb74:	10800003 	ldbu	r2,0(r2)
 d03bb78:	10c03fcc 	andi	r3,r2,255
 d03bb7c:	e0bffe17 	ldw	r2,-8(fp)
 d03bb80:	10ffde16 	blt	r2,r3,d03bafc <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d03bb84:	e03ffe15 	stw	zero,-8(fp)
 d03bb88:	00005406 	br	d03bcdc <alt_tse_phy_get_common_speed+0x230>

        pmac_info = pmac_group->pmac_info[i];
 d03bb8c:	e0bffe17 	ldw	r2,-8(fp)
 d03bb90:	e0ffff17 	ldw	r3,-4(fp)
 d03bb94:	1085883a 	add	r2,r2,r2
 d03bb98:	1085883a 	add	r2,r2,r2
 d03bb9c:	10c5883a 	add	r2,r2,r3
 d03bba0:	10800104 	addi	r2,r2,4
 d03bba4:	10800017 	ldw	r2,0(r2)
 d03bba8:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 d03bbac:	e0bffa17 	ldw	r2,-24(fp)
 d03bbb0:	10800117 	ldw	r2,4(r2)
 d03bbb4:	e0bff915 	stw	r2,-28(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 d03bbb8:	e0bff917 	ldw	r2,-28(fp)
 d03bbbc:	1005003a 	cmpeq	r2,r2,zero
 d03bbc0:	1000431e 	bne	r2,zero,d03bcd0 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 d03bbc4:	e13ff917 	ldw	r4,-28(fp)
 d03bbc8:	d03b0300 	call	d03b030 <alt_tse_phy_get_cap>
 d03bbcc:	1004c03a 	cmpne	r2,r2,zero
 d03bbd0:	10003f1e 	bne	r2,zero,d03bcd0 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 d03bbd4:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 d03bbd8:	e0bffa17 	ldw	r2,-24(fp)
 d03bbdc:	10800003 	ldbu	r2,0(r2)
 d03bbe0:	10803fcc 	andi	r2,r2,255
 d03bbe4:	10800058 	cmpnei	r2,r2,1
 d03bbe8:	1000021e 	bne	r2,zero,d03bbf4 <alt_tse_phy_get_common_speed+0x148>
            common_1000 = 0;
 d03bbec:	e03ffd85 	stb	zero,-10(fp)
 d03bbf0:	00000706 	br	d03bc10 <alt_tse_phy_get_common_speed+0x164>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 d03bbf4:	e0bffa17 	ldw	r2,-24(fp)
 d03bbf8:	10800003 	ldbu	r2,0(r2)
 d03bbfc:	10803fcc 	andi	r2,r2,255
 d03bc00:	10800098 	cmpnei	r2,r2,2
 d03bc04:	1000021e 	bne	r2,zero,d03bc10 <alt_tse_phy_get_common_speed+0x164>
            common_100 = 0;
 d03bc08:	e03ffd45 	stb	zero,-11(fp)
            common_10 = 0;            
 d03bc0c:	e03ffd05 	stb	zero,-12(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 d03bc10:	e0bff917 	ldw	r2,-28(fp)
 d03bc14:	10c000c3 	ldbu	r3,3(r2)
 d03bc18:	e0bff917 	ldw	r2,-28(fp)
 d03bc1c:	10800303 	ldbu	r2,12(r2)
 d03bc20:	1884703a 	and	r2,r3,r2
 d03bc24:	1007883a 	mov	r3,r2
 d03bc28:	e0bffd83 	ldbu	r2,-10(fp)
 d03bc2c:	10c4703a 	and	r2,r2,r3
 d03bc30:	e0bffd85 	stb	r2,-10(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 d03bc34:	e0bff917 	ldw	r2,-28(fp)
 d03bc38:	10c00183 	ldbu	r3,6(r2)
 d03bc3c:	e0bff917 	ldw	r2,-28(fp)
 d03bc40:	108003c3 	ldbu	r2,15(r2)
 d03bc44:	1884703a 	and	r2,r3,r2
 d03bc48:	1009883a 	mov	r4,r2
 d03bc4c:	e0bff917 	ldw	r2,-28(fp)
 d03bc50:	10c001c3 	ldbu	r3,7(r2)
 d03bc54:	e0bff917 	ldw	r2,-28(fp)
 d03bc58:	10800403 	ldbu	r2,16(r2)
 d03bc5c:	1884703a 	and	r2,r3,r2
 d03bc60:	2084b03a 	or	r2,r4,r2
 d03bc64:	1009883a 	mov	r4,r2
 d03bc68:	e0bff917 	ldw	r2,-28(fp)
 d03bc6c:	10c00143 	ldbu	r3,5(r2)
 d03bc70:	e0bff917 	ldw	r2,-28(fp)
 d03bc74:	10800383 	ldbu	r2,14(r2)
 d03bc78:	1884703a 	and	r2,r3,r2
 d03bc7c:	2084b03a 	or	r2,r4,r2
 d03bc80:	1007883a 	mov	r3,r2
 d03bc84:	e0bffd43 	ldbu	r2,-11(fp)
 d03bc88:	10c4703a 	and	r2,r2,r3
 d03bc8c:	e0bffd45 	stb	r2,-11(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 d03bc90:	e0bff917 	ldw	r2,-28(fp)
 d03bc94:	10c00283 	ldbu	r3,10(r2)
 d03bc98:	e0bff917 	ldw	r2,-28(fp)
 d03bc9c:	10800443 	ldbu	r2,17(r2)
 d03bca0:	1884703a 	and	r2,r3,r2
 d03bca4:	1009883a 	mov	r4,r2
 d03bca8:	e0bff917 	ldw	r2,-28(fp)
 d03bcac:	10c002c3 	ldbu	r3,11(r2)
 d03bcb0:	e0bff917 	ldw	r2,-28(fp)
 d03bcb4:	10800483 	ldbu	r2,18(r2)
 d03bcb8:	1884703a 	and	r2,r3,r2
 d03bcbc:	2084b03a 	or	r2,r4,r2
 d03bcc0:	1007883a 	mov	r3,r2
 d03bcc4:	e0bffd03 	ldbu	r2,-12(fp)
 d03bcc8:	10c4703a 	and	r2,r2,r3
 d03bccc:	e0bffd05 	stb	r2,-12(fp)
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d03bcd0:	e0bffe17 	ldw	r2,-8(fp)
 d03bcd4:	10800044 	addi	r2,r2,1
 d03bcd8:	e0bffe15 	stw	r2,-8(fp)
 d03bcdc:	e0bfff17 	ldw	r2,-4(fp)
 d03bce0:	10800003 	ldbu	r2,0(r2)
 d03bce4:	10c03fcc 	andi	r3,r2,255
 d03bce8:	e0bffe17 	ldw	r2,-8(fp)
 d03bcec:	10ffa716 	blt	r2,r3,d03bb8c <alt_tse_phy_get_common_speed+0xe0>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 d03bcf0:	e0bffb03 	ldbu	r2,-20(fp)
 d03bcf4:	10800058 	cmpnei	r2,r2,1
 d03bcf8:	1000071e 	bne	r2,zero,d03bd18 <alt_tse_phy_get_common_speed+0x26c>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 d03bcfc:	00bfffc4 	movi	r2,-1
 d03bd00:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 d03bd04:	e17ff807 	ldb	r5,-32(fp)
 d03bd08:	01034174 	movhi	r4,3333
 d03bd0c:	21054004 	addi	r4,r4,5376
 d03bd10:	d0028a00 	call	d0028a0 <printf>
 d03bd14:	00002606 	br	d03bdb0 <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_1000) {
 d03bd18:	e0bffd83 	ldbu	r2,-10(fp)
 d03bd1c:	1005003a 	cmpeq	r2,r2,zero
 d03bd20:	1000081e 	bne	r2,zero,d03bd44 <alt_tse_phy_get_common_speed+0x298>
        common_speed = TSE_PHY_SPEED_1000;
 d03bd24:	00800084 	movi	r2,2
 d03bd28:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 d03bd2c:	e17ff807 	ldb	r5,-32(fp)
 d03bd30:	01034174 	movhi	r4,3333
 d03bd34:	21055204 	addi	r4,r4,5448
 d03bd38:	0180fa04 	movi	r6,1000
 d03bd3c:	d0028a00 	call	d0028a0 <printf>
 d03bd40:	00001b06 	br	d03bdb0 <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_100) {
 d03bd44:	e0bffd43 	ldbu	r2,-11(fp)
 d03bd48:	1005003a 	cmpeq	r2,r2,zero
 d03bd4c:	1000081e 	bne	r2,zero,d03bd70 <alt_tse_phy_get_common_speed+0x2c4>
        common_speed = TSE_PHY_SPEED_100;
 d03bd50:	00800044 	movi	r2,1
 d03bd54:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 d03bd58:	e17ff807 	ldb	r5,-32(fp)
 d03bd5c:	01034174 	movhi	r4,3333
 d03bd60:	21055204 	addi	r4,r4,5448
 d03bd64:	01801904 	movi	r6,100
 d03bd68:	d0028a00 	call	d0028a0 <printf>
 d03bd6c:	00001006 	br	d03bdb0 <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_10) {
 d03bd70:	e0bffd03 	ldbu	r2,-12(fp)
 d03bd74:	1005003a 	cmpeq	r2,r2,zero
 d03bd78:	1000071e 	bne	r2,zero,d03bd98 <alt_tse_phy_get_common_speed+0x2ec>
        common_speed = TSE_PHY_SPEED_10;
 d03bd7c:	e03ffc15 	stw	zero,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 d03bd80:	e17ff807 	ldb	r5,-32(fp)
 d03bd84:	01034174 	movhi	r4,3333
 d03bd88:	21055204 	addi	r4,r4,5448
 d03bd8c:	01800284 	movi	r6,10
 d03bd90:	d0028a00 	call	d0028a0 <printf>
 d03bd94:	00000606 	br	d03bdb0 <alt_tse_phy_get_common_speed+0x304>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 d03bd98:	00bfffc4 	movi	r2,-1
 d03bd9c:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 d03bda0:	e17ff807 	ldb	r5,-32(fp)
 d03bda4:	01034174 	movhi	r4,3333
 d03bda8:	21055f04 	addi	r4,r4,5500
 d03bdac:	d0028a00 	call	d0028a0 <printf>

    return common_speed;
 d03bdb0:	e0bffc17 	ldw	r2,-16(fp)
}
 d03bdb4:	e037883a 	mov	sp,fp
 d03bdb8:	dfc00117 	ldw	ra,4(sp)
 d03bdbc:	df000017 	ldw	fp,0(sp)
 d03bdc0:	dec00204 	addi	sp,sp,8
 d03bdc4:	f800283a 	ret

0d03bdc8 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 d03bdc8:	deffec04 	addi	sp,sp,-80
 d03bdcc:	dfc01315 	stw	ra,76(sp)
 d03bdd0:	df001215 	stw	fp,72(sp)
 d03bdd4:	dc401115 	stw	r17,68(sp)
 d03bdd8:	dc001015 	stw	r16,64(sp)
 d03bddc:	df001004 	addi	fp,sp,64
 d03bde0:	e13ff915 	stw	r4,-28(fp)
 d03bde4:	e17ffa15 	stw	r5,-24(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 d03bde8:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 d03bdec:	e03ff515 	stw	zero,-44(fp)
    alt_tse_system_info *psys = 0;
 d03bdf0:	e03ff415 	stw	zero,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 d03bdf4:	e03ff345 	stb	zero,-51(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d03bdf8:	e13ff917 	ldw	r4,-28(fp)
 d03bdfc:	d0385380 	call	d038538 <alt_tse_get_mac_group_index>
 d03be00:	e0bff305 	stb	r2,-52(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d03be04:	e0bff917 	ldw	r2,-28(fp)
 d03be08:	10800117 	ldw	r2,4(r2)
 d03be0c:	10800217 	ldw	r2,8(r2)
 d03be10:	10800017 	ldw	r2,0(r2)
 d03be14:	e0bff215 	stw	r2,-56(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 d03be18:	e0bff217 	ldw	r2,-56(fp)
 d03be1c:	10801004 	addi	r2,r2,64
 d03be20:	10800037 	ldwio	r2,0(r2)
 d03be24:	e0bff115 	stw	r2,-60(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 d03be28:	e0bffa17 	ldw	r2,-24(fp)
 d03be2c:	1004803a 	cmplt	r2,r2,zero
 d03be30:	1000031e 	bne	r2,zero,d03be40 <alt_tse_phy_set_common_speed+0x78>
 d03be34:	e0bffa17 	ldw	r2,-24(fp)
 d03be38:	108000d0 	cmplti	r2,r2,3
 d03be3c:	10000d1e 	bne	r2,zero,d03be74 <alt_tse_phy_set_common_speed+0xac>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 d03be40:	e17ff307 	ldb	r5,-52(fp)
 d03be44:	01034174 	movhi	r4,3333
 d03be48:	21056c04 	addi	r4,r4,5552
 d03be4c:	e1bffa17 	ldw	r6,-24(fp)
 d03be50:	d0028a00 	call	d0028a0 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d03be54:	e0bff217 	ldw	r2,-56(fp)
 d03be58:	10801004 	addi	r2,r2,64
 d03be5c:	1007883a 	mov	r3,r2
 d03be60:	e0bff117 	ldw	r2,-60(fp)
 d03be64:	18800035 	stwio	r2,0(r3)
        return TSE_PHY_SPEED_NO_COMMON;
 d03be68:	00bfffc4 	movi	r2,-1
 d03be6c:	e0bfff15 	stw	r2,-4(fp)
 d03be70:	00010606 	br	d03c28c <alt_tse_phy_set_common_speed+0x4c4>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d03be74:	e03ff815 	stw	zero,-32(fp)
 d03be78:	0000dd06 	br	d03c1f0 <alt_tse_phy_set_common_speed+0x428>
        pmac_info = pmac_group->pmac_info[i];
 d03be7c:	e0bff817 	ldw	r2,-32(fp)
 d03be80:	e0fff917 	ldw	r3,-28(fp)
 d03be84:	1085883a 	add	r2,r2,r2
 d03be88:	1085883a 	add	r2,r2,r2
 d03be8c:	10c5883a 	add	r2,r2,r3
 d03be90:	10800104 	addi	r2,r2,4
 d03be94:	10800017 	ldw	r2,0(r2)
 d03be98:	e0bff515 	stw	r2,-44(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d03be9c:	e13ff517 	ldw	r4,-44(fp)
 d03bea0:	d0385b80 	call	d0385b8 <alt_tse_get_mac_info_index>
 d03bea4:	e0bff345 	stb	r2,-51(fp)

        pphy = pmac_info->pphy_info;
 d03bea8:	e0bff517 	ldw	r2,-44(fp)
 d03beac:	10800117 	ldw	r2,4(r2)
 d03beb0:	e0bff615 	stw	r2,-40(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 d03beb4:	e0bff617 	ldw	r2,-40(fp)
 d03beb8:	1005003a 	cmpeq	r2,r2,zero
 d03bebc:	1000c91e 	bne	r2,zero,d03c1e4 <alt_tse_phy_set_common_speed+0x41c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 d03bec0:	e0bff517 	ldw	r2,-44(fp)
 d03bec4:	10800217 	ldw	r2,8(r2)
 d03bec8:	e0bff415 	stw	r2,-48(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d03becc:	e0bff617 	ldw	r2,-40(fp)
 d03bed0:	10800003 	ldbu	r2,0(r2)
 d03bed4:	11403fcc 	andi	r5,r2,255
 d03bed8:	e13ff617 	ldw	r4,-40(fp)
 d03bedc:	d0396f80 	call	d0396f8 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 d03bee0:	e0bff617 	ldw	r2,-40(fp)
 d03bee4:	108000c3 	ldbu	r2,3(r2)
 d03bee8:	10803fcc 	andi	r2,r2,255
 d03beec:	1004c03a 	cmpne	r2,r2,zero
 d03bef0:	10000f1e 	bne	r2,zero,d03bf30 <alt_tse_phy_set_common_speed+0x168>
 d03bef4:	e0bff617 	ldw	r2,-40(fp)
 d03bef8:	10800103 	ldbu	r2,4(r2)
 d03befc:	10803fcc 	andi	r2,r2,255
 d03bf00:	1004c03a 	cmpne	r2,r2,zero
 d03bf04:	10000a1e 	bne	r2,zero,d03bf30 <alt_tse_phy_set_common_speed+0x168>
 d03bf08:	e0bff617 	ldw	r2,-40(fp)
 d03bf0c:	10800043 	ldbu	r2,1(r2)
 d03bf10:	10803fcc 	andi	r2,r2,255
 d03bf14:	1004c03a 	cmpne	r2,r2,zero
 d03bf18:	1000051e 	bne	r2,zero,d03bf30 <alt_tse_phy_set_common_speed+0x168>
 d03bf1c:	e0bff617 	ldw	r2,-40(fp)
 d03bf20:	10800083 	ldbu	r2,2(r2)
 d03bf24:	10803fcc 	andi	r2,r2,255
 d03bf28:	1005003a 	cmpeq	r2,r2,zero
 d03bf2c:	1000031e 	bne	r2,zero,d03bf3c <alt_tse_phy_set_common_speed+0x174>
 d03bf30:	00800044 	movi	r2,1
 d03bf34:	e0bffe15 	stw	r2,-8(fp)
 d03bf38:	00000106 	br	d03bf40 <alt_tse_phy_set_common_speed+0x178>
 d03bf3c:	e03ffe15 	stw	zero,-8(fp)
 d03bf40:	e0bffe17 	ldw	r2,-8(fp)
 d03bf44:	e0bff705 	stb	r2,-36(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 d03bf48:	e0bff703 	ldbu	r2,-36(fp)
 d03bf4c:	1004c03a 	cmpne	r2,r2,zero
 d03bf50:	1000101e 	bne	r2,zero,d03bf94 <alt_tse_phy_set_common_speed+0x1cc>
 d03bf54:	e0bffa17 	ldw	r2,-24(fp)
 d03bf58:	10800098 	cmpnei	r2,r2,2
 d03bf5c:	10000d1e 	bne	r2,zero,d03bf94 <alt_tse_phy_set_common_speed+0x1cc>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 d03bf60:	e17ff307 	ldb	r5,-52(fp)
 d03bf64:	e1bff347 	ldb	r6,-51(fp)
 d03bf68:	01034174 	movhi	r4,3333
 d03bf6c:	21058004 	addi	r4,r4,5632
 d03bf70:	d0028a00 	call	d0028a0 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d03bf74:	e0bff217 	ldw	r2,-56(fp)
 d03bf78:	10801004 	addi	r2,r2,64
 d03bf7c:	1007883a 	mov	r3,r2
 d03bf80:	e0bff117 	ldw	r2,-60(fp)
 d03bf84:	18800035 	stwio	r2,0(r3)
            return TSE_PHY_SPEED_NO_COMMON;
 d03bf88:	00bfffc4 	movi	r2,-1
 d03bf8c:	e0bfff15 	stw	r2,-4(fp)
 d03bf90:	0000be06 	br	d03c28c <alt_tse_phy_set_common_speed+0x4c4>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 d03bf94:	e13ff617 	ldw	r4,-40(fp)
 d03bf98:	01400044 	movi	r5,1
 d03bf9c:	018000c4 	movi	r6,3
 d03bfa0:	01c00044 	movi	r7,1
 d03bfa4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03bfa8:	1004c03a 	cmpne	r2,r2,zero
 d03bfac:	1000151e 	bne	r2,zero,d03c004 <alt_tse_phy_set_common_speed+0x23c>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 d03bfb0:	e0bff703 	ldbu	r2,-36(fp)
 d03bfb4:	1005003a 	cmpeq	r2,r2,zero
 d03bfb8:	1000091e 	bne	r2,zero,d03bfe0 <alt_tse_phy_set_common_speed+0x218>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 d03bfbc:	e0bffa17 	ldw	r2,-24(fp)
 d03bfc0:	1005d07a 	srai	r2,r2,1
 d03bfc4:	10bfffcc 	andi	r2,r2,65535
 d03bfc8:	d8800015 	stw	r2,0(sp)
 d03bfcc:	e13ff617 	ldw	r4,-40(fp)
 d03bfd0:	000b883a 	mov	r5,zero
 d03bfd4:	01800184 	movi	r6,6
 d03bfd8:	01c00044 	movi	r7,1
 d03bfdc:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 d03bfe0:	e0bffa17 	ldw	r2,-24(fp)
 d03bfe4:	10bfffcc 	andi	r2,r2,65535
 d03bfe8:	d8800015 	stw	r2,0(sp)
 d03bfec:	e13ff617 	ldw	r4,-40(fp)
 d03bff0:	000b883a 	mov	r5,zero
 d03bff4:	01800344 	movi	r6,13
 d03bff8:	01c00044 	movi	r7,1
 d03bffc:	d03974c0 	call	d03974c <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 d03c000:	00007806 	br	d03c1e4 <alt_tse_phy_set_common_speed+0x41c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 d03c004:	e0bffa17 	ldw	r2,-24(fp)
 d03c008:	10800098 	cmpnei	r2,r2,2
 d03c00c:	10000a1e 	bne	r2,zero,d03c038 <alt_tse_phy_set_common_speed+0x270>
            alt_tse_phy_set_adv_1000(pphy, 1);
 d03c010:	e13ff617 	ldw	r4,-40(fp)
 d03c014:	01400044 	movi	r5,1
 d03c018:	d03b5700 	call	d03b570 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 d03c01c:	e13ff617 	ldw	r4,-40(fp)
 d03c020:	01400044 	movi	r5,1
 d03c024:	d03b7040 	call	d03b704 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d03c028:	e13ff617 	ldw	r4,-40(fp)
 d03c02c:	01400044 	movi	r5,1
 d03c030:	d03b9140 	call	d03b914 <alt_tse_phy_set_adv_10>
 d03c034:	00002306 	br	d03c0c4 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 d03c038:	e0bffa17 	ldw	r2,-24(fp)
 d03c03c:	10800058 	cmpnei	r2,r2,1
 d03c040:	10000a1e 	bne	r2,zero,d03c06c <alt_tse_phy_set_common_speed+0x2a4>
            alt_tse_phy_set_adv_1000(pphy, 0);
 d03c044:	e13ff617 	ldw	r4,-40(fp)
 d03c048:	000b883a 	mov	r5,zero
 d03c04c:	d03b5700 	call	d03b570 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 d03c050:	e13ff617 	ldw	r4,-40(fp)
 d03c054:	01400044 	movi	r5,1
 d03c058:	d03b7040 	call	d03b704 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d03c05c:	e13ff617 	ldw	r4,-40(fp)
 d03c060:	01400044 	movi	r5,1
 d03c064:	d03b9140 	call	d03b914 <alt_tse_phy_set_adv_10>
 d03c068:	00001606 	br	d03c0c4 <alt_tse_phy_set_common_speed+0x2fc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 d03c06c:	e0bffa17 	ldw	r2,-24(fp)
 d03c070:	1004c03a 	cmpne	r2,r2,zero
 d03c074:	10000a1e 	bne	r2,zero,d03c0a0 <alt_tse_phy_set_common_speed+0x2d8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 d03c078:	e13ff617 	ldw	r4,-40(fp)
 d03c07c:	000b883a 	mov	r5,zero
 d03c080:	d03b5700 	call	d03b570 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 d03c084:	e13ff617 	ldw	r4,-40(fp)
 d03c088:	000b883a 	mov	r5,zero
 d03c08c:	d03b7040 	call	d03b704 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d03c090:	e13ff617 	ldw	r4,-40(fp)
 d03c094:	01400044 	movi	r5,1
 d03c098:	d03b9140 	call	d03b914 <alt_tse_phy_set_adv_10>
 d03c09c:	00000906 	br	d03c0c4 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 d03c0a0:	e13ff617 	ldw	r4,-40(fp)
 d03c0a4:	000b883a 	mov	r5,zero
 d03c0a8:	d03b5700 	call	d03b570 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 d03c0ac:	e13ff617 	ldw	r4,-40(fp)
 d03c0b0:	000b883a 	mov	r5,zero
 d03c0b4:	d03b7040 	call	d03b704 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 d03c0b8:	e13ff617 	ldw	r4,-40(fp)
 d03c0bc:	000b883a 	mov	r5,zero
 d03c0c0:	d03b9140 	call	d03b914 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 d03c0c4:	e13ff617 	ldw	r4,-40(fp)
 d03c0c8:	01400044 	movi	r5,1
 d03c0cc:	01800144 	movi	r6,5
 d03c0d0:	01c00044 	movi	r7,1
 d03c0d4:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03c0d8:	10800058 	cmpnei	r2,r2,1
 d03c0dc:	1000341e 	bne	r2,zero,d03c1b0 <alt_tse_phy_set_common_speed+0x3e8>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 d03c0e0:	e0bff703 	ldbu	r2,-36(fp)
 d03c0e4:	1005003a 	cmpeq	r2,r2,zero
 d03c0e8:	10000d1e 	bne	r2,zero,d03c120 <alt_tse_phy_set_common_speed+0x358>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 d03c0ec:	e0bff617 	ldw	r2,-40(fp)
 d03c0f0:	10800517 	ldw	r2,20(r2)
 d03c0f4:	10801583 	ldbu	r2,86(r2)
 d03c0f8:	11403fcc 	andi	r5,r2,255
 d03c0fc:	e0bff617 	ldw	r2,-40(fp)
 d03c100:	10800517 	ldw	r2,20(r2)
 d03c104:	108015c3 	ldbu	r2,87(r2)
 d03c108:	11803fcc 	andi	r6,r2,255
 d03c10c:	e13ff617 	ldw	r4,-40(fp)
 d03c110:	01c00084 	movi	r7,2
 d03c114:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03c118:	e0bff785 	stb	r2,-34(fp)
 d03c11c:	00000c06 	br	d03c150 <alt_tse_phy_set_common_speed+0x388>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 d03c120:	e0bff617 	ldw	r2,-40(fp)
 d03c124:	10800517 	ldw	r2,20(r2)
 d03c128:	10801583 	ldbu	r2,86(r2)
 d03c12c:	11403fcc 	andi	r5,r2,255
 d03c130:	e0bff617 	ldw	r2,-40(fp)
 d03c134:	10800517 	ldw	r2,20(r2)
 d03c138:	108015c3 	ldbu	r2,87(r2)
 d03c13c:	11803fcc 	andi	r6,r2,255
 d03c140:	e13ff617 	ldw	r4,-40(fp)
 d03c144:	01c00044 	movi	r7,1
 d03c148:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03c14c:	e0bff785 	stb	r2,-34(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 d03c150:	e0fff783 	ldbu	r3,-34(fp)
 d03c154:	e0bffa17 	ldw	r2,-24(fp)
 d03c158:	18800426 	beq	r3,r2,d03c16c <alt_tse_phy_set_common_speed+0x3a4>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d03c15c:	e13ff617 	ldw	r4,-40(fp)
 d03c160:	01400134 	movhi	r5,4
 d03c164:	29742404 	addi	r5,r5,-12144
 d03c168:	d03ad3c0 	call	d03ad3c <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 d03c16c:	e0bff617 	ldw	r2,-40(fp)
 d03c170:	10800517 	ldw	r2,20(r2)
 d03c174:	10801583 	ldbu	r2,86(r2)
 d03c178:	11403fcc 	andi	r5,r2,255
 d03c17c:	e0bff617 	ldw	r2,-40(fp)
 d03c180:	10800517 	ldw	r2,20(r2)
 d03c184:	10801603 	ldbu	r2,88(r2)
 d03c188:	11803fcc 	andi	r6,r2,255
 d03c18c:	e13ff617 	ldw	r4,-40(fp)
 d03c190:	01c00044 	movi	r7,1
 d03c194:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03c198:	e0bff745 	stb	r2,-35(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 d03c19c:	e0bff417 	ldw	r2,-48(fp)
 d03c1a0:	10800017 	ldw	r2,0(r2)
 d03c1a4:	1009883a 	mov	r4,r2
 d03c1a8:	e17ff743 	ldbu	r5,-35(fp)
 d03c1ac:	d0388100 	call	d038810 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 d03c1b0:	e43ff307 	ldb	r16,-52(fp)
 d03c1b4:	e47ff347 	ldb	r17,-51(fp)
 d03c1b8:	e13ff617 	ldw	r4,-40(fp)
 d03c1bc:	01400044 	movi	r5,1
 d03c1c0:	000d883a 	mov	r6,zero
 d03c1c4:	01c00404 	movi	r7,16
 d03c1c8:	d0398740 	call	d039874 <alt_tse_phy_rd_mdio_reg>
 d03c1cc:	100f883a 	mov	r7,r2
 d03c1d0:	01034174 	movhi	r4,3333
 d03c1d4:	21059704 	addi	r4,r4,5724
 d03c1d8:	800b883a 	mov	r5,r16
 d03c1dc:	880d883a 	mov	r6,r17
 d03c1e0:	d0028a00 	call	d0028a0 <printf>
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d03c1e4:	e0bff817 	ldw	r2,-32(fp)
 d03c1e8:	10800044 	addi	r2,r2,1
 d03c1ec:	e0bff815 	stw	r2,-32(fp)
 d03c1f0:	e0bff917 	ldw	r2,-28(fp)
 d03c1f4:	10800003 	ldbu	r2,0(r2)
 d03c1f8:	10c03fcc 	andi	r3,r2,255
 d03c1fc:	e0bff817 	ldw	r2,-32(fp)
 d03c200:	10ff1e16 	blt	r2,r3,d03be7c <alt_tse_phy_set_common_speed+0xb4>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 d03c204:	e0bff307 	ldb	r2,-52(fp)
 d03c208:	e0bffd15 	stw	r2,-12(fp)
 d03c20c:	e0bffa17 	ldw	r2,-24(fp)
 d03c210:	108000a0 	cmpeqi	r2,r2,2
 d03c214:	10000b1e 	bne	r2,zero,d03c244 <alt_tse_phy_set_common_speed+0x47c>
 d03c218:	e0bffa17 	ldw	r2,-24(fp)
 d03c21c:	10800058 	cmpnei	r2,r2,1
 d03c220:	1000031e 	bne	r2,zero,d03c230 <alt_tse_phy_set_common_speed+0x468>
 d03c224:	00801904 	movi	r2,100
 d03c228:	e0bffb15 	stw	r2,-20(fp)
 d03c22c:	00000206 	br	d03c238 <alt_tse_phy_set_common_speed+0x470>
 d03c230:	00800284 	movi	r2,10
 d03c234:	e0bffb15 	stw	r2,-20(fp)
 d03c238:	e0bffb17 	ldw	r2,-20(fp)
 d03c23c:	e0bffc15 	stw	r2,-16(fp)
 d03c240:	00000206 	br	d03c24c <alt_tse_phy_set_common_speed+0x484>
 d03c244:	0080fa04 	movi	r2,1000
 d03c248:	e0bffc15 	stw	r2,-16(fp)
 d03c24c:	01034174 	movhi	r4,3333
 d03c250:	2105a304 	addi	r4,r4,5772
 d03c254:	e17ffd17 	ldw	r5,-12(fp)
 d03c258:	e1bffc17 	ldw	r6,-16(fp)
 d03c25c:	d0028a00 	call	d0028a0 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 d03c260:	e0bffa17 	ldw	r2,-24(fp)
 d03c264:	11403fcc 	andi	r5,r2,255
 d03c268:	e13ff217 	ldw	r4,-56(fp)
 d03c26c:	d0387240 	call	d038724 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d03c270:	e0bff217 	ldw	r2,-56(fp)
 d03c274:	10801004 	addi	r2,r2,64
 d03c278:	1007883a 	mov	r3,r2
 d03c27c:	e0bff117 	ldw	r2,-60(fp)
 d03c280:	18800035 	stwio	r2,0(r3)
        
    return common_speed;
 d03c284:	e0bffa17 	ldw	r2,-24(fp)
 d03c288:	e0bfff15 	stw	r2,-4(fp)
 d03c28c:	e0bfff17 	ldw	r2,-4(fp)
}
 d03c290:	e037883a 	mov	sp,fp
 d03c294:	dfc00317 	ldw	ra,12(sp)
 d03c298:	df000217 	ldw	fp,8(sp)
 d03c29c:	dc400117 	ldw	r17,4(sp)
 d03c2a0:	dc000017 	ldw	r16,0(sp)
 d03c2a4:	dec00404 	addi	sp,sp,16
 d03c2a8:	f800283a 	ret

0d03c2ac <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 d03c2ac:	defffc04 	addi	sp,sp,-16
 d03c2b0:	dfc00315 	stw	ra,12(sp)
 d03c2b4:	df000215 	stw	fp,8(sp)
 d03c2b8:	df000204 	addi	fp,sp,8
 d03c2bc:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 d03c2c0:	e0bfff17 	ldw	r2,-4(fp)
 d03c2c4:	1080a104 	addi	r2,r2,644
 d03c2c8:	10800037 	ldwio	r2,0(r2)
 d03c2cc:	1080080c 	andi	r2,r2,32
 d03c2d0:	1004c03a 	cmpne	r2,r2,zero
 d03c2d4:	1000191e 	bne	r2,zero,d03c33c <marvell_phy_cfg+0x90>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 d03c2d8:	01034174 	movhi	r4,3333
 d03c2dc:	2105b404 	addi	r4,r4,5840
 d03c2e0:	d002bc80 	call	d002bc8 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 d03c2e4:	e0bfff17 	ldw	r2,-4(fp)
 d03c2e8:	1080a004 	addi	r2,r2,640
 d03c2ec:	10801004 	addi	r2,r2,64
 d03c2f0:	1007883a 	mov	r3,r2
 d03c2f4:	00801e04 	movi	r2,120
 d03c2f8:	18800035 	stwio	r2,0(r3)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 d03c2fc:	01034174 	movhi	r4,3333
 d03c300:	2105bd04 	addi	r4,r4,5876
 d03c304:	d002bc80 	call	d002bc8 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d03c308:	e0bfff17 	ldw	r2,-4(fp)
 d03c30c:	1080a004 	addi	r2,r2,640
 d03c310:	10800037 	ldwio	r2,0(r2)
 d03c314:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 d03c318:	e0bfff17 	ldw	r2,-4(fp)
 d03c31c:	1080a004 	addi	r2,r2,640
 d03c320:	1009883a 	mov	r4,r2
 d03c324:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c328:	00a00004 	movi	r2,-32768
 d03c32c:	1884b03a 	or	r2,r3,r2
 d03c330:	10ffffcc 	andi	r3,r2,65535
 d03c334:	2005883a 	mov	r2,r4
 d03c338:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 d03c33c:	0005883a 	mov	r2,zero
}
 d03c340:	e037883a 	mov	sp,fp
 d03c344:	dfc00117 	ldw	ra,4(sp)
 d03c348:	df000017 	ldw	fp,0(sp)
 d03c34c:	dec00204 	addi	sp,sp,8
 d03c350:	f800283a 	ret

0d03c354 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 d03c354:	defffc04 	addi	sp,sp,-16
 d03c358:	dfc00315 	stw	ra,12(sp)
 d03c35c:	df000215 	stw	fp,8(sp)
 d03c360:	df000204 	addi	fp,sp,8
 d03c364:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 d03c368:	e0bfff17 	ldw	r2,-4(fp)
 d03c36c:	1080bb04 	addi	r2,r2,748
 d03c370:	10800037 	ldwio	r2,0(r2)
 d03c374:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 d03c378:	00fffc04 	movi	r3,-16
 d03c37c:	e0bffe0b 	ldhu	r2,-8(fp)
 d03c380:	10c4703a 	and	r2,r2,r3
 d03c384:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 d03c388:	01034174 	movhi	r4,3333
 d03c38c:	2105c204 	addi	r4,r4,5896
 d03c390:	d002bc80 	call	d002bc8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 d03c394:	e0bfff17 	ldw	r2,-4(fp)
 d03c398:	1080bb04 	addi	r2,r2,748
 d03c39c:	1009883a 	mov	r4,r2
 d03c3a0:	e0bffe0b 	ldhu	r2,-8(fp)
 d03c3a4:	108003d4 	ori	r2,r2,15
 d03c3a8:	10ffffcc 	andi	r3,r2,65535
 d03c3ac:	2005883a 	mov	r2,r4
 d03c3b0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 d03c3b4:	01034174 	movhi	r4,3333
 d03c3b8:	2105ce04 	addi	r4,r4,5944
 d03c3bc:	d002bc80 	call	d002bc8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 d03c3c0:	e0bfff17 	ldw	r2,-4(fp)
 d03c3c4:	1080b404 	addi	r2,r2,720
 d03c3c8:	10800037 	ldwio	r2,0(r2)
 d03c3cc:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 d03c3d0:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c3d4:	00bfdf44 	movi	r2,-131
 d03c3d8:	1884703a 	and	r2,r3,r2
 d03c3dc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 d03c3e0:	e0bfff17 	ldw	r2,-4(fp)
 d03c3e4:	1080b404 	addi	r2,r2,720
 d03c3e8:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c3ec:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 d03c3f0:	01034174 	movhi	r4,3333
 d03c3f4:	2105bd04 	addi	r4,r4,5876
 d03c3f8:	d002bc80 	call	d002bc8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d03c3fc:	e0bfff17 	ldw	r2,-4(fp)
 d03c400:	1080a004 	addi	r2,r2,640
 d03c404:	10800037 	ldwio	r2,0(r2)
 d03c408:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 d03c40c:	e0bfff17 	ldw	r2,-4(fp)
 d03c410:	1080a004 	addi	r2,r2,640
 d03c414:	1009883a 	mov	r4,r2
 d03c418:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c41c:	00a00004 	movi	r2,-32768
 d03c420:	1884b03a 	or	r2,r3,r2
 d03c424:	10ffffcc 	andi	r3,r2,65535
 d03c428:	2005883a 	mov	r2,r4
 d03c42c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 d03c430:	00800044 	movi	r2,1
}
 d03c434:	e037883a 	mov	sp,fp
 d03c438:	dfc00117 	ldw	ra,4(sp)
 d03c43c:	df000017 	ldw	fp,0(sp)
 d03c440:	dec00204 	addi	sp,sp,8
 d03c444:	f800283a 	ret

0d03c448 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 d03c448:	defffc04 	addi	sp,sp,-16
 d03c44c:	dfc00315 	stw	ra,12(sp)
 d03c450:	df000215 	stw	fp,8(sp)
 d03c454:	df000204 	addi	fp,sp,8
 d03c458:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 d03c45c:	e0bfff17 	ldw	r2,-4(fp)
 d03c460:	1080bb04 	addi	r2,r2,748
 d03c464:	10800037 	ldwio	r2,0(r2)
 d03c468:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 d03c46c:	00fffc04 	movi	r3,-16
 d03c470:	e0bffe0b 	ldhu	r2,-8(fp)
 d03c474:	10c4703a 	and	r2,r2,r3
 d03c478:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 d03c47c:	01034174 	movhi	r4,3333
 d03c480:	2105d804 	addi	r4,r4,5984
 d03c484:	d002bc80 	call	d002bc8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 d03c488:	e0bfff17 	ldw	r2,-4(fp)
 d03c48c:	1080bb04 	addi	r2,r2,748
 d03c490:	1009883a 	mov	r4,r2
 d03c494:	e0bffe0b 	ldhu	r2,-8(fp)
 d03c498:	10800114 	ori	r2,r2,4
 d03c49c:	10ffffcc 	andi	r3,r2,65535
 d03c4a0:	2005883a 	mov	r2,r4
 d03c4a4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 d03c4a8:	01034174 	movhi	r4,3333
 d03c4ac:	2105ce04 	addi	r4,r4,5944
 d03c4b0:	d002bc80 	call	d002bc8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 d03c4b4:	e0bfff17 	ldw	r2,-4(fp)
 d03c4b8:	1080b404 	addi	r2,r2,720
 d03c4bc:	10800037 	ldwio	r2,0(r2)
 d03c4c0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 d03c4c4:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c4c8:	00bfdf44 	movi	r2,-131
 d03c4cc:	1884703a 	and	r2,r3,r2
 d03c4d0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 d03c4d4:	e0bfff17 	ldw	r2,-4(fp)
 d03c4d8:	1080b404 	addi	r2,r2,720
 d03c4dc:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c4e0:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 d03c4e4:	01034174 	movhi	r4,3333
 d03c4e8:	2105bd04 	addi	r4,r4,5876
 d03c4ec:	d002bc80 	call	d002bc8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d03c4f0:	e0bfff17 	ldw	r2,-4(fp)
 d03c4f4:	1080a004 	addi	r2,r2,640
 d03c4f8:	10800037 	ldwio	r2,0(r2)
 d03c4fc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 d03c500:	e0bfff17 	ldw	r2,-4(fp)
 d03c504:	1080a004 	addi	r2,r2,640
 d03c508:	1009883a 	mov	r4,r2
 d03c50c:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c510:	00a00004 	movi	r2,-32768
 d03c514:	1884b03a 	or	r2,r3,r2
 d03c518:	10ffffcc 	andi	r3,r2,65535
 d03c51c:	2005883a 	mov	r2,r4
 d03c520:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 d03c524:	00800044 	movi	r2,1
}
 d03c528:	e037883a 	mov	sp,fp
 d03c52c:	dfc00117 	ldw	ra,4(sp)
 d03c530:	df000017 	ldw	fp,0(sp)
 d03c534:	dec00204 	addi	sp,sp,8
 d03c538:	f800283a 	ret

0d03c53c <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 d03c53c:	defffc04 	addi	sp,sp,-16
 d03c540:	dfc00315 	stw	ra,12(sp)
 d03c544:	df000215 	stw	fp,8(sp)
 d03c548:	df000204 	addi	fp,sp,8
 d03c54c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 d03c550:	e0bfff17 	ldw	r2,-4(fp)
 d03c554:	1080bb04 	addi	r2,r2,748
 d03c558:	10800037 	ldwio	r2,0(r2)
 d03c55c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 d03c560:	00fffc04 	movi	r3,-16
 d03c564:	e0bffe0b 	ldhu	r2,-8(fp)
 d03c568:	10c4703a 	and	r2,r2,r3
 d03c56c:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 d03c570:	01034174 	movhi	r4,3333
 d03c574:	2105ed04 	addi	r4,r4,6068
 d03c578:	d002bc80 	call	d002bc8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 d03c57c:	e0bfff17 	ldw	r2,-4(fp)
 d03c580:	1080bb04 	addi	r2,r2,748
 d03c584:	1009883a 	mov	r4,r2
 d03c588:	e0bffe0b 	ldhu	r2,-8(fp)
 d03c58c:	108002d4 	ori	r2,r2,11
 d03c590:	10ffffcc 	andi	r3,r2,65535
 d03c594:	2005883a 	mov	r2,r4
 d03c598:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 d03c59c:	01034174 	movhi	r4,3333
 d03c5a0:	2105fc04 	addi	r4,r4,6128
 d03c5a4:	d002bc80 	call	d002bc8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 d03c5a8:	e0bfff17 	ldw	r2,-4(fp)
 d03c5ac:	1080b404 	addi	r2,r2,720
 d03c5b0:	10800037 	ldwio	r2,0(r2)
 d03c5b4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 d03c5b8:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c5bc:	00bfdf44 	movi	r2,-131
 d03c5c0:	1884703a 	and	r2,r3,r2
 d03c5c4:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 d03c5c8:	e0bffe0b 	ldhu	r2,-8(fp)
 d03c5cc:	10802094 	ori	r2,r2,130
 d03c5d0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 d03c5d4:	e0bfff17 	ldw	r2,-4(fp)
 d03c5d8:	1080b404 	addi	r2,r2,720
 d03c5dc:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c5e0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 d03c5e4:	01034174 	movhi	r4,3333
 d03c5e8:	2105bd04 	addi	r4,r4,5876
 d03c5ec:	d002bc80 	call	d002bc8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d03c5f0:	e0bfff17 	ldw	r2,-4(fp)
 d03c5f4:	1080a004 	addi	r2,r2,640
 d03c5f8:	10800037 	ldwio	r2,0(r2)
 d03c5fc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 d03c600:	e0bfff17 	ldw	r2,-4(fp)
 d03c604:	1080a004 	addi	r2,r2,640
 d03c608:	1009883a 	mov	r4,r2
 d03c60c:	e0fffe0b 	ldhu	r3,-8(fp)
 d03c610:	00a00004 	movi	r2,-32768
 d03c614:	1884b03a 	or	r2,r3,r2
 d03c618:	10ffffcc 	andi	r3,r2,65535
 d03c61c:	2005883a 	mov	r2,r4
 d03c620:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 d03c624:	00800044 	movi	r2,1
    
}
 d03c628:	e037883a 	mov	sp,fp
 d03c62c:	dfc00117 	ldw	ra,4(sp)
 d03c630:	df000017 	ldw	fp,0(sp)
 d03c634:	dec00204 	addi	sp,sp,8
 d03c638:	f800283a 	ret

0d03c63c <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 d03c63c:	defffc04 	addi	sp,sp,-16
 d03c640:	df000315 	stw	fp,12(sp)
 d03c644:	df000304 	addi	fp,sp,12
 d03c648:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 d03c64c:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 d03c650:	e0bfff17 	ldw	r2,-4(fp)
 d03c654:	1080b004 	addi	r2,r2,704
 d03c658:	10800037 	ldwio	r2,0(r2)
 d03c65c:	e0bffd15 	stw	r2,-12(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 d03c660:	e0bffd17 	ldw	r2,-12(fp)
 d03c664:	1080008c 	andi	r2,r2,2
 d03c668:	1005003a 	cmpeq	r2,r2,zero
 d03c66c:	1000041e 	bne	r2,zero,d03c680 <DP83848C_link_status_read+0x44>
		link_status |= 0x8;
 d03c670:	e0bffe17 	ldw	r2,-8(fp)
 d03c674:	10800214 	ori	r2,r2,8
 d03c678:	e0bffe15 	stw	r2,-8(fp)
 d03c67c:	00000306 	br	d03c68c <DP83848C_link_status_read+0x50>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 d03c680:	e0bffe17 	ldw	r2,-8(fp)
 d03c684:	10800114 	ori	r2,r2,4
 d03c688:	e0bffe15 	stw	r2,-8(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 d03c68c:	e0bffd17 	ldw	r2,-12(fp)
 d03c690:	1080010c 	andi	r2,r2,4
 d03c694:	1005003a 	cmpeq	r2,r2,zero
 d03c698:	1000031e 	bne	r2,zero,d03c6a8 <DP83848C_link_status_read+0x6c>
		link_status |= 0x1;
 d03c69c:	e0bffe17 	ldw	r2,-8(fp)
 d03c6a0:	10800054 	ori	r2,r2,1
 d03c6a4:	e0bffe15 	stw	r2,-8(fp)
	}
	
	return link_status;
 d03c6a8:	e0bffe17 	ldw	r2,-8(fp)
}
 d03c6ac:	e037883a 	mov	sp,fp
 d03c6b0:	df000017 	ldw	fp,0(sp)
 d03c6b4:	dec00104 	addi	sp,sp,4
 d03c6b8:	f800283a 	ret

0d03c6bc <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 d03c6bc:	defffb04 	addi	sp,sp,-20
 d03c6c0:	dfc00415 	stw	ra,16(sp)
 d03c6c4:	df000315 	stw	fp,12(sp)
 d03c6c8:	dc000215 	stw	r16,8(sp)
 d03c6cc:	df000204 	addi	fp,sp,8
   int   e = 0;
 d03c6d0:	e03fff15 	stw	zero,-4(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 d03c6d4:	d1204b17 	ldw	r4,-32468(gp)
 d03c6d8:	d002bc80 	call	d002bc8 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 d03c6dc:	01034174 	movhi	r4,3333
 d03c6e0:	21061104 	addi	r4,r4,6212
 d03c6e4:	d002bc80 	call	d002bc8 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 d03c6e8:	d0263b80 	call	d0263b8 <pre_task_setup>
 d03c6ec:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 d03c6f0:	e0bffe17 	ldw	r2,-8(fp)
 d03c6f4:	1005003a 	cmpeq	r2,r2,zero
 d03c6f8:	1000021e 	bne	r2,zero,d03c704 <netmain_init+0x48>
      panic(msg);
 d03c6fc:	e13ffe17 	ldw	r4,-8(fp)
 d03c700:	d02093c0 	call	d02093c <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 d03c704:	d01e4600 	call	d01e460 <ip_startup>
 d03c708:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 d03c70c:	e0bffe17 	ldw	r2,-8(fp)
 d03c710:	1005003a 	cmpeq	r2,r2,zero
 d03c714:	1000071e 	bne	r2,zero,d03c734 <netmain_init+0x78>
   {
      printf("inet startup error: %s\n", msg);
 d03c718:	01034174 	movhi	r4,3333
 d03c71c:	21062304 	addi	r4,r4,6284
 d03c720:	e17ffe17 	ldw	r5,-8(fp)
 d03c724:	d0028a00 	call	d0028a0 <printf>
      panic("IP");
 d03c728:	01034174 	movhi	r4,3333
 d03c72c:	21062904 	addi	r4,r4,6308
 d03c730:	d02093c0 	call	d02093c <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 d03c734:	d04732c0 	call	d04732c <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 d03c738:	d0468ec0 	call	d0468ec <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 d03c73c:	00834174 	movhi	r2,3333
 d03c740:	109b2004 	addi	r2,r2,27776
 d03c744:	10000015 	stw	zero,0(r2)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 d03c748:	008341b4 	movhi	r2,3334
 d03c74c:	10856304 	addi	r2,r2,5516
 d03c750:	10800017 	ldw	r2,0(r2)
 d03c754:	14000104 	addi	r16,r2,4
 d03c758:	008341b4 	movhi	r2,3334
 d03c75c:	10856304 	addi	r2,r2,5516
 d03c760:	10800017 	ldw	r2,0(r2)
 d03c764:	11000a17 	ldw	r4,40(r2)
 d03c768:	d02079c0 	call	d02079c <print_ipad>
 d03c76c:	100d883a 	mov	r6,r2
 d03c770:	01034174 	movhi	r4,3333
 d03c774:	21062a04 	addi	r4,r4,6312
 d03c778:	800b883a 	mov	r5,r16
 d03c77c:	d0028a00 	call	d0028a0 <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 d03c780:	d02642c0 	call	d02642c <post_task_setup>
 d03c784:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 d03c788:	e0bffe17 	ldw	r2,-8(fp)
 d03c78c:	1005003a 	cmpeq	r2,r2,zero
 d03c790:	1000021e 	bne	r2,zero,d03c79c <netmain_init+0xe0>
      panic(msg);
 d03c794:	e13ffe17 	ldw	r4,-8(fp)
 d03c798:	d02093c0 	call	d02093c <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 d03c79c:	d046f980 	call	d046f98 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 d03c7a0:	e037883a 	mov	sp,fp
 d03c7a4:	dfc00217 	ldw	ra,8(sp)
 d03c7a8:	df000117 	ldw	fp,4(sp)
 d03c7ac:	dc000017 	ldw	r16,0(sp)
 d03c7b0:	dec00304 	addi	sp,sp,12
 d03c7b4:	f800283a 	ret

0d03c7b8 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 d03c7b8:	defffb04 	addi	sp,sp,-20
 d03c7bc:	dfc00415 	stw	ra,16(sp)
 d03c7c0:	df000315 	stw	fp,12(sp)
 d03c7c4:	dc000215 	stw	r16,8(sp)
 d03c7c8:	df000204 	addi	fp,sp,8
 d03c7cc:	e13ffe15 	stw	r4,-8(fp)
 d03c7d0:	e17fff15 	stw	r5,-4(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 d03c7d4:	e0bfff17 	ldw	r2,-4(fp)
 d03c7d8:	10800003 	ldbu	r2,0(r2)
 d03c7dc:	10803fcc 	andi	r2,r2,255
 d03c7e0:	1080201c 	xori	r2,r2,128
 d03c7e4:	10bfe004 	addi	r2,r2,-128
 d03c7e8:	00c34174 	movhi	r3,3333
 d03c7ec:	18d1bb04 	addi	r3,r3,18156
 d03c7f0:	1085883a 	add	r2,r2,r2
 d03c7f4:	1085883a 	add	r2,r2,r2
 d03c7f8:	10c5883a 	add	r2,r2,r3
 d03c7fc:	14000017 	ldw	r16,0(r2)
 d03c800:	e0bffe17 	ldw	r2,-8(fp)
 d03c804:	11000717 	ldw	r4,28(r2)
 d03c808:	d02079c0 	call	d02079c <print_ipad>
 d03c80c:	100d883a 	mov	r6,r2
 d03c810:	01034174 	movhi	r4,3333
 d03c814:	21063a04 	addi	r4,r4,6376
 d03c818:	800b883a 	mov	r5,r16
 d03c81c:	d0028a00 	call	d0028a0 <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 d03c820:	d1204c17 	ldw	r4,-32464(gp)
 d03c824:	d0028a00 	call	d0028a0 <printf>
}
 d03c828:	e037883a 	mov	sp,fp
 d03c82c:	dfc00217 	ldw	ra,8(sp)
 d03c830:	df000117 	ldw	fp,4(sp)
 d03c834:	dc000017 	ldw	r16,0(sp)
 d03c838:	dec00304 	addi	sp,sp,12
 d03c83c:	f800283a 	ret

0d03c840 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 d03c840:	defff904 	addi	sp,sp,-28
 d03c844:	dfc00615 	stw	ra,24(sp)
 d03c848:	df000515 	stw	fp,20(sp)
 d03c84c:	dc000415 	stw	r16,16(sp)
 d03c850:	df000404 	addi	fp,sp,16
 d03c854:	e13fff15 	stw	r4,-4(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 d03c858:	e03ffe15 	stw	zero,-8(fp)
 d03c85c:	008341b4 	movhi	r2,3334
 d03c860:	10856304 	addi	r2,r2,5516
 d03c864:	10800017 	ldw	r2,0(r2)
 d03c868:	e0bffd15 	stw	r2,-12(fp)
 d03c86c:	00002206 	br	d03c8f8 <station_state+0xb8>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 d03c870:	e0bffd17 	ldw	r2,-12(fp)
 d03c874:	14000104 	addi	r16,r2,4
 d03c878:	e0bffd17 	ldw	r2,-12(fp)
 d03c87c:	11000a17 	ldw	r4,40(r2)
 d03c880:	d02079c0 	call	d02079c <print_ipad>
 d03c884:	d8800015 	stw	r2,0(sp)
 d03c888:	e13fff17 	ldw	r4,-4(fp)
 d03c88c:	01434174 	movhi	r5,3333
 d03c890:	29464304 	addi	r5,r5,6412
 d03c894:	e1bffe17 	ldw	r6,-8(fp)
 d03c898:	800f883a 	mov	r7,r16
 d03c89c:	d020b640 	call	d020b64 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 d03c8a0:	e0bffd17 	ldw	r2,-12(fp)
 d03c8a4:	11000c17 	ldw	r4,48(r2)
 d03c8a8:	d02079c0 	call	d02079c <print_ipad>
 d03c8ac:	100d883a 	mov	r6,r2
 d03c8b0:	e13fff17 	ldw	r4,-4(fp)
 d03c8b4:	01434174 	movhi	r5,3333
 d03c8b8:	29464a04 	addi	r5,r5,6440
 d03c8bc:	d020b640 	call	d020b64 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 d03c8c0:	e0bffd17 	ldw	r2,-12(fp)
 d03c8c4:	11000d17 	ldw	r4,52(r2)
 d03c8c8:	d02079c0 	call	d02079c <print_ipad>
 d03c8cc:	100d883a 	mov	r6,r2
 d03c8d0:	e13fff17 	ldw	r4,-4(fp)
 d03c8d4:	01434174 	movhi	r5,3333
 d03c8d8:	29464d04 	addi	r5,r5,6452
 d03c8dc:	d020b640 	call	d020b64 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 d03c8e0:	e0bffd17 	ldw	r2,-12(fp)
 d03c8e4:	10800017 	ldw	r2,0(r2)
 d03c8e8:	e0bffd15 	stw	r2,-12(fp)
 d03c8ec:	e0bffe17 	ldw	r2,-8(fp)
 d03c8f0:	10800044 	addi	r2,r2,1
 d03c8f4:	e0bffe15 	stw	r2,-8(fp)
 d03c8f8:	e0bffd17 	ldw	r2,-12(fp)
 d03c8fc:	1004c03a 	cmpne	r2,r2,zero
 d03c900:	103fdb1e 	bne	r2,zero,d03c870 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 d03c904:	00834174 	movhi	r2,3333
 d03c908:	109b4504 	addi	r2,r2,27924
 d03c90c:	11800017 	ldw	r6,0(r2)
 d03c910:	e13fff17 	ldw	r4,-4(fp)
 d03c914:	01434174 	movhi	r5,3333
 d03c918:	29465004 	addi	r5,r5,6464
 d03c91c:	d020b640 	call	d020b64 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 d03c920:	d4204d17 	ldw	r16,-32460(gp)
 d03c924:	d1204d17 	ldw	r4,-32460(gp)
 d03c928:	01400284 	movi	r5,10
 d03c92c:	d00235c0 	call	d00235c <__mulsi3>
 d03c930:	100f883a 	mov	r7,r2
 d03c934:	e13fff17 	ldw	r4,-4(fp)
 d03c938:	01434174 	movhi	r5,3333
 d03c93c:	29465604 	addi	r5,r5,6488
 d03c940:	800d883a 	mov	r6,r16
 d03c944:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 d03c948:	d1293917 	ldw	r4,-23324(gp)
 d03c94c:	d02079c0 	call	d02079c <print_ipad>
 d03c950:	100d883a 	mov	r6,r2
 d03c954:	e13fff17 	ldw	r4,-4(fp)
 d03c958:	01434174 	movhi	r5,3333
 d03c95c:	29466204 	addi	r5,r5,6536
 d03c960:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 d03c964:	d1a04e17 	ldw	r6,-32456(gp)
 d03c968:	e13fff17 	ldw	r4,-4(fp)
 d03c96c:	01434174 	movhi	r5,3333
 d03c970:	29466904 	addi	r5,r5,6564
 d03c974:	d020b640 	call	d020b64 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 d03c978:	e13fff17 	ldw	r4,-4(fp)
 d03c97c:	d03cfdc0 	call	d03cfdc <task_stats>

   return 0;
 d03c980:	0005883a 	mov	r2,zero
}
 d03c984:	e037883a 	mov	sp,fp
 d03c988:	dfc00217 	ldw	ra,8(sp)
 d03c98c:	df000117 	ldw	fp,4(sp)
 d03c990:	dc000017 	ldw	r16,0(sp)
 d03c994:	dec00304 	addi	sp,sp,12
 d03c998:	f800283a 	ret

0d03c99c <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 d03c99c:	defffe04 	addi	sp,sp,-8
 d03c9a0:	dfc00115 	stw	ra,4(sp)
 d03c9a4:	df000015 	stw	fp,0(sp)
 d03c9a8:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 d03c9ac:	00834174 	movhi	r2,3333
 d03c9b0:	109b4504 	addi	r2,r2,27924
 d03c9b4:	11000017 	ldw	r4,0(r2)
 d03c9b8:	01401904 	movi	r5,100
 d03c9bc:	d00c90c0 	call	d00c90c <__udivsi3>
 d03c9c0:	1009883a 	mov	r4,r2
 d03c9c4:	01401904 	movi	r5,100
 d03c9c8:	d00235c0 	call	d00235c <__mulsi3>
}
 d03c9cc:	e037883a 	mov	sp,fp
 d03c9d0:	dfc00117 	ldw	ra,4(sp)
 d03c9d4:	df000017 	ldw	fp,0(sp)
 d03c9d8:	dec00204 	addi	sp,sp,8
 d03c9dc:	f800283a 	ret

0d03c9e0 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 d03c9e0:	defffe04 	addi	sp,sp,-8
 d03c9e4:	dfc00115 	stw	ra,4(sp)
 d03c9e8:	df000015 	stw	fp,0(sp)
 d03c9ec:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 d03c9f0:	d0a93a17 	ldw	r2,-23320(gp)
 d03c9f4:	1004c03a 	cmpne	r2,r2,zero
 d03c9f8:	1000071e 	bne	r2,zero,d03ca18 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 d03c9fc:	d0a93a17 	ldw	r2,-23320(gp)
 d03ca00:	10800044 	addi	r2,r2,1
 d03ca04:	d0a93a15 	stw	r2,-23320(gp)
   pktdemux();          /* process low level packet input */
 d03ca08:	d01de180 	call	d01de18 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 d03ca0c:	d0a93a17 	ldw	r2,-23320(gp)
 d03ca10:	10bfffc4 	addi	r2,r2,-1
 d03ca14:	d0a93a15 	stw	r2,-23320(gp)
}
 d03ca18:	e037883a 	mov	sp,fp
 d03ca1c:	dfc00117 	ldw	ra,4(sp)
 d03ca20:	df000017 	ldw	fp,0(sp)
 d03ca24:	dec00204 	addi	sp,sp,8
 d03ca28:	f800283a 	ret

0d03ca2c <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 d03ca2c:	defffe04 	addi	sp,sp,-8
 d03ca30:	df000115 	stw	fp,4(sp)
 d03ca34:	df000104 	addi	fp,sp,4
 d03ca38:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 d03ca3c:	0005883a 	mov	r2,zero
}
 d03ca40:	e037883a 	mov	sp,fp
 d03ca44:	df000017 	ldw	fp,0(sp)
 d03ca48:	dec00104 	addi	sp,sp,4
 d03ca4c:	f800283a 	ret

0d03ca50 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 d03ca50:	defffd04 	addi	sp,sp,-12
 d03ca54:	dfc00215 	stw	ra,8(sp)
 d03ca58:	df000115 	stw	fp,4(sp)
 d03ca5c:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 d03ca60:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 d03ca64:	d04a4a40 	call	d04a4a4 <prep_vfs>
 d03ca68:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 d03ca6c:	e0bfff17 	ldw	r2,-4(fp)
 d03ca70:	1005003a 	cmpeq	r2,r2,zero
 d03ca74:	1000061e 	bne	r2,zero,d03ca90 <prep_modules+0x40>
   {
      dprintf("VFS Module prep failed\n");
 d03ca78:	01034174 	movhi	r4,3333
 d03ca7c:	21067104 	addi	r4,r4,6596
 d03ca80:	d002bc80 	call	d002bc8 <puts>
      panic("prep_modules");
 d03ca84:	01034174 	movhi	r4,3333
 d03ca88:	21067704 	addi	r4,r4,6620
 d03ca8c:	d02093c0 	call	d02093c <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 d03ca90:	0005883a 	mov	r2,zero
}
 d03ca94:	e037883a 	mov	sp,fp
 d03ca98:	dfc00117 	ldw	ra,4(sp)
 d03ca9c:	df000017 	ldw	fp,0(sp)
 d03caa0:	dec00204 	addi	sp,sp,8
 d03caa4:	f800283a 	ret

0d03caa8 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 d03caa8:	defffe04 	addi	sp,sp,-8
 d03caac:	dfc00115 	stw	ra,4(sp)
 d03cab0:	df000015 	stw	fp,0(sp)
 d03cab4:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 d03cab8:	00834174 	movhi	r2,3333
 d03cabc:	109b6704 	addi	r2,r2,28060
 d03cac0:	10c00017 	ldw	r3,0(r2)
 d03cac4:	00834174 	movhi	r2,3333
 d03cac8:	109b4504 	addi	r2,r2,27924
 d03cacc:	10800017 	ldw	r2,0(r2)
 d03cad0:	1880012e 	bgeu	r3,r2,d03cad8 <inet_timer+0x30>
      ip_reasm_process_timer_tick ();
 d03cad4:	d04210c0 	call	d04210c <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 d03cad8:	d027ffc0 	call	d027ffc <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 d03cadc:	d03cb6c0 	call	d03cb6c <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 d03cae0:	00834174 	movhi	r2,3333
 d03cae4:	109b2404 	addi	r2,r2,27792
 d03cae8:	10c00017 	ldw	r3,0(r2)
 d03caec:	00834174 	movhi	r2,3333
 d03caf0:	109b4504 	addi	r2,r2,27924
 d03caf4:	10800017 	ldw	r2,0(r2)
 d03caf8:	1880012e 	bgeu	r3,r2,d03cb00 <inet_timer+0x58>
      igmp_fasttimo();
 d03cafc:	d01eac40 	call	d01eac4 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 d03cb00:	d0a93b17 	ldw	r2,-23316(gp)
 d03cb04:	00c34174 	movhi	r3,3333
 d03cb08:	18db4504 	addi	r3,r3,27924
 d03cb0c:	18c00017 	ldw	r3,0(r3)
 d03cb10:	10c00636 	bltu	r2,r3,d03cb2c <inet_timer+0x84>
 d03cb14:	00834174 	movhi	r2,3333
 d03cb18:	109b4504 	addi	r2,r2,27924
 d03cb1c:	10800017 	ldw	r2,0(r2)
 d03cb20:	10c0fa04 	addi	r3,r2,1000
 d03cb24:	d0a93b17 	ldw	r2,-23316(gp)
 d03cb28:	18800b2e 	bgeu	r3,r2,d03cb58 <inet_timer+0xb0>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 d03cb2c:	00834174 	movhi	r2,3333
 d03cb30:	109b4504 	addi	r2,r2,27924
 d03cb34:	10800017 	ldw	r2,0(r2)
 d03cb38:	10801904 	addi	r2,r2,100
 d03cb3c:	d0a93b15 	stw	r2,-23316(gp)

      if (port_1s_callout != NULL)
 d03cb40:	d0a93c17 	ldw	r2,-23312(gp)
 d03cb44:	1005003a 	cmpeq	r2,r2,zero
 d03cb48:	1000021e 	bne	r2,zero,d03cb54 <inet_timer+0xac>
         (*port_1s_callout)();
 d03cb4c:	d0a93c17 	ldw	r2,-23312(gp)
 d03cb50:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 d03cb54:	d023f980 	call	d023f98 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 d03cb58:	e037883a 	mov	sp,fp
 d03cb5c:	dfc00117 	ldw	ra,4(sp)
 d03cb60:	df000017 	ldw	fp,0(sp)
 d03cb64:	dec00204 	addi	sp,sp,8
 d03cb68:	f800283a 	ret

0d03cb6c <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 d03cb6c:	defff904 	addi	sp,sp,-28
 d03cb70:	dfc00615 	stw	ra,24(sp)
 d03cb74:	df000515 	stw	fp,20(sp)
 d03cb78:	dc800415 	stw	r18,16(sp)
 d03cb7c:	dc400315 	stw	r17,12(sp)
 d03cb80:	dc000215 	stw	r16,8(sp)
 d03cb84:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 d03cb88:	e03ffe15 	stw	zero,-8(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 d03cb8c:	d0a93d17 	ldw	r2,-23308(gp)
 d03cb90:	10800050 	cmplti	r2,r2,1
 d03cb94:	1000631e 	bne	r2,zero,d03cd24 <check_interval_timers+0x1b8>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 d03cb98:	e03fff15 	stw	zero,-4(fp)
 d03cb9c:	00005e06 	br	d03cd18 <check_interval_timers+0x1ac>
      {
         if (intimers[i].callback)   /* is this timer active? */
 d03cba0:	e13fff17 	ldw	r4,-4(fp)
 d03cba4:	040341b4 	movhi	r16,3334
 d03cba8:	84050a04 	addi	r16,r16,5160
 d03cbac:	01400504 	movi	r5,20
 d03cbb0:	d00235c0 	call	d00235c <__mulsi3>
 d03cbb4:	1405883a 	add	r2,r2,r16
 d03cbb8:	10800017 	ldw	r2,0(r2)
 d03cbbc:	1005003a 	cmpeq	r2,r2,zero
 d03cbc0:	1000521e 	bne	r2,zero,d03cd0c <check_interval_timers+0x1a0>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 d03cbc4:	e13fff17 	ldw	r4,-4(fp)
 d03cbc8:	040341b4 	movhi	r16,3334
 d03cbcc:	84050a04 	addi	r16,r16,5160
 d03cbd0:	01400504 	movi	r5,20
 d03cbd4:	d00235c0 	call	d00235c <__mulsi3>
 d03cbd8:	1405883a 	add	r2,r2,r16
 d03cbdc:	10800304 	addi	r2,r2,12
 d03cbe0:	10c00017 	ldw	r3,0(r2)
 d03cbe4:	00834174 	movhi	r2,3333
 d03cbe8:	109b4504 	addi	r2,r2,27924
 d03cbec:	10800017 	ldw	r2,0(r2)
 d03cbf0:	1880402e 	bgeu	r3,r2,d03ccf4 <check_interval_timers+0x188>
 d03cbf4:	e13fff17 	ldw	r4,-4(fp)
 d03cbf8:	040341b4 	movhi	r16,3334
 d03cbfc:	84050a04 	addi	r16,r16,5160
 d03cc00:	01400504 	movi	r5,20
 d03cc04:	d00235c0 	call	d00235c <__mulsi3>
 d03cc08:	1405883a 	add	r2,r2,r16
 d03cc0c:	10800404 	addi	r2,r2,16
 d03cc10:	10800017 	ldw	r2,0(r2)
 d03cc14:	1004c03a 	cmpne	r2,r2,zero
 d03cc18:	1000361e 	bne	r2,zero,d03ccf4 <check_interval_timers+0x188>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 d03cc1c:	e4bfff17 	ldw	r18,-4(fp)
 d03cc20:	e13fff17 	ldw	r4,-4(fp)
 d03cc24:	040341b4 	movhi	r16,3334
 d03cc28:	84050a04 	addi	r16,r16,5160
 d03cc2c:	01400504 	movi	r5,20
 d03cc30:	d00235c0 	call	d00235c <__mulsi3>
 d03cc34:	1405883a 	add	r2,r2,r16
 d03cc38:	10800204 	addi	r2,r2,8
 d03cc3c:	10c00017 	ldw	r3,0(r2)
 d03cc40:	00834174 	movhi	r2,3333
 d03cc44:	109b4504 	addi	r2,r2,27924
 d03cc48:	10800017 	ldw	r2,0(r2)
 d03cc4c:	18a3883a 	add	r17,r3,r2
 d03cc50:	040341b4 	movhi	r16,3334
 d03cc54:	84050a04 	addi	r16,r16,5160
 d03cc58:	9009883a 	mov	r4,r18
 d03cc5c:	01400504 	movi	r5,20
 d03cc60:	d00235c0 	call	d00235c <__mulsi3>
 d03cc64:	1405883a 	add	r2,r2,r16
 d03cc68:	10800304 	addi	r2,r2,12
 d03cc6c:	14400015 	stw	r17,0(r2)
               intimers[i].inuse = TRUE;
 d03cc70:	e13fff17 	ldw	r4,-4(fp)
 d03cc74:	040341b4 	movhi	r16,3334
 d03cc78:	84050a04 	addi	r16,r16,5160
 d03cc7c:	01400504 	movi	r5,20
 d03cc80:	d00235c0 	call	d00235c <__mulsi3>
 d03cc84:	1405883a 	add	r2,r2,r16
 d03cc88:	10c00404 	addi	r3,r2,16
 d03cc8c:	00800044 	movi	r2,1
 d03cc90:	18800015 	stw	r2,0(r3)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 d03cc94:	e13fff17 	ldw	r4,-4(fp)
 d03cc98:	040341b4 	movhi	r16,3334
 d03cc9c:	84050a04 	addi	r16,r16,5160
 d03cca0:	01400504 	movi	r5,20
 d03cca4:	d00235c0 	call	d00235c <__mulsi3>
 d03cca8:	1405883a 	add	r2,r2,r16
 d03ccac:	14400017 	ldw	r17,0(r2)
 d03ccb0:	e13fff17 	ldw	r4,-4(fp)
 d03ccb4:	040341b4 	movhi	r16,3334
 d03ccb8:	84050a04 	addi	r16,r16,5160
 d03ccbc:	01400504 	movi	r5,20
 d03ccc0:	d00235c0 	call	d00235c <__mulsi3>
 d03ccc4:	1405883a 	add	r2,r2,r16
 d03ccc8:	10800104 	addi	r2,r2,4
 d03cccc:	11000017 	ldw	r4,0(r2)
 d03ccd0:	883ee83a 	callr	r17
               intimers[i].inuse = FALSE;
 d03ccd4:	e13fff17 	ldw	r4,-4(fp)
 d03ccd8:	040341b4 	movhi	r16,3334
 d03ccdc:	84050a04 	addi	r16,r16,5160
 d03cce0:	01400504 	movi	r5,20
 d03cce4:	d00235c0 	call	d00235c <__mulsi3>
 d03cce8:	1405883a 	add	r2,r2,r16
 d03ccec:	10800404 	addi	r2,r2,16
 d03ccf0:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 d03ccf4:	e0bffe17 	ldw	r2,-8(fp)
 d03ccf8:	10800044 	addi	r2,r2,1
 d03ccfc:	e0bffe15 	stw	r2,-8(fp)
 d03cd00:	d0e93d17 	ldw	r3,-23308(gp)
 d03cd04:	e0bffe17 	ldw	r2,-8(fp)
 d03cd08:	10c0060e 	bge	r2,r3,d03cd24 <check_interval_timers+0x1b8>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 d03cd0c:	e0bfff17 	ldw	r2,-4(fp)
 d03cd10:	10800044 	addi	r2,r2,1
 d03cd14:	e0bfff15 	stw	r2,-4(fp)
 d03cd18:	e0bfff17 	ldw	r2,-4(fp)
 d03cd1c:	10800150 	cmplti	r2,r2,5
 d03cd20:	103f9f1e 	bne	r2,zero,d03cba0 <check_interval_timers+0x34>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 d03cd24:	e037883a 	mov	sp,fp
 d03cd28:	dfc00417 	ldw	ra,16(sp)
 d03cd2c:	df000317 	ldw	fp,12(sp)
 d03cd30:	dc800217 	ldw	r18,8(sp)
 d03cd34:	dc400117 	ldw	r17,4(sp)
 d03cd38:	dc000017 	ldw	r16,0(sp)
 d03cd3c:	dec00504 	addi	sp,sp,20
 d03cd40:	f800283a 	ret

0d03cd44 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 d03cd44:	defff604 	addi	sp,sp,-40
 d03cd48:	dfc00915 	stw	ra,36(sp)
 d03cd4c:	df000815 	stw	fp,32(sp)
 d03cd50:	dc800715 	stw	r18,28(sp)
 d03cd54:	dc400615 	stw	r17,24(sp)
 d03cd58:	dc000515 	stw	r16,20(sp)
 d03cd5c:	df000504 	addi	fp,sp,20
 d03cd60:	e13ffc15 	stw	r4,-16(fp)
 d03cd64:	e17ffd15 	stw	r5,-12(fp)
 d03cd68:	e1bffe15 	stw	r6,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03cd6c:	e03ffb15 	stw	zero,-20(fp)
 d03cd70:	00005606 	br	d03cecc <in_timerset+0x188>
   {
      if(intimers[i].callback == NULL)
 d03cd74:	e13ffb17 	ldw	r4,-20(fp)
 d03cd78:	040341b4 	movhi	r16,3334
 d03cd7c:	84050a04 	addi	r16,r16,5160
 d03cd80:	01400504 	movi	r5,20
 d03cd84:	d00235c0 	call	d00235c <__mulsi3>
 d03cd88:	1405883a 	add	r2,r2,r16
 d03cd8c:	10800017 	ldw	r2,0(r2)
 d03cd90:	1004c03a 	cmpne	r2,r2,zero
 d03cd94:	10004a1e 	bne	r2,zero,d03cec0 <in_timerset+0x17c>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 d03cd98:	e13ffb17 	ldw	r4,-20(fp)
 d03cd9c:	040341b4 	movhi	r16,3334
 d03cda0:	84050a04 	addi	r16,r16,5160
 d03cda4:	01400504 	movi	r5,20
 d03cda8:	d00235c0 	call	d00235c <__mulsi3>
 d03cdac:	1407883a 	add	r3,r2,r16
 d03cdb0:	e0bffc17 	ldw	r2,-16(fp)
 d03cdb4:	18800015 	stw	r2,0(r3)
         intimers[i].parm = parm;
 d03cdb8:	e13ffb17 	ldw	r4,-20(fp)
 d03cdbc:	040341b4 	movhi	r16,3334
 d03cdc0:	84050a04 	addi	r16,r16,5160
 d03cdc4:	01400504 	movi	r5,20
 d03cdc8:	d00235c0 	call	d00235c <__mulsi3>
 d03cdcc:	1405883a 	add	r2,r2,r16
 d03cdd0:	10c00104 	addi	r3,r2,4
 d03cdd4:	e0bffe17 	ldw	r2,-8(fp)
 d03cdd8:	18800015 	stw	r2,0(r3)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 d03cddc:	e4bffb17 	ldw	r18,-20(fp)
 d03cde0:	e13ffd17 	ldw	r4,-12(fp)
 d03cde4:	01401904 	movi	r5,100
 d03cde8:	d00235c0 	call	d00235c <__mulsi3>
 d03cdec:	1009883a 	mov	r4,r2
 d03cdf0:	0140fa04 	movi	r5,1000
 d03cdf4:	d00c90c0 	call	d00c90c <__udivsi3>
 d03cdf8:	1023883a 	mov	r17,r2
 d03cdfc:	040341b4 	movhi	r16,3334
 d03ce00:	84050a04 	addi	r16,r16,5160
 d03ce04:	9009883a 	mov	r4,r18
 d03ce08:	01400504 	movi	r5,20
 d03ce0c:	d00235c0 	call	d00235c <__mulsi3>
 d03ce10:	1405883a 	add	r2,r2,r16
 d03ce14:	10800204 	addi	r2,r2,8
 d03ce18:	14400015 	stw	r17,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 d03ce1c:	e4bffb17 	ldw	r18,-20(fp)
 d03ce20:	e13ffb17 	ldw	r4,-20(fp)
 d03ce24:	040341b4 	movhi	r16,3334
 d03ce28:	84050a04 	addi	r16,r16,5160
 d03ce2c:	01400504 	movi	r5,20
 d03ce30:	d00235c0 	call	d00235c <__mulsi3>
 d03ce34:	1405883a 	add	r2,r2,r16
 d03ce38:	10800204 	addi	r2,r2,8
 d03ce3c:	10c00017 	ldw	r3,0(r2)
 d03ce40:	00834174 	movhi	r2,3333
 d03ce44:	109b4504 	addi	r2,r2,27924
 d03ce48:	10800017 	ldw	r2,0(r2)
 d03ce4c:	18a3883a 	add	r17,r3,r2
 d03ce50:	040341b4 	movhi	r16,3334
 d03ce54:	84050a04 	addi	r16,r16,5160
 d03ce58:	9009883a 	mov	r4,r18
 d03ce5c:	01400504 	movi	r5,20
 d03ce60:	d00235c0 	call	d00235c <__mulsi3>
 d03ce64:	1405883a 	add	r2,r2,r16
 d03ce68:	10800304 	addi	r2,r2,12
 d03ce6c:	14400015 	stw	r17,0(r2)
		 intimers[i].inuse = FALSE;
 d03ce70:	e13ffb17 	ldw	r4,-20(fp)
 d03ce74:	040341b4 	movhi	r16,3334
 d03ce78:	84050a04 	addi	r16,r16,5160
 d03ce7c:	01400504 	movi	r5,20
 d03ce80:	d00235c0 	call	d00235c <__mulsi3>
 d03ce84:	1405883a 	add	r2,r2,r16
 d03ce88:	10800404 	addi	r2,r2,16
 d03ce8c:	10000015 	stw	zero,0(r2)
         numtimers++;
 d03ce90:	d0a93d17 	ldw	r2,-23308(gp)
 d03ce94:	10800044 	addi	r2,r2,1
 d03ce98:	d0a93d15 	stw	r2,-23308(gp)
         return (long)&intimers[i];
 d03ce9c:	e13ffb17 	ldw	r4,-20(fp)
 d03cea0:	01400504 	movi	r5,20
 d03cea4:	d00235c0 	call	d00235c <__mulsi3>
 d03cea8:	1007883a 	mov	r3,r2
 d03ceac:	008341b4 	movhi	r2,3334
 d03ceb0:	10850a04 	addi	r2,r2,5160
 d03ceb4:	1885883a 	add	r2,r3,r2
 d03ceb8:	e0bfff15 	stw	r2,-4(fp)
 d03cebc:	00000706 	br	d03cedc <in_timerset+0x198>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03cec0:	e0bffb17 	ldw	r2,-20(fp)
 d03cec4:	10800044 	addi	r2,r2,1
 d03cec8:	e0bffb15 	stw	r2,-20(fp)
 d03cecc:	e0bffb17 	ldw	r2,-20(fp)
 d03ced0:	10800150 	cmplti	r2,r2,5
 d03ced4:	103fa71e 	bne	r2,zero,d03cd74 <in_timerset+0x30>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 d03ced8:	e03fff15 	stw	zero,-4(fp)
 d03cedc:	e0bfff17 	ldw	r2,-4(fp)
}
 d03cee0:	e037883a 	mov	sp,fp
 d03cee4:	dfc00417 	ldw	ra,16(sp)
 d03cee8:	df000317 	ldw	fp,12(sp)
 d03ceec:	dc800217 	ldw	r18,8(sp)
 d03cef0:	dc400117 	ldw	r17,4(sp)
 d03cef4:	dc000017 	ldw	r16,0(sp)
 d03cef8:	dec00504 	addi	sp,sp,20
 d03cefc:	f800283a 	ret

0d03cf00 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 d03cf00:	defffa04 	addi	sp,sp,-24
 d03cf04:	dfc00515 	stw	ra,20(sp)
 d03cf08:	df000415 	stw	fp,16(sp)
 d03cf0c:	dc000315 	stw	r16,12(sp)
 d03cf10:	df000304 	addi	fp,sp,12
 d03cf14:	e13ffe15 	stw	r4,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03cf18:	e03ffd15 	stw	zero,-12(fp)
 d03cf1c:	00001906 	br	d03cf84 <in_timerkill+0x84>
   {
      if(timer == (long)&intimers[i])
 d03cf20:	e13ffd17 	ldw	r4,-12(fp)
 d03cf24:	01400504 	movi	r5,20
 d03cf28:	d00235c0 	call	d00235c <__mulsi3>
 d03cf2c:	1007883a 	mov	r3,r2
 d03cf30:	008341b4 	movhi	r2,3334
 d03cf34:	10850a04 	addi	r2,r2,5160
 d03cf38:	1885883a 	add	r2,r3,r2
 d03cf3c:	1007883a 	mov	r3,r2
 d03cf40:	e0bffe17 	ldw	r2,-8(fp)
 d03cf44:	18800c1e 	bne	r3,r2,d03cf78 <in_timerkill+0x78>
      {
         intimers[i].callback = NULL;
 d03cf48:	e13ffd17 	ldw	r4,-12(fp)
 d03cf4c:	040341b4 	movhi	r16,3334
 d03cf50:	84050a04 	addi	r16,r16,5160
 d03cf54:	01400504 	movi	r5,20
 d03cf58:	d00235c0 	call	d00235c <__mulsi3>
 d03cf5c:	1405883a 	add	r2,r2,r16
 d03cf60:	10000015 	stw	zero,0(r2)
         numtimers--;
 d03cf64:	d0a93d17 	ldw	r2,-23308(gp)
 d03cf68:	10bfffc4 	addi	r2,r2,-1
 d03cf6c:	d0a93d15 	stw	r2,-23308(gp)
         return 0;      /* OK return */
 d03cf70:	e03fff15 	stw	zero,-4(fp)
 d03cf74:	00000906 	br	d03cf9c <in_timerkill+0x9c>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03cf78:	e0bffd17 	ldw	r2,-12(fp)
 d03cf7c:	10800044 	addi	r2,r2,1
 d03cf80:	e0bffd15 	stw	r2,-12(fp)
 d03cf84:	e0bffd17 	ldw	r2,-12(fp)
 d03cf88:	10800150 	cmplti	r2,r2,5
 d03cf8c:	103fe41e 	bne	r2,zero,d03cf20 <in_timerkill+0x20>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 d03cf90:	d025a500 	call	d025a50 <dtrap>
   return ENP_PARAM;
 d03cf94:	00bffd84 	movi	r2,-10
 d03cf98:	e0bfff15 	stw	r2,-4(fp)
 d03cf9c:	e0bfff17 	ldw	r2,-4(fp)
}
 d03cfa0:	e037883a 	mov	sp,fp
 d03cfa4:	dfc00217 	ldw	ra,8(sp)
 d03cfa8:	df000117 	ldw	fp,4(sp)
 d03cfac:	dc000017 	ldw	r16,0(sp)
 d03cfb0:	dec00304 	addi	sp,sp,12
 d03cfb4:	f800283a 	ret

0d03cfb8 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 d03cfb8:	defffe04 	addi	sp,sp,-8
 d03cfbc:	df000115 	stw	fp,4(sp)
 d03cfc0:	df000104 	addi	fp,sp,4
int e = 0;
 d03cfc4:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 d03cfc8:	e0bfff17 	ldw	r2,-4(fp)
}
 d03cfcc:	e037883a 	mov	sp,fp
 d03cfd0:	df000017 	ldw	fp,0(sp)
 d03cfd4:	dec00104 	addi	sp,sp,4
 d03cfd8:	f800283a 	ret

0d03cfdc <task_stats>:
 */


void
task_stats(void * pio)
{
 d03cfdc:	defffd04 	addi	sp,sp,-12
 d03cfe0:	dfc00215 	stw	ra,8(sp)
 d03cfe4:	df000115 	stw	fp,4(sp)
 d03cfe8:	df000104 	addi	fp,sp,4
 d03cfec:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 d03cff0:	e13fff17 	ldw	r4,-4(fp)
 d03cff4:	01434174 	movhi	r5,3333
 d03cff8:	29467b04 	addi	r5,r5,6636
 d03cffc:	d020b640 	call	d020b64 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 d03d000:	00834174 	movhi	r2,3333
 d03d004:	109b2704 	addi	r2,r2,27804
 d03d008:	11800017 	ldw	r6,0(r2)
 d03d00c:	e13fff17 	ldw	r4,-4(fp)
 d03d010:	01434174 	movhi	r5,3333
 d03d014:	29467f04 	addi	r5,r5,6652
 d03d018:	d020b640 	call	d020b64 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 d03d01c:	00834174 	movhi	r2,3333
 d03d020:	109b2804 	addi	r2,r2,27808
 d03d024:	11800017 	ldw	r6,0(r2)
 d03d028:	e13fff17 	ldw	r4,-4(fp)
 d03d02c:	01434174 	movhi	r5,3333
 d03d030:	29468304 	addi	r5,r5,6668
 d03d034:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 d03d038:	e13fff17 	ldw	r4,-4(fp)
 d03d03c:	01434174 	movhi	r5,3333
 d03d040:	29468704 	addi	r5,r5,6684
 d03d044:	d020b640 	call	d020b64 <ns_printf>
}
 d03d048:	e037883a 	mov	sp,fp
 d03d04c:	dfc00117 	ldw	ra,4(sp)
 d03d050:	df000017 	ldw	fp,0(sp)
 d03d054:	dec00204 	addi	sp,sp,8
 d03d058:	f800283a 	ret

0d03d05c <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 d03d05c:	defff704 	addi	sp,sp,-36
 d03d060:	dfc00615 	stw	ra,24(sp)
 d03d064:	df000515 	stw	fp,20(sp)
 d03d068:	df000504 	addi	fp,sp,20
 d03d06c:	e13ffd15 	stw	r4,-12(fp)
 d03d070:	e1800215 	stw	r6,8(fp)
 d03d074:	e1c00315 	stw	r7,12(fp)
 d03d078:	e17ffe15 	stw	r5,-8(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 d03d07c:	e0bffd17 	ldw	r2,-12(fp)
 d03d080:	10800808 	cmpgei	r2,r2,32
 d03d084:	10000e1e 	bne	r2,zero,d03d0c0 <fcntl+0x64>
  {
    va_start(argp, cmd);
 d03d088:	e0800204 	addi	r2,fp,8
 d03d08c:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 d03d090:	e0fffc17 	ldw	r3,-16(fp)
 d03d094:	18800104 	addi	r2,r3,4
 d03d098:	e0bffc15 	stw	r2,-16(fp)
 d03d09c:	1805883a 	mov	r2,r3
 d03d0a0:	10800017 	ldw	r2,0(r2)
 d03d0a4:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 d03d0a8:	e13ffd17 	ldw	r4,-12(fp)
 d03d0ac:	e17ffe17 	ldw	r5,-8(fp)
 d03d0b0:	e1bffb17 	ldw	r6,-20(fp)
 d03d0b4:	d04a6240 	call	d04a624 <alt_fcntl>
 d03d0b8:	e0bfff15 	stw	r2,-4(fp)
 d03d0bc:	00000d06 	br	d03d0f4 <fcntl+0x98>
  }
  else
  {
    va_start(argp, cmd);
 d03d0c0:	e0800204 	addi	r2,fp,8
 d03d0c4:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 d03d0c8:	e0fffc17 	ldw	r3,-16(fp)
 d03d0cc:	18800104 	addi	r2,r3,4
 d03d0d0:	e0bffc15 	stw	r2,-16(fp)
 d03d0d4:	1805883a 	mov	r2,r3
 d03d0d8:	10800017 	ldw	r2,0(r2)
 d03d0dc:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 d03d0e0:	e17ffe17 	ldw	r5,-8(fp)
 d03d0e4:	e13ffd17 	ldw	r4,-12(fp)
 d03d0e8:	e1bffb17 	ldw	r6,-20(fp)
 d03d0ec:	d01ff900 	call	d01ff90 <bsd_ioctl>
 d03d0f0:	e0bfff15 	stw	r2,-4(fp)
 d03d0f4:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 d03d0f8:	e037883a 	mov	sp,fp
 d03d0fc:	dfc00117 	ldw	ra,4(sp)
 d03d100:	df000017 	ldw	fp,0(sp)
 d03d104:	dec00404 	addi	sp,sp,16
 d03d108:	f800283a 	ret

0d03d10c <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 d03d10c:	defffd04 	addi	sp,sp,-12
 d03d110:	dfc00215 	stw	ra,8(sp)
 d03d114:	df000115 	stw	fp,4(sp)
 d03d118:	df000104 	addi	fp,sp,4
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 d03d11c:	01018204 	movi	r4,1544
 d03d120:	d03e7100 	call	d03e710 <reg_type>
 d03d124:	1005003a 	cmpeq	r2,r2,zero
 d03d128:	1000061e 	bne	r2,zero,d03d144 <etainit+0x38>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 d03d12c:	01034174 	movhi	r4,3333
 d03d130:	21068804 	addi	r4,r4,6688
 d03d134:	d002bc80 	call	d002bc8 <puts>
#endif
      return (1);
 d03d138:	00800044 	movi	r2,1
 d03d13c:	e0bfff15 	stw	r2,-4(fp)
 d03d140:	00000106 	br	d03d148 <etainit+0x3c>
   }
   return (0);
 d03d144:	e03fff15 	stw	zero,-4(fp)
 d03d148:	e0bfff17 	ldw	r2,-4(fp)
}
 d03d14c:	e037883a 	mov	sp,fp
 d03d150:	dfc00117 	ldw	ra,4(sp)
 d03d154:	df000017 	ldw	fp,0(sp)
 d03d158:	dec00204 	addi	sp,sp,8
 d03d15c:	f800283a 	ret

0d03d160 <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 d03d160:	defff904 	addi	sp,sp,-28
 d03d164:	dfc00615 	stw	ra,24(sp)
 d03d168:	df000515 	stw	fp,20(sp)
 d03d16c:	df000504 	addi	fp,sp,20
 d03d170:	e13ffe15 	stw	r4,-8(fp)
 d03d174:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 d03d178:	e0bffe17 	ldw	r2,-8(fp)
 d03d17c:	10800617 	ldw	r2,24(r2)
 d03d180:	10802717 	ldw	r2,156(r2)
 d03d184:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 d03d188:	00834174 	movhi	r2,3333
 d03d18c:	109b4504 	addi	r2,r2,27924
 d03d190:	10c00017 	ldw	r3,0(r2)
 d03d194:	e0bfff17 	ldw	r2,-4(fp)
 d03d198:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 d03d19c:	e0bffe17 	ldw	r2,-8(fp)
 d03d1a0:	10800317 	ldw	r2,12(r2)
 d03d1a4:	10fffc04 	addi	r3,r2,-16
 d03d1a8:	e0bffe17 	ldw	r2,-8(fp)
 d03d1ac:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 d03d1b0:	e0bffe17 	ldw	r2,-8(fp)
 d03d1b4:	10800417 	ldw	r2,16(r2)
 d03d1b8:	10c00404 	addi	r3,r2,16
 d03d1bc:	e0bffe17 	ldw	r2,-8(fp)
 d03d1c0:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 d03d1c4:	e0bffe17 	ldw	r2,-8(fp)
 d03d1c8:	10800317 	ldw	r2,12(r2)
 d03d1cc:	10800084 	addi	r2,r2,2
 d03d1d0:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 d03d1d4:	e0bffe17 	ldw	r2,-8(fp)
 d03d1d8:	10c00117 	ldw	r3,4(r2)
 d03d1dc:	e0bffd17 	ldw	r2,-12(fp)
 d03d1e0:	10c0032e 	bgeu	r2,r3,d03d1f0 <et_send+0x90>
      panic("et_send: prepend");
 d03d1e4:	01034174 	movhi	r4,3333
 d03d1e8:	21069404 	addi	r4,r4,6736
 d03d1ec:	d02093c0 	call	d02093c <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 d03d1f0:	e0bfff17 	ldw	r2,-4(fp)
 d03d1f4:	11400104 	addi	r5,r2,4
 d03d1f8:	e13ffd17 	ldw	r4,-12(fp)
 d03d1fc:	01800184 	movi	r6,6
 d03d200:	d0026a80 	call	d0026a8 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 d03d204:	e0bffd17 	ldw	r2,-12(fp)
 d03d208:	11000184 	addi	r4,r2,6
 d03d20c:	e0bffc17 	ldw	r2,-16(fp)
 d03d210:	11400517 	ldw	r5,20(r2)
 d03d214:	01800184 	movi	r6,6
 d03d218:	d0026a80 	call	d0026a8 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 d03d21c:	e0bfff17 	ldw	r2,-4(fp)
 d03d220:	1080070b 	ldhu	r2,28(r2)
 d03d224:	10bfffcc 	andi	r2,r2,65535
 d03d228:	108000cc 	andi	r2,r2,3
 d03d22c:	108000a0 	cmpeqi	r2,r2,2
 d03d230:	1000041e 	bne	r2,zero,d03d244 <et_send+0xe4>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 d03d234:	e0bffd17 	ldw	r2,-12(fp)
 d03d238:	10c00304 	addi	r3,r2,12
 d03d23c:	00800204 	movi	r2,8
 d03d240:	18800005 	stb	r2,0(r3)
 d03d244:	e0bffd17 	ldw	r2,-12(fp)
 d03d248:	10800344 	addi	r2,r2,13
 d03d24c:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 d03d250:	e0bffe17 	ldw	r2,-8(fp)
 d03d254:	10800617 	ldw	r2,24(r2)
 d03d258:	10800417 	ldw	r2,16(r2)
 d03d25c:	1005003a 	cmpeq	r2,r2,zero
 d03d260:	1000071e 	bne	r2,zero,d03d280 <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 d03d264:	e0bffe17 	ldw	r2,-8(fp)
 d03d268:	10800617 	ldw	r2,24(r2)
 d03d26c:	10800417 	ldw	r2,16(r2)
 d03d270:	e13ffe17 	ldw	r4,-8(fp)
 d03d274:	103ee83a 	callr	r2
 d03d278:	e0bffb15 	stw	r2,-20(fp)
 d03d27c:	00001106 	br	d03d2c4 <et_send+0x164>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 d03d280:	e0bffe17 	ldw	r2,-8(fp)
 d03d284:	10800617 	ldw	r2,24(r2)
 d03d288:	10c00317 	ldw	r3,12(r2)
 d03d28c:	e0bffe17 	ldw	r2,-8(fp)
 d03d290:	11000617 	ldw	r4,24(r2)
 d03d294:	e0bffe17 	ldw	r2,-8(fp)
 d03d298:	11400317 	ldw	r5,12(r2)
 d03d29c:	e0bffe17 	ldw	r2,-8(fp)
 d03d2a0:	11800417 	ldw	r6,16(r2)
 d03d2a4:	183ee83a 	callr	r3
 d03d2a8:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d2ac:	01000084 	movi	r4,2
 d03d2b0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d03d2b4:	e13ffe17 	ldw	r4,-8(fp)
 d03d2b8:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d2bc:	01000084 	movi	r4,2
 d03d2c0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 d03d2c4:	e0bffb17 	ldw	r2,-20(fp)
}
 d03d2c8:	e037883a 	mov	sp,fp
 d03d2cc:	dfc00117 	ldw	ra,4(sp)
 d03d2d0:	df000017 	ldw	fp,0(sp)
 d03d2d4:	dec00204 	addi	sp,sp,8
 d03d2d8:	f800283a 	ret

0d03d2dc <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 d03d2dc:	defffb04 	addi	sp,sp,-20
 d03d2e0:	dfc00415 	stw	ra,16(sp)
 d03d2e4:	df000315 	stw	fp,12(sp)
 d03d2e8:	df000304 	addi	fp,sp,12
 d03d2ec:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 d03d2f0:	e0bfff17 	ldw	r2,-4(fp)
 d03d2f4:	10800417 	ldw	r2,16(r2)
 d03d2f8:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;
 d03d2fc:	e0bfff17 	ldw	r2,-4(fp)
 d03d300:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d304:	01000084 	movi	r4,2
 d03d308:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 d03d30c:	00000906 	br	d03d334 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 d03d310:	e0bffe17 	ldw	r2,-8(fp)
 d03d314:	10800017 	ldw	r2,0(r2)
 d03d318:	e0bffd15 	stw	r2,-12(fp)
      tmppkt->next = (PACKET)NULL;
 d03d31c:	e0bffe17 	ldw	r2,-8(fp)
 d03d320:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 d03d324:	e13ffe17 	ldw	r4,-8(fp)
 d03d328:	d0251a00 	call	d0251a0 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 d03d32c:	e0bffd17 	ldw	r2,-12(fp)
 d03d330:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 d03d334:	e0bffe17 	ldw	r2,-8(fp)
 d03d338:	1004c03a 	cmpne	r2,r2,zero
 d03d33c:	103ff41e 	bne	r2,zero,d03d310 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 d03d340:	e0bfff17 	ldw	r2,-4(fp)
 d03d344:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d348:	01000084 	movi	r4,2
 d03d34c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
}
 d03d350:	e037883a 	mov	sp,fp
 d03d354:	dfc00117 	ldw	ra,4(sp)
 d03d358:	df000017 	ldw	fp,0(sp)
 d03d35c:	dec00204 	addi	sp,sp,8
 d03d360:	f800283a 	ret

0d03d364 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 d03d364:	defffc04 	addi	sp,sp,-16
 d03d368:	dfc00315 	stw	ra,12(sp)
 d03d36c:	df000215 	stw	fp,8(sp)
 d03d370:	df000204 	addi	fp,sp,8
 d03d374:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 d03d378:	e0bfff17 	ldw	r2,-4(fp)
 d03d37c:	10800417 	ldw	r2,16(r2)
 d03d380:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 d03d384:	00000906 	br	d03d3ac <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 d03d388:	e0bffe17 	ldw	r2,-8(fp)
 d03d38c:	10c00017 	ldw	r3,0(r2)
 d03d390:	e0bfff17 	ldw	r2,-4(fp)
 d03d394:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 d03d398:	e0bffe17 	ldw	r2,-8(fp)
 d03d39c:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 d03d3a0:	e13ffe17 	ldw	r4,-8(fp)
 d03d3a4:	e17fff17 	ldw	r5,-4(fp)
 d03d3a8:	d03d1600 	call	d03d160 <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 d03d3ac:	e0bfff17 	ldw	r2,-4(fp)
 d03d3b0:	10800417 	ldw	r2,16(r2)
 d03d3b4:	e0bffe15 	stw	r2,-8(fp)
 d03d3b8:	e0bffe17 	ldw	r2,-8(fp)
 d03d3bc:	1004c03a 	cmpne	r2,r2,zero
 d03d3c0:	103ff11e 	bne	r2,zero,d03d388 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 d03d3c4:	e037883a 	mov	sp,fp
 d03d3c8:	dfc00117 	ldw	ra,4(sp)
 d03d3cc:	df000017 	ldw	fp,0(sp)
 d03d3d0:	dec00204 	addi	sp,sp,8
 d03d3d4:	f800283a 	ret

0d03d3d8 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 d03d3d8:	defff304 	addi	sp,sp,-52
 d03d3dc:	dfc00c15 	stw	ra,48(sp)
 d03d3e0:	df000b15 	stw	fp,44(sp)
 d03d3e4:	df000b04 	addi	fp,sp,44
 d03d3e8:	e13ffd15 	stw	r4,-12(fp)
 d03d3ec:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 d03d3f0:	e0bffd17 	ldw	r2,-12(fp)
 d03d3f4:	10800617 	ldw	r2,24(r2)
 d03d3f8:	e0bff915 	stw	r2,-28(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 d03d3fc:	e0bffd17 	ldw	r2,-12(fp)
 d03d400:	10800617 	ldw	r2,24(r2)
 d03d404:	10802717 	ldw	r2,156(r2)
 d03d408:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 d03d40c:	e0bffe17 	ldw	r2,-8(fp)
 d03d410:	10bfffe0 	cmpeqi	r2,r2,-1
 d03d414:	10001b1e 	bne	r2,zero,d03d484 <send_arp+0xac>
 d03d418:	e0bff917 	ldw	r2,-28(fp)
 d03d41c:	10800c17 	ldw	r2,48(r2)
 d03d420:	0086303a 	nor	r3,zero,r2
 d03d424:	e0bffe17 	ldw	r2,-8(fp)
 d03d428:	1886703a 	and	r3,r3,r2
 d03d42c:	e0bff917 	ldw	r2,-28(fp)
 d03d430:	10800c17 	ldw	r2,48(r2)
 d03d434:	0084303a 	nor	r2,zero,r2
 d03d438:	18801226 	beq	r3,r2,d03d484 <send_arp+0xac>
 d03d43c:	e0bffe17 	ldw	r2,-8(fp)
 d03d440:	1004d63a 	srli	r2,r2,24
 d03d444:	10c03fcc 	andi	r3,r2,255
 d03d448:	e0bffe17 	ldw	r2,-8(fp)
 d03d44c:	1004d23a 	srli	r2,r2,8
 d03d450:	10bfc00c 	andi	r2,r2,65280
 d03d454:	1886b03a 	or	r3,r3,r2
 d03d458:	e0bffe17 	ldw	r2,-8(fp)
 d03d45c:	10bfc00c 	andi	r2,r2,65280
 d03d460:	1004923a 	slli	r2,r2,8
 d03d464:	1886b03a 	or	r3,r3,r2
 d03d468:	e0bffe17 	ldw	r2,-8(fp)
 d03d46c:	10803fcc 	andi	r2,r2,255
 d03d470:	1004963a 	slli	r2,r2,24
 d03d474:	1884b03a 	or	r2,r3,r2
 d03d478:	10fc002c 	andhi	r3,r2,61440
 d03d47c:	00b80034 	movhi	r2,57344
 d03d480:	1880441e 	bne	r3,r2,d03d594 <send_arp+0x1bc>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 d03d484:	e0bffd17 	ldw	r2,-12(fp)
 d03d488:	11400617 	ldw	r5,24(r2)
 d03d48c:	e13ffe17 	ldw	r4,-8(fp)
 d03d490:	d03da180 	call	d03da18 <make_arp_entry>
 d03d494:	e0bffb15 	stw	r2,-20(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 d03d498:	e0bffb17 	ldw	r2,-20(fp)
 d03d49c:	10c00104 	addi	r3,r2,4
 d03d4a0:	00bfffc4 	movi	r2,-1
 d03d4a4:	18800005 	stb	r2,0(r3)
 d03d4a8:	00bfffc4 	movi	r2,-1
 d03d4ac:	18800045 	stb	r2,1(r3)
 d03d4b0:	00bfffc4 	movi	r2,-1
 d03d4b4:	18800085 	stb	r2,2(r3)
 d03d4b8:	00bfffc4 	movi	r2,-1
 d03d4bc:	188000c5 	stb	r2,3(r3)
 d03d4c0:	00bfffc4 	movi	r2,-1
 d03d4c4:	18800105 	stb	r2,4(r3)
 d03d4c8:	00bfffc4 	movi	r2,-1
 d03d4cc:	18800145 	stb	r2,5(r3)
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 d03d4d0:	e0bffd17 	ldw	r2,-12(fp)
 d03d4d4:	10800617 	ldw	r2,24(r2)
 d03d4d8:	10802b17 	ldw	r2,172(r2)
 d03d4dc:	1005003a 	cmpeq	r2,r2,zero
 d03d4e0:	1000271e 	bne	r2,zero,d03d580 <send_arp+0x1a8>
 d03d4e4:	e0bffe17 	ldw	r2,-8(fp)
 d03d4e8:	1004d63a 	srli	r2,r2,24
 d03d4ec:	10c03fcc 	andi	r3,r2,255
 d03d4f0:	e0bffe17 	ldw	r2,-8(fp)
 d03d4f4:	1004d23a 	srli	r2,r2,8
 d03d4f8:	10bfc00c 	andi	r2,r2,65280
 d03d4fc:	1886b03a 	or	r3,r3,r2
 d03d500:	e0bffe17 	ldw	r2,-8(fp)
 d03d504:	10bfc00c 	andi	r2,r2,65280
 d03d508:	1004923a 	slli	r2,r2,8
 d03d50c:	1886b03a 	or	r3,r3,r2
 d03d510:	e0bffe17 	ldw	r2,-8(fp)
 d03d514:	10803fcc 	andi	r2,r2,255
 d03d518:	1004963a 	slli	r2,r2,24
 d03d51c:	1884b03a 	or	r2,r3,r2
 d03d520:	10fc002c 	andhi	r3,r2,61440
 d03d524:	00b80034 	movhi	r2,57344
 d03d528:	1880151e 	bne	r3,r2,d03d580 <send_arp+0x1a8>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 d03d52c:	e0bffe17 	ldw	r2,-8(fp)
 d03d530:	e0bffc15 	stw	r2,-16(fp)
         oldest->t_phy_addr[0] = 0x01;
 d03d534:	e0fffb17 	ldw	r3,-20(fp)
 d03d538:	00800044 	movi	r2,1
 d03d53c:	18800105 	stb	r2,4(r3)
         oldest->t_phy_addr[1] = 0x00;
 d03d540:	e0bffb17 	ldw	r2,-20(fp)
 d03d544:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 d03d548:	e0fffb17 	ldw	r3,-20(fp)
 d03d54c:	00801784 	movi	r2,94
 d03d550:	18800185 	stb	r2,6(r3)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 d03d554:	e0bffc43 	ldbu	r2,-15(fp)
 d03d558:	10801fcc 	andi	r2,r2,127
 d03d55c:	1007883a 	mov	r3,r2
 d03d560:	e0bffb17 	ldw	r2,-20(fp)
 d03d564:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 d03d568:	e0fffc83 	ldbu	r3,-14(fp)
 d03d56c:	e0bffb17 	ldw	r2,-20(fp)
 d03d570:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 d03d574:	e0fffcc3 	ldbu	r3,-13(fp)
 d03d578:	e0bffb17 	ldw	r2,-20(fp)
 d03d57c:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 d03d580:	e13ffd17 	ldw	r4,-12(fp)
 d03d584:	e17ffb17 	ldw	r5,-20(fp)
 d03d588:	d03d1600 	call	d03d160 <et_send>
 d03d58c:	e0bfff15 	stw	r2,-4(fp)
 d03d590:	0000b106 	br	d03d858 <send_arp+0x480>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 d03d594:	e0bffd17 	ldw	r2,-12(fp)
 d03d598:	10c00717 	ldw	r3,28(r2)
 d03d59c:	e0bffd17 	ldw	r2,-12(fp)
 d03d5a0:	10800617 	ldw	r2,24(r2)
 d03d5a4:	10800a17 	ldw	r2,40(r2)
 d03d5a8:	18800e1e 	bne	r3,r2,d03d5e4 <send_arp+0x20c>
 d03d5ac:	e0bffd17 	ldw	r2,-12(fp)
 d03d5b0:	10800717 	ldw	r2,28(r2)
 d03d5b4:	10803fcc 	andi	r2,r2,255
 d03d5b8:	10801fe0 	cmpeqi	r2,r2,127
 d03d5bc:	1000091e 	bne	r2,zero,d03d5e4 <send_arp+0x20c>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d5c0:	01000084 	movi	r4,2
 d03d5c4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d03d5c8:	e13ffd17 	ldw	r4,-12(fp)
 d03d5cc:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d5d0:	01000084 	movi	r4,2
 d03d5d4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 d03d5d8:	00bff7c4 	movi	r2,-33
 d03d5dc:	e0bfff15 	stw	r2,-4(fp)
 d03d5e0:	00009d06 	br	d03d858 <send_arp+0x480>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 d03d5e4:	01000084 	movi	r4,2
 d03d5e8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 d03d5ec:	01000c04 	movi	r4,48
 d03d5f0:	d024e0c0 	call	d024e0c <pk_alloc>
 d03d5f4:	e0bff615 	stw	r2,-40(fp)
   if (!arppkt)
 d03d5f8:	e0bff617 	ldw	r2,-40(fp)
 d03d5fc:	1004c03a 	cmpne	r2,r2,zero
 d03d600:	1000071e 	bne	r2,zero,d03d620 <send_arp+0x248>
   {
      pk_free(pkt);
 d03d604:	e13ffd17 	ldw	r4,-12(fp)
 d03d608:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d60c:	01000084 	movi	r4,2
 d03d610:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 d03d614:	00bffa84 	movi	r2,-22
 d03d618:	e0bfff15 	stw	r2,-4(fp)
 d03d61c:	00008e06 	br	d03d858 <send_arp+0x480>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d620:	01000084 	movi	r4,2
 d03d624:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 d03d628:	e0bff617 	ldw	r2,-40(fp)
 d03d62c:	10c00117 	ldw	r3,4(r2)
 d03d630:	e0bff617 	ldw	r2,-40(fp)
 d03d634:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 d03d638:	e0fff617 	ldw	r3,-40(fp)
 d03d63c:	00800c04 	movi	r2,48
 d03d640:	18800415 	stw	r2,16(r3)
   arppkt->net = pkt->net;
 d03d644:	e0bffd17 	ldw	r2,-12(fp)
 d03d648:	10c00617 	ldw	r3,24(r2)
 d03d64c:	e0bff617 	ldw	r2,-40(fp)
 d03d650:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 d03d654:	e0bffd17 	ldw	r2,-12(fp)
 d03d658:	11400617 	ldw	r5,24(r2)
 d03d65c:	e13ffe17 	ldw	r4,-8(fp)
 d03d660:	d03da180 	call	d03da18 <make_arp_entry>
 d03d664:	e0bffb15 	stw	r2,-20(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 d03d668:	e0fffb17 	ldw	r3,-20(fp)
 d03d66c:	e0bffd17 	ldw	r2,-12(fp)
 d03d670:	18800415 	stw	r2,16(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 d03d674:	e0bff617 	ldw	r2,-40(fp)
 d03d678:	10800117 	ldw	r2,4(r2)
 d03d67c:	10800084 	addi	r2,r2,2
 d03d680:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 d03d684:	e0bff617 	ldw	r2,-40(fp)
 d03d688:	10800117 	ldw	r2,4(r2)
 d03d68c:	10800404 	addi	r2,r2,16
 d03d690:	e0bff815 	stw	r2,-32(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 d03d694:	e0fff817 	ldw	r3,-32(fp)
 d03d698:	00804004 	movi	r2,256
 d03d69c:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 d03d6a0:	e0fff817 	ldw	r3,-32(fp)
 d03d6a4:	00800204 	movi	r2,8
 d03d6a8:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 d03d6ac:	e0fff817 	ldw	r3,-32(fp)
 d03d6b0:	00800184 	movi	r2,6
 d03d6b4:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 d03d6b8:	e0fff817 	ldw	r3,-32(fp)
 d03d6bc:	00800104 	movi	r2,4
 d03d6c0:	18800145 	stb	r2,5(r3)
   arphdr->ar_op = ARREQ;
 d03d6c4:	e0fff817 	ldw	r3,-32(fp)
 d03d6c8:	00804004 	movi	r2,256
 d03d6cc:	1880018d 	sth	r2,6(r3)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 d03d6d0:	e0fff817 	ldw	r3,-32(fp)
 d03d6d4:	e0bffe17 	ldw	r2,-8(fp)
 d03d6d8:	18800715 	stw	r2,28(r3)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 d03d6dc:	e0bffd17 	ldw	r2,-12(fp)
 d03d6e0:	10800617 	ldw	r2,24(r2)
 d03d6e4:	10c00a17 	ldw	r3,40(r2)
 d03d6e8:	e0bff817 	ldw	r2,-32(fp)
 d03d6ec:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 d03d6f0:	e0bff817 	ldw	r2,-32(fp)
 d03d6f4:	11000204 	addi	r4,r2,8
 d03d6f8:	e0bff717 	ldw	r2,-36(fp)
 d03d6fc:	11400517 	ldw	r5,20(r2)
 d03d700:	01800184 	movi	r6,6
 d03d704:	d0026a80 	call	d0026a8 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 d03d708:	e0fffa17 	ldw	r3,-24(fp)
 d03d70c:	00bfffc4 	movi	r2,-1
 d03d710:	18800005 	stb	r2,0(r3)
 d03d714:	00bfffc4 	movi	r2,-1
 d03d718:	18800045 	stb	r2,1(r3)
 d03d71c:	00bfffc4 	movi	r2,-1
 d03d720:	18800085 	stb	r2,2(r3)
 d03d724:	00bfffc4 	movi	r2,-1
 d03d728:	188000c5 	stb	r2,3(r3)
 d03d72c:	00bfffc4 	movi	r2,-1
 d03d730:	18800105 	stb	r2,4(r3)
 d03d734:	00bfffc4 	movi	r2,-1
 d03d738:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 d03d73c:	e0bffa17 	ldw	r2,-24(fp)
 d03d740:	11000184 	addi	r4,r2,6
 d03d744:	e0bff717 	ldw	r2,-36(fp)
 d03d748:	11400517 	ldw	r5,20(r2)
 d03d74c:	01800184 	movi	r6,6
 d03d750:	d0026a80 	call	d0026a8 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 d03d754:	e0bffa17 	ldw	r2,-24(fp)
 d03d758:	10c00304 	addi	r3,r2,12
 d03d75c:	00800204 	movi	r2,8
 d03d760:	18800005 	stb	r2,0(r3)
 d03d764:	e0bffa17 	ldw	r2,-24(fp)
 d03d768:	10c00344 	addi	r3,r2,13
 d03d76c:	00800184 	movi	r2,6
 d03d770:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 d03d774:	e0bff817 	ldw	r2,-32(fp)
 d03d778:	e0bff515 	stw	r2,-44(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 d03d77c:	e0bff517 	ldw	r2,-44(fp)
 d03d780:	11000204 	addi	r4,r2,8
 d03d784:	e0bff817 	ldw	r2,-32(fp)
 d03d788:	11400204 	addi	r5,r2,8
 d03d78c:	01800184 	movi	r6,6
 d03d790:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 d03d794:	e0bff517 	ldw	r2,-44(fp)
 d03d798:	10800204 	addi	r2,r2,8
 d03d79c:	11000184 	addi	r4,r2,6
 d03d7a0:	e0bff817 	ldw	r2,-32(fp)
 d03d7a4:	11400404 	addi	r5,r2,16
 d03d7a8:	01800104 	movi	r6,4
 d03d7ac:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 d03d7b0:	e0bff517 	ldw	r2,-44(fp)
 d03d7b4:	10800204 	addi	r2,r2,8
 d03d7b8:	11000284 	addi	r4,r2,10
 d03d7bc:	e0bff817 	ldw	r2,-32(fp)
 d03d7c0:	11400504 	addi	r5,r2,20
 d03d7c4:	01800184 	movi	r6,6
 d03d7c8:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 d03d7cc:	e0bff517 	ldw	r2,-44(fp)
 d03d7d0:	10800204 	addi	r2,r2,8
 d03d7d4:	11000404 	addi	r4,r2,16
 d03d7d8:	e0bff817 	ldw	r2,-32(fp)
 d03d7dc:	11400704 	addi	r5,r2,28
 d03d7e0:	01800104 	movi	r6,4
 d03d7e4:	d0026a80 	call	d0026a8 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 d03d7e8:	e0bff917 	ldw	r2,-28(fp)
 d03d7ec:	10800417 	ldw	r2,16(r2)
 d03d7f0:	1005003a 	cmpeq	r2,r2,zero
 d03d7f4:	1000051e 	bne	r2,zero,d03d80c <send_arp+0x434>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 d03d7f8:	e0bff917 	ldw	r2,-28(fp)
 d03d7fc:	10800417 	ldw	r2,16(r2)
 d03d800:	e13ff617 	ldw	r4,-40(fp)
 d03d804:	103ee83a 	callr	r2
 d03d808:	00000e06 	br	d03d844 <send_arp+0x46c>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 d03d80c:	e0bff917 	ldw	r2,-28(fp)
 d03d810:	10c00317 	ldw	r3,12(r2)
 d03d814:	e0bff617 	ldw	r2,-40(fp)
 d03d818:	11000617 	ldw	r4,24(r2)
 d03d81c:	e0bff617 	ldw	r2,-40(fp)
 d03d820:	11400117 	ldw	r5,4(r2)
 d03d824:	01800c04 	movi	r6,48
 d03d828:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d82c:	01000084 	movi	r4,2
 d03d830:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 d03d834:	e13ff617 	ldw	r4,-40(fp)
 d03d838:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d83c:	01000084 	movi	r4,2
 d03d840:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 d03d844:	d0a94117 	ldw	r2,-23292(gp)
 d03d848:	10800044 	addi	r2,r2,1
 d03d84c:	d0a94115 	stw	r2,-23292(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 d03d850:	00800044 	movi	r2,1
 d03d854:	e0bfff15 	stw	r2,-4(fp)
 d03d858:	e0bfff17 	ldw	r2,-4(fp)
}
 d03d85c:	e037883a 	mov	sp,fp
 d03d860:	dfc00117 	ldw	ra,4(sp)
 d03d864:	df000017 	ldw	fp,0(sp)
 d03d868:	dec00204 	addi	sp,sp,8
 d03d86c:	f800283a 	ret

0d03d870 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 d03d870:	defff604 	addi	sp,sp,-40
 d03d874:	dfc00915 	stw	ra,36(sp)
 d03d878:	df000815 	stw	fp,32(sp)
 d03d87c:	df000804 	addi	fp,sp,32
 d03d880:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 d03d884:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 d03d888:	e03ffa15 	stw	zero,-24(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 d03d88c:	e03ff915 	stw	zero,-28(fp)
   unsigned long lticks = cticks;
 d03d890:	00834174 	movhi	r2,3333
 d03d894:	109b4504 	addi	r2,r2,27924
 d03d898:	10800017 	ldw	r2,0(r2)
 d03d89c:	e0bff815 	stw	r2,-32(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03d8a0:	008341b4 	movhi	r2,3334
 d03d8a4:	10852304 	addi	r2,r2,5260
 d03d8a8:	e0bffc15 	stw	r2,-16(fp)
 d03d8ac:	00004006 	br	d03d9b0 <find_oldest_arp+0x140>
   {
      /* age out old, pending entries */
      if (tp->pending)
 d03d8b0:	e0bffc17 	ldw	r2,-16(fp)
 d03d8b4:	10800417 	ldw	r2,16(r2)
 d03d8b8:	1005003a 	cmpeq	r2,r2,zero
 d03d8bc:	10000b1e 	bne	r2,zero,d03d8ec <find_oldest_arp+0x7c>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 d03d8c0:	e0bffc17 	ldw	r2,-16(fp)
 d03d8c4:	10c00517 	ldw	r3,20(r2)
 d03d8c8:	e0bff817 	ldw	r2,-32(fp)
 d03d8cc:	10c5c83a 	sub	r2,r2,r3
 d03d8d0:	10801970 	cmpltui	r2,r2,101
 d03d8d4:	1000181e 	bne	r2,zero,d03d938 <find_oldest_arp+0xc8>
         {
            arp_free_pending(tp);   /* free pending packets */
 d03d8d8:	e13ffc17 	ldw	r4,-16(fp)
 d03d8dc:	d03d2dc0 	call	d03d2dc <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03d8e0:	e0bffc17 	ldw	r2,-16(fp)
 d03d8e4:	10000015 	stw	zero,0(r2)
 d03d8e8:	00001306 	br	d03d938 <find_oldest_arp+0xc8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 d03d8ec:	e0bffc17 	ldw	r2,-16(fp)
 d03d8f0:	10800017 	ldw	r2,0(r2)
 d03d8f4:	1005003a 	cmpeq	r2,r2,zero
 d03d8f8:	10000f1e 	bne	r2,zero,d03d938 <find_oldest_arp+0xc8>
 d03d8fc:	e0bffc17 	ldw	r2,-16(fp)
 d03d900:	10c00517 	ldw	r3,20(r2)
 d03d904:	e0bff817 	ldw	r2,-32(fp)
 d03d908:	10c5c83a 	sub	r2,r2,r3
 d03d90c:	1007883a 	mov	r3,r2
 d03d910:	d0a04f17 	ldw	r2,-32452(gp)
 d03d914:	18800816 	blt	r3,r2,d03d938 <find_oldest_arp+0xc8>
 d03d918:	e0bffc17 	ldw	r2,-16(fp)
 d03d91c:	10c00617 	ldw	r3,24(r2)
 d03d920:	e0bff817 	ldw	r2,-32(fp)
 d03d924:	10c5c83a 	sub	r2,r2,r3
 d03d928:	10801930 	cmpltui	r2,r2,100
 d03d92c:	1000021e 	bne	r2,zero,d03d938 <find_oldest_arp+0xc8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03d930:	e0bffc17 	ldw	r2,-16(fp)
 d03d934:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 d03d938:	e0bffc17 	ldw	r2,-16(fp)
 d03d93c:	10c00017 	ldw	r3,0(r2)
 d03d940:	e0bffd17 	ldw	r2,-12(fp)
 d03d944:	1880031e 	bne	r3,r2,d03d954 <find_oldest_arp+0xe4>
      {
         exact = tp;
 d03d948:	e0bffc17 	ldw	r2,-16(fp)
 d03d94c:	e0bffb15 	stw	r2,-20(fp)
 d03d950:	00001406 	br	d03d9a4 <find_oldest_arp+0x134>
      }
      else if (tp->t_pro_addr != 0)
 d03d954:	e0bffc17 	ldw	r2,-16(fp)
 d03d958:	10800017 	ldw	r2,0(r2)
 d03d95c:	1005003a 	cmpeq	r2,r2,zero
 d03d960:	10000b1e 	bne	r2,zero,d03d990 <find_oldest_arp+0x120>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 d03d964:	e0bffa17 	ldw	r2,-24(fp)
 d03d968:	1005003a 	cmpeq	r2,r2,zero
 d03d96c:	1000051e 	bne	r2,zero,d03d984 <find_oldest_arp+0x114>
 d03d970:	e0bffc17 	ldw	r2,-16(fp)
 d03d974:	10c00617 	ldw	r3,24(r2)
 d03d978:	e0bffa17 	ldw	r2,-24(fp)
 d03d97c:	10800617 	ldw	r2,24(r2)
 d03d980:	1880082e 	bgeu	r3,r2,d03d9a4 <find_oldest_arp+0x134>
            oldest = tp;
 d03d984:	e0bffc17 	ldw	r2,-16(fp)
 d03d988:	e0bffa15 	stw	r2,-24(fp)
 d03d98c:	00000506 	br	d03d9a4 <find_oldest_arp+0x134>
      }
      else if (!empty)
 d03d990:	e0bff917 	ldw	r2,-28(fp)
 d03d994:	1004c03a 	cmpne	r2,r2,zero
 d03d998:	1000021e 	bne	r2,zero,d03d9a4 <find_oldest_arp+0x134>
         empty = tp;          /* grab first empty slot */
 d03d99c:	e0bffc17 	ldw	r2,-16(fp)
 d03d9a0:	e0bff915 	stw	r2,-28(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03d9a4:	e0bffc17 	ldw	r2,-16(fp)
 d03d9a8:	10800804 	addi	r2,r2,32
 d03d9ac:	e0bffc15 	stw	r2,-16(fp)
 d03d9b0:	00c341b4 	movhi	r3,3334
 d03d9b4:	18c56304 	addi	r3,r3,5516
 d03d9b8:	e0bffc17 	ldw	r2,-16(fp)
 d03d9bc:	10ffbc36 	bltu	r2,r3,d03d8b0 <find_oldest_arp+0x40>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 d03d9c0:	e0bffb17 	ldw	r2,-20(fp)
 d03d9c4:	1004c03a 	cmpne	r2,r2,zero
 d03d9c8:	10000b1e 	bne	r2,zero,d03d9f8 <find_oldest_arp+0x188>
 d03d9cc:	e0bff917 	ldw	r2,-28(fp)
 d03d9d0:	1005003a 	cmpeq	r2,r2,zero
 d03d9d4:	1000031e 	bne	r2,zero,d03d9e4 <find_oldest_arp+0x174>
 d03d9d8:	e0bff917 	ldw	r2,-28(fp)
 d03d9dc:	e0bffe15 	stw	r2,-8(fp)
 d03d9e0:	00000206 	br	d03d9ec <find_oldest_arp+0x17c>
 d03d9e4:	e0bffa17 	ldw	r2,-24(fp)
 d03d9e8:	e0bffe15 	stw	r2,-8(fp)
 d03d9ec:	e0bffe17 	ldw	r2,-8(fp)
 d03d9f0:	e0bfff15 	stw	r2,-4(fp)
 d03d9f4:	00000206 	br	d03da00 <find_oldest_arp+0x190>
 d03d9f8:	e0bffb17 	ldw	r2,-20(fp)
 d03d9fc:	e0bfff15 	stw	r2,-4(fp)
 d03da00:	e0bfff17 	ldw	r2,-4(fp)
}
 d03da04:	e037883a 	mov	sp,fp
 d03da08:	dfc00117 	ldw	ra,4(sp)
 d03da0c:	df000017 	ldw	fp,0(sp)
 d03da10:	dec00204 	addi	sp,sp,8
 d03da14:	f800283a 	ret

0d03da18 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 d03da18:	defffa04 	addi	sp,sp,-24
 d03da1c:	dfc00515 	stw	ra,20(sp)
 d03da20:	df000415 	stw	fp,16(sp)
 d03da24:	df000404 	addi	fp,sp,16
 d03da28:	e13ffe15 	stw	r4,-8(fp)
 d03da2c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 d03da30:	00834174 	movhi	r2,3333
 d03da34:	109b4504 	addi	r2,r2,27924
 d03da38:	10800017 	ldw	r2,0(r2)
 d03da3c:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 d03da40:	e13ffe17 	ldw	r4,-8(fp)
 d03da44:	d03d8700 	call	d03d870 <find_oldest_arp>
 d03da48:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 d03da4c:	e0bffd17 	ldw	r2,-12(fp)
 d03da50:	10800417 	ldw	r2,16(r2)
 d03da54:	1005003a 	cmpeq	r2,r2,zero
 d03da58:	1000061e 	bne	r2,zero,d03da74 <make_arp_entry+0x5c>
 d03da5c:	e0bffd17 	ldw	r2,-12(fp)
 d03da60:	10c00017 	ldw	r3,0(r2)
 d03da64:	e0bffe17 	ldw	r2,-8(fp)
 d03da68:	18800226 	beq	r3,r2,d03da74 <make_arp_entry+0x5c>
   {
      arp_free_pending(oldest);
 d03da6c:	e13ffd17 	ldw	r4,-12(fp)
 d03da70:	d03d2dc0 	call	d03d2dc <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 d03da74:	e0fffd17 	ldw	r3,-12(fp)
 d03da78:	e0bffe17 	ldw	r2,-8(fp)
 d03da7c:	18800015 	stw	r2,0(r3)
   oldest->net = net;
 d03da80:	e0fffd17 	ldw	r3,-12(fp)
 d03da84:	e0bfff17 	ldw	r2,-4(fp)
 d03da88:	18800315 	stw	r2,12(r3)
   oldest->flags = 0;
 d03da8c:	e0bffd17 	ldw	r2,-12(fp)
 d03da90:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 d03da94:	e0bffd17 	ldw	r2,-12(fp)
 d03da98:	10800104 	addi	r2,r2,4
 d03da9c:	10000005 	stb	zero,0(r2)
 d03daa0:	10000045 	stb	zero,1(r2)
 d03daa4:	10000085 	stb	zero,2(r2)
 d03daa8:	100000c5 	stb	zero,3(r2)
 d03daac:	10000105 	stb	zero,4(r2)
 d03dab0:	10000145 	stb	zero,5(r2)
   oldest->createtime = oldest->lasttime = lticks;
 d03dab4:	e0fffd17 	ldw	r3,-12(fp)
 d03dab8:	e0bffc17 	ldw	r2,-16(fp)
 d03dabc:	18800615 	stw	r2,24(r3)
 d03dac0:	e0bffd17 	ldw	r2,-12(fp)
 d03dac4:	10c00617 	ldw	r3,24(r2)
 d03dac8:	e0bffd17 	ldw	r2,-12(fp)
 d03dacc:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 d03dad0:	d0a93e17 	ldw	r2,-23304(gp)
 d03dad4:	1004c03a 	cmpne	r2,r2,zero
 d03dad8:	1000071e 	bne	r2,zero,d03daf8 <make_arp_entry+0xe0>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 d03dadc:	01034134 	movhi	r4,3332
 d03dae0:	21387204 	addi	r4,r4,-7736
 d03dae4:	0149c404 	movi	r5,10000
 d03dae8:	000d883a 	mov	r6,zero
 d03daec:	d03cd440 	call	d03cd44 <in_timerset>
 d03daf0:	d0a93e15 	stw	r2,-23304(gp)
 d03daf4:	00000706 	br	d03db14 <make_arp_entry+0xfc>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 d03daf8:	d0a93e17 	ldw	r2,-23304(gp)
 d03dafc:	1009883a 	mov	r4,r2
 d03db00:	d0a93e17 	ldw	r2,-23304(gp)
 d03db04:	10c00217 	ldw	r3,8(r2)
 d03db08:	e0bffc17 	ldw	r2,-16(fp)
 d03db0c:	1885883a 	add	r2,r3,r2
 d03db10:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 d03db14:	e0bffd17 	ldw	r2,-12(fp)
}
 d03db18:	e037883a 	mov	sp,fp
 d03db1c:	dfc00117 	ldw	ra,4(sp)
 d03db20:	df000017 	ldw	fp,0(sp)
 d03db24:	dec00204 	addi	sp,sp,8
 d03db28:	f800283a 	ret

0d03db2c <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 d03db2c:	defff704 	addi	sp,sp,-36
 d03db30:	dfc00815 	stw	ra,32(sp)
 d03db34:	df000715 	stw	fp,28(sp)
 d03db38:	df000704 	addi	fp,sp,28
 d03db3c:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03db40:	01000084 	movi	r4,2
 d03db44:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 d03db48:	01000c04 	movi	r4,48
 d03db4c:	d024e0c0 	call	d024e0c <pk_alloc>
 d03db50:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03db54:	01000084 	movi	r4,2
 d03db58:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 d03db5c:	e0bffe17 	ldw	r2,-8(fp)
 d03db60:	1004c03a 	cmpne	r2,r2,zero
 d03db64:	1000021e 	bne	r2,zero,d03db70 <arpReply+0x44>
   {
      dtrap();
 d03db68:	d025a500 	call	d025a50 <dtrap>
      return;
 d03db6c:	00008f06 	br	d03ddac <arpReply+0x280>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 d03db70:	e0bfff17 	ldw	r2,-4(fp)
 d03db74:	10c00617 	ldw	r3,24(r2)
 d03db78:	e0bffe17 	ldw	r2,-8(fp)
 d03db7c:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 d03db80:	e0bfff17 	ldw	r2,-4(fp)
 d03db84:	10800317 	ldw	r2,12(r2)
 d03db88:	10bffc84 	addi	r2,r2,-14
 d03db8c:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 d03db90:	e0bffe17 	ldw	r2,-8(fp)
 d03db94:	10800117 	ldw	r2,4(r2)
 d03db98:	10800084 	addi	r2,r2,2
 d03db9c:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 d03dba0:	e0bffb17 	ldw	r2,-20(fp)
 d03dba4:	10c00304 	addi	r3,r2,12
 d03dba8:	00800204 	movi	r2,8
 d03dbac:	18800005 	stb	r2,0(r3)
 d03dbb0:	e0bffb17 	ldw	r2,-20(fp)
 d03dbb4:	10c00344 	addi	r3,r2,13
 d03dbb8:	00800184 	movi	r2,6
 d03dbbc:	18800005 	stb	r2,0(r3)
      in = (struct arp_hdr *)(pkt->nb_prot);
 d03dbc0:	e0bfff17 	ldw	r2,-4(fp)
 d03dbc4:	10800317 	ldw	r2,12(r2)
 d03dbc8:	e0bffd15 	stw	r2,-12(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 d03dbcc:	e0bffe17 	ldw	r2,-8(fp)
 d03dbd0:	10800117 	ldw	r2,4(r2)
 d03dbd4:	10800404 	addi	r2,r2,16
 d03dbd8:	e0bffc15 	stw	r2,-16(fp)
      outpkt->nb_plen = arpsize;
 d03dbdc:	e0fffe17 	ldw	r3,-8(fp)
 d03dbe0:	00800c04 	movi	r2,48
 d03dbe4:	18800415 	stw	r2,16(r3)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 d03dbe8:	e0fffc17 	ldw	r3,-16(fp)
 d03dbec:	00804004 	movi	r2,256
 d03dbf0:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 d03dbf4:	e0fffc17 	ldw	r3,-16(fp)
 d03dbf8:	00800204 	movi	r2,8
 d03dbfc:	1880008d 	sth	r2,2(r3)
   out->ar_hln = 6;
 d03dc00:	e0fffc17 	ldw	r3,-16(fp)
 d03dc04:	00800184 	movi	r2,6
 d03dc08:	18800105 	stb	r2,4(r3)
   out->ar_pln = 4;
 d03dc0c:	e0fffc17 	ldw	r3,-16(fp)
 d03dc10:	00800104 	movi	r2,4
 d03dc14:	18800145 	stb	r2,5(r3)
   out->ar_op = ARREP;
 d03dc18:	e0fffc17 	ldw	r3,-16(fp)
 d03dc1c:	00808004 	movi	r2,512
 d03dc20:	1880018d 	sth	r2,6(r3)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 d03dc24:	e0bffd17 	ldw	r2,-12(fp)
 d03dc28:	10c00417 	ldw	r3,16(r2)
 d03dc2c:	e0bffc17 	ldw	r2,-16(fp)
 d03dc30:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 d03dc34:	e0bffd17 	ldw	r2,-12(fp)
 d03dc38:	10c00717 	ldw	r3,28(r2)
 d03dc3c:	e0bffc17 	ldw	r2,-16(fp)
 d03dc40:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 d03dc44:	e0bffc17 	ldw	r2,-16(fp)
 d03dc48:	11000504 	addi	r4,r2,20
 d03dc4c:	e0bffd17 	ldw	r2,-12(fp)
 d03dc50:	11400204 	addi	r5,r2,8
 d03dc54:	01800184 	movi	r6,6
 d03dc58:	d0026a80 	call	d0026a8 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 d03dc5c:	e0bffc17 	ldw	r2,-16(fp)
 d03dc60:	11000204 	addi	r4,r2,8
 d03dc64:	e0bffe17 	ldw	r2,-8(fp)
 d03dc68:	10800617 	ldw	r2,24(r2)
 d03dc6c:	10802717 	ldw	r2,156(r2)
 d03dc70:	11400517 	ldw	r5,20(r2)
 d03dc74:	01800184 	movi	r6,6
 d03dc78:	d0026a80 	call	d0026a8 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 d03dc7c:	e0bffa17 	ldw	r2,-24(fp)
 d03dc80:	11400184 	addi	r5,r2,6
 d03dc84:	e13ffb17 	ldw	r4,-20(fp)
 d03dc88:	01800184 	movi	r6,6
 d03dc8c:	d0026a80 	call	d0026a8 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 d03dc90:	e0bffb17 	ldw	r2,-20(fp)
 d03dc94:	11000184 	addi	r4,r2,6
 d03dc98:	e0bffe17 	ldw	r2,-8(fp)
 d03dc9c:	10800617 	ldw	r2,24(r2)
 d03dca0:	10802717 	ldw	r2,156(r2)
 d03dca4:	11400517 	ldw	r5,20(r2)
 d03dca8:	01800184 	movi	r6,6
 d03dcac:	d0026a80 	call	d0026a8 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 d03dcb0:	e0bffc17 	ldw	r2,-16(fp)
 d03dcb4:	e0bff915 	stw	r2,-28(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 d03dcb8:	e0bff917 	ldw	r2,-28(fp)
 d03dcbc:	11000204 	addi	r4,r2,8
 d03dcc0:	e0bffc17 	ldw	r2,-16(fp)
 d03dcc4:	11400204 	addi	r5,r2,8
 d03dcc8:	01800184 	movi	r6,6
 d03dccc:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 d03dcd0:	e0bff917 	ldw	r2,-28(fp)
 d03dcd4:	10800204 	addi	r2,r2,8
 d03dcd8:	11000184 	addi	r4,r2,6
 d03dcdc:	e0bffc17 	ldw	r2,-16(fp)
 d03dce0:	11400404 	addi	r5,r2,16
 d03dce4:	01800104 	movi	r6,4
 d03dce8:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 d03dcec:	e0bff917 	ldw	r2,-28(fp)
 d03dcf0:	10800204 	addi	r2,r2,8
 d03dcf4:	11000284 	addi	r4,r2,10
 d03dcf8:	e0bffc17 	ldw	r2,-16(fp)
 d03dcfc:	11400504 	addi	r5,r2,20
 d03dd00:	01800184 	movi	r6,6
 d03dd04:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 d03dd08:	e0bff917 	ldw	r2,-28(fp)
 d03dd0c:	10800204 	addi	r2,r2,8
 d03dd10:	11000404 	addi	r4,r2,16
 d03dd14:	e0bffc17 	ldw	r2,-16(fp)
 d03dd18:	11400704 	addi	r5,r2,28
 d03dd1c:	01800104 	movi	r6,4
 d03dd20:	d0026a80 	call	d0026a8 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 d03dd24:	e0bffe17 	ldw	r2,-8(fp)
 d03dd28:	10800617 	ldw	r2,24(r2)
 d03dd2c:	10800417 	ldw	r2,16(r2)
 d03dd30:	1005003a 	cmpeq	r2,r2,zero
 d03dd34:	10000a1e 	bne	r2,zero,d03dd60 <arpReply+0x234>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 d03dd38:	e0bffe17 	ldw	r2,-8(fp)
 d03dd3c:	10c00117 	ldw	r3,4(r2)
 d03dd40:	e0bffe17 	ldw	r2,-8(fp)
 d03dd44:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 d03dd48:	e0bffe17 	ldw	r2,-8(fp)
 d03dd4c:	10800617 	ldw	r2,24(r2)
 d03dd50:	10800417 	ldw	r2,16(r2)
 d03dd54:	e13ffe17 	ldw	r4,-8(fp)
 d03dd58:	103ee83a 	callr	r2
 d03dd5c:	00001006 	br	d03dda0 <arpReply+0x274>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 d03dd60:	e0bffe17 	ldw	r2,-8(fp)
 d03dd64:	10800617 	ldw	r2,24(r2)
 d03dd68:	10c00317 	ldw	r3,12(r2)
 d03dd6c:	e0bfff17 	ldw	r2,-4(fp)
 d03dd70:	11000617 	ldw	r4,24(r2)
 d03dd74:	e0bffe17 	ldw	r2,-8(fp)
 d03dd78:	11400117 	ldw	r5,4(r2)
 d03dd7c:	e0bffe17 	ldw	r2,-8(fp)
 d03dd80:	11800417 	ldw	r6,16(r2)
 d03dd84:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03dd88:	01000084 	movi	r4,2
 d03dd8c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 d03dd90:	e13ffe17 	ldw	r4,-8(fp)
 d03dd94:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03dd98:	01000084 	movi	r4,2
 d03dd9c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 d03dda0:	d0a94317 	ldw	r2,-23284(gp)
 d03dda4:	10800044 	addi	r2,r2,1
 d03dda8:	d0a94315 	stw	r2,-23284(gp)
}
 d03ddac:	e037883a 	mov	sp,fp
 d03ddb0:	dfc00117 	ldw	ra,4(sp)
 d03ddb4:	df000017 	ldw	fp,0(sp)
 d03ddb8:	dec00204 	addi	sp,sp,8
 d03ddbc:	f800283a 	ret

0d03ddc0 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 d03ddc0:	defff804 	addi	sp,sp,-32
 d03ddc4:	dfc00715 	stw	ra,28(sp)
 d03ddc8:	df000615 	stw	fp,24(sp)
 d03ddcc:	df000604 	addi	fp,sp,24
 d03ddd0:	e13ffe15 	stw	r4,-8(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 d03ddd4:	e0bffe17 	ldw	r2,-8(fp)
 d03ddd8:	10800317 	ldw	r2,12(r2)
 d03dddc:	10bffc84 	addi	r2,r2,-14
 d03dde0:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 d03dde4:	e0bffe17 	ldw	r2,-8(fp)
 d03dde8:	10800317 	ldw	r2,12(r2)
 d03ddec:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 d03ddf0:	e0bffd17 	ldw	r2,-12(fp)
 d03ddf4:	e0bffa15 	stw	r2,-24(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 d03ddf8:	e0bffd17 	ldw	r2,-12(fp)
 d03ddfc:	11000704 	addi	r4,r2,28
 d03de00:	e0bffa17 	ldw	r2,-24(fp)
 d03de04:	10800204 	addi	r2,r2,8
 d03de08:	11400404 	addi	r5,r2,16
 d03de0c:	01800104 	movi	r6,4
 d03de10:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 d03de14:	e0bffd17 	ldw	r2,-12(fp)
 d03de18:	11000504 	addi	r4,r2,20
 d03de1c:	e0bffa17 	ldw	r2,-24(fp)
 d03de20:	10800204 	addi	r2,r2,8
 d03de24:	11400284 	addi	r5,r2,10
 d03de28:	01800184 	movi	r6,6
 d03de2c:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 d03de30:	e0bffd17 	ldw	r2,-12(fp)
 d03de34:	11000404 	addi	r4,r2,16
 d03de38:	e0bffa17 	ldw	r2,-24(fp)
 d03de3c:	10800204 	addi	r2,r2,8
 d03de40:	11400184 	addi	r5,r2,6
 d03de44:	01800104 	movi	r6,4
 d03de48:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 d03de4c:	e0bffd17 	ldw	r2,-12(fp)
 d03de50:	11000204 	addi	r4,r2,8
 d03de54:	e0bffa17 	ldw	r2,-24(fp)
 d03de58:	11400204 	addi	r5,r2,8
 d03de5c:	01800184 	movi	r6,6
 d03de60:	d0026a80 	call	d0026a8 <memmove>
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 d03de64:	e0bffd17 	ldw	r2,-12(fp)
 d03de68:	10c00717 	ldw	r3,28(r2)
 d03de6c:	e0bffe17 	ldw	r2,-8(fp)
 d03de70:	10800617 	ldw	r2,24(r2)
 d03de74:	10800a17 	ldw	r2,40(r2)
 d03de78:	18801f26 	beq	r3,r2,d03def8 <arprcv+0x138>
 d03de7c:	e0bffd17 	ldw	r2,-12(fp)
 d03de80:	10800717 	ldw	r2,28(r2)
 d03de84:	1004d63a 	srli	r2,r2,24
 d03de88:	10c03fcc 	andi	r3,r2,255
 d03de8c:	e0bffd17 	ldw	r2,-12(fp)
 d03de90:	10800717 	ldw	r2,28(r2)
 d03de94:	1004d23a 	srli	r2,r2,8
 d03de98:	10bfc00c 	andi	r2,r2,65280
 d03de9c:	1886b03a 	or	r3,r3,r2
 d03dea0:	e0bffd17 	ldw	r2,-12(fp)
 d03dea4:	10800717 	ldw	r2,28(r2)
 d03dea8:	10bfc00c 	andi	r2,r2,65280
 d03deac:	1004923a 	slli	r2,r2,8
 d03deb0:	1886b03a 	or	r3,r3,r2
 d03deb4:	e0bffd17 	ldw	r2,-12(fp)
 d03deb8:	10800717 	ldw	r2,28(r2)
 d03debc:	10803fcc 	andi	r2,r2,255
 d03dec0:	1004963a 	slli	r2,r2,24
 d03dec4:	1884b03a 	or	r2,r3,r2
 d03dec8:	10fc002c 	andhi	r3,r2,61440
 d03decc:	00b80034 	movhi	r2,57344
 d03ded0:	18800926 	beq	r3,r2,d03def8 <arprcv+0x138>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ded4:	01000084 	movi	r4,2
 d03ded8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 d03dedc:	e13ffe17 	ldw	r4,-8(fp)
 d03dee0:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03dee4:	01000084 	movi	r4,2
 d03dee8:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 d03deec:	00800084 	movi	r2,2
 d03def0:	e0bfff15 	stw	r2,-4(fp)
 d03def4:	00004406 	br	d03e008 <arprcv+0x248>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 d03def8:	e0bffd17 	ldw	r2,-12(fp)
 d03defc:	1080018b 	ldhu	r2,6(r2)
 d03df00:	10bfffcc 	andi	r2,r2,65535
 d03df04:	10804018 	cmpnei	r2,r2,256
 d03df08:	10000b1e 	bne	r2,zero,d03df38 <arprcv+0x178>
   {
      arpReqsIn++;   /* count these */
 d03df0c:	d0a94017 	ldw	r2,-23296(gp)
 d03df10:	10800044 	addi	r2,r2,1
 d03df14:	d0a94015 	stw	r2,-23296(gp)
      arpReply(pkt); /* send arp reply */
 d03df18:	e13ffe17 	ldw	r4,-8(fp)
 d03df1c:	d03db2c0 	call	d03db2c <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 d03df20:	e0bffd17 	ldw	r2,-12(fp)
 d03df24:	11000417 	ldw	r4,16(r2)
 d03df28:	e0bffe17 	ldw	r2,-8(fp)
 d03df2c:	11400617 	ldw	r5,24(r2)
 d03df30:	d03da180 	call	d03da18 <make_arp_entry>
 d03df34:	00000306 	br	d03df44 <arprcv+0x184>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 d03df38:	d0a94217 	ldw	r2,-23288(gp)
 d03df3c:	10800044 	addi	r2,r2,1
 d03df40:	d0a94215 	stw	r2,-23288(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03df44:	008341b4 	movhi	r2,3334
 d03df48:	10852304 	addi	r2,r2,5260
 d03df4c:	e0bffc15 	stw	r2,-16(fp)
 d03df50:	00002106 	br	d03dfd8 <arprcv+0x218>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 d03df54:	e0bffc17 	ldw	r2,-16(fp)
 d03df58:	10c00017 	ldw	r3,0(r2)
 d03df5c:	e0bffd17 	ldw	r2,-12(fp)
 d03df60:	10800417 	ldw	r2,16(r2)
 d03df64:	1880191e 	bne	r3,r2,d03dfcc <arprcv+0x20c>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 d03df68:	e0bffc17 	ldw	r2,-16(fp)
 d03df6c:	11000104 	addi	r4,r2,4
 d03df70:	e0bffd17 	ldw	r2,-12(fp)
 d03df74:	11400204 	addi	r5,r2,8
 d03df78:	01800184 	movi	r6,6
 d03df7c:	d0026a80 	call	d0026a8 <memmove>
         tp->lasttime = cticks;
 d03df80:	00834174 	movhi	r2,3333
 d03df84:	109b4504 	addi	r2,r2,27924
 d03df88:	10c00017 	ldw	r3,0(r2)
 d03df8c:	e0bffc17 	ldw	r2,-16(fp)
 d03df90:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 d03df94:	e0bffc17 	ldw	r2,-16(fp)
 d03df98:	10800417 	ldw	r2,16(r2)
 d03df9c:	1005003a 	cmpeq	r2,r2,zero
 d03dfa0:	1000021e 	bne	r2,zero,d03dfac <arprcv+0x1ec>
         {
            arp_send_pending(tp);
 d03dfa4:	e13ffc17 	ldw	r4,-16(fp)
 d03dfa8:	d03d3640 	call	d03d364 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03dfac:	01000084 	movi	r4,2
 d03dfb0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d03dfb4:	e13ffe17 	ldw	r4,-8(fp)
 d03dfb8:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03dfbc:	01000084 	movi	r4,2
 d03dfc0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

         return (0);
 d03dfc4:	e03fff15 	stw	zero,-4(fp)
 d03dfc8:	00000f06 	br	d03e008 <arprcv+0x248>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03dfcc:	e0bffc17 	ldw	r2,-16(fp)
 d03dfd0:	10800804 	addi	r2,r2,32
 d03dfd4:	e0bffc15 	stw	r2,-16(fp)
 d03dfd8:	00c341b4 	movhi	r3,3334
 d03dfdc:	18c56304 	addi	r3,r3,5516
 d03dfe0:	e0bffc17 	ldw	r2,-16(fp)
 d03dfe4:	10ffdb36 	bltu	r2,r3,d03df54 <arprcv+0x194>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03dfe8:	01000084 	movi	r4,2
 d03dfec:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 d03dff0:	e13ffe17 	ldw	r4,-8(fp)
 d03dff4:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03dff8:	01000084 	movi	r4,2
 d03dffc:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 d03e000:	00800084 	movi	r2,2
 d03e004:	e0bfff15 	stw	r2,-4(fp)
 d03e008:	e0bfff17 	ldw	r2,-4(fp)
}
 d03e00c:	e037883a 	mov	sp,fp
 d03e010:	dfc00117 	ldw	ra,4(sp)
 d03e014:	df000017 	ldw	fp,0(sp)
 d03e018:	dec00204 	addi	sp,sp,8
 d03e01c:	f800283a 	ret

0d03e020 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 d03e020:	defff704 	addi	sp,sp,-36
 d03e024:	dfc00815 	stw	ra,32(sp)
 d03e028:	df000715 	stw	fp,28(sp)
 d03e02c:	df000704 	addi	fp,sp,28
 d03e030:	e13ffd15 	stw	r4,-12(fp)
 d03e034:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 d03e038:	00834174 	movhi	r2,3333
 d03e03c:	109b4504 	addi	r2,r2,27924
 d03e040:	10800017 	ldw	r2,0(r2)
 d03e044:	e0bffb15 	stw	r2,-20(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 d03e048:	e0bffe17 	ldw	r2,-8(fp)
 d03e04c:	1004c03a 	cmpne	r2,r2,zero
 d03e050:	1000091e 	bne	r2,zero,d03e078 <send_via_arp+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03e054:	01000084 	movi	r4,2
 d03e058:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d03e05c:	e13ffd17 	ldw	r4,-12(fp)
 d03e060:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e064:	01000084 	movi	r4,2
 d03e068:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 d03e06c:	00bffa84 	movi	r2,-22
 d03e070:	e0bfff15 	stw	r2,-4(fp)
 d03e074:	00004e06 	br	d03e1b0 <send_via_arp+0x190>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 d03e078:	d0e94417 	ldw	r3,-23280(gp)
 d03e07c:	e0bffb17 	ldw	r2,-20(fp)
 d03e080:	10c5c83a 	sub	r2,r2,r3
 d03e084:	10801970 	cmpltui	r2,r2,101
 d03e088:	1000011e 	bne	r2,zero,d03e090 <send_via_arp+0x70>
      arpcache = (struct arptabent *)NULL;
 d03e08c:	d0293f15 	stw	zero,-23300(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 d03e090:	d0a93f17 	ldw	r2,-23300(gp)
 d03e094:	1005003a 	cmpeq	r2,r2,zero
 d03e098:	1000071e 	bne	r2,zero,d03e0b8 <send_via_arp+0x98>
 d03e09c:	d0a93f17 	ldw	r2,-23300(gp)
 d03e0a0:	10c00017 	ldw	r3,0(r2)
 d03e0a4:	e0bffe17 	ldw	r2,-8(fp)
 d03e0a8:	1880031e 	bne	r3,r2,d03e0b8 <send_via_arp+0x98>
      tp = arpcache;
 d03e0ac:	d0a93f17 	ldw	r2,-23300(gp)
 d03e0b0:	e0bffc15 	stw	r2,-16(fp)
   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
      arpcache = (struct arptabent *)NULL;

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 d03e0b4:	00000306 	br	d03e0c4 <send_via_arp+0xa4>
      tp = arpcache;
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 d03e0b8:	e13ffe17 	ldw	r4,-8(fp)
 d03e0bc:	d03d8700 	call	d03d870 <find_oldest_arp>
 d03e0c0:	e0bffc15 	stw	r2,-16(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 d03e0c4:	e0bffc17 	ldw	r2,-16(fp)
 d03e0c8:	10c00017 	ldw	r3,0(r2)
 d03e0cc:	e0bffe17 	ldw	r2,-8(fp)
 d03e0d0:	1880311e 	bne	r3,r2,d03e198 <send_via_arp+0x178>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 d03e0d4:	e0bffc17 	ldw	r2,-16(fp)
 d03e0d8:	10800417 	ldw	r2,16(r2)
 d03e0dc:	1005003a 	cmpeq	r2,r2,zero
 d03e0e0:	1000241e 	bne	r2,zero,d03e174 <send_via_arp+0x154>
      {
         if (lilfreeq.q_len < 2)
 d03e0e4:	008341b4 	movhi	r2,3334
 d03e0e8:	10837c04 	addi	r2,r2,3568
 d03e0ec:	10800217 	ldw	r2,8(r2)
 d03e0f0:	10800088 	cmpgei	r2,r2,2
 d03e0f4:	1000091e 	bne	r2,zero,d03e11c <send_via_arp+0xfc>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03e0f8:	01000084 	movi	r4,2
 d03e0fc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 d03e100:	e13ffd17 	ldw	r4,-12(fp)
 d03e104:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e108:	01000084 	movi	r4,2
 d03e10c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 d03e110:	00bffa84 	movi	r2,-22
 d03e114:	e0bffa15 	stw	r2,-24(fp)
 d03e118:	00002306 	br	d03e1a8 <send_via_arp+0x188>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 d03e11c:	e0bffc17 	ldw	r2,-16(fp)
 d03e120:	10800417 	ldw	r2,16(r2)
 d03e124:	e0bff915 	stw	r2,-28(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 d03e128:	00000306 	br	d03e138 <send_via_arp+0x118>
               tmppkt = tmppkt->next;
 d03e12c:	e0bff917 	ldw	r2,-28(fp)
 d03e130:	10800017 	ldw	r2,0(r2)
 d03e134:	e0bff915 	stw	r2,-28(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 d03e138:	e0bff917 	ldw	r2,-28(fp)
 d03e13c:	10800017 	ldw	r2,0(r2)
 d03e140:	1004c03a 	cmpne	r2,r2,zero
 d03e144:	103ff91e 	bne	r2,zero,d03e12c <send_via_arp+0x10c>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 d03e148:	e0fff917 	ldw	r3,-28(fp)
 d03e14c:	e0bffd17 	ldw	r2,-12(fp)
 d03e150:	18800015 	stw	r2,0(r3)
            if (pkt->next)
 d03e154:	e0bffd17 	ldw	r2,-12(fp)
 d03e158:	10800017 	ldw	r2,0(r2)
 d03e15c:	1005003a 	cmpeq	r2,r2,zero
 d03e160:	1000011e 	bne	r2,zero,d03e168 <send_via_arp+0x148>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 d03e164:	d025a500 	call	d025a50 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 d03e168:	00800044 	movi	r2,1
 d03e16c:	e0bffa15 	stw	r2,-24(fp)
 d03e170:	00000d06 	br	d03e1a8 <send_via_arp+0x188>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 d03e174:	e0bffc17 	ldw	r2,-16(fp)
 d03e178:	d0a93f15 	stw	r2,-23300(gp)
         cachetime = lticks;  /* mark time we cached */
 d03e17c:	e0bffb17 	ldw	r2,-20(fp)
 d03e180:	d0a94415 	stw	r2,-23280(gp)
         err = et_send(pkt, tp);
 d03e184:	e13ffd17 	ldw	r4,-12(fp)
 d03e188:	e17ffc17 	ldw	r5,-16(fp)
 d03e18c:	d03d1600 	call	d03d160 <et_send>
 d03e190:	e0bffa15 	stw	r2,-24(fp)
 d03e194:	00000406 	br	d03e1a8 <send_via_arp+0x188>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 d03e198:	e13ffd17 	ldw	r4,-12(fp)
 d03e19c:	e17ffe17 	ldw	r5,-8(fp)
 d03e1a0:	d03d3d80 	call	d03d3d8 <send_arp>
 d03e1a4:	e0bffa15 	stw	r2,-24(fp)

   return (err);
 d03e1a8:	e0bffa17 	ldw	r2,-24(fp)
 d03e1ac:	e0bfff15 	stw	r2,-4(fp)
 d03e1b0:	e0bfff17 	ldw	r2,-4(fp)
}
 d03e1b4:	e037883a 	mov	sp,fp
 d03e1b8:	dfc00117 	ldw	ra,4(sp)
 d03e1bc:	df000017 	ldw	fp,0(sp)
 d03e1c0:	dec00204 	addi	sp,sp,8
 d03e1c4:	f800283a 	ret

0d03e1c8 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 d03e1c8:	defffa04 	addi	sp,sp,-24
 d03e1cc:	dfc00515 	stw	ra,20(sp)
 d03e1d0:	df000415 	stw	fp,16(sp)
 d03e1d4:	df000404 	addi	fp,sp,16
 d03e1d8:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 d03e1dc:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 d03e1e0:	00834174 	movhi	r2,3333
 d03e1e4:	109b4504 	addi	r2,r2,27924
 d03e1e8:	10800017 	ldw	r2,0(r2)
 d03e1ec:	e0bffc15 	stw	r2,-16(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03e1f0:	008341b4 	movhi	r2,3334
 d03e1f4:	10852304 	addi	r2,r2,5260
 d03e1f8:	e0bffe15 	stw	r2,-8(fp)
 d03e1fc:	00002906 	br	d03e2a4 <cb_arpent_tmo+0xdc>
   {
      if (tp->t_pro_addr != 0)
 d03e200:	e0bffe17 	ldw	r2,-8(fp)
 d03e204:	10800017 	ldw	r2,0(r2)
 d03e208:	1005003a 	cmpeq	r2,r2,zero
 d03e20c:	1000221e 	bne	r2,zero,d03e298 <cb_arpent_tmo+0xd0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 d03e210:	e0bffe17 	ldw	r2,-8(fp)
 d03e214:	10800417 	ldw	r2,16(r2)
 d03e218:	1005003a 	cmpeq	r2,r2,zero
 d03e21c:	10000b1e 	bne	r2,zero,d03e24c <cb_arpent_tmo+0x84>
 d03e220:	e0bffe17 	ldw	r2,-8(fp)
 d03e224:	10c00517 	ldw	r3,20(r2)
 d03e228:	e0bffc17 	ldw	r2,-16(fp)
 d03e22c:	10c5c83a 	sub	r2,r2,r3
 d03e230:	10801970 	cmpltui	r2,r2,101
 d03e234:	1000051e 	bne	r2,zero,d03e24c <cb_arpent_tmo+0x84>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 d03e238:	e13ffe17 	ldw	r4,-8(fp)
 d03e23c:	d03d2dc0 	call	d03d2dc <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03e240:	e0bffe17 	ldw	r2,-8(fp)
 d03e244:	10000015 	stw	zero,0(r2)
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
   {
      if (tp->t_pro_addr != 0)
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 d03e248:	00001306 	br	d03e298 <cb_arpent_tmo+0xd0>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 d03e24c:	e0bffe17 	ldw	r2,-8(fp)
 d03e250:	10c00517 	ldw	r3,20(r2)
 d03e254:	e0bffc17 	ldw	r2,-16(fp)
 d03e258:	10c5c83a 	sub	r2,r2,r3
 d03e25c:	1007883a 	mov	r3,r2
 d03e260:	d0a04f17 	ldw	r2,-32452(gp)
 d03e264:	18800916 	blt	r3,r2,d03e28c <cb_arpent_tmo+0xc4>
 d03e268:	e0bffe17 	ldw	r2,-8(fp)
 d03e26c:	10c00617 	ldw	r3,24(r2)
 d03e270:	e0bffc17 	ldw	r2,-16(fp)
 d03e274:	10c5c83a 	sub	r2,r2,r3
 d03e278:	10801930 	cmpltui	r2,r2,100
 d03e27c:	1000031e 	bne	r2,zero,d03e28c <cb_arpent_tmo+0xc4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03e280:	e0bffe17 	ldw	r2,-8(fp)
 d03e284:	10000015 	stw	zero,0(r2)
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 d03e288:	00000306 	br	d03e298 <cb_arpent_tmo+0xd0>
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else
            arp_count++;
 d03e28c:	e0bffd17 	ldw	r2,-12(fp)
 d03e290:	10800044 	addi	r2,r2,1
 d03e294:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03e298:	e0bffe17 	ldw	r2,-8(fp)
 d03e29c:	10800804 	addi	r2,r2,32
 d03e2a0:	e0bffe15 	stw	r2,-8(fp)
 d03e2a4:	00c341b4 	movhi	r3,3334
 d03e2a8:	18c56304 	addi	r3,r3,5516
 d03e2ac:	e0bffe17 	ldw	r2,-8(fp)
 d03e2b0:	10ffd336 	bltu	r2,r3,d03e200 <cb_arpent_tmo+0x38>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 d03e2b4:	e0bffd17 	ldw	r2,-12(fp)
 d03e2b8:	1004c03a 	cmpne	r2,r2,zero
 d03e2bc:	1000031e 	bne	r2,zero,d03e2cc <cb_arpent_tmo+0x104>
   {
      in_timerkill(arp_timer);
 d03e2c0:	d1293e17 	ldw	r4,-23304(gp)
 d03e2c4:	d03cf000 	call	d03cf00 <in_timerkill>
      arp_timer = 0;
 d03e2c8:	d0293e15 	stw	zero,-23304(gp)
   }
      
   USE_ARG(arg);
}
 d03e2cc:	e037883a 	mov	sp,fp
 d03e2d0:	dfc00117 	ldw	ra,4(sp)
 d03e2d4:	df000017 	ldw	fp,0(sp)
 d03e2d8:	dec00204 	addi	sp,sp,8
 d03e2dc:	f800283a 	ret

0d03e2e0 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 d03e2e0:	defff604 	addi	sp,sp,-40
 d03e2e4:	dfc00915 	stw	ra,36(sp)
 d03e2e8:	df000815 	stw	fp,32(sp)
 d03e2ec:	df000804 	addi	fp,sp,32
 d03e2f0:	e13ffd15 	stw	r4,-12(fp)
 d03e2f4:	e17ffe15 	stw	r5,-8(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 d03e2f8:	e0bffd17 	ldw	r2,-12(fp)
 d03e2fc:	10802717 	ldw	r2,156(r2)
 d03e300:	e0bffa15 	stw	r2,-24(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 d03e304:	01000084 	movi	r4,2
 d03e308:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 d03e30c:	01000c04 	movi	r4,48
 d03e310:	d024e0c0 	call	d024e0c <pk_alloc>
 d03e314:	e0bff915 	stw	r2,-28(fp)
   if (!arppkt)
 d03e318:	e0bff917 	ldw	r2,-28(fp)
 d03e31c:	1004c03a 	cmpne	r2,r2,zero
 d03e320:	1000051e 	bne	r2,zero,d03e338 <grat_arp+0x58>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e324:	01000084 	movi	r4,2
 d03e328:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 d03e32c:	00bffa84 	movi	r2,-22
 d03e330:	e0bfff15 	stw	r2,-4(fp)
 d03e334:	00009706 	br	d03e594 <grat_arp+0x2b4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e338:	01000084 	movi	r4,2
 d03e33c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 d03e340:	e0bff917 	ldw	r2,-28(fp)
 d03e344:	10c00117 	ldw	r3,4(r2)
 d03e348:	e0bff917 	ldw	r2,-28(fp)
 d03e34c:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 d03e350:	e0fff917 	ldw	r3,-28(fp)
 d03e354:	00800c04 	movi	r2,48
 d03e358:	18800415 	stw	r2,16(r3)
   arppkt->net = net;
 d03e35c:	e0fff917 	ldw	r3,-28(fp)
 d03e360:	e0bffd17 	ldw	r2,-12(fp)
 d03e364:	18800615 	stw	r2,24(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 d03e368:	e0bff917 	ldw	r2,-28(fp)
 d03e36c:	10800117 	ldw	r2,4(r2)
 d03e370:	10800084 	addi	r2,r2,2
 d03e374:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 d03e378:	e0bff917 	ldw	r2,-28(fp)
 d03e37c:	10800117 	ldw	r2,4(r2)
 d03e380:	10800404 	addi	r2,r2,16
 d03e384:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 d03e388:	e0fffb17 	ldw	r3,-20(fp)
 d03e38c:	00804004 	movi	r2,256
 d03e390:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 d03e394:	e0fffb17 	ldw	r3,-20(fp)
 d03e398:	00800204 	movi	r2,8
 d03e39c:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 d03e3a0:	e0fffb17 	ldw	r3,-20(fp)
 d03e3a4:	00800184 	movi	r2,6
 d03e3a8:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 d03e3ac:	e0fffb17 	ldw	r3,-20(fp)
 d03e3b0:	00800104 	movi	r2,4
 d03e3b4:	18800145 	stb	r2,5(r3)
   
   /* ARP req? */
   if (flag == 0)
 d03e3b8:	e0bffe17 	ldw	r2,-8(fp)
 d03e3bc:	1004c03a 	cmpne	r2,r2,zero
 d03e3c0:	1000041e 	bne	r2,zero,d03e3d4 <grat_arp+0xf4>
      /* yup */
      arphdr->ar_op = ARREQ;
 d03e3c4:	e0fffb17 	ldw	r3,-20(fp)
 d03e3c8:	00804004 	movi	r2,256
 d03e3cc:	1880018d 	sth	r2,6(r3)
 d03e3d0:	00000306 	br	d03e3e0 <grat_arp+0x100>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 d03e3d4:	e0fffb17 	ldw	r3,-20(fp)
 d03e3d8:	00808004 	movi	r2,512
 d03e3dc:	1880018d 	sth	r2,6(r3)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 d03e3e0:	e0bffd17 	ldw	r2,-12(fp)
 d03e3e4:	10c00a17 	ldw	r3,40(r2)
 d03e3e8:	e0bffb17 	ldw	r2,-20(fp)
 d03e3ec:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 d03e3f0:	e0bffd17 	ldw	r2,-12(fp)
 d03e3f4:	10c00a17 	ldw	r3,40(r2)
 d03e3f8:	e0bffb17 	ldw	r2,-20(fp)
 d03e3fc:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 d03e400:	e0bffb17 	ldw	r2,-20(fp)
 d03e404:	11000204 	addi	r4,r2,8
 d03e408:	e0bffa17 	ldw	r2,-24(fp)
 d03e40c:	11400517 	ldw	r5,20(r2)
 d03e410:	01800184 	movi	r6,6
 d03e414:	d0026a80 	call	d0026a8 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 d03e418:	e0fffc17 	ldw	r3,-16(fp)
 d03e41c:	00bfffc4 	movi	r2,-1
 d03e420:	18800005 	stb	r2,0(r3)
 d03e424:	00bfffc4 	movi	r2,-1
 d03e428:	18800045 	stb	r2,1(r3)
 d03e42c:	00bfffc4 	movi	r2,-1
 d03e430:	18800085 	stb	r2,2(r3)
 d03e434:	00bfffc4 	movi	r2,-1
 d03e438:	188000c5 	stb	r2,3(r3)
 d03e43c:	00bfffc4 	movi	r2,-1
 d03e440:	18800105 	stb	r2,4(r3)
 d03e444:	00bfffc4 	movi	r2,-1
 d03e448:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 d03e44c:	e0bffc17 	ldw	r2,-16(fp)
 d03e450:	11000184 	addi	r4,r2,6
 d03e454:	e0bffa17 	ldw	r2,-24(fp)
 d03e458:	11400517 	ldw	r5,20(r2)
 d03e45c:	01800184 	movi	r6,6
 d03e460:	d0026a80 	call	d0026a8 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 d03e464:	e0bffc17 	ldw	r2,-16(fp)
 d03e468:	10c00304 	addi	r3,r2,12
 d03e46c:	00800204 	movi	r2,8
 d03e470:	18800005 	stb	r2,0(r3)
 d03e474:	e0bffc17 	ldw	r2,-16(fp)
 d03e478:	10c00344 	addi	r3,r2,13
 d03e47c:	00800184 	movi	r2,6
 d03e480:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 d03e484:	e0bffb17 	ldw	r2,-20(fp)
 d03e488:	e0bff815 	stw	r2,-32(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 d03e48c:	e0bff817 	ldw	r2,-32(fp)
 d03e490:	11000204 	addi	r4,r2,8
 d03e494:	e0bffb17 	ldw	r2,-20(fp)
 d03e498:	11400204 	addi	r5,r2,8
 d03e49c:	01800184 	movi	r6,6
 d03e4a0:	d0026a80 	call	d0026a8 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 d03e4a4:	e0bff817 	ldw	r2,-32(fp)
 d03e4a8:	10800204 	addi	r2,r2,8
 d03e4ac:	11000184 	addi	r4,r2,6
 d03e4b0:	e0bffb17 	ldw	r2,-20(fp)
 d03e4b4:	11400404 	addi	r5,r2,16
 d03e4b8:	01800104 	movi	r6,4
 d03e4bc:	d0026a80 	call	d0026a8 <memmove>

   /* ARP req? */
   if (flag == 0)
 d03e4c0:	e0bffe17 	ldw	r2,-8(fp)
 d03e4c4:	1004c03a 	cmpne	r2,r2,zero
 d03e4c8:	1000081e 	bne	r2,zero,d03e4ec <grat_arp+0x20c>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 d03e4cc:	e0bff817 	ldw	r2,-32(fp)
 d03e4d0:	10800204 	addi	r2,r2,8
 d03e4d4:	11000284 	addi	r4,r2,10
 d03e4d8:	e0bffb17 	ldw	r2,-20(fp)
 d03e4dc:	11400504 	addi	r5,r2,20
 d03e4e0:	01800184 	movi	r6,6
 d03e4e4:	d0026a80 	call	d0026a8 <memmove>
 d03e4e8:	00000706 	br	d03e508 <grat_arp+0x228>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 d03e4ec:	e0bff817 	ldw	r2,-32(fp)
 d03e4f0:	10800204 	addi	r2,r2,8
 d03e4f4:	11000284 	addi	r4,r2,10
 d03e4f8:	e0bffb17 	ldw	r2,-20(fp)
 d03e4fc:	11400204 	addi	r5,r2,8
 d03e500:	01800184 	movi	r6,6
 d03e504:	d0026a80 	call	d0026a8 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 d03e508:	e0bff817 	ldw	r2,-32(fp)
 d03e50c:	10800204 	addi	r2,r2,8
 d03e510:	11000404 	addi	r4,r2,16
 d03e514:	e0bffb17 	ldw	r2,-20(fp)
 d03e518:	11400704 	addi	r5,r2,28
 d03e51c:	01800104 	movi	r6,4
 d03e520:	d0026a80 	call	d0026a8 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 d03e524:	e0bffd17 	ldw	r2,-12(fp)
 d03e528:	10800417 	ldw	r2,16(r2)
 d03e52c:	1005003a 	cmpeq	r2,r2,zero
 d03e530:	1000051e 	bne	r2,zero,d03e548 <grat_arp+0x268>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 d03e534:	e0bffd17 	ldw	r2,-12(fp)
 d03e538:	10800417 	ldw	r2,16(r2)
 d03e53c:	e13ff917 	ldw	r4,-28(fp)
 d03e540:	103ee83a 	callr	r2
 d03e544:	00000e06 	br	d03e580 <grat_arp+0x2a0>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 d03e548:	e0bffd17 	ldw	r2,-12(fp)
 d03e54c:	10c00317 	ldw	r3,12(r2)
 d03e550:	e0bff917 	ldw	r2,-28(fp)
 d03e554:	11000617 	ldw	r4,24(r2)
 d03e558:	e0bff917 	ldw	r2,-28(fp)
 d03e55c:	11400117 	ldw	r5,4(r2)
 d03e560:	01800c04 	movi	r6,48
 d03e564:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03e568:	01000084 	movi	r4,2
 d03e56c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 d03e570:	e13ff917 	ldw	r4,-28(fp)
 d03e574:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e578:	01000084 	movi	r4,2
 d03e57c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 d03e580:	d0a94117 	ldw	r2,-23292(gp)
 d03e584:	10800044 	addi	r2,r2,1
 d03e588:	d0a94115 	stw	r2,-23292(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 d03e58c:	00800044 	movi	r2,1
 d03e590:	e0bfff15 	stw	r2,-4(fp)
 d03e594:	e0bfff17 	ldw	r2,-4(fp)
}
 d03e598:	e037883a 	mov	sp,fp
 d03e59c:	dfc00117 	ldw	ra,4(sp)
 d03e5a0:	df000017 	ldw	fp,0(sp)
 d03e5a4:	dec00204 	addi	sp,sp,8
 d03e5a8:	f800283a 	ret

0d03e5ac <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 d03e5ac:	defffb04 	addi	sp,sp,-20
 d03e5b0:	dfc00415 	stw	ra,16(sp)
 d03e5b4:	df000315 	stw	fp,12(sp)
 d03e5b8:	df000304 	addi	fp,sp,12
 d03e5bc:	e13ffe15 	stw	r4,-8(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03e5c0:	008341b4 	movhi	r2,3334
 d03e5c4:	10856304 	addi	r2,r2,5516
 d03e5c8:	10800017 	ldw	r2,0(r2)
 d03e5cc:	e0bffd15 	stw	r2,-12(fp)
 d03e5d0:	00000c06 	br	d03e604 <if_getbynum+0x58>
   {
      if(ifnum-- == 0)
 d03e5d4:	e0bffe17 	ldw	r2,-8(fp)
 d03e5d8:	10bfffc4 	addi	r2,r2,-1
 d03e5dc:	e0bffe15 	stw	r2,-8(fp)
 d03e5e0:	e0bffe17 	ldw	r2,-8(fp)
 d03e5e4:	10bfffd8 	cmpnei	r2,r2,-1
 d03e5e8:	1000031e 	bne	r2,zero,d03e5f8 <if_getbynum+0x4c>
         return ifp;
 d03e5ec:	e0bffd17 	ldw	r2,-12(fp)
 d03e5f0:	e0bfff15 	stw	r2,-4(fp)
 d03e5f4:	00000806 	br	d03e618 <if_getbynum+0x6c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03e5f8:	e0bffd17 	ldw	r2,-12(fp)
 d03e5fc:	10800017 	ldw	r2,0(r2)
 d03e600:	e0bffd15 	stw	r2,-12(fp)
 d03e604:	e0bffd17 	ldw	r2,-12(fp)
 d03e608:	1004c03a 	cmpne	r2,r2,zero
 d03e60c:	103ff11e 	bne	r2,zero,d03e5d4 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 d03e610:	d025a500 	call	d025a50 <dtrap>
   return NULL;   /* list is not long enough */
 d03e614:	e03fff15 	stw	zero,-4(fp)
 d03e618:	e0bfff17 	ldw	r2,-4(fp)
}
 d03e61c:	e037883a 	mov	sp,fp
 d03e620:	dfc00117 	ldw	ra,4(sp)
 d03e624:	df000017 	ldw	fp,0(sp)
 d03e628:	dec00204 	addi	sp,sp,8
 d03e62c:	f800283a 	ret

0d03e630 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 d03e630:	defffc04 	addi	sp,sp,-16
 d03e634:	df000315 	stw	fp,12(sp)
 d03e638:	df000304 	addi	fp,sp,12
 d03e63c:	e13ffd15 	stw	r4,-12(fp)
 d03e640:	e17ffe15 	stw	r5,-8(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 d03e644:	e0bffe17 	ldw	r2,-8(fp)
 d03e648:	108000cc 	andi	r2,r2,3
 d03e64c:	1005003a 	cmpeq	r2,r2,zero
 d03e650:	10000e1e 	bne	r2,zero,d03e68c <isbcast+0x5c>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 d03e654:	e0bffe17 	ldw	r2,-8(fp)
 d03e658:	1080000b 	ldhu	r2,0(r2)
 d03e65c:	10ffffcc 	andi	r3,r2,65535
 d03e660:	00bfffd4 	movui	r2,65535
 d03e664:	18800226 	beq	r3,r2,d03e670 <isbcast+0x40>
         return(FALSE);
 d03e668:	e03fff15 	stw	zero,-4(fp)
 d03e66c:	00002306 	br	d03e6fc <isbcast+0xcc>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 d03e670:	e0bffe17 	ldw	r2,-8(fp)
 d03e674:	10800084 	addi	r2,r2,2
 d03e678:	10800017 	ldw	r2,0(r2)
 d03e67c:	10bfffe0 	cmpeqi	r2,r2,-1
 d03e680:	1000101e 	bne	r2,zero,d03e6c4 <isbcast+0x94>
         return FALSE;
 d03e684:	e03fff15 	stw	zero,-4(fp)
 d03e688:	00001c06 	br	d03e6fc <isbcast+0xcc>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 d03e68c:	e0bffe17 	ldw	r2,-8(fp)
 d03e690:	10800017 	ldw	r2,0(r2)
 d03e694:	10bfffe0 	cmpeqi	r2,r2,-1
 d03e698:	1000021e 	bne	r2,zero,d03e6a4 <isbcast+0x74>
         return FALSE;
 d03e69c:	e03fff15 	stw	zero,-4(fp)
 d03e6a0:	00001606 	br	d03e6fc <isbcast+0xcc>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 d03e6a4:	e0bffe17 	ldw	r2,-8(fp)
 d03e6a8:	10800104 	addi	r2,r2,4
 d03e6ac:	1080000b 	ldhu	r2,0(r2)
 d03e6b0:	10ffffcc 	andi	r3,r2,65535
 d03e6b4:	00bfffd4 	movui	r2,65535
 d03e6b8:	18800226 	beq	r3,r2,d03e6c4 <isbcast+0x94>
         return(FALSE);
 d03e6bc:	e03fff15 	stw	zero,-4(fp)
 d03e6c0:	00000e06 	br	d03e6fc <isbcast+0xcc>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 d03e6c4:	e0bffd17 	ldw	r2,-12(fp)
 d03e6c8:	10802717 	ldw	r2,156(r2)
 d03e6cc:	10800217 	ldw	r2,8(r2)
 d03e6d0:	108005e0 	cmpeqi	r2,r2,23
 d03e6d4:	1000051e 	bne	r2,zero,d03e6ec <isbcast+0xbc>
 d03e6d8:	e0bffd17 	ldw	r2,-12(fp)
 d03e6dc:	10802717 	ldw	r2,156(r2)
 d03e6e0:	10800217 	ldw	r2,8(r2)
 d03e6e4:	10800718 	cmpnei	r2,r2,28
 d03e6e8:	1000021e 	bne	r2,zero,d03e6f4 <isbcast+0xc4>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 d03e6ec:	e03fff15 	stw	zero,-4(fp)
 d03e6f0:	00000206 	br	d03e6fc <isbcast+0xcc>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 d03e6f4:	00800044 	movi	r2,1
 d03e6f8:	e0bfff15 	stw	r2,-4(fp)
 d03e6fc:	e0bfff17 	ldw	r2,-4(fp)
}
 d03e700:	e037883a 	mov	sp,fp
 d03e704:	df000017 	ldw	fp,0(sp)
 d03e708:	dec00104 	addi	sp,sp,4
 d03e70c:	f800283a 	ret

0d03e710 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 d03e710:	defffa04 	addi	sp,sp,-24
 d03e714:	dfc00515 	stw	ra,20(sp)
 d03e718:	df000415 	stw	fp,16(sp)
 d03e71c:	df000404 	addi	fp,sp,16
 d03e720:	e13ffe0d 	sth	r4,-8(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03e724:	008341b4 	movhi	r2,3334
 d03e728:	10856304 	addi	r2,r2,5516
 d03e72c:	10800017 	ldw	r2,0(r2)
 d03e730:	e0bffd15 	stw	r2,-12(fp)
 d03e734:	00001306 	br	d03e784 <reg_type+0x74>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 d03e738:	e0bffd17 	ldw	r2,-12(fp)
 d03e73c:	10800617 	ldw	r2,24(r2)
 d03e740:	1005003a 	cmpeq	r2,r2,zero
 d03e744:	10000c1e 	bne	r2,zero,d03e778 <reg_type+0x68>
      {
         e = (ifp->n_reg_type)(type, ifp);
 d03e748:	e0bffd17 	ldw	r2,-12(fp)
 d03e74c:	10800617 	ldw	r2,24(r2)
 d03e750:	e13ffe0b 	ldhu	r4,-8(fp)
 d03e754:	e17ffd17 	ldw	r5,-12(fp)
 d03e758:	103ee83a 	callr	r2
 d03e75c:	e0bffc15 	stw	r2,-16(fp)
         if (e)
 d03e760:	e0bffc17 	ldw	r2,-16(fp)
 d03e764:	1005003a 	cmpeq	r2,r2,zero
 d03e768:	1000031e 	bne	r2,zero,d03e778 <reg_type+0x68>
            return e;   /* bails out if error */
 d03e76c:	e0bffc17 	ldw	r2,-16(fp)
 d03e770:	e0bfff15 	stw	r2,-4(fp)
 d03e774:	00000706 	br	d03e794 <reg_type+0x84>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03e778:	e0bffd17 	ldw	r2,-12(fp)
 d03e77c:	10800017 	ldw	r2,0(r2)
 d03e780:	e0bffd15 	stw	r2,-12(fp)
 d03e784:	e0bffd17 	ldw	r2,-12(fp)
 d03e788:	1004c03a 	cmpne	r2,r2,zero
 d03e78c:	103fea1e 	bne	r2,zero,d03e738 <reg_type+0x28>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 d03e790:	e03fff15 	stw	zero,-4(fp)
 d03e794:	e0bfff17 	ldw	r2,-4(fp)
}
 d03e798:	e037883a 	mov	sp,fp
 d03e79c:	dfc00117 	ldw	ra,4(sp)
 d03e7a0:	df000017 	ldw	fp,0(sp)
 d03e7a4:	dec00204 	addi	sp,sp,8
 d03e7a8:	f800283a 	ret

0d03e7ac <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 d03e7ac:	defffa04 	addi	sp,sp,-24
 d03e7b0:	dfc00515 	stw	ra,20(sp)
 d03e7b4:	df000415 	stw	fp,16(sp)
 d03e7b8:	df000404 	addi	fp,sp,16
 d03e7bc:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 d03e7c0:	008341b4 	movhi	r2,3334
 d03e7c4:	10845704 	addi	r2,r2,4444
 d03e7c8:	10800017 	ldw	r2,0(r2)
 d03e7cc:	e0bffe15 	stw	r2,-8(fp)
   while(so)
 d03e7d0:	00001406 	br	d03e824 <if_killsocks+0x78>
   {
      if(so->so_pcb)
 d03e7d4:	e0bffe17 	ldw	r2,-8(fp)
 d03e7d8:	10800117 	ldw	r2,4(r2)
 d03e7dc:	1005003a 	cmpeq	r2,r2,zero
 d03e7e0:	1000051e 	bne	r2,zero,d03e7f8 <if_killsocks+0x4c>
         so_ifp = so->so_pcb->ifp;
 d03e7e4:	e0bffe17 	ldw	r2,-8(fp)
 d03e7e8:	10800117 	ldw	r2,4(r2)
 d03e7ec:	10800a17 	ldw	r2,40(r2)
 d03e7f0:	e0bffc15 	stw	r2,-16(fp)
 d03e7f4:	00000106 	br	d03e7fc <if_killsocks+0x50>
      else
         so_ifp = NULL;
 d03e7f8:	e03ffc15 	stw	zero,-16(fp)
      next = (struct socket *)so->next;
 d03e7fc:	e0bffe17 	ldw	r2,-8(fp)
 d03e800:	10800017 	ldw	r2,0(r2)
 d03e804:	e0bffd15 	stw	r2,-12(fp)
      if (so_ifp == ifp)
 d03e808:	e0fffc17 	ldw	r3,-16(fp)
 d03e80c:	e0bfff17 	ldw	r2,-4(fp)
 d03e810:	1880021e 	bne	r3,r2,d03e81c <if_killsocks+0x70>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 d03e814:	e13ffe17 	ldw	r4,-8(fp)
 d03e818:	d02a9ec0 	call	d02a9ec <soabort>
      }
      so = next;
 d03e81c:	e0bffd17 	ldw	r2,-12(fp)
 d03e820:	e0bffe15 	stw	r2,-8(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 d03e824:	e0bffe17 	ldw	r2,-8(fp)
 d03e828:	1004c03a 	cmpne	r2,r2,zero
 d03e82c:	103fe91e 	bne	r2,zero,d03e7d4 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 d03e830:	e037883a 	mov	sp,fp
 d03e834:	dfc00117 	ldw	ra,4(sp)
 d03e838:	df000017 	ldw	fp,0(sp)
 d03e83c:	dec00204 	addi	sp,sp,8
 d03e840:	f800283a 	ret

0d03e844 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 d03e844:	defffc04 	addi	sp,sp,-16
 d03e848:	dfc00315 	stw	ra,12(sp)
 d03e84c:	df000215 	stw	fp,8(sp)
 d03e850:	dc000115 	stw	r16,4(sp)
 d03e854:	df000104 	addi	fp,sp,4

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 d03e858:	01000204 	movi	r4,8
 d03e85c:	d03e7100 	call	d03e710 <reg_type>
 d03e860:	1005003a 	cmpeq	r2,r2,zero
 d03e864:	1000061e 	bne	r2,zero,d03e880 <ip_init+0x3c>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 d03e868:	01034174 	movhi	r4,3333
 d03e86c:	21069904 	addi	r4,r4,6756
 d03e870:	d002bc80 	call	d002bc8 <puts>
#endif
      return(1);
 d03e874:	00800044 	movi	r2,1
 d03e878:	e0bfff15 	stw	r2,-4(fp)
 d03e87c:	00002e06 	br	d03e938 <ip_init+0xf4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 d03e880:	008341b4 	movhi	r2,3334
 d03e884:	10856804 	addi	r2,r2,5536
 d03e888:	1009883a 	mov	r4,r2
 d03e88c:	01801404 	movi	r6,80
 d03e890:	000b883a 	mov	r5,zero
 d03e894:	d0027880 	call	d002788 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 d03e898:	00c341b4 	movhi	r3,3334
 d03e89c:	18c56804 	addi	r3,r3,5536
 d03e8a0:	00800084 	movi	r2,2
 d03e8a4:	18800015 	stw	r2,0(r3)
   ip_mib.ipDefaultTTL = IP_TTL;
 d03e8a8:	00c341b4 	movhi	r3,3334
 d03e8ac:	18c56804 	addi	r3,r3,5536
 d03e8b0:	00801004 	movi	r2,64
 d03e8b4:	18800115 	stw	r2,4(r3)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 d03e8b8:	d1205117 	ldw	r4,-32444(gp)
 d03e8bc:	01400f04 	movi	r5,60
 d03e8c0:	d00235c0 	call	d00235c <__mulsi3>
 d03e8c4:	1009883a 	mov	r4,r2
 d03e8c8:	d0264b80 	call	d0264b8 <npalloc>
 d03e8cc:	d0a94515 	stw	r2,-23276(gp)
   if (!rt_mib)
 d03e8d0:	d0a94517 	ldw	r2,-23276(gp)
 d03e8d4:	1004c03a 	cmpne	r2,r2,zero
 d03e8d8:	1000061e 	bne	r2,zero,d03e8f4 <ip_init+0xb0>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 d03e8dc:	01034174 	movhi	r4,3333
 d03e8e0:	2106a604 	addi	r4,r4,6808
 d03e8e4:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 d03e8e8:	00bffb04 	movi	r2,-20
 d03e8ec:	e0bfff15 	stw	r2,-4(fp)
 d03e8f0:	00001106 	br	d03e938 <ip_init+0xf4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 d03e8f4:	d4294517 	ldw	r16,-23276(gp)
 d03e8f8:	d1205117 	ldw	r4,-32444(gp)
 d03e8fc:	01400f04 	movi	r5,60
 d03e900:	d00235c0 	call	d00235c <__mulsi3>
 d03e904:	8009883a 	mov	r4,r16
 d03e908:	100d883a 	mov	r6,r2
 d03e90c:	000b883a 	mov	r5,zero
 d03e910:	d0027880 	call	d002788 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 d03e914:	00c341b4 	movhi	r3,3334
 d03e918:	18c56804 	addi	r3,r3,5536
 d03e91c:	00800044 	movi	r2,1
 d03e920:	18800015 	stw	r2,0(r3)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 d03e924:	00c341b4 	movhi	r3,3334
 d03e928:	18c56804 	addi	r3,r3,5536
 d03e92c:	00801e04 	movi	r2,120
 d03e930:	18800c15 	stw	r2,48(r3)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 d03e934:	e03fff15 	stw	zero,-4(fp)
 d03e938:	e0bfff17 	ldw	r2,-4(fp)
}
 d03e93c:	e037883a 	mov	sp,fp
 d03e940:	dfc00217 	ldw	ra,8(sp)
 d03e944:	df000117 	ldw	fp,4(sp)
 d03e948:	dc000017 	ldw	r16,0(sp)
 d03e94c:	dec00304 	addi	sp,sp,12
 d03e950:	f800283a 	ret

0d03e954 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 d03e954:	defff804 	addi	sp,sp,-32
 d03e958:	dfc00715 	stw	ra,28(sp)
 d03e95c:	df000615 	stw	fp,24(sp)
 d03e960:	df000604 	addi	fp,sp,24
 d03e964:	e13ffc15 	stw	r4,-16(fp)
 d03e968:	e17ffd15 	stw	r5,-12(fp)
 d03e96c:	e1bffe05 	stb	r6,-8(fp)
 d03e970:	e1ffff0d 	sth	r7,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 d03e974:	e0bffc17 	ldw	r2,-16(fp)
 d03e978:	10800317 	ldw	r2,12(r2)
 d03e97c:	10fffb04 	addi	r3,r2,-20
 d03e980:	e0bffc17 	ldw	r2,-16(fp)
 d03e984:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 d03e988:	e0bffc17 	ldw	r2,-16(fp)
 d03e98c:	10800417 	ldw	r2,16(r2)
 d03e990:	10c00504 	addi	r3,r2,20
 d03e994:	e0bffc17 	ldw	r2,-16(fp)
 d03e998:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 d03e99c:	e0bffc17 	ldw	r2,-16(fp)
 d03e9a0:	10800317 	ldw	r2,12(r2)
 d03e9a4:	e0bffb15 	stw	r2,-20(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 d03e9a8:	e0fffb17 	ldw	r3,-20(fp)
 d03e9ac:	00801144 	movi	r2,69
 d03e9b0:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 d03e9b4:	e0fffb17 	ldw	r3,-20(fp)
 d03e9b8:	e0bfff0b 	ldhu	r2,-4(fp)
 d03e9bc:	1880018d 	sth	r2,6(r3)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 d03e9c0:	e0bffd17 	ldw	r2,-12(fp)
 d03e9c4:	10bfffcc 	andi	r2,r2,65535
 d03e9c8:	1004d23a 	srli	r2,r2,8
 d03e9cc:	10803fcc 	andi	r2,r2,255
 d03e9d0:	1009883a 	mov	r4,r2
 d03e9d4:	e0bffd17 	ldw	r2,-12(fp)
 d03e9d8:	10bfffcc 	andi	r2,r2,65535
 d03e9dc:	1004923a 	slli	r2,r2,8
 d03e9e0:	1007883a 	mov	r3,r2
 d03e9e4:	00bfc004 	movi	r2,-256
 d03e9e8:	1884703a 	and	r2,r3,r2
 d03e9ec:	2084b03a 	or	r2,r4,r2
 d03e9f0:	1007883a 	mov	r3,r2
 d03e9f4:	e0bffb17 	ldw	r2,-20(fp)
 d03e9f8:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 d03e9fc:	e0bffc17 	ldw	r2,-16(fp)
 d03ea00:	10800417 	ldw	r2,16(r2)
 d03ea04:	10bfffcc 	andi	r2,r2,65535
 d03ea08:	1004d23a 	srli	r2,r2,8
 d03ea0c:	10803fcc 	andi	r2,r2,255
 d03ea10:	1009883a 	mov	r4,r2
 d03ea14:	e0bffc17 	ldw	r2,-16(fp)
 d03ea18:	10800417 	ldw	r2,16(r2)
 d03ea1c:	10bfffcc 	andi	r2,r2,65535
 d03ea20:	1004923a 	slli	r2,r2,8
 d03ea24:	1007883a 	mov	r3,r2
 d03ea28:	00bfc004 	movi	r2,-256
 d03ea2c:	1884703a 	and	r2,r3,r2
 d03ea30:	2084b03a 	or	r2,r4,r2
 d03ea34:	1007883a 	mov	r3,r2
 d03ea38:	e0bffb17 	ldw	r2,-20(fp)
 d03ea3c:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 d03ea40:	e0fffb17 	ldw	r3,-20(fp)
 d03ea44:	e0bffe03 	ldbu	r2,-8(fp)
 d03ea48:	18800245 	stb	r2,9(r3)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 d03ea4c:	e0bffc17 	ldw	r2,-16(fp)
 d03ea50:	10800c17 	ldw	r2,48(r2)
 d03ea54:	e0bffa15 	stw	r2,-24(fp)
 d03ea58:	e0bffa17 	ldw	r2,-24(fp)
 d03ea5c:	1005003a 	cmpeq	r2,r2,zero
 d03ea60:	1000121e 	bne	r2,zero,d03eaac <ip_bldhead+0x158>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 d03ea64:	e0bffa17 	ldw	r2,-24(fp)
 d03ea68:	10800043 	ldbu	r2,1(r2)
 d03ea6c:	10803fcc 	andi	r2,r2,255
 d03ea70:	1005003a 	cmpeq	r2,r2,zero
 d03ea74:	1000051e 	bne	r2,zero,d03ea8c <ip_bldhead+0x138>
         pip->ip_time = sopts->ip_ttl;
 d03ea78:	e0bffa17 	ldw	r2,-24(fp)
 d03ea7c:	10c00043 	ldbu	r3,1(r2)
 d03ea80:	e0bffb17 	ldw	r2,-20(fp)
 d03ea84:	10c00205 	stb	r3,8(r2)
 d03ea88:	00000306 	br	d03ea98 <ip_bldhead+0x144>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 d03ea8c:	e0fffb17 	ldw	r3,-20(fp)
 d03ea90:	00801004 	movi	r2,64
 d03ea94:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 d03ea98:	e0bffa17 	ldw	r2,-24(fp)
 d03ea9c:	10c00003 	ldbu	r3,0(r2)
 d03eaa0:	e0bffb17 	ldw	r2,-20(fp)
 d03eaa4:	10c00045 	stb	r3,1(r2)
 d03eaa8:	00000506 	br	d03eac0 <ip_bldhead+0x16c>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 d03eaac:	e0bffb17 	ldw	r2,-20(fp)
 d03eab0:	00c01004 	movi	r3,64
 d03eab4:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 d03eab8:	e0bffb17 	ldw	r2,-20(fp)
 d03eabc:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 d03eac0:	e0bffb17 	ldw	r2,-20(fp)
 d03eac4:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 d03eac8:	e13ffb17 	ldw	r4,-20(fp)
 d03eacc:	01400284 	movi	r5,10
 d03ead0:	d0205440 	call	d020544 <cksum>
 d03ead4:	0084303a 	nor	r2,zero,r2
 d03ead8:	1007883a 	mov	r3,r2
 d03eadc:	e0bffb17 	ldw	r2,-20(fp)
 d03eae0:	10c0028d 	sth	r3,10(r2)
}
 d03eae4:	e037883a 	mov	sp,fp
 d03eae8:	dfc00117 	ldw	ra,4(sp)
 d03eaec:	df000017 	ldw	fp,0(sp)
 d03eaf0:	dec00204 	addi	sp,sp,8
 d03eaf4:	f800283a 	ret

0d03eaf8 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 d03eaf8:	deffed04 	addi	sp,sp,-76
 d03eafc:	dfc01215 	stw	ra,72(sp)
 d03eb00:	df001115 	stw	fp,68(sp)
 d03eb04:	df001104 	addi	fp,sp,68
 d03eb08:	e13ffc15 	stw	r4,-16(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 d03eb0c:	e0bffc17 	ldw	r2,-16(fp)
 d03eb10:	10800717 	ldw	r2,28(r2)
 d03eb14:	1004d63a 	srli	r2,r2,24
 d03eb18:	10c03fcc 	andi	r3,r2,255
 d03eb1c:	e0bffc17 	ldw	r2,-16(fp)
 d03eb20:	10800717 	ldw	r2,28(r2)
 d03eb24:	1004d23a 	srli	r2,r2,8
 d03eb28:	10bfc00c 	andi	r2,r2,65280
 d03eb2c:	1886b03a 	or	r3,r3,r2
 d03eb30:	e0bffc17 	ldw	r2,-16(fp)
 d03eb34:	10800717 	ldw	r2,28(r2)
 d03eb38:	10bfc00c 	andi	r2,r2,65280
 d03eb3c:	1004923a 	slli	r2,r2,8
 d03eb40:	1886b03a 	or	r3,r3,r2
 d03eb44:	e0bffc17 	ldw	r2,-16(fp)
 d03eb48:	10800717 	ldw	r2,28(r2)
 d03eb4c:	10803fcc 	andi	r2,r2,255
 d03eb50:	1004963a 	slli	r2,r2,24
 d03eb54:	1884b03a 	or	r2,r3,r2
 d03eb58:	10fc002c 	andhi	r3,r2,61440
 d03eb5c:	00b80034 	movhi	r2,57344
 d03eb60:	1880b31e 	bne	r3,r2,d03ee30 <ip_write_internal+0x338>
   {
      if (p->imo != NULL)
 d03eb64:	e0bffc17 	ldw	r2,-16(fp)
 d03eb68:	10800b17 	ldw	r2,44(r2)
 d03eb6c:	1005003a 	cmpeq	r2,r2,zero
 d03eb70:	1000131e 	bne	r2,zero,d03ebc0 <ip_write_internal+0xc8>
         if (p->imo->imo_multicast_netp)
 d03eb74:	e0bffc17 	ldw	r2,-16(fp)
 d03eb78:	10800b17 	ldw	r2,44(r2)
 d03eb7c:	10800017 	ldw	r2,0(r2)
 d03eb80:	1005003a 	cmpeq	r2,r2,zero
 d03eb84:	1000061e 	bne	r2,zero,d03eba0 <ip_write_internal+0xa8>
            p->net = p->imo->imo_multicast_netp;
 d03eb88:	e0bffc17 	ldw	r2,-16(fp)
 d03eb8c:	10800b17 	ldw	r2,44(r2)
 d03eb90:	10c00017 	ldw	r3,0(r2)
 d03eb94:	e0bffc17 	ldw	r2,-16(fp)
 d03eb98:	10c00615 	stw	r3,24(r2)
 d03eb9c:	00002606 	br	d03ec38 <ip_write_internal+0x140>
         else
            p->net = iproute(p->fhost, &firsthop);
 d03eba0:	e0bffc17 	ldw	r2,-16(fp)
 d03eba4:	11000717 	ldw	r4,28(r2)
 d03eba8:	e17ffb04 	addi	r5,fp,-20
 d03ebac:	d0407680 	call	d040768 <iproute>
 d03ebb0:	1007883a 	mov	r3,r2
 d03ebb4:	e0bffc17 	ldw	r2,-16(fp)
 d03ebb8:	10c00615 	stw	r3,24(r2)
 d03ebbc:	00001e06 	br	d03ec38 <ip_write_internal+0x140>
      else
      {
         for (i = 0; i < ifNumber; i++)
 d03ebc0:	e03ff815 	stw	zero,-32(fp)
 d03ebc4:	00001706 	br	d03ec24 <ip_write_internal+0x12c>
            if (nets[i]->n_mcastlist)
 d03ebc8:	e0bff817 	ldw	r2,-32(fp)
 d03ebcc:	00c341b4 	movhi	r3,3334
 d03ebd0:	18c31a04 	addi	r3,r3,3176
 d03ebd4:	1085883a 	add	r2,r2,r2
 d03ebd8:	1085883a 	add	r2,r2,r2
 d03ebdc:	10c5883a 	add	r2,r2,r3
 d03ebe0:	10800017 	ldw	r2,0(r2)
 d03ebe4:	10802b17 	ldw	r2,172(r2)
 d03ebe8:	1005003a 	cmpeq	r2,r2,zero
 d03ebec:	10000a1e 	bne	r2,zero,d03ec18 <ip_write_internal+0x120>
            {
               p->net = nets[i];
 d03ebf0:	e0bff817 	ldw	r2,-32(fp)
 d03ebf4:	00c341b4 	movhi	r3,3334
 d03ebf8:	18c31a04 	addi	r3,r3,3176
 d03ebfc:	1085883a 	add	r2,r2,r2
 d03ec00:	1085883a 	add	r2,r2,r2
 d03ec04:	10c5883a 	add	r2,r2,r3
 d03ec08:	10c00017 	ldw	r3,0(r2)
 d03ec0c:	e0bffc17 	ldw	r2,-16(fp)
 d03ec10:	10c00615 	stw	r3,24(r2)
               break;
 d03ec14:	00000806 	br	d03ec38 <ip_write_internal+0x140>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 d03ec18:	e0bff817 	ldw	r2,-32(fp)
 d03ec1c:	10800044 	addi	r2,r2,1
 d03ec20:	e0bff815 	stw	r2,-32(fp)
 d03ec24:	00834174 	movhi	r2,3333
 d03ec28:	109b2104 	addi	r2,r2,27780
 d03ec2c:	10c00017 	ldw	r3,0(r2)
 d03ec30:	e0bff817 	ldw	r2,-32(fp)
 d03ec34:	10ffe436 	bltu	r2,r3,d03ebc8 <ip_write_internal+0xd0>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 d03ec38:	e0bffc17 	ldw	r2,-16(fp)
 d03ec3c:	10800617 	ldw	r2,24(r2)
 d03ec40:	1005003a 	cmpeq	r2,r2,zero
 d03ec44:	1000051e 	bne	r2,zero,d03ec5c <ip_write_internal+0x164>
 d03ec48:	e0bffc17 	ldw	r2,-16(fp)
 d03ec4c:	10800617 	ldw	r2,24(r2)
 d03ec50:	10802b17 	ldw	r2,172(r2)
 d03ec54:	1004c03a 	cmpne	r2,r2,zero
 d03ec58:	10002e1e 	bne	r2,zero,d03ed14 <ip_write_internal+0x21c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 d03ec5c:	00834174 	movhi	r2,3333
 d03ec60:	109b2004 	addi	r2,r2,27776
 d03ec64:	10800017 	ldw	r2,0(r2)
 d03ec68:	1080840c 	andi	r2,r2,528
 d03ec6c:	1005003a 	cmpeq	r2,r2,zero
 d03ec70:	1000181e 	bne	r2,zero,d03ecd4 <ip_write_internal+0x1dc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 d03ec74:	e0bffc17 	ldw	r2,-16(fp)
 d03ec78:	11800417 	ldw	r6,16(r2)
 d03ec7c:	e0bffc17 	ldw	r2,-16(fp)
 d03ec80:	10800717 	ldw	r2,28(r2)
 d03ec84:	11c03fcc 	andi	r7,r2,255
 d03ec88:	e0bffc17 	ldw	r2,-16(fp)
 d03ec8c:	10800717 	ldw	r2,28(r2)
 d03ec90:	1004d23a 	srli	r2,r2,8
 d03ec94:	11003fcc 	andi	r4,r2,255
 d03ec98:	e0bffc17 	ldw	r2,-16(fp)
 d03ec9c:	10800717 	ldw	r2,28(r2)
 d03eca0:	1004d43a 	srli	r2,r2,16
 d03eca4:	10c03fcc 	andi	r3,r2,255
 d03eca8:	e0bffc17 	ldw	r2,-16(fp)
 d03ecac:	10800717 	ldw	r2,28(r2)
 d03ecb0:	1004d63a 	srli	r2,r2,24
 d03ecb4:	d9000015 	stw	r4,0(sp)
 d03ecb8:	d8c00115 	stw	r3,4(sp)
 d03ecbc:	d8800215 	stw	r2,8(sp)
 d03ecc0:	01034174 	movhi	r4,3333
 d03ecc4:	2106b004 	addi	r4,r4,6848
 d03ecc8:	e17ffc17 	ldw	r5,-16(fp)
 d03eccc:	d0028a00 	call	d0028a0 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 d03ecd0:	d025a500 	call	d025a50 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 d03ecd4:	008341b4 	movhi	r2,3334
 d03ecd8:	10856804 	addi	r2,r2,5536
 d03ecdc:	10800b17 	ldw	r2,44(r2)
 d03ece0:	10c00044 	addi	r3,r2,1
 d03ece4:	008341b4 	movhi	r2,3334
 d03ece8:	10856804 	addi	r2,r2,5536
 d03ecec:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ecf0:	01000084 	movi	r4,2
 d03ecf4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03ecf8:	e13ffc17 	ldw	r4,-16(fp)
 d03ecfc:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03ed00:	01000084 	movi	r4,2
 d03ed04:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 d03ed08:	00bff7c4 	movi	r2,-33
 d03ed0c:	e0bffd15 	stw	r2,-12(fp)
 d03ed10:	00015306 	br	d03f260 <ip_write_internal+0x768>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 d03ed14:	e0bffc17 	ldw	r2,-16(fp)
 d03ed18:	11000717 	ldw	r4,28(r2)
 d03ed1c:	e0bffc17 	ldw	r2,-16(fp)
 d03ed20:	11400617 	ldw	r5,24(r2)
 d03ed24:	d0439640 	call	d043964 <lookup_mcast>
 d03ed28:	e0bff915 	stw	r2,-28(fp)
      if ((inm != NULL) &&
 d03ed2c:	e0bff917 	ldw	r2,-28(fp)
 d03ed30:	1005003a 	cmpeq	r2,r2,zero
 d03ed34:	10001f1e 	bne	r2,zero,d03edb4 <ip_write_internal+0x2bc>
 d03ed38:	e0bffc17 	ldw	r2,-16(fp)
 d03ed3c:	10800b17 	ldw	r2,44(r2)
 d03ed40:	1005003a 	cmpeq	r2,r2,zero
 d03ed44:	1000061e 	bne	r2,zero,d03ed60 <ip_write_internal+0x268>
 d03ed48:	e0bffc17 	ldw	r2,-16(fp)
 d03ed4c:	10800b17 	ldw	r2,44(r2)
 d03ed50:	10800143 	ldbu	r2,5(r2)
 d03ed54:	10803fcc 	andi	r2,r2,255
 d03ed58:	1005003a 	cmpeq	r2,r2,zero
 d03ed5c:	1000151e 	bne	r2,zero,d03edb4 <ip_write_internal+0x2bc>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
      {
         p->type = IPTP;
 d03ed60:	e0fffc17 	ldw	r3,-16(fp)
 d03ed64:	00800204 	movi	r2,8
 d03ed68:	1880080d 	sth	r2,32(r3)
         pkt2 = ip_copypkt(p);
 d03ed6c:	e13ffc17 	ldw	r4,-16(fp)
 d03ed70:	d0409d40 	call	d0409d4 <ip_copypkt>
 d03ed74:	e0bffa15 	stw	r2,-24(fp)
         if (pkt2)
 d03ed78:	e0bffa17 	ldw	r2,-24(fp)
 d03ed7c:	1005003a 	cmpeq	r2,r2,zero
 d03ed80:	10000c1e 	bne	r2,zero,d03edb4 <ip_write_internal+0x2bc>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 d03ed84:	01000044 	movi	r4,1
 d03ed88:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 d03ed8c:	e17ffa17 	ldw	r5,-24(fp)
 d03ed90:	010341b4 	movhi	r4,3334
 d03ed94:	21025504 	addi	r4,r4,2388
 d03ed98:	d0253e00 	call	d0253e0 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 d03ed9c:	01000044 	movi	r4,1
 d03eda0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 d03eda4:	00834174 	movhi	r2,3333
 d03eda8:	109b4804 	addi	r2,r2,27936
 d03edac:	11000017 	ldw	r4,0(r2)
 d03edb0:	d0139400 	call	d013940 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 d03edb4:	e0bffc17 	ldw	r2,-16(fp)
 d03edb8:	10800317 	ldw	r2,12(r2)
 d03edbc:	e0bff715 	stw	r2,-36(fp)
      if ((pip->ip_time == 0) || 
 d03edc0:	e0bff717 	ldw	r2,-36(fp)
 d03edc4:	10800203 	ldbu	r2,8(r2)
 d03edc8:	10803fcc 	andi	r2,r2,255
 d03edcc:	1005003a 	cmpeq	r2,r2,zero
 d03edd0:	10000b1e 	bne	r2,zero,d03ee00 <ip_write_internal+0x308>
 d03edd4:	e0bffc17 	ldw	r2,-16(fp)
 d03edd8:	10800717 	ldw	r2,28(r2)
 d03eddc:	10803fcc 	andi	r2,r2,255
 d03ede0:	10801fe0 	cmpeqi	r2,r2,127
 d03ede4:	1000061e 	bne	r2,zero,d03ee00 <ip_write_internal+0x308>
 d03ede8:	e0bffc17 	ldw	r2,-16(fp)
 d03edec:	10c00717 	ldw	r3,28(r2)
 d03edf0:	e0bffc17 	ldw	r2,-16(fp)
 d03edf4:	10800617 	ldw	r2,24(r2)
 d03edf8:	10800a17 	ldw	r2,40(r2)
 d03edfc:	1880081e 	bne	r3,r2,d03ee20 <ip_write_internal+0x328>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ee00:	01000084 	movi	r4,2
 d03ee04:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03ee08:	e13ffc17 	ldw	r4,-16(fp)
 d03ee0c:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03ee10:	01000084 	movi	r4,2
 d03ee14:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 d03ee18:	e03ffd15 	stw	zero,-12(fp)
 d03ee1c:	00011006 	br	d03f260 <ip_write_internal+0x768>
      }

      firsthop = p->fhost;
 d03ee20:	e0bffc17 	ldw	r2,-16(fp)
 d03ee24:	10800717 	ldw	r2,28(r2)
 d03ee28:	e0bffb15 	stw	r2,-20(fp)

      goto sendit;
 d03ee2c:	00004106 	br	d03ef34 <ip_write_internal+0x43c>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 d03ee30:	e0bffc17 	ldw	r2,-16(fp)
 d03ee34:	10800717 	ldw	r2,28(r2)
 d03ee38:	10bfffd8 	cmpnei	r2,r2,-1
 d03ee3c:	1000041e 	bne	r2,zero,d03ee50 <ip_write_internal+0x358>
   {
      firsthop = p->fhost;
 d03ee40:	e0bffc17 	ldw	r2,-16(fp)
 d03ee44:	10800717 	ldw	r2,28(r2)
 d03ee48:	e0bffb15 	stw	r2,-20(fp)
 d03ee4c:	00003906 	br	d03ef34 <ip_write_internal+0x43c>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 d03ee50:	e0bffc17 	ldw	r2,-16(fp)
 d03ee54:	11000717 	ldw	r4,28(r2)
 d03ee58:	e17ffb04 	addi	r5,fp,-20
 d03ee5c:	d0407680 	call	d040768 <iproute>
 d03ee60:	1007883a 	mov	r3,r2
 d03ee64:	e0bffc17 	ldw	r2,-16(fp)
 d03ee68:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 d03ee6c:	e0bffc17 	ldw	r2,-16(fp)
 d03ee70:	10800617 	ldw	r2,24(r2)
 d03ee74:	1004c03a 	cmpne	r2,r2,zero
 d03ee78:	10002e1e 	bne	r2,zero,d03ef34 <ip_write_internal+0x43c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 d03ee7c:	00834174 	movhi	r2,3333
 d03ee80:	109b2004 	addi	r2,r2,27776
 d03ee84:	10800017 	ldw	r2,0(r2)
 d03ee88:	1080840c 	andi	r2,r2,528
 d03ee8c:	1005003a 	cmpeq	r2,r2,zero
 d03ee90:	1000181e 	bne	r2,zero,d03eef4 <ip_write_internal+0x3fc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 d03ee94:	e0bffc17 	ldw	r2,-16(fp)
 d03ee98:	11800417 	ldw	r6,16(r2)
 d03ee9c:	e0bffc17 	ldw	r2,-16(fp)
 d03eea0:	10800717 	ldw	r2,28(r2)
 d03eea4:	11c03fcc 	andi	r7,r2,255
 d03eea8:	e0bffc17 	ldw	r2,-16(fp)
 d03eeac:	10800717 	ldw	r2,28(r2)
 d03eeb0:	1004d23a 	srli	r2,r2,8
 d03eeb4:	11003fcc 	andi	r4,r2,255
 d03eeb8:	e0bffc17 	ldw	r2,-16(fp)
 d03eebc:	10800717 	ldw	r2,28(r2)
 d03eec0:	1004d43a 	srli	r2,r2,16
 d03eec4:	10c03fcc 	andi	r3,r2,255
 d03eec8:	e0bffc17 	ldw	r2,-16(fp)
 d03eecc:	10800717 	ldw	r2,28(r2)
 d03eed0:	1004d63a 	srli	r2,r2,24
 d03eed4:	d9000015 	stw	r4,0(sp)
 d03eed8:	d8c00115 	stw	r3,4(sp)
 d03eedc:	d8800215 	stw	r2,8(sp)
 d03eee0:	01034174 	movhi	r4,3333
 d03eee4:	2106b004 	addi	r4,r4,6848
 d03eee8:	e17ffc17 	ldw	r5,-16(fp)
 d03eeec:	d0028a00 	call	d0028a0 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 d03eef0:	d025a500 	call	d025a50 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 d03eef4:	008341b4 	movhi	r2,3334
 d03eef8:	10856804 	addi	r2,r2,5536
 d03eefc:	10800b17 	ldw	r2,44(r2)
 d03ef00:	10c00044 	addi	r3,r2,1
 d03ef04:	008341b4 	movhi	r2,3334
 d03ef08:	10856804 	addi	r2,r2,5536
 d03ef0c:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ef10:	01000084 	movi	r4,2
 d03ef14:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03ef18:	e13ffc17 	ldw	r4,-16(fp)
 d03ef1c:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03ef20:	01000084 	movi	r4,2
 d03ef24:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 d03ef28:	00fff7c4 	movi	r3,-33
 d03ef2c:	e0fffd15 	stw	r3,-12(fp)
 d03ef30:	0000cb06 	br	d03f260 <ip_write_internal+0x768>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 d03ef34:	00834174 	movhi	r2,3333
 d03ef38:	109b2004 	addi	r2,r2,27776
 d03ef3c:	10800017 	ldw	r2,0(r2)
 d03ef40:	1080800c 	andi	r2,r2,512
 d03ef44:	1005003a 	cmpeq	r2,r2,zero
 d03ef48:	1000231e 	bne	r2,zero,d03efd8 <ip_write_internal+0x4e0>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 d03ef4c:	e0bffc17 	ldw	r2,-16(fp)
 d03ef50:	11400417 	ldw	r5,16(r2)
 d03ef54:	e0bffc17 	ldw	r2,-16(fp)
 d03ef58:	10800717 	ldw	r2,28(r2)
 d03ef5c:	11803fcc 	andi	r6,r2,255
 d03ef60:	e0bffc17 	ldw	r2,-16(fp)
 d03ef64:	10800717 	ldw	r2,28(r2)
 d03ef68:	1004d23a 	srli	r2,r2,8
 d03ef6c:	11c03fcc 	andi	r7,r2,255
 d03ef70:	e0bffc17 	ldw	r2,-16(fp)
 d03ef74:	10800717 	ldw	r2,28(r2)
 d03ef78:	1004d43a 	srli	r2,r2,16
 d03ef7c:	10c03fcc 	andi	r3,r2,255
 d03ef80:	e0bffc17 	ldw	r2,-16(fp)
 d03ef84:	10800717 	ldw	r2,28(r2)
 d03ef88:	1004d63a 	srli	r2,r2,24
 d03ef8c:	d8c00015 	stw	r3,0(sp)
 d03ef90:	d8800115 	stw	r2,4(sp)
 d03ef94:	01034174 	movhi	r4,3333
 d03ef98:	2106c004 	addi	r4,r4,6912
 d03ef9c:	d0028a00 	call	d0028a0 <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 d03efa0:	e0bffb17 	ldw	r2,-20(fp)
 d03efa4:	11403fcc 	andi	r5,r2,255
 d03efa8:	e0bffb17 	ldw	r2,-20(fp)
 d03efac:	1004d23a 	srli	r2,r2,8
 d03efb0:	11803fcc 	andi	r6,r2,255
 d03efb4:	e0bffb17 	ldw	r2,-20(fp)
 d03efb8:	1004d43a 	srli	r2,r2,16
 d03efbc:	11c03fcc 	andi	r7,r2,255
 d03efc0:	e0bffb17 	ldw	r2,-20(fp)
 d03efc4:	1004d63a 	srli	r2,r2,24
 d03efc8:	d8800015 	stw	r2,0(sp)
 d03efcc:	01034174 	movhi	r4,3333
 d03efd0:	2106c904 	addi	r4,r4,6948
 d03efd4:	d0028a00 	call	d0028a0 <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 d03efd8:	e0bffc17 	ldw	r2,-16(fp)
 d03efdc:	10800617 	ldw	r2,24(r2)
 d03efe0:	10c00a17 	ldw	r3,40(r2)
 d03efe4:	e0bffc17 	ldw	r2,-16(fp)
 d03efe8:	10800717 	ldw	r2,28(r2)
 d03efec:	18802a1e 	bne	r3,r2,d03f098 <ip_write_internal+0x5a0>
 d03eff0:	e0bffc17 	ldw	r2,-16(fp)
 d03eff4:	10800717 	ldw	r2,28(r2)
 d03eff8:	10803fcc 	andi	r2,r2,255
 d03effc:	10801fe0 	cmpeqi	r2,r2,127
 d03f000:	1000251e 	bne	r2,zero,d03f098 <ip_write_internal+0x5a0>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 d03f004:	e0bffc17 	ldw	r2,-16(fp)
 d03f008:	10800617 	ldw	r2,24(r2)
 d03f00c:	10802a17 	ldw	r2,168(r2)
 d03f010:	1080020c 	andi	r2,r2,8
 d03f014:	1004c03a 	cmpne	r2,r2,zero
 d03f018:	10000a1e 	bne	r2,zero,d03f044 <ip_write_internal+0x54c>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 d03f01c:	d025a500 	call	d025a50 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03f020:	01000084 	movi	r4,2
 d03f024:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03f028:	e13ffc17 	ldw	r4,-16(fp)
 d03f02c:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03f030:	01000084 	movi	r4,2
 d03f034:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 d03f038:	00bffd44 	movi	r2,-11
 d03f03c:	e0bffd15 	stw	r2,-12(fp)
 d03f040:	00008706 	br	d03f260 <ip_write_internal+0x768>
      }
      p->type = IPTP;
 d03f044:	e0fffc17 	ldw	r3,-16(fp)
 d03f048:	00800204 	movi	r2,8
 d03f04c:	1880080d 	sth	r2,32(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 d03f050:	0009883a 	mov	r4,zero
 d03f054:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 d03f058:	01000044 	movi	r4,1
 d03f05c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 d03f060:	e17ffc17 	ldw	r5,-16(fp)
 d03f064:	010341b4 	movhi	r4,3334
 d03f068:	21025504 	addi	r4,r4,2388
 d03f06c:	d0253e00 	call	d0253e0 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 d03f070:	01000044 	movi	r4,1
 d03f074:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 d03f078:	0009883a 	mov	r4,zero
 d03f07c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 d03f080:	00834174 	movhi	r2,3333
 d03f084:	109b4804 	addi	r2,r2,27936
 d03f088:	11000017 	ldw	r4,0(r2)
 d03f08c:	d0139400 	call	d013940 <OSSemPost>

      return SUCCESS;
 d03f090:	e03ffd15 	stw	zero,-12(fp)
 d03f094:	00007206 	br	d03f260 <ip_write_internal+0x768>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 d03f098:	e0bffc17 	ldw	r2,-16(fp)
 d03f09c:	10800a17 	ldw	r2,40(r2)
 d03f0a0:	1080040c 	andi	r2,r2,16
 d03f0a4:	1005003a 	cmpeq	r2,r2,zero
 d03f0a8:	e0bff605 	stb	r2,-40(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 d03f0ac:	d02524c0 	call	d02524c <pk_get_max_intrsafe_buf_len>
 d03f0b0:	e0bff315 	stw	r2,-52(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 d03f0b4:	e0bff603 	ldbu	r2,-40(fp)
 d03f0b8:	1004c03a 	cmpne	r2,r2,zero
 d03f0bc:	10000e1e 	bne	r2,zero,d03f0f8 <ip_write_internal+0x600>
       limit = MIN(maxbuflen,p->net->n_mtu);
 d03f0c0:	e0bffc17 	ldw	r2,-16(fp)
 d03f0c4:	10800617 	ldw	r2,24(r2)
 d03f0c8:	10800917 	ldw	r2,36(r2)
 d03f0cc:	e0fff317 	ldw	r3,-52(fp)
 d03f0d0:	e0ffff15 	stw	r3,-4(fp)
 d03f0d4:	e0bffe15 	stw	r2,-8(fp)
 d03f0d8:	e0bfff17 	ldw	r2,-4(fp)
 d03f0dc:	e0fffe17 	ldw	r3,-8(fp)
 d03f0e0:	10c0022e 	bgeu	r2,r3,d03f0ec <ip_write_internal+0x5f4>
 d03f0e4:	e0bfff17 	ldw	r2,-4(fp)
 d03f0e8:	e0bffe15 	stw	r2,-8(fp)
 d03f0ec:	e0fffe17 	ldw	r3,-8(fp)
 d03f0f0:	e0fff515 	stw	r3,-44(fp)
 d03f0f4:	00000406 	br	d03f108 <ip_write_internal+0x610>
   else
       limit = p->net->n_mtu;
 d03f0f8:	e0bffc17 	ldw	r2,-16(fp)
 d03f0fc:	10800617 	ldw	r2,24(r2)
 d03f100:	10800917 	ldw	r2,36(r2)
 d03f104:	e0bff515 	stw	r2,-44(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 d03f108:	e0bffc17 	ldw	r2,-16(fp)
 d03f10c:	10c00417 	ldw	r3,16(r2)
 d03f110:	e0bffc17 	ldw	r2,-16(fp)
 d03f114:	10800617 	ldw	r2,24(r2)
 d03f118:	10800817 	ldw	r2,32(r2)
 d03f11c:	1887883a 	add	r3,r3,r2
 d03f120:	e0bff517 	ldw	r2,-44(fp)
 d03f124:	10c0072e 	bgeu	r2,r3,d03f144 <ip_write_internal+0x64c>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 d03f128:	e17ffb17 	ldw	r5,-20(fp)
 d03f12c:	e13ffc17 	ldw	r4,-16(fp)
 d03f130:	d03fdd00 	call	d03fdd0 <ip_fragment>
 d03f134:	e0bff215 	stw	r2,-56(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 d03f138:	e0bff217 	ldw	r2,-56(fp)
 d03f13c:	e0bffd15 	stw	r2,-12(fp)
 d03f140:	00004706 	br	d03f260 <ip_write_internal+0x768>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 d03f144:	e0bff603 	ldbu	r2,-40(fp)
 d03f148:	1004c03a 	cmpne	r2,r2,zero
 d03f14c:	1000401e 	bne	r2,zero,d03f250 <ip_write_internal+0x758>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03f150:	01000084 	movi	r4,2
 d03f154:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 d03f158:	e0bffc17 	ldw	r2,-16(fp)
 d03f15c:	10c00417 	ldw	r3,16(r2)
 d03f160:	e0bffc17 	ldw	r2,-16(fp)
 d03f164:	10800617 	ldw	r2,24(r2)
 d03f168:	10800817 	ldw	r2,32(r2)
 d03f16c:	1889883a 	add	r4,r3,r2
 d03f170:	d024e0c0 	call	d024e0c <pk_alloc>
 d03f174:	e0bff415 	stw	r2,-48(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03f178:	01000084 	movi	r4,2
 d03f17c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 d03f180:	e0bff417 	ldw	r2,-48(fp)
 d03f184:	1004c03a 	cmpne	r2,r2,zero
 d03f188:	1000091e 	bne	r2,zero,d03f1b0 <ip_write_internal+0x6b8>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03f18c:	01000084 	movi	r4,2
 d03f190:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(p);
 d03f194:	e13ffc17 	ldw	r4,-16(fp)
 d03f198:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03f19c:	01000084 	movi	r4,2
 d03f1a0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 d03f1a4:	00fffac4 	movi	r3,-21
 d03f1a8:	e0fffd15 	stw	r3,-12(fp)
 d03f1ac:	00002c06 	br	d03f260 <ip_write_internal+0x768>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 d03f1b0:	e0bff417 	ldw	r2,-48(fp)
 d03f1b4:	10c00117 	ldw	r3,4(r2)
 d03f1b8:	e0bffc17 	ldw	r2,-16(fp)
 d03f1bc:	10800617 	ldw	r2,24(r2)
 d03f1c0:	10800817 	ldw	r2,32(r2)
 d03f1c4:	1887883a 	add	r3,r3,r2
 d03f1c8:	e0bff417 	ldw	r2,-48(fp)
 d03f1cc:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 d03f1d0:	e0bff417 	ldw	r2,-48(fp)
 d03f1d4:	10c00317 	ldw	r3,12(r2)
 d03f1d8:	e0bffc17 	ldw	r2,-16(fp)
 d03f1dc:	11400317 	ldw	r5,12(r2)
 d03f1e0:	e0bffc17 	ldw	r2,-16(fp)
 d03f1e4:	10800417 	ldw	r2,16(r2)
 d03f1e8:	1809883a 	mov	r4,r3
 d03f1ec:	100d883a 	mov	r6,r2
 d03f1f0:	d0026080 	call	d002608 <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 d03f1f4:	e0bffc17 	ldw	r2,-16(fp)
 d03f1f8:	10c00417 	ldw	r3,16(r2)
 d03f1fc:	e0bff417 	ldw	r2,-48(fp)
 d03f200:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 d03f204:	e0bffc17 	ldw	r2,-16(fp)
 d03f208:	10c00617 	ldw	r3,24(r2)
 d03f20c:	e0bff417 	ldw	r2,-48(fp)
 d03f210:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 d03f214:	e0bffc17 	ldw	r2,-16(fp)
 d03f218:	10c00717 	ldw	r3,28(r2)
 d03f21c:	e0bff417 	ldw	r2,-48(fp)
 d03f220:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03f224:	01000084 	movi	r4,2
 d03f228:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(p);
 d03f22c:	e13ffc17 	ldw	r4,-16(fp)
 d03f230:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03f234:	01000084 	movi	r4,2
 d03f238:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 d03f23c:	e17ffb17 	ldw	r5,-20(fp)
 d03f240:	e13ff417 	ldw	r4,-48(fp)
 d03f244:	d01e2bc0 	call	d01e2bc <ip2mac>
 d03f248:	e0bffd15 	stw	r2,-12(fp)
 d03f24c:	00000406 	br	d03f260 <ip_write_internal+0x768>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 d03f250:	e17ffb17 	ldw	r5,-20(fp)
 d03f254:	e13ffc17 	ldw	r4,-16(fp)
 d03f258:	d01e2bc0 	call	d01e2bc <ip2mac>
 d03f25c:	e0bffd15 	stw	r2,-12(fp)
 d03f260:	e0bffd17 	ldw	r2,-12(fp)
      }
   }
}
 d03f264:	e037883a 	mov	sp,fp
 d03f268:	dfc00117 	ldw	ra,4(sp)
 d03f26c:	df000017 	ldw	fp,0(sp)
 d03f270:	dec00204 	addi	sp,sp,8
 d03f274:	f800283a 	ret

0d03f278 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 d03f278:	defff904 	addi	sp,sp,-28
 d03f27c:	dfc00615 	stw	ra,24(sp)
 d03f280:	df000515 	stw	fp,20(sp)
 d03f284:	df000504 	addi	fp,sp,20
 d03f288:	e17fff15 	stw	r5,-4(fp)
 d03f28c:	e13ffe05 	stb	r4,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 d03f290:	008341b4 	movhi	r2,3334
 d03f294:	10856804 	addi	r2,r2,5536
 d03f298:	10800917 	ldw	r2,36(r2)
 d03f29c:	10c00044 	addi	r3,r2,1
 d03f2a0:	008341b4 	movhi	r2,3334
 d03f2a4:	10856804 	addi	r2,r2,5536
 d03f2a8:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 d03f2ac:	e0bfff17 	ldw	r2,-4(fp)
 d03f2b0:	10800317 	ldw	r2,12(r2)
 d03f2b4:	10fffb04 	addi	r3,r2,-20
 d03f2b8:	e0bfff17 	ldw	r2,-4(fp)
 d03f2bc:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 d03f2c0:	e0bfff17 	ldw	r2,-4(fp)
 d03f2c4:	10800417 	ldw	r2,16(r2)
 d03f2c8:	10c00504 	addi	r3,r2,20
 d03f2cc:	e0bfff17 	ldw	r2,-4(fp)
 d03f2d0:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 d03f2d4:	e0bfff17 	ldw	r2,-4(fp)
 d03f2d8:	10800317 	ldw	r2,12(r2)
 d03f2dc:	e0bffd15 	stw	r2,-12(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 d03f2e0:	e0fffd17 	ldw	r3,-12(fp)
 d03f2e4:	00801144 	movi	r2,69
 d03f2e8:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 d03f2ec:	e0bffd17 	ldw	r2,-12(fp)
 d03f2f0:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 d03f2f4:	d0a05017 	ldw	r2,-32448(gp)
 d03f2f8:	10bfffcc 	andi	r2,r2,65535
 d03f2fc:	1004d23a 	srli	r2,r2,8
 d03f300:	10803fcc 	andi	r2,r2,255
 d03f304:	1009883a 	mov	r4,r2
 d03f308:	d0a05017 	ldw	r2,-32448(gp)
 d03f30c:	10bfffcc 	andi	r2,r2,65535
 d03f310:	1004923a 	slli	r2,r2,8
 d03f314:	1007883a 	mov	r3,r2
 d03f318:	00bfc004 	movi	r2,-256
 d03f31c:	1884703a 	and	r2,r3,r2
 d03f320:	2084b03a 	or	r2,r4,r2
 d03f324:	1007883a 	mov	r3,r2
 d03f328:	e0bffd17 	ldw	r2,-12(fp)
 d03f32c:	10c0010d 	sth	r3,4(r2)
   uid++;
 d03f330:	d0a05017 	ldw	r2,-32448(gp)
 d03f334:	10800044 	addi	r2,r2,1
 d03f338:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 d03f33c:	e0bfff17 	ldw	r2,-4(fp)
 d03f340:	10800417 	ldw	r2,16(r2)
 d03f344:	10bfffcc 	andi	r2,r2,65535
 d03f348:	1004d23a 	srli	r2,r2,8
 d03f34c:	10803fcc 	andi	r2,r2,255
 d03f350:	1009883a 	mov	r4,r2
 d03f354:	e0bfff17 	ldw	r2,-4(fp)
 d03f358:	10800417 	ldw	r2,16(r2)
 d03f35c:	10bfffcc 	andi	r2,r2,65535
 d03f360:	1004923a 	slli	r2,r2,8
 d03f364:	1007883a 	mov	r3,r2
 d03f368:	00bfc004 	movi	r2,-256
 d03f36c:	1884703a 	and	r2,r3,r2
 d03f370:	2084b03a 	or	r2,r4,r2
 d03f374:	1007883a 	mov	r3,r2
 d03f378:	e0bffd17 	ldw	r2,-12(fp)
 d03f37c:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 d03f380:	e0fffd17 	ldw	r3,-12(fp)
 d03f384:	e0bffe03 	ldbu	r2,-8(fp)
 d03f388:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 d03f38c:	e0bffd17 	ldw	r2,-12(fp)
 d03f390:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 d03f394:	00801004 	movi	r2,64
 d03f398:	e0bffc05 	stb	r2,-16(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 d03f39c:	e0bfff17 	ldw	r2,-4(fp)
 d03f3a0:	10800717 	ldw	r2,28(r2)
 d03f3a4:	1004d63a 	srli	r2,r2,24
 d03f3a8:	10c03fcc 	andi	r3,r2,255
 d03f3ac:	e0bfff17 	ldw	r2,-4(fp)
 d03f3b0:	10800717 	ldw	r2,28(r2)
 d03f3b4:	1004d23a 	srli	r2,r2,8
 d03f3b8:	10bfc00c 	andi	r2,r2,65280
 d03f3bc:	1886b03a 	or	r3,r3,r2
 d03f3c0:	e0bfff17 	ldw	r2,-4(fp)
 d03f3c4:	10800717 	ldw	r2,28(r2)
 d03f3c8:	10bfc00c 	andi	r2,r2,65280
 d03f3cc:	1004923a 	slli	r2,r2,8
 d03f3d0:	1886b03a 	or	r3,r3,r2
 d03f3d4:	e0bfff17 	ldw	r2,-4(fp)
 d03f3d8:	10800717 	ldw	r2,28(r2)
 d03f3dc:	10803fcc 	andi	r2,r2,255
 d03f3e0:	1004963a 	slli	r2,r2,24
 d03f3e4:	1884b03a 	or	r2,r3,r2
 d03f3e8:	10fc002c 	andhi	r3,r2,61440
 d03f3ec:	00b80034 	movhi	r2,57344
 d03f3f0:	1880081e 	bne	r3,r2,d03f414 <ip_write+0x19c>
 d03f3f4:	e0bfff17 	ldw	r2,-4(fp)
 d03f3f8:	10800b17 	ldw	r2,44(r2)
 d03f3fc:	1005003a 	cmpeq	r2,r2,zero
 d03f400:	1000041e 	bne	r2,zero,d03f414 <ip_write+0x19c>
      ttl = p->imo->imo_multicast_ttl;
 d03f404:	e0bfff17 	ldw	r2,-4(fp)
 d03f408:	10800b17 	ldw	r2,44(r2)
 d03f40c:	10800103 	ldbu	r2,4(r2)
 d03f410:	e0bffc05 	stb	r2,-16(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 d03f414:	e0bfff17 	ldw	r2,-4(fp)
 d03f418:	10800c17 	ldw	r2,48(r2)
 d03f41c:	e0bffb15 	stw	r2,-20(fp)
 d03f420:	e0bffb17 	ldw	r2,-20(fp)
 d03f424:	1005003a 	cmpeq	r2,r2,zero
 d03f428:	1000121e 	bne	r2,zero,d03f474 <ip_write+0x1fc>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 d03f42c:	e0bffb17 	ldw	r2,-20(fp)
 d03f430:	10800043 	ldbu	r2,1(r2)
 d03f434:	10803fcc 	andi	r2,r2,255
 d03f438:	1005003a 	cmpeq	r2,r2,zero
 d03f43c:	1000051e 	bne	r2,zero,d03f454 <ip_write+0x1dc>
         pip->ip_time = sopts->ip_ttl;
 d03f440:	e0bffb17 	ldw	r2,-20(fp)
 d03f444:	10c00043 	ldbu	r3,1(r2)
 d03f448:	e0bffd17 	ldw	r2,-12(fp)
 d03f44c:	10c00205 	stb	r3,8(r2)
 d03f450:	00000306 	br	d03f460 <ip_write+0x1e8>
	  else
         pip->ip_time = ttl;
 d03f454:	e0fffd17 	ldw	r3,-12(fp)
 d03f458:	e0bffc03 	ldbu	r2,-16(fp)
 d03f45c:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 d03f460:	e0bffb17 	ldw	r2,-20(fp)
 d03f464:	10c00003 	ldbu	r3,0(r2)
 d03f468:	e0bffd17 	ldw	r2,-12(fp)
 d03f46c:	10c00045 	stb	r3,1(r2)
 d03f470:	00000506 	br	d03f488 <ip_write+0x210>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 d03f474:	e0bffd17 	ldw	r2,-12(fp)
 d03f478:	e0fffc03 	ldbu	r3,-16(fp)
 d03f47c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 d03f480:	e0bffd17 	ldw	r2,-12(fp)
 d03f484:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 d03f488:	e13ffd17 	ldw	r4,-12(fp)
 d03f48c:	01400284 	movi	r5,10
 d03f490:	d0205440 	call	d020544 <cksum>
 d03f494:	0084303a 	nor	r2,zero,r2
 d03f498:	1007883a 	mov	r3,r2
 d03f49c:	e0bffd17 	ldw	r2,-12(fp)
 d03f4a0:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 d03f4a4:	e13fff17 	ldw	r4,-4(fp)
 d03f4a8:	d03eaf80 	call	d03eaf8 <ip_write_internal>
}
 d03f4ac:	e037883a 	mov	sp,fp
 d03f4b0:	dfc00117 	ldw	ra,4(sp)
 d03f4b4:	df000017 	ldw	fp,0(sp)
 d03f4b8:	dec00204 	addi	sp,sp,8
 d03f4bc:	f800283a 	ret

0d03f4c0 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 d03f4c0:	defff504 	addi	sp,sp,-44
 d03f4c4:	dfc00a15 	stw	ra,40(sp)
 d03f4c8:	df000915 	stw	fp,36(sp)
 d03f4cc:	df000904 	addi	fp,sp,36
 d03f4d0:	e17ffe15 	stw	r5,-8(fp)
 d03f4d4:	e1bfff15 	stw	r6,-4(fp)
 d03f4d8:	e13ffd05 	stb	r4,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 d03f4dc:	00800504 	movi	r2,20
 d03f4e0:	e0bff905 	stb	r2,-28(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 d03f4e4:	008341b4 	movhi	r2,3334
 d03f4e8:	10856804 	addi	r2,r2,5536
 d03f4ec:	10800917 	ldw	r2,36(r2)
 d03f4f0:	10c00044 	addi	r3,r2,1
 d03f4f4:	008341b4 	movhi	r2,3334
 d03f4f8:	10856804 	addi	r2,r2,5536
 d03f4fc:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 d03f500:	e0bfff17 	ldw	r2,-4(fp)
 d03f504:	e0bff815 	stw	r2,-32(fp)
 d03f508:	00000c06 	br	d03f53c <ip_write2+0x7c>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 d03f50c:	e0bff817 	ldw	r2,-32(fp)
 d03f510:	10800003 	ldbu	r2,0(r2)
 d03f514:	10803fcc 	andi	r2,r2,255
 d03f518:	10800520 	cmpeqi	r2,r2,20
 d03f51c:	1000011e 	bne	r2,zero,d03f524 <ip_write2+0x64>
 d03f520:	00000306 	br	d03f530 <ip_write2+0x70>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 d03f524:	e0bff903 	ldbu	r2,-28(fp)
 d03f528:	10800104 	addi	r2,r2,4
 d03f52c:	e0bff905 	stb	r2,-28(fp)
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 d03f530:	e0bff817 	ldw	r2,-32(fp)
 d03f534:	10800044 	addi	r2,r2,1
 d03f538:	e0bff815 	stw	r2,-32(fp)
 d03f53c:	e0bff817 	ldw	r2,-32(fp)
 d03f540:	10800003 	ldbu	r2,0(r2)
 d03f544:	10803fcc 	andi	r2,r2,255
 d03f548:	1004c03a 	cmpne	r2,r2,zero
 d03f54c:	103fef1e 	bne	r2,zero,d03f50c <ip_write2+0x4c>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 d03f550:	e0bff903 	ldbu	r2,-28(fp)
 d03f554:	108000cc 	andi	r2,r2,3
 d03f558:	1005003a 	cmpeq	r2,r2,zero
 d03f55c:	1000071e 	bne	r2,zero,d03f57c <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 d03f560:	e0bff903 	ldbu	r2,-28(fp)
 d03f564:	108000cc 	andi	r2,r2,3
 d03f568:	1007883a 	mov	r3,r2
 d03f56c:	00800104 	movi	r2,4
 d03f570:	10c5c83a 	sub	r2,r2,r3
 d03f574:	e0bff745 	stb	r2,-35(fp)
 d03f578:	00000106 	br	d03f580 <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 d03f57c:	e03ff745 	stb	zero,-35(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 d03f580:	e0bffe17 	ldw	r2,-8(fp)
 d03f584:	11000317 	ldw	r4,12(r2)
 d03f588:	e0fff903 	ldbu	r3,-28(fp)
 d03f58c:	e0bff743 	ldbu	r2,-35(fp)
 d03f590:	1885883a 	add	r2,r3,r2
 d03f594:	2087c83a 	sub	r3,r4,r2
 d03f598:	e0bffe17 	ldw	r2,-8(fp)
 d03f59c:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 d03f5a0:	e0bffe17 	ldw	r2,-8(fp)
 d03f5a4:	11000417 	ldw	r4,16(r2)
 d03f5a8:	e0fff903 	ldbu	r3,-28(fp)
 d03f5ac:	e0bff743 	ldbu	r2,-35(fp)
 d03f5b0:	1885883a 	add	r2,r3,r2
 d03f5b4:	2087883a 	add	r3,r4,r2
 d03f5b8:	e0bffe17 	ldw	r2,-8(fp)
 d03f5bc:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 d03f5c0:	e0bffe17 	ldw	r2,-8(fp)
 d03f5c4:	10800317 	ldw	r2,12(r2)
 d03f5c8:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 d03f5cc:	e0fff903 	ldbu	r3,-28(fp)
 d03f5d0:	e0bff743 	ldbu	r2,-35(fp)
 d03f5d4:	1885883a 	add	r2,r3,r2
 d03f5d8:	1005d0ba 	srai	r2,r2,2
 d03f5dc:	10801014 	ori	r2,r2,64
 d03f5e0:	1007883a 	mov	r3,r2
 d03f5e4:	e0bffc17 	ldw	r2,-16(fp)
 d03f5e8:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 d03f5ec:	e0bffc17 	ldw	r2,-16(fp)
 d03f5f0:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 d03f5f4:	d0a05017 	ldw	r2,-32448(gp)
 d03f5f8:	10bfffcc 	andi	r2,r2,65535
 d03f5fc:	1004d23a 	srli	r2,r2,8
 d03f600:	10803fcc 	andi	r2,r2,255
 d03f604:	1009883a 	mov	r4,r2
 d03f608:	d0a05017 	ldw	r2,-32448(gp)
 d03f60c:	10bfffcc 	andi	r2,r2,65535
 d03f610:	1004923a 	slli	r2,r2,8
 d03f614:	1007883a 	mov	r3,r2
 d03f618:	00bfc004 	movi	r2,-256
 d03f61c:	1884703a 	and	r2,r3,r2
 d03f620:	2084b03a 	or	r2,r4,r2
 d03f624:	1007883a 	mov	r3,r2
 d03f628:	e0bffc17 	ldw	r2,-16(fp)
 d03f62c:	10c0010d 	sth	r3,4(r2)
   uid++;
 d03f630:	d0a05017 	ldw	r2,-32448(gp)
 d03f634:	10800044 	addi	r2,r2,1
 d03f638:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 d03f63c:	e0bffe17 	ldw	r2,-8(fp)
 d03f640:	10800417 	ldw	r2,16(r2)
 d03f644:	10bfffcc 	andi	r2,r2,65535
 d03f648:	1004d23a 	srli	r2,r2,8
 d03f64c:	10803fcc 	andi	r2,r2,255
 d03f650:	1009883a 	mov	r4,r2
 d03f654:	e0bffe17 	ldw	r2,-8(fp)
 d03f658:	10800417 	ldw	r2,16(r2)
 d03f65c:	10bfffcc 	andi	r2,r2,65535
 d03f660:	1004923a 	slli	r2,r2,8
 d03f664:	1007883a 	mov	r3,r2
 d03f668:	00bfc004 	movi	r2,-256
 d03f66c:	1884703a 	and	r2,r3,r2
 d03f670:	2084b03a 	or	r2,r4,r2
 d03f674:	1007883a 	mov	r3,r2
 d03f678:	e0bffc17 	ldw	r2,-16(fp)
 d03f67c:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 d03f680:	e0fffc17 	ldw	r3,-16(fp)
 d03f684:	e0bffd03 	ldbu	r2,-12(fp)
 d03f688:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 d03f68c:	e0bffc17 	ldw	r2,-16(fp)
 d03f690:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 d03f694:	00801004 	movi	r2,64
 d03f698:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 d03f69c:	e0bffe17 	ldw	r2,-8(fp)
 d03f6a0:	10800717 	ldw	r2,28(r2)
 d03f6a4:	1004d63a 	srli	r2,r2,24
 d03f6a8:	10c03fcc 	andi	r3,r2,255
 d03f6ac:	e0bffe17 	ldw	r2,-8(fp)
 d03f6b0:	10800717 	ldw	r2,28(r2)
 d03f6b4:	1004d23a 	srli	r2,r2,8
 d03f6b8:	10bfc00c 	andi	r2,r2,65280
 d03f6bc:	1886b03a 	or	r3,r3,r2
 d03f6c0:	e0bffe17 	ldw	r2,-8(fp)
 d03f6c4:	10800717 	ldw	r2,28(r2)
 d03f6c8:	10bfc00c 	andi	r2,r2,65280
 d03f6cc:	1004923a 	slli	r2,r2,8
 d03f6d0:	1886b03a 	or	r3,r3,r2
 d03f6d4:	e0bffe17 	ldw	r2,-8(fp)
 d03f6d8:	10800717 	ldw	r2,28(r2)
 d03f6dc:	10803fcc 	andi	r2,r2,255
 d03f6e0:	1004963a 	slli	r2,r2,24
 d03f6e4:	1884b03a 	or	r2,r3,r2
 d03f6e8:	10fc002c 	andhi	r3,r2,61440
 d03f6ec:	00b80034 	movhi	r2,57344
 d03f6f0:	1880081e 	bne	r3,r2,d03f714 <ip_write2+0x254>
 d03f6f4:	e0bffe17 	ldw	r2,-8(fp)
 d03f6f8:	10800b17 	ldw	r2,44(r2)
 d03f6fc:	1005003a 	cmpeq	r2,r2,zero
 d03f700:	1000041e 	bne	r2,zero,d03f714 <ip_write2+0x254>
      ttl = p->imo->imo_multicast_ttl;
 d03f704:	e0bffe17 	ldw	r2,-8(fp)
 d03f708:	10800b17 	ldw	r2,44(r2)
 d03f70c:	10800103 	ldbu	r2,4(r2)
 d03f710:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 d03f714:	e0bffe17 	ldw	r2,-8(fp)
 d03f718:	10800c17 	ldw	r2,48(r2)
 d03f71c:	e0bffa15 	stw	r2,-24(fp)
 d03f720:	e0bffa17 	ldw	r2,-24(fp)
 d03f724:	1005003a 	cmpeq	r2,r2,zero
 d03f728:	1000121e 	bne	r2,zero,d03f774 <ip_write2+0x2b4>
   {
      if (sopts->ip_ttl)
 d03f72c:	e0bffa17 	ldw	r2,-24(fp)
 d03f730:	10800043 	ldbu	r2,1(r2)
 d03f734:	10803fcc 	andi	r2,r2,255
 d03f738:	1005003a 	cmpeq	r2,r2,zero
 d03f73c:	1000051e 	bne	r2,zero,d03f754 <ip_write2+0x294>
         pip->ip_time = sopts->ip_ttl;
 d03f740:	e0bffa17 	ldw	r2,-24(fp)
 d03f744:	10c00043 	ldbu	r3,1(r2)
 d03f748:	e0bffc17 	ldw	r2,-16(fp)
 d03f74c:	10c00205 	stb	r3,8(r2)
 d03f750:	00000306 	br	d03f760 <ip_write2+0x2a0>
      else
         pip->ip_time = ttl;
 d03f754:	e0fffc17 	ldw	r3,-16(fp)
 d03f758:	e0bffb03 	ldbu	r2,-20(fp)
 d03f75c:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 d03f760:	e0bffa17 	ldw	r2,-24(fp)
 d03f764:	10c00003 	ldbu	r3,0(r2)
 d03f768:	e0bffc17 	ldw	r2,-16(fp)
 d03f76c:	10c00045 	stb	r3,1(r2)
 d03f770:	00000506 	br	d03f788 <ip_write2+0x2c8>
   }
   else
   {
      pip->ip_time = ttl;
 d03f774:	e0bffc17 	ldw	r2,-16(fp)
 d03f778:	e0fffb03 	ldbu	r3,-20(fp)
 d03f77c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 d03f780:	e0bffc17 	ldw	r2,-16(fp)
 d03f784:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 d03f788:	e0bffe17 	ldw	r2,-8(fp)
 d03f78c:	10800317 	ldw	r2,12(r2)
 d03f790:	10800504 	addi	r2,r2,20
 d03f794:	e0bff815 	stw	r2,-32(fp)
 d03f798:	00000f06 	br	d03f7d8 <ip_write2+0x318>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 d03f79c:	e0bfff17 	ldw	r2,-4(fp)
 d03f7a0:	10800003 	ldbu	r2,0(r2)
 d03f7a4:	10803fcc 	andi	r2,r2,255
 d03f7a8:	10800520 	cmpeqi	r2,r2,20
 d03f7ac:	1000011e 	bne	r2,zero,d03f7b4 <ip_write2+0x2f4>
 d03f7b0:	00000606 	br	d03f7cc <ip_write2+0x30c>
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 d03f7b4:	e0fff817 	ldw	r3,-32(fp)
 d03f7b8:	00812504 	movi	r2,1172
 d03f7bc:	18800015 	stw	r2,0(r3)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 d03f7c0:	e0bff817 	ldw	r2,-32(fp)
 d03f7c4:	10800104 	addi	r2,r2,4
 d03f7c8:	e0bff815 	stw	r2,-32(fp)
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 d03f7cc:	e0bfff17 	ldw	r2,-4(fp)
 d03f7d0:	10800044 	addi	r2,r2,1
 d03f7d4:	e0bfff15 	stw	r2,-4(fp)
 d03f7d8:	e0bfff17 	ldw	r2,-4(fp)
 d03f7dc:	10800003 	ldbu	r2,0(r2)
 d03f7e0:	10803fcc 	andi	r2,r2,255
 d03f7e4:	1004c03a 	cmpne	r2,r2,zero
 d03f7e8:	103fec1e 	bne	r2,zero,d03f79c <ip_write2+0x2dc>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 d03f7ec:	e03ff705 	stb	zero,-36(fp)
 d03f7f0:	00000806 	br	d03f814 <ip_write2+0x354>
 d03f7f4:	e0bff703 	ldbu	r2,-36(fp)
 d03f7f8:	1007883a 	mov	r3,r2
 d03f7fc:	e0bff817 	ldw	r2,-32(fp)
 d03f800:	1885883a 	add	r2,r3,r2
 d03f804:	10000005 	stb	zero,0(r2)
 d03f808:	e0bff703 	ldbu	r2,-36(fp)
 d03f80c:	10800044 	addi	r2,r2,1
 d03f810:	e0bff705 	stb	r2,-36(fp)
 d03f814:	e0fff703 	ldbu	r3,-36(fp)
 d03f818:	e0bff743 	ldbu	r2,-35(fp)
 d03f81c:	18bff536 	bltu	r3,r2,d03f7f4 <ip_write2+0x334>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 d03f820:	e0fff903 	ldbu	r3,-28(fp)
 d03f824:	e0bff743 	ldbu	r2,-35(fp)
 d03f828:	1887883a 	add	r3,r3,r2
 d03f82c:	1804d7fa 	srli	r2,r3,31
 d03f830:	10c5883a 	add	r2,r2,r3
 d03f834:	1005d07a 	srai	r2,r2,1
 d03f838:	100b883a 	mov	r5,r2
 d03f83c:	e13ffc17 	ldw	r4,-16(fp)
 d03f840:	d0205440 	call	d020544 <cksum>
 d03f844:	0084303a 	nor	r2,zero,r2
 d03f848:	1007883a 	mov	r3,r2
 d03f84c:	e0bffc17 	ldw	r2,-16(fp)
 d03f850:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 d03f854:	e13ffe17 	ldw	r4,-8(fp)
 d03f858:	d03eaf80 	call	d03eaf8 <ip_write_internal>
}
 d03f85c:	e037883a 	mov	sp,fp
 d03f860:	dfc00117 	ldw	ra,4(sp)
 d03f864:	df000017 	ldw	fp,0(sp)
 d03f868:	dec00204 	addi	sp,sp,8
 d03f86c:	f800283a 	ret

0d03f870 <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 d03f870:	defffc04 	addi	sp,sp,-16
 d03f874:	dfc00315 	stw	ra,12(sp)
 d03f878:	df000215 	stw	fp,8(sp)
 d03f87c:	df000204 	addi	fp,sp,8
 d03f880:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 d03f884:	008341b4 	movhi	r2,3334
 d03f888:	10856804 	addi	r2,r2,5536
 d03f88c:	10800917 	ldw	r2,36(r2)
 d03f890:	10c00044 	addi	r3,r2,1
 d03f894:	008341b4 	movhi	r2,3334
 d03f898:	10856804 	addi	r2,r2,5536
 d03f89c:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 d03f8a0:	e0bfff17 	ldw	r2,-4(fp)
 d03f8a4:	10800317 	ldw	r2,12(r2)
 d03f8a8:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 d03f8ac:	e0bffe17 	ldw	r2,-8(fp)
 d03f8b0:	1080010b 	ldhu	r2,4(r2)
 d03f8b4:	10bfffcc 	andi	r2,r2,65535
 d03f8b8:	1004c03a 	cmpne	r2,r2,zero
 d03f8bc:	1000121e 	bne	r2,zero,d03f908 <ip_raw_write+0x98>
   {
      pip->ip_id = htons((unshort)uid);
 d03f8c0:	d0a05017 	ldw	r2,-32448(gp)
 d03f8c4:	10bfffcc 	andi	r2,r2,65535
 d03f8c8:	1004d23a 	srli	r2,r2,8
 d03f8cc:	10803fcc 	andi	r2,r2,255
 d03f8d0:	1009883a 	mov	r4,r2
 d03f8d4:	d0a05017 	ldw	r2,-32448(gp)
 d03f8d8:	10bfffcc 	andi	r2,r2,65535
 d03f8dc:	1004923a 	slli	r2,r2,8
 d03f8e0:	1007883a 	mov	r3,r2
 d03f8e4:	00bfc004 	movi	r2,-256
 d03f8e8:	1884703a 	and	r2,r3,r2
 d03f8ec:	2084b03a 	or	r2,r4,r2
 d03f8f0:	1007883a 	mov	r3,r2
 d03f8f4:	e0bffe17 	ldw	r2,-8(fp)
 d03f8f8:	10c0010d 	sth	r3,4(r2)
      uid++;
 d03f8fc:	d0a05017 	ldw	r2,-32448(gp)
 d03f900:	10800044 	addi	r2,r2,1
 d03f904:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 d03f908:	e0bffe17 	ldw	r2,-8(fp)
 d03f90c:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 d03f910:	e13ffe17 	ldw	r4,-8(fp)
 d03f914:	01400284 	movi	r5,10
 d03f918:	d0205440 	call	d020544 <cksum>
 d03f91c:	0084303a 	nor	r2,zero,r2
 d03f920:	1007883a 	mov	r3,r2
 d03f924:	e0bffe17 	ldw	r2,-8(fp)
 d03f928:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 d03f92c:	e13fff17 	ldw	r4,-4(fp)
 d03f930:	d03eaf80 	call	d03eaf8 <ip_write_internal>
}
 d03f934:	e037883a 	mov	sp,fp
 d03f938:	dfc00117 	ldw	ra,4(sp)
 d03f93c:	df000017 	ldw	fp,0(sp)
 d03f940:	dec00204 	addi	sp,sp,8
 d03f944:	f800283a 	ret

0d03f948 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 d03f948:	deffed04 	addi	sp,sp,-76
 d03f94c:	dfc01215 	stw	ra,72(sp)
 d03f950:	df001115 	stw	fp,68(sp)
 d03f954:	df001104 	addi	fp,sp,68
 d03f958:	e13ffa15 	stw	r4,-24(fp)
 d03f95c:	e17ffb15 	stw	r5,-20(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 d03f960:	008341b4 	movhi	r2,3334
 d03f964:	10856804 	addi	r2,r2,5536
 d03f968:	10801017 	ldw	r2,64(r2)
 d03f96c:	10c00044 	addi	r3,r2,1
 d03f970:	008341b4 	movhi	r2,3334
 d03f974:	10856804 	addi	r2,r2,5536
 d03f978:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 d03f97c:	e0bffa17 	ldw	r2,-24(fp)
 d03f980:	10800317 	ldw	r2,12(r2)
 d03f984:	e0bff115 	stw	r2,-60(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 d03f988:	e0bff117 	ldw	r2,-60(fp)
 d03f98c:	10800003 	ldbu	r2,0(r2)
 d03f990:	10803fcc 	andi	r2,r2,255
 d03f994:	108003cc 	andi	r2,r2,15
 d03f998:	1085883a 	add	r2,r2,r2
 d03f99c:	1085883a 	add	r2,r2,r2
 d03f9a0:	e0bff015 	stw	r2,-64(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 d03f9a4:	e0bffa17 	ldw	r2,-24(fp)
 d03f9a8:	10800417 	ldw	r2,16(r2)
 d03f9ac:	1007883a 	mov	r3,r2
 d03f9b0:	e0bff017 	ldw	r2,-64(fp)
 d03f9b4:	1885c83a 	sub	r2,r3,r2
 d03f9b8:	e0bff415 	stw	r2,-48(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 d03f9bc:	e0bffa17 	ldw	r2,-24(fp)
 d03f9c0:	10800617 	ldw	r2,24(r2)
 d03f9c4:	11000917 	ldw	r4,36(r2)
 d03f9c8:	e0bffa17 	ldw	r2,-24(fp)
 d03f9cc:	10800617 	ldw	r2,24(r2)
 d03f9d0:	10c00817 	ldw	r3,32(r2)
 d03f9d4:	e0bff017 	ldw	r2,-64(fp)
 d03f9d8:	1885883a 	add	r2,r3,r2
 d03f9dc:	2085c83a 	sub	r2,r4,r2
 d03f9e0:	10bffe04 	addi	r2,r2,-8
 d03f9e4:	e0bff815 	stw	r2,-32(fp)
   if (maxipsize < 64)  /* to small to use */
 d03f9e8:	e0bff817 	ldw	r2,-32(fp)
 d03f9ec:	10801028 	cmpgeui	r2,r2,64
 d03f9f0:	1000041e 	bne	r2,zero,d03fa04 <ip_fragment_lc+0xbc>
   {
      dtrap();    /* probably bad programming */
 d03f9f4:	d025a500 	call	d025a50 <dtrap>
      return ENP_LOGIC;
 d03f9f8:	00bffd44 	movi	r2,-11
 d03f9fc:	e0bffe15 	stw	r2,-8(fp)
 d03fa00:	0000ed06 	br	d03fdb8 <ip_fragment_lc+0x470>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 d03fa04:	e0bffa17 	ldw	r2,-24(fp)
 d03fa08:	11000417 	ldw	r4,16(r2)
 d03fa0c:	e17ff817 	ldw	r5,-32(fp)
 d03fa10:	d00c90c0 	call	d00c90c <__udivsi3>
 d03fa14:	10800044 	addi	r2,r2,1
 d03fa18:	e0bff715 	stw	r2,-36(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 d03fa1c:	e0bffa17 	ldw	r2,-24(fp)
 d03fa20:	10c00417 	ldw	r3,16(r2)
 d03fa24:	e0bff717 	ldw	r2,-36(fp)
 d03fa28:	1885883a 	add	r2,r3,r2
 d03fa2c:	113fffc4 	addi	r4,r2,-1
 d03fa30:	e17ff717 	ldw	r5,-36(fp)
 d03fa34:	d00c90c0 	call	d00c90c <__udivsi3>
 d03fa38:	10c001c4 	addi	r3,r2,7
 d03fa3c:	00bffe04 	movi	r2,-8
 d03fa40:	1884703a 	and	r2,r3,r2
 d03fa44:	e0bff915 	stw	r2,-28(fp)
   foffset = 0;
 d03fa48:	e03ff615 	stw	zero,-40(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 d03fa4c:	e0bff117 	ldw	r2,-60(fp)
 d03fa50:	1080018b 	ldhu	r2,6(r2)
 d03fa54:	10bfffcc 	andi	r2,r2,65535
 d03fa58:	1004d23a 	srli	r2,r2,8
 d03fa5c:	10803fcc 	andi	r2,r2,255
 d03fa60:	1009883a 	mov	r4,r2
 d03fa64:	e0bff117 	ldw	r2,-60(fp)
 d03fa68:	1080018b 	ldhu	r2,6(r2)
 d03fa6c:	10bfffcc 	andi	r2,r2,65535
 d03fa70:	1004923a 	slli	r2,r2,8
 d03fa74:	1007883a 	mov	r3,r2
 d03fa78:	00bfc004 	movi	r2,-256
 d03fa7c:	1884703a 	and	r2,r3,r2
 d03fa80:	2084b03a 	or	r2,r4,r2
 d03fa84:	e0bfef0d 	sth	r2,-68(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 d03fa88:	e0ffef0b 	ldhu	r3,-68(fp)
 d03fa8c:	00bffff4 	movhi	r2,65535
 d03fa90:	1087ffc4 	addi	r2,r2,8191
 d03fa94:	1884703a 	and	r2,r3,r2
 d03fa98:	1005003a 	cmpeq	r2,r2,zero
 d03fa9c:	1000081e 	bne	r2,zero,d03fac0 <ip_fragment_lc+0x178>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 d03faa0:	e0ffef0b 	ldhu	r3,-68(fp)
 d03faa4:	00bffff4 	movhi	r2,65535
 d03faa8:	1087ffc4 	addi	r2,r2,8191
 d03faac:	1884703a 	and	r2,r3,r2
 d03fab0:	e0bff615 	stw	r2,-40(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 d03fab4:	e0bff617 	ldw	r2,-40(fp)
 d03fab8:	100490fa 	slli	r2,r2,3
 d03fabc:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 d03fac0:	e0bffa17 	ldw	r2,-24(fp)
 d03fac4:	e0bff315 	stw	r2,-52(fp)
   e = 0;
 d03fac8:	e03ff215 	stw	zero,-56(fp)
   while (left > 1)  /* more data left to send? */
 d03facc:	0000b506 	br	d03fda4 <ip_fragment_lc+0x45c>
   {
      p = pkt2;  /* move next fragment up */
 d03fad0:	e0bff317 	ldw	r2,-52(fp)
 d03fad4:	e0bffa15 	stw	r2,-24(fp)
      pip = (struct ip *)(p->nb_prot);
 d03fad8:	e0bffa17 	ldw	r2,-24(fp)
 d03fadc:	10800317 	ldw	r2,12(r2)
 d03fae0:	e0bff115 	stw	r2,-60(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 d03fae4:	e0bff917 	ldw	r2,-28(fp)
 d03fae8:	e0fff417 	ldw	r3,-48(fp)
 d03faec:	e0ffff15 	stw	r3,-4(fp)
 d03faf0:	e0bffd15 	stw	r2,-12(fp)
 d03faf4:	e0bfff17 	ldw	r2,-4(fp)
 d03faf8:	e0fffd17 	ldw	r3,-12(fp)
 d03fafc:	10c0020e 	bge	r2,r3,d03fb08 <ip_fragment_lc+0x1c0>
 d03fb00:	e0bfff17 	ldw	r2,-4(fp)
 d03fb04:	e0bffd15 	stw	r2,-12(fp)
 d03fb08:	e0bff017 	ldw	r2,-64(fp)
 d03fb0c:	e0fffd17 	ldw	r3,-12(fp)
 d03fb10:	1885883a 	add	r2,r3,r2
 d03fb14:	1007883a 	mov	r3,r2
 d03fb18:	e0bffa17 	ldw	r2,-24(fp)
 d03fb1c:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 d03fb20:	e0fff417 	ldw	r3,-48(fp)
 d03fb24:	e0bff917 	ldw	r2,-28(fp)
 d03fb28:	1885c83a 	sub	r2,r3,r2
 d03fb2c:	e0bff415 	stw	r2,-48(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 d03fb30:	e0bffa17 	ldw	r2,-24(fp)
 d03fb34:	10800417 	ldw	r2,16(r2)
 d03fb38:	10bfffcc 	andi	r2,r2,65535
 d03fb3c:	1004d23a 	srli	r2,r2,8
 d03fb40:	10803fcc 	andi	r2,r2,255
 d03fb44:	1009883a 	mov	r4,r2
 d03fb48:	e0bffa17 	ldw	r2,-24(fp)
 d03fb4c:	10800417 	ldw	r2,16(r2)
 d03fb50:	10bfffcc 	andi	r2,r2,65535
 d03fb54:	1004923a 	slli	r2,r2,8
 d03fb58:	1007883a 	mov	r3,r2
 d03fb5c:	00bfc004 	movi	r2,-256
 d03fb60:	1884703a 	and	r2,r3,r2
 d03fb64:	2084b03a 	or	r2,r4,r2
 d03fb68:	1007883a 	mov	r3,r2
 d03fb6c:	e0bff117 	ldw	r2,-60(fp)
 d03fb70:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 d03fb74:	e0bff617 	ldw	r2,-40(fp)
 d03fb78:	1004d0fa 	srli	r2,r2,3
 d03fb7c:	e0bff50d 	sth	r2,-44(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 d03fb80:	e0bff417 	ldw	r2,-48(fp)
 d03fb84:	10800090 	cmplti	r2,r2,2
 d03fb88:	1000031e 	bne	r2,zero,d03fb98 <ip_fragment_lc+0x250>
 d03fb8c:	00880004 	movi	r2,8192
 d03fb90:	e0bffc0d 	sth	r2,-16(fp)
 d03fb94:	00000106 	br	d03fb9c <ip_fragment_lc+0x254>
 d03fb98:	e03ffc0d 	sth	zero,-16(fp)
 d03fb9c:	e0bff50b 	ldhu	r2,-44(fp)
 d03fba0:	e0fffc0b 	ldhu	r3,-16(fp)
 d03fba4:	1884b03a 	or	r2,r3,r2
 d03fba8:	e0bff50d 	sth	r2,-44(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 d03fbac:	e0bfef0b 	ldhu	r2,-68(fp)
 d03fbb0:	1088000c 	andi	r2,r2,8192
 d03fbb4:	1005003a 	cmpeq	r2,r2,zero
 d03fbb8:	1000031e 	bne	r2,zero,d03fbc8 <ip_fragment_lc+0x280>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 d03fbbc:	e0bff50b 	ldhu	r2,-44(fp)
 d03fbc0:	10880014 	ori	r2,r2,8192
 d03fbc4:	e0bff50d 	sth	r2,-44(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 d03fbc8:	e0bff50b 	ldhu	r2,-44(fp)
 d03fbcc:	1004d23a 	srli	r2,r2,8
 d03fbd0:	10803fcc 	andi	r2,r2,255
 d03fbd4:	1009883a 	mov	r4,r2
 d03fbd8:	e0bff50b 	ldhu	r2,-44(fp)
 d03fbdc:	1004923a 	slli	r2,r2,8
 d03fbe0:	1007883a 	mov	r3,r2
 d03fbe4:	00bfc004 	movi	r2,-256
 d03fbe8:	1884703a 	and	r2,r3,r2
 d03fbec:	2084b03a 	or	r2,r4,r2
 d03fbf0:	1007883a 	mov	r3,r2
 d03fbf4:	e0bff117 	ldw	r2,-60(fp)
 d03fbf8:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 d03fbfc:	e0bff417 	ldw	r2,-48(fp)
 d03fc00:	10800090 	cmplti	r2,r2,2
 d03fc04:	1000401e 	bne	r2,zero,d03fd08 <ip_fragment_lc+0x3c0>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03fc08:	01000084 	movi	r4,2
 d03fc0c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 d03fc10:	e0fff417 	ldw	r3,-48(fp)
 d03fc14:	e0bff017 	ldw	r2,-64(fp)
 d03fc18:	1887883a 	add	r3,r3,r2
 d03fc1c:	00834174 	movhi	r2,3333
 d03fc20:	109b1e04 	addi	r2,r2,27768
 d03fc24:	10800017 	ldw	r2,0(r2)
 d03fc28:	1885883a 	add	r2,r3,r2
 d03fc2c:	1009883a 	mov	r4,r2
 d03fc30:	d024e0c0 	call	d024e0c <pk_alloc>
 d03fc34:	e0bff315 	stw	r2,-52(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03fc38:	01000084 	movi	r4,2
 d03fc3c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 d03fc40:	e0bff317 	ldw	r2,-52(fp)
 d03fc44:	1004c03a 	cmpne	r2,r2,zero
 d03fc48:	1000111e 	bne	r2,zero,d03fc90 <ip_fragment_lc+0x348>
         {
            dtrap();
 d03fc4c:	d025a500 	call	d025a50 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03fc50:	01000084 	movi	r4,2
 d03fc54:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(p);
 d03fc58:	e13ffa17 	ldw	r4,-24(fp)
 d03fc5c:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03fc60:	01000084 	movi	r4,2
 d03fc64:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 d03fc68:	008341b4 	movhi	r2,3334
 d03fc6c:	10856804 	addi	r2,r2,5536
 d03fc70:	10801117 	ldw	r2,68(r2)
 d03fc74:	10c00044 	addi	r3,r2,1
 d03fc78:	008341b4 	movhi	r2,3334
 d03fc7c:	10856804 	addi	r2,r2,5536
 d03fc80:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 d03fc84:	00bffa84 	movi	r2,-22
 d03fc88:	e0bffe15 	stw	r2,-8(fp)
 d03fc8c:	00004a06 	br	d03fdb8 <ip_fragment_lc+0x470>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 d03fc90:	e0bffa17 	ldw	r2,-24(fp)
 d03fc94:	10c00617 	ldw	r3,24(r2)
 d03fc98:	e0bff317 	ldw	r2,-52(fp)
 d03fc9c:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 d03fca0:	e0bffa17 	ldw	r2,-24(fp)
 d03fca4:	10c00717 	ldw	r3,28(r2)
 d03fca8:	e0bff317 	ldw	r2,-52(fp)
 d03fcac:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 d03fcb0:	e0bff317 	ldw	r2,-52(fp)
 d03fcb4:	11000317 	ldw	r4,12(r2)
 d03fcb8:	e0bffa17 	ldw	r2,-24(fp)
 d03fcbc:	10800317 	ldw	r2,12(r2)
 d03fcc0:	e0fff017 	ldw	r3,-64(fp)
 d03fcc4:	100b883a 	mov	r5,r2
 d03fcc8:	180d883a 	mov	r6,r3
 d03fccc:	d0026080 	call	d002608 <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 d03fcd0:	e0bff317 	ldw	r2,-52(fp)
 d03fcd4:	10c00317 	ldw	r3,12(r2)
 d03fcd8:	e0bff017 	ldw	r2,-64(fp)
 d03fcdc:	1889883a 	add	r4,r3,r2
 d03fce0:	e0bffa17 	ldw	r2,-24(fp)
 d03fce4:	10c00317 	ldw	r3,12(r2)
 d03fce8:	e0bff017 	ldw	r2,-64(fp)
 d03fcec:	1887883a 	add	r3,r3,r2
 d03fcf0:	e0bff917 	ldw	r2,-28(fp)
 d03fcf4:	1885883a 	add	r2,r3,r2
 d03fcf8:	e0fff417 	ldw	r3,-48(fp)
 d03fcfc:	100b883a 	mov	r5,r2
 d03fd00:	180d883a 	mov	r6,r3
 d03fd04:	d0026080 	call	d002608 <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 d03fd08:	e0bff117 	ldw	r2,-60(fp)
 d03fd0c:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 d03fd10:	e13ff117 	ldw	r4,-60(fp)
 d03fd14:	01400284 	movi	r5,10
 d03fd18:	d0205440 	call	d020544 <cksum>
 d03fd1c:	0084303a 	nor	r2,zero,r2
 d03fd20:	1007883a 	mov	r3,r2
 d03fd24:	e0bff117 	ldw	r2,-60(fp)
 d03fd28:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 d03fd2c:	e13ffa17 	ldw	r4,-24(fp)
 d03fd30:	e17ffb17 	ldw	r5,-20(fp)
 d03fd34:	d01e2bc0 	call	d01e2bc <ip2mac>
 d03fd38:	e0bff215 	stw	r2,-56(fp)
      ip_mib.ipFragCreates++;
 d03fd3c:	008341b4 	movhi	r2,3334
 d03fd40:	10856804 	addi	r2,r2,5536
 d03fd44:	10801217 	ldw	r2,72(r2)
 d03fd48:	10c00044 	addi	r3,r2,1
 d03fd4c:	008341b4 	movhi	r2,3334
 d03fd50:	10856804 	addi	r2,r2,5536
 d03fd54:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 d03fd58:	e0bff217 	ldw	r2,-56(fp)
 d03fd5c:	1004403a 	cmpge	r2,r2,zero
 d03fd60:	10000c1e 	bne	r2,zero,d03fd94 <ip_fragment_lc+0x44c>
      {
         if (left > 1) 
 d03fd64:	e0bff417 	ldw	r2,-48(fp)
 d03fd68:	10800090 	cmplti	r2,r2,2
 d03fd6c:	1000061e 	bne	r2,zero,d03fd88 <ip_fragment_lc+0x440>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03fd70:	01000084 	movi	r4,2
 d03fd74:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 d03fd78:	e13ff317 	ldw	r4,-52(fp)
 d03fd7c:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03fd80:	01000084 	movi	r4,2
 d03fd84:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         }
         return e;
 d03fd88:	e0fff217 	ldw	r3,-56(fp)
 d03fd8c:	e0fffe15 	stw	r3,-8(fp)
 d03fd90:	00000906 	br	d03fdb8 <ip_fragment_lc+0x470>
      }
      foffset += fragsize;    /* offset for next fragment */
 d03fd94:	e0bff617 	ldw	r2,-40(fp)
 d03fd98:	e0fff917 	ldw	r3,-28(fp)
 d03fd9c:	10c5883a 	add	r2,r2,r3
 d03fda0:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 d03fda4:	e0bff417 	ldw	r2,-48(fp)
 d03fda8:	10800088 	cmpgei	r2,r2,2
 d03fdac:	103f481e 	bne	r2,zero,d03fad0 <ip_fragment_lc+0x188>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 d03fdb0:	e0bff217 	ldw	r2,-56(fp)
 d03fdb4:	e0bffe15 	stw	r2,-8(fp)
 d03fdb8:	e0bffe17 	ldw	r2,-8(fp)
}
 d03fdbc:	e037883a 	mov	sp,fp
 d03fdc0:	dfc00117 	ldw	ra,4(sp)
 d03fdc4:	df000017 	ldw	fp,0(sp)
 d03fdc8:	dec00204 	addi	sp,sp,8
 d03fdcc:	f800283a 	ret

0d03fdd0 <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 d03fdd0:	deffeb04 	addi	sp,sp,-84
 d03fdd4:	dfc01415 	stw	ra,80(sp)
 d03fdd8:	df001315 	stw	fp,76(sp)
 d03fddc:	dc401215 	stw	r17,72(sp)
 d03fde0:	dc001115 	stw	r16,68(sp)
 d03fde4:	df001104 	addi	fp,sp,68
 d03fde8:	e13ffa15 	stw	r4,-24(fp)
 d03fdec:	e17ffb15 	stw	r5,-20(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 d03fdf0:	e0bffa17 	ldw	r2,-24(fp)
 d03fdf4:	10800317 	ldw	r2,12(r2)
 d03fdf8:	e0bff815 	stw	r2,-32(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 d03fdfc:	e0bff817 	ldw	r2,-32(fp)
 d03fe00:	1080018b 	ldhu	r2,6(r2)
 d03fe04:	10bfffcc 	andi	r2,r2,65535
 d03fe08:	1004d23a 	srli	r2,r2,8
 d03fe0c:	10bfffcc 	andi	r2,r2,65535
 d03fe10:	10c03fcc 	andi	r3,r2,255
 d03fe14:	e0bff817 	ldw	r2,-32(fp)
 d03fe18:	1080018b 	ldhu	r2,6(r2)
 d03fe1c:	10bfffcc 	andi	r2,r2,65535
 d03fe20:	1004923a 	slli	r2,r2,8
 d03fe24:	10bfc00c 	andi	r2,r2,65280
 d03fe28:	1884b03a 	or	r2,r3,r2
 d03fe2c:	1090000c 	andi	r2,r2,16384
 d03fe30:	1005003a 	cmpeq	r2,r2,zero
 d03fe34:	10001a1e 	bne	r2,zero,d03fea0 <ip_fragment+0xd0>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03fe38:	01000084 	movi	r4,2
 d03fe3c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d03fe40:	e13ffa17 	ldw	r4,-24(fp)
 d03fe44:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03fe48:	01000084 	movi	r4,2
 d03fe4c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 d03fe50:	008341b4 	movhi	r2,3334
 d03fe54:	10856804 	addi	r2,r2,5536
 d03fe58:	10801117 	ldw	r2,68(r2)
 d03fe5c:	10c00044 	addi	r3,r2,1
 d03fe60:	008341b4 	movhi	r2,3334
 d03fe64:	10856804 	addi	r2,r2,5536
 d03fe68:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 d03fe6c:	e0bff817 	ldw	r2,-32(fp)
 d03fe70:	11000317 	ldw	r4,12(r2)
 d03fe74:	e0bffa17 	ldw	r2,-24(fp)
 d03fe78:	10800617 	ldw	r2,24(r2)
 d03fe7c:	11400a17 	ldw	r5,40(r2)
 d03fe80:	e0bffa17 	ldw	r2,-24(fp)
 d03fe84:	10800617 	ldw	r2,24(r2)
 d03fe88:	d8800015 	stw	r2,0(sp)
 d03fe8c:	e1bff817 	ldw	r6,-32(fp)
 d03fe90:	01c00104 	movi	r7,4
 d03fe94:	d04b6c40 	call	d04b6c4 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 d03fe98:	e03ffe15 	stw	zero,-8(fp)
 d03fe9c:	00015106 	br	d0403e4 <ip_fragment+0x614>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 d03fea0:	d02524c0 	call	d02524c <pk_get_max_intrsafe_buf_len>
 d03fea4:	e0bff915 	stw	r2,-28(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 d03fea8:	e0bffa17 	ldw	r2,-24(fp)
 d03feac:	10800617 	ldw	r2,24(r2)
 d03feb0:	10800917 	ldw	r2,36(r2)
 d03feb4:	e0fff917 	ldw	r3,-28(fp)
 d03feb8:	e0ffff15 	stw	r3,-4(fp)
 d03febc:	e0bffd15 	stw	r2,-12(fp)
 d03fec0:	e0bfff17 	ldw	r2,-4(fp)
 d03fec4:	e0fffd17 	ldw	r3,-12(fp)
 d03fec8:	10c0022e 	bgeu	r2,r3,d03fed4 <ip_fragment+0x104>
 d03fecc:	e0bfff17 	ldw	r2,-4(fp)
 d03fed0:	e0bffd15 	stw	r2,-12(fp)
 d03fed4:	e0fffd17 	ldw	r3,-12(fp)
 d03fed8:	e0fff58d 	sth	r3,-42(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 d03fedc:	e0bff817 	ldw	r2,-32(fp)
 d03fee0:	10800003 	ldbu	r2,0(r2)
 d03fee4:	108003cc 	andi	r2,r2,15
 d03fee8:	1085883a 	add	r2,r2,r2
 d03feec:	1085883a 	add	r2,r2,r2
 d03fef0:	e0bff7c5 	stb	r2,-33(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 d03fef4:	e0bffa17 	ldw	r2,-24(fp)
 d03fef8:	10800617 	ldw	r2,24(r2)
 d03fefc:	10800817 	ldw	r2,32(r2)
 d03ff00:	e0bff785 	stb	r2,-34(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 d03ff04:	e0fff7c3 	ldbu	r3,-33(fp)
 d03ff08:	e0bff58b 	ldhu	r2,-42(fp)
 d03ff0c:	10c5c83a 	sub	r2,r2,r3
 d03ff10:	1007883a 	mov	r3,r2
 d03ff14:	e0bff783 	ldbu	r2,-34(fp)
 d03ff18:	1885c83a 	sub	r2,r3,r2
 d03ff1c:	e0bff70d 	sth	r2,-36(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 d03ff20:	e0fff70b 	ldhu	r3,-36(fp)
 d03ff24:	00bffe04 	movi	r2,-8
 d03ff28:	1884703a 	and	r2,r3,r2
 d03ff2c:	e0bff70d 	sth	r2,-36(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 d03ff30:	e0bff817 	ldw	r2,-32(fp)
 d03ff34:	1080008b 	ldhu	r2,2(r2)
 d03ff38:	10bfffcc 	andi	r2,r2,65535
 d03ff3c:	1004d23a 	srli	r2,r2,8
 d03ff40:	10803fcc 	andi	r2,r2,255
 d03ff44:	1009883a 	mov	r4,r2
 d03ff48:	e0bff817 	ldw	r2,-32(fp)
 d03ff4c:	1080008b 	ldhu	r2,2(r2)
 d03ff50:	10bfffcc 	andi	r2,r2,65535
 d03ff54:	1004923a 	slli	r2,r2,8
 d03ff58:	1007883a 	mov	r3,r2
 d03ff5c:	00bfc004 	movi	r2,-256
 d03ff60:	1884703a 	and	r2,r3,r2
 d03ff64:	2084b03a 	or	r2,r4,r2
 d03ff68:	1007883a 	mov	r3,r2
 d03ff6c:	e0bff7c3 	ldbu	r2,-33(fp)
 d03ff70:	1885c83a 	sub	r2,r3,r2
 d03ff74:	e0bff68d 	sth	r2,-38(fp)
   num_frags = (total_payload_len / useable_payload_len);
 d03ff78:	e13ff68b 	ldhu	r4,-38(fp)
 d03ff7c:	e17ff70b 	ldhu	r5,-36(fp)
 d03ff80:	d00c90c0 	call	d00c90c <__udivsi3>
 d03ff84:	e0bff50d 	sth	r2,-44(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 d03ff88:	e13ff68b 	ldhu	r4,-38(fp)
 d03ff8c:	e17ff70b 	ldhu	r5,-36(fp)
 d03ff90:	d00c9140 	call	d00c914 <__umodsi3>
 d03ff94:	e0bff60d 	sth	r2,-40(fp)
 d03ff98:	e0bff60b 	ldhu	r2,-40(fp)
 d03ff9c:	1005003a 	cmpeq	r2,r2,zero
 d03ffa0:	1000031e 	bne	r2,zero,d03ffb0 <ip_fragment+0x1e0>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 d03ffa4:	e0bff50b 	ldhu	r2,-44(fp)
 d03ffa8:	10800044 	addi	r2,r2,1
 d03ffac:	e0bff50d 	sth	r2,-44(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 d03ffb0:	e0bff50b 	ldhu	r2,-44(fp)
 d03ffb4:	10800128 	cmpgeui	r2,r2,4
 d03ffb8:	10000a1e 	bne	r2,zero,d03ffe4 <ip_fragment+0x214>
 d03ffbc:	e0bffa17 	ldw	r2,-24(fp)
 d03ffc0:	10800a17 	ldw	r2,40(r2)
 d03ffc4:	1080040c 	andi	r2,r2,16
 d03ffc8:	1004c03a 	cmpne	r2,r2,zero
 d03ffcc:	1000051e 	bne	r2,zero,d03ffe4 <ip_fragment+0x214>
   {
      return (ip_fragment_lc (p, firsthop));
 d03ffd0:	e13ffa17 	ldw	r4,-24(fp)
 d03ffd4:	e17ffb17 	ldw	r5,-20(fp)
 d03ffd8:	d03f9480 	call	d03f948 <ip_fragment_lc>
 d03ffdc:	e0bffe15 	stw	r2,-8(fp)
 d03ffe0:	00010006 	br	d0403e4 <ip_fragment+0x614>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 d03ffe4:	e0bff817 	ldw	r2,-32(fp)
 d03ffe8:	1080018b 	ldhu	r2,6(r2)
 d03ffec:	10bfffcc 	andi	r2,r2,65535
 d03fff0:	1004d23a 	srli	r2,r2,8
 d03fff4:	10803fcc 	andi	r2,r2,255
 d03fff8:	1009883a 	mov	r4,r2
 d03fffc:	e0bff817 	ldw	r2,-32(fp)
 d040000:	1080018b 	ldhu	r2,6(r2)
 d040004:	10bfffcc 	andi	r2,r2,65535
 d040008:	1004923a 	slli	r2,r2,8
 d04000c:	1007883a 	mov	r3,r2
 d040010:	00bfc004 	movi	r2,-256
 d040014:	1884703a 	and	r2,r3,r2
 d040018:	2084b03a 	or	r2,r4,r2
 d04001c:	1087ffcc 	andi	r2,r2,8191
 d040020:	100490fa 	slli	r2,r2,3
 d040024:	e0bff38d 	sth	r2,-50(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 d040028:	e0bff817 	ldw	r2,-32(fp)
 d04002c:	1080018b 	ldhu	r2,6(r2)
 d040030:	10bfffcc 	andi	r2,r2,65535
 d040034:	1004d23a 	srli	r2,r2,8
 d040038:	10803fcc 	andi	r2,r2,255
 d04003c:	1009883a 	mov	r4,r2
 d040040:	e0bff817 	ldw	r2,-32(fp)
 d040044:	1080018b 	ldhu	r2,6(r2)
 d040048:	10bfffcc 	andi	r2,r2,65535
 d04004c:	1004923a 	slli	r2,r2,8
 d040050:	1007883a 	mov	r3,r2
 d040054:	00bfc004 	movi	r2,-256
 d040058:	1884703a 	and	r2,r3,r2
 d04005c:	2084b03a 	or	r2,r4,r2
 d040060:	1088000c 	andi	r2,r2,8192
 d040064:	e0bff30d 	sth	r2,-52(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 d040068:	e03ff48d 	sth	zero,-46(fp)
 d04006c:	0000cc06 	br	d0403a0 <ip_fragment+0x5d0>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d040070:	01000084 	movi	r4,2
 d040074:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 d040078:	e0fff70b 	ldhu	r3,-36(fp)
 d04007c:	e0bff7c3 	ldbu	r2,-33(fp)
 d040080:	1887883a 	add	r3,r3,r2
 d040084:	e0bff783 	ldbu	r2,-34(fp)
 d040088:	1885883a 	add	r2,r3,r2
 d04008c:	1009883a 	mov	r4,r2
 d040090:	d024e0c0 	call	d024e0c <pk_alloc>
 d040094:	e0bff215 	stw	r2,-56(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d040098:	01000084 	movi	r4,2
 d04009c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 d0400a0:	e0bff217 	ldw	r2,-56(fp)
 d0400a4:	1004c03a 	cmpne	r2,r2,zero
 d0400a8:	1000101e 	bne	r2,zero,d0400ec <ip_fragment+0x31c>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d0400ac:	01000084 	movi	r4,2
 d0400b0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(p);
 d0400b4:	e13ffa17 	ldw	r4,-24(fp)
 d0400b8:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0400bc:	01000084 	movi	r4,2
 d0400c0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 d0400c4:	008341b4 	movhi	r2,3334
 d0400c8:	10856804 	addi	r2,r2,5536
 d0400cc:	10801117 	ldw	r2,68(r2)
 d0400d0:	10c00044 	addi	r3,r2,1
 d0400d4:	008341b4 	movhi	r2,3334
 d0400d8:	10856804 	addi	r2,r2,5536
 d0400dc:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 d0400e0:	00bffac4 	movi	r2,-21
 d0400e4:	e0bffe15 	stw	r2,-8(fp)
 d0400e8:	0000be06 	br	d0403e4 <ip_fragment+0x614>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 d0400ec:	e0bff217 	ldw	r2,-56(fp)
 d0400f0:	10c00117 	ldw	r3,4(r2)
 d0400f4:	e0bff783 	ldbu	r2,-34(fp)
 d0400f8:	1889883a 	add	r4,r3,r2
 d0400fc:	e0bffa17 	ldw	r2,-24(fp)
 d040100:	10800317 	ldw	r2,12(r2)
 d040104:	e0fff7c3 	ldbu	r3,-33(fp)
 d040108:	100b883a 	mov	r5,r2
 d04010c:	180d883a 	mov	r6,r3
 d040110:	d0026080 	call	d002608 <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 d040114:	e0fff48b 	ldhu	r3,-46(fp)
 d040118:	e0bff50b 	ldhu	r2,-44(fp)
 d04011c:	10bfffc4 	addi	r2,r2,-1
 d040120:	1880030e 	bge	r3,r2,d040130 <ip_fragment+0x360>
         {
            amt_to_copy = useable_payload_len;
 d040124:	e0bff70b 	ldhu	r2,-36(fp)
 d040128:	e0bff40d 	sth	r2,-48(fp)
 d04012c:	00000a06 	br	d040158 <ip_fragment+0x388>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 d040130:	e0bff60b 	ldhu	r2,-40(fp)
 d040134:	1004c03a 	cmpne	r2,r2,zero
 d040138:	1000031e 	bne	r2,zero,d040148 <ip_fragment+0x378>
 d04013c:	e0fff70b 	ldhu	r3,-36(fp)
 d040140:	e0fffc0d 	sth	r3,-16(fp)
 d040144:	00000206 	br	d040150 <ip_fragment+0x380>
 d040148:	e0bff60b 	ldhu	r2,-40(fp)
 d04014c:	e0bffc0d 	sth	r2,-16(fp)
 d040150:	e0fffc0b 	ldhu	r3,-16(fp)
 d040154:	e0fff40d 	sth	r3,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 d040158:	e0bff217 	ldw	r2,-56(fp)
 d04015c:	10c00117 	ldw	r3,4(r2)
 d040160:	e0bff783 	ldbu	r2,-34(fp)
 d040164:	1887883a 	add	r3,r3,r2
 d040168:	e0bff7c3 	ldbu	r2,-33(fp)
 d04016c:	18a3883a 	add	r17,r3,r2
 d040170:	e0bffa17 	ldw	r2,-24(fp)
 d040174:	10c00317 	ldw	r3,12(r2)
 d040178:	e0bff7c3 	ldbu	r2,-33(fp)
 d04017c:	18a1883a 	add	r16,r3,r2
 d040180:	e13ff70b 	ldhu	r4,-36(fp)
 d040184:	e17ff48b 	ldhu	r5,-46(fp)
 d040188:	d00235c0 	call	d00235c <__mulsi3>
 d04018c:	8085883a 	add	r2,r16,r2
 d040190:	e0fff40b 	ldhu	r3,-48(fp)
 d040194:	8809883a 	mov	r4,r17
 d040198:	100b883a 	mov	r5,r2
 d04019c:	180d883a 	mov	r6,r3
 d0401a0:	d0026080 	call	d002608 <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 d0401a4:	e0bff217 	ldw	r2,-56(fp)
 d0401a8:	10c00117 	ldw	r3,4(r2)
 d0401ac:	e0bff783 	ldbu	r2,-34(fp)
 d0401b0:	1887883a 	add	r3,r3,r2
 d0401b4:	e0bff217 	ldw	r2,-56(fp)
 d0401b8:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 d0401bc:	e0fff7c3 	ldbu	r3,-33(fp)
 d0401c0:	e0bff40b 	ldhu	r2,-48(fp)
 d0401c4:	1885883a 	add	r2,r3,r2
 d0401c8:	1007883a 	mov	r3,r2
 d0401cc:	e0bff217 	ldw	r2,-56(fp)
 d0401d0:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 d0401d4:	e0bffa17 	ldw	r2,-24(fp)
 d0401d8:	10c00617 	ldw	r3,24(r2)
 d0401dc:	e0bff217 	ldw	r2,-56(fp)
 d0401e0:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 d0401e4:	e0bffa17 	ldw	r2,-24(fp)
 d0401e8:	10c00717 	ldw	r3,28(r2)
 d0401ec:	e0bff217 	ldw	r2,-56(fp)
 d0401f0:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 d0401f4:	e0fff217 	ldw	r3,-56(fp)
 d0401f8:	00820004 	movi	r2,2048
 d0401fc:	1880080d 	sth	r2,32(r3)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 d040200:	e0bff217 	ldw	r2,-56(fp)
 d040204:	10800317 	ldw	r2,12(r2)
 d040208:	e0bff115 	stw	r2,-60(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 d04020c:	e0bff217 	ldw	r2,-56(fp)
 d040210:	10800417 	ldw	r2,16(r2)
 d040214:	1004d23a 	srli	r2,r2,8
 d040218:	10803fcc 	andi	r2,r2,255
 d04021c:	1009883a 	mov	r4,r2
 d040220:	e0bff217 	ldw	r2,-56(fp)
 d040224:	10800417 	ldw	r2,16(r2)
 d040228:	1004923a 	slli	r2,r2,8
 d04022c:	1007883a 	mov	r3,r2
 d040230:	00bfc004 	movi	r2,-256
 d040234:	1884703a 	and	r2,r3,r2
 d040238:	2084b03a 	or	r2,r4,r2
 d04023c:	1007883a 	mov	r3,r2
 d040240:	e0bff117 	ldw	r2,-60(fp)
 d040244:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 d040248:	e43ff38b 	ldhu	r16,-50(fp)
 d04024c:	e13ff70b 	ldhu	r4,-36(fp)
 d040250:	e17ff48b 	ldhu	r5,-46(fp)
 d040254:	d00235c0 	call	d00235c <__mulsi3>
 d040258:	8085883a 	add	r2,r16,r2
 d04025c:	1005d2fa 	srai	r2,r2,11
 d040260:	10803fcc 	andi	r2,r2,255
 d040264:	1023883a 	mov	r17,r2
 d040268:	e43ff38b 	ldhu	r16,-50(fp)
 d04026c:	e13ff70b 	ldhu	r4,-36(fp)
 d040270:	e17ff48b 	ldhu	r5,-46(fp)
 d040274:	d00235c0 	call	d00235c <__mulsi3>
 d040278:	8085883a 	add	r2,r16,r2
 d04027c:	1005d0fa 	srai	r2,r2,3
 d040280:	1004923a 	slli	r2,r2,8
 d040284:	1007883a 	mov	r3,r2
 d040288:	00bfc004 	movi	r2,-256
 d04028c:	1884703a 	and	r2,r3,r2
 d040290:	8884b03a 	or	r2,r17,r2
 d040294:	1007883a 	mov	r3,r2
 d040298:	e0bff117 	ldw	r2,-60(fp)
 d04029c:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 d0402a0:	e0fff48b 	ldhu	r3,-46(fp)
 d0402a4:	e0bff50b 	ldhu	r2,-44(fp)
 d0402a8:	10bfffc4 	addi	r2,r2,-1
 d0402ac:	1880070e 	bge	r3,r2,d0402cc <ip_fragment+0x4fc>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 d0402b0:	e0bff117 	ldw	r2,-60(fp)
 d0402b4:	1080018b 	ldhu	r2,6(r2)
 d0402b8:	10800814 	ori	r2,r2,32
 d0402bc:	1007883a 	mov	r3,r2
 d0402c0:	e0bff117 	ldw	r2,-60(fp)
 d0402c4:	10c0018d 	sth	r3,6(r2)
 d0402c8:	00000906 	br	d0402f0 <ip_fragment+0x520>
         }
         else
         {
            if (parent_mf)
 d0402cc:	e0bff30b 	ldhu	r2,-52(fp)
 d0402d0:	1005003a 	cmpeq	r2,r2,zero
 d0402d4:	1000061e 	bne	r2,zero,d0402f0 <ip_fragment+0x520>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 d0402d8:	e0bff117 	ldw	r2,-60(fp)
 d0402dc:	1080018b 	ldhu	r2,6(r2)
 d0402e0:	10800814 	ori	r2,r2,32
 d0402e4:	1007883a 	mov	r3,r2
 d0402e8:	e0bff117 	ldw	r2,-60(fp)
 d0402ec:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 d0402f0:	e0bff117 	ldw	r2,-60(fp)
 d0402f4:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 d0402f8:	e0bff7c3 	ldbu	r2,-33(fp)
 d0402fc:	1004d07a 	srli	r2,r2,1
 d040300:	11403fcc 	andi	r5,r2,255
 d040304:	e13ff117 	ldw	r4,-60(fp)
 d040308:	d0205440 	call	d020544 <cksum>
 d04030c:	0084303a 	nor	r2,zero,r2
 d040310:	1007883a 	mov	r3,r2
 d040314:	e0bff117 	ldw	r2,-60(fp)
 d040318:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 d04031c:	008341b4 	movhi	r2,3334
 d040320:	10856804 	addi	r2,r2,5536
 d040324:	10801217 	ldw	r2,72(r2)
 d040328:	10c00044 	addi	r3,r2,1
 d04032c:	008341b4 	movhi	r2,3334
 d040330:	10856804 	addi	r2,r2,5536
 d040334:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 d040338:	e13ff217 	ldw	r4,-56(fp)
 d04033c:	e17ffb17 	ldw	r5,-20(fp)
 d040340:	d01e2bc0 	call	d01e2bc <ip2mac>
 d040344:	e0bff015 	stw	r2,-64(fp)
         if (e < 0)
 d040348:	e0bff017 	ldw	r2,-64(fp)
 d04034c:	1004403a 	cmpge	r2,r2,zero
 d040350:	1000101e 	bne	r2,zero,d040394 <ip_fragment+0x5c4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d040354:	01000084 	movi	r4,2
 d040358:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(p);
 d04035c:	e13ffa17 	ldw	r4,-24(fp)
 d040360:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d040364:	01000084 	movi	r4,2
 d040368:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 d04036c:	008341b4 	movhi	r2,3334
 d040370:	10856804 	addi	r2,r2,5536
 d040374:	10801117 	ldw	r2,68(r2)
 d040378:	10c00044 	addi	r3,r2,1
 d04037c:	008341b4 	movhi	r2,3334
 d040380:	10856804 	addi	r2,r2,5536
 d040384:	10c01115 	stw	r3,68(r2)
            return e;
 d040388:	e0bff017 	ldw	r2,-64(fp)
 d04038c:	e0bffe15 	stw	r2,-8(fp)
 d040390:	00001406 	br	d0403e4 <ip_fragment+0x614>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 d040394:	e0bff48b 	ldhu	r2,-46(fp)
 d040398:	10800044 	addi	r2,r2,1
 d04039c:	e0bff48d 	sth	r2,-46(fp)
 d0403a0:	e0fff48b 	ldhu	r3,-46(fp)
 d0403a4:	e0bff50b 	ldhu	r2,-44(fp)
 d0403a8:	18bf3136 	bltu	r3,r2,d040070 <ip_fragment+0x2a0>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d0403ac:	01000084 	movi	r4,2
 d0403b0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p);
 d0403b4:	e13ffa17 	ldw	r4,-24(fp)
 d0403b8:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0403bc:	01000084 	movi	r4,2
 d0403c0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 d0403c4:	008341b4 	movhi	r2,3334
 d0403c8:	10856804 	addi	r2,r2,5536
 d0403cc:	10801017 	ldw	r2,64(r2)
 d0403d0:	10c00044 	addi	r3,r2,1
 d0403d4:	008341b4 	movhi	r2,3334
 d0403d8:	10856804 	addi	r2,r2,5536
 d0403dc:	10c01015 	stw	r3,64(r2)

   return 0;
 d0403e0:	e03ffe15 	stw	zero,-8(fp)
 d0403e4:	e0bffe17 	ldw	r2,-8(fp)
}
 d0403e8:	e037883a 	mov	sp,fp
 d0403ec:	dfc00317 	ldw	ra,12(sp)
 d0403f0:	df000217 	ldw	fp,8(sp)
 d0403f4:	dc400117 	ldw	r17,4(sp)
 d0403f8:	dc000017 	ldw	r16,0(sp)
 d0403fc:	dec00404 	addi	sp,sp,16
 d040400:	f800283a 	ret

0d040404 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 d040404:	defff904 	addi	sp,sp,-28
 d040408:	dfc00615 	stw	ra,24(sp)
 d04040c:	df000515 	stw	fp,20(sp)
 d040410:	df000504 	addi	fp,sp,20
 d040414:	e13ffe15 	stw	r4,-8(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 d040418:	e17ffd04 	addi	r5,fp,-12
 d04041c:	e13ffe17 	ldw	r4,-8(fp)
 d040420:	d0407680 	call	d040768 <iproute>
 d040424:	e0bffc15 	stw	r2,-16(fp)
   if (tnet == 0)
 d040428:	e0bffc17 	ldw	r2,-16(fp)
 d04042c:	1004c03a 	cmpne	r2,r2,zero
 d040430:	1000161e 	bne	r2,zero,d04048c <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 d040434:	00834174 	movhi	r2,3333
 d040438:	109b2004 	addi	r2,r2,27776
 d04043c:	10800017 	ldw	r2,0(r2)
 d040440:	1080050c 	andi	r2,r2,20
 d040444:	1005003a 	cmpeq	r2,r2,zero
 d040448:	10000e1e 	bne	r2,zero,d040484 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d04044c:	e0bffe17 	ldw	r2,-8(fp)
 d040450:	11403fcc 	andi	r5,r2,255
 d040454:	e0bffe17 	ldw	r2,-8(fp)
 d040458:	1004d23a 	srli	r2,r2,8
 d04045c:	11803fcc 	andi	r6,r2,255
 d040460:	e0bffe17 	ldw	r2,-8(fp)
 d040464:	1004d43a 	srli	r2,r2,16
 d040468:	11c03fcc 	andi	r7,r2,255
 d04046c:	e0bffe17 	ldw	r2,-8(fp)
 d040470:	1004d63a 	srli	r2,r2,24
 d040474:	d8800015 	stw	r2,0(sp)
 d040478:	01034174 	movhi	r4,3333
 d04047c:	2106ce04 	addi	r4,r4,6968
 d040480:	d0028a00 	call	d0028a0 <printf>
#endif   /* NPDEBUG */
      return 0L;
 d040484:	e03fff15 	stw	zero,-4(fp)
 d040488:	00000306 	br	d040498 <ip_mymach+0x94>
   }
   return tnet->n_ipaddr;
 d04048c:	e0bffc17 	ldw	r2,-16(fp)
 d040490:	10800a17 	ldw	r2,40(r2)
 d040494:	e0bfff15 	stw	r2,-4(fp)
 d040498:	e0bfff17 	ldw	r2,-4(fp)
#endif /* MULTI_HOMED */
}
 d04049c:	e037883a 	mov	sp,fp
 d0404a0:	dfc00117 	ldw	ra,4(sp)
 d0404a4:	df000017 	ldw	fp,0(sp)
 d0404a8:	dec00204 	addi	sp,sp,8
 d0404ac:	f800283a 	ret

0d0404b0 <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 d0404b0:	defff204 	addi	sp,sp,-56
 d0404b4:	dfc00d15 	stw	ra,52(sp)
 d0404b8:	df000c15 	stw	fp,48(sp)
 d0404bc:	df000c04 	addi	fp,sp,48
 d0404c0:	e13ffa15 	stw	r4,-24(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 d0404c4:	e0bffa17 	ldw	r2,-24(fp)
 d0404c8:	10800317 	ldw	r2,12(r2)
 d0404cc:	e0bff915 	stw	r2,-28(fp)
   osum = pip->ip_chksum;
 d0404d0:	e0bff917 	ldw	r2,-28(fp)
 d0404d4:	1080028b 	ldhu	r2,10(r2)
 d0404d8:	e0bff70d 	sth	r2,-36(fp)
   pip->ip_chksum = 0;
 d0404dc:	e0bff917 	ldw	r2,-28(fp)
 d0404e0:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 d0404e4:	e0bff917 	ldw	r2,-28(fp)
 d0404e8:	10800003 	ldbu	r2,0(r2)
 d0404ec:	10803fcc 	andi	r2,r2,255
 d0404f0:	108003cc 	andi	r2,r2,15
 d0404f4:	1085883a 	add	r2,r2,r2
 d0404f8:	1085883a 	add	r2,r2,r2
 d0404fc:	1005d07a 	srai	r2,r2,1
 d040500:	100b883a 	mov	r5,r2
 d040504:	e13ff917 	ldw	r4,-28(fp)
 d040508:	d0205440 	call	d020544 <cksum>
 d04050c:	0084303a 	nor	r2,zero,r2
 d040510:	e0bff78d 	sth	r2,-34(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 d040514:	e0fff70b 	ldhu	r3,-36(fp)
 d040518:	e0bff78b 	ldhu	r2,-34(fp)
 d04051c:	18800126 	beq	r3,r2,d040524 <ip_dump+0x74>
   {
      dtrap();
 d040520:	d025a500 	call	d025a50 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 d040524:	0009883a 	mov	r4,zero
 d040528:	01434174 	movhi	r5,3333
 d04052c:	2946d704 	addi	r5,r5,7004
 d040530:	d020b640 	call	d020b64 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 d040534:	e0bff917 	ldw	r2,-28(fp)
 d040538:	e0bff815 	stw	r2,-32(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 d04053c:	e0bff817 	ldw	r2,-32(fp)
 d040540:	10800003 	ldbu	r2,0(r2)
 d040544:	11803fcc 	andi	r6,r2,255
 d040548:	e0bff817 	ldw	r2,-32(fp)
 d04054c:	10800044 	addi	r2,r2,1
 d040550:	10800003 	ldbu	r2,0(r2)
 d040554:	11c03fcc 	andi	r7,r2,255
 d040558:	e0bff917 	ldw	r2,-28(fp)
 d04055c:	1080008b 	ldhu	r2,2(r2)
 d040560:	10bfffcc 	andi	r2,r2,65535
 d040564:	1004d23a 	srli	r2,r2,8
 d040568:	10bfffcc 	andi	r2,r2,65535
 d04056c:	10c03fcc 	andi	r3,r2,255
 d040570:	e0bff917 	ldw	r2,-28(fp)
 d040574:	1080008b 	ldhu	r2,2(r2)
 d040578:	10bfffcc 	andi	r2,r2,65535
 d04057c:	1004923a 	slli	r2,r2,8
 d040580:	10bfc00c 	andi	r2,r2,65280
 d040584:	1888b03a 	or	r4,r3,r2
 d040588:	e0bff917 	ldw	r2,-28(fp)
 d04058c:	1080010b 	ldhu	r2,4(r2)
 d040590:	10bfffcc 	andi	r2,r2,65535
 d040594:	1004d23a 	srli	r2,r2,8
 d040598:	10bfffcc 	andi	r2,r2,65535
 d04059c:	10c03fcc 	andi	r3,r2,255
 d0405a0:	e0bff917 	ldw	r2,-28(fp)
 d0405a4:	1080010b 	ldhu	r2,4(r2)
 d0405a8:	10bfffcc 	andi	r2,r2,65535
 d0405ac:	1004923a 	slli	r2,r2,8
 d0405b0:	10bfc00c 	andi	r2,r2,65280
 d0405b4:	1884b03a 	or	r2,r3,r2
 d0405b8:	d9000015 	stw	r4,0(sp)
 d0405bc:	d8800115 	stw	r2,4(sp)
 d0405c0:	0009883a 	mov	r4,zero
 d0405c4:	01434174 	movhi	r5,3333
 d0405c8:	2946dc04 	addi	r5,r5,7024
 d0405cc:	d020b640 	call	d020b64 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 d0405d0:	e0bff817 	ldw	r2,-32(fp)
 d0405d4:	10800184 	addi	r2,r2,6
 d0405d8:	1080000b 	ldhu	r2,0(r2)
 d0405dc:	10bfffcc 	andi	r2,r2,65535
 d0405e0:	1004d23a 	srli	r2,r2,8
 d0405e4:	10bfffcc 	andi	r2,r2,65535
 d0405e8:	10c03fcc 	andi	r3,r2,255
 d0405ec:	e0bff817 	ldw	r2,-32(fp)
 d0405f0:	10800184 	addi	r2,r2,6
 d0405f4:	1080000b 	ldhu	r2,0(r2)
 d0405f8:	10bfffcc 	andi	r2,r2,65535
 d0405fc:	1004923a 	slli	r2,r2,8
 d040600:	10bfc00c 	andi	r2,r2,65280
 d040604:	1886b03a 	or	r3,r3,r2
 d040608:	e0ffff15 	stw	r3,-4(fp)
 d04060c:	e0bff917 	ldw	r2,-28(fp)
 d040610:	10800203 	ldbu	r2,8(r2)
 d040614:	10803fcc 	andi	r2,r2,255
 d040618:	e0bffe15 	stw	r2,-8(fp)
 d04061c:	e0bff917 	ldw	r2,-28(fp)
 d040620:	10800243 	ldbu	r2,9(r2)
 d040624:	10803fcc 	andi	r2,r2,255
 d040628:	e0bffd15 	stw	r2,-12(fp)
 d04062c:	e0bff70b 	ldhu	r2,-36(fp)
 d040630:	1004d23a 	srli	r2,r2,8
 d040634:	10bfffcc 	andi	r2,r2,65535
 d040638:	10c03fcc 	andi	r3,r2,255
 d04063c:	e0bff70b 	ldhu	r2,-36(fp)
 d040640:	1004923a 	slli	r2,r2,8
 d040644:	10bfc00c 	andi	r2,r2,65280
 d040648:	1886b03a 	or	r3,r3,r2
 d04064c:	e0fffc15 	stw	r3,-16(fp)
 d040650:	e0fff70b 	ldhu	r3,-36(fp)
 d040654:	e0bff78b 	ldhu	r2,-34(fp)
 d040658:	1880041e 	bne	r3,r2,d04066c <ip_dump+0x1bc>
 d04065c:	00834174 	movhi	r2,3333
 d040660:	1086e804 	addi	r2,r2,7072
 d040664:	e0bffb15 	stw	r2,-20(fp)
 d040668:	00000306 	br	d040678 <ip_dump+0x1c8>
 d04066c:	00834174 	movhi	r2,3333
 d040670:	1086e904 	addi	r2,r2,7076
 d040674:	e0bffb15 	stw	r2,-20(fp)
 d040678:	e0bffd17 	ldw	r2,-12(fp)
 d04067c:	d8800015 	stw	r2,0(sp)
 d040680:	e0bffc17 	ldw	r2,-16(fp)
 d040684:	d8800115 	stw	r2,4(sp)
 d040688:	e0bffb17 	ldw	r2,-20(fp)
 d04068c:	d8800215 	stw	r2,8(sp)
 d040690:	0009883a 	mov	r4,zero
 d040694:	01434174 	movhi	r5,3333
 d040698:	2946ea04 	addi	r5,r5,7080
 d04069c:	e1bfff17 	ldw	r6,-4(fp)
 d0406a0:	e1fffe17 	ldw	r7,-8(fp)
 d0406a4:	d020b640 	call	d020b64 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 d0406a8:	e0bff917 	ldw	r2,-28(fp)
 d0406ac:	10800317 	ldw	r2,12(r2)
 d0406b0:	11803fcc 	andi	r6,r2,255
 d0406b4:	e0bff917 	ldw	r2,-28(fp)
 d0406b8:	10800317 	ldw	r2,12(r2)
 d0406bc:	1004d23a 	srli	r2,r2,8
 d0406c0:	11c03fcc 	andi	r7,r2,255
 d0406c4:	e0bff917 	ldw	r2,-28(fp)
 d0406c8:	10800317 	ldw	r2,12(r2)
 d0406cc:	1004d43a 	srli	r2,r2,16
 d0406d0:	10c03fcc 	andi	r3,r2,255
 d0406d4:	e0bff917 	ldw	r2,-28(fp)
 d0406d8:	10800317 	ldw	r2,12(r2)
 d0406dc:	1004d63a 	srli	r2,r2,24
 d0406e0:	d8c00015 	stw	r3,0(sp)
 d0406e4:	d8800115 	stw	r2,4(sp)
 d0406e8:	0009883a 	mov	r4,zero
 d0406ec:	01434174 	movhi	r5,3333
 d0406f0:	2946fa04 	addi	r5,r5,7144
 d0406f4:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 d0406f8:	e0bff917 	ldw	r2,-28(fp)
 d0406fc:	10800417 	ldw	r2,16(r2)
 d040700:	11803fcc 	andi	r6,r2,255
 d040704:	e0bff917 	ldw	r2,-28(fp)
 d040708:	10800417 	ldw	r2,16(r2)
 d04070c:	1004d23a 	srli	r2,r2,8
 d040710:	11c03fcc 	andi	r7,r2,255
 d040714:	e0bff917 	ldw	r2,-28(fp)
 d040718:	10800417 	ldw	r2,16(r2)
 d04071c:	1004d43a 	srli	r2,r2,16
 d040720:	10c03fcc 	andi	r3,r2,255
 d040724:	e0bff917 	ldw	r2,-28(fp)
 d040728:	10800417 	ldw	r2,16(r2)
 d04072c:	1004d63a 	srli	r2,r2,24
 d040730:	d8c00015 	stw	r3,0(sp)
 d040734:	d8800115 	stw	r2,4(sp)
 d040738:	0009883a 	mov	r4,zero
 d04073c:	01434174 	movhi	r5,3333
 d040740:	2946ff04 	addi	r5,r5,7164
 d040744:	d020b640 	call	d020b64 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 d040748:	e0fff917 	ldw	r3,-28(fp)
 d04074c:	e0bff70b 	ldhu	r2,-36(fp)
 d040750:	1880028d 	sth	r2,10(r3)
}
 d040754:	e037883a 	mov	sp,fp
 d040758:	dfc00117 	ldw	ra,4(sp)
 d04075c:	df000017 	ldw	fp,0(sp)
 d040760:	dec00204 	addi	sp,sp,8
 d040764:	f800283a 	ret

0d040768 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 d040768:	defff704 	addi	sp,sp,-36
 d04076c:	dfc00815 	stw	ra,32(sp)
 d040770:	df000715 	stw	fp,28(sp)
 d040774:	df000704 	addi	fp,sp,28
 d040778:	e13ffd15 	stw	r4,-12(fp)
 d04077c:	e17ffe15 	stw	r5,-8(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 d040780:	e0bffd17 	ldw	r2,-12(fp)
 d040784:	1004c03a 	cmpne	r2,r2,zero
 d040788:	1000021e 	bne	r2,zero,d040794 <iproute+0x2c>
      return NULL;
 d04078c:	e03fff15 	stw	zero,-4(fp)
 d040790:	00008a06 	br	d0409bc <iproute+0x254>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 d040794:	d0a94517 	ldw	r2,-23276(gp)
 d040798:	1004c03a 	cmpne	r2,r2,zero
 d04079c:	1000021e 	bne	r2,zero,d0407a8 <iproute+0x40>
      return NULL;
 d0407a0:	e03fff15 	stw	zero,-4(fp)
 d0407a4:	00008506 	br	d0409bc <iproute+0x254>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 d0407a8:	00834174 	movhi	r2,3333
 d0407ac:	109b6e04 	addi	r2,r2,28088
 d0407b0:	10800017 	ldw	r2,0(r2)
 d0407b4:	1005003a 	cmpeq	r2,r2,zero
 d0407b8:	1000191e 	bne	r2,zero,d040820 <iproute+0xb8>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 d0407bc:	00834174 	movhi	r2,3333
 d0407c0:	109b6e04 	addi	r2,r2,28088
 d0407c4:	10800017 	ldw	r2,0(r2)
 d0407c8:	10c00017 	ldw	r3,0(r2)
 d0407cc:	e0bffd17 	ldw	r2,-12(fp)
 d0407d0:	1880131e 	bne	r3,r2,d040820 <iproute+0xb8>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 d0407d4:	00834174 	movhi	r2,3333
 d0407d8:	109b6e04 	addi	r2,r2,28088
 d0407dc:	10800017 	ldw	r2,0(r2)
 d0407e0:	10c00617 	ldw	r3,24(r2)
 d0407e4:	e0bffe17 	ldw	r2,-8(fp)
 d0407e8:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 d0407ec:	00834174 	movhi	r2,3333
 d0407f0:	109b6e04 	addi	r2,r2,28088
 d0407f4:	10c00017 	ldw	r3,0(r2)
 d0407f8:	00834174 	movhi	r2,3333
 d0407fc:	109b4504 	addi	r2,r2,27924
 d040800:	10800017 	ldw	r2,0(r2)
 d040804:	18800915 	stw	r2,36(r3)
         return(cachedRoute->ifp); /* net to send on */
 d040808:	00834174 	movhi	r2,3333
 d04080c:	109b6e04 	addi	r2,r2,28088
 d040810:	10800017 	ldw	r2,0(r2)
 d040814:	10800e17 	ldw	r2,56(r2)
 d040818:	e0bfff15 	stw	r2,-4(fp)
 d04081c:	00006706 	br	d0409bc <iproute+0x254>
      }
   }

   rtp = rt_lookup(host);
 d040820:	e13ffd17 	ldw	r4,-12(fp)
 d040824:	d0440080 	call	d044008 <rt_lookup>
 d040828:	e0bffa15 	stw	r2,-24(fp)
   if(rtp)
 d04082c:	e0bffa17 	ldw	r2,-24(fp)
 d040830:	1005003a 	cmpeq	r2,r2,zero
 d040834:	10000c1e 	bne	r2,zero,d040868 <iproute+0x100>
   {
      cachedRoute = rtp;
 d040838:	00c34174 	movhi	r3,3333
 d04083c:	18db6e04 	addi	r3,r3,28088
 d040840:	e0bffa17 	ldw	r2,-24(fp)
 d040844:	18800015 	stw	r2,0(r3)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 d040848:	e0bffa17 	ldw	r2,-24(fp)
 d04084c:	10c00617 	ldw	r3,24(r2)
 d040850:	e0bffe17 	ldw	r2,-8(fp)
 d040854:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 d040858:	e0bffa17 	ldw	r2,-24(fp)
 d04085c:	10800e17 	ldw	r2,56(r2)
 d040860:	e0bfff15 	stw	r2,-4(fp)
 d040864:	00005506 	br	d0409bc <iproute+0x254>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 d040868:	008341b4 	movhi	r2,3334
 d04086c:	10856304 	addi	r2,r2,5516
 d040870:	10800017 	ldw	r2,0(r2)
 d040874:	e0bffb15 	stw	r2,-20(fp)
   i = 0;
 d040878:	e03ffc15 	stw	zero,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 d04087c:	00002f06 	br	d04093c <iproute+0x1d4>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 d040880:	e0bffb17 	ldw	r2,-20(fp)
 d040884:	10800c17 	ldw	r2,48(r2)
 d040888:	1005003a 	cmpeq	r2,r2,zero
 d04088c:	1000251e 	bne	r2,zero,d040924 <iproute+0x1bc>
 d040890:	e0bffb17 	ldw	r2,-20(fp)
 d040894:	10800a17 	ldw	r2,40(r2)
 d040898:	1005003a 	cmpeq	r2,r2,zero
 d04089c:	1000211e 	bne	r2,zero,d040924 <iproute+0x1bc>
 d0408a0:	e0bffb17 	ldw	r2,-20(fp)
 d0408a4:	10c00a17 	ldw	r3,40(r2)
 d0408a8:	e0bffb17 	ldw	r2,-20(fp)
 d0408ac:	10800c17 	ldw	r2,48(r2)
 d0408b0:	1888703a 	and	r4,r3,r2
 d0408b4:	e0bffb17 	ldw	r2,-20(fp)
 d0408b8:	10c00c17 	ldw	r3,48(r2)
 d0408bc:	e0bffd17 	ldw	r2,-12(fp)
 d0408c0:	1884703a 	and	r2,r3,r2
 d0408c4:	2080171e 	bne	r4,r2,d040924 <iproute+0x1bc>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 d0408c8:	00800044 	movi	r2,1
 d0408cc:	d8800015 	stw	r2,0(sp)
 d0408d0:	e13ffd17 	ldw	r4,-12(fp)
 d0408d4:	017fffc4 	movi	r5,-1
 d0408d8:	e1bffd17 	ldw	r6,-12(fp)
 d0408dc:	e1fffc17 	ldw	r7,-16(fp)
 d0408e0:	d0441980 	call	d044198 <add_route>
 d0408e4:	1007883a 	mov	r3,r2
 d0408e8:	00834174 	movhi	r2,3333
 d0408ec:	109b6e04 	addi	r2,r2,28088
 d0408f0:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 d0408f4:	00834174 	movhi	r2,3333
 d0408f8:	109b6e04 	addi	r2,r2,28088
 d0408fc:	10800017 	ldw	r2,0(r2)
 d040900:	1004c03a 	cmpne	r2,r2,zero
 d040904:	1000011e 	bne	r2,zero,d04090c <iproute+0x1a4>
            dtrap();
 d040908:	d025a500 	call	d025a50 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 d04090c:	e0fffe17 	ldw	r3,-8(fp)
 d040910:	e0bffd17 	ldw	r2,-12(fp)
 d040914:	18800015 	stw	r2,0(r3)
         return ifp;
 d040918:	e0bffb17 	ldw	r2,-20(fp)
 d04091c:	e0bfff15 	stw	r2,-4(fp)
 d040920:	00002606 	br	d0409bc <iproute+0x254>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 d040924:	e0bffb17 	ldw	r2,-20(fp)
 d040928:	10800017 	ldw	r2,0(r2)
 d04092c:	e0bffb15 	stw	r2,-20(fp)
 d040930:	e0bffc17 	ldw	r2,-16(fp)
 d040934:	10800044 	addi	r2,r2,1
 d040938:	e0bffc15 	stw	r2,-16(fp)
 d04093c:	e0bffb17 	ldw	r2,-20(fp)
 d040940:	1004c03a 	cmpne	r2,r2,zero
 d040944:	103fce1e 	bne	r2,zero,d040880 <iproute+0x118>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 d040948:	008341b4 	movhi	r2,3334
 d04094c:	10856304 	addi	r2,r2,5516
 d040950:	10800017 	ldw	r2,0(r2)
 d040954:	e0bffb15 	stw	r2,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 d040958:	00000e06 	br	d040994 <iproute+0x22c>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 d04095c:	e0bffb17 	ldw	r2,-20(fp)
 d040960:	10800d17 	ldw	r2,52(r2)
 d040964:	1005003a 	cmpeq	r2,r2,zero
 d040968:	1000071e 	bne	r2,zero,d040988 <iproute+0x220>
      {
         *hop1 = ifp->n_defgw;
 d04096c:	e0bffb17 	ldw	r2,-20(fp)
 d040970:	10c00d17 	ldw	r3,52(r2)
 d040974:	e0bffe17 	ldw	r2,-8(fp)
 d040978:	10c00015 	stw	r3,0(r2)
         return ifp;
 d04097c:	e0bffb17 	ldw	r2,-20(fp)
 d040980:	e0bfff15 	stw	r2,-4(fp)
 d040984:	00000d06 	br	d0409bc <iproute+0x254>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 d040988:	e0bffb17 	ldw	r2,-20(fp)
 d04098c:	10800017 	ldw	r2,0(r2)
 d040990:	e0bffb15 	stw	r2,-20(fp)
 d040994:	e0bffb17 	ldw	r2,-20(fp)
 d040998:	1004c03a 	cmpne	r2,r2,zero
 d04099c:	103fef1e 	bne	r2,zero,d04095c <iproute+0x1f4>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 d0409a0:	e0fffe17 	ldw	r3,-8(fp)
 d0409a4:	e0bffd17 	ldw	r2,-12(fp)
 d0409a8:	18800015 	stw	r2,0(r3)
   return((NET)(netlist.q_head));
 d0409ac:	008341b4 	movhi	r2,3334
 d0409b0:	10856304 	addi	r2,r2,5516
 d0409b4:	10800017 	ldw	r2,0(r2)
 d0409b8:	e0bfff15 	stw	r2,-4(fp)
 d0409bc:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* STRICT_SUBNETTING */
}
 d0409c0:	e037883a 	mov	sp,fp
 d0409c4:	dfc00117 	ldw	ra,4(sp)
 d0409c8:	df000017 	ldw	fp,0(sp)
 d0409cc:	dec00204 	addi	sp,sp,8
 d0409d0:	f800283a 	ret

0d0409d4 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 d0409d4:	defffa04 	addi	sp,sp,-24
 d0409d8:	dfc00515 	stw	ra,20(sp)
 d0409dc:	df000415 	stw	fp,16(sp)
 d0409e0:	df000404 	addi	fp,sp,16
 d0409e4:	e13ffe15 	stw	r4,-8(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 d0409e8:	e0bffe17 	ldw	r2,-8(fp)
 d0409ec:	11000417 	ldw	r4,16(r2)
 d0409f0:	e0bffe17 	ldw	r2,-8(fp)
 d0409f4:	10800317 	ldw	r2,12(r2)
 d0409f8:	1007883a 	mov	r3,r2
 d0409fc:	e0bffe17 	ldw	r2,-8(fp)
 d040a00:	10800117 	ldw	r2,4(r2)
 d040a04:	1885c83a 	sub	r2,r3,r2
 d040a08:	2085883a 	add	r2,r4,r2
 d040a0c:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d040a10:	01000084 	movi	r4,2
 d040a14:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 d040a18:	e13ffc17 	ldw	r4,-16(fp)
 d040a1c:	d024e0c0 	call	d024e0c <pk_alloc>
 d040a20:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d040a24:	01000084 	movi	r4,2
 d040a28:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 d040a2c:	e0bffd17 	ldw	r2,-12(fp)
 d040a30:	1004c03a 	cmpne	r2,r2,zero
 d040a34:	1000061e 	bne	r2,zero,d040a50 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 d040a38:	01034174 	movhi	r4,3333
 d040a3c:	21070404 	addi	r4,r4,7184
 d040a40:	e17ffc17 	ldw	r5,-16(fp)
 d040a44:	d0028a00 	call	d0028a0 <printf>
#endif
      return NULL;
 d040a48:	e03fff15 	stw	zero,-4(fp)
 d040a4c:	00002906 	br	d040af4 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 d040a50:	e0bffd17 	ldw	r2,-12(fp)
 d040a54:	11000117 	ldw	r4,4(r2)
 d040a58:	e0bffe17 	ldw	r2,-8(fp)
 d040a5c:	10800117 	ldw	r2,4(r2)
 d040a60:	e0fffc17 	ldw	r3,-16(fp)
 d040a64:	100b883a 	mov	r5,r2
 d040a68:	180d883a 	mov	r6,r3
 d040a6c:	d0026080 	call	d002608 <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 d040a70:	e0bffd17 	ldw	r2,-12(fp)
 d040a74:	11000117 	ldw	r4,4(r2)
 d040a78:	e0bffe17 	ldw	r2,-8(fp)
 d040a7c:	10800317 	ldw	r2,12(r2)
 d040a80:	1007883a 	mov	r3,r2
 d040a84:	e0bffe17 	ldw	r2,-8(fp)
 d040a88:	10800117 	ldw	r2,4(r2)
 d040a8c:	1885c83a 	sub	r2,r3,r2
 d040a90:	2087883a 	add	r3,r4,r2
 d040a94:	e0bffd17 	ldw	r2,-12(fp)
 d040a98:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 d040a9c:	e0bffe17 	ldw	r2,-8(fp)
 d040aa0:	10c00417 	ldw	r3,16(r2)
 d040aa4:	e0bffd17 	ldw	r2,-12(fp)
 d040aa8:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 d040aac:	e0bffe17 	ldw	r2,-8(fp)
 d040ab0:	10c00617 	ldw	r3,24(r2)
 d040ab4:	e0bffd17 	ldw	r2,-12(fp)
 d040ab8:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 d040abc:	e0bffe17 	ldw	r2,-8(fp)
 d040ac0:	10c00717 	ldw	r3,28(r2)
 d040ac4:	e0bffd17 	ldw	r2,-12(fp)
 d040ac8:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 d040acc:	e0bffe17 	ldw	r2,-8(fp)
 d040ad0:	10c0080b 	ldhu	r3,32(r2)
 d040ad4:	e0bffd17 	ldw	r2,-12(fp)
 d040ad8:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 d040adc:	e0bffe17 	ldw	r2,-8(fp)
 d040ae0:	10c00517 	ldw	r3,20(r2)
 d040ae4:	e0bffd17 	ldw	r2,-12(fp)
 d040ae8:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 d040aec:	e0bffd17 	ldw	r2,-12(fp)
 d040af0:	e0bfff15 	stw	r2,-4(fp)
 d040af4:	e0bfff17 	ldw	r2,-4(fp)
}
 d040af8:	e037883a 	mov	sp,fp
 d040afc:	dfc00117 	ldw	ra,4(sp)
 d040b00:	df000017 	ldw	fp,0(sp)
 d040b04:	dec00204 	addi	sp,sp,8
 d040b08:	f800283a 	ret

0d040b0c <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 d040b0c:	defff904 	addi	sp,sp,-28
 d040b10:	df000615 	stw	fp,24(sp)
 d040b14:	df000604 	addi	fp,sp,24
 d040b18:	e13ffe15 	stw	r4,-8(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 d040b1c:	e0bffe17 	ldw	r2,-8(fp)
 d040b20:	10800317 	ldw	r2,12(r2)
 d040b24:	e0bffd15 	stw	r2,-12(fp)
   dest = pip->ip_dest;
 d040b28:	e0bffe17 	ldw	r2,-8(fp)
 d040b2c:	10800417 	ldw	r2,16(r2)
 d040b30:	e0bffc15 	stw	r2,-16(fp)
   prot = pip->ip_prot;
 d040b34:	e0bffe17 	ldw	r2,-8(fp)
 d040b38:	10800243 	ldbu	r2,9(r2)
 d040b3c:	e0bffb85 	stb	r2,-18(fp)
   id = pip->ip_id;
 d040b40:	e0bffe17 	ldw	r2,-8(fp)
 d040b44:	1080010b 	ldhu	r2,4(r2)
 d040b48:	e0bffb0d 	sth	r2,-20(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d040b4c:	d0a94717 	ldw	r2,-23268(gp)
 d040b50:	e0bffa15 	stw	r2,-24(fp)
 d040b54:	00001806 	br	d040bb8 <ip_reasm_match_frag_with_ire+0xac>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 d040b58:	e0bffa17 	ldw	r2,-24(fp)
 d040b5c:	10c00117 	ldw	r3,4(r2)
 d040b60:	e0bffd17 	ldw	r2,-12(fp)
 d040b64:	1880111e 	bne	r3,r2,d040bac <ip_reasm_match_frag_with_ire+0xa0>
 d040b68:	e0bffa17 	ldw	r2,-24(fp)
 d040b6c:	10c00217 	ldw	r3,8(r2)
 d040b70:	e0bffc17 	ldw	r2,-16(fp)
 d040b74:	18800d1e 	bne	r3,r2,d040bac <ip_reasm_match_frag_with_ire+0xa0>
 d040b78:	e0bffa17 	ldw	r2,-24(fp)
 d040b7c:	10800383 	ldbu	r2,14(r2)
 d040b80:	10c03fcc 	andi	r3,r2,255
 d040b84:	e0bffb83 	ldbu	r2,-18(fp)
 d040b88:	1880081e 	bne	r3,r2,d040bac <ip_reasm_match_frag_with_ire+0xa0>
 d040b8c:	e0bffa17 	ldw	r2,-24(fp)
 d040b90:	1080030b 	ldhu	r2,12(r2)
 d040b94:	10ffffcc 	andi	r3,r2,65535
 d040b98:	e0bffb0b 	ldhu	r2,-20(fp)
 d040b9c:	1880031e 	bne	r3,r2,d040bac <ip_reasm_match_frag_with_ire+0xa0>
          (tmpp->prot == prot) && (tmpp->id == id))
         {
         return tmpp; /* we've found a match */
 d040ba0:	e0bffa17 	ldw	r2,-24(fp)
 d040ba4:	e0bfff15 	stw	r2,-4(fp)
 d040ba8:	00000706 	br	d040bc8 <ip_reasm_match_frag_with_ire+0xbc>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d040bac:	e0bffa17 	ldw	r2,-24(fp)
 d040bb0:	10800017 	ldw	r2,0(r2)
 d040bb4:	e0bffa15 	stw	r2,-24(fp)
 d040bb8:	e0bffa17 	ldw	r2,-24(fp)
 d040bbc:	1004c03a 	cmpne	r2,r2,zero
 d040bc0:	103fe51e 	bne	r2,zero,d040b58 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 d040bc4:	e03fff15 	stw	zero,-4(fp)
 d040bc8:	e0bfff17 	ldw	r2,-4(fp)
}
 d040bcc:	e037883a 	mov	sp,fp
 d040bd0:	df000017 	ldw	fp,0(sp)
 d040bd4:	dec00104 	addi	sp,sp,4
 d040bd8:	f800283a 	ret

0d040bdc <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 d040bdc:	defffc04 	addi	sp,sp,-16
 d040be0:	df000315 	stw	fp,12(sp)
 d040be4:	df000304 	addi	fp,sp,12
 d040be8:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 d040bec:	e0bfff17 	ldw	r2,-4(fp)
 d040bf0:	1080018b 	ldhu	r2,6(r2)
 d040bf4:	10bfffcc 	andi	r2,r2,65535
 d040bf8:	1004d23a 	srli	r2,r2,8
 d040bfc:	10bfffcc 	andi	r2,r2,65535
 d040c00:	10c03fcc 	andi	r3,r2,255
 d040c04:	e0bfff17 	ldw	r2,-4(fp)
 d040c08:	1080018b 	ldhu	r2,6(r2)
 d040c0c:	10bfffcc 	andi	r2,r2,65535
 d040c10:	1004923a 	slli	r2,r2,8
 d040c14:	10bfc00c 	andi	r2,r2,65280
 d040c18:	1884b03a 	or	r2,r3,r2
 d040c1c:	1088000c 	andi	r2,r2,8192
 d040c20:	1005d37a 	srai	r2,r2,13
 d040c24:	e0bffe8d 	sth	r2,-6(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 d040c28:	e0bfff17 	ldw	r2,-4(fp)
 d040c2c:	1080018b 	ldhu	r2,6(r2)
 d040c30:	10bfffcc 	andi	r2,r2,65535
 d040c34:	1004d23a 	srli	r2,r2,8
 d040c38:	10803fcc 	andi	r2,r2,255
 d040c3c:	1009883a 	mov	r4,r2
 d040c40:	e0bfff17 	ldw	r2,-4(fp)
 d040c44:	1080018b 	ldhu	r2,6(r2)
 d040c48:	10bfffcc 	andi	r2,r2,65535
 d040c4c:	1004923a 	slli	r2,r2,8
 d040c50:	1007883a 	mov	r3,r2
 d040c54:	00bfc004 	movi	r2,-256
 d040c58:	1884703a 	and	r2,r3,r2
 d040c5c:	2084b03a 	or	r2,r4,r2
 d040c60:	1087ffcc 	andi	r2,r2,8191
 d040c64:	e0bffe0d 	sth	r2,-8(fp)

  if (mf == 0)
 d040c68:	e0bffe8b 	ldhu	r2,-6(fp)
 d040c6c:	1004c03a 	cmpne	r2,r2,zero
 d040c70:	1000081e 	bne	r2,zero,d040c94 <ip_reasm_determine_type_of_frag+0xb8>
     {
     if (foff == 0) {rc = IP_CP;}
 d040c74:	e0bffe0b 	ldhu	r2,-8(fp)
 d040c78:	1004c03a 	cmpne	r2,r2,zero
 d040c7c:	1000021e 	bne	r2,zero,d040c88 <ip_reasm_determine_type_of_frag+0xac>
 d040c80:	e03ffd15 	stw	zero,-12(fp)
 d040c84:	00000b06 	br	d040cb4 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_LF;}
 d040c88:	00800144 	movi	r2,5
 d040c8c:	e0bffd15 	stw	r2,-12(fp)
 d040c90:	00000806 	br	d040cb4 <ip_reasm_determine_type_of_frag+0xd8>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 d040c94:	e0bffe0b 	ldhu	r2,-8(fp)
 d040c98:	1004c03a 	cmpne	r2,r2,zero
 d040c9c:	1000031e 	bne	r2,zero,d040cac <ip_reasm_determine_type_of_frag+0xd0>
 d040ca0:	00800044 	movi	r2,1
 d040ca4:	e0bffd15 	stw	r2,-12(fp)
 d040ca8:	00000206 	br	d040cb4 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_MF;}
 d040cac:	008000c4 	movi	r2,3
 d040cb0:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 d040cb4:	e0bffd17 	ldw	r2,-12(fp)
}
 d040cb8:	e037883a 	mov	sp,fp
 d040cbc:	df000017 	ldw	fp,0(sp)
 d040cc0:	dec00104 	addi	sp,sp,4
 d040cc4:	f800283a 	ret

0d040cc8 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 d040cc8:	defffd04 	addi	sp,sp,-12
 d040ccc:	df000215 	stw	fp,8(sp)
 d040cd0:	df000204 	addi	fp,sp,8
 d040cd4:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 d040cd8:	d0e94617 	ldw	r3,-23272(gp)
 d040cdc:	008001b4 	movhi	r2,6
 d040ce0:	10c0072e 	bgeu	r2,r3,d040d00 <ip_reasm_check_mem_useage+0x38>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 d040ce4:	008341b4 	movhi	r2,3334
 d040ce8:	10857c04 	addi	r2,r2,5616
 d040cec:	10800217 	ldw	r2,8(r2)
 d040cf0:	10c00044 	addi	r3,r2,1
 d040cf4:	008341b4 	movhi	r2,3334
 d040cf8:	10857c04 	addi	r2,r2,5616
 d040cfc:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 d040d00:	d0e94617 	ldw	r3,-23272(gp)
 d040d04:	008001b4 	movhi	r2,6
 d040d08:	18800526 	beq	r3,r2,d040d20 <ip_reasm_check_mem_useage+0x58>
 d040d0c:	e0fffe0b 	ldhu	r3,-8(fp)
 d040d10:	d0a94617 	ldw	r2,-23272(gp)
 d040d14:	1887883a 	add	r3,r3,r2
 d040d18:	008001b4 	movhi	r2,6
 d040d1c:	10c00a2e 	bgeu	r2,r3,d040d48 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 d040d20:	008341b4 	movhi	r2,3334
 d040d24:	10857c04 	addi	r2,r2,5616
 d040d28:	10800317 	ldw	r2,12(r2)
 d040d2c:	10c00044 	addi	r3,r2,1
 d040d30:	008341b4 	movhi	r2,3334
 d040d34:	10857c04 	addi	r2,r2,5616
 d040d38:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 d040d3c:	00bffa84 	movi	r2,-22
 d040d40:	e0bfff15 	stw	r2,-4(fp)
 d040d44:	00000106 	br	d040d4c <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 d040d48:	e03fff15 	stw	zero,-4(fp)
 d040d4c:	e0bfff17 	ldw	r2,-4(fp)
}
 d040d50:	e037883a 	mov	sp,fp
 d040d54:	df000017 	ldw	fp,0(sp)
 d040d58:	dec00104 	addi	sp,sp,4
 d040d5c:	f800283a 	ret

0d040d60 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 d040d60:	defffd04 	addi	sp,sp,-12
 d040d64:	df000215 	stw	fp,8(sp)
 d040d68:	df000204 	addi	fp,sp,8
 d040d6c:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 d040d70:	d0e94617 	ldw	r3,-23272(gp)
 d040d74:	008001b4 	movhi	r2,6
 d040d78:	10c00a2e 	bgeu	r2,r3,d040da4 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 d040d7c:	008341b4 	movhi	r2,3334
 d040d80:	10857c04 	addi	r2,r2,5616
 d040d84:	10800217 	ldw	r2,8(r2)
 d040d88:	10c00044 	addi	r3,r2,1
 d040d8c:	008341b4 	movhi	r2,3334
 d040d90:	10857c04 	addi	r2,r2,5616
 d040d94:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 d040d98:	00bffa84 	movi	r2,-22
 d040d9c:	e0bfff15 	stw	r2,-4(fp)
 d040da0:	00001406 	br	d040df4 <ip_reasm_incr_mem_useage+0x94>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 d040da4:	e0fffe0b 	ldhu	r3,-8(fp)
 d040da8:	d0a94617 	ldw	r2,-23272(gp)
 d040dac:	1887883a 	add	r3,r3,r2
 d040db0:	008001b4 	movhi	r2,6
 d040db4:	10c00a2e 	bgeu	r2,r3,d040de0 <ip_reasm_incr_mem_useage+0x80>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 d040db8:	008341b4 	movhi	r2,3334
 d040dbc:	10857c04 	addi	r2,r2,5616
 d040dc0:	10800417 	ldw	r2,16(r2)
 d040dc4:	10c00044 	addi	r3,r2,1
 d040dc8:	008341b4 	movhi	r2,3334
 d040dcc:	10857c04 	addi	r2,r2,5616
 d040dd0:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 d040dd4:	00bffa84 	movi	r2,-22
 d040dd8:	e0bfff15 	stw	r2,-4(fp)
 d040ddc:	00000506 	br	d040df4 <ip_reasm_incr_mem_useage+0x94>
   }

   ipr_curr_mem += increment;
 d040de0:	e0bffe0b 	ldhu	r2,-8(fp)
 d040de4:	d0e94617 	ldw	r3,-23272(gp)
 d040de8:	10c5883a 	add	r2,r2,r3
 d040dec:	d0a94615 	stw	r2,-23272(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 d040df0:	e03fff15 	stw	zero,-4(fp)
 d040df4:	e0bfff17 	ldw	r2,-4(fp)
}
 d040df8:	e037883a 	mov	sp,fp
 d040dfc:	df000017 	ldw	fp,0(sp)
 d040e00:	dec00104 	addi	sp,sp,4
 d040e04:	f800283a 	ret

0d040e08 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 d040e08:	defffd04 	addi	sp,sp,-12
 d040e0c:	df000215 	stw	fp,8(sp)
 d040e10:	df000204 	addi	fp,sp,8
 d040e14:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 d040e18:	d0e94617 	ldw	r3,-23272(gp)
 d040e1c:	008001b4 	movhi	r2,6
 d040e20:	10c00a2e 	bgeu	r2,r3,d040e4c <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 d040e24:	008341b4 	movhi	r2,3334
 d040e28:	10857c04 	addi	r2,r2,5616
 d040e2c:	10800217 	ldw	r2,8(r2)
 d040e30:	10c00044 	addi	r3,r2,1
 d040e34:	008341b4 	movhi	r2,3334
 d040e38:	10857c04 	addi	r2,r2,5616
 d040e3c:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 d040e40:	00bffa84 	movi	r2,-22
 d040e44:	e0bfff15 	stw	r2,-4(fp)
 d040e48:	00001206 	br	d040e94 <ip_reasm_decr_mem_useage+0x8c>
   }
   if (ipr_curr_mem < decrement)
 d040e4c:	e0fffe0b 	ldhu	r3,-8(fp)
 d040e50:	d0a94617 	ldw	r2,-23272(gp)
 d040e54:	10c00a2e 	bgeu	r2,r3,d040e80 <ip_reasm_decr_mem_useage+0x78>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 d040e58:	008341b4 	movhi	r2,3334
 d040e5c:	10857c04 	addi	r2,r2,5616
 d040e60:	10800517 	ldw	r2,20(r2)
 d040e64:	10c00044 	addi	r3,r2,1
 d040e68:	008341b4 	movhi	r2,3334
 d040e6c:	10857c04 	addi	r2,r2,5616
 d040e70:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 d040e74:	00bffa84 	movi	r2,-22
 d040e78:	e0bfff15 	stw	r2,-4(fp)
 d040e7c:	00000506 	br	d040e94 <ip_reasm_decr_mem_useage+0x8c>
   }

   ipr_curr_mem -= decrement;
 d040e80:	d0a94617 	ldw	r2,-23272(gp)
 d040e84:	e0fffe0b 	ldhu	r3,-8(fp)
 d040e88:	10c5c83a 	sub	r2,r2,r3
 d040e8c:	d0a94615 	stw	r2,-23272(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 d040e90:	e03fff15 	stw	zero,-4(fp)
 d040e94:	e0bfff17 	ldw	r2,-4(fp)
}
 d040e98:	e037883a 	mov	sp,fp
 d040e9c:	df000017 	ldw	fp,0(sp)
 d040ea0:	dec00104 	addi	sp,sp,4
 d040ea4:	f800283a 	ret

0d040ea8 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 d040ea8:	defff604 	addi	sp,sp,-40
 d040eac:	dfc00915 	stw	ra,36(sp)
 d040eb0:	df000815 	stw	fp,32(sp)
 d040eb4:	df000804 	addi	fp,sp,32
 d040eb8:	e13ffe15 	stw	r4,-8(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 d040ebc:	e0bffe17 	ldw	r2,-8(fp)
 d040ec0:	10800217 	ldw	r2,8(r2)
 d040ec4:	10802204 	addi	r2,r2,136
 d040ec8:	113fffcc 	andi	r4,r2,65535
 d040ecc:	d040cc80 	call	d040cc8 <ip_reasm_check_mem_useage>
 d040ed0:	e0bff815 	stw	r2,-32(fp)
 d040ed4:	e0bff817 	ldw	r2,-32(fp)
 d040ed8:	1005003a 	cmpeq	r2,r2,zero
 d040edc:	1000101e 	bne	r2,zero,d040f20 <ip_reasm_process_first_fragment+0x78>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d040ee0:	01000084 	movi	r4,2
 d040ee4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free (p);
 d040ee8:	e13ffe17 	ldw	r4,-8(fp)
 d040eec:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d040ef0:	01000084 	movi	r4,2
 d040ef4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 d040ef8:	008341b4 	movhi	r2,3334
 d040efc:	10856804 	addi	r2,r2,5536
 d040f00:	10800f17 	ldw	r2,60(r2)
 d040f04:	10c00044 	addi	r3,r2,1
 d040f08:	008341b4 	movhi	r2,3334
 d040f0c:	10856804 	addi	r2,r2,5536
 d040f10:	10c00f15 	stw	r3,60(r2)
      return rc;
 d040f14:	e0bff817 	ldw	r2,-32(fp)
 d040f18:	e0bfff15 	stw	r2,-4(fp)
 d040f1c:	00009406 	br	d041170 <ip_reasm_process_first_fragment+0x2c8>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 d040f20:	01002204 	movi	r4,136
 d040f24:	d0264b80 	call	d0264b8 <npalloc>
 d040f28:	e0bffc15 	stw	r2,-16(fp)
   if (irep == 0) 
 d040f2c:	e0bffc17 	ldw	r2,-16(fp)
 d040f30:	1004c03a 	cmpne	r2,r2,zero
 d040f34:	1000101e 	bne	r2,zero,d040f78 <ip_reasm_process_first_fragment+0xd0>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d040f38:	01000084 	movi	r4,2
 d040f3c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free (p);
 d040f40:	e13ffe17 	ldw	r4,-8(fp)
 d040f44:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d040f48:	01000084 	movi	r4,2
 d040f4c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 d040f50:	008341b4 	movhi	r2,3334
 d040f54:	10856804 	addi	r2,r2,5536
 d040f58:	10800f17 	ldw	r2,60(r2)
 d040f5c:	10c00044 	addi	r3,r2,1
 d040f60:	008341b4 	movhi	r2,3334
 d040f64:	10856804 	addi	r2,r2,5536
 d040f68:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 d040f6c:	00bffa84 	movi	r2,-22
 d040f70:	e0bfff15 	stw	r2,-4(fp)
 d040f74:	00007e06 	br	d041170 <ip_reasm_process_first_fragment+0x2c8>
   }

   pip = ip_head(p);
 d040f78:	e0bffe17 	ldw	r2,-8(fp)
 d040f7c:	10800317 	ldw	r2,12(r2)
 d040f80:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen(pip);
 d040f84:	e0bffd17 	ldw	r2,-12(fp)
 d040f88:	10800003 	ldbu	r2,0(r2)
 d040f8c:	108003cc 	andi	r2,r2,15
 d040f90:	1085883a 	add	r2,r2,r2
 d040f94:	1085883a 	add	r2,r2,r2
 d040f98:	e0bffa05 	stb	r2,-24(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 d040f9c:	e13ffd17 	ldw	r4,-12(fp)
 d040fa0:	d040bdc0 	call	d040bdc <ip_reasm_determine_type_of_frag>
 d040fa4:	e0bffb15 	stw	r2,-20(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 d040fa8:	e0bffd17 	ldw	r2,-12(fp)
 d040fac:	1080018b 	ldhu	r2,6(r2)
 d040fb0:	10bfffcc 	andi	r2,r2,65535
 d040fb4:	1004d23a 	srli	r2,r2,8
 d040fb8:	10803fcc 	andi	r2,r2,255
 d040fbc:	1009883a 	mov	r4,r2
 d040fc0:	e0bffd17 	ldw	r2,-12(fp)
 d040fc4:	1080018b 	ldhu	r2,6(r2)
 d040fc8:	10bfffcc 	andi	r2,r2,65535
 d040fcc:	1004923a 	slli	r2,r2,8
 d040fd0:	1007883a 	mov	r3,r2
 d040fd4:	00bfc004 	movi	r2,-256
 d040fd8:	1884703a 	and	r2,r3,r2
 d040fdc:	2084b03a 	or	r2,r4,r2
 d040fe0:	1087ffcc 	andi	r2,r2,8191
 d040fe4:	100490fa 	slli	r2,r2,3
 d040fe8:	e0bff98d 	sth	r2,-26(fp)
   total_len = ntohs(pip->ip_len);
 d040fec:	e0bffd17 	ldw	r2,-12(fp)
 d040ff0:	1080008b 	ldhu	r2,2(r2)
 d040ff4:	10bfffcc 	andi	r2,r2,65535
 d040ff8:	1004d23a 	srli	r2,r2,8
 d040ffc:	10803fcc 	andi	r2,r2,255
 d041000:	1009883a 	mov	r4,r2
 d041004:	e0bffd17 	ldw	r2,-12(fp)
 d041008:	1080008b 	ldhu	r2,2(r2)
 d04100c:	10bfffcc 	andi	r2,r2,65535
 d041010:	1004923a 	slli	r2,r2,8
 d041014:	1007883a 	mov	r3,r2
 d041018:	00bfc004 	movi	r2,-256
 d04101c:	1884703a 	and	r2,r3,r2
 d041020:	2084b03a 	or	r2,r4,r2
 d041024:	e0bff90d 	sth	r2,-28(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 d041028:	e0bffd17 	ldw	r2,-12(fp)
 d04102c:	10c00317 	ldw	r3,12(r2)
 d041030:	e0bffc17 	ldw	r2,-16(fp)
 d041034:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 d041038:	e0bffd17 	ldw	r2,-12(fp)
 d04103c:	10c00417 	ldw	r3,16(r2)
 d041040:	e0bffc17 	ldw	r2,-16(fp)
 d041044:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 d041048:	e0bffd17 	ldw	r2,-12(fp)
 d04104c:	10c00243 	ldbu	r3,9(r2)
 d041050:	e0bffc17 	ldw	r2,-16(fp)
 d041054:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 d041058:	e0bffd17 	ldw	r2,-12(fp)
 d04105c:	10c0010b 	ldhu	r3,4(r2)
 d041060:	e0bffc17 	ldw	r2,-16(fp)
 d041064:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 d041068:	e0bffb17 	ldw	r2,-20(fp)
 d04106c:	10800158 	cmpnei	r2,r2,5
 d041070:	10000a1e 	bne	r2,zero,d04109c <ip_reasm_process_first_fragment+0x1f4>
      {
      irep->length = frag_offset + (total_len - iphlen);
 d041074:	e0fffa03 	ldbu	r3,-24(fp)
 d041078:	e0bff90b 	ldhu	r2,-28(fp)
 d04107c:	10c5c83a 	sub	r2,r2,r3
 d041080:	1007883a 	mov	r3,r2
 d041084:	e0bff98b 	ldhu	r2,-26(fp)
 d041088:	1885883a 	add	r2,r3,r2
 d04108c:	1007883a 	mov	r3,r2
 d041090:	e0bffc17 	ldw	r2,-16(fp)
 d041094:	10c0040d 	sth	r3,16(r2)
 d041098:	00000a06 	br	d0410c4 <ip_reasm_process_first_fragment+0x21c>
      }
   else if (ftype == IP_FF)
 d04109c:	e0bffb17 	ldw	r2,-20(fp)
 d0410a0:	10800058 	cmpnei	r2,r2,1
 d0410a4:	1000071e 	bne	r2,zero,d0410c4 <ip_reasm_process_first_fragment+0x21c>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 d0410a8:	e0bffe17 	ldw	r2,-8(fp)
 d0410ac:	10c00117 	ldw	r3,4(r2)
 d0410b0:	e0bffc17 	ldw	r2,-16(fp)
 d0410b4:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 d0410b8:	e0fffd17 	ldw	r3,-12(fp)
 d0410bc:	e0bffc17 	ldw	r2,-16(fp)
 d0410c0:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 d0410c4:	e0fffa03 	ldbu	r3,-24(fp)
 d0410c8:	e0bff90b 	ldhu	r2,-28(fp)
 d0410cc:	10c5c83a 	sub	r2,r2,r3
 d0410d0:	1007883a 	mov	r3,r2
 d0410d4:	e0bffc17 	ldw	r2,-16(fp)
 d0410d8:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 d0410dc:	e0bffc17 	ldw	r2,-16(fp)
 d0410e0:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 d0410e4:	e0bffc17 	ldw	r2,-16(fp)
 d0410e8:	10802103 	ldbu	r2,132(r2)
 d0410ec:	10800054 	ori	r2,r2,1
 d0410f0:	1007883a 	mov	r3,r2
 d0410f4:	e0bffc17 	ldw	r2,-16(fp)
 d0410f8:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 d0410fc:	e0fffc17 	ldw	r3,-16(fp)
 d041100:	e0bffe17 	ldw	r2,-8(fp)
 d041104:	18800715 	stw	r2,28(r3)
   irep->rfq.frag_offset[0] = frag_offset;
 d041108:	e0fffc17 	ldw	r3,-16(fp)
 d04110c:	e0bff98b 	ldhu	r2,-26(fp)
 d041110:	1880170d 	sth	r2,92(r3)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 d041114:	e0bffe17 	ldw	r2,-8(fp)
 d041118:	10c00317 	ldw	r3,12(r2)
 d04111c:	e0bffa03 	ldbu	r2,-24(fp)
 d041120:	1887883a 	add	r3,r3,r2
 d041124:	e0bffe17 	ldw	r2,-8(fp)
 d041128:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 d04112c:	e0bffe17 	ldw	r2,-8(fp)
 d041130:	10c00417 	ldw	r3,16(r2)
 d041134:	e0bffa03 	ldbu	r2,-24(fp)
 d041138:	1887c83a 	sub	r3,r3,r2
 d04113c:	e0bffe17 	ldw	r2,-8(fp)
 d041140:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 d041144:	d0e94717 	ldw	r3,-23268(gp)
 d041148:	e0bffc17 	ldw	r2,-16(fp)
 d04114c:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 d041150:	e0bffc17 	ldw	r2,-16(fp)
 d041154:	d0a94715 	stw	r2,-23268(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 d041158:	e0bffe17 	ldw	r2,-8(fp)
 d04115c:	10800217 	ldw	r2,8(r2)
 d041160:	10802204 	addi	r2,r2,136
 d041164:	113fffcc 	andi	r4,r2,65535
 d041168:	d040d600 	call	d040d60 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 d04116c:	e03fff15 	stw	zero,-4(fp)
 d041170:	e0bfff17 	ldw	r2,-4(fp)
}
 d041174:	e037883a 	mov	sp,fp
 d041178:	dfc00117 	ldw	ra,4(sp)
 d04117c:	df000017 	ldw	fp,0(sp)
 d041180:	dec00204 	addi	sp,sp,8
 d041184:	f800283a 	ret

0d041188 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 d041188:	defff804 	addi	sp,sp,-32
 d04118c:	dfc00715 	stw	ra,28(sp)
 d041190:	df000615 	stw	fp,24(sp)
 d041194:	df000604 	addi	fp,sp,24
 d041198:	e13ffe15 	stw	r4,-8(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 d04119c:	e0bffe17 	ldw	r2,-8(fp)
 d0411a0:	10800317 	ldw	r2,12(r2)
 d0411a4:	e0bffc15 	stw	r2,-16(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 d0411a8:	e13ffc17 	ldw	r4,-16(fp)
 d0411ac:	d040b0c0 	call	d040b0c <ip_reasm_match_frag_with_ire>
 d0411b0:	e0bffd15 	stw	r2,-12(fp)

   if (!irep)
 d0411b4:	e0bffd17 	ldw	r2,-12(fp)
 d0411b8:	1004c03a 	cmpne	r2,r2,zero
 d0411bc:	1000091e 	bne	r2,zero,d0411e4 <ip_reassm+0x5c>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 d0411c0:	e13ffe17 	ldw	r4,-8(fp)
 d0411c4:	d040ea80 	call	d040ea8 <ip_reasm_process_first_fragment>
 d0411c8:	e0bffb15 	stw	r2,-20(fp)
 d0411cc:	e0bffb17 	ldw	r2,-20(fp)
 d0411d0:	1005003a 	cmpeq	r2,r2,zero
 d0411d4:	10000d1e 	bne	r2,zero,d04120c <ip_reassm+0x84>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 d0411d8:	e0bffb17 	ldw	r2,-20(fp)
 d0411dc:	e0bfff15 	stw	r2,-4(fp)
 d0411e0:	00000b06 	br	d041210 <ip_reassm+0x88>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 d0411e4:	e13ffe17 	ldw	r4,-8(fp)
 d0411e8:	e17ffd17 	ldw	r5,-12(fp)
 d0411ec:	d0417b80 	call	d0417b8 <ip_reasm_process_subsequent_fragments>
 d0411f0:	e0bffa15 	stw	r2,-24(fp)
 d0411f4:	e0bffa17 	ldw	r2,-24(fp)
 d0411f8:	1005003a 	cmpeq	r2,r2,zero
 d0411fc:	1000031e 	bne	r2,zero,d04120c <ip_reassm+0x84>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 d041200:	e0bffa17 	ldw	r2,-24(fp)
 d041204:	e0bfff15 	stw	r2,-4(fp)
 d041208:	00000106 	br	d041210 <ip_reassm+0x88>
      }
   }

   return IPREASM_OK;
 d04120c:	e03fff15 	stw	zero,-4(fp)
 d041210:	e0bfff17 	ldw	r2,-4(fp)
}
 d041214:	e037883a 	mov	sp,fp
 d041218:	dfc00117 	ldw	ra,4(sp)
 d04121c:	df000017 	ldw	fp,0(sp)
 d041220:	dec00204 	addi	sp,sp,8
 d041224:	f800283a 	ret

0d041228 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 d041228:	defff204 	addi	sp,sp,-56
 d04122c:	dfc00d15 	stw	ra,52(sp)
 d041230:	df000c15 	stw	fp,48(sp)
 d041234:	df000c04 	addi	fp,sp,48
 d041238:	e13ffb15 	stw	r4,-20(fp)
 d04123c:	e17ffc15 	stw	r5,-16(fp)
 d041240:	e1bffd15 	stw	r6,-12(fp)
 d041244:	e1fffe15 	stw	r7,-8(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 d041248:	e13ffc17 	ldw	r4,-16(fp)
 d04124c:	d041d4c0 	call	d041d4c <ip_reasm_find_ire>
 d041250:	10803fcc 	andi	r2,r2,255
 d041254:	10800060 	cmpeqi	r2,r2,1
 d041258:	1000101e 	bne	r2,zero,d04129c <ip_reasm_compute_overlap+0x74>
      {
      ++ire_stats.bad_irep;
 d04125c:	008341b4 	movhi	r2,3334
 d041260:	10857c04 	addi	r2,r2,5616
 d041264:	10800017 	ldw	r2,0(r2)
 d041268:	10c00044 	addi	r3,r2,1
 d04126c:	008341b4 	movhi	r2,3334
 d041270:	10857c04 	addi	r2,r2,5616
 d041274:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d041278:	01000084 	movi	r4,2
 d04127c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free (p);
 d041280:	e13ffb17 	ldw	r4,-20(fp)
 d041284:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041288:	01000084 	movi	r4,2
 d04128c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 d041290:	00800044 	movi	r2,1
 d041294:	e0bfff15 	stw	r2,-4(fp)
 d041298:	00014106 	br	d0417a0 <ip_reasm_compute_overlap+0x578>
      }

   jrip = ip_head(p);
 d04129c:	e0bffb17 	ldw	r2,-20(fp)
 d0412a0:	10800317 	ldw	r2,12(r2)
 d0412a4:	e0bff815 	stw	r2,-32(fp)
   iphlen = ip_hlen (jrip);
 d0412a8:	e0bff817 	ldw	r2,-32(fp)
 d0412ac:	10800003 	ldbu	r2,0(r2)
 d0412b0:	108003cc 	andi	r2,r2,15
 d0412b4:	1085883a 	add	r2,r2,r2
 d0412b8:	1085883a 	add	r2,r2,r2
 d0412bc:	e0bff485 	stb	r2,-46(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 d0412c0:	e0bff817 	ldw	r2,-32(fp)
 d0412c4:	1080018b 	ldhu	r2,6(r2)
 d0412c8:	10bfffcc 	andi	r2,r2,65535
 d0412cc:	1004d23a 	srli	r2,r2,8
 d0412d0:	10803fcc 	andi	r2,r2,255
 d0412d4:	1009883a 	mov	r4,r2
 d0412d8:	e0bff817 	ldw	r2,-32(fp)
 d0412dc:	1080018b 	ldhu	r2,6(r2)
 d0412e0:	10bfffcc 	andi	r2,r2,65535
 d0412e4:	1004923a 	slli	r2,r2,8
 d0412e8:	1007883a 	mov	r3,r2
 d0412ec:	00bfc004 	movi	r2,-256
 d0412f0:	1884703a 	and	r2,r3,r2
 d0412f4:	2084b03a 	or	r2,r4,r2
 d0412f8:	1087ffcc 	andi	r2,r2,8191
 d0412fc:	100490fa 	slli	r2,r2,3
 d041300:	e0bff70d 	sth	r2,-36(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 d041304:	e0bff817 	ldw	r2,-32(fp)
 d041308:	1080008b 	ldhu	r2,2(r2)
 d04130c:	10bfffcc 	andi	r2,r2,65535
 d041310:	1004d23a 	srli	r2,r2,8
 d041314:	10803fcc 	andi	r2,r2,255
 d041318:	1009883a 	mov	r4,r2
 d04131c:	e0bff817 	ldw	r2,-32(fp)
 d041320:	1080008b 	ldhu	r2,2(r2)
 d041324:	10bfffcc 	andi	r2,r2,65535
 d041328:	1004923a 	slli	r2,r2,8
 d04132c:	1007883a 	mov	r3,r2
 d041330:	00bfc004 	movi	r2,-256
 d041334:	1884703a 	and	r2,r3,r2
 d041338:	2084b03a 	or	r2,r4,r2
 d04133c:	1007883a 	mov	r3,r2
 d041340:	e0bff483 	ldbu	r2,-46(fp)
 d041344:	1885c83a 	sub	r2,r3,r2
 d041348:	1007883a 	mov	r3,r2
 d04134c:	e0bff70b 	ldhu	r2,-36(fp)
 d041350:	1885883a 	add	r2,r3,r2
 d041354:	10bfffc4 	addi	r2,r2,-1
 d041358:	e0bff68d 	sth	r2,-38(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 d04135c:	e0bffb17 	ldw	r2,-20(fp)
 d041360:	10c00317 	ldw	r3,12(r2)
 d041364:	e0bff483 	ldbu	r2,-46(fp)
 d041368:	1887883a 	add	r3,r3,r2
 d04136c:	e0bffb17 	ldw	r2,-20(fp)
 d041370:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 d041374:	e0bffb17 	ldw	r2,-20(fp)
 d041378:	10c00417 	ldw	r3,16(r2)
 d04137c:	e0bff483 	ldbu	r2,-46(fp)
 d041380:	1887c83a 	sub	r3,r3,r2
 d041384:	e0bffb17 	ldw	r2,-20(fp)
 d041388:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 d04138c:	e0c00217 	ldw	r3,8(fp)
 d041390:	e0bff70b 	ldhu	r2,-36(fp)
 d041394:	1880000d 	sth	r2,0(r3)
   *indexp = INVALID_FRAG_INDEX;
 d041398:	e0fffd17 	ldw	r3,-12(fp)
 d04139c:	00800404 	movi	r2,16
 d0413a0:	1880000d 	sth	r2,0(r3)
   *last_rfqpp = 0;
 d0413a4:	e0bffe17 	ldw	r2,-8(fp)
 d0413a8:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 d0413ac:	e0800317 	ldw	r2,12(fp)
 d0413b0:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 d0413b4:	e0bffc17 	ldw	r2,-16(fp)
 d0413b8:	10800604 	addi	r2,r2,24
 d0413bc:	e0bffa15 	stw	r2,-24(fp)

   while (rfqp)
 d0413c0:	0000ef06 	br	d041780 <ip_reasm_compute_overlap+0x558>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d0413c4:	e03ff40d 	sth	zero,-48(fp)
 d0413c8:	0000df06 	br	d041748 <ip_reasm_compute_overlap+0x520>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 d0413cc:	e0bff40b 	ldhu	r2,-48(fp)
 d0413d0:	e0fffa17 	ldw	r3,-24(fp)
 d0413d4:	1085883a 	add	r2,r2,r2
 d0413d8:	1085883a 	add	r2,r2,r2
 d0413dc:	10c5883a 	add	r2,r2,r3
 d0413e0:	10800104 	addi	r2,r2,4
 d0413e4:	10800017 	ldw	r2,0(r2)
 d0413e8:	e0bff915 	stw	r2,-28(fp)
 d0413ec:	e0bff917 	ldw	r2,-28(fp)
 d0413f0:	1005003a 	cmpeq	r2,r2,zero
 d0413f4:	1000bf1e 	bne	r2,zero,d0416f4 <ip_reasm_compute_overlap+0x4cc>
            {
            currstart = rfqp->frag_offset[i];
 d0413f8:	e0bff40b 	ldhu	r2,-48(fp)
 d0413fc:	e0fffa17 	ldw	r3,-24(fp)
 d041400:	1085883a 	add	r2,r2,r2
 d041404:	10c5883a 	add	r2,r2,r3
 d041408:	10801104 	addi	r2,r2,68
 d04140c:	1080000b 	ldhu	r2,0(r2)
 d041410:	e0bff60d 	sth	r2,-40(fp)
            currend = currstart + currpkt->nb_plen - 1;
 d041414:	e0bff917 	ldw	r2,-28(fp)
 d041418:	10800417 	ldw	r2,16(r2)
 d04141c:	1007883a 	mov	r3,r2
 d041420:	e0bff60b 	ldhu	r2,-40(fp)
 d041424:	1885883a 	add	r2,r3,r2
 d041428:	10bfffc4 	addi	r2,r2,-1
 d04142c:	e0bff58d 	sth	r2,-42(fp)

            if (currstart < jrstart)
 d041430:	e0fff60b 	ldhu	r3,-40(fp)
 d041434:	e0bff70b 	ldhu	r2,-36(fp)
 d041438:	18802b2e 	bgeu	r3,r2,d0414e8 <ip_reasm_compute_overlap+0x2c0>
               {
               if (currend < jrend) /* cases A1 and A2 */
 d04143c:	e0fff58b 	ldhu	r3,-42(fp)
 d041440:	e0bff68b 	ldhu	r2,-38(fp)
 d041444:	1880202e 	bgeu	r3,r2,d0414c8 <ip_reasm_compute_overlap+0x2a0>
                  {
                  if (currend < jrstart) /* A1 */
 d041448:	e0fff58b 	ldhu	r3,-42(fp)
 d04144c:	e0bff70b 	ldhu	r2,-36(fp)
 d041450:	1880ba36 	bltu	r3,r2,d04173c <ip_reasm_compute_overlap+0x514>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 d041454:	e0fff58b 	ldhu	r3,-42(fp)
 d041458:	e0bff70b 	ldhu	r2,-36(fp)
 d04145c:	1885c83a 	sub	r2,r3,r2
 d041460:	10800044 	addi	r2,r2,1
 d041464:	e0bff50d 	sth	r2,-44(fp)
                     p->nb_prot += drop_len;
 d041468:	e0bffb17 	ldw	r2,-20(fp)
 d04146c:	10c00317 	ldw	r3,12(r2)
 d041470:	e0bff50b 	ldhu	r2,-44(fp)
 d041474:	1887883a 	add	r3,r3,r2
 d041478:	e0bffb17 	ldw	r2,-20(fp)
 d04147c:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 d041480:	e0bffb17 	ldw	r2,-20(fp)
 d041484:	10c00417 	ldw	r3,16(r2)
 d041488:	e0bff50b 	ldhu	r2,-44(fp)
 d04148c:	1887c83a 	sub	r3,r3,r2
 d041490:	e0bffb17 	ldw	r2,-20(fp)
 d041494:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 d041498:	e0fff70b 	ldhu	r3,-36(fp)
 d04149c:	e0bff50b 	ldhu	r2,-44(fp)
 d0414a0:	1885883a 	add	r2,r3,r2
 d0414a4:	e0bff70d 	sth	r2,-36(fp)
                     jrend = jrstart + p->nb_plen - 1;
 d0414a8:	e0bffb17 	ldw	r2,-20(fp)
 d0414ac:	10800417 	ldw	r2,16(r2)
 d0414b0:	1007883a 	mov	r3,r2
 d0414b4:	e0bff70b 	ldhu	r2,-36(fp)
 d0414b8:	1885883a 	add	r2,r3,r2
 d0414bc:	10bfffc4 	addi	r2,r2,-1
 d0414c0:	e0bff68d 	sth	r2,-38(fp)
 d0414c4:	00009d06 	br	d04173c <ip_reasm_compute_overlap+0x514>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d0414c8:	01000084 	movi	r4,2
 d0414cc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
                  pk_free (p);
 d0414d0:	e13ffb17 	ldw	r4,-20(fp)
 d0414d4:	d0251a00 	call	d0251a0 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d0414d8:	01000084 	movi	r4,2
 d0414dc:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 d0414e0:	e03fff15 	stw	zero,-4(fp)
 d0414e4:	0000ae06 	br	d0417a0 <ip_reasm_compute_overlap+0x578>
                  }
               }
            else if (currstart > jrstart)
 d0414e8:	e0fff60b 	ldhu	r3,-40(fp)
 d0414ec:	e0bff70b 	ldhu	r2,-36(fp)
 d0414f0:	10c04d2e 	bgeu	r2,r3,d041628 <ip_reasm_compute_overlap+0x400>
               {
               if (currend > jrend) /* cases B1 and B2 */
 d0414f4:	e0fff58b 	ldhu	r3,-42(fp)
 d0414f8:	e0bff68b 	ldhu	r2,-38(fp)
 d0414fc:	10c0112e 	bgeu	r2,r3,d041544 <ip_reasm_compute_overlap+0x31c>
                  {
                  if (currstart > jrend) /* B1 */
 d041500:	e0fff60b 	ldhu	r3,-40(fp)
 d041504:	e0bff68b 	ldhu	r2,-38(fp)
 d041508:	10c08c36 	bltu	r2,r3,d04173c <ip_reasm_compute_overlap+0x514>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 d04150c:	e0fff60b 	ldhu	r3,-40(fp)
 d041510:	e0bff70b 	ldhu	r2,-36(fp)
 d041514:	1885c83a 	sub	r2,r3,r2
 d041518:	1007883a 	mov	r3,r2
 d04151c:	e0bffb17 	ldw	r2,-20(fp)
 d041520:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 d041524:	e0bffb17 	ldw	r2,-20(fp)
 d041528:	10800417 	ldw	r2,16(r2)
 d04152c:	1007883a 	mov	r3,r2
 d041530:	e0bff70b 	ldhu	r2,-36(fp)
 d041534:	1885883a 	add	r2,r3,r2
 d041538:	10bfffc4 	addi	r2,r2,-1
 d04153c:	e0bff68d 	sth	r2,-38(fp)
 d041540:	00007e06 	br	d04173c <ip_reasm_compute_overlap+0x514>
                     }
                  }
               else if (currend == jrend) /* F1 */
 d041544:	e0fff58b 	ldhu	r3,-42(fp)
 d041548:	e0bff68b 	ldhu	r2,-38(fp)
 d04154c:	18800e1e 	bne	r3,r2,d041588 <ip_reasm_compute_overlap+0x360>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 d041550:	e0fff60b 	ldhu	r3,-40(fp)
 d041554:	e0bff70b 	ldhu	r2,-36(fp)
 d041558:	1885c83a 	sub	r2,r3,r2
 d04155c:	1007883a 	mov	r3,r2
 d041560:	e0bffb17 	ldw	r2,-20(fp)
 d041564:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 d041568:	e0bffb17 	ldw	r2,-20(fp)
 d04156c:	10800417 	ldw	r2,16(r2)
 d041570:	1007883a 	mov	r3,r2
 d041574:	e0bff70b 	ldhu	r2,-36(fp)
 d041578:	1885883a 	add	r2,r3,r2
 d04157c:	10bfffc4 	addi	r2,r2,-1
 d041580:	e0bff68d 	sth	r2,-38(fp)
 d041584:	00006d06 	br	d04173c <ip_reasm_compute_overlap+0x514>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 d041588:	e0bff917 	ldw	r2,-28(fp)
 d04158c:	10800217 	ldw	r2,8(r2)
 d041590:	113fffcc 	andi	r4,r2,65535
 d041594:	d040e080 	call	d040e08 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 d041598:	e0bffc17 	ldw	r2,-16(fp)
 d04159c:	10c0048b 	ldhu	r3,18(r2)
 d0415a0:	e0bff917 	ldw	r2,-28(fp)
 d0415a4:	10800417 	ldw	r2,16(r2)
 d0415a8:	1885c83a 	sub	r2,r3,r2
 d0415ac:	1007883a 	mov	r3,r2
 d0415b0:	e0bffc17 	ldw	r2,-16(fp)
 d0415b4:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d0415b8:	01000084 	movi	r4,2
 d0415bc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 d0415c0:	e13ff917 	ldw	r4,-28(fp)
 d0415c4:	d0251a00 	call	d0251a0 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d0415c8:	01000084 	movi	r4,2
 d0415cc:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 d0415d0:	e0bff40b 	ldhu	r2,-48(fp)
 d0415d4:	e0fffa17 	ldw	r3,-24(fp)
 d0415d8:	1085883a 	add	r2,r2,r2
 d0415dc:	1085883a 	add	r2,r2,r2
 d0415e0:	10c5883a 	add	r2,r2,r3
 d0415e4:	10800104 	addi	r2,r2,4
 d0415e8:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 d0415ec:	e0bffd17 	ldw	r2,-12(fp)
 d0415f0:	1080000b 	ldhu	r2,0(r2)
 d0415f4:	10bfffcc 	andi	r2,r2,65535
 d0415f8:	10800418 	cmpnei	r2,r2,16
 d0415fc:	1000061e 	bne	r2,zero,d041618 <ip_reasm_compute_overlap+0x3f0>
                     {
                     *indexp = i;
 d041600:	e0fffd17 	ldw	r3,-12(fp)
 d041604:	e0bff40b 	ldhu	r2,-48(fp)
 d041608:	1880000d 	sth	r2,0(r3)
                     *last_rfqpp = rfqp;
 d04160c:	e0fffe17 	ldw	r3,-8(fp)
 d041610:	e0bffa17 	ldw	r2,-24(fp)
 d041614:	18800015 	stw	r2,0(r3)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 d041618:	e0c00317 	ldw	r3,12(fp)
 d04161c:	00800044 	movi	r2,1
 d041620:	18800005 	stb	r2,0(r3)
 d041624:	00004506 	br	d04173c <ip_reasm_compute_overlap+0x514>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 d041628:	e0fff58b 	ldhu	r3,-42(fp)
 d04162c:	e0bff68b 	ldhu	r2,-38(fp)
 d041630:	1880081e 	bne	r3,r2,d041654 <ip_reasm_compute_overlap+0x42c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d041634:	01000084 	movi	r4,2
 d041638:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
                  pk_free (p);
 d04163c:	e13ffb17 	ldw	r4,-20(fp)
 d041640:	d0251a00 	call	d0251a0 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041644:	01000084 	movi	r4,2
 d041648:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 d04164c:	e03fff15 	stw	zero,-4(fp)
 d041650:	00005306 	br	d0417a0 <ip_reasm_compute_overlap+0x578>
                  }
               else if (currend > jrend) /* case D1 */
 d041654:	e0fff58b 	ldhu	r3,-42(fp)
 d041658:	e0bff68b 	ldhu	r2,-38(fp)
 d04165c:	10c0082e 	bgeu	r2,r3,d041680 <ip_reasm_compute_overlap+0x458>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d041660:	01000084 	movi	r4,2
 d041664:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
                  pk_free (p);
 d041668:	e13ffb17 	ldw	r4,-20(fp)
 d04166c:	d0251a00 	call	d0251a0 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041670:	01000084 	movi	r4,2
 d041674:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 d041678:	e03fff15 	stw	zero,-4(fp)
 d04167c:	00004806 	br	d0417a0 <ip_reasm_compute_overlap+0x578>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 d041680:	e0fff58b 	ldhu	r3,-42(fp)
 d041684:	e0bff70b 	ldhu	r2,-36(fp)
 d041688:	1885c83a 	sub	r2,r3,r2
 d04168c:	10800044 	addi	r2,r2,1
 d041690:	e0bff50d 	sth	r2,-44(fp)
                  p->nb_prot += drop_len;
 d041694:	e0bffb17 	ldw	r2,-20(fp)
 d041698:	10c00317 	ldw	r3,12(r2)
 d04169c:	e0bff50b 	ldhu	r2,-44(fp)
 d0416a0:	1887883a 	add	r3,r3,r2
 d0416a4:	e0bffb17 	ldw	r2,-20(fp)
 d0416a8:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 d0416ac:	e0bffb17 	ldw	r2,-20(fp)
 d0416b0:	10c00417 	ldw	r3,16(r2)
 d0416b4:	e0bff50b 	ldhu	r2,-44(fp)
 d0416b8:	1887c83a 	sub	r3,r3,r2
 d0416bc:	e0bffb17 	ldw	r2,-20(fp)
 d0416c0:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 d0416c4:	e0fff70b 	ldhu	r3,-36(fp)
 d0416c8:	e0bff50b 	ldhu	r2,-44(fp)
 d0416cc:	1885883a 	add	r2,r3,r2
 d0416d0:	e0bff70d 	sth	r2,-36(fp)
                  jrend = jrstart + p->nb_plen - 1;
 d0416d4:	e0bffb17 	ldw	r2,-20(fp)
 d0416d8:	10800417 	ldw	r2,16(r2)
 d0416dc:	1007883a 	mov	r3,r2
 d0416e0:	e0bff70b 	ldhu	r2,-36(fp)
 d0416e4:	1885883a 	add	r2,r3,r2
 d0416e8:	10bfffc4 	addi	r2,r2,-1
 d0416ec:	e0bff68d 	sth	r2,-38(fp)
 d0416f0:	00001206 	br	d04173c <ip_reasm_compute_overlap+0x514>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 d0416f4:	e0bffd17 	ldw	r2,-12(fp)
 d0416f8:	1080000b 	ldhu	r2,0(r2)
 d0416fc:	10bfffcc 	andi	r2,r2,65535
 d041700:	10800418 	cmpnei	r2,r2,16
 d041704:	1000061e 	bne	r2,zero,d041720 <ip_reasm_compute_overlap+0x4f8>
               {
               *indexp = i;
 d041708:	e0fffd17 	ldw	r3,-12(fp)
 d04170c:	e0bff40b 	ldhu	r2,-48(fp)
 d041710:	1880000d 	sth	r2,0(r3)
               *last_rfqpp = rfqp;               
 d041714:	e0fffe17 	ldw	r3,-8(fp)
 d041718:	e0bffa17 	ldw	r2,-24(fp)
 d04171c:	18800015 	stw	r2,0(r3)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 d041720:	e0bffc17 	ldw	r2,-16(fp)
 d041724:	10802103 	ldbu	r2,132(r2)
 d041728:	10803fcc 	andi	r2,r2,255
 d04172c:	1080004c 	andi	r2,r2,1
 d041730:	10803fcc 	andi	r2,r2,255
 d041734:	1004c03a 	cmpne	r2,r2,zero
 d041738:	1000061e 	bne	r2,zero,d041754 <ip_reasm_compute_overlap+0x52c>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d04173c:	e0bff40b 	ldhu	r2,-48(fp)
 d041740:	10800044 	addi	r2,r2,1
 d041744:	e0bff40d 	sth	r2,-48(fp)
 d041748:	e0bff40b 	ldhu	r2,-48(fp)
 d04174c:	10800430 	cmpltui	r2,r2,16
 d041750:	103f1e1e 	bne	r2,zero,d0413cc <ip_reasm_compute_overlap+0x1a4>
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 d041754:	e0bffd17 	ldw	r2,-12(fp)
 d041758:	1080000b 	ldhu	r2,0(r2)
 d04175c:	10bfffcc 	andi	r2,r2,65535
 d041760:	10800418 	cmpnei	r2,r2,16
 d041764:	1000031e 	bne	r2,zero,d041774 <ip_reasm_compute_overlap+0x54c>
         {
         *last_rfqpp = rfqp;
 d041768:	e0fffe17 	ldw	r3,-8(fp)
 d04176c:	e0bffa17 	ldw	r2,-24(fp)
 d041770:	18800015 	stw	r2,0(r3)
         }
      rfqp = rfqp->next;
 d041774:	e0bffa17 	ldw	r2,-24(fp)
 d041778:	10800017 	ldw	r2,0(r2)
 d04177c:	e0bffa15 	stw	r2,-24(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 d041780:	e0bffa17 	ldw	r2,-24(fp)
 d041784:	1004c03a 	cmpne	r2,r2,zero
 d041788:	103f0e1e 	bne	r2,zero,d0413c4 <ip_reasm_compute_overlap+0x19c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 d04178c:	e0c00217 	ldw	r3,8(fp)
 d041790:	e0bff70b 	ldhu	r2,-36(fp)
 d041794:	1880000d 	sth	r2,0(r3)

   return IPREASM_ACCEPT_FRAG;
 d041798:	00800084 	movi	r2,2
 d04179c:	e0bfff15 	stw	r2,-4(fp)
 d0417a0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0417a4:	e037883a 	mov	sp,fp
 d0417a8:	dfc00117 	ldw	ra,4(sp)
 d0417ac:	df000017 	ldw	fp,0(sp)
 d0417b0:	dec00204 	addi	sp,sp,8
 d0417b4:	f800283a 	ret

0d0417b8 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 d0417b8:	deffed04 	addi	sp,sp,-76
 d0417bc:	dfc01215 	stw	ra,72(sp)
 d0417c0:	df001115 	stw	fp,68(sp)
 d0417c4:	df001104 	addi	fp,sp,68
 d0417c8:	e13ffa15 	stw	r4,-24(fp)
 d0417cc:	e17ffb15 	stw	r5,-20(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 d0417d0:	e03ff415 	stw	zero,-48(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 d0417d4:	e13ffb17 	ldw	r4,-20(fp)
 d0417d8:	d041d4c0 	call	d041d4c <ip_reasm_find_ire>
 d0417dc:	10803fcc 	andi	r2,r2,255
 d0417e0:	10800060 	cmpeqi	r2,r2,1
 d0417e4:	1000171e 	bne	r2,zero,d041844 <ip_reasm_process_subsequent_fragments+0x8c>
      {
      ++ire_stats.bad_irep;
 d0417e8:	008341b4 	movhi	r2,3334
 d0417ec:	10857c04 	addi	r2,r2,5616
 d0417f0:	10800017 	ldw	r2,0(r2)
 d0417f4:	10c00044 	addi	r3,r2,1
 d0417f8:	008341b4 	movhi	r2,3334
 d0417fc:	10857c04 	addi	r2,r2,5616
 d041800:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d041804:	01000084 	movi	r4,2
 d041808:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free (p);
 d04180c:	e13ffa17 	ldw	r4,-24(fp)
 d041810:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041814:	01000084 	movi	r4,2
 d041818:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 d04181c:	008341b4 	movhi	r2,3334
 d041820:	10856804 	addi	r2,r2,5536
 d041824:	10800f17 	ldw	r2,60(r2)
 d041828:	10c00044 	addi	r3,r2,1
 d04182c:	008341b4 	movhi	r2,3334
 d041830:	10856804 	addi	r2,r2,5536
 d041834:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 d041838:	00bffd84 	movi	r2,-10
 d04183c:	e0bffe15 	stw	r2,-8(fp)
 d041840:	00013c06 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   pip = ip_head(p);
 d041844:	e0bffa17 	ldw	r2,-24(fp)
 d041848:	10800317 	ldw	r2,12(r2)
 d04184c:	e0bff515 	stw	r2,-44(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 d041850:	e13ff517 	ldw	r4,-44(fp)
 d041854:	d040bdc0 	call	d040bdc <ip_reasm_determine_type_of_frag>
 d041858:	e0bff215 	stw	r2,-56(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 d04185c:	e0bff217 	ldw	r2,-56(fp)
 d041860:	10800158 	cmpnei	r2,r2,5
 d041864:	10002c1e 	bne	r2,zero,d041918 <ip_reasm_process_subsequent_fragments+0x160>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 d041868:	e0bff517 	ldw	r2,-44(fp)
 d04186c:	1080018b 	ldhu	r2,6(r2)
 d041870:	10bfffcc 	andi	r2,r2,65535
 d041874:	1004d23a 	srli	r2,r2,8
 d041878:	10803fcc 	andi	r2,r2,255
 d04187c:	1009883a 	mov	r4,r2
 d041880:	e0bff517 	ldw	r2,-44(fp)
 d041884:	1080018b 	ldhu	r2,6(r2)
 d041888:	10bfffcc 	andi	r2,r2,65535
 d04188c:	1004923a 	slli	r2,r2,8
 d041890:	1007883a 	mov	r3,r2
 d041894:	00bfc004 	movi	r2,-256
 d041898:	1884703a 	and	r2,r3,r2
 d04189c:	2084b03a 	or	r2,r4,r2
 d0418a0:	1087ffcc 	andi	r2,r2,8191
 d0418a4:	100490fa 	slli	r2,r2,3
 d0418a8:	100b883a 	mov	r5,r2
 d0418ac:	e0bff517 	ldw	r2,-44(fp)
 d0418b0:	1080008b 	ldhu	r2,2(r2)
 d0418b4:	10bfffcc 	andi	r2,r2,65535
 d0418b8:	1004d23a 	srli	r2,r2,8
 d0418bc:	10803fcc 	andi	r2,r2,255
 d0418c0:	1009883a 	mov	r4,r2
 d0418c4:	e0bff517 	ldw	r2,-44(fp)
 d0418c8:	1080008b 	ldhu	r2,2(r2)
 d0418cc:	10bfffcc 	andi	r2,r2,65535
 d0418d0:	1004923a 	slli	r2,r2,8
 d0418d4:	1007883a 	mov	r3,r2
 d0418d8:	00bfc004 	movi	r2,-256
 d0418dc:	1884703a 	and	r2,r3,r2
 d0418e0:	2084b03a 	or	r2,r4,r2
 d0418e4:	1007883a 	mov	r3,r2
 d0418e8:	e0bff517 	ldw	r2,-44(fp)
 d0418ec:	10800003 	ldbu	r2,0(r2)
 d0418f0:	10803fcc 	andi	r2,r2,255
 d0418f4:	108003cc 	andi	r2,r2,15
 d0418f8:	1085883a 	add	r2,r2,r2
 d0418fc:	1085883a 	add	r2,r2,r2
 d041900:	1885c83a 	sub	r2,r3,r2
 d041904:	2885883a 	add	r2,r5,r2
 d041908:	1007883a 	mov	r3,r2
 d04190c:	e0bffb17 	ldw	r2,-20(fp)
 d041910:	10c0040d 	sth	r3,16(r2)
 d041914:	00000a06 	br	d041940 <ip_reasm_process_subsequent_fragments+0x188>
      }
   else if (ftype == IP_FF)
 d041918:	e0bff217 	ldw	r2,-56(fp)
 d04191c:	10800058 	cmpnei	r2,r2,1
 d041920:	1000071e 	bne	r2,zero,d041940 <ip_reasm_process_subsequent_fragments+0x188>
      {
      irep->l2_hdr = p->nb_buff;
 d041924:	e0bffa17 	ldw	r2,-24(fp)
 d041928:	10c00117 	ldw	r3,4(r2)
 d04192c:	e0bffb17 	ldw	r2,-20(fp)
 d041930:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 d041934:	e0fff517 	ldw	r3,-44(fp)
 d041938:	e0bffb17 	ldw	r2,-20(fp)
 d04193c:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 d041940:	e1bff704 	addi	r6,fp,-36
 d041944:	e1fff804 	addi	r7,fp,-32
 d041948:	e0bff904 	addi	r2,fp,-28
 d04194c:	d8800015 	stw	r2,0(sp)
 d041950:	e0bff984 	addi	r2,fp,-26
 d041954:	d8800115 	stw	r2,4(sp)
 d041958:	e13ffa17 	ldw	r4,-24(fp)
 d04195c:	e17ffb17 	ldw	r5,-20(fp)
 d041960:	d0412280 	call	d041228 <ip_reasm_compute_overlap>
 d041964:	e0bff115 	stw	r2,-60(fp)
 d041968:	e0bff117 	ldw	r2,-60(fp)
 d04196c:	108000a0 	cmpeqi	r2,r2,2
 d041970:	10000e1e 	bne	r2,zero,d0419ac <ip_reasm_process_subsequent_fragments+0x1f4>
      {
      switch (rc2)
 d041974:	e0fff117 	ldw	r3,-60(fp)
 d041978:	e0ffff15 	stw	r3,-4(fp)
 d04197c:	e13fff17 	ldw	r4,-4(fp)
 d041980:	2005003a 	cmpeq	r2,r4,zero
 d041984:	1000041e 	bne	r2,zero,d041998 <ip_reasm_process_subsequent_fragments+0x1e0>
 d041988:	e0ffff17 	ldw	r3,-4(fp)
 d04198c:	18800060 	cmpeqi	r2,r3,1
 d041990:	1000031e 	bne	r2,zero,d0419a0 <ip_reasm_process_subsequent_fragments+0x1e8>
 d041994:	00000506 	br	d0419ac <ip_reasm_process_subsequent_fragments+0x1f4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 d041998:	e03ffe15 	stw	zero,-8(fp)
 d04199c:	0000e506 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 d0419a0:	013ffd84 	movi	r4,-10
 d0419a4:	e13ffe15 	stw	r4,-8(fp)
 d0419a8:	0000e206 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 d0419ac:	e0bffa17 	ldw	r2,-24(fp)
 d0419b0:	10800217 	ldw	r2,8(r2)
 d0419b4:	113fffcc 	andi	r4,r2,65535
 d0419b8:	d040cc80 	call	d040cc8 <ip_reasm_check_mem_useage>
 d0419bc:	e0bff315 	stw	r2,-52(fp)
 d0419c0:	e0bff317 	ldw	r2,-52(fp)
 d0419c4:	1005003a 	cmpeq	r2,r2,zero
 d0419c8:	1000121e 	bne	r2,zero,d041a14 <ip_reasm_process_subsequent_fragments+0x25c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d0419cc:	01000084 	movi	r4,2
 d0419d0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free (p);
 d0419d4:	e13ffa17 	ldw	r4,-24(fp)
 d0419d8:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d0419dc:	01000084 	movi	r4,2
 d0419e0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 d0419e4:	e13ffb17 	ldw	r4,-20(fp)
 d0419e8:	d0421f00 	call	d0421f0 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 d0419ec:	008341b4 	movhi	r2,3334
 d0419f0:	10856804 	addi	r2,r2,5536
 d0419f4:	10800f17 	ldw	r2,60(r2)
 d0419f8:	10c00044 	addi	r3,r2,1
 d0419fc:	008341b4 	movhi	r2,3334
 d041a00:	10856804 	addi	r2,r2,5536
 d041a04:	10c00f15 	stw	r3,60(r2)
      return rc;
 d041a08:	e0bff317 	ldw	r2,-52(fp)
 d041a0c:	e0bffe15 	stw	r2,-8(fp)
 d041a10:	0000c806 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 d041a14:	e0bff70b 	ldhu	r2,-36(fp)
 d041a18:	10bfffcc 	andi	r2,r2,65535
 d041a1c:	10800420 	cmpeqi	r2,r2,16
 d041a20:	1000121e 	bne	r2,zero,d041a6c <ip_reasm_process_subsequent_fragments+0x2b4>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 d041a24:	e0fff817 	ldw	r3,-32(fp)
 d041a28:	e0bff70b 	ldhu	r2,-36(fp)
 d041a2c:	10bfffcc 	andi	r2,r2,65535
 d041a30:	1085883a 	add	r2,r2,r2
 d041a34:	1085883a 	add	r2,r2,r2
 d041a38:	10c5883a 	add	r2,r2,r3
 d041a3c:	10c00104 	addi	r3,r2,4
 d041a40:	e0bffa17 	ldw	r2,-24(fp)
 d041a44:	18800015 	stw	r2,0(r3)
      rfqp->frag_offset[index] = frag_offset;
 d041a48:	e0fff817 	ldw	r3,-32(fp)
 d041a4c:	e0bff70b 	ldhu	r2,-36(fp)
 d041a50:	10bfffcc 	andi	r2,r2,65535
 d041a54:	e13ff90b 	ldhu	r4,-28(fp)
 d041a58:	1085883a 	add	r2,r2,r2
 d041a5c:	10c5883a 	add	r2,r2,r3
 d041a60:	10801104 	addi	r2,r2,68
 d041a64:	1100000d 	sth	r4,0(r2)
 d041a68:	00003c06 	br	d041b5c <ip_reasm_process_subsequent_fragments+0x3a4>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 d041a6c:	e0bffa17 	ldw	r2,-24(fp)
 d041a70:	10800217 	ldw	r2,8(r2)
 d041a74:	10801904 	addi	r2,r2,100
 d041a78:	113fffcc 	andi	r4,r2,65535
 d041a7c:	d040cc80 	call	d040cc8 <ip_reasm_check_mem_useage>
 d041a80:	e0bff315 	stw	r2,-52(fp)
 d041a84:	e0bff317 	ldw	r2,-52(fp)
 d041a88:	1005003a 	cmpeq	r2,r2,zero
 d041a8c:	1000121e 	bne	r2,zero,d041ad8 <ip_reasm_process_subsequent_fragments+0x320>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 d041a90:	01000084 	movi	r4,2
 d041a94:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free (p);
 d041a98:	e13ffa17 	ldw	r4,-24(fp)
 d041a9c:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041aa0:	01000084 	movi	r4,2
 d041aa4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 d041aa8:	e13ffb17 	ldw	r4,-20(fp)
 d041aac:	d0421f00 	call	d0421f0 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 d041ab0:	008341b4 	movhi	r2,3334
 d041ab4:	10856804 	addi	r2,r2,5536
 d041ab8:	10800f17 	ldw	r2,60(r2)
 d041abc:	10c00044 	addi	r3,r2,1
 d041ac0:	008341b4 	movhi	r2,3334
 d041ac4:	10856804 	addi	r2,r2,5536
 d041ac8:	10c00f15 	stw	r3,60(r2)
         return rc;
 d041acc:	e0fff317 	ldw	r3,-52(fp)
 d041ad0:	e0fffe15 	stw	r3,-8(fp)
 d041ad4:	00009706 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 d041ad8:	01001904 	movi	r4,100
 d041adc:	d0264b80 	call	d0264b8 <npalloc>
 d041ae0:	e0bff415 	stw	r2,-48(fp)
      if (new_rfqp == 0)
 d041ae4:	e0bff417 	ldw	r2,-48(fp)
 d041ae8:	1004c03a 	cmpne	r2,r2,zero
 d041aec:	1000121e 	bne	r2,zero,d041b38 <ip_reasm_process_subsequent_fragments+0x380>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 d041af0:	01000084 	movi	r4,2
 d041af4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free (p);
 d041af8:	e13ffa17 	ldw	r4,-24(fp)
 d041afc:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041b00:	01000084 	movi	r4,2
 d041b04:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 d041b08:	e13ffb17 	ldw	r4,-20(fp)
 d041b0c:	d0421f00 	call	d0421f0 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 d041b10:	008341b4 	movhi	r2,3334
 d041b14:	10856804 	addi	r2,r2,5536
 d041b18:	10800f17 	ldw	r2,60(r2)
 d041b1c:	10c00044 	addi	r3,r2,1
 d041b20:	008341b4 	movhi	r2,3334
 d041b24:	10856804 	addi	r2,r2,5536
 d041b28:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 d041b2c:	013ffa84 	movi	r4,-22
 d041b30:	e13ffe15 	stw	r4,-8(fp)
 d041b34:	00007f06 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 d041b38:	e0fff417 	ldw	r3,-48(fp)
 d041b3c:	e0bffa17 	ldw	r2,-24(fp)
 d041b40:	18800115 	stw	r2,4(r3)
         new_rfqp->frag_offset[0] = frag_offset;
 d041b44:	e0fff90b 	ldhu	r3,-28(fp)
 d041b48:	e0bff417 	ldw	r2,-48(fp)
 d041b4c:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 d041b50:	e0fff817 	ldw	r3,-32(fp)
 d041b54:	e0bff417 	ldw	r2,-48(fp)
 d041b58:	18800015 	stw	r2,0(r3)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 d041b5c:	e0bff983 	ldbu	r2,-26(fp)
 d041b60:	10803fcc 	andi	r2,r2,255
 d041b64:	1005003a 	cmpeq	r2,r2,zero
 d041b68:	1000161e 	bne	r2,zero,d041bc4 <ip_reasm_process_subsequent_fragments+0x40c>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 d041b6c:	e13ffb17 	ldw	r4,-20(fp)
 d041b70:	d0423b80 	call	d0423b8 <ip_reasm_mark_compact_rfq>
 d041b74:	e0bff315 	stw	r2,-52(fp)
 d041b78:	e0bff317 	ldw	r2,-52(fp)
 d041b7c:	1005003a 	cmpeq	r2,r2,zero
 d041b80:	1000101e 	bne	r2,zero,d041bc4 <ip_reasm_process_subsequent_fragments+0x40c>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 d041b84:	01000084 	movi	r4,2
 d041b88:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free (p);
 d041b8c:	e13ffa17 	ldw	r4,-24(fp)
 d041b90:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041b94:	01000084 	movi	r4,2
 d041b98:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 d041b9c:	008341b4 	movhi	r2,3334
 d041ba0:	10856804 	addi	r2,r2,5536
 d041ba4:	10800f17 	ldw	r2,60(r2)
 d041ba8:	10c00044 	addi	r3,r2,1
 d041bac:	008341b4 	movhi	r2,3334
 d041bb0:	10856804 	addi	r2,r2,5536
 d041bb4:	10c00f15 	stw	r3,60(r2)
            return rc;
 d041bb8:	e0bff317 	ldw	r2,-52(fp)
 d041bbc:	e0bffe15 	stw	r2,-8(fp)
 d041bc0:	00005c06 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 d041bc4:	e0bffb17 	ldw	r2,-20(fp)
 d041bc8:	10c0048b 	ldhu	r3,18(r2)
 d041bcc:	e0bffa17 	ldw	r2,-24(fp)
 d041bd0:	10800417 	ldw	r2,16(r2)
 d041bd4:	1885883a 	add	r2,r3,r2
 d041bd8:	1007883a 	mov	r3,r2
 d041bdc:	e0bffb17 	ldw	r2,-20(fp)
 d041be0:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 d041be4:	e0bffa17 	ldw	r2,-24(fp)
 d041be8:	10800217 	ldw	r2,8(r2)
 d041bec:	e0bffd0d 	sth	r2,-12(fp)
 d041bf0:	e0bff417 	ldw	r2,-48(fp)
 d041bf4:	1004c03a 	cmpne	r2,r2,zero
 d041bf8:	1000021e 	bne	r2,zero,d041c04 <ip_reasm_process_subsequent_fragments+0x44c>
 d041bfc:	e03ffc0d 	sth	zero,-16(fp)
 d041c00:	00000206 	br	d041c0c <ip_reasm_process_subsequent_fragments+0x454>
 d041c04:	00c01904 	movi	r3,100
 d041c08:	e0fffc0d 	sth	r3,-16(fp)
 d041c0c:	e13ffd0b 	ldhu	r4,-12(fp)
 d041c10:	e0fffc0b 	ldhu	r3,-16(fp)
 d041c14:	20c5883a 	add	r2,r4,r3
 d041c18:	113fffcc 	andi	r4,r2,65535
 d041c1c:	d040d600 	call	d040d60 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 d041c20:	e0bffb17 	ldw	r2,-20(fp)
 d041c24:	1080040b 	ldhu	r2,16(r2)
 d041c28:	10bfffcc 	andi	r2,r2,65535
 d041c2c:	1005003a 	cmpeq	r2,r2,zero
 d041c30:	10003f1e 	bne	r2,zero,d041d30 <ip_reasm_process_subsequent_fragments+0x578>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 d041c34:	e0bffb17 	ldw	r2,-20(fp)
 d041c38:	10c0048b 	ldhu	r3,18(r2)
 d041c3c:	e0bffb17 	ldw	r2,-20(fp)
 d041c40:	1080040b 	ldhu	r2,16(r2)
 d041c44:	18ffffcc 	andi	r3,r3,65535
 d041c48:	10bfffcc 	andi	r2,r2,65535
 d041c4c:	1880381e 	bne	r3,r2,d041d30 <ip_reasm_process_subsequent_fragments+0x578>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 d041c50:	e0bffb17 	ldw	r2,-20(fp)
 d041c54:	10802017 	ldw	r2,128(r2)
 d041c58:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 d041c5c:	01000084 	movi	r4,2
 d041c60:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 d041c64:	e0bffb17 	ldw	r2,-20(fp)
 d041c68:	1080040b 	ldhu	r2,16(r2)
 d041c6c:	113fffcc 	andi	r4,r2,65535
 d041c70:	e0bffb17 	ldw	r2,-20(fp)
 d041c74:	10802017 	ldw	r2,128(r2)
 d041c78:	1007883a 	mov	r3,r2
 d041c7c:	e0bffb17 	ldw	r2,-20(fp)
 d041c80:	10801f17 	ldw	r2,124(r2)
 d041c84:	1885c83a 	sub	r2,r3,r2
 d041c88:	2087883a 	add	r3,r4,r2
 d041c8c:	e0bff517 	ldw	r2,-44(fp)
 d041c90:	10800003 	ldbu	r2,0(r2)
 d041c94:	10803fcc 	andi	r2,r2,255
 d041c98:	108003cc 	andi	r2,r2,15
 d041c9c:	1085883a 	add	r2,r2,r2
 d041ca0:	1085883a 	add	r2,r2,r2
 d041ca4:	1885883a 	add	r2,r3,r2
 d041ca8:	1009883a 	mov	r4,r2
 d041cac:	d024e0c0 	call	d024e0c <pk_alloc>
 d041cb0:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041cb4:	01000084 	movi	r4,2
 d041cb8:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 d041cbc:	e0bff617 	ldw	r2,-40(fp)
 d041cc0:	1004c03a 	cmpne	r2,r2,zero
 d041cc4:	10000c1e 	bne	r2,zero,d041cf8 <ip_reasm_process_subsequent_fragments+0x540>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 d041cc8:	e13ffb17 	ldw	r4,-20(fp)
 d041ccc:	d0421f00 	call	d0421f0 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 d041cd0:	008341b4 	movhi	r2,3334
 d041cd4:	10856804 	addi	r2,r2,5536
 d041cd8:	10800f17 	ldw	r2,60(r2)
 d041cdc:	10c00044 	addi	r3,r2,1
 d041ce0:	008341b4 	movhi	r2,3334
 d041ce4:	10856804 	addi	r2,r2,5536
 d041ce8:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 d041cec:	013ffac4 	movi	r4,-21
 d041cf0:	e13ffe15 	stw	r4,-8(fp)
 d041cf4:	00000f06 	br	d041d34 <ip_reasm_process_subsequent_fragments+0x57c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 d041cf8:	e13ff617 	ldw	r4,-40(fp)
 d041cfc:	e17ffb17 	ldw	r5,-20(fp)
 d041d00:	d041db00 	call	d041db0 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 d041d04:	e13ffb17 	ldw	r4,-20(fp)
 d041d08:	d0421f00 	call	d0421f0 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 d041d0c:	008341b4 	movhi	r2,3334
 d041d10:	10856804 	addi	r2,r2,5536
 d041d14:	10800e17 	ldw	r2,56(r2)
 d041d18:	10c00044 	addi	r3,r2,1
 d041d1c:	008341b4 	movhi	r2,3334
 d041d20:	10856804 	addi	r2,r2,5536
 d041d24:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 d041d28:	e13ff617 	ldw	r4,-40(fp)
 d041d2c:	d0432b40 	call	d0432b4 <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 d041d30:	e03ffe15 	stw	zero,-8(fp)
 d041d34:	e0bffe17 	ldw	r2,-8(fp)
}
 d041d38:	e037883a 	mov	sp,fp
 d041d3c:	dfc00117 	ldw	ra,4(sp)
 d041d40:	df000017 	ldw	fp,0(sp)
 d041d44:	dec00204 	addi	sp,sp,8
 d041d48:	f800283a 	ret

0d041d4c <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 d041d4c:	defffc04 	addi	sp,sp,-16
 d041d50:	df000315 	stw	fp,12(sp)
 d041d54:	df000304 	addi	fp,sp,12
 d041d58:	e13ffe15 	stw	r4,-8(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d041d5c:	d0a94717 	ldw	r2,-23268(gp)
 d041d60:	e0bffd15 	stw	r2,-12(fp)
 d041d64:	00000906 	br	d041d8c <ip_reasm_find_ire+0x40>
      {
      if (tmpp == irep) 
 d041d68:	e0fffd17 	ldw	r3,-12(fp)
 d041d6c:	e0bffe17 	ldw	r2,-8(fp)
 d041d70:	1880031e 	bne	r3,r2,d041d80 <ip_reasm_find_ire+0x34>
         {
         return IPREASM_TRUE;
 d041d74:	00800044 	movi	r2,1
 d041d78:	e0bfff15 	stw	r2,-4(fp)
 d041d7c:	00000706 	br	d041d9c <ip_reasm_find_ire+0x50>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d041d80:	e0bffd17 	ldw	r2,-12(fp)
 d041d84:	10800017 	ldw	r2,0(r2)
 d041d88:	e0bffd15 	stw	r2,-12(fp)
 d041d8c:	e0bffd17 	ldw	r2,-12(fp)
 d041d90:	1004c03a 	cmpne	r2,r2,zero
 d041d94:	103ff41e 	bne	r2,zero,d041d68 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 d041d98:	e03fff15 	stw	zero,-4(fp)
 d041d9c:	e0bfff17 	ldw	r2,-4(fp)
}
 d041da0:	e037883a 	mov	sp,fp
 d041da4:	df000017 	ldw	fp,0(sp)
 d041da8:	dec00104 	addi	sp,sp,4
 d041dac:	f800283a 	ret

0d041db0 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 d041db0:	defff404 	addi	sp,sp,-48
 d041db4:	dfc00b15 	stw	ra,44(sp)
 d041db8:	df000a15 	stw	fp,40(sp)
 d041dbc:	df000a04 	addi	fp,sp,40
 d041dc0:	e13ffe15 	stw	r4,-8(fp)
 d041dc4:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 d041dc8:	e03ff615 	stw	zero,-40(fp)

   pip = (struct ip *) irep->l3_hdr;
 d041dcc:	e0bfff17 	ldw	r2,-4(fp)
 d041dd0:	10802017 	ldw	r2,128(r2)
 d041dd4:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen (pip);
 d041dd8:	e0bffd17 	ldw	r2,-12(fp)
 d041ddc:	10800003 	ldbu	r2,0(r2)
 d041de0:	108003cc 	andi	r2,r2,15
 d041de4:	1085883a 	add	r2,r2,r2
 d041de8:	1085883a 	add	r2,r2,r2
 d041dec:	e0bff805 	stb	r2,-32(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 d041df0:	e0bfff17 	ldw	r2,-4(fp)
 d041df4:	10802017 	ldw	r2,128(r2)
 d041df8:	1007883a 	mov	r3,r2
 d041dfc:	e0bfff17 	ldw	r2,-4(fp)
 d041e00:	10801f17 	ldw	r2,124(r2)
 d041e04:	1885c83a 	sub	r2,r3,r2
 d041e08:	1007883a 	mov	r3,r2
 d041e0c:	e0bff803 	ldbu	r2,-32(fp)
 d041e10:	1885883a 	add	r2,r3,r2
 d041e14:	e0bffc05 	stb	r2,-16(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 d041e18:	e0bffe17 	ldw	r2,-8(fp)
 d041e1c:	11000117 	ldw	r4,4(r2)
 d041e20:	e0bfff17 	ldw	r2,-4(fp)
 d041e24:	10801f17 	ldw	r2,124(r2)
 d041e28:	e0fffc03 	ldbu	r3,-16(fp)
 d041e2c:	100b883a 	mov	r5,r2
 d041e30:	180d883a 	mov	r6,r3
 d041e34:	d0026080 	call	d002608 <memcpy>

   rfqp = &(irep->rfq);
 d041e38:	e0bfff17 	ldw	r2,-4(fp)
 d041e3c:	10800604 	addi	r2,r2,24
 d041e40:	e0bffb15 	stw	r2,-20(fp)
   writep = reassy_pkt->nb_buff + offset;
 d041e44:	e0bffe17 	ldw	r2,-8(fp)
 d041e48:	10c00117 	ldw	r3,4(r2)
 d041e4c:	e0bffc03 	ldbu	r2,-16(fp)
 d041e50:	1885883a 	add	r2,r3,r2
 d041e54:	e0bff715 	stw	r2,-36(fp)

   while (rfqp)
 d041e58:	00004606 	br	d041f74 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d041e5c:	e03ffa0d 	sth	zero,-24(fp)
 d041e60:	00003e06 	br	d041f5c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1ac>
         {
         if ((p = rfqp->bufp [i]) != 0)
 d041e64:	e0bffa0b 	ldhu	r2,-24(fp)
 d041e68:	e0fffb17 	ldw	r3,-20(fp)
 d041e6c:	1085883a 	add	r2,r2,r2
 d041e70:	1085883a 	add	r2,r2,r2
 d041e74:	10c5883a 	add	r2,r2,r3
 d041e78:	10800104 	addi	r2,r2,4
 d041e7c:	10800017 	ldw	r2,0(r2)
 d041e80:	e0bff915 	stw	r2,-28(fp)
 d041e84:	e0bff917 	ldw	r2,-28(fp)
 d041e88:	1005003a 	cmpeq	r2,r2,zero
 d041e8c:	1000291e 	bne	r2,zero,d041f34 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 d041e90:	e0bffa0b 	ldhu	r2,-24(fp)
 d041e94:	e0fffb17 	ldw	r3,-20(fp)
 d041e98:	1085883a 	add	r2,r2,r2
 d041e9c:	10c5883a 	add	r2,r2,r3
 d041ea0:	10801104 	addi	r2,r2,68
 d041ea4:	1080000b 	ldhu	r2,0(r2)
 d041ea8:	10bfffcc 	andi	r2,r2,65535
 d041eac:	1007883a 	mov	r3,r2
 d041eb0:	e0bff717 	ldw	r2,-36(fp)
 d041eb4:	1887883a 	add	r3,r3,r2
 d041eb8:	e0bff917 	ldw	r2,-28(fp)
 d041ebc:	11400317 	ldw	r5,12(r2)
 d041ec0:	e0bff917 	ldw	r2,-28(fp)
 d041ec4:	10800417 	ldw	r2,16(r2)
 d041ec8:	1809883a 	mov	r4,r3
 d041ecc:	100d883a 	mov	r6,r2
 d041ed0:	d0026080 	call	d002608 <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 d041ed4:	e0bff617 	ldw	r2,-40(fp)
 d041ed8:	1004c03a 	cmpne	r2,r2,zero
 d041edc:	1000031e 	bne	r2,zero,d041eec <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x13c>
 d041ee0:	e0bff917 	ldw	r2,-28(fp)
 d041ee4:	e0bff615 	stw	r2,-40(fp)
 d041ee8:	00000a06 	br	d041f14 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 d041eec:	e0bff917 	ldw	r2,-28(fp)
 d041ef0:	10800217 	ldw	r2,8(r2)
 d041ef4:	113fffcc 	andi	r4,r2,65535
 d041ef8:	d040e080 	call	d040e08 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 d041efc:	01000084 	movi	r4,2
 d041f00:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
               pk_free (p);
 d041f04:	e13ff917 	ldw	r4,-28(fp)
 d041f08:	d0251a00 	call	d0251a0 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d041f0c:	01000084 	movi	r4,2
 d041f10:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 d041f14:	e0bffa0b 	ldhu	r2,-24(fp)
 d041f18:	e0fffb17 	ldw	r3,-20(fp)
 d041f1c:	1085883a 	add	r2,r2,r2
 d041f20:	1085883a 	add	r2,r2,r2
 d041f24:	10c5883a 	add	r2,r2,r3
 d041f28:	10800104 	addi	r2,r2,4
 d041f2c:	10000015 	stw	zero,0(r2)
 d041f30:	00000706 	br	d041f50 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a0>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 d041f34:	e0bfff17 	ldw	r2,-4(fp)
 d041f38:	10802103 	ldbu	r2,132(r2)
 d041f3c:	10803fcc 	andi	r2,r2,255
 d041f40:	1080004c 	andi	r2,r2,1
 d041f44:	10803fcc 	andi	r2,r2,255
 d041f48:	1004c03a 	cmpne	r2,r2,zero
 d041f4c:	1000061e 	bne	r2,zero,d041f68 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d041f50:	e0bffa0b 	ldhu	r2,-24(fp)
 d041f54:	10800044 	addi	r2,r2,1
 d041f58:	e0bffa0d 	sth	r2,-24(fp)
 d041f5c:	e0bffa0b 	ldhu	r2,-24(fp)
 d041f60:	10800430 	cmpltui	r2,r2,16
 d041f64:	103fbf1e 	bne	r2,zero,d041e64 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb4>
               break;
               }
            }
          }

      rfqp = rfqp->next;
 d041f68:	e0bffb17 	ldw	r2,-20(fp)
 d041f6c:	10800017 	ldw	r2,0(r2)
 d041f70:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 d041f74:	e0bffb17 	ldw	r2,-20(fp)
 d041f78:	1004c03a 	cmpne	r2,r2,zero
 d041f7c:	103fb71e 	bne	r2,zero,d041e5c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xac>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 d041f80:	e0bffe17 	ldw	r2,-8(fp)
 d041f84:	11000117 	ldw	r4,4(r2)
 d041f88:	e0bfff17 	ldw	r2,-4(fp)
 d041f8c:	10802017 	ldw	r2,128(r2)
 d041f90:	1007883a 	mov	r3,r2
 d041f94:	e0bfff17 	ldw	r2,-4(fp)
 d041f98:	10801f17 	ldw	r2,124(r2)
 d041f9c:	1885c83a 	sub	r2,r3,r2
 d041fa0:	2087883a 	add	r3,r4,r2
 d041fa4:	e0bffe17 	ldw	r2,-8(fp)
 d041fa8:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 d041fac:	e0bfff17 	ldw	r2,-4(fp)
 d041fb0:	1080040b 	ldhu	r2,16(r2)
 d041fb4:	10ffffcc 	andi	r3,r2,65535
 d041fb8:	e0bff803 	ldbu	r2,-32(fp)
 d041fbc:	1885883a 	add	r2,r3,r2
 d041fc0:	1007883a 	mov	r3,r2
 d041fc4:	e0bffe17 	ldw	r2,-8(fp)
 d041fc8:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 d041fcc:	00834174 	movhi	r2,3333
 d041fd0:	109b4504 	addi	r2,r2,27924
 d041fd4:	10800017 	ldw	r2,0(r2)
 d041fd8:	1007883a 	mov	r3,r2
 d041fdc:	e0bffe17 	ldw	r2,-8(fp)
 d041fe0:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 d041fe4:	e0bffe17 	ldw	r2,-8(fp)
 d041fe8:	10c00a17 	ldw	r3,40(r2)
 d041fec:	e0bff617 	ldw	r2,-40(fp)
 d041ff0:	10800a17 	ldw	r2,40(r2)
 d041ff4:	108000cc 	andi	r2,r2,3
 d041ff8:	1886b03a 	or	r3,r3,r2
 d041ffc:	e0bffe17 	ldw	r2,-8(fp)
 d042000:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 d042004:	e0bff617 	ldw	r2,-40(fp)
 d042008:	10c00617 	ldw	r3,24(r2)
 d04200c:	e0bffe17 	ldw	r2,-8(fp)
 d042010:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 d042014:	e0bff617 	ldw	r2,-40(fp)
 d042018:	10c0080b 	ldhu	r3,32(r2)
 d04201c:	e0bffe17 	ldw	r2,-8(fp)
 d042020:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 d042024:	e0bff617 	ldw	r2,-40(fp)
 d042028:	10800217 	ldw	r2,8(r2)
 d04202c:	113fffcc 	andi	r4,r2,65535
 d042030:	d040e080 	call	d040e08 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 d042034:	01000084 	movi	r4,2
 d042038:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 d04203c:	e13ff617 	ldw	r4,-40(fp)
 d042040:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d042044:	01000084 	movi	r4,2
 d042048:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 d04204c:	e0bffe17 	ldw	r2,-8(fp)
 d042050:	10800317 	ldw	r2,12(r2)
 d042054:	e0bffd15 	stw	r2,-12(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 d042058:	e0bffe17 	ldw	r2,-8(fp)
 d04205c:	10800417 	ldw	r2,16(r2)
 d042060:	1004d23a 	srli	r2,r2,8
 d042064:	10803fcc 	andi	r2,r2,255
 d042068:	1009883a 	mov	r4,r2
 d04206c:	e0bffe17 	ldw	r2,-8(fp)
 d042070:	10800417 	ldw	r2,16(r2)
 d042074:	1004923a 	slli	r2,r2,8
 d042078:	1007883a 	mov	r3,r2
 d04207c:	00bfc004 	movi	r2,-256
 d042080:	1884703a 	and	r2,r3,r2
 d042084:	2084b03a 	or	r2,r4,r2
 d042088:	1007883a 	mov	r3,r2
 d04208c:	e0bffd17 	ldw	r2,-12(fp)
 d042090:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 d042094:	e0bffd17 	ldw	r2,-12(fp)
 d042098:	10c0018b 	ldhu	r3,6(r2)
 d04209c:	00bff7c4 	movi	r2,-33
 d0420a0:	1884703a 	and	r2,r3,r2
 d0420a4:	1007883a 	mov	r3,r2
 d0420a8:	e0bffd17 	ldw	r2,-12(fp)
 d0420ac:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 d0420b0:	e0bffd17 	ldw	r2,-12(fp)
 d0420b4:	1080018b 	ldhu	r2,6(r2)
 d0420b8:	1080380c 	andi	r2,r2,224
 d0420bc:	1007883a 	mov	r3,r2
 d0420c0:	e0bffd17 	ldw	r2,-12(fp)
 d0420c4:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 d0420c8:	e0bffd17 	ldw	r2,-12(fp)
 d0420cc:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 d0420d0:	e0bff803 	ldbu	r2,-32(fp)
 d0420d4:	1004d07a 	srli	r2,r2,1
 d0420d8:	11403fcc 	andi	r5,r2,255
 d0420dc:	e13ffd17 	ldw	r4,-12(fp)
 d0420e0:	d0205440 	call	d020544 <cksum>
 d0420e4:	0084303a 	nor	r2,zero,r2
 d0420e8:	1007883a 	mov	r3,r2
 d0420ec:	e0bffd17 	ldw	r2,-12(fp)
 d0420f0:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 d0420f4:	0005883a 	mov	r2,zero
}
 d0420f8:	e037883a 	mov	sp,fp
 d0420fc:	dfc00117 	ldw	ra,4(sp)
 d042100:	df000017 	ldw	fp,0(sp)
 d042104:	dec00204 	addi	sp,sp,8
 d042108:	f800283a 	ret

0d04210c <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 d04210c:	defffc04 	addi	sp,sp,-16
 d042110:	dfc00315 	stw	ra,12(sp)
 d042114:	df000215 	stw	fp,8(sp)
 d042118:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 d04211c:	0009883a 	mov	r4,zero
 d042120:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 d042124:	d0a94717 	ldw	r2,-23268(gp)
 d042128:	e0bfff15 	stw	r2,-4(fp)
 d04212c:	00002006 	br	d0421b0 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 d042130:	e0bfff17 	ldw	r2,-4(fp)
 d042134:	10800017 	ldw	r2,0(r2)
 d042138:	e0bffe15 	stw	r2,-8(fp)
      ++tmpp->age;
 d04213c:	e0bfff17 	ldw	r2,-4(fp)
 d042140:	10800517 	ldw	r2,20(r2)
 d042144:	10c00044 	addi	r3,r2,1
 d042148:	e0bfff17 	ldw	r2,-4(fp)
 d04214c:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 d042150:	e0bfff17 	ldw	r2,-4(fp)
 d042154:	10800517 	ldw	r2,20(r2)
 d042158:	10801e18 	cmpnei	r2,r2,120
 d04215c:	1000121e 	bne	r2,zero,d0421a8 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 d042160:	008341b4 	movhi	r2,3334
 d042164:	10857c04 	addi	r2,r2,5616
 d042168:	10800117 	ldw	r2,4(r2)
 d04216c:	10c00044 	addi	r3,r2,1
 d042170:	008341b4 	movhi	r2,3334
 d042174:	10857c04 	addi	r2,r2,5616
 d042178:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 d04217c:	e13fff17 	ldw	r4,-4(fp)
 d042180:	d0428540 	call	d042854 <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 d042184:	e13fff17 	ldw	r4,-4(fp)
 d042188:	d0421f00 	call	d0421f0 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 d04218c:	008341b4 	movhi	r2,3334
 d042190:	10856804 	addi	r2,r2,5536
 d042194:	10800f17 	ldw	r2,60(r2)
 d042198:	10c00044 	addi	r3,r2,1
 d04219c:	008341b4 	movhi	r2,3334
 d0421a0:	10856804 	addi	r2,r2,5536
 d0421a4:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 d0421a8:	e0bffe17 	ldw	r2,-8(fp)
 d0421ac:	e0bfff15 	stw	r2,-4(fp)
 d0421b0:	e0bfff17 	ldw	r2,-4(fp)
 d0421b4:	1004c03a 	cmpne	r2,r2,zero
 d0421b8:	103fdd1e 	bne	r2,zero,d042130 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 d0421bc:	00834174 	movhi	r2,3333
 d0421c0:	109b4504 	addi	r2,r2,27924
 d0421c4:	10800017 	ldw	r2,0(r2)
 d0421c8:	10801904 	addi	r2,r2,100
 d0421cc:	d0a94815 	stw	r2,-23264(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 d0421d0:	0009883a 	mov	r4,zero
 d0421d4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 d0421d8:	0005883a 	mov	r2,zero
}
 d0421dc:	e037883a 	mov	sp,fp
 d0421e0:	dfc00117 	ldw	ra,4(sp)
 d0421e4:	df000017 	ldw	fp,0(sp)
 d0421e8:	dec00204 	addi	sp,sp,8
 d0421ec:	f800283a 	ret

0d0421f0 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 d0421f0:	defff504 	addi	sp,sp,-44
 d0421f4:	dfc00a15 	stw	ra,40(sp)
 d0421f8:	df000915 	stw	fp,36(sp)
 d0421fc:	df000904 	addi	fp,sp,36
 d042200:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 d042204:	e03ff715 	stw	zero,-36(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d042208:	d0a94717 	ldw	r2,-23268(gp)
 d04220c:	e0bff815 	stw	r2,-32(fp)
 d042210:	00001406 	br	d042264 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 d042214:	e0fff817 	ldw	r3,-32(fp)
 d042218:	e0bffe17 	ldw	r2,-8(fp)
 d04221c:	18800c1e 	bne	r3,r2,d042250 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 d042220:	d0e94717 	ldw	r3,-23268(gp)
 d042224:	e0bff817 	ldw	r2,-32(fp)
 d042228:	10c0041e 	bne	r2,r3,d04223c <ip_reasm_delete_ire+0x4c>
 d04222c:	e0bffe17 	ldw	r2,-8(fp)
 d042230:	10800017 	ldw	r2,0(r2)
 d042234:	d0a94715 	stw	r2,-23268(gp)
 d042238:	00000d06 	br	d042270 <ip_reasm_delete_ire+0x80>
         else prev_tmpp->next = irep->next;
 d04223c:	e0bffe17 	ldw	r2,-8(fp)
 d042240:	10c00017 	ldw	r3,0(r2)
 d042244:	e0bff717 	ldw	r2,-36(fp)
 d042248:	10c00015 	stw	r3,0(r2)
         break;
 d04224c:	00000806 	br	d042270 <ip_reasm_delete_ire+0x80>
         }
      prev_tmpp = tmpp;
 d042250:	e0bff817 	ldw	r2,-32(fp)
 d042254:	e0bff715 	stw	r2,-36(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d042258:	e0bff817 	ldw	r2,-32(fp)
 d04225c:	10800017 	ldw	r2,0(r2)
 d042260:	e0bff815 	stw	r2,-32(fp)
 d042264:	e0bff817 	ldw	r2,-32(fp)
 d042268:	1004c03a 	cmpne	r2,r2,zero
 d04226c:	103fe91e 	bne	r2,zero,d042214 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 d042270:	e0bff817 	ldw	r2,-32(fp)
 d042274:	1004c03a 	cmpne	r2,r2,zero
 d042278:	10000a1e 	bne	r2,zero,d0422a4 <ip_reasm_delete_ire+0xb4>
      {
      ++ire_stats.bad_irep;
 d04227c:	008341b4 	movhi	r2,3334
 d042280:	10857c04 	addi	r2,r2,5616
 d042284:	10800017 	ldw	r2,0(r2)
 d042288:	10c00044 	addi	r3,r2,1
 d04228c:	008341b4 	movhi	r2,3334
 d042290:	10857c04 	addi	r2,r2,5616
 d042294:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 d042298:	00bffd84 	movi	r2,-10
 d04229c:	e0bfff15 	stw	r2,-4(fp)
 d0422a0:	00003f06 	br	d0423a0 <ip_reasm_delete_ire+0x1b0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 d0422a4:	e0bffe17 	ldw	r2,-8(fp)
 d0422a8:	10800604 	addi	r2,r2,24
 d0422ac:	e0bffc15 	stw	r2,-16(fp)
 d0422b0:	e0bffc17 	ldw	r2,-16(fp)
 d0422b4:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 d0422b8:	00003106 	br	d042380 <ip_reasm_delete_ire+0x190>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d0422bc:	e03ffa0d 	sth	zero,-24(fp)
 d0422c0:	00002006 	br	d042344 <ip_reasm_delete_ire+0x154>
         {
         if ((p = rfqp->bufp [i]) != 0)
 d0422c4:	e0bffa0b 	ldhu	r2,-24(fp)
 d0422c8:	e0fffd17 	ldw	r3,-12(fp)
 d0422cc:	1085883a 	add	r2,r2,r2
 d0422d0:	1085883a 	add	r2,r2,r2
 d0422d4:	10c5883a 	add	r2,r2,r3
 d0422d8:	10800104 	addi	r2,r2,4
 d0422dc:	10800017 	ldw	r2,0(r2)
 d0422e0:	e0bff915 	stw	r2,-28(fp)
 d0422e4:	e0bff917 	ldw	r2,-28(fp)
 d0422e8:	1005003a 	cmpeq	r2,r2,zero
 d0422ec:	10000b1e 	bne	r2,zero,d04231c <ip_reasm_delete_ire+0x12c>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 d0422f0:	e0bff917 	ldw	r2,-28(fp)
 d0422f4:	10800217 	ldw	r2,8(r2)
 d0422f8:	113fffcc 	andi	r4,r2,65535
 d0422fc:	d040e080 	call	d040e08 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 d042300:	01000084 	movi	r4,2
 d042304:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free (p);
 d042308:	e13ff917 	ldw	r4,-28(fp)
 d04230c:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 d042310:	01000084 	movi	r4,2
 d042314:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
 d042318:	00000706 	br	d042338 <ip_reasm_delete_ire+0x148>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 d04231c:	e0bffe17 	ldw	r2,-8(fp)
 d042320:	10802103 	ldbu	r2,132(r2)
 d042324:	10803fcc 	andi	r2,r2,255
 d042328:	1080004c 	andi	r2,r2,1
 d04232c:	10803fcc 	andi	r2,r2,255
 d042330:	1004c03a 	cmpne	r2,r2,zero
 d042334:	1000061e 	bne	r2,zero,d042350 <ip_reasm_delete_ire+0x160>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d042338:	e0bffa0b 	ldhu	r2,-24(fp)
 d04233c:	10800044 	addi	r2,r2,1
 d042340:	e0bffa0d 	sth	r2,-24(fp)
 d042344:	e0bffa0b 	ldhu	r2,-24(fp)
 d042348:	10800430 	cmpltui	r2,r2,16
 d04234c:	103fdd1e 	bne	r2,zero,d0422c4 <ip_reasm_delete_ire+0xd4>
               break;
               }
            }
          }

       prev_rfqp = rfqp;
 d042350:	e0bffd17 	ldw	r2,-12(fp)
 d042354:	e0bffb15 	stw	r2,-20(fp)
       rfqp = rfqp->next;
 d042358:	e0bffd17 	ldw	r2,-12(fp)
 d04235c:	10800017 	ldw	r2,0(r2)
 d042360:	e0bffd15 	stw	r2,-12(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 d042364:	e0fffb17 	ldw	r3,-20(fp)
 d042368:	e0bffc17 	ldw	r2,-16(fp)
 d04236c:	18800426 	beq	r3,r2,d042380 <ip_reasm_delete_ire+0x190>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 d042370:	01001904 	movi	r4,100
 d042374:	d040e080 	call	d040e08 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 d042378:	e13ffb17 	ldw	r4,-20(fp)
 d04237c:	d0265ac0 	call	d0265ac <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 d042380:	e0bffd17 	ldw	r2,-12(fp)
 d042384:	1004c03a 	cmpne	r2,r2,zero
 d042388:	103fcc1e 	bne	r2,zero,d0422bc <ip_reasm_delete_ire+0xcc>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 d04238c:	01002204 	movi	r4,136
 d042390:	d040e080 	call	d040e08 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 d042394:	e13ffe17 	ldw	r4,-8(fp)
 d042398:	d0265ac0 	call	d0265ac <npfree>

   return IPREASM_OK;
 d04239c:	e03fff15 	stw	zero,-4(fp)
 d0423a0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0423a4:	e037883a 	mov	sp,fp
 d0423a8:	dfc00117 	ldw	ra,4(sp)
 d0423ac:	df000017 	ldw	fp,0(sp)
 d0423b0:	dec00204 	addi	sp,sp,8
 d0423b4:	f800283a 	ret

0d0423b8 <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 d0423b8:	defffa04 	addi	sp,sp,-24
 d0423bc:	dfc00515 	stw	ra,20(sp)
 d0423c0:	df000415 	stw	fp,16(sp)
 d0423c4:	df000404 	addi	fp,sp,16
 d0423c8:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 d0423cc:	e03ffc45 	stb	zero,-15(fp)
   u_char compact = IPREASM_TRUE;
 d0423d0:	00800044 	movi	r2,1
 d0423d4:	e0bffc05 	stb	r2,-16(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 d0423d8:	e13ffe17 	ldw	r4,-8(fp)
 d0423dc:	d041d4c0 	call	d041d4c <ip_reasm_find_ire>
 d0423e0:	10803fcc 	andi	r2,r2,255
 d0423e4:	10800060 	cmpeqi	r2,r2,1
 d0423e8:	10000a1e 	bne	r2,zero,d042414 <ip_reasm_mark_compact_rfq+0x5c>
   {
      ++ire_stats.bad_irep;
 d0423ec:	008341b4 	movhi	r2,3334
 d0423f0:	10857c04 	addi	r2,r2,5616
 d0423f4:	10800017 	ldw	r2,0(r2)
 d0423f8:	10c00044 	addi	r3,r2,1
 d0423fc:	008341b4 	movhi	r2,3334
 d042400:	10857c04 	addi	r2,r2,5616
 d042404:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 d042408:	00bffd84 	movi	r2,-10
 d04240c:	e0bfff15 	stw	r2,-4(fp)
 d042410:	00003506 	br	d0424e8 <ip_reasm_mark_compact_rfq+0x130>
   }

   rfqp = &(irep->rfq);
 d042414:	e0bffe17 	ldw	r2,-8(fp)
 d042418:	10800604 	addi	r2,r2,24
 d04241c:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 d042420:	00001c06 	br	d042494 <ip_reasm_mark_compact_rfq+0xdc>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d042424:	e03ffc8d 	sth	zero,-14(fp)
 d042428:	00001406 	br	d04247c <ip_reasm_mark_compact_rfq+0xc4>
         {
         if (rfqp->bufp [i] == 0)
 d04242c:	e0bffc8b 	ldhu	r2,-14(fp)
 d042430:	e0fffd17 	ldw	r3,-12(fp)
 d042434:	1085883a 	add	r2,r2,r2
 d042438:	1085883a 	add	r2,r2,r2
 d04243c:	10c5883a 	add	r2,r2,r3
 d042440:	10800104 	addi	r2,r2,4
 d042444:	10800017 	ldw	r2,0(r2)
 d042448:	1004c03a 	cmpne	r2,r2,zero
 d04244c:	1000031e 	bne	r2,zero,d04245c <ip_reasm_mark_compact_rfq+0xa4>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 d042450:	00800044 	movi	r2,1
 d042454:	e0bffc45 	stb	r2,-15(fp)
 d042458:	00000506 	br	d042470 <ip_reasm_mark_compact_rfq+0xb8>
            }
         else
            {
            if (empty_slot_discovered) 
 d04245c:	e0bffc43 	ldbu	r2,-15(fp)
 d042460:	1005003a 	cmpeq	r2,r2,zero
 d042464:	1000021e 	bne	r2,zero,d042470 <ip_reasm_mark_compact_rfq+0xb8>
               {
               compact = IPREASM_FALSE;
 d042468:	e03ffc05 	stb	zero,-16(fp)
               break;
 d04246c:	00000606 	br	d042488 <ip_reasm_mark_compact_rfq+0xd0>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d042470:	e0bffc8b 	ldhu	r2,-14(fp)
 d042474:	10800044 	addi	r2,r2,1
 d042478:	e0bffc8d 	sth	r2,-14(fp)
 d04247c:	e0bffc8b 	ldhu	r2,-14(fp)
 d042480:	10800430 	cmpltui	r2,r2,16
 d042484:	103fe91e 	bne	r2,zero,d04242c <ip_reasm_mark_compact_rfq+0x74>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 d042488:	e0bffd17 	ldw	r2,-12(fp)
 d04248c:	10800017 	ldw	r2,0(r2)
 d042490:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 d042494:	e0bffd17 	ldw	r2,-12(fp)
 d042498:	1004c03a 	cmpne	r2,r2,zero
 d04249c:	103fe11e 	bne	r2,zero,d042424 <ip_reasm_mark_compact_rfq+0x6c>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 d0424a0:	e0bffc03 	ldbu	r2,-16(fp)
 d0424a4:	1005003a 	cmpeq	r2,r2,zero
 d0424a8:	1000071e 	bne	r2,zero,d0424c8 <ip_reasm_mark_compact_rfq+0x110>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 d0424ac:	e0bffe17 	ldw	r2,-8(fp)
 d0424b0:	10802103 	ldbu	r2,132(r2)
 d0424b4:	10800054 	ori	r2,r2,1
 d0424b8:	1007883a 	mov	r3,r2
 d0424bc:	e0bffe17 	ldw	r2,-8(fp)
 d0424c0:	10c02105 	stb	r3,132(r2)
 d0424c4:	00000706 	br	d0424e4 <ip_reasm_mark_compact_rfq+0x12c>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 d0424c8:	e0bffe17 	ldw	r2,-8(fp)
 d0424cc:	10c02103 	ldbu	r3,132(r2)
 d0424d0:	00bfff84 	movi	r2,-2
 d0424d4:	1884703a 	and	r2,r3,r2
 d0424d8:	1007883a 	mov	r3,r2
 d0424dc:	e0bffe17 	ldw	r2,-8(fp)
 d0424e0:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 d0424e4:	e03fff15 	stw	zero,-4(fp)
 d0424e8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0424ec:	e037883a 	mov	sp,fp
 d0424f0:	dfc00117 	ldw	ra,4(sp)
 d0424f4:	df000017 	ldw	fp,0(sp)
 d0424f8:	dec00204 	addi	sp,sp,8
 d0424fc:	f800283a 	ret

0d042500 <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 d042500:	deffec04 	addi	sp,sp,-80
 d042504:	dfc01315 	stw	ra,76(sp)
 d042508:	df001215 	stw	fp,72(sp)
 d04250c:	dc001115 	stw	r16,68(sp)
 d042510:	df001104 	addi	fp,sp,68
 d042514:	e13fff15 	stw	r4,-4(fp)
   unsigned long ticks_elapsed = cticks;
 d042518:	00834174 	movhi	r2,3333
 d04251c:	109b4504 	addi	r2,r2,27924
 d042520:	10800017 	ldw	r2,0(r2)
 d042524:	e0bffe15 	stw	r2,-8(fp)
   u_short size_ire = sizeof(IRE);
 d042528:	00802204 	movi	r2,136
 d04252c:	e0bffd8d 	sth	r2,-10(fp)
   u_short size_rfq = sizeof(RFQ);
 d042530:	00801904 	movi	r2,100
 d042534:	e0bffd0d 	sth	r2,-12(fp)
   IREP tmpp;
   u_short count = 0;
 d042538:	e03ffb0d 	sth	zero,-20(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 d04253c:	e03ff98d 	sth	zero,-26(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 d042540:	e13fff17 	ldw	r4,-4(fp)
 d042544:	01434174 	movhi	r5,3333
 d042548:	29471004 	addi	r5,r5,7232
 d04254c:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 d042550:	d4294617 	ldw	r16,-23272(gp)
 d042554:	e13ffe17 	ldw	r4,-8(fp)
 d042558:	01401904 	movi	r5,100
 d04255c:	d00c90c0 	call	d00c90c <__udivsi3>
 d042560:	e0fffd8b 	ldhu	r3,-10(fp)
 d042564:	e13ffd0b 	ldhu	r4,-12(fp)
 d042568:	d8800015 	stw	r2,0(sp)
 d04256c:	d8c00115 	stw	r3,4(sp)
 d042570:	d9000215 	stw	r4,8(sp)
 d042574:	e13fff17 	ldw	r4,-4(fp)
 d042578:	01434174 	movhi	r5,3333
 d04257c:	29471704 	addi	r5,r5,7260
 d042580:	800d883a 	mov	r6,r16
 d042584:	e1fffe17 	ldw	r7,-8(fp)
 d042588:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 d04258c:	008341b4 	movhi	r2,3334
 d042590:	10857c04 	addi	r2,r2,5616
 d042594:	11800117 	ldw	r6,4(r2)
 d042598:	008341b4 	movhi	r2,3334
 d04259c:	10857c04 	addi	r2,r2,5616
 d0425a0:	11c00017 	ldw	r7,0(r2)
 d0425a4:	008341b4 	movhi	r2,3334
 d0425a8:	10857c04 	addi	r2,r2,5616
 d0425ac:	11000217 	ldw	r4,8(r2)
 d0425b0:	008341b4 	movhi	r2,3334
 d0425b4:	10857c04 	addi	r2,r2,5616
 d0425b8:	11400317 	ldw	r5,12(r2)
 d0425bc:	008341b4 	movhi	r2,3334
 d0425c0:	10857c04 	addi	r2,r2,5616
 d0425c4:	10c00417 	ldw	r3,16(r2)
 d0425c8:	008341b4 	movhi	r2,3334
 d0425cc:	10857c04 	addi	r2,r2,5616
 d0425d0:	10800517 	ldw	r2,20(r2)
 d0425d4:	d9000015 	stw	r4,0(sp)
 d0425d8:	d9400115 	stw	r5,4(sp)
 d0425dc:	d8c00215 	stw	r3,8(sp)
 d0425e0:	d8800315 	stw	r2,12(sp)
 d0425e4:	e13fff17 	ldw	r4,-4(fp)
 d0425e8:	01434174 	movhi	r5,3333
 d0425ec:	29472704 	addi	r5,r5,7324
 d0425f0:	d020b640 	call	d020b64 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 d0425f4:	d1a94717 	ldw	r6,-23268(gp)
 d0425f8:	e13fff17 	ldw	r4,-4(fp)
 d0425fc:	01434174 	movhi	r5,3333
 d042600:	29473c04 	addi	r5,r5,7408
 d042604:	d020b640 	call	d020b64 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d042608:	d0a94717 	ldw	r2,-23268(gp)
 d04260c:	e0bffc15 	stw	r2,-16(fp)
 d042610:	00008106 	br	d042818 <ipr_stats+0x318>
      {
      ++count;
 d042614:	e0bffb0b 	ldhu	r2,-20(fp)
 d042618:	10800044 	addi	r2,r2,1
 d04261c:	e0bffb0d 	sth	r2,-20(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 d042620:	e0bffc17 	ldw	r2,-16(fp)
 d042624:	10800604 	addi	r2,r2,24
 d042628:	e0bffa15 	stw	r2,-24(fp)
      while (rfqp)
 d04262c:	00001f06 	br	d0426ac <ipr_stats+0x1ac>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d042630:	e03ff90d 	sth	zero,-28(fp)
 d042634:	00001706 	br	d042694 <ipr_stats+0x194>
            {
            if (rfqp->bufp [i] != 0)
 d042638:	e0bff90b 	ldhu	r2,-28(fp)
 d04263c:	e0fffa17 	ldw	r3,-24(fp)
 d042640:	1085883a 	add	r2,r2,r2
 d042644:	1085883a 	add	r2,r2,r2
 d042648:	10c5883a 	add	r2,r2,r3
 d04264c:	10800104 	addi	r2,r2,4
 d042650:	10800017 	ldw	r2,0(r2)
 d042654:	1005003a 	cmpeq	r2,r2,zero
 d042658:	1000041e 	bne	r2,zero,d04266c <ipr_stats+0x16c>
               {
               ++frag_count;            
 d04265c:	e0bff98b 	ldhu	r2,-26(fp)
 d042660:	10800044 	addi	r2,r2,1
 d042664:	e0bff98d 	sth	r2,-26(fp)
 d042668:	00000706 	br	d042688 <ipr_stats+0x188>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 d04266c:	e0bffc17 	ldw	r2,-16(fp)
 d042670:	10802103 	ldbu	r2,132(r2)
 d042674:	10803fcc 	andi	r2,r2,255
 d042678:	1080004c 	andi	r2,r2,1
 d04267c:	10803fcc 	andi	r2,r2,255
 d042680:	1004c03a 	cmpne	r2,r2,zero
 d042684:	1000061e 	bne	r2,zero,d0426a0 <ipr_stats+0x1a0>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d042688:	e0bff90b 	ldhu	r2,-28(fp)
 d04268c:	10800044 	addi	r2,r2,1
 d042690:	e0bff90d 	sth	r2,-28(fp)
 d042694:	e0bff90b 	ldhu	r2,-28(fp)
 d042698:	10800430 	cmpltui	r2,r2,16
 d04269c:	103fe61e 	bne	r2,zero,d042638 <ipr_stats+0x138>
                  {
                  break;
                  }
               }
            }
         rfqp = rfqp->next;
 d0426a0:	e0bffa17 	ldw	r2,-24(fp)
 d0426a4:	10800017 	ldw	r2,0(r2)
 d0426a8:	e0bffa15 	stw	r2,-24(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 d0426ac:	e0bffa17 	ldw	r2,-24(fp)
 d0426b0:	1004c03a 	cmpne	r2,r2,zero
 d0426b4:	103fde1e 	bne	r2,zero,d042630 <ipr_stats+0x130>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 d0426b8:	e1fff98b 	ldhu	r7,-26(fp)
 d0426bc:	e0bffc17 	ldw	r2,-16(fp)
 d0426c0:	10800117 	ldw	r2,4(r2)
 d0426c4:	1004d63a 	srli	r2,r2,24
 d0426c8:	10c03fcc 	andi	r3,r2,255
 d0426cc:	e0bffc17 	ldw	r2,-16(fp)
 d0426d0:	10800117 	ldw	r2,4(r2)
 d0426d4:	1004d23a 	srli	r2,r2,8
 d0426d8:	10bfc00c 	andi	r2,r2,65280
 d0426dc:	1886b03a 	or	r3,r3,r2
 d0426e0:	e0bffc17 	ldw	r2,-16(fp)
 d0426e4:	10800117 	ldw	r2,4(r2)
 d0426e8:	10bfc00c 	andi	r2,r2,65280
 d0426ec:	1004923a 	slli	r2,r2,8
 d0426f0:	1886b03a 	or	r3,r3,r2
 d0426f4:	e0bffc17 	ldw	r2,-16(fp)
 d0426f8:	10800117 	ldw	r2,4(r2)
 d0426fc:	10803fcc 	andi	r2,r2,255
 d042700:	1004963a 	slli	r2,r2,24
 d042704:	1888b03a 	or	r4,r3,r2
 d042708:	e0bffc17 	ldw	r2,-16(fp)
 d04270c:	10800217 	ldw	r2,8(r2)
 d042710:	1004d63a 	srli	r2,r2,24
 d042714:	10c03fcc 	andi	r3,r2,255
 d042718:	e0bffc17 	ldw	r2,-16(fp)
 d04271c:	10800217 	ldw	r2,8(r2)
 d042720:	1004d23a 	srli	r2,r2,8
 d042724:	10bfc00c 	andi	r2,r2,65280
 d042728:	1886b03a 	or	r3,r3,r2
 d04272c:	e0bffc17 	ldw	r2,-16(fp)
 d042730:	10800217 	ldw	r2,8(r2)
 d042734:	10bfc00c 	andi	r2,r2,65280
 d042738:	1004923a 	slli	r2,r2,8
 d04273c:	1886b03a 	or	r3,r3,r2
 d042740:	e0bffc17 	ldw	r2,-16(fp)
 d042744:	10800217 	ldw	r2,8(r2)
 d042748:	10803fcc 	andi	r2,r2,255
 d04274c:	1004963a 	slli	r2,r2,24
 d042750:	188ab03a 	or	r5,r3,r2
 d042754:	e0bffc17 	ldw	r2,-16(fp)
 d042758:	10800383 	ldbu	r2,14(r2)
 d04275c:	11803fcc 	andi	r6,r2,255
 d042760:	e0bffc17 	ldw	r2,-16(fp)
 d042764:	1080030b 	ldhu	r2,12(r2)
 d042768:	10bfffcc 	andi	r2,r2,65535
 d04276c:	1004d23a 	srli	r2,r2,8
 d042770:	10bfffcc 	andi	r2,r2,65535
 d042774:	10c03fcc 	andi	r3,r2,255
 d042778:	e0bffc17 	ldw	r2,-16(fp)
 d04277c:	1080030b 	ldhu	r2,12(r2)
 d042780:	10bfffcc 	andi	r2,r2,65535
 d042784:	1004923a 	slli	r2,r2,8
 d042788:	10bfc00c 	andi	r2,r2,65280
 d04278c:	1886b03a 	or	r3,r3,r2
 d042790:	e0bffc17 	ldw	r2,-16(fp)
 d042794:	1080040b 	ldhu	r2,16(r2)
 d042798:	123fffcc 	andi	r8,r2,65535
 d04279c:	e0bffc17 	ldw	r2,-16(fp)
 d0427a0:	1080048b 	ldhu	r2,18(r2)
 d0427a4:	127fffcc 	andi	r9,r2,65535
 d0427a8:	e0bffc17 	ldw	r2,-16(fp)
 d0427ac:	12800517 	ldw	r10,20(r2)
 d0427b0:	e0bffc17 	ldw	r2,-16(fp)
 d0427b4:	12c01f17 	ldw	r11,124(r2)
 d0427b8:	e0bffc17 	ldw	r2,-16(fp)
 d0427bc:	13002017 	ldw	r12,128(r2)
 d0427c0:	e0bffc17 	ldw	r2,-16(fp)
 d0427c4:	10802103 	ldbu	r2,132(r2)
 d0427c8:	10803fcc 	andi	r2,r2,255
 d0427cc:	1080004c 	andi	r2,r2,1
 d0427d0:	d9000015 	stw	r4,0(sp)
 d0427d4:	d9400115 	stw	r5,4(sp)
 d0427d8:	d9800215 	stw	r6,8(sp)
 d0427dc:	d8c00315 	stw	r3,12(sp)
 d0427e0:	da000415 	stw	r8,16(sp)
 d0427e4:	da400515 	stw	r9,20(sp)
 d0427e8:	da800615 	stw	r10,24(sp)
 d0427ec:	dac00715 	stw	r11,28(sp)
 d0427f0:	db000815 	stw	r12,32(sp)
 d0427f4:	d8800915 	stw	r2,36(sp)
 d0427f8:	e13fff17 	ldw	r4,-4(fp)
 d0427fc:	01434174 	movhi	r5,3333
 d042800:	29474204 	addi	r5,r5,7432
 d042804:	e1bffc17 	ldw	r6,-16(fp)
 d042808:	d020b640 	call	d020b64 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d04280c:	e0bffc17 	ldw	r2,-16(fp)
 d042810:	10800017 	ldw	r2,0(r2)
 d042814:	e0bffc15 	stw	r2,-16(fp)
 d042818:	e0bffc17 	ldw	r2,-16(fp)
 d04281c:	1004c03a 	cmpne	r2,r2,zero
 d042820:	103f7c1e 	bne	r2,zero,d042614 <ipr_stats+0x114>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 d042824:	e1bffb0b 	ldhu	r6,-20(fp)
 d042828:	e13fff17 	ldw	r4,-4(fp)
 d04282c:	01434174 	movhi	r5,3333
 d042830:	29475d04 	addi	r5,r5,7540
 d042834:	d020b640 	call	d020b64 <ns_printf>

   return IPREASM_OK;
 d042838:	0005883a 	mov	r2,zero
}
 d04283c:	e037883a 	mov	sp,fp
 d042840:	dfc00217 	ldw	ra,8(sp)
 d042844:	df000117 	ldw	fp,4(sp)
 d042848:	dc000017 	ldw	r16,0(sp)
 d04284c:	dec00304 	addi	sp,sp,12
 d042850:	f800283a 	ret

0d042854 <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 d042854:	defffc04 	addi	sp,sp,-16
 d042858:	dfc00315 	stw	ra,12(sp)
 d04285c:	df000215 	stw	fp,8(sp)
 d042860:	df000204 	addi	fp,sp,8
 d042864:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 d042868:	e0bfff17 	ldw	r2,-4(fp)
 d04286c:	10801f17 	ldw	r2,124(r2)
 d042870:	1005003a 	cmpeq	r2,r2,zero
 d042874:	1000061e 	bne	r2,zero,d042890 <ip_reasm_send_icmp_timex+0x3c>
      {
      pip = (struct ip *) irep->l3_hdr;
 d042878:	e0bfff17 	ldw	r2,-4(fp)
 d04287c:	10802017 	ldw	r2,128(r2)
 d042880:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 d042884:	e13ffe17 	ldw	r4,-8(fp)
 d042888:	01400044 	movi	r5,1
 d04288c:	d04ba140 	call	d04ba14 <icmp_timex>
      }

   return IPREASM_OK;
 d042890:	0005883a 	mov	r2,zero
}
 d042894:	e037883a 	mov	sp,fp
 d042898:	dfc00117 	ldw	ra,4(sp)
 d04289c:	df000017 	ldw	fp,0(sp)
 d0428a0:	dec00204 	addi	sp,sp,8
 d0428a4:	f800283a 	ret

0d0428a8 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 d0428a8:	defff204 	addi	sp,sp,-56
 d0428ac:	dfc00d15 	stw	ra,52(sp)
 d0428b0:	df000c15 	stw	fp,48(sp)
 d0428b4:	dc000b15 	stw	r16,44(sp)
 d0428b8:	df000b04 	addi	fp,sp,44
 d0428bc:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 d0428c0:	00bfffc4 	movi	r2,-1
 d0428c4:	e0bff515 	stw	r2,-44(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d0428c8:	00834174 	movhi	r2,3333
 d0428cc:	109b2004 	addi	r2,r2,27776
 d0428d0:	10800017 	ldw	r2,0(r2)
 d0428d4:	1081000c 	andi	r2,r2,1024
 d0428d8:	1005003a 	cmpeq	r2,r2,zero
 d0428dc:	1000101e 	bne	r2,zero,d042920 <ip_rcv+0x78>
 d0428e0:	00834174 	movhi	r2,3333
 d0428e4:	109b2004 	addi	r2,r2,27776
 d0428e8:	10800017 	ldw	r2,0(r2)
 d0428ec:	1080800c 	andi	r2,r2,512
 d0428f0:	1005003a 	cmpeq	r2,r2,zero
 d0428f4:	10000a1e 	bne	r2,zero,d042920 <ip_rcv+0x78>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 d0428f8:	e0bffe17 	ldw	r2,-8(fp)
 d0428fc:	14000417 	ldw	r16,16(r2)
 d042900:	e0bffe17 	ldw	r2,-8(fp)
 d042904:	11000617 	ldw	r4,24(r2)
 d042908:	d01e88c0 	call	d01e88c <if_netnumber>
 d04290c:	100d883a 	mov	r6,r2
 d042910:	01034174 	movhi	r4,3333
 d042914:	21076604 	addi	r4,r4,7576
 d042918:	800b883a 	mov	r5,r16
 d04291c:	d0028a00 	call	d0028a0 <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   nt = p->net;      /* which interface it came in on */
 d042920:	e0bffe17 	ldw	r2,-8(fp)
 d042924:	10800617 	ldw	r2,24(r2)
 d042928:	e0bffb15 	stw	r2,-20(fp)
   ip_mib.ipInReceives++;
 d04292c:	008341b4 	movhi	r2,3334
 d042930:	10856804 	addi	r2,r2,5536
 d042934:	10800217 	ldw	r2,8(r2)
 d042938:	10c00044 	addi	r3,r2,1
 d04293c:	008341b4 	movhi	r2,3334
 d042940:	10856804 	addi	r2,r2,5536
 d042944:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 d042948:	e0bffe17 	ldw	r2,-8(fp)
 d04294c:	10800317 	ldw	r2,12(r2)
 d042950:	e0bffd15 	stw	r2,-12(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 d042954:	e0bffe17 	ldw	r2,-8(fp)
 d042958:	11000417 	ldw	r4,16(r2)
 d04295c:	e0bffd17 	ldw	r2,-12(fp)
 d042960:	1080008b 	ldhu	r2,2(r2)
 d042964:	10bfffcc 	andi	r2,r2,65535
 d042968:	1004d23a 	srli	r2,r2,8
 d04296c:	10bfffcc 	andi	r2,r2,65535
 d042970:	10c03fcc 	andi	r3,r2,255
 d042974:	e0bffd17 	ldw	r2,-12(fp)
 d042978:	1080008b 	ldhu	r2,2(r2)
 d04297c:	10bfffcc 	andi	r2,r2,65535
 d042980:	1004923a 	slli	r2,r2,8
 d042984:	10bfc00c 	andi	r2,r2,65280
 d042988:	1884b03a 	or	r2,r3,r2
 d04298c:	2080272e 	bgeu	r4,r2,d042a2c <ip_rcv+0x184>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d042990:	00834174 	movhi	r2,3333
 d042994:	109b2004 	addi	r2,r2,27776
 d042998:	10800017 	ldw	r2,0(r2)
 d04299c:	1081000c 	andi	r2,r2,1024
 d0429a0:	1005003a 	cmpeq	r2,r2,zero
 d0429a4:	1000111e 	bne	r2,zero,d0429ec <ip_rcv+0x144>
 d0429a8:	00834174 	movhi	r2,3333
 d0429ac:	109b2004 	addi	r2,r2,27776
 d0429b0:	10800017 	ldw	r2,0(r2)
 d0429b4:	1080800c 	andi	r2,r2,512
 d0429b8:	1005003a 	cmpeq	r2,r2,zero
 d0429bc:	10000b1e 	bne	r2,zero,d0429ec <ip_rcv+0x144>
      {
         dprintf("ip_rcv: bad pkt len\n");
 d0429c0:	01034174 	movhi	r4,3333
 d0429c4:	21076f04 	addi	r4,r4,7612
 d0429c8:	d002bc80 	call	d002bc8 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 d0429cc:	00834174 	movhi	r2,3333
 d0429d0:	109b2004 	addi	r2,r2,27776
 d0429d4:	10800017 	ldw	r2,0(r2)
 d0429d8:	1080008c 	andi	r2,r2,2
 d0429dc:	1005003a 	cmpeq	r2,r2,zero
 d0429e0:	1000021e 	bne	r2,zero,d0429ec <ip_rcv+0x144>
 d0429e4:	e13ffe17 	ldw	r4,-8(fp)
 d0429e8:	d0404b00 	call	d0404b0 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 d0429ec:	008341b4 	movhi	r2,3334
 d0429f0:	10856804 	addi	r2,r2,5536
 d0429f4:	10800317 	ldw	r2,12(r2)
 d0429f8:	10c00044 	addi	r3,r2,1
 d0429fc:	008341b4 	movhi	r2,3334
 d042a00:	10856804 	addi	r2,r2,5536
 d042a04:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d042a08:	01000084 	movi	r4,2
 d042a0c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d042a10:	e13ffe17 	ldw	r4,-8(fp)
 d042a14:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042a18:	01000084 	movi	r4,2
 d042a1c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 d042a20:	00bff804 	movi	r2,-32
 d042a24:	e0bfff15 	stw	r2,-4(fp)
 d042a28:	00009806 	br	d042c8c <ip_rcv+0x3e4>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 d042a2c:	e0bffd17 	ldw	r2,-12(fp)
 d042a30:	1080008b 	ldhu	r2,2(r2)
 d042a34:	10bfffcc 	andi	r2,r2,65535
 d042a38:	1004d23a 	srli	r2,r2,8
 d042a3c:	10bfffcc 	andi	r2,r2,65535
 d042a40:	10c03fcc 	andi	r3,r2,255
 d042a44:	e0bffd17 	ldw	r2,-12(fp)
 d042a48:	1080008b 	ldhu	r2,2(r2)
 d042a4c:	10bfffcc 	andi	r2,r2,65535
 d042a50:	1004923a 	slli	r2,r2,8
 d042a54:	10bfc00c 	andi	r2,r2,65280
 d042a58:	1884b03a 	or	r2,r3,r2
 d042a5c:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 d042a60:	e0fffe17 	ldw	r3,-8(fp)
 d042a64:	e0bff917 	ldw	r2,-28(fp)
 d042a68:	18800415 	stw	r2,16(r3)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 d042a6c:	e0bffd17 	ldw	r2,-12(fp)
 d042a70:	10800003 	ldbu	r2,0(r2)
 d042a74:	10803fcc 	andi	r2,r2,255
 d042a78:	10803c0c 	andi	r2,r2,240
 d042a7c:	1005d13a 	srai	r2,r2,4
 d042a80:	10800120 	cmpeqi	r2,r2,4
 d042a84:	1000271e 	bne	r2,zero,d042b24 <ip_rcv+0x27c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d042a88:	00834174 	movhi	r2,3333
 d042a8c:	109b2004 	addi	r2,r2,27776
 d042a90:	10800017 	ldw	r2,0(r2)
 d042a94:	1081000c 	andi	r2,r2,1024
 d042a98:	1005003a 	cmpeq	r2,r2,zero
 d042a9c:	1000111e 	bne	r2,zero,d042ae4 <ip_rcv+0x23c>
 d042aa0:	00834174 	movhi	r2,3333
 d042aa4:	109b2004 	addi	r2,r2,27776
 d042aa8:	10800017 	ldw	r2,0(r2)
 d042aac:	1080800c 	andi	r2,r2,512
 d042ab0:	1005003a 	cmpeq	r2,r2,zero
 d042ab4:	10000b1e 	bne	r2,zero,d042ae4 <ip_rcv+0x23c>
      {
         dprintf("ip_rcv: bad version number\n");
 d042ab8:	01034174 	movhi	r4,3333
 d042abc:	21077404 	addi	r4,r4,7632
 d042ac0:	d002bc80 	call	d002bc8 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 d042ac4:	00834174 	movhi	r2,3333
 d042ac8:	109b2004 	addi	r2,r2,27776
 d042acc:	10800017 	ldw	r2,0(r2)
 d042ad0:	1080008c 	andi	r2,r2,2
 d042ad4:	1005003a 	cmpeq	r2,r2,zero
 d042ad8:	1000021e 	bne	r2,zero,d042ae4 <ip_rcv+0x23c>
 d042adc:	e13ffe17 	ldw	r4,-8(fp)
 d042ae0:	d0404b00 	call	d0404b0 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 d042ae4:	008341b4 	movhi	r2,3334
 d042ae8:	10856804 	addi	r2,r2,5536
 d042aec:	10800317 	ldw	r2,12(r2)
 d042af0:	10c00044 	addi	r3,r2,1
 d042af4:	008341b4 	movhi	r2,3334
 d042af8:	10856804 	addi	r2,r2,5536
 d042afc:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d042b00:	01000084 	movi	r4,2
 d042b04:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d042b08:	e13ffe17 	ldw	r4,-8(fp)
 d042b0c:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042b10:	01000084 	movi	r4,2
 d042b14:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 d042b18:	00bff804 	movi	r2,-32
 d042b1c:	e0bfff15 	stw	r2,-4(fp)
 d042b20:	00005a06 	br	d042c8c <ip_rcv+0x3e4>
   }

   csum = pip->ip_chksum;
 d042b24:	e0bffd17 	ldw	r2,-12(fp)
 d042b28:	1080028b 	ldhu	r2,10(r2)
 d042b2c:	e0bffc8d 	sth	r2,-14(fp)
   pip->ip_chksum = 0;
 d042b30:	e0bffd17 	ldw	r2,-12(fp)
 d042b34:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 d042b38:	e0bffd17 	ldw	r2,-12(fp)
 d042b3c:	10800003 	ldbu	r2,0(r2)
 d042b40:	10803fcc 	andi	r2,r2,255
 d042b44:	108003cc 	andi	r2,r2,15
 d042b48:	1085883a 	add	r2,r2,r2
 d042b4c:	1085883a 	add	r2,r2,r2
 d042b50:	e0bffa15 	stw	r2,-24(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 d042b54:	e0bffa17 	ldw	r2,-24(fp)
 d042b58:	100ad07a 	srli	r5,r2,1
 d042b5c:	e13ffd17 	ldw	r4,-12(fp)
 d042b60:	d0205440 	call	d020544 <cksum>
 d042b64:	0084303a 	nor	r2,zero,r2
 d042b68:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 d042b6c:	e0fffc8b 	ldhu	r3,-14(fp)
 d042b70:	e0bffc0b 	ldhu	r2,-16(fp)
 d042b74:	18802a26 	beq	r3,r2,d042c20 <ip_rcv+0x378>
   {
      pip->ip_chksum = csum;
 d042b78:	e0fffd17 	ldw	r3,-12(fp)
 d042b7c:	e0bffc8b 	ldhu	r2,-14(fp)
 d042b80:	1880028d 	sth	r2,10(r3)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d042b84:	00834174 	movhi	r2,3333
 d042b88:	109b2004 	addi	r2,r2,27776
 d042b8c:	10800017 	ldw	r2,0(r2)
 d042b90:	1081000c 	andi	r2,r2,1024
 d042b94:	1005003a 	cmpeq	r2,r2,zero
 d042b98:	1000111e 	bne	r2,zero,d042be0 <ip_rcv+0x338>
 d042b9c:	00834174 	movhi	r2,3333
 d042ba0:	109b2004 	addi	r2,r2,27776
 d042ba4:	10800017 	ldw	r2,0(r2)
 d042ba8:	1080800c 	andi	r2,r2,512
 d042bac:	1005003a 	cmpeq	r2,r2,zero
 d042bb0:	10000b1e 	bne	r2,zero,d042be0 <ip_rcv+0x338>
      {
         dprintf("ip_rcv: bad xsum\n");
 d042bb4:	01034174 	movhi	r4,3333
 d042bb8:	21077b04 	addi	r4,r4,7660
 d042bbc:	d002bc80 	call	d002bc8 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 d042bc0:	00834174 	movhi	r2,3333
 d042bc4:	109b2004 	addi	r2,r2,27776
 d042bc8:	10800017 	ldw	r2,0(r2)
 d042bcc:	1080008c 	andi	r2,r2,2
 d042bd0:	1005003a 	cmpeq	r2,r2,zero
 d042bd4:	1000021e 	bne	r2,zero,d042be0 <ip_rcv+0x338>
 d042bd8:	e13ffe17 	ldw	r4,-8(fp)
 d042bdc:	d0404b00 	call	d0404b0 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 d042be0:	008341b4 	movhi	r2,3334
 d042be4:	10856804 	addi	r2,r2,5536
 d042be8:	10800317 	ldw	r2,12(r2)
 d042bec:	10c00044 	addi	r3,r2,1
 d042bf0:	008341b4 	movhi	r2,3334
 d042bf4:	10856804 	addi	r2,r2,5536
 d042bf8:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d042bfc:	01000084 	movi	r4,2
 d042c00:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d042c04:	e13ffe17 	ldw	r4,-8(fp)
 d042c08:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042c0c:	01000084 	movi	r4,2
 d042c10:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 d042c14:	00bff804 	movi	r2,-32
 d042c18:	e0bfff15 	stw	r2,-4(fp)
 d042c1c:	00001b06 	br	d042c8c <ip_rcv+0x3e4>
   }

   pip->ip_chksum = csum;
 d042c20:	e0fffd17 	ldw	r3,-12(fp)
 d042c24:	e0bffc8b 	ldhu	r2,-14(fp)
 d042c28:	1880028d 	sth	r2,10(r3)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 d042c2c:	00800044 	movi	r2,1
 d042c30:	e0bff80d 	sth	r2,-32(fp)
    pktp = &p;
 d042c34:	e0bffe04 	addi	r2,fp,-8
 d042c38:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 d042c3c:	e03ff605 	stb	zero,-40(fp)
 d042c40:	00000c06 	br	d042c74 <ip_rcv+0x3cc>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 d042c44:	e0bff603 	ldbu	r2,-40(fp)
 d042c48:	1085883a 	add	r2,r2,r2
 d042c4c:	1085883a 	add	r2,r2,r2
 d042c50:	1007883a 	mov	r3,r2
 d042c54:	e0bff717 	ldw	r2,-36(fp)
 d042c58:	1885883a 	add	r2,r3,r2
 d042c5c:	11000017 	ldw	r4,0(r2)
 d042c60:	d042ca80 	call	d042ca8 <ip_rcv_phase2>
 d042c64:	e0bff515 	stw	r2,-44(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 d042c68:	e0bff603 	ldbu	r2,-40(fp)
 d042c6c:	10800044 	addi	r2,r2,1
 d042c70:	e0bff605 	stb	r2,-40(fp)
 d042c74:	e0bff603 	ldbu	r2,-40(fp)
 d042c78:	10ffffcc 	andi	r3,r2,65535
 d042c7c:	e0bff80b 	ldhu	r2,-32(fp)
 d042c80:	18bff036 	bltu	r3,r2,d042c44 <ip_rcv+0x39c>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 d042c84:	e0bff517 	ldw	r2,-44(fp)
 d042c88:	e0bfff15 	stw	r2,-4(fp)
 d042c8c:	e0bfff17 	ldw	r2,-4(fp)
}
 d042c90:	e037883a 	mov	sp,fp
 d042c94:	dfc00217 	ldw	ra,8(sp)
 d042c98:	df000117 	ldw	fp,4(sp)
 d042c9c:	dc000017 	ldw	r16,0(sp)
 d042ca0:	dec00304 	addi	sp,sp,12
 d042ca4:	f800283a 	ret

0d042ca8 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 d042ca8:	defff404 	addi	sp,sp,-48
 d042cac:	dfc00b15 	stw	ra,44(sp)
 d042cb0:	df000a15 	stw	fp,40(sp)
 d042cb4:	df000a04 	addi	fp,sp,40
 d042cb8:	e13ffe15 	stw	r4,-8(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 d042cbc:	e0bffe17 	ldw	r2,-8(fp)
 d042cc0:	10800317 	ldw	r2,12(r2)
 d042cc4:	e0bffc15 	stw	r2,-16(fp)
   nt = p->net;      /* which interface it came in on */
 d042cc8:	e0bffe17 	ldw	r2,-8(fp)
 d042ccc:	10800617 	ldw	r2,24(r2)
 d042cd0:	e0bffb15 	stw	r2,-20(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 d042cd4:	e0bffc17 	ldw	r2,-16(fp)
 d042cd8:	10800417 	ldw	r2,16(r2)
 d042cdc:	1004d63a 	srli	r2,r2,24
 d042ce0:	10c03fcc 	andi	r3,r2,255
 d042ce4:	e0bffc17 	ldw	r2,-16(fp)
 d042ce8:	10800417 	ldw	r2,16(r2)
 d042cec:	1004d23a 	srli	r2,r2,8
 d042cf0:	10bfc00c 	andi	r2,r2,65280
 d042cf4:	1886b03a 	or	r3,r3,r2
 d042cf8:	e0bffc17 	ldw	r2,-16(fp)
 d042cfc:	10800417 	ldw	r2,16(r2)
 d042d00:	10bfc00c 	andi	r2,r2,65280
 d042d04:	1004923a 	slli	r2,r2,8
 d042d08:	1886b03a 	or	r3,r3,r2
 d042d0c:	e0bffc17 	ldw	r2,-16(fp)
 d042d10:	10800417 	ldw	r2,16(r2)
 d042d14:	10803fcc 	andi	r2,r2,255
 d042d18:	1004963a 	slli	r2,r2,24
 d042d1c:	1884b03a 	or	r2,r3,r2
 d042d20:	10fc002c 	andhi	r3,r2,61440
 d042d24:	00b80034 	movhi	r2,57344
 d042d28:	1880181e 	bne	r3,r2,d042d8c <ip_rcv_phase2+0xe4>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 d042d2c:	e0bffc17 	ldw	r2,-16(fp)
 d042d30:	11000417 	ldw	r4,16(r2)
 d042d34:	e17ffb17 	ldw	r5,-20(fp)
 d042d38:	d0439640 	call	d043964 <lookup_mcast>
 d042d3c:	e0bff915 	stw	r2,-28(fp)
      if (inm == NULL) 
 d042d40:	e0bff917 	ldw	r2,-28(fp)
 d042d44:	1004c03a 	cmpne	r2,r2,zero
 d042d48:	10010d1e 	bne	r2,zero,d043180 <ip_rcv_phase2+0x4d8>
      {
         ip_mib.ipOutNoRoutes++;
 d042d4c:	008341b4 	movhi	r2,3334
 d042d50:	10856804 	addi	r2,r2,5536
 d042d54:	10800b17 	ldw	r2,44(r2)
 d042d58:	10c00044 	addi	r3,r2,1
 d042d5c:	008341b4 	movhi	r2,3334
 d042d60:	10856804 	addi	r2,r2,5536
 d042d64:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d042d68:	01000084 	movi	r4,2
 d042d6c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(p);
 d042d70:	e13ffe17 	ldw	r4,-8(fp)
 d042d74:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042d78:	01000084 	movi	r4,2
 d042d7c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 d042d80:	00800084 	movi	r2,2
 d042d84:	e0bfff15 	stw	r2,-4(fp)
 d042d88:	00014406 	br	d04329c <ip_rcv_phase2+0x5f4>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 d042d8c:	e0bffc17 	ldw	r2,-16(fp)
 d042d90:	10c00417 	ldw	r3,16(r2)
 d042d94:	e0bffb17 	ldw	r2,-20(fp)
 d042d98:	10800a17 	ldw	r2,40(r2)
 d042d9c:	1880f826 	beq	r3,r2,d043180 <ip_rcv_phase2+0x4d8>
 d042da0:	e0bffc17 	ldw	r2,-16(fp)
 d042da4:	10800417 	ldw	r2,16(r2)
 d042da8:	10bfffe0 	cmpeqi	r2,r2,-1
 d042dac:	1000f41e 	bne	r2,zero,d043180 <ip_rcv_phase2+0x4d8>
 d042db0:	e0bffc17 	ldw	r2,-16(fp)
 d042db4:	10c00417 	ldw	r3,16(r2)
 d042db8:	e0bffb17 	ldw	r2,-20(fp)
 d042dbc:	10800e17 	ldw	r2,56(r2)
 d042dc0:	1880ef26 	beq	r3,r2,d043180 <ip_rcv_phase2+0x4d8>
 d042dc4:	e0bffc17 	ldw	r2,-16(fp)
 d042dc8:	10c00417 	ldw	r3,16(r2)
 d042dcc:	e0bffb17 	ldw	r2,-20(fp)
 d042dd0:	10800f17 	ldw	r2,60(r2)
 d042dd4:	1880ea26 	beq	r3,r2,d043180 <ip_rcv_phase2+0x4d8>
 d042dd8:	e0bffc17 	ldw	r2,-16(fp)
 d042ddc:	10c00417 	ldw	r3,16(r2)
 d042de0:	e0bffb17 	ldw	r2,-20(fp)
 d042de4:	10801017 	ldw	r2,64(r2)
 d042de8:	1880e526 	beq	r3,r2,d043180 <ip_rcv_phase2+0x4d8>
 d042dec:	e0bffb17 	ldw	r2,-20(fp)
 d042df0:	10c00a17 	ldw	r3,40(r2)
 d042df4:	e0bffb17 	ldw	r2,-20(fp)
 d042df8:	10800c17 	ldw	r2,48(r2)
 d042dfc:	0084303a 	nor	r2,zero,r2
 d042e00:	1884703a 	and	r2,r3,r2
 d042e04:	1005003a 	cmpeq	r2,r2,zero
 d042e08:	1000dd1e 	bne	r2,zero,d043180 <ip_rcv_phase2+0x4d8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d042e0c:	00834174 	movhi	r2,3333
 d042e10:	109b2004 	addi	r2,r2,27776
 d042e14:	10800017 	ldw	r2,0(r2)
 d042e18:	1081000c 	andi	r2,r2,1024
 d042e1c:	1005003a 	cmpeq	r2,r2,zero
 d042e20:	1000181e 	bne	r2,zero,d042e84 <ip_rcv_phase2+0x1dc>
 d042e24:	00834174 	movhi	r2,3333
 d042e28:	109b2004 	addi	r2,r2,27776
 d042e2c:	10800017 	ldw	r2,0(r2)
 d042e30:	1080800c 	andi	r2,r2,512
 d042e34:	1005003a 	cmpeq	r2,r2,zero
 d042e38:	1000121e 	bne	r2,zero,d042e84 <ip_rcv_phase2+0x1dc>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 d042e3c:	e0bffc17 	ldw	r2,-16(fp)
 d042e40:	10800417 	ldw	r2,16(r2)
 d042e44:	11403fcc 	andi	r5,r2,255
 d042e48:	e0bffc17 	ldw	r2,-16(fp)
 d042e4c:	10800417 	ldw	r2,16(r2)
 d042e50:	1004d23a 	srli	r2,r2,8
 d042e54:	11803fcc 	andi	r6,r2,255
 d042e58:	e0bffc17 	ldw	r2,-16(fp)
 d042e5c:	10800417 	ldw	r2,16(r2)
 d042e60:	1004d43a 	srli	r2,r2,16
 d042e64:	11c03fcc 	andi	r7,r2,255
 d042e68:	e0bffc17 	ldw	r2,-16(fp)
 d042e6c:	10800417 	ldw	r2,16(r2)
 d042e70:	1004d63a 	srli	r2,r2,24
 d042e74:	d8800015 	stw	r2,0(sp)
 d042e78:	01034174 	movhi	r4,3333
 d042e7c:	21078004 	addi	r4,r4,7680
 d042e80:	d0028a00 	call	d0028a0 <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 d042e84:	008341b4 	movhi	r2,3334
 d042e88:	10856804 	addi	r2,r2,5536
 d042e8c:	10800017 	ldw	r2,0(r2)
 d042e90:	10800098 	cmpnei	r2,r2,2
 d042e94:	1000101e 	bne	r2,zero,d042ed8 <ip_rcv_phase2+0x230>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 d042e98:	008341b4 	movhi	r2,3334
 d042e9c:	10856804 	addi	r2,r2,5536
 d042ea0:	10800a17 	ldw	r2,40(r2)
 d042ea4:	10c00044 	addi	r3,r2,1
 d042ea8:	008341b4 	movhi	r2,3334
 d042eac:	10856804 	addi	r2,r2,5536
 d042eb0:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d042eb4:	01000084 	movi	r4,2
 d042eb8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
         pk_free(p);
 d042ebc:	e13ffe17 	ldw	r4,-8(fp)
 d042ec0:	d0251a00 	call	d0251a0 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042ec4:	01000084 	movi	r4,2
 d042ec8:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 d042ecc:	00bff7c4 	movi	r2,-33
 d042ed0:	e0bfff15 	stw	r2,-4(fp)
 d042ed4:	0000f106 	br	d04329c <ip_rcv_phase2+0x5f4>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 d042ed8:	008341b4 	movhi	r2,3334
 d042edc:	10856804 	addi	r2,r2,5536
 d042ee0:	10800517 	ldw	r2,20(r2)
 d042ee4:	10c00044 	addi	r3,r2,1
 d042ee8:	008341b4 	movhi	r2,3334
 d042eec:	10856804 	addi	r2,r2,5536
 d042ef0:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 d042ef4:	e0bffc17 	ldw	r2,-16(fp)
 d042ef8:	10800203 	ldbu	r2,8(r2)
 d042efc:	10803fcc 	andi	r2,r2,255
 d042f00:	108000a8 	cmpgeui	r2,r2,2
 d042f04:	10001b1e 	bne	r2,zero,d042f74 <ip_rcv_phase2+0x2cc>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 d042f08:	008341b4 	movhi	r2,3334
 d042f0c:	10856804 	addi	r2,r2,5536
 d042f10:	10800a17 	ldw	r2,40(r2)
 d042f14:	10c00044 	addi	r3,r2,1
 d042f18:	008341b4 	movhi	r2,3334
 d042f1c:	10856804 	addi	r2,r2,5536
 d042f20:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 d042f24:	e0bffc17 	ldw	r2,-16(fp)
 d042f28:	11000317 	ldw	r4,12(r2)
 d042f2c:	e0bffe17 	ldw	r2,-8(fp)
 d042f30:	10800617 	ldw	r2,24(r2)
 d042f34:	11400a17 	ldw	r5,40(r2)
 d042f38:	e0bffe17 	ldw	r2,-8(fp)
 d042f3c:	10800617 	ldw	r2,24(r2)
 d042f40:	d8800015 	stw	r2,0(sp)
 d042f44:	e1bffc17 	ldw	r6,-16(fp)
 d042f48:	01c2c004 	movi	r7,2816
 d042f4c:	d04b6c40 	call	d04b6c4 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d042f50:	01000084 	movi	r4,2
 d042f54:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(p);
 d042f58:	e13ffe17 	ldw	r4,-8(fp)
 d042f5c:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042f60:	01000084 	movi	r4,2
 d042f64:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 d042f68:	00bff7c4 	movi	r2,-33
 d042f6c:	e0bfff15 	stw	r2,-4(fp)
 d042f70:	0000ca06 	br	d04329c <ip_rcv_phase2+0x5f4>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 d042f74:	e0bffc17 	ldw	r2,-16(fp)
 d042f78:	10c00417 	ldw	r3,16(r2)
 d042f7c:	e0bffe17 	ldw	r2,-8(fp)
 d042f80:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 d042f84:	e0bffe17 	ldw	r2,-8(fp)
 d042f88:	11000717 	ldw	r4,28(r2)
 d042f8c:	e17ffd04 	addi	r5,fp,-12
 d042f90:	d0407680 	call	d040768 <iproute>
 d042f94:	e0bff815 	stw	r2,-32(fp)
 d042f98:	e0bff817 	ldw	r2,-32(fp)
 d042f9c:	1004c03a 	cmpne	r2,r2,zero
 d042fa0:	1000101e 	bne	r2,zero,d042fe4 <ip_rcv_phase2+0x33c>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 d042fa4:	008341b4 	movhi	r2,3334
 d042fa8:	10856804 	addi	r2,r2,5536
 d042fac:	10800b17 	ldw	r2,44(r2)
 d042fb0:	10c00044 	addi	r3,r2,1
 d042fb4:	008341b4 	movhi	r2,3334
 d042fb8:	10856804 	addi	r2,r2,5536
 d042fbc:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d042fc0:	01000084 	movi	r4,2
 d042fc4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
            pk_free(p);
 d042fc8:	e13ffe17 	ldw	r4,-8(fp)
 d042fcc:	d0251a00 	call	d0251a0 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042fd0:	01000084 	movi	r4,2
 d042fd4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 d042fd8:	00bff7c4 	movi	r2,-33
 d042fdc:	e0bfff15 	stw	r2,-4(fp)
 d042fe0:	0000ae06 	br	d04329c <ip_rcv_phase2+0x5f4>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 d042fe4:	e0bffc17 	ldw	r2,-16(fp)
 d042fe8:	10c00417 	ldw	r3,16(r2)
 d042fec:	e0bff817 	ldw	r2,-32(fp)
 d042ff0:	10800a17 	ldw	r2,40(r2)
 d042ff4:	18806226 	beq	r3,r2,d043180 <ip_rcv_phase2+0x4d8>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 d042ff8:	e0bffc17 	ldw	r2,-16(fp)
 d042ffc:	10c00417 	ldw	r3,16(r2)
 d043000:	e0bff817 	ldw	r2,-32(fp)
 d043004:	10800e17 	ldw	r2,56(r2)
 d043008:	18805d26 	beq	r3,r2,d043180 <ip_rcv_phase2+0x4d8>
 d04300c:	e0bffc17 	ldw	r2,-16(fp)
 d043010:	10c00417 	ldw	r3,16(r2)
 d043014:	e0bffe17 	ldw	r2,-8(fp)
 d043018:	10800617 	ldw	r2,24(r2)
 d04301c:	10800e17 	ldw	r2,56(r2)
 d043020:	18805726 	beq	r3,r2,d043180 <ip_rcv_phase2+0x4d8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 d043024:	e0fffe17 	ldw	r3,-8(fp)
 d043028:	e0bff817 	ldw	r2,-32(fp)
 d04302c:	18800615 	stw	r2,24(r3)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 d043030:	e0bffe17 	ldw	r2,-8(fp)
 d043034:	10c00417 	ldw	r3,16(r2)
 d043038:	e0bffe17 	ldw	r2,-8(fp)
 d04303c:	10800617 	ldw	r2,24(r2)
 d043040:	10800817 	ldw	r2,32(r2)
 d043044:	1887883a 	add	r3,r3,r2
 d043048:	e0bff817 	ldw	r2,-32(fp)
 d04304c:	10800917 	ldw	r2,36(r2)
 d043050:	10c0372e 	bgeu	r2,r3,d043130 <ip_rcv_phase2+0x488>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 d043054:	e0bffc17 	ldw	r2,-16(fp)
 d043058:	1080018b 	ldhu	r2,6(r2)
 d04305c:	10bfffcc 	andi	r2,r2,65535
 d043060:	1004d23a 	srli	r2,r2,8
 d043064:	10bfffcc 	andi	r2,r2,65535
 d043068:	10c03fcc 	andi	r3,r2,255
 d04306c:	e0bffc17 	ldw	r2,-16(fp)
 d043070:	1080018b 	ldhu	r2,6(r2)
 d043074:	10bfffcc 	andi	r2,r2,65535
 d043078:	1004923a 	slli	r2,r2,8
 d04307c:	10bfc00c 	andi	r2,r2,65280
 d043080:	1884b03a 	or	r2,r3,r2
 d043084:	1090000c 	andi	r2,r2,16384
 d043088:	1005003a 	cmpeq	r2,r2,zero
 d04308c:	10001b1e 	bne	r2,zero,d0430fc <ip_rcv_phase2+0x454>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 d043090:	e0bffc17 	ldw	r2,-16(fp)
 d043094:	11000317 	ldw	r4,12(r2)
 d043098:	e0bffe17 	ldw	r2,-8(fp)
 d04309c:	10800617 	ldw	r2,24(r2)
 d0430a0:	11400a17 	ldw	r5,40(r2)
 d0430a4:	e0bffe17 	ldw	r2,-8(fp)
 d0430a8:	10800617 	ldw	r2,24(r2)
 d0430ac:	d8800015 	stw	r2,0(sp)
 d0430b0:	e1bffc17 	ldw	r6,-16(fp)
 d0430b4:	01c00104 	movi	r7,4
 d0430b8:	d04b6c40 	call	d04b6c4 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 d0430bc:	008341b4 	movhi	r2,3334
 d0430c0:	10856804 	addi	r2,r2,5536
 d0430c4:	10801117 	ldw	r2,68(r2)
 d0430c8:	10c00044 	addi	r3,r2,1
 d0430cc:	008341b4 	movhi	r2,3334
 d0430d0:	10856804 	addi	r2,r2,5536
 d0430d4:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 d0430d8:	01000084 	movi	r4,2
 d0430dc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
               pk_free(p);
 d0430e0:	e13ffe17 	ldw	r4,-8(fp)
 d0430e4:	d0251a00 	call	d0251a0 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0430e8:	01000084 	movi	r4,2
 d0430ec:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 d0430f0:	00bffd44 	movi	r2,-11
 d0430f4:	e0bfff15 	stw	r2,-4(fp)
 d0430f8:	00006806 	br	d04329c <ip_rcv_phase2+0x5f4>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 d0430fc:	e0bffc17 	ldw	r2,-16(fp)
 d043100:	10800203 	ldbu	r2,8(r2)
 d043104:	10bfffc4 	addi	r2,r2,-1
 d043108:	1007883a 	mov	r3,r2
 d04310c:	e0bffc17 	ldw	r2,-16(fp)
 d043110:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 d043114:	e17ffd17 	ldw	r5,-12(fp)
 d043118:	e13ffe17 	ldw	r4,-8(fp)
 d04311c:	d03fdd00 	call	d03fdd0 <ip_fragment>
 d043120:	e0bff715 	stw	r2,-36(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 d043124:	e0bff717 	ldw	r2,-36(fp)
 d043128:	e0bfff15 	stw	r2,-4(fp)
 d04312c:	00005b06 	br	d04329c <ip_rcv_phase2+0x5f4>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 d043130:	e0bffc17 	ldw	r2,-16(fp)
 d043134:	10800203 	ldbu	r2,8(r2)
 d043138:	10bfffc4 	addi	r2,r2,-1
 d04313c:	1007883a 	mov	r3,r2
 d043140:	e0bffc17 	ldw	r2,-16(fp)
 d043144:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 d043148:	e0bffc17 	ldw	r2,-16(fp)
 d04314c:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 d043150:	e13ffc17 	ldw	r4,-16(fp)
 d043154:	01400284 	movi	r5,10
 d043158:	d0205440 	call	d020544 <cksum>
 d04315c:	0084303a 	nor	r2,zero,r2
 d043160:	1007883a 	mov	r3,r2
 d043164:	e0bffc17 	ldw	r2,-16(fp)
 d043168:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 d04316c:	e17ffd17 	ldw	r5,-12(fp)
 d043170:	e13ffe17 	ldw	r4,-8(fp)
 d043174:	d01e2bc0 	call	d01e2bc <ip2mac>
 d043178:	e0bfff15 	stw	r2,-4(fp)
 d04317c:	00004706 	br	d04329c <ip_rcv_phase2+0x5f4>
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 d043180:	e0bffc17 	ldw	r2,-16(fp)
 d043184:	1080018b 	ldhu	r2,6(r2)
 d043188:	10bfffcc 	andi	r2,r2,65535
 d04318c:	1004d23a 	srli	r2,r2,8
 d043190:	10803fcc 	andi	r2,r2,255
 d043194:	1009883a 	mov	r4,r2
 d043198:	e0bffc17 	ldw	r2,-16(fp)
 d04319c:	1080018b 	ldhu	r2,6(r2)
 d0431a0:	10bfffcc 	andi	r2,r2,65535
 d0431a4:	1004923a 	slli	r2,r2,8
 d0431a8:	1007883a 	mov	r3,r2
 d0431ac:	00bfc004 	movi	r2,-256
 d0431b0:	1884703a 	and	r2,r3,r2
 d0431b4:	2084b03a 	or	r2,r4,r2
 d0431b8:	e0bffa0d 	sth	r2,-24(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 d0431bc:	e0bffa0b 	ldhu	r2,-24(fp)
 d0431c0:	1088000c 	andi	r2,r2,8192
 d0431c4:	1004c03a 	cmpne	r2,r2,zero
 d0431c8:	1000061e 	bne	r2,zero,d0431e4 <ip_rcv_phase2+0x53c>
 d0431cc:	e0fffa0b 	ldhu	r3,-24(fp)
 d0431d0:	00bffff4 	movhi	r2,65535
 d0431d4:	1087ffc4 	addi	r2,r2,8191
 d0431d8:	1884703a 	and	r2,r3,r2
 d0431dc:	1005003a 	cmpeq	r2,r2,zero
 d0431e0:	10002b1e 	bne	r2,zero,d043290 <ip_rcv_phase2+0x5e8>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d0431e4:	00834174 	movhi	r2,3333
 d0431e8:	109b2004 	addi	r2,r2,27776
 d0431ec:	10800017 	ldw	r2,0(r2)
 d0431f0:	1081000c 	andi	r2,r2,1024
 d0431f4:	1005003a 	cmpeq	r2,r2,zero
 d0431f8:	10001a1e 	bne	r2,zero,d043264 <ip_rcv_phase2+0x5bc>
 d0431fc:	00834174 	movhi	r2,3333
 d043200:	109b2004 	addi	r2,r2,27776
 d043204:	10800017 	ldw	r2,0(r2)
 d043208:	1080800c 	andi	r2,r2,512
 d04320c:	1005003a 	cmpeq	r2,r2,zero
 d043210:	1000141e 	bne	r2,zero,d043264 <ip_rcv_phase2+0x5bc>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 d043214:	e0bffc17 	ldw	r2,-16(fp)
 d043218:	10800317 	ldw	r2,12(r2)
 d04321c:	11403fcc 	andi	r5,r2,255
 d043220:	e0bffc17 	ldw	r2,-16(fp)
 d043224:	10800317 	ldw	r2,12(r2)
 d043228:	1004d23a 	srli	r2,r2,8
 d04322c:	11803fcc 	andi	r6,r2,255
 d043230:	e0bffc17 	ldw	r2,-16(fp)
 d043234:	10800317 	ldw	r2,12(r2)
 d043238:	1004d43a 	srli	r2,r2,16
 d04323c:	11c03fcc 	andi	r7,r2,255
 d043240:	e0bffc17 	ldw	r2,-16(fp)
 d043244:	10800317 	ldw	r2,12(r2)
 d043248:	1004d63a 	srli	r2,r2,24
 d04324c:	d8800015 	stw	r2,0(sp)
 d043250:	01034174 	movhi	r4,3333
 d043254:	21078c04 	addi	r4,r4,7728
 d043258:	d0028a00 	call	d0028a0 <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 d04325c:	e13ffe17 	ldw	r4,-8(fp)
 d043260:	d0404b00 	call	d0404b0 <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 d043264:	008341b4 	movhi	r2,3334
 d043268:	10856804 	addi	r2,r2,5536
 d04326c:	10800d17 	ldw	r2,52(r2)
 d043270:	10c00044 	addi	r3,r2,1
 d043274:	008341b4 	movhi	r2,3334
 d043278:	10856804 	addi	r2,r2,5536
 d04327c:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 d043280:	e13ffe17 	ldw	r4,-8(fp)
 d043284:	d0411880 	call	d041188 <ip_reassm>
 d043288:	e0bfff15 	stw	r2,-4(fp)
 d04328c:	00000306 	br	d04329c <ip_rcv_phase2+0x5f4>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 d043290:	e13ffe17 	ldw	r4,-8(fp)
 d043294:	d0432b40 	call	d0432b4 <ip_demux>
 d043298:	e0bfff15 	stw	r2,-4(fp)
 d04329c:	e0bfff17 	ldw	r2,-4(fp)
}
 d0432a0:	e037883a 	mov	sp,fp
 d0432a4:	dfc00117 	ldw	ra,4(sp)
 d0432a8:	df000017 	ldw	fp,0(sp)
 d0432ac:	dec00204 	addi	sp,sp,8
 d0432b0:	f800283a 	ret

0d0432b4 <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 d0432b4:	defff704 	addi	sp,sp,-36
 d0432b8:	dfc00815 	stw	ra,32(sp)
 d0432bc:	df000715 	stw	fp,28(sp)
 d0432c0:	df000704 	addi	fp,sp,28
 d0432c4:	e13ffd15 	stw	r4,-12(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 d0432c8:	e0bffd17 	ldw	r2,-12(fp)
 d0432cc:	10800317 	ldw	r2,12(r2)
 d0432d0:	e0bffc15 	stw	r2,-16(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 d0432d4:	e0bffc17 	ldw	r2,-16(fp)
 d0432d8:	10800003 	ldbu	r2,0(r2)
 d0432dc:	10803fcc 	andi	r2,r2,255
 d0432e0:	10801160 	cmpeqi	r2,r2,69
 d0432e4:	1000131e 	bne	r2,zero,d043334 <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 d0432e8:	e0bffc17 	ldw	r2,-16(fp)
 d0432ec:	10800003 	ldbu	r2,0(r2)
 d0432f0:	10803fcc 	andi	r2,r2,255
 d0432f4:	10801170 	cmpltui	r2,r2,69
 d0432f8:	1000051e 	bne	r2,zero,d043310 <ip_demux+0x5c>
 d0432fc:	e0bffc17 	ldw	r2,-16(fp)
 d043300:	10800003 	ldbu	r2,0(r2)
 d043304:	10803fcc 	andi	r2,r2,255
 d043308:	10801230 	cmpltui	r2,r2,72
 d04330c:	1000091e 	bne	r2,zero,d043334 <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 d043310:	e0bffc17 	ldw	r2,-16(fp)
 d043314:	10800003 	ldbu	r2,0(r2)
 d043318:	11403fcc 	andi	r5,r2,255
 d04331c:	01034174 	movhi	r4,3333
 d043320:	21079504 	addi	r4,r4,7764
 d043324:	d0028a00 	call	d0028a0 <printf>
         return ENP_LOGIC;
 d043328:	00bffd44 	movi	r2,-11
 d04332c:	e0bfff15 	stw	r2,-4(fp)
 d043330:	0000e606 	br	d0436cc <ip_demux+0x418>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 d043334:	e0bffc17 	ldw	r2,-16(fp)
 d043338:	10c00317 	ldw	r3,12(r2)
 d04333c:	e0bffd17 	ldw	r2,-12(fp)
 d043340:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d043344:	00834174 	movhi	r2,3333
 d043348:	109b2004 	addi	r2,r2,27776
 d04334c:	10800017 	ldw	r2,0(r2)
 d043350:	1081000c 	andi	r2,r2,1024
 d043354:	1005003a 	cmpeq	r2,r2,zero
 d043358:	1000241e 	bne	r2,zero,d0433ec <ip_demux+0x138>
 d04335c:	00834174 	movhi	r2,3333
 d043360:	109b2004 	addi	r2,r2,27776
 d043364:	10800017 	ldw	r2,0(r2)
 d043368:	1080800c 	andi	r2,r2,512
 d04336c:	1005003a 	cmpeq	r2,r2,zero
 d043370:	10001e1e 	bne	r2,zero,d0433ec <ip_demux+0x138>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 d043374:	e0bffc17 	ldw	r2,-16(fp)
 d043378:	10800243 	ldbu	r2,9(r2)
 d04337c:	11403fcc 	andi	r5,r2,255
 d043380:	e0bffc17 	ldw	r2,-16(fp)
 d043384:	10800317 	ldw	r2,12(r2)
 d043388:	11803fcc 	andi	r6,r2,255
 d04338c:	e0bffc17 	ldw	r2,-16(fp)
 d043390:	10800317 	ldw	r2,12(r2)
 d043394:	1004d23a 	srli	r2,r2,8
 d043398:	11c03fcc 	andi	r7,r2,255
 d04339c:	e0bffc17 	ldw	r2,-16(fp)
 d0433a0:	10800317 	ldw	r2,12(r2)
 d0433a4:	1004d43a 	srli	r2,r2,16
 d0433a8:	10c03fcc 	andi	r3,r2,255
 d0433ac:	e0bffc17 	ldw	r2,-16(fp)
 d0433b0:	10800317 	ldw	r2,12(r2)
 d0433b4:	1004d63a 	srli	r2,r2,24
 d0433b8:	d8c00015 	stw	r3,0(sp)
 d0433bc:	d8800115 	stw	r2,4(sp)
 d0433c0:	01034174 	movhi	r4,3333
 d0433c4:	21079c04 	addi	r4,r4,7792
 d0433c8:	d0028a00 	call	d0028a0 <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 d0433cc:	00834174 	movhi	r2,3333
 d0433d0:	109b2004 	addi	r2,r2,27776
 d0433d4:	10800017 	ldw	r2,0(r2)
 d0433d8:	1080008c 	andi	r2,r2,2
 d0433dc:	1005003a 	cmpeq	r2,r2,zero
 d0433e0:	1000021e 	bne	r2,zero,d0433ec <ip_demux+0x138>
 d0433e4:	e13ffd17 	ldw	r4,-12(fp)
 d0433e8:	d0404b00 	call	d0404b0 <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 d0433ec:	e0bffc17 	ldw	r2,-16(fp)
 d0433f0:	10800243 	ldbu	r2,9(r2)
 d0433f4:	10803fcc 	andi	r2,r2,255
 d0433f8:	e0bffe15 	stw	r2,-8(fp)
 d0433fc:	e0fffe17 	ldw	r3,-8(fp)
 d043400:	188000a0 	cmpeqi	r2,r3,2
 d043404:	1000241e 	bne	r2,zero,d043498 <ip_demux+0x1e4>
 d043408:	e0fffe17 	ldw	r3,-8(fp)
 d04340c:	188000c8 	cmpgei	r2,r3,3
 d043410:	1000041e 	bne	r2,zero,d043424 <ip_demux+0x170>
 d043414:	e0fffe17 	ldw	r3,-8(fp)
 d043418:	18800060 	cmpeqi	r2,r3,1
 d04341c:	1000131e 	bne	r2,zero,d04346c <ip_demux+0x1b8>
 d043420:	00003306 	br	d0434f0 <ip_demux+0x23c>
 d043424:	e0fffe17 	ldw	r3,-8(fp)
 d043428:	188001a0 	cmpeqi	r2,r3,6
 d04342c:	1000251e 	bne	r2,zero,d0434c4 <ip_demux+0x210>
 d043430:	e0fffe17 	ldw	r3,-8(fp)
 d043434:	18800460 	cmpeqi	r2,r3,17
 d043438:	1000011e 	bne	r2,zero,d043440 <ip_demux+0x18c>
 d04343c:	00002c06 	br	d0434f0 <ip_demux+0x23c>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 d043440:	008341b4 	movhi	r2,3334
 d043444:	10856804 	addi	r2,r2,5536
 d043448:	10800817 	ldw	r2,32(r2)
 d04344c:	10c00044 	addi	r3,r2,1
 d043450:	008341b4 	movhi	r2,3334
 d043454:	10856804 	addi	r2,r2,5536
 d043458:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 d04345c:	e13ffd17 	ldw	r4,-12(fp)
 d043460:	d04470c0 	call	d04470c <udpdemux>
 d043464:	e0bffb15 	stw	r2,-20(fp)
      break;
 d043468:	00002b06 	br	d043518 <ip_demux+0x264>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 d04346c:	008341b4 	movhi	r2,3334
 d043470:	10856804 	addi	r2,r2,5536
 d043474:	10800817 	ldw	r2,32(r2)
 d043478:	10c00044 	addi	r3,r2,1
 d04347c:	008341b4 	movhi	r2,3334
 d043480:	10856804 	addi	r2,r2,5536
 d043484:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 d043488:	e13ffd17 	ldw	r4,-12(fp)
 d04348c:	d04aa900 	call	d04aa90 <icmprcv>
 d043490:	e0bffb15 	stw	r2,-20(fp)
      break;
 d043494:	00002006 	br	d043518 <ip_demux+0x264>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 d043498:	008341b4 	movhi	r2,3334
 d04349c:	10856804 	addi	r2,r2,5536
 d0434a0:	10800817 	ldw	r2,32(r2)
 d0434a4:	10c00044 	addi	r3,r2,1
 d0434a8:	008341b4 	movhi	r2,3334
 d0434ac:	10856804 	addi	r2,r2,5536
 d0434b0:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 d0434b4:	e13ffd17 	ldw	r4,-12(fp)
 d0434b8:	d01e9cc0 	call	d01e9cc <igmp_input>
 d0434bc:	e0bffb15 	stw	r2,-20(fp)
      break;
 d0434c0:	00001506 	br	d043518 <ip_demux+0x264>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 d0434c4:	008341b4 	movhi	r2,3334
 d0434c8:	10856804 	addi	r2,r2,5536
 d0434cc:	10800817 	ldw	r2,32(r2)
 d0434d0:	10c00044 	addi	r3,r2,1
 d0434d4:	008341b4 	movhi	r2,3334
 d0434d8:	10856804 	addi	r2,r2,5536
 d0434dc:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 d0434e0:	e13ffd17 	ldw	r4,-12(fp)
 d0434e4:	d0273980 	call	d027398 <tcp_rcv>
 d0434e8:	e0bffb15 	stw	r2,-20(fp)
      break;
 d0434ec:	00000a06 	br	d043518 <ip_demux+0x264>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 d0434f0:	008341b4 	movhi	r2,3334
 d0434f4:	10856804 	addi	r2,r2,5536
 d0434f8:	10800817 	ldw	r2,32(r2)
 d0434fc:	10c00044 	addi	r3,r2,1
 d043500:	008341b4 	movhi	r2,3334
 d043504:	10856804 	addi	r2,r2,5536
 d043508:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 d04350c:	e13ffd17 	ldw	r4,-12(fp)
 d043510:	d043c680 	call	d043c68 <ip_raw_input>
 d043514:	e0bffb15 	stw	r2,-20(fp)
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 d043518:	e0bffb17 	ldw	r2,-20(fp)
 d04351c:	10bffda0 	cmpeqi	r2,r2,-10
 d043520:	1000031e 	bne	r2,zero,d043530 <ip_demux+0x27c>
   {
      return err;
 d043524:	e0bffb17 	ldw	r2,-20(fp)
 d043528:	e0bfff15 	stw	r2,-4(fp)
 d04352c:	00006706 	br	d0436cc <ip_demux+0x418>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 d043530:	e0bffc17 	ldw	r2,-16(fp)
 d043534:	10800417 	ldw	r2,16(r2)
 d043538:	10bfffe0 	cmpeqi	r2,r2,-1
 d04353c:	1000541e 	bne	r2,zero,d043690 <ip_demux+0x3dc>
 d043540:	e0bffc17 	ldw	r2,-16(fp)
 d043544:	10800417 	ldw	r2,16(r2)
 d043548:	1004d63a 	srli	r2,r2,24
 d04354c:	10c03fcc 	andi	r3,r2,255
 d043550:	e0bffc17 	ldw	r2,-16(fp)
 d043554:	10800417 	ldw	r2,16(r2)
 d043558:	1004d23a 	srli	r2,r2,8
 d04355c:	10bfc00c 	andi	r2,r2,65280
 d043560:	1886b03a 	or	r3,r3,r2
 d043564:	e0bffc17 	ldw	r2,-16(fp)
 d043568:	10800417 	ldw	r2,16(r2)
 d04356c:	10bfc00c 	andi	r2,r2,65280
 d043570:	1004923a 	slli	r2,r2,8
 d043574:	1886b03a 	or	r3,r3,r2
 d043578:	e0bffc17 	ldw	r2,-16(fp)
 d04357c:	10800417 	ldw	r2,16(r2)
 d043580:	10803fcc 	andi	r2,r2,255
 d043584:	1004963a 	slli	r2,r2,24
 d043588:	1884b03a 	or	r2,r3,r2
 d04358c:	10fc002c 	andhi	r3,r2,61440
 d043590:	00b80034 	movhi	r2,57344
 d043594:	18803e26 	beq	r3,r2,d043690 <ip_demux+0x3dc>
 d043598:	e0bffc17 	ldw	r2,-16(fp)
 d04359c:	10c00417 	ldw	r3,16(r2)
 d0435a0:	e0bffd17 	ldw	r2,-12(fp)
 d0435a4:	10800617 	ldw	r2,24(r2)
 d0435a8:	10800e17 	ldw	r2,56(r2)
 d0435ac:	18803826 	beq	r3,r2,d043690 <ip_demux+0x3dc>
 d0435b0:	e0bffc17 	ldw	r2,-16(fp)
 d0435b4:	10c00417 	ldw	r3,16(r2)
 d0435b8:	e0bffd17 	ldw	r2,-12(fp)
 d0435bc:	10800617 	ldw	r2,24(r2)
 d0435c0:	10800f17 	ldw	r2,60(r2)
 d0435c4:	18803226 	beq	r3,r2,d043690 <ip_demux+0x3dc>
 d0435c8:	e0bffc17 	ldw	r2,-16(fp)
 d0435cc:	10c00417 	ldw	r3,16(r2)
 d0435d0:	e0bffd17 	ldw	r2,-12(fp)
 d0435d4:	10800617 	ldw	r2,24(r2)
 d0435d8:	10801017 	ldw	r2,64(r2)
 d0435dc:	18802c26 	beq	r3,r2,d043690 <ip_demux+0x3dc>
 d0435e0:	e0bffd17 	ldw	r2,-12(fp)
 d0435e4:	10800617 	ldw	r2,24(r2)
 d0435e8:	10c00a17 	ldw	r3,40(r2)
 d0435ec:	e0bffd17 	ldw	r2,-12(fp)
 d0435f0:	10800617 	ldw	r2,24(r2)
 d0435f4:	10801017 	ldw	r2,64(r2)
 d0435f8:	18802526 	beq	r3,r2,d043690 <ip_demux+0x3dc>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d0435fc:	00834174 	movhi	r2,3333
 d043600:	109b2004 	addi	r2,r2,27776
 d043604:	10800017 	ldw	r2,0(r2)
 d043608:	1081000c 	andi	r2,r2,1024
 d04360c:	1005003a 	cmpeq	r2,r2,zero
 d043610:	1000141e 	bne	r2,zero,d043664 <ip_demux+0x3b0>
 d043614:	00834174 	movhi	r2,3333
 d043618:	109b2004 	addi	r2,r2,27776
 d04361c:	10800017 	ldw	r2,0(r2)
 d043620:	1080800c 	andi	r2,r2,512
 d043624:	1005003a 	cmpeq	r2,r2,zero
 d043628:	10000e1e 	bne	r2,zero,d043664 <ip_demux+0x3b0>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 d04362c:	e0bffc17 	ldw	r2,-16(fp)
 d043630:	10800243 	ldbu	r2,9(r2)
 d043634:	11403fcc 	andi	r5,r2,255
 d043638:	01034174 	movhi	r4,3333
 d04363c:	2107a604 	addi	r4,r4,7832
 d043640:	d0028a00 	call	d0028a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d043644:	00834174 	movhi	r2,3333
 d043648:	109b2004 	addi	r2,r2,27776
 d04364c:	10800017 	ldw	r2,0(r2)
 d043650:	1080008c 	andi	r2,r2,2
 d043654:	1005003a 	cmpeq	r2,r2,zero
 d043658:	1000021e 	bne	r2,zero,d043664 <ip_demux+0x3b0>
 d04365c:	e13ffd17 	ldw	r4,-12(fp)
 d043660:	d0404b00 	call	d0404b0 <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 d043664:	e0bffc17 	ldw	r2,-16(fp)
 d043668:	11000317 	ldw	r4,12(r2)
 d04366c:	e0bffd17 	ldw	r2,-12(fp)
 d043670:	10800617 	ldw	r2,24(r2)
 d043674:	11400a17 	ldw	r5,40(r2)
 d043678:	e0bffd17 	ldw	r2,-12(fp)
 d04367c:	10800617 	ldw	r2,24(r2)
 d043680:	d8800015 	stw	r2,0(sp)
 d043684:	e1bffc17 	ldw	r6,-16(fp)
 d043688:	01c00084 	movi	r7,2
 d04368c:	d04b6c40 	call	d04b6c4 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 d043690:	008341b4 	movhi	r2,3334
 d043694:	10856804 	addi	r2,r2,5536
 d043698:	10800617 	ldw	r2,24(r2)
 d04369c:	10c00044 	addi	r3,r2,1
 d0436a0:	008341b4 	movhi	r2,3334
 d0436a4:	10856804 	addi	r2,r2,5536
 d0436a8:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d0436ac:	01000084 	movi	r4,2
 d0436b0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p);
 d0436b4:	e13ffd17 	ldw	r4,-12(fp)
 d0436b8:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0436bc:	01000084 	movi	r4,2
 d0436c0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 d0436c4:	00c00084 	movi	r3,2
 d0436c8:	e0ffff15 	stw	r3,-4(fp)
 d0436cc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0436d0:	e037883a 	mov	sp,fp
 d0436d4:	dfc00117 	ldw	ra,4(sp)
 d0436d8:	df000017 	ldw	fp,0(sp)
 d0436dc:	dec00204 	addi	sp,sp,8
 d0436e0:	f800283a 	ret

0d0436e4 <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 d0436e4:	defff804 	addi	sp,sp,-32
 d0436e8:	dfc00715 	stw	ra,28(sp)
 d0436ec:	df000615 	stw	fp,24(sp)
 d0436f0:	df000604 	addi	fp,sp,24
 d0436f4:	e13ffc15 	stw	r4,-16(fp)
 d0436f8:	e17ffd15 	stw	r5,-12(fp)
 d0436fc:	e1bffe15 	stw	r6,-8(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 d043700:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 d043704:	e0bffc17 	ldw	r2,-16(fp)
 d043708:	1005003a 	cmpeq	r2,r2,zero
 d04370c:	1000041e 	bne	r2,zero,d043720 <in_addmulti+0x3c>
 d043710:	e0bffc17 	ldw	r2,-16(fp)
 d043714:	10800017 	ldw	r2,0(r2)
 d043718:	1004c03a 	cmpne	r2,r2,zero
 d04371c:	1000021e 	bne	r2,zero,d043728 <in_addmulti+0x44>
      return ((struct in_multi *)NULL);  
 d043720:	e03fff15 	stw	zero,-4(fp)
 d043724:	00004306 	br	d043834 <in_addmulti+0x150>

   ENTER_CRIT_SECTION(netp);
 d043728:	d025c500 	call	d025c50 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 d04372c:	e0bffe17 	ldw	r2,-8(fp)
 d043730:	108001a0 	cmpeqi	r2,r2,6
 d043734:	1000051e 	bne	r2,zero,d04374c <in_addmulti+0x68>
      inm = lookup_mcast(*ap, netp);
 d043738:	e0bffc17 	ldw	r2,-16(fp)
 d04373c:	11000017 	ldw	r4,0(r2)
 d043740:	e17ffd17 	ldw	r5,-12(fp)
 d043744:	d0439640 	call	d043964 <lookup_mcast>
 d043748:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 d04374c:	e0bffb17 	ldw	r2,-20(fp)
 d043750:	1005003a 	cmpeq	r2,r2,zero
 d043754:	1000061e 	bne	r2,zero,d043770 <in_addmulti+0x8c>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 d043758:	e0bffb17 	ldw	r2,-20(fp)
 d04375c:	10800217 	ldw	r2,8(r2)
 d043760:	10c00044 	addi	r3,r2,1
 d043764:	e0bffb17 	ldw	r2,-20(fp)
 d043768:	10c00215 	stw	r3,8(r2)
 d04376c:	00002e06 	br	d043828 <in_addmulti+0x144>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 d043770:	01000604 	movi	r4,24
 d043774:	d0264b80 	call	d0264b8 <npalloc>
 d043778:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 d04377c:	e0bffb17 	ldw	r2,-20(fp)
 d043780:	1004c03a 	cmpne	r2,r2,zero
 d043784:	1000031e 	bne	r2,zero,d043794 <in_addmulti+0xb0>
      {
         EXIT_CRIT_SECTION(netp);
 d043788:	d025cac0 	call	d025cac <irq_Unmask>
         return ((struct in_multi *)NULL);
 d04378c:	e03fff15 	stw	zero,-4(fp)
 d043790:	00002806 	br	d043834 <in_addmulti+0x150>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 d043794:	e0bffe17 	ldw	r2,-8(fp)
 d043798:	108001a0 	cmpeqi	r2,r2,6
 d04379c:	1000041e 	bne	r2,zero,d0437b0 <in_addmulti+0xcc>
         inm->inm_addr = *ap;
 d0437a0:	e0bffc17 	ldw	r2,-16(fp)
 d0437a4:	10c00017 	ldw	r3,0(r2)
 d0437a8:	e0bffb17 	ldw	r2,-20(fp)
 d0437ac:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 d0437b0:	e0fffb17 	ldw	r3,-20(fp)
 d0437b4:	e0bffd17 	ldw	r2,-12(fp)
 d0437b8:	18800115 	stw	r2,4(r3)
      inm->inm_refcount = 1;
 d0437bc:	e0fffb17 	ldw	r3,-20(fp)
 d0437c0:	00800044 	movi	r2,1
 d0437c4:	18800215 	stw	r2,8(r3)
      inm->inm_next = netp->mc_list;
 d0437c8:	e0bffd17 	ldw	r2,-12(fp)
 d0437cc:	10c02c17 	ldw	r3,176(r2)
 d0437d0:	e0bffb17 	ldw	r2,-20(fp)
 d0437d4:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 d0437d8:	e0fffd17 	ldw	r3,-12(fp)
 d0437dc:	e0bffb17 	ldw	r2,-20(fp)
 d0437e0:	18802c15 	stw	r2,176(r3)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 d0437e4:	e0bffd17 	ldw	r2,-12(fp)
 d0437e8:	10802b17 	ldw	r2,172(r2)
 d0437ec:	1005003a 	cmpeq	r2,r2,zero
 d0437f0:	1000061e 	bne	r2,zero,d04380c <in_addmulti+0x128>
         error = netp->n_mcastlist(inm);
 d0437f4:	e0bffd17 	ldw	r2,-12(fp)
 d0437f8:	10802b17 	ldw	r2,172(r2)
 d0437fc:	e13ffb17 	ldw	r4,-20(fp)
 d043800:	103ee83a 	callr	r2
 d043804:	e0bffa15 	stw	r2,-24(fp)
 d043808:	00000106 	br	d043810 <in_addmulti+0x12c>
      else
         error = 0;
 d04380c:	e03ffa15 	stw	zero,-24(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 d043810:	e0bffb17 	ldw	r2,-20(fp)
 d043814:	10800017 	ldw	r2,0(r2)
 d043818:	1005003a 	cmpeq	r2,r2,zero
 d04381c:	1000021e 	bne	r2,zero,d043828 <in_addmulti+0x144>
 d043820:	e13ffb17 	ldw	r4,-20(fp)
 d043824:	d01ef040 	call	d01ef04 <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 d043828:	d025cac0 	call	d025cac <irq_Unmask>
   USE_ARG(error);

   return (inm);
 d04382c:	e0bffb17 	ldw	r2,-20(fp)
 d043830:	e0bfff15 	stw	r2,-4(fp)
 d043834:	e0bfff17 	ldw	r2,-4(fp)
}
 d043838:	e037883a 	mov	sp,fp
 d04383c:	dfc00117 	ldw	ra,4(sp)
 d043840:	df000017 	ldw	fp,0(sp)
 d043844:	dec00204 	addi	sp,sp,8
 d043848:	f800283a 	ret

0d04384c <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 d04384c:	defffa04 	addi	sp,sp,-24
 d043850:	dfc00515 	stw	ra,20(sp)
 d043854:	df000415 	stw	fp,16(sp)
 d043858:	df000404 	addi	fp,sp,16
 d04385c:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 d043860:	e0bfff17 	ldw	r2,-4(fp)
 d043864:	10800117 	ldw	r2,4(r2)
 d043868:	e0bffd15 	stw	r2,-12(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 d04386c:	d025c500 	call	d025c50 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 d043870:	e0bfff17 	ldw	r2,-4(fp)
 d043874:	10800217 	ldw	r2,8(r2)
 d043878:	10ffffc4 	addi	r3,r2,-1
 d04387c:	e0bfff17 	ldw	r2,-4(fp)
 d043880:	10c00215 	stw	r3,8(r2)
 d043884:	e0bfff17 	ldw	r2,-4(fp)
 d043888:	10800217 	ldw	r2,8(r2)
 d04388c:	1004c03a 	cmpne	r2,r2,zero
 d043890:	10002e1e 	bne	r2,zero,d04394c <in_delmulti+0x100>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 d043894:	e0bffd17 	ldw	r2,-12(fp)
 d043898:	10802c17 	ldw	r2,176(r2)
 d04389c:	e0bffe15 	stw	r2,-8(fp)
 d0438a0:	00001406 	br	d0438f4 <in_delmulti+0xa8>
      {
         if(p == inm)   /* inm is first in mc_list */
 d0438a4:	e0fffe17 	ldw	r3,-8(fp)
 d0438a8:	e0bfff17 	ldw	r2,-4(fp)
 d0438ac:	1880051e 	bne	r3,r2,d0438c4 <in_delmulti+0x78>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 d0438b0:	e0bffe17 	ldw	r2,-8(fp)
 d0438b4:	10c00517 	ldw	r3,20(r2)
 d0438b8:	e0bffd17 	ldw	r2,-12(fp)
 d0438bc:	10c02c15 	stw	r3,176(r2)
            break;
 d0438c0:	00000f06 	br	d043900 <in_delmulti+0xb4>
         }
         else if(p->inm_next == inm)   /* inm is next */
 d0438c4:	e0bffe17 	ldw	r2,-8(fp)
 d0438c8:	10c00517 	ldw	r3,20(r2)
 d0438cc:	e0bfff17 	ldw	r2,-4(fp)
 d0438d0:	1880051e 	bne	r3,r2,d0438e8 <in_delmulti+0x9c>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 d0438d4:	e0bfff17 	ldw	r2,-4(fp)
 d0438d8:	10c00517 	ldw	r3,20(r2)
 d0438dc:	e0bffe17 	ldw	r2,-8(fp)
 d0438e0:	10c00515 	stw	r3,20(r2)
            break;
 d0438e4:	00000606 	br	d043900 <in_delmulti+0xb4>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 d0438e8:	e0bffe17 	ldw	r2,-8(fp)
 d0438ec:	10800517 	ldw	r2,20(r2)
 d0438f0:	e0bffe15 	stw	r2,-8(fp)
 d0438f4:	e0bffe17 	ldw	r2,-8(fp)
 d0438f8:	1004c03a 	cmpne	r2,r2,zero
 d0438fc:	103fe91e 	bne	r2,zero,d0438a4 <in_delmulti+0x58>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 d043900:	e0bffd17 	ldw	r2,-12(fp)
 d043904:	10802b17 	ldw	r2,172(r2)
 d043908:	1005003a 	cmpeq	r2,r2,zero
 d04390c:	1000061e 	bne	r2,zero,d043928 <in_delmulti+0xdc>
         error = netp->n_mcastlist(inm);
 d043910:	e0bffd17 	ldw	r2,-12(fp)
 d043914:	10802b17 	ldw	r2,172(r2)
 d043918:	e13fff17 	ldw	r4,-4(fp)
 d04391c:	103ee83a 	callr	r2
 d043920:	e0bffc15 	stw	r2,-16(fp)
 d043924:	00000106 	br	d04392c <in_delmulti+0xe0>
      else
         error = 0;
 d043928:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 d04392c:	e0bfff17 	ldw	r2,-4(fp)
 d043930:	10800017 	ldw	r2,0(r2)
 d043934:	1005003a 	cmpeq	r2,r2,zero
 d043938:	1000021e 	bne	r2,zero,d043944 <in_delmulti+0xf8>
 d04393c:	e13fff17 	ldw	r4,-4(fp)
 d043940:	d01f1700 	call	d01f170 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 d043944:	e13fff17 	ldw	r4,-4(fp)
 d043948:	d0265ac0 	call	d0265ac <npfree>
   }
   EXIT_CRIT_SECTION(inm);
 d04394c:	d025cac0 	call	d025cac <irq_Unmask>
}
 d043950:	e037883a 	mov	sp,fp
 d043954:	dfc00117 	ldw	ra,4(sp)
 d043958:	df000017 	ldw	fp,0(sp)
 d04395c:	dec00204 	addi	sp,sp,8
 d043960:	f800283a 	ret

0d043964 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 d043964:	defffb04 	addi	sp,sp,-20
 d043968:	df000415 	stw	fp,16(sp)
 d04396c:	df000404 	addi	fp,sp,16
 d043970:	e13ffd15 	stw	r4,-12(fp)
 d043974:	e17ffe15 	stw	r5,-8(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 d043978:	e0bffe17 	ldw	r2,-8(fp)
 d04397c:	10802c17 	ldw	r2,176(r2)
 d043980:	e0bffc15 	stw	r2,-16(fp)
 d043984:	00000a06 	br	d0439b0 <lookup_mcast+0x4c>
   {
      if(imp->inm_addr == addr)
 d043988:	e0bffc17 	ldw	r2,-16(fp)
 d04398c:	10c00017 	ldw	r3,0(r2)
 d043990:	e0bffd17 	ldw	r2,-12(fp)
 d043994:	1880031e 	bne	r3,r2,d0439a4 <lookup_mcast+0x40>
         return imp;
 d043998:	e0bffc17 	ldw	r2,-16(fp)
 d04399c:	e0bfff15 	stw	r2,-4(fp)
 d0439a0:	00000706 	br	d0439c0 <lookup_mcast+0x5c>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 d0439a4:	e0bffc17 	ldw	r2,-16(fp)
 d0439a8:	10800517 	ldw	r2,20(r2)
 d0439ac:	e0bffc15 	stw	r2,-16(fp)
 d0439b0:	e0bffc17 	ldw	r2,-16(fp)
 d0439b4:	1004c03a 	cmpne	r2,r2,zero
 d0439b8:	103ff31e 	bne	r2,zero,d043988 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 d0439bc:	e03fff15 	stw	zero,-4(fp)
 d0439c0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0439c4:	e037883a 	mov	sp,fp
 d0439c8:	df000017 	ldw	fp,0(sp)
 d0439cc:	dec00104 	addi	sp,sp,4
 d0439d0:	f800283a 	ret

0d0439d4 <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 d0439d4:	defffc04 	addi	sp,sp,-16
 d0439d8:	dfc00315 	stw	ra,12(sp)
 d0439dc:	df000215 	stw	fp,8(sp)
 d0439e0:	df000204 	addi	fp,sp,8
 d0439e4:	e13ffe15 	stw	r4,-8(fp)
   if (port_prep)
 d0439e8:	d0a94917 	ldw	r2,-23260(gp)
 d0439ec:	1005003a 	cmpeq	r2,r2,zero
 d0439f0:	1000041e 	bne	r2,zero,d043a04 <prep_ifaces+0x30>
      ifaces_found = port_prep(ifaces_found);
 d0439f4:	d0a94917 	ldw	r2,-23260(gp)
 d0439f8:	e13ffe17 	ldw	r4,-8(fp)
 d0439fc:	103ee83a 	callr	r2
 d043a00:	e0bffe15 	stw	r2,-8(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 d043a04:	e0fffe17 	ldw	r3,-8(fp)
 d043a08:	00834174 	movhi	r2,3333
 d043a0c:	109b2104 	addi	r2,r2,27780
 d043a10:	10c00015 	stw	r3,0(r2)

   initmsg("prepped %u interface%s, initializing...\n", 
 d043a14:	e0bffe17 	ldw	r2,-8(fp)
 d043a18:	10800058 	cmpnei	r2,r2,1
 d043a1c:	1000041e 	bne	r2,zero,d043a30 <prep_ifaces+0x5c>
 d043a20:	00834174 	movhi	r2,3333
 d043a24:	1087ae04 	addi	r2,r2,7864
 d043a28:	e0bfff15 	stw	r2,-4(fp)
 d043a2c:	00000306 	br	d043a3c <prep_ifaces+0x68>
 d043a30:	00834174 	movhi	r2,3333
 d043a34:	1087af04 	addi	r2,r2,7868
 d043a38:	e0bfff15 	stw	r2,-4(fp)
 d043a3c:	01034174 	movhi	r4,3333
 d043a40:	2107b004 	addi	r4,r4,7872
 d043a44:	e17ffe17 	ldw	r5,-8(fp)
 d043a48:	e1bfff17 	ldw	r6,-4(fp)
 d043a4c:	d0028a00 	call	d0028a0 <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 d043a50:	e0bffe17 	ldw	r2,-8(fp)
}
 d043a54:	e037883a 	mov	sp,fp
 d043a58:	dfc00117 	ldw	ra,4(sp)
 d043a5c:	df000017 	ldw	fp,0(sp)
 d043a60:	dec00204 	addi	sp,sp,8
 d043a64:	f800283a 	ret

0d043a68 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 d043a68:	defffd04 	addi	sp,sp,-12
 d043a6c:	dfc00215 	stw	ra,8(sp)
 d043a70:	df000115 	stw	fp,4(sp)
 d043a74:	df000104 	addi	fp,sp,4
 d043a78:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 d043a7c:	00800044 	movi	r2,1
 d043a80:	d0a94a15 	stw	r2,-23256(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 d043a84:	d01e7bc0 	call	d01e7bc <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 d043a88:	e13fff17 	ldw	r4,-4(fp)
 d043a8c:	d04bde40 	call	d04bde4 <exit>

0d043a90 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 d043a90:	deffff04 	addi	sp,sp,-4
 d043a94:	df000015 	stw	fp,0(sp)
 d043a98:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 d043a9c:	d0294d05 	stb	zero,-23244(gp)
   so_evtmap_create = 0;
 d043aa0:	d0294b15 	stw	zero,-23252(gp)
   so_evtmap_delete = 0;
 d043aa4:	d0294c15 	stw	zero,-23248(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 d043aa8:	e037883a 	mov	sp,fp
 d043aac:	df000017 	ldw	fp,0(sp)
 d043ab0:	dec00104 	addi	sp,sp,4
 d043ab4:	f800283a 	ret

0d043ab8 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 d043ab8:	defff804 	addi	sp,sp,-32
 d043abc:	dfc00715 	stw	ra,28(sp)
 d043ac0:	df000615 	stw	fp,24(sp)
 d043ac4:	df000604 	addi	fp,sp,24
 d043ac8:	e17ffc15 	stw	r5,-16(fp)
 d043acc:	e1bffd15 	stw	r6,-12(fp)
 d043ad0:	e1fffe15 	stw	r7,-8(fp)
 d043ad4:	e13ffb05 	stb	r4,-20(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 d043ad8:	0009883a 	mov	r4,zero
 d043adc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 d043ae0:	01000604 	movi	r4,24
 d043ae4:	d0264b80 	call	d0264b8 <npalloc>
 d043ae8:	e0bffa15 	stw	r2,-24(fp)
   if (ep == NULL)
 d043aec:	e0bffa17 	ldw	r2,-24(fp)
 d043af0:	1004c03a 	cmpne	r2,r2,zero
 d043af4:	10000e1e 	bne	r2,zero,d043b30 <ip_raw_open+0x78>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 d043af8:	00834174 	movhi	r2,3333
 d043afc:	109b2004 	addi	r2,r2,27776
 d043b00:	10800017 	ldw	r2,0(r2)
 d043b04:	1080010c 	andi	r2,r2,4
 d043b08:	1005003a 	cmpeq	r2,r2,zero
 d043b0c:	1000031e 	bne	r2,zero,d043b1c <ip_raw_open+0x64>
         dprintf("IP: Couldn't allocate ep storage.\n");
 d043b10:	01034174 	movhi	r4,3333
 d043b14:	2107bb04 	addi	r4,r4,7916
 d043b18:	d002bc80 	call	d002bc8 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 d043b1c:	0009883a 	mov	r4,zero
 d043b20:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ep;
 d043b24:	e0bffa17 	ldw	r2,-24(fp)
 d043b28:	e0bfff15 	stw	r2,-4(fp)
 d043b2c:	00001806 	br	d043b90 <ip_raw_open+0xd8>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 d043b30:	e0fffa17 	ldw	r3,-24(fp)
 d043b34:	e0bffc17 	ldw	r2,-16(fp)
 d043b38:	18800115 	stw	r2,4(r3)
   ep->ipr_faddr = faddr;
 d043b3c:	e0fffa17 	ldw	r3,-24(fp)
 d043b40:	e0bffd17 	ldw	r2,-12(fp)
 d043b44:	18800215 	stw	r2,8(r3)
   ep->ipr_prot = prot;
 d043b48:	e0fffa17 	ldw	r3,-24(fp)
 d043b4c:	e0bffb03 	ldbu	r2,-20(fp)
 d043b50:	18800505 	stb	r2,20(r3)
   ep->ipr_rcv = handler;
 d043b54:	e0fffa17 	ldw	r3,-24(fp)
 d043b58:	e0bffe17 	ldw	r2,-8(fp)
 d043b5c:	18800315 	stw	r2,12(r3)
   ep->ipr_data = data;
 d043b60:	e0fffa17 	ldw	r3,-24(fp)
 d043b64:	e0800217 	ldw	r2,8(fp)
 d043b68:	18800415 	stw	r2,16(r3)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 d043b6c:	d0e94e17 	ldw	r3,-23240(gp)
 d043b70:	e0bffa17 	ldw	r2,-24(fp)
 d043b74:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 d043b78:	e0bffa17 	ldw	r2,-24(fp)
 d043b7c:	d0a94e15 	stw	r2,-23240(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 d043b80:	0009883a 	mov	r4,zero
 d043b84:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return ep;
 d043b88:	e0bffa17 	ldw	r2,-24(fp)
 d043b8c:	e0bfff15 	stw	r2,-4(fp)
 d043b90:	e0bfff17 	ldw	r2,-4(fp)
}
 d043b94:	e037883a 	mov	sp,fp
 d043b98:	dfc00117 	ldw	ra,4(sp)
 d043b9c:	df000017 	ldw	fp,0(sp)
 d043ba0:	dec00204 	addi	sp,sp,8
 d043ba4:	f800283a 	ret

0d043ba8 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 d043ba8:	defffb04 	addi	sp,sp,-20
 d043bac:	dfc00415 	stw	ra,16(sp)
 d043bb0:	df000315 	stw	fp,12(sp)
 d043bb4:	df000304 	addi	fp,sp,12
 d043bb8:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 d043bbc:	0009883a 	mov	r4,zero
 d043bc0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 d043bc4:	e03ffe15 	stw	zero,-8(fp)
 d043bc8:	d0a94e17 	ldw	r2,-23240(gp)
 d043bcc:	e0bffd15 	stw	r2,-12(fp)
        curr_ep != NULL;
 d043bd0:	00000806 	br	d043bf4 <ip_raw_close+0x4c>
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 d043bd4:	e0fffd17 	ldw	r3,-12(fp)
 d043bd8:	e0bfff17 	ldw	r2,-4(fp)
 d043bdc:	18800826 	beq	r3,r2,d043c00 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 d043be0:	e0bffd17 	ldw	r2,-12(fp)
 d043be4:	e0bffe15 	stw	r2,-8(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 d043be8:	e0bffd17 	ldw	r2,-12(fp)
 d043bec:	10800017 	ldw	r2,0(r2)
 d043bf0:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
 d043bf4:	e0bffd17 	ldw	r2,-12(fp)
 d043bf8:	1004c03a 	cmpne	r2,r2,zero
 d043bfc:	103ff51e 	bne	r2,zero,d043bd4 <ip_raw_close+0x2c>
         break;
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 d043c00:	e0bffd17 	ldw	r2,-12(fp)
 d043c04:	1004c03a 	cmpne	r2,r2,zero
 d043c08:	1000041e 	bne	r2,zero,d043c1c <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 d043c0c:	d025a500 	call	d025a50 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d043c10:	0009883a 	mov	r4,zero
 d043c14:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return;
 d043c18:	00000e06 	br	d043c54 <ip_raw_close+0xac>
   }

   /* unlink it from the list */
   if (prev_ep)
 d043c1c:	e0bffe17 	ldw	r2,-8(fp)
 d043c20:	1005003a 	cmpeq	r2,r2,zero
 d043c24:	1000041e 	bne	r2,zero,d043c38 <ip_raw_close+0x90>
      prev_ep = curr_ep->ipr_next;
 d043c28:	e0bffd17 	ldw	r2,-12(fp)
 d043c2c:	10800017 	ldw	r2,0(r2)
 d043c30:	e0bffe15 	stw	r2,-8(fp)
 d043c34:	00000306 	br	d043c44 <ip_raw_close+0x9c>
   else
      ipraw_eps = curr_ep->ipr_next;
 d043c38:	e0bffd17 	ldw	r2,-12(fp)
 d043c3c:	10800017 	ldw	r2,0(r2)
 d043c40:	d0a94e15 	stw	r2,-23240(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 d043c44:	e13ffd17 	ldw	r4,-12(fp)
 d043c48:	d0265ac0 	call	d0265ac <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 d043c4c:	0009883a 	mov	r4,zero
 d043c50:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
}
 d043c54:	e037883a 	mov	sp,fp
 d043c58:	dfc00117 	ldw	ra,4(sp)
 d043c5c:	df000017 	ldw	fp,0(sp)
 d043c60:	dec00204 	addi	sp,sp,8
 d043c64:	f800283a 	ret

0d043c68 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 d043c68:	defff604 	addi	sp,sp,-40
 d043c6c:	dfc00915 	stw	ra,36(sp)
 d043c70:	df000815 	stw	fp,32(sp)
 d043c74:	df000804 	addi	fp,sp,32
 d043c78:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 d043c7c:	e03ffb15 	stw	zero,-20(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 d043c80:	e03ff915 	stw	zero,-28(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 d043c84:	e0bfff17 	ldw	r2,-4(fp)
 d043c88:	10800317 	ldw	r2,12(r2)
 d043c8c:	e0bffe15 	stw	r2,-8(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 d043c90:	d0a94e17 	ldw	r2,-23240(gp)
 d043c94:	e0bffd15 	stw	r2,-12(fp)
 d043c98:	00004d06 	br	d043dd0 <ip_raw_input+0x168>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 d043c9c:	e0bffd17 	ldw	r2,-12(fp)
 d043ca0:	10800017 	ldw	r2,0(r2)
 d043ca4:	e0bffc15 	stw	r2,-16(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 d043ca8:	e0bffd17 	ldw	r2,-12(fp)
 d043cac:	10800503 	ldbu	r2,20(r2)
 d043cb0:	10803fcc 	andi	r2,r2,255
 d043cb4:	1005003a 	cmpeq	r2,r2,zero
 d043cb8:	1000071e 	bne	r2,zero,d043cd8 <ip_raw_input+0x70>
 d043cbc:	e0bffd17 	ldw	r2,-12(fp)
 d043cc0:	10c00503 	ldbu	r3,20(r2)
 d043cc4:	e0bffe17 	ldw	r2,-8(fp)
 d043cc8:	10800243 	ldbu	r2,9(r2)
 d043ccc:	18c03fcc 	andi	r3,r3,255
 d043cd0:	10803fcc 	andi	r2,r2,255
 d043cd4:	18803c1e 	bne	r3,r2,d043dc8 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 d043cd8:	e0bffd17 	ldw	r2,-12(fp)
 d043cdc:	10800117 	ldw	r2,4(r2)
 d043ce0:	1005003a 	cmpeq	r2,r2,zero
 d043ce4:	1000051e 	bne	r2,zero,d043cfc <ip_raw_input+0x94>
 d043ce8:	e0bffd17 	ldw	r2,-12(fp)
 d043cec:	10c00117 	ldw	r3,4(r2)
 d043cf0:	e0bffe17 	ldw	r2,-8(fp)
 d043cf4:	10800417 	ldw	r2,16(r2)
 d043cf8:	1880331e 	bne	r3,r2,d043dc8 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 d043cfc:	e0bffd17 	ldw	r2,-12(fp)
 d043d00:	10800217 	ldw	r2,8(r2)
 d043d04:	1005003a 	cmpeq	r2,r2,zero
 d043d08:	1000051e 	bne	r2,zero,d043d20 <ip_raw_input+0xb8>
 d043d0c:	e0bffd17 	ldw	r2,-12(fp)
 d043d10:	10c00217 	ldw	r3,8(r2)
 d043d14:	e0bffe17 	ldw	r2,-8(fp)
 d043d18:	10800317 	ldw	r2,12(r2)
 d043d1c:	18802a1e 	bne	r3,r2,d043dc8 <ip_raw_input+0x160>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 d043d20:	e0bffd17 	ldw	r2,-12(fp)
 d043d24:	10800317 	ldw	r2,12(r2)
 d043d28:	1005003a 	cmpeq	r2,r2,zero
 d043d2c:	1000261e 	bne	r2,zero,d043dc8 <ip_raw_input+0x160>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 d043d30:	e0bffb17 	ldw	r2,-20(fp)
 d043d34:	1005003a 	cmpeq	r2,r2,zero
 d043d38:	1000211e 	bne	r2,zero,d043dc0 <ip_raw_input+0x158>
 d043d3c:	e0bffb17 	ldw	r2,-20(fp)
 d043d40:	10800317 	ldw	r2,12(r2)
 d043d44:	1005003a 	cmpeq	r2,r2,zero
 d043d48:	10001d1e 	bne	r2,zero,d043dc0 <ip_raw_input+0x158>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 d043d4c:	e13fff17 	ldw	r4,-4(fp)
 d043d50:	d0409d40 	call	d0409d4 <ip_copypkt>
 d043d54:	e0bff815 	stw	r2,-32(fp)
            if (p2)
 d043d58:	e0bff817 	ldw	r2,-32(fp)
 d043d5c:	1005003a 	cmpeq	r2,r2,zero
 d043d60:	1000171e 	bne	r2,zero,d043dc0 <ip_raw_input+0x158>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 d043d64:	0009883a 	mov	r4,zero
 d043d68:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 d043d6c:	e0bffb17 	ldw	r2,-20(fp)
 d043d70:	10c00317 	ldw	r3,12(r2)
 d043d74:	e0bffb17 	ldw	r2,-20(fp)
 d043d78:	11400417 	ldw	r5,16(r2)
 d043d7c:	e13ff817 	ldw	r4,-32(fp)
 d043d80:	183ee83a 	callr	r3
 d043d84:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 d043d88:	0009883a 	mov	r4,zero
 d043d8c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
               if (err)
 d043d90:	e0bffa17 	ldw	r2,-24(fp)
 d043d94:	1005003a 	cmpeq	r2,r2,zero
 d043d98:	1000071e 	bne	r2,zero,d043db8 <ip_raw_input+0x150>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 d043d9c:	01000084 	movi	r4,2
 d043da0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 d043da4:	e13ff817 	ldw	r4,-32(fp)
 d043da8:	d0251a00 	call	d0251a0 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d043dac:	01000084 	movi	r4,2
 d043db0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
 d043db4:	00000206 	br	d043dc0 <ip_raw_input+0x158>
               }
               else
                  delivered = 1;
 d043db8:	00800044 	movi	r2,1
 d043dbc:	e0bff915 	stw	r2,-28(fp)
            }
         }
         matched_ep = ep;
 d043dc0:	e0bffd17 	ldw	r2,-12(fp)
 d043dc4:	e0bffb15 	stw	r2,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 d043dc8:	e0bffc17 	ldw	r2,-16(fp)
 d043dcc:	e0bffd15 	stw	r2,-12(fp)
 d043dd0:	e0bffd17 	ldw	r2,-12(fp)
 d043dd4:	1004c03a 	cmpne	r2,r2,zero
 d043dd8:	103fb01e 	bne	r2,zero,d043c9c <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 d043ddc:	e0bffb17 	ldw	r2,-20(fp)
 d043de0:	1005003a 	cmpeq	r2,r2,zero
 d043de4:	1000151e 	bne	r2,zero,d043e3c <ip_raw_input+0x1d4>
 d043de8:	e0bffb17 	ldw	r2,-20(fp)
 d043dec:	10800317 	ldw	r2,12(r2)
 d043df0:	1005003a 	cmpeq	r2,r2,zero
 d043df4:	1000111e 	bne	r2,zero,d043e3c <ip_raw_input+0x1d4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d043df8:	0009883a 	mov	r4,zero
 d043dfc:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 d043e00:	e0bffb17 	ldw	r2,-20(fp)
 d043e04:	10c00317 	ldw	r3,12(r2)
 d043e08:	e0bffb17 	ldw	r2,-20(fp)
 d043e0c:	11400417 	ldw	r5,16(r2)
 d043e10:	e13fff17 	ldw	r4,-4(fp)
 d043e14:	183ee83a 	callr	r3
 d043e18:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 d043e1c:	0009883a 	mov	r4,zero
 d043e20:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      if (err == 0)
 d043e24:	e0bffa17 	ldw	r2,-24(fp)
 d043e28:	1004c03a 	cmpne	r2,r2,zero
 d043e2c:	10000c1e 	bne	r2,zero,d043e60 <ip_raw_input+0x1f8>
         delivered = 1;
 d043e30:	00800044 	movi	r2,1
 d043e34:	e0bff915 	stw	r2,-28(fp)
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 d043e38:	00000906 	br	d043e60 <ip_raw_input+0x1f8>
      if (err == 0)
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 d043e3c:	00bffd84 	movi	r2,-10
 d043e40:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 d043e44:	008341b4 	movhi	r2,3334
 d043e48:	10856804 	addi	r2,r2,5536
 d043e4c:	10800617 	ldw	r2,24(r2)
 d043e50:	10c00044 	addi	r3,r2,1
 d043e54:	008341b4 	movhi	r2,3334
 d043e58:	10856804 	addi	r2,r2,5536
 d043e5c:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 d043e60:	e0bff917 	ldw	r2,-28(fp)
 d043e64:	1004c03a 	cmpne	r2,r2,zero
 d043e68:	1000071e 	bne	r2,zero,d043e88 <ip_raw_input+0x220>
      ip_mib.ipInDelivers--;
 d043e6c:	008341b4 	movhi	r2,3334
 d043e70:	10856804 	addi	r2,r2,5536
 d043e74:	10800817 	ldw	r2,32(r2)
 d043e78:	10ffffc4 	addi	r3,r2,-1
 d043e7c:	008341b4 	movhi	r2,3334
 d043e80:	10856804 	addi	r2,r2,5536
 d043e84:	10c00815 	stw	r3,32(r2)

   return err;
 d043e88:	e0bffa17 	ldw	r2,-24(fp)
}
 d043e8c:	e037883a 	mov	sp,fp
 d043e90:	dfc00117 	ldw	ra,4(sp)
 d043e94:	df000017 	ldw	fp,0(sp)
 d043e98:	dec00204 	addi	sp,sp,8
 d043e9c:	f800283a 	ret

0d043ea0 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 d043ea0:	defffa04 	addi	sp,sp,-24
 d043ea4:	dfc00515 	stw	ra,20(sp)
 d043ea8:	df000415 	stw	fp,16(sp)
 d043eac:	df000404 	addi	fp,sp,16
 d043eb0:	e13ffe15 	stw	r4,-8(fp)
 d043eb4:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 d043eb8:	e0bffe17 	ldw	r2,-8(fp)
 d043ebc:	10c00044 	addi	r3,r2,1
 d043ec0:	00bfff84 	movi	r2,-2
 d043ec4:	1884703a 	and	r2,r3,r2
 d043ec8:	e0bffd15 	stw	r2,-12(fp)
   if (!hdrincl)
 d043ecc:	e0bfff17 	ldw	r2,-4(fp)
 d043ed0:	1004c03a 	cmpne	r2,r2,zero
 d043ed4:	1000031e 	bne	r2,zero,d043ee4 <ip_raw_alloc+0x44>
      len += IPHSIZ;
 d043ed8:	e0bffd17 	ldw	r2,-12(fp)
 d043edc:	10800504 	addi	r2,r2,20
 d043ee0:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d043ee4:	01000084 	movi	r4,2
 d043ee8:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 d043eec:	00834174 	movhi	r2,3333
 d043ef0:	109b1e04 	addi	r2,r2,27768
 d043ef4:	10c00017 	ldw	r3,0(r2)
 d043ef8:	e0bffd17 	ldw	r2,-12(fp)
 d043efc:	1885883a 	add	r2,r3,r2
 d043f00:	1009883a 	mov	r4,r2
 d043f04:	d024e0c0 	call	d024e0c <pk_alloc>
 d043f08:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d043f0c:	01000084 	movi	r4,2
 d043f10:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   if (p)
 d043f14:	e0bffc17 	ldw	r2,-16(fp)
 d043f18:	1005003a 	cmpeq	r2,r2,zero
 d043f1c:	10000d1e 	bne	r2,zero,d043f54 <ip_raw_alloc+0xb4>
   {
      if (!hdrincl)
 d043f20:	e0bfff17 	ldw	r2,-4(fp)
 d043f24:	1004c03a 	cmpne	r2,r2,zero
 d043f28:	10000a1e 	bne	r2,zero,d043f54 <ip_raw_alloc+0xb4>
      {
         p->nb_prot += IPHSIZ;
 d043f2c:	e0bffc17 	ldw	r2,-16(fp)
 d043f30:	10800317 	ldw	r2,12(r2)
 d043f34:	10c00504 	addi	r3,r2,20
 d043f38:	e0bffc17 	ldw	r2,-16(fp)
 d043f3c:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 d043f40:	e0bffc17 	ldw	r2,-16(fp)
 d043f44:	10800417 	ldw	r2,16(r2)
 d043f48:	10fffb04 	addi	r3,r2,-20
 d043f4c:	e0bffc17 	ldw	r2,-16(fp)
 d043f50:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 d043f54:	e0bffc17 	ldw	r2,-16(fp)
}
 d043f58:	e037883a 	mov	sp,fp
 d043f5c:	dfc00117 	ldw	ra,4(sp)
 d043f60:	df000017 	ldw	fp,0(sp)
 d043f64:	dec00204 	addi	sp,sp,8
 d043f68:	f800283a 	ret

0d043f6c <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 d043f6c:	defffd04 	addi	sp,sp,-12
 d043f70:	dfc00215 	stw	ra,8(sp)
 d043f74:	df000115 	stw	fp,4(sp)
 d043f78:	df000104 	addi	fp,sp,4
 d043f7c:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d043f80:	01000084 	movi	r4,2
 d043f84:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p);
 d043f88:	e13fff17 	ldw	r4,-4(fp)
 d043f8c:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d043f90:	01000084 	movi	r4,2
 d043f94:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
}
 d043f98:	e037883a 	mov	sp,fp
 d043f9c:	dfc00117 	ldw	ra,4(sp)
 d043fa0:	df000017 	ldw	fp,0(sp)
 d043fa4:	dec00204 	addi	sp,sp,8
 d043fa8:	f800283a 	ret

0d043fac <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 d043fac:	defffd04 	addi	sp,sp,-12
 d043fb0:	df000215 	stw	fp,8(sp)
 d043fb4:	df000204 	addi	fp,sp,8
 d043fb8:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 d043fbc:	00834174 	movhi	r2,3333
 d043fc0:	10925704 	addi	r2,r2,18780
 d043fc4:	10c00017 	ldw	r3,0(r2)
 d043fc8:	00834174 	movhi	r2,3333
 d043fcc:	109b1e04 	addi	r2,r2,27768
 d043fd0:	10800017 	ldw	r2,0(r2)
 d043fd4:	1885c83a 	sub	r2,r3,r2
 d043fd8:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 d043fdc:	e0bfff17 	ldw	r2,-4(fp)
 d043fe0:	1004c03a 	cmpne	r2,r2,zero
 d043fe4:	1000031e 	bne	r2,zero,d043ff4 <ip_raw_maxalloc+0x48>
      len -= IPHSIZ;
 d043fe8:	e0bffe17 	ldw	r2,-8(fp)
 d043fec:	10bffb04 	addi	r2,r2,-20
 d043ff0:	e0bffe15 	stw	r2,-8(fp)
   return len;
 d043ff4:	e0bffe17 	ldw	r2,-8(fp)
}
 d043ff8:	e037883a 	mov	sp,fp
 d043ffc:	df000017 	ldw	fp,0(sp)
 d044000:	dec00104 	addi	sp,sp,4
 d044004:	f800283a 	ret

0d044008 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 d044008:	defff704 	addi	sp,sp,-36
 d04400c:	dfc00815 	stw	ra,32(sp)
 d044010:	df000715 	stw	fp,28(sp)
 d044014:	df000704 	addi	fp,sp,28
 d044018:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 d04401c:	e03ffc45 	stb	zero,-15(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 d044020:	e03ffd15 	stw	zero,-12(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d044024:	00834174 	movhi	r2,3333
 d044028:	109b6404 	addi	r2,r2,28048
 d04402c:	10800017 	ldw	r2,0(r2)
 d044030:	e0bffe15 	stw	r2,-8(fp)
 d044034:	00003e06 	br	d044130 <rt_lookup+0x128>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 d044038:	e0bffe17 	ldw	r2,-8(fp)
 d04403c:	10800617 	ldw	r2,24(r2)
 d044040:	1005003a 	cmpeq	r2,r2,zero
 d044044:	1000371e 	bne	r2,zero,d044124 <rt_lookup+0x11c>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 d044048:	e0bffe17 	ldw	r2,-8(fp)
 d04404c:	10800a17 	ldw	r2,40(r2)
 d044050:	e0bffb15 	stw	r2,-20(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 d044054:	e0bffe17 	ldw	r2,-8(fp)
 d044058:	10c00017 	ldw	r3,0(r2)
 d04405c:	e0bffb17 	ldw	r2,-20(fp)
 d044060:	1888703a 	and	r4,r3,r2
 d044064:	e0ffff17 	ldw	r3,-4(fp)
 d044068:	e0bffb17 	ldw	r2,-20(fp)
 d04406c:	1884703a 	and	r2,r3,r2
 d044070:	20802c1e 	bne	r4,r2,d044124 <rt_lookup+0x11c>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 d044074:	e03ffc05 	stb	zero,-16(fp)
 d044078:	00a00034 	movhi	r2,32768
 d04407c:	e0bffa15 	stw	r2,-24(fp)
 d044080:	00001b06 	br	d0440f0 <rt_lookup+0xe8>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 d044084:	e0bffb17 	ldw	r2,-20(fp)
 d044088:	1004d63a 	srli	r2,r2,24
 d04408c:	10c03fcc 	andi	r3,r2,255
 d044090:	e0bffb17 	ldw	r2,-20(fp)
 d044094:	1004d23a 	srli	r2,r2,8
 d044098:	10bfc00c 	andi	r2,r2,65280
 d04409c:	1886b03a 	or	r3,r3,r2
 d0440a0:	e0bffb17 	ldw	r2,-20(fp)
 d0440a4:	10bfc00c 	andi	r2,r2,65280
 d0440a8:	1004923a 	slli	r2,r2,8
 d0440ac:	1886b03a 	or	r3,r3,r2
 d0440b0:	e0bffb17 	ldw	r2,-20(fp)
 d0440b4:	10803fcc 	andi	r2,r2,255
 d0440b8:	1004963a 	slli	r2,r2,24
 d0440bc:	1886b03a 	or	r3,r3,r2
 d0440c0:	e0bffa17 	ldw	r2,-24(fp)
 d0440c4:	1884703a 	and	r2,r3,r2
 d0440c8:	e0bff915 	stw	r2,-28(fp)
            if (extracted_bit) ++curr_bits_matched;
 d0440cc:	e0bff917 	ldw	r2,-28(fp)
 d0440d0:	1005003a 	cmpeq	r2,r2,zero
 d0440d4:	1000031e 	bne	r2,zero,d0440e4 <rt_lookup+0xdc>
 d0440d8:	e0bffc03 	ldbu	r2,-16(fp)
 d0440dc:	10800044 	addi	r2,r2,1
 d0440e0:	e0bffc05 	stb	r2,-16(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 d0440e4:	e0bffa17 	ldw	r2,-24(fp)
 d0440e8:	1004d07a 	srli	r2,r2,1
 d0440ec:	e0bffa15 	stw	r2,-24(fp)
 d0440f0:	e0bffa17 	ldw	r2,-24(fp)
 d0440f4:	1004c03a 	cmpne	r2,r2,zero
 d0440f8:	103fe21e 	bne	r2,zero,d044084 <rt_lookup+0x7c>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 d0440fc:	e0fffc03 	ldbu	r3,-16(fp)
 d044100:	e0bffc43 	ldbu	r2,-15(fp)
 d044104:	10c0072e 	bgeu	r2,r3,d044124 <rt_lookup+0x11c>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 d044108:	e0bffc03 	ldbu	r2,-16(fp)
 d04410c:	e0bffc45 	stb	r2,-15(fp)
            netmatch = rtp;
 d044110:	e0bffe17 	ldw	r2,-8(fp)
 d044114:	e0bffd15 	stw	r2,-12(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 d044118:	e0bffc43 	ldbu	r2,-15(fp)
 d04411c:	10800820 	cmpeqi	r2,r2,32
 d044120:	10000f1e 	bne	r2,zero,d044160 <rt_lookup+0x158>
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d044124:	e0bffe17 	ldw	r2,-8(fp)
 d044128:	10800f04 	addi	r2,r2,60
 d04412c:	e0bffe15 	stw	r2,-8(fp)
 d044130:	00834174 	movhi	r2,3333
 d044134:	10927004 	addi	r2,r2,18880
 d044138:	11000017 	ldw	r4,0(r2)
 d04413c:	01400f04 	movi	r5,60
 d044140:	d00235c0 	call	d00235c <__mulsi3>
 d044144:	1007883a 	mov	r3,r2
 d044148:	00834174 	movhi	r2,3333
 d04414c:	109b6404 	addi	r2,r2,28048
 d044150:	10800017 	ldw	r2,0(r2)
 d044154:	1887883a 	add	r3,r3,r2
 d044158:	e0bffe17 	ldw	r2,-8(fp)
 d04415c:	10ffb636 	bltu	r2,r3,d044038 <rt_lookup+0x30>
               break;
         }
      }
   }

   if (netmatch)
 d044160:	e0bffd17 	ldw	r2,-12(fp)
 d044164:	1005003a 	cmpeq	r2,r2,zero
 d044168:	1000051e 	bne	r2,zero,d044180 <rt_lookup+0x178>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 d04416c:	00834174 	movhi	r2,3333
 d044170:	109b4504 	addi	r2,r2,27924
 d044174:	10c00017 	ldw	r3,0(r2)
 d044178:	e0bffd17 	ldw	r2,-12(fp)
 d04417c:	10c00915 	stw	r3,36(r2)

   return netmatch;
 d044180:	e0bffd17 	ldw	r2,-12(fp)
}
 d044184:	e037883a 	mov	sp,fp
 d044188:	dfc00117 	ldw	ra,4(sp)
 d04418c:	df000017 	ldw	fp,0(sp)
 d044190:	dec00204 	addi	sp,sp,8
 d044194:	f800283a 	ret

0d044198 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 d044198:	defff604 	addi	sp,sp,-40
 d04419c:	dfc00915 	stw	ra,36(sp)
 d0441a0:	df000815 	stw	fp,32(sp)
 d0441a4:	df000804 	addi	fp,sp,32
 d0441a8:	e13ffb15 	stw	r4,-20(fp)
 d0441ac:	e17ffc15 	stw	r5,-16(fp)
 d0441b0:	e1bffd15 	stw	r6,-12(fp)
 d0441b4:	e1fffe15 	stw	r7,-8(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 d0441b8:	e03ff915 	stw	zero,-28(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 d0441bc:	e13ffe17 	ldw	r4,-8(fp)
 d0441c0:	d03e5ac0 	call	d03e5ac <if_getbynum>
 d0441c4:	e0bff815 	stw	r2,-32(fp)
   if(!ifp)
 d0441c8:	e0bff817 	ldw	r2,-32(fp)
 d0441cc:	1004c03a 	cmpne	r2,r2,zero
 d0441d0:	1000021e 	bne	r2,zero,d0441dc <add_route+0x44>
      return NULL;
 d0441d4:	e03fff15 	stw	zero,-4(fp)
 d0441d8:	0000f406 	br	d0445ac <add_route+0x414>

   if (rt_mib == NULL)
 d0441dc:	00834174 	movhi	r2,3333
 d0441e0:	109b6404 	addi	r2,r2,28048
 d0441e4:	10800017 	ldw	r2,0(r2)
 d0441e8:	1004c03a 	cmpne	r2,r2,zero
 d0441ec:	1000021e 	bne	r2,zero,d0441f8 <add_route+0x60>
      return NULL;
 d0441f0:	e03fff15 	stw	zero,-4(fp)
 d0441f4:	0000ed06 	br	d0445ac <add_route+0x414>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 d0441f8:	e0bffb17 	ldw	r2,-20(fp)
 d0441fc:	1005003a 	cmpeq	r2,r2,zero
 d044200:	1000031e 	bne	r2,zero,d044210 <add_route+0x78>
 d044204:	e0bffc17 	ldw	r2,-16(fp)
 d044208:	1004c03a 	cmpne	r2,r2,zero
 d04420c:	1000241e 	bne	r2,zero,d0442a0 <add_route+0x108>
   {
      dtrap();    /* bad configuration? */
 d044210:	d025a500 	call	d025a50 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 d044214:	e0bffb17 	ldw	r2,-20(fp)
 d044218:	1004d63a 	srli	r2,r2,24
 d04421c:	10c03fcc 	andi	r3,r2,255
 d044220:	e0bffb17 	ldw	r2,-20(fp)
 d044224:	1004d23a 	srli	r2,r2,8
 d044228:	10bfc00c 	andi	r2,r2,65280
 d04422c:	1886b03a 	or	r3,r3,r2
 d044230:	e0bffb17 	ldw	r2,-20(fp)
 d044234:	10bfc00c 	andi	r2,r2,65280
 d044238:	1004923a 	slli	r2,r2,8
 d04423c:	1886b03a 	or	r3,r3,r2
 d044240:	e0bffb17 	ldw	r2,-20(fp)
 d044244:	10803fcc 	andi	r2,r2,255
 d044248:	1004963a 	slli	r2,r2,24
 d04424c:	188ab03a 	or	r5,r3,r2
 d044250:	e0bffc17 	ldw	r2,-16(fp)
 d044254:	1004d63a 	srli	r2,r2,24
 d044258:	10c03fcc 	andi	r3,r2,255
 d04425c:	e0bffc17 	ldw	r2,-16(fp)
 d044260:	1004d23a 	srli	r2,r2,8
 d044264:	10bfc00c 	andi	r2,r2,65280
 d044268:	1886b03a 	or	r3,r3,r2
 d04426c:	e0bffc17 	ldw	r2,-16(fp)
 d044270:	10bfc00c 	andi	r2,r2,65280
 d044274:	1004923a 	slli	r2,r2,8
 d044278:	1886b03a 	or	r3,r3,r2
 d04427c:	e0bffc17 	ldw	r2,-16(fp)
 d044280:	10803fcc 	andi	r2,r2,255
 d044284:	1004963a 	slli	r2,r2,24
 d044288:	188cb03a 	or	r6,r3,r2
 d04428c:	01034174 	movhi	r4,3333
 d044290:	2107c404 	addi	r4,r4,7952
 d044294:	d0028a00 	call	d0028a0 <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 d044298:	e03fff15 	stw	zero,-4(fp)
 d04429c:	0000c306 	br	d0445ac <add_route+0x414>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d0442a0:	00834174 	movhi	r2,3333
 d0442a4:	109b6404 	addi	r2,r2,28048
 d0442a8:	10800017 	ldw	r2,0(r2)
 d0442ac:	e0bffa15 	stw	r2,-24(fp)
 d0442b0:	00006f06 	br	d044470 <add_route+0x2d8>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 d0442b4:	e0bffa17 	ldw	r2,-24(fp)
 d0442b8:	10c00017 	ldw	r3,0(r2)
 d0442bc:	e0bffb17 	ldw	r2,-20(fp)
 d0442c0:	1880181e 	bne	r3,r2,d044324 <add_route+0x18c>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 d0442c4:	e0fffa17 	ldw	r3,-24(fp)
 d0442c8:	e0bffd17 	ldw	r2,-12(fp)
 d0442cc:	18800615 	stw	r2,24(r3)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 d0442d0:	00834174 	movhi	r2,3333
 d0442d4:	109b4504 	addi	r2,r2,27924
 d0442d8:	10c00017 	ldw	r3,0(r2)
 d0442dc:	e0bffa17 	ldw	r2,-24(fp)
 d0442e0:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 d0442e4:	e0bffe17 	ldw	r2,-8(fp)
 d0442e8:	10c00044 	addi	r3,r2,1
 d0442ec:	e0bffa17 	ldw	r2,-24(fp)
 d0442f0:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 d0442f4:	e0fffa17 	ldw	r3,-24(fp)
 d0442f8:	e0800217 	ldw	r2,8(fp)
 d0442fc:	18800815 	stw	r2,32(r3)
         rtp->ipRouteMask = mask;
 d044300:	e0fffa17 	ldw	r3,-24(fp)
 d044304:	e0bffc17 	ldw	r2,-16(fp)
 d044308:	18800a15 	stw	r2,40(r3)
         rtp->ifp = ifp;
 d04430c:	e0fffa17 	ldw	r3,-24(fp)
 d044310:	e0bff817 	ldw	r2,-32(fp)
 d044314:	18800e15 	stw	r2,56(r3)
         return(rtp);   /* just update and exit */
 d044318:	e0bffa17 	ldw	r2,-24(fp)
 d04431c:	e0bfff15 	stw	r2,-4(fp)
 d044320:	0000a206 	br	d0445ac <add_route+0x414>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 d044324:	e0bff917 	ldw	r2,-28(fp)
 d044328:	1005003a 	cmpeq	r2,r2,zero
 d04432c:	1000041e 	bne	r2,zero,d044340 <add_route+0x1a8>
 d044330:	e0bff917 	ldw	r2,-28(fp)
 d044334:	10800817 	ldw	r2,32(r2)
 d044338:	1005003a 	cmpeq	r2,r2,zero
 d04433c:	1000491e 	bne	r2,zero,d044464 <add_route+0x2cc>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 d044340:	e0bffa17 	ldw	r2,-24(fp)
 d044344:	10800617 	ldw	r2,24(r2)
 d044348:	1004c03a 	cmpne	r2,r2,zero
 d04434c:	1000051e 	bne	r2,zero,d044364 <add_route+0x1cc>
         {
            newrt = rtp;   /* record empty route for use */
 d044350:	e0bffa17 	ldw	r2,-24(fp)
 d044354:	e0bff915 	stw	r2,-28(fp)
            newrt->ipRouteProto = 0;
 d044358:	e0bff917 	ldw	r2,-28(fp)
 d04435c:	10000815 	stw	zero,32(r2)
            continue;
 d044360:	00004006 	br	d044464 <add_route+0x2cc>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 d044364:	e0c00217 	ldw	r3,8(fp)
 d044368:	00834174 	movhi	r2,3333
 d04436c:	1091c104 	addi	r2,r2,18180
 d044370:	10c5883a 	add	r2,r2,r3
 d044374:	11000003 	ldbu	r4,0(r2)
 d044378:	e0bffa17 	ldw	r2,-24(fp)
 d04437c:	10c00817 	ldw	r3,32(r2)
 d044380:	00834174 	movhi	r2,3333
 d044384:	1091c104 	addi	r2,r2,18180
 d044388:	10c5883a 	add	r2,r2,r3
 d04438c:	10800003 	ldbu	r2,0(r2)
 d044390:	20c03fcc 	andi	r3,r4,255
 d044394:	10803fcc 	andi	r2,r2,255
 d044398:	18803236 	bltu	r3,r2,d044464 <add_route+0x2cc>
         {
            if (!newrt)
 d04439c:	e0bff917 	ldw	r2,-28(fp)
 d0443a0:	1004c03a 	cmpne	r2,r2,zero
 d0443a4:	1000031e 	bne	r2,zero,d0443b4 <add_route+0x21c>
            {
               newrt = rtp;
 d0443a8:	e0bffa17 	ldw	r2,-24(fp)
 d0443ac:	e0bff915 	stw	r2,-28(fp)
               continue;
 d0443b0:	00002c06 	br	d044464 <add_route+0x2cc>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 d0443b4:	e0bffa17 	ldw	r2,-24(fp)
 d0443b8:	10c00817 	ldw	r3,32(r2)
 d0443bc:	00834174 	movhi	r2,3333
 d0443c0:	1091c104 	addi	r2,r2,18180
 d0443c4:	10c5883a 	add	r2,r2,r3
 d0443c8:	11000003 	ldbu	r4,0(r2)
 d0443cc:	e0bff917 	ldw	r2,-28(fp)
 d0443d0:	10c00817 	ldw	r3,32(r2)
 d0443d4:	00834174 	movhi	r2,3333
 d0443d8:	1091c104 	addi	r2,r2,18180
 d0443dc:	10c5883a 	add	r2,r2,r3
 d0443e0:	10800003 	ldbu	r2,0(r2)
 d0443e4:	20c03fcc 	andi	r3,r4,255
 d0443e8:	10803fcc 	andi	r2,r2,255
 d0443ec:	1880032e 	bgeu	r3,r2,d0443fc <add_route+0x264>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 d0443f0:	e0bffa17 	ldw	r2,-24(fp)
 d0443f4:	e0bff915 	stw	r2,-28(fp)
 d0443f8:	00001a06 	br	d044464 <add_route+0x2cc>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 d0443fc:	e0bffa17 	ldw	r2,-24(fp)
 d044400:	10c00817 	ldw	r3,32(r2)
 d044404:	00834174 	movhi	r2,3333
 d044408:	1091c104 	addi	r2,r2,18180
 d04440c:	10c5883a 	add	r2,r2,r3
 d044410:	11000003 	ldbu	r4,0(r2)
 d044414:	e0bff917 	ldw	r2,-28(fp)
 d044418:	10c00817 	ldw	r3,32(r2)
 d04441c:	00834174 	movhi	r2,3333
 d044420:	1091c104 	addi	r2,r2,18180
 d044424:	10c5883a 	add	r2,r2,r3
 d044428:	10800003 	ldbu	r2,0(r2)
 d04442c:	20c03fcc 	andi	r3,r4,255
 d044430:	10803fcc 	andi	r2,r2,255
 d044434:	18800b1e 	bne	r3,r2,d044464 <add_route+0x2cc>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 d044438:	e0bffa17 	ldw	r2,-24(fp)
 d04443c:	11000917 	ldw	r4,36(r2)
 d044440:	e0bff917 	ldw	r2,-28(fp)
 d044444:	11400917 	ldw	r5,36(r2)
 d044448:	d01e1ec0 	call	d01e1ec <c_older>
 d04444c:	1007883a 	mov	r3,r2
 d044450:	e0bffa17 	ldw	r2,-24(fp)
 d044454:	10800917 	ldw	r2,36(r2)
 d044458:	1880021e 	bne	r3,r2,d044464 <add_route+0x2cc>
                  newrt = rtp;   /* got an older one */
 d04445c:	e0bffa17 	ldw	r2,-24(fp)
 d044460:	e0bff915 	stw	r2,-28(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d044464:	e0bffa17 	ldw	r2,-24(fp)
 d044468:	10800f04 	addi	r2,r2,60
 d04446c:	e0bffa15 	stw	r2,-24(fp)
 d044470:	00834174 	movhi	r2,3333
 d044474:	10927004 	addi	r2,r2,18880
 d044478:	11000017 	ldw	r4,0(r2)
 d04447c:	01400f04 	movi	r5,60
 d044480:	d00235c0 	call	d00235c <__mulsi3>
 d044484:	1007883a 	mov	r3,r2
 d044488:	00834174 	movhi	r2,3333
 d04448c:	109b6404 	addi	r2,r2,28048
 d044490:	10800017 	ldw	r2,0(r2)
 d044494:	1887883a 	add	r3,r3,r2
 d044498:	e0bffa17 	ldw	r2,-24(fp)
 d04449c:	10ff8536 	bltu	r2,r3,d0442b4 <add_route+0x11c>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 d0444a0:	e0bff917 	ldw	r2,-28(fp)
 d0444a4:	1005003a 	cmpeq	r2,r2,zero
 d0444a8:	10002a1e 	bne	r2,zero,d044554 <add_route+0x3bc>
      rtp = newrt;   /* create new entry in lowest priority slot */
 d0444ac:	e0bff917 	ldw	r2,-28(fp)
 d0444b0:	e0bffa15 	stw	r2,-24(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 d0444b4:	e0fffa17 	ldw	r3,-24(fp)
 d0444b8:	e0bff817 	ldw	r2,-32(fp)
 d0444bc:	18800e15 	stw	r2,56(r3)
   rtp->ipRouteDest = dest;
 d0444c0:	e0fffa17 	ldw	r3,-24(fp)
 d0444c4:	e0bffb17 	ldw	r2,-20(fp)
 d0444c8:	18800015 	stw	r2,0(r3)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 d0444cc:	e13ff817 	ldw	r4,-32(fp)
 d0444d0:	d01e88c0 	call	d01e88c <if_netnumber>
 d0444d4:	10c00044 	addi	r3,r2,1
 d0444d8:	e0bffa17 	ldw	r2,-24(fp)
 d0444dc:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 d0444e0:	008341b4 	movhi	r2,3334
 d0444e4:	10856804 	addi	r2,r2,5536
 d0444e8:	10800117 	ldw	r2,4(r2)
 d0444ec:	1007883a 	mov	r3,r2
 d0444f0:	e0bffa17 	ldw	r2,-24(fp)
 d0444f4:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 d0444f8:	e0fffa17 	ldw	r3,-24(fp)
 d0444fc:	00bfffc4 	movi	r2,-1
 d044500:	18800315 	stw	r2,12(r3)
   rtp->ipRouteMetric3 = -1;
 d044504:	e0fffa17 	ldw	r3,-24(fp)
 d044508:	00bfffc4 	movi	r2,-1
 d04450c:	18800415 	stw	r2,16(r3)
   rtp->ipRouteMetric4 = -1;
 d044510:	e0fffa17 	ldw	r3,-24(fp)
 d044514:	00bfffc4 	movi	r2,-1
 d044518:	18800515 	stw	r2,20(r3)
   rtp->ipRouteNextHop = nexthop;
 d04451c:	e0fffa17 	ldw	r3,-24(fp)
 d044520:	e0bffd17 	ldw	r2,-12(fp)
 d044524:	18800615 	stw	r2,24(r3)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 d044528:	e0fffa17 	ldw	r3,-24(fp)
 d04452c:	e0800217 	ldw	r2,8(fp)
 d044530:	18800815 	stw	r2,32(r3)

   if ((dest & mask) == (nexthop & mask))
 d044534:	e0fffb17 	ldw	r3,-20(fp)
 d044538:	e0bffc17 	ldw	r2,-16(fp)
 d04453c:	1888703a 	and	r4,r3,r2
 d044540:	e0fffd17 	ldw	r3,-12(fp)
 d044544:	e0bffc17 	ldw	r2,-16(fp)
 d044548:	1884703a 	and	r2,r3,r2
 d04454c:	20800326 	beq	r4,r2,d04455c <add_route+0x3c4>
 d044550:	00000606 	br	d04456c <add_route+0x3d4>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 d044554:	e03fff15 	stw	zero,-4(fp)
 d044558:	00001406 	br	d0445ac <add_route+0x414>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 d04455c:	e0fffa17 	ldw	r3,-24(fp)
 d044560:	008000c4 	movi	r2,3
 d044564:	18800715 	stw	r2,28(r3)
 d044568:	00000306 	br	d044578 <add_route+0x3e0>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 d04456c:	e0fffa17 	ldw	r3,-24(fp)
 d044570:	00800104 	movi	r2,4
 d044574:	18800715 	stw	r2,28(r3)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 d044578:	00834174 	movhi	r2,3333
 d04457c:	109b4504 	addi	r2,r2,27924
 d044580:	10c00017 	ldw	r3,0(r2)
 d044584:	e0bffa17 	ldw	r2,-24(fp)
 d044588:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 d04458c:	e0fffa17 	ldw	r3,-24(fp)
 d044590:	e0bffc17 	ldw	r2,-16(fp)
 d044594:	18800a15 	stw	r2,40(r3)
   rtp->ipRouteMetric5 = -1;
 d044598:	e0fffa17 	ldw	r3,-24(fp)
 d04459c:	00bfffc4 	movi	r2,-1
 d0445a0:	18800b15 	stw	r2,44(r3)
   return(rtp);
 d0445a4:	e0bffa17 	ldw	r2,-24(fp)
 d0445a8:	e0bfff15 	stw	r2,-4(fp)
 d0445ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d0445b0:	e037883a 	mov	sp,fp
 d0445b4:	dfc00117 	ldw	ra,4(sp)
 d0445b8:	df000017 	ldw	fp,0(sp)
 d0445bc:	dec00204 	addi	sp,sp,8
 d0445c0:	f800283a 	ret

0d0445c4 <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 d0445c4:	defff704 	addi	sp,sp,-36
 d0445c8:	dfc00815 	stw	ra,32(sp)
 d0445cc:	df000715 	stw	fp,28(sp)
 d0445d0:	df000704 	addi	fp,sp,28
 d0445d4:	e13ffc15 	stw	r4,-16(fp)
 d0445d8:	e17ffd15 	stw	r5,-12(fp)
 d0445dc:	e1bffe15 	stw	r6,-8(fp)
   RTMIB rtp;
   int   retval   =  0;
 d0445e0:	e03ffa15 	stw	zero,-24(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 d0445e4:	e0bffe17 	ldw	r2,-8(fp)
 d0445e8:	10bfffd8 	cmpnei	r2,r2,-1
 d0445ec:	1000021e 	bne	r2,zero,d0445f8 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 d0445f0:	e03ff915 	stw	zero,-28(fp)
 d0445f4:	00000306 	br	d044604 <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 d0445f8:	e13ffe17 	ldw	r4,-8(fp)
 d0445fc:	d03e5ac0 	call	d03e5ac <if_getbynum>
 d044600:	e0bff915 	stw	r2,-28(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 d044604:	00834174 	movhi	r2,3333
 d044608:	109b6404 	addi	r2,r2,28048
 d04460c:	10800017 	ldw	r2,0(r2)
 d044610:	1004c03a 	cmpne	r2,r2,zero
 d044614:	1000021e 	bne	r2,zero,d044620 <del_route+0x5c>
      return 0;
 d044618:	e03fff15 	stw	zero,-4(fp)
 d04461c:	00003506 	br	d0446f4 <del_route+0x130>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d044620:	00834174 	movhi	r2,3333
 d044624:	109b6404 	addi	r2,r2,28048
 d044628:	10800017 	ldw	r2,0(r2)
 d04462c:	e0bffb15 	stw	r2,-20(fp)
 d044630:	00002206 	br	d0446bc <del_route+0xf8>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 d044634:	e0bffb17 	ldw	r2,-20(fp)
 d044638:	10800617 	ldw	r2,24(r2)
 d04463c:	1005003a 	cmpeq	r2,r2,zero
 d044640:	10001b1e 	bne	r2,zero,d0446b0 <del_route+0xec>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 d044644:	e0bff917 	ldw	r2,-28(fp)
 d044648:	1005003a 	cmpeq	r2,r2,zero
 d04464c:	1000041e 	bne	r2,zero,d044660 <del_route+0x9c>
 d044650:	e0bffb17 	ldw	r2,-20(fp)
 d044654:	10c00e17 	ldw	r3,56(r2)
 d044658:	e0bff917 	ldw	r2,-28(fp)
 d04465c:	1880141e 	bne	r3,r2,d0446b0 <del_route+0xec>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 d044660:	e0bffb17 	ldw	r2,-20(fp)
 d044664:	10c00017 	ldw	r3,0(r2)
 d044668:	e0bffd17 	ldw	r2,-12(fp)
 d04466c:	1888703a 	and	r4,r3,r2
 d044670:	e0fffc17 	ldw	r3,-16(fp)
 d044674:	e0bffd17 	ldw	r2,-12(fp)
 d044678:	1884703a 	and	r2,r3,r2
 d04467c:	2080081e 	bne	r4,r2,d0446a0 <del_route+0xdc>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 d044680:	e0bffb17 	ldw	r2,-20(fp)
 d044684:	1009883a 	mov	r4,r2
 d044688:	01800f04 	movi	r6,60
 d04468c:	000b883a 	mov	r5,zero
 d044690:	d0027880 	call	d002788 <memset>
         retval++;
 d044694:	e0bffa17 	ldw	r2,-24(fp)
 d044698:	10800044 	addi	r2,r2,1
 d04469c:	e0bffa15 	stw	r2,-24(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 d0446a0:	d0e94f17 	ldw	r3,-23236(gp)
 d0446a4:	e0bffb17 	ldw	r2,-20(fp)
 d0446a8:	1880011e 	bne	r3,r2,d0446b0 <del_route+0xec>
         cachedRoute = NULL;
 d0446ac:	d0294f15 	stw	zero,-23236(gp)
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d0446b0:	e0bffb17 	ldw	r2,-20(fp)
 d0446b4:	10800f04 	addi	r2,r2,60
 d0446b8:	e0bffb15 	stw	r2,-20(fp)
 d0446bc:	00834174 	movhi	r2,3333
 d0446c0:	10927004 	addi	r2,r2,18880
 d0446c4:	11000017 	ldw	r4,0(r2)
 d0446c8:	01400f04 	movi	r5,60
 d0446cc:	d00235c0 	call	d00235c <__mulsi3>
 d0446d0:	1007883a 	mov	r3,r2
 d0446d4:	00834174 	movhi	r2,3333
 d0446d8:	109b6404 	addi	r2,r2,28048
 d0446dc:	10800017 	ldw	r2,0(r2)
 d0446e0:	1887883a 	add	r3,r3,r2
 d0446e4:	e0bffb17 	ldw	r2,-20(fp)
 d0446e8:	10ffd236 	bltu	r2,r3,d044634 <del_route+0x70>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 d0446ec:	e0bffa17 	ldw	r2,-24(fp)
 d0446f0:	e0bfff15 	stw	r2,-4(fp)
 d0446f4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0446f8:	e037883a 	mov	sp,fp
 d0446fc:	dfc00117 	ldw	ra,4(sp)
 d044700:	df000017 	ldw	fp,0(sp)
 d044704:	dec00204 	addi	sp,sp,8
 d044708:	f800283a 	ret

0d04470c <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 d04470c:	deffec04 	addi	sp,sp,-80
 d044710:	dfc01315 	stw	ra,76(sp)
 d044714:	df001215 	stw	fp,72(sp)
 d044718:	df001204 	addi	fp,sp,72
 d04471c:	e13ffe15 	stw	r4,-8(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 d044720:	e0bffe17 	ldw	r2,-8(fp)
 d044724:	10800317 	ldw	r2,12(r2)
 d044728:	e0bffa15 	stw	r2,-24(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 d04472c:	e0bffa17 	ldw	r2,-24(fp)
 d044730:	10800003 	ldbu	r2,0(r2)
 d044734:	10803fcc 	andi	r2,r2,255
 d044738:	108003cc 	andi	r2,r2,15
 d04473c:	1085883a 	add	r2,r2,r2
 d044740:	1085883a 	add	r2,r2,r2
 d044744:	1007883a 	mov	r3,r2
 d044748:	e0bffa17 	ldw	r2,-24(fp)
 d04474c:	1885883a 	add	r2,r3,r2
 d044750:	e0bff915 	stw	r2,-28(fp)
   plen = htons(pup->ud_len);
 d044754:	e0bff917 	ldw	r2,-28(fp)
 d044758:	1080010b 	ldhu	r2,4(r2)
 d04475c:	10bfffcc 	andi	r2,r2,65535
 d044760:	1004d23a 	srli	r2,r2,8
 d044764:	10bfffcc 	andi	r2,r2,65535
 d044768:	10c03fcc 	andi	r3,r2,255
 d04476c:	e0bff917 	ldw	r2,-28(fp)
 d044770:	1080010b 	ldhu	r2,4(r2)
 d044774:	10bfffcc 	andi	r2,r2,65535
 d044778:	1004923a 	slli	r2,r2,8
 d04477c:	10bfc00c 	andi	r2,r2,65280
 d044780:	1884b03a 	or	r2,r3,r2
 d044784:	e0bff615 	stw	r2,-40(fp)

   if (plen > p->nb_plen)
 d044788:	e0bffe17 	ldw	r2,-8(fp)
 d04478c:	10c00417 	ldw	r3,16(r2)
 d044790:	e0bff617 	ldw	r2,-40(fp)
 d044794:	18802a2e 	bgeu	r3,r2,d044840 <udpdemux+0x134>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d044798:	00834174 	movhi	r2,3333
 d04479c:	109b2004 	addi	r2,r2,27776
 d0447a0:	10800017 	ldw	r2,0(r2)
 d0447a4:	1081000c 	andi	r2,r2,1024
 d0447a8:	1005003a 	cmpeq	r2,r2,zero
 d0447ac:	1000181e 	bne	r2,zero,d044810 <udpdemux+0x104>
 d0447b0:	00834174 	movhi	r2,3333
 d0447b4:	109b2004 	addi	r2,r2,27776
 d0447b8:	10800017 	ldw	r2,0(r2)
 d0447bc:	1080400c 	andi	r2,r2,256
 d0447c0:	1005003a 	cmpeq	r2,r2,zero
 d0447c4:	1000121e 	bne	r2,zero,d044810 <udpdemux+0x104>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 d0447c8:	e0bffe17 	ldw	r2,-8(fp)
 d0447cc:	11400417 	ldw	r5,16(r2)
 d0447d0:	e0bff917 	ldw	r2,-28(fp)
 d0447d4:	1080010b 	ldhu	r2,4(r2)
 d0447d8:	10bfffcc 	andi	r2,r2,65535
 d0447dc:	1004d23a 	srli	r2,r2,8
 d0447e0:	10bfffcc 	andi	r2,r2,65535
 d0447e4:	10c03fcc 	andi	r3,r2,255
 d0447e8:	e0bff917 	ldw	r2,-28(fp)
 d0447ec:	1080010b 	ldhu	r2,4(r2)
 d0447f0:	10bfffcc 	andi	r2,r2,65535
 d0447f4:	1004923a 	slli	r2,r2,8
 d0447f8:	10bfc00c 	andi	r2,r2,65280
 d0447fc:	1884b03a 	or	r2,r3,r2
 d044800:	11800204 	addi	r6,r2,8
 d044804:	01034174 	movhi	r4,3333
 d044808:	2107d204 	addi	r4,r4,8008
 d04480c:	d0028a00 	call	d0028a0 <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 d044810:	008341b4 	movhi	r2,3334
 d044814:	10858204 	addi	r2,r2,5640
 d044818:	10800217 	ldw	r2,8(r2)
 d04481c:	10c00044 	addi	r3,r2,1
 d044820:	008341b4 	movhi	r2,3334
 d044824:	10858204 	addi	r2,r2,5640
 d044828:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 d04482c:	e13ffe17 	ldw	r4,-8(fp)
 d044830:	d0455080 	call	d045508 <udp_free>
      return ENP_BAD_HEADER;
 d044834:	00bff804 	movi	r2,-32
 d044838:	e0bfff15 	stw	r2,-4(fp)
 d04483c:	0001c306 	br	d044f4c <udpdemux+0x840>
   }

   osum = pup->ud_cksum;
 d044840:	e0bff917 	ldw	r2,-28(fp)
 d044844:	1080018b 	ldhu	r2,6(r2)
 d044848:	e0bff78d 	sth	r2,-34(fp)
   /* did other guy use checksumming? */
   if (osum)
 d04484c:	e0bff78b 	ldhu	r2,-34(fp)
 d044850:	1005003a 	cmpeq	r2,r2,zero
 d044854:	1000631e 	bne	r2,zero,d0449e4 <udpdemux+0x2d8>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 d044858:	e0bff617 	ldw	r2,-40(fp)
 d04485c:	1080004c 	andi	r2,r2,1
 d044860:	10803fcc 	andi	r2,r2,255
 d044864:	1005003a 	cmpeq	r2,r2,zero
 d044868:	1000041e 	bne	r2,zero,d04487c <udpdemux+0x170>
 d04486c:	e0bff917 	ldw	r2,-28(fp)
 d044870:	e0fff617 	ldw	r3,-40(fp)
 d044874:	10c5883a 	add	r2,r2,r3
 d044878:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 d04487c:	e0bffe17 	ldw	r2,-8(fp)
 d044880:	10800717 	ldw	r2,28(r2)
 d044884:	e0bffb15 	stw	r2,-20(fp)
      php.ph_dest = pip->ip_dest;
 d044888:	e0bffa17 	ldw	r2,-24(fp)
 d04488c:	10800417 	ldw	r2,16(r2)
 d044890:	e0bffc15 	stw	r2,-16(fp)
      php.ph_zero = 0;
 d044894:	e03ffd05 	stb	zero,-12(fp)
      php.ph_prot = UDP_PROT;
 d044898:	00800444 	movi	r2,17
 d04489c:	e0bffd45 	stb	r2,-11(fp)
      php.ph_len  = pup->ud_len;
 d0448a0:	e0bff917 	ldw	r2,-28(fp)
 d0448a4:	1080010b 	ldhu	r2,4(r2)
 d0448a8:	e0bffd8d 	sth	r2,-10(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 d0448ac:	e13ffb04 	addi	r4,fp,-20
 d0448b0:	01400184 	movi	r5,6
 d0448b4:	d0205440 	call	d020544 <cksum>
 d0448b8:	1007883a 	mov	r3,r2
 d0448bc:	e0bff917 	ldw	r2,-28(fp)
 d0448c0:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 d0448c4:	e0bff617 	ldw	r2,-40(fp)
 d0448c8:	10800044 	addi	r2,r2,1
 d0448cc:	100ad07a 	srli	r5,r2,1
 d0448d0:	e13ff917 	ldw	r4,-28(fp)
 d0448d4:	d0205440 	call	d020544 <cksum>
 d0448d8:	0084303a 	nor	r2,zero,r2
 d0448dc:	e0bff70d 	sth	r2,-36(fp)
      if (!xsum)
 d0448e0:	e0bff70b 	ldhu	r2,-36(fp)
 d0448e4:	1004c03a 	cmpne	r2,r2,zero
 d0448e8:	1000021e 	bne	r2,zero,d0448f4 <udpdemux+0x1e8>
         xsum = 0xffff;
 d0448ec:	00bfffc4 	movi	r2,-1
 d0448f0:	e0bff70d 	sth	r2,-36(fp)
      pup->ud_cksum = osum;
 d0448f4:	e0fff917 	ldw	r3,-28(fp)
 d0448f8:	e0bff78b 	ldhu	r2,-34(fp)
 d0448fc:	1880018d 	sth	r2,6(r3)
      if (xsum != osum)
 d044900:	e0fff70b 	ldhu	r3,-36(fp)
 d044904:	e0bff78b 	ldhu	r2,-34(fp)
 d044908:	18803626 	beq	r3,r2,d0449e4 <udpdemux+0x2d8>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d04490c:	00834174 	movhi	r2,3333
 d044910:	109b2004 	addi	r2,r2,27776
 d044914:	10800017 	ldw	r2,0(r2)
 d044918:	1081000c 	andi	r2,r2,1024
 d04491c:	1005003a 	cmpeq	r2,r2,zero
 d044920:	1000241e 	bne	r2,zero,d0449b4 <udpdemux+0x2a8>
 d044924:	00834174 	movhi	r2,3333
 d044928:	109b2004 	addi	r2,r2,27776
 d04492c:	10800017 	ldw	r2,0(r2)
 d044930:	1080400c 	andi	r2,r2,256
 d044934:	1005003a 	cmpeq	r2,r2,zero
 d044938:	10001e1e 	bne	r2,zero,d0449b4 <udpdemux+0x2a8>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 d04493c:	e17ff78b 	ldhu	r5,-34(fp)
 d044940:	e1bff70b 	ldhu	r6,-36(fp)
 d044944:	e0bffe17 	ldw	r2,-8(fp)
 d044948:	10800717 	ldw	r2,28(r2)
 d04494c:	11c03fcc 	andi	r7,r2,255
 d044950:	e0bffe17 	ldw	r2,-8(fp)
 d044954:	10800717 	ldw	r2,28(r2)
 d044958:	1004d23a 	srli	r2,r2,8
 d04495c:	11003fcc 	andi	r4,r2,255
 d044960:	e0bffe17 	ldw	r2,-8(fp)
 d044964:	10800717 	ldw	r2,28(r2)
 d044968:	1004d43a 	srli	r2,r2,16
 d04496c:	10c03fcc 	andi	r3,r2,255
 d044970:	e0bffe17 	ldw	r2,-8(fp)
 d044974:	10800717 	ldw	r2,28(r2)
 d044978:	1004d63a 	srli	r2,r2,24
 d04497c:	d9000015 	stw	r4,0(sp)
 d044980:	d8c00115 	stw	r3,4(sp)
 d044984:	d8800215 	stw	r2,8(sp)
 d044988:	01034174 	movhi	r4,3333
 d04498c:	2107dc04 	addi	r4,r4,8048
 d044990:	d0028a00 	call	d0028a0 <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 d044994:	00834174 	movhi	r2,3333
 d044998:	109b2004 	addi	r2,r2,27776
 d04499c:	10800017 	ldw	r2,0(r2)
 d0449a0:	1080008c 	andi	r2,r2,2
 d0449a4:	1005003a 	cmpeq	r2,r2,zero
 d0449a8:	1000021e 	bne	r2,zero,d0449b4 <udpdemux+0x2a8>
               ip_dump(p);
 d0449ac:	e13ffe17 	ldw	r4,-8(fp)
 d0449b0:	d0404b00 	call	d0404b0 <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 d0449b4:	008341b4 	movhi	r2,3334
 d0449b8:	10858204 	addi	r2,r2,5640
 d0449bc:	10800217 	ldw	r2,8(r2)
 d0449c0:	10c00044 	addi	r3,r2,1
 d0449c4:	008341b4 	movhi	r2,3334
 d0449c8:	10858204 	addi	r2,r2,5640
 d0449cc:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 d0449d0:	e13ffe17 	ldw	r4,-8(fp)
 d0449d4:	d0455080 	call	d045508 <udp_free>
         return ENP_BAD_HEADER;
 d0449d8:	00bff804 	movi	r2,-32
 d0449dc:	e0bfff15 	stw	r2,-4(fp)
 d0449e0:	00015a06 	br	d044f4c <udpdemux+0x840>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 d0449e4:	e13ff917 	ldw	r4,-28(fp)
 d0449e8:	d04521c0 	call	d04521c <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 d0449ec:	e0bffa17 	ldw	r2,-24(fp)
 d0449f0:	10800003 	ldbu	r2,0(r2)
 d0449f4:	10803fcc 	andi	r2,r2,255
 d0449f8:	108003cc 	andi	r2,r2,15
 d0449fc:	1085883a 	add	r2,r2,r2
 d044a00:	1085883a 	add	r2,r2,r2
 d044a04:	10800204 	addi	r2,r2,8
 d044a08:	e0bff515 	stw	r2,-44(fp)
   p->nb_plen -= e;
 d044a0c:	e0bffe17 	ldw	r2,-8(fp)
 d044a10:	10c00417 	ldw	r3,16(r2)
 d044a14:	e0bff517 	ldw	r2,-44(fp)
 d044a18:	1887c83a 	sub	r3,r3,r2
 d044a1c:	e0bffe17 	ldw	r2,-8(fp)
 d044a20:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 d044a24:	e0bffe17 	ldw	r2,-8(fp)
 d044a28:	10c00317 	ldw	r3,12(r2)
 d044a2c:	e0bff517 	ldw	r2,-44(fp)
 d044a30:	1887883a 	add	r3,r3,r2
 d044a34:	e0bffe17 	ldw	r2,-8(fp)
 d044a38:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d044a3c:	00834174 	movhi	r2,3333
 d044a40:	109b2004 	addi	r2,r2,27776
 d044a44:	10800017 	ldw	r2,0(r2)
 d044a48:	1081000c 	andi	r2,r2,1024
 d044a4c:	1005003a 	cmpeq	r2,r2,zero
 d044a50:	1000221e 	bne	r2,zero,d044adc <udpdemux+0x3d0>
 d044a54:	00834174 	movhi	r2,3333
 d044a58:	109b2004 	addi	r2,r2,27776
 d044a5c:	10800017 	ldw	r2,0(r2)
 d044a60:	1080400c 	andi	r2,r2,256
 d044a64:	1005003a 	cmpeq	r2,r2,zero
 d044a68:	10001c1e 	bne	r2,zero,d044adc <udpdemux+0x3d0>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 d044a6c:	e0bffe17 	ldw	r2,-8(fp)
 d044a70:	10800717 	ldw	r2,28(r2)
 d044a74:	11803fcc 	andi	r6,r2,255
 d044a78:	e0bffe17 	ldw	r2,-8(fp)
 d044a7c:	10800717 	ldw	r2,28(r2)
 d044a80:	1004d23a 	srli	r2,r2,8
 d044a84:	11c03fcc 	andi	r7,r2,255
 d044a88:	e0bffe17 	ldw	r2,-8(fp)
 d044a8c:	10800717 	ldw	r2,28(r2)
 d044a90:	1004d43a 	srli	r2,r2,16
 d044a94:	10c03fcc 	andi	r3,r2,255
 d044a98:	e0bffe17 	ldw	r2,-8(fp)
 d044a9c:	10800717 	ldw	r2,28(r2)
 d044aa0:	1008d63a 	srli	r4,r2,24
 d044aa4:	e0bff917 	ldw	r2,-28(fp)
 d044aa8:	1080000b 	ldhu	r2,0(r2)
 d044aac:	117fffcc 	andi	r5,r2,65535
 d044ab0:	e0bff917 	ldw	r2,-28(fp)
 d044ab4:	1080008b 	ldhu	r2,2(r2)
 d044ab8:	10bfffcc 	andi	r2,r2,65535
 d044abc:	d8c00015 	stw	r3,0(sp)
 d044ac0:	d9000115 	stw	r4,4(sp)
 d044ac4:	d9400215 	stw	r5,8(sp)
 d044ac8:	d8800315 	stw	r2,12(sp)
 d044acc:	01034174 	movhi	r4,3333
 d044ad0:	2107ea04 	addi	r4,r4,8104
 d044ad4:	e17ff617 	ldw	r5,-40(fp)
 d044ad8:	d0028a00 	call	d0028a0 <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 d044adc:	00834174 	movhi	r2,3333
 d044ae0:	109b3904 	addi	r2,r2,27876
 d044ae4:	10800017 	ldw	r2,0(r2)
 d044ae8:	e0bff815 	stw	r2,-32(fp)
 d044aec:	0000b106 	br	d044db4 <udpdemux+0x6a8>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 d044af0:	e0bff817 	ldw	r2,-32(fp)
 d044af4:	1080018b 	ldhu	r2,6(r2)
 d044af8:	10bfffcc 	andi	r2,r2,65535
 d044afc:	1005003a 	cmpeq	r2,r2,zero
 d044b00:	1000071e 	bne	r2,zero,d044b20 <udpdemux+0x414>
 d044b04:	e0bff817 	ldw	r2,-32(fp)
 d044b08:	10c0018b 	ldhu	r3,6(r2)
 d044b0c:	e0bff917 	ldw	r2,-28(fp)
 d044b10:	1080008b 	ldhu	r2,2(r2)
 d044b14:	18ffffcc 	andi	r3,r3,65535
 d044b18:	10bfffcc 	andi	r2,r2,65535
 d044b1c:	1880a21e 	bne	r3,r2,d044da8 <udpdemux+0x69c>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 d044b20:	e0bff817 	ldw	r2,-32(fp)
 d044b24:	1080020b 	ldhu	r2,8(r2)
 d044b28:	10bfffcc 	andi	r2,r2,65535
 d044b2c:	1005003a 	cmpeq	r2,r2,zero
 d044b30:	1000071e 	bne	r2,zero,d044b50 <udpdemux+0x444>
 d044b34:	e0bff817 	ldw	r2,-32(fp)
 d044b38:	10c0020b 	ldhu	r3,8(r2)
 d044b3c:	e0bff917 	ldw	r2,-28(fp)
 d044b40:	1080000b 	ldhu	r2,0(r2)
 d044b44:	18ffffcc 	andi	r3,r3,65535
 d044b48:	10bfffcc 	andi	r2,r2,65535
 d044b4c:	1880961e 	bne	r3,r2,d044da8 <udpdemux+0x69c>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 d044b50:	e0bff817 	ldw	r2,-32(fp)
 d044b54:	10800417 	ldw	r2,16(r2)
 d044b58:	1005003a 	cmpeq	r2,r2,zero
 d044b5c:	1000051e 	bne	r2,zero,d044b74 <udpdemux+0x468>
 d044b60:	e0bff817 	ldw	r2,-32(fp)
 d044b64:	10c00417 	ldw	r3,16(r2)
 d044b68:	e0bffe17 	ldw	r2,-8(fp)
 d044b6c:	10800717 	ldw	r2,28(r2)
 d044b70:	18808d1e 	bne	r3,r2,d044da8 <udpdemux+0x69c>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 d044b74:	e0bffa17 	ldw	r2,-24(fp)
 d044b78:	10800417 	ldw	r2,16(r2)
 d044b7c:	1004d63a 	srli	r2,r2,24
 d044b80:	10c03fcc 	andi	r3,r2,255
 d044b84:	e0bffa17 	ldw	r2,-24(fp)
 d044b88:	10800417 	ldw	r2,16(r2)
 d044b8c:	1004d23a 	srli	r2,r2,8
 d044b90:	10bfc00c 	andi	r2,r2,65280
 d044b94:	1886b03a 	or	r3,r3,r2
 d044b98:	e0bffa17 	ldw	r2,-24(fp)
 d044b9c:	10800417 	ldw	r2,16(r2)
 d044ba0:	10bfc00c 	andi	r2,r2,65280
 d044ba4:	1004923a 	slli	r2,r2,8
 d044ba8:	1886b03a 	or	r3,r3,r2
 d044bac:	e0bffa17 	ldw	r2,-24(fp)
 d044bb0:	10800417 	ldw	r2,16(r2)
 d044bb4:	10803fcc 	andi	r2,r2,255
 d044bb8:	1004963a 	slli	r2,r2,24
 d044bbc:	1884b03a 	or	r2,r3,r2
 d044bc0:	10fc002c 	andhi	r3,r2,61440
 d044bc4:	00b80034 	movhi	r2,57344
 d044bc8:	1880301e 	bne	r3,r2,d044c8c <udpdemux+0x580>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 d044bcc:	e0bff817 	ldw	r2,-32(fp)
 d044bd0:	10800617 	ldw	r2,24(r2)
 d044bd4:	e0bff415 	stw	r2,-48(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 d044bd8:	e0bff817 	ldw	r2,-32(fp)
 d044bdc:	10c00517 	ldw	r3,20(r2)
 d044be0:	008340f4 	movhi	r2,3331
 d044be4:	10907804 	addi	r2,r2,16864
 d044be8:	1880281e 	bne	r3,r2,d044c8c <udpdemux+0x580>
 d044bec:	e0bff417 	ldw	r2,-48(fp)
 d044bf0:	10800317 	ldw	r2,12(r2)
 d044bf4:	1005003a 	cmpeq	r2,r2,zero
 d044bf8:	1000241e 	bne	r2,zero,d044c8c <udpdemux+0x580>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 d044bfc:	e0bff417 	ldw	r2,-48(fp)
 d044c00:	10800317 	ldw	r2,12(r2)
 d044c04:	e0bff215 	stw	r2,-56(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 d044c08:	e03ff30d 	sth	zero,-52(fp)
 d044c0c:	00001906 	br	d044c74 <udpdemux+0x568>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 d044c10:	e0bff30b 	ldhu	r2,-52(fp)
 d044c14:	e0fff217 	ldw	r3,-56(fp)
 d044c18:	1085883a 	add	r2,r2,r2
 d044c1c:	1085883a 	add	r2,r2,r2
 d044c20:	10c5883a 	add	r2,r2,r3
 d044c24:	10800204 	addi	r2,r2,8
 d044c28:	10800017 	ldw	r2,0(r2)
 d044c2c:	10c00117 	ldw	r3,4(r2)
 d044c30:	e0bffe17 	ldw	r2,-8(fp)
 d044c34:	10800617 	ldw	r2,24(r2)
 d044c38:	18800b1e 	bne	r3,r2,d044c68 <udpdemux+0x55c>
 d044c3c:	e0bff30b 	ldhu	r2,-52(fp)
 d044c40:	e0fff217 	ldw	r3,-56(fp)
 d044c44:	1085883a 	add	r2,r2,r2
 d044c48:	1085883a 	add	r2,r2,r2
 d044c4c:	10c5883a 	add	r2,r2,r3
 d044c50:	10800204 	addi	r2,r2,8
 d044c54:	10800017 	ldw	r2,0(r2)
 d044c58:	10c00017 	ldw	r3,0(r2)
 d044c5c:	e0bffa17 	ldw	r2,-24(fp)
 d044c60:	10800417 	ldw	r2,16(r2)
 d044c64:	18800926 	beq	r3,r2,d044c8c <udpdemux+0x580>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 d044c68:	e0bff30b 	ldhu	r2,-52(fp)
 d044c6c:	10800044 	addi	r2,r2,1
 d044c70:	e0bff30d 	sth	r2,-52(fp)
 d044c74:	e0bff217 	ldw	r2,-56(fp)
 d044c78:	1080018b 	ldhu	r2,6(r2)
 d044c7c:	10ffffcc 	andi	r3,r2,65535
 d044c80:	e0bff30b 	ldhu	r2,-52(fp)
 d044c84:	10ffe236 	bltu	r2,r3,d044c10 <udpdemux+0x504>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 d044c88:	00004706 	br	d044da8 <udpdemux+0x69c>
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 d044c8c:	e0bffa17 	ldw	r2,-24(fp)
 d044c90:	10800417 	ldw	r2,16(r2)
 d044c94:	1004d63a 	srli	r2,r2,24
 d044c98:	10c03fcc 	andi	r3,r2,255
 d044c9c:	e0bffa17 	ldw	r2,-24(fp)
 d044ca0:	10800417 	ldw	r2,16(r2)
 d044ca4:	1004d23a 	srli	r2,r2,8
 d044ca8:	10bfc00c 	andi	r2,r2,65280
 d044cac:	1886b03a 	or	r3,r3,r2
 d044cb0:	e0bffa17 	ldw	r2,-24(fp)
 d044cb4:	10800417 	ldw	r2,16(r2)
 d044cb8:	10bfc00c 	andi	r2,r2,65280
 d044cbc:	1004923a 	slli	r2,r2,8
 d044cc0:	1886b03a 	or	r3,r3,r2
 d044cc4:	e0bffa17 	ldw	r2,-24(fp)
 d044cc8:	10800417 	ldw	r2,16(r2)
 d044ccc:	10803fcc 	andi	r2,r2,255
 d044cd0:	1004963a 	slli	r2,r2,24
 d044cd4:	1884b03a 	or	r2,r3,r2
 d044cd8:	10fc002c 	andhi	r3,r2,61440
 d044cdc:	00b80034 	movhi	r2,57344
 d044ce0:	18800926 	beq	r3,r2,d044d08 <udpdemux+0x5fc>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 d044ce4:	e0bff817 	ldw	r2,-32(fp)
 d044ce8:	10800317 	ldw	r2,12(r2)
 d044cec:	1005003a 	cmpeq	r2,r2,zero
 d044cf0:	1000051e 	bne	r2,zero,d044d08 <udpdemux+0x5fc>
 d044cf4:	e0bff817 	ldw	r2,-32(fp)
 d044cf8:	10c00317 	ldw	r3,12(r2)
 d044cfc:	e0bffa17 	ldw	r2,-24(fp)
 d044d00:	10800417 	ldw	r2,16(r2)
 d044d04:	1880281e 	bne	r3,r2,d044da8 <udpdemux+0x69c>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 d044d08:	008341b4 	movhi	r2,3334
 d044d0c:	10858204 	addi	r2,r2,5640
 d044d10:	10800017 	ldw	r2,0(r2)
 d044d14:	10c00044 	addi	r3,r2,1
 d044d18:	008341b4 	movhi	r2,3334
 d044d1c:	10858204 	addi	r2,r2,5640
 d044d20:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 d044d24:	e0bff817 	ldw	r2,-32(fp)
 d044d28:	10800517 	ldw	r2,20(r2)
 d044d2c:	1005003a 	cmpeq	r2,r2,zero
 d044d30:	10000c1e 	bne	r2,zero,d044d64 <udpdemux+0x658>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 d044d34:	0009883a 	mov	r4,zero
 d044d38:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 d044d3c:	e0bff817 	ldw	r2,-32(fp)
 d044d40:	10c00517 	ldw	r3,20(r2)
 d044d44:	e0bff817 	ldw	r2,-32(fp)
 d044d48:	11400617 	ldw	r5,24(r2)
 d044d4c:	e13ffe17 	ldw	r4,-8(fp)
 d044d50:	183ee83a 	callr	r3
 d044d54:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 d044d58:	0009883a 	mov	r4,zero
 d044d5c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
 d044d60:	00000206 	br	d044d6c <udpdemux+0x660>
      }
      else
         e = ENP_LOGIC;
 d044d64:	00bffd44 	movi	r2,-11
 d044d68:	e0bff515 	stw	r2,-44(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 d044d6c:	e0bff517 	ldw	r2,-44(fp)
 d044d70:	1005003a 	cmpeq	r2,r2,zero
 d044d74:	1000091e 	bne	r2,zero,d044d9c <udpdemux+0x690>
      {
         udp_mib.udpInErrors++;
 d044d78:	008341b4 	movhi	r2,3334
 d044d7c:	10858204 	addi	r2,r2,5640
 d044d80:	10800217 	ldw	r2,8(r2)
 d044d84:	10c00044 	addi	r3,r2,1
 d044d88:	008341b4 	movhi	r2,3334
 d044d8c:	10858204 	addi	r2,r2,5640
 d044d90:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 d044d94:	e13ffe17 	ldw	r4,-8(fp)
 d044d98:	d0455080 	call	d045508 <udp_free>
      }

      return(e);
 d044d9c:	e0bff517 	ldw	r2,-44(fp)
 d044da0:	e0bfff15 	stw	r2,-4(fp)
 d044da4:	00006906 	br	d044f4c <udpdemux+0x840>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 d044da8:	e0bff817 	ldw	r2,-32(fp)
 d044dac:	10800017 	ldw	r2,0(r2)
 d044db0:	e0bff815 	stw	r2,-32(fp)
 d044db4:	e0bff817 	ldw	r2,-32(fp)
 d044db8:	1004c03a 	cmpne	r2,r2,zero
 d044dbc:	103f4c1e 	bne	r2,zero,d044af0 <udpdemux+0x3e4>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 d044dc0:	e0bffa17 	ldw	r2,-24(fp)
 d044dc4:	10800417 	ldw	r2,16(r2)
 d044dc8:	10bfffe0 	cmpeqi	r2,r2,-1
 d044dcc:	1000121e 	bne	r2,zero,d044e18 <udpdemux+0x70c>
 d044dd0:	e0bffa17 	ldw	r2,-24(fp)
 d044dd4:	10c00417 	ldw	r3,16(r2)
 d044dd8:	e0bffe17 	ldw	r2,-8(fp)
 d044ddc:	10800617 	ldw	r2,24(r2)
 d044de0:	10800e17 	ldw	r2,56(r2)
 d044de4:	18800c26 	beq	r3,r2,d044e18 <udpdemux+0x70c>
 d044de8:	e0bffa17 	ldw	r2,-24(fp)
 d044dec:	10c00417 	ldw	r3,16(r2)
 d044df0:	e0bffe17 	ldw	r2,-8(fp)
 d044df4:	10800617 	ldw	r2,24(r2)
 d044df8:	10800f17 	ldw	r2,60(r2)
 d044dfc:	18800626 	beq	r3,r2,d044e18 <udpdemux+0x70c>
 d044e00:	e0bffa17 	ldw	r2,-24(fp)
 d044e04:	10c00417 	ldw	r3,16(r2)
 d044e08:	e0bffe17 	ldw	r2,-8(fp)
 d044e0c:	10800617 	ldw	r2,24(r2)
 d044e10:	10801017 	ldw	r2,64(r2)
 d044e14:	18801b1e 	bne	r3,r2,d044e84 <udpdemux+0x778>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d044e18:	00834174 	movhi	r2,3333
 d044e1c:	109b2004 	addi	r2,r2,27776
 d044e20:	10800017 	ldw	r2,0(r2)
 d044e24:	1081000c 	andi	r2,r2,1024
 d044e28:	1005003a 	cmpeq	r2,r2,zero
 d044e2c:	1000091e 	bne	r2,zero,d044e54 <udpdemux+0x748>
 d044e30:	00834174 	movhi	r2,3333
 d044e34:	109b2004 	addi	r2,r2,27776
 d044e38:	10800017 	ldw	r2,0(r2)
 d044e3c:	1080400c 	andi	r2,r2,256
 d044e40:	1005003a 	cmpeq	r2,r2,zero
 d044e44:	1000031e 	bne	r2,zero,d044e54 <udpdemux+0x748>
         dprintf("UDP: ignoring ip broadcast\n");
 d044e48:	01034174 	movhi	r4,3333
 d044e4c:	2107f404 	addi	r4,r4,8144
 d044e50:	d002bc80 	call	d002bc8 <puts>
#endif
      udp_mib.udpInErrors++;
 d044e54:	008341b4 	movhi	r2,3334
 d044e58:	10858204 	addi	r2,r2,5640
 d044e5c:	10800217 	ldw	r2,8(r2)
 d044e60:	10c00044 	addi	r3,r2,1
 d044e64:	008341b4 	movhi	r2,3334
 d044e68:	10858204 	addi	r2,r2,5640
 d044e6c:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 d044e70:	e13ffe17 	ldw	r4,-8(fp)
 d044e74:	d0455080 	call	d045508 <udp_free>
      return ENP_NOT_MINE;
 d044e78:	00800084 	movi	r2,2
 d044e7c:	e0bfff15 	stw	r2,-4(fp)
 d044e80:	00003206 	br	d044f4c <udpdemux+0x840>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d044e84:	00834174 	movhi	r2,3333
 d044e88:	109b2004 	addi	r2,r2,27776
 d044e8c:	10800017 	ldw	r2,0(r2)
 d044e90:	1081000c 	andi	r2,r2,1024
 d044e94:	1005003a 	cmpeq	r2,r2,zero
 d044e98:	1000141e 	bne	r2,zero,d044eec <udpdemux+0x7e0>
 d044e9c:	00834174 	movhi	r2,3333
 d044ea0:	109b2004 	addi	r2,r2,27776
 d044ea4:	10800017 	ldw	r2,0(r2)
 d044ea8:	1080400c 	andi	r2,r2,256
 d044eac:	1005003a 	cmpeq	r2,r2,zero
 d044eb0:	10000e1e 	bne	r2,zero,d044eec <udpdemux+0x7e0>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 d044eb4:	e0bff917 	ldw	r2,-28(fp)
 d044eb8:	1080008b 	ldhu	r2,2(r2)
 d044ebc:	117fffcc 	andi	r5,r2,65535
 d044ec0:	01034174 	movhi	r4,3333
 d044ec4:	2107fb04 	addi	r4,r4,8172
 d044ec8:	d0028a00 	call	d0028a0 <printf>
      if (NDEBUG & DUMP) 
 d044ecc:	00834174 	movhi	r2,3333
 d044ed0:	109b2004 	addi	r2,r2,27776
 d044ed4:	10800017 	ldw	r2,0(r2)
 d044ed8:	1080008c 	andi	r2,r2,2
 d044edc:	1005003a 	cmpeq	r2,r2,zero
 d044ee0:	1000021e 	bne	r2,zero,d044eec <udpdemux+0x7e0>
         ip_dump(p);
 d044ee4:	e13ffe17 	ldw	r4,-8(fp)
 d044ee8:	d0404b00 	call	d0404b0 <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 d044eec:	e13ff917 	ldw	r4,-28(fp)
 d044ef0:	d04521c0 	call	d04521c <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 d044ef4:	e0bffe17 	ldw	r2,-8(fp)
 d044ef8:	11000717 	ldw	r4,28(r2)
 d044efc:	e0bffe17 	ldw	r2,-8(fp)
 d044f00:	10800617 	ldw	r2,24(r2)
 d044f04:	11400a17 	ldw	r5,40(r2)
 d044f08:	e0bffe17 	ldw	r2,-8(fp)
 d044f0c:	10800617 	ldw	r2,24(r2)
 d044f10:	d8800015 	stw	r2,0(sp)
 d044f14:	e1bffa17 	ldw	r6,-24(fp)
 d044f18:	01c000c4 	movi	r7,3
 d044f1c:	d04b6c40 	call	d04b6c4 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 d044f20:	008341b4 	movhi	r2,3334
 d044f24:	10858204 	addi	r2,r2,5640
 d044f28:	10800117 	ldw	r2,4(r2)
 d044f2c:	10c00044 	addi	r3,r2,1
 d044f30:	008341b4 	movhi	r2,3334
 d044f34:	10858204 	addi	r2,r2,5640
 d044f38:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 d044f3c:	e13ffe17 	ldw	r4,-8(fp)
 d044f40:	d0455080 	call	d045508 <udp_free>
   return ENP_NOT_MINE;
 d044f44:	00800084 	movi	r2,2
 d044f48:	e0bfff15 	stw	r2,-4(fp)
 d044f4c:	e0bfff17 	ldw	r2,-4(fp)
}
 d044f50:	e037883a 	mov	sp,fp
 d044f54:	dfc00117 	ldw	ra,4(sp)
 d044f58:	df000017 	ldw	fp,0(sp)
 d044f5c:	dec00204 	addi	sp,sp,8
 d044f60:	f800283a 	ret

0d044f64 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 d044f64:	deffee04 	addi	sp,sp,-72
 d044f68:	dfc01115 	stw	ra,68(sp)
 d044f6c:	df001015 	stw	fp,64(sp)
 d044f70:	df001004 	addi	fp,sp,64
 d044f74:	e1bffe15 	stw	r6,-8(fp)
 d044f78:	e13ffc0d 	sth	r4,-16(fp)
 d044f7c:	e17ffd0d 	sth	r5,-12(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 d044f80:	00834174 	movhi	r2,3333
 d044f84:	109b2004 	addi	r2,r2,27776
 d044f88:	10800017 	ldw	r2,0(r2)
 d044f8c:	1080410c 	andi	r2,r2,260
 d044f90:	1005003a 	cmpeq	r2,r2,zero
 d044f94:	10001c1e 	bne	r2,zero,d045008 <udp_send+0xa4>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 d044f98:	e0bffe17 	ldw	r2,-8(fp)
 d044f9c:	11800417 	ldw	r6,16(r2)
 d044fa0:	e1fffd0b 	ldhu	r7,-12(fp)
 d044fa4:	e0bffe17 	ldw	r2,-8(fp)
 d044fa8:	10800717 	ldw	r2,28(r2)
 d044fac:	12003fcc 	andi	r8,r2,255
 d044fb0:	e0bffe17 	ldw	r2,-8(fp)
 d044fb4:	10800717 	ldw	r2,28(r2)
 d044fb8:	1004d23a 	srli	r2,r2,8
 d044fbc:	11003fcc 	andi	r4,r2,255
 d044fc0:	e0bffe17 	ldw	r2,-8(fp)
 d044fc4:	10800717 	ldw	r2,28(r2)
 d044fc8:	1004d43a 	srli	r2,r2,16
 d044fcc:	11403fcc 	andi	r5,r2,255
 d044fd0:	e0bffe17 	ldw	r2,-8(fp)
 d044fd4:	10800717 	ldw	r2,28(r2)
 d044fd8:	1004d63a 	srli	r2,r2,24
 d044fdc:	e0fffc0b 	ldhu	r3,-16(fp)
 d044fe0:	d9000015 	stw	r4,0(sp)
 d044fe4:	d9400115 	stw	r5,4(sp)
 d044fe8:	d8800215 	stw	r2,8(sp)
 d044fec:	d8c00315 	stw	r3,12(sp)
 d044ff0:	01034174 	movhi	r4,3333
 d044ff4:	21080204 	addi	r4,r4,8200
 d044ff8:	300b883a 	mov	r5,r6
 d044ffc:	380d883a 	mov	r6,r7
 d045000:	400f883a 	mov	r7,r8
 d045004:	d0028a00 	call	d0028a0 <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 d045008:	0009883a 	mov	r4,zero
 d04500c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 d045010:	e0bffe17 	ldw	r2,-8(fp)
 d045014:	10800317 	ldw	r2,12(r2)
 d045018:	10fffe04 	addi	r3,r2,-8
 d04501c:	e0bffe17 	ldw	r2,-8(fp)
 d045020:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 d045024:	e0bffe17 	ldw	r2,-8(fp)
 d045028:	10800317 	ldw	r2,12(r2)
 d04502c:	e0bff815 	stw	r2,-32(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 d045030:	e0bffe17 	ldw	r2,-8(fp)
 d045034:	10800417 	ldw	r2,16(r2)
 d045038:	10800204 	addi	r2,r2,8
 d04503c:	e0bff615 	stw	r2,-40(fp)
   p->nb_plen = udplen;
 d045040:	e0fff617 	ldw	r3,-40(fp)
 d045044:	e0bffe17 	ldw	r2,-8(fp)
 d045048:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 d04504c:	e0bff617 	ldw	r2,-40(fp)
 d045050:	1080004c 	andi	r2,r2,1
 d045054:	10803fcc 	andi	r2,r2,255
 d045058:	1005003a 	cmpeq	r2,r2,zero
 d04505c:	1000041e 	bne	r2,zero,d045070 <udp_send+0x10c>
 d045060:	e0fff817 	ldw	r3,-32(fp)
 d045064:	e0bff617 	ldw	r2,-40(fp)
 d045068:	1885883a 	add	r2,r3,r2
 d04506c:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 d045070:	e0bff617 	ldw	r2,-40(fp)
 d045074:	1007883a 	mov	r3,r2
 d045078:	e0bff817 	ldw	r2,-32(fp)
 d04507c:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 d045080:	e0fff817 	ldw	r3,-32(fp)
 d045084:	e0bffd0b 	ldhu	r2,-12(fp)
 d045088:	1880000d 	sth	r2,0(r3)
   pup->ud_dstp = fport;
 d04508c:	e0fff817 	ldw	r3,-32(fp)
 d045090:	e0bffc0b 	ldhu	r2,-16(fp)
 d045094:	1880008d 	sth	r2,2(r3)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 d045098:	e13ff817 	ldw	r4,-32(fp)
 d04509c:	d04521c0 	call	d04521c <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 d0450a0:	e0bffe17 	ldw	r2,-8(fp)
 d0450a4:	10800717 	ldw	r2,28(r2)
 d0450a8:	10bfffd8 	cmpnei	r2,r2,-1
 d0450ac:	1000111e 	bne	r2,zero,d0450f4 <udp_send+0x190>
   {
      if (!p->net)
 d0450b0:	e0bffe17 	ldw	r2,-8(fp)
 d0450b4:	10800617 	ldw	r2,24(r2)
 d0450b8:	1004c03a 	cmpne	r2,r2,zero
 d0450bc:	1000081e 	bne	r2,zero,d0450e0 <udp_send+0x17c>
      {
         dtrap();    /* programmer forgot to select iface */
 d0450c0:	d025a500 	call	d025a50 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 d0450c4:	e13ffe17 	ldw	r4,-8(fp)
 d0450c8:	d0455080 	call	d045508 <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 d0450cc:	0009883a 	mov	r4,zero
 d0450d0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 d0450d4:	00bff784 	movi	r2,-34
 d0450d8:	e0bfff15 	stw	r2,-4(fp)
 d0450dc:	00004906 	br	d045204 <udp_send+0x2a0>
      }
      src_ip = p->net->n_ipaddr;
 d0450e0:	e0bffe17 	ldw	r2,-8(fp)
 d0450e4:	10800617 	ldw	r2,24(r2)
 d0450e8:	10800a17 	ldw	r2,40(r2)
 d0450ec:	e0bff415 	stw	r2,-48(fp)
 d0450f0:	00000406 	br	d045104 <udp_send+0x1a0>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 d0450f4:	e0bffe17 	ldw	r2,-8(fp)
 d0450f8:	11000717 	ldw	r4,28(r2)
 d0450fc:	d0404040 	call	d040404 <ip_mymach>
 d045100:	e0bff415 	stw	r2,-48(fp)
   php.ph_src = src_ip;
 d045104:	e0bff417 	ldw	r2,-48(fp)
 d045108:	e0bff915 	stw	r2,-28(fp)
   php.ph_dest = p->fhost;
 d04510c:	e0bffe17 	ldw	r2,-8(fp)
 d045110:	10800717 	ldw	r2,28(r2)
 d045114:	e0bffa15 	stw	r2,-24(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 d045118:	e03ffb05 	stb	zero,-20(fp)
   php.ph_prot = UDP_PROT;
 d04511c:	00800444 	movi	r2,17
 d045120:	e0bffb45 	stb	r2,-19(fp)
   php.ph_len = pup->ud_len;
 d045124:	e0bff817 	ldw	r2,-32(fp)
 d045128:	1080010b 	ldhu	r2,4(r2)
 d04512c:	e0bffb8d 	sth	r2,-18(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 d045130:	e13ff904 	addi	r4,fp,-28
 d045134:	01400184 	movi	r5,6
 d045138:	d0205440 	call	d020544 <cksum>
 d04513c:	1007883a 	mov	r3,r2
 d045140:	e0bff817 	ldw	r2,-32(fp)
 d045144:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 d045148:	e0bff617 	ldw	r2,-40(fp)
 d04514c:	10800044 	addi	r2,r2,1
 d045150:	1005d07a 	srai	r2,r2,1
 d045154:	100b883a 	mov	r5,r2
 d045158:	e13ff817 	ldw	r4,-32(fp)
 d04515c:	d0205440 	call	d020544 <cksum>
 d045160:	0084303a 	nor	r2,zero,r2
 d045164:	1007883a 	mov	r3,r2
 d045168:	e0bff817 	ldw	r2,-32(fp)
 d04516c:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 d045170:	e0bff817 	ldw	r2,-32(fp)
 d045174:	1080018b 	ldhu	r2,6(r2)
 d045178:	10bfffcc 	andi	r2,r2,65535
 d04517c:	1004c03a 	cmpne	r2,r2,zero
 d045180:	1000031e 	bne	r2,zero,d045190 <udp_send+0x22c>
      pup->ud_cksum = 0xffff;
 d045184:	e0fff817 	ldw	r3,-32(fp)
 d045188:	00bfffc4 	movi	r2,-1
 d04518c:	1880018d 	sth	r2,6(r3)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 d045190:	e0bffe17 	ldw	r2,-8(fp)
 d045194:	10800317 	ldw	r2,12(r2)
 d045198:	10bffb04 	addi	r2,r2,-20
 d04519c:	e0bff715 	stw	r2,-36(fp)
   pip->ip_src = src_ip;
 d0451a0:	e0fff717 	ldw	r3,-36(fp)
 d0451a4:	e0bff417 	ldw	r2,-48(fp)
 d0451a8:	18800315 	stw	r2,12(r3)
   pip->ip_dest = p->fhost;
 d0451ac:	e0bffe17 	ldw	r2,-8(fp)
 d0451b0:	10c00717 	ldw	r3,28(r2)
 d0451b4:	e0bff717 	ldw	r2,-36(fp)
 d0451b8:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 d0451bc:	008341b4 	movhi	r2,3334
 d0451c0:	10858204 	addi	r2,r2,5640
 d0451c4:	10800317 	ldw	r2,12(r2)
 d0451c8:	10c00044 	addi	r3,r2,1
 d0451cc:	008341b4 	movhi	r2,3334
 d0451d0:	10858204 	addi	r2,r2,5640
 d0451d4:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 d0451d8:	e0fff617 	ldw	r3,-40(fp)
 d0451dc:	e0bffe17 	ldw	r2,-8(fp)
 d0451e0:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 d0451e4:	01000444 	movi	r4,17
 d0451e8:	e17ffe17 	ldw	r5,-8(fp)
 d0451ec:	d03f2780 	call	d03f278 <ip_write>
 d0451f0:	e0bff515 	stw	r2,-44(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d0451f4:	0009883a 	mov	r4,zero
 d0451f8:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   return e;
 d0451fc:	e0bff517 	ldw	r2,-44(fp)
 d045200:	e0bfff15 	stw	r2,-4(fp)
 d045204:	e0bfff17 	ldw	r2,-4(fp)
}
 d045208:	e037883a 	mov	sp,fp
 d04520c:	dfc00117 	ldw	ra,4(sp)
 d045210:	df000017 	ldw	fp,0(sp)
 d045214:	dec00204 	addi	sp,sp,8
 d045218:	f800283a 	ret

0d04521c <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 d04521c:	defffe04 	addi	sp,sp,-8
 d045220:	df000115 	stw	fp,4(sp)
 d045224:	df000104 	addi	fp,sp,4
 d045228:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 d04522c:	e0bfff17 	ldw	r2,-4(fp)
 d045230:	1080000b 	ldhu	r2,0(r2)
 d045234:	10bfffcc 	andi	r2,r2,65535
 d045238:	1004d23a 	srli	r2,r2,8
 d04523c:	10803fcc 	andi	r2,r2,255
 d045240:	1009883a 	mov	r4,r2
 d045244:	e0bfff17 	ldw	r2,-4(fp)
 d045248:	1080000b 	ldhu	r2,0(r2)
 d04524c:	10bfffcc 	andi	r2,r2,65535
 d045250:	1004923a 	slli	r2,r2,8
 d045254:	1007883a 	mov	r3,r2
 d045258:	00bfc004 	movi	r2,-256
 d04525c:	1884703a 	and	r2,r3,r2
 d045260:	2084b03a 	or	r2,r4,r2
 d045264:	1007883a 	mov	r3,r2
 d045268:	e0bfff17 	ldw	r2,-4(fp)
 d04526c:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 d045270:	e0bfff17 	ldw	r2,-4(fp)
 d045274:	1080008b 	ldhu	r2,2(r2)
 d045278:	10bfffcc 	andi	r2,r2,65535
 d04527c:	1004d23a 	srli	r2,r2,8
 d045280:	10803fcc 	andi	r2,r2,255
 d045284:	1009883a 	mov	r4,r2
 d045288:	e0bfff17 	ldw	r2,-4(fp)
 d04528c:	1080008b 	ldhu	r2,2(r2)
 d045290:	10bfffcc 	andi	r2,r2,65535
 d045294:	1004923a 	slli	r2,r2,8
 d045298:	1007883a 	mov	r3,r2
 d04529c:	00bfc004 	movi	r2,-256
 d0452a0:	1884703a 	and	r2,r3,r2
 d0452a4:	2084b03a 	or	r2,r4,r2
 d0452a8:	1007883a 	mov	r3,r2
 d0452ac:	e0bfff17 	ldw	r2,-4(fp)
 d0452b0:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 d0452b4:	e0bfff17 	ldw	r2,-4(fp)
 d0452b8:	1080010b 	ldhu	r2,4(r2)
 d0452bc:	10bfffcc 	andi	r2,r2,65535
 d0452c0:	1004d23a 	srli	r2,r2,8
 d0452c4:	10803fcc 	andi	r2,r2,255
 d0452c8:	1009883a 	mov	r4,r2
 d0452cc:	e0bfff17 	ldw	r2,-4(fp)
 d0452d0:	1080010b 	ldhu	r2,4(r2)
 d0452d4:	10bfffcc 	andi	r2,r2,65535
 d0452d8:	1004923a 	slli	r2,r2,8
 d0452dc:	1007883a 	mov	r3,r2
 d0452e0:	00bfc004 	movi	r2,-256
 d0452e4:	1884703a 	and	r2,r3,r2
 d0452e8:	2084b03a 	or	r2,r4,r2
 d0452ec:	1007883a 	mov	r3,r2
 d0452f0:	e0bfff17 	ldw	r2,-4(fp)
 d0452f4:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 d0452f8:	e0bfff17 	ldw	r2,-4(fp)
 d0452fc:	1080018b 	ldhu	r2,6(r2)
 d045300:	10bfffcc 	andi	r2,r2,65535
 d045304:	1004d23a 	srli	r2,r2,8
 d045308:	10803fcc 	andi	r2,r2,255
 d04530c:	1009883a 	mov	r4,r2
 d045310:	e0bfff17 	ldw	r2,-4(fp)
 d045314:	1080018b 	ldhu	r2,6(r2)
 d045318:	10bfffcc 	andi	r2,r2,65535
 d04531c:	1004923a 	slli	r2,r2,8
 d045320:	1007883a 	mov	r3,r2
 d045324:	00bfc004 	movi	r2,-256
 d045328:	1884703a 	and	r2,r3,r2
 d04532c:	2084b03a 	or	r2,r4,r2
 d045330:	1007883a 	mov	r3,r2
 d045334:	e0bfff17 	ldw	r2,-4(fp)
 d045338:	10c0018d 	sth	r3,6(r2)
}
 d04533c:	e037883a 	mov	sp,fp
 d045340:	df000017 	ldw	fp,0(sp)
 d045344:	dec00104 	addi	sp,sp,4
 d045348:	f800283a 	ret

0d04534c <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 d04534c:	defffe04 	addi	sp,sp,-8
 d045350:	df000115 	stw	fp,4(sp)
 d045354:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 d045358:	d0a9500b 	ldhu	r2,-23232(gp)
 d04535c:	10bfffcc 	andi	r2,r2,65535
 d045360:	10812c28 	cmpgeui	r2,r2,1200
 d045364:	10000c1e 	bne	r2,zero,d045398 <udp_socket+0x4c>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 d045368:	00834174 	movhi	r2,3333
 d04536c:	109b4504 	addi	r2,r2,27924
 d045370:	10800017 	ldw	r2,0(r2)
 d045374:	109fffcc 	andi	r2,r2,32767
 d045378:	d0a9500d 	sth	r2,-23232(gp)
      if (usocket < MINSOCKET)
 d04537c:	d0a9500b 	ldhu	r2,-23232(gp)
 d045380:	10bfffcc 	andi	r2,r2,65535
 d045384:	10812c28 	cmpgeui	r2,r2,1200
 d045388:	1000031e 	bne	r2,zero,d045398 <udp_socket+0x4c>
         usocket += MINSOCKET;
 d04538c:	d0a9500b 	ldhu	r2,-23232(gp)
 d045390:	10812c04 	addi	r2,r2,1200
 d045394:	d0a9500d 	sth	r2,-23232(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d045398:	00834174 	movhi	r2,3333
 d04539c:	109b3904 	addi	r2,r2,27876
 d0453a0:	10800017 	ldw	r2,0(r2)
 d0453a4:	e0bfff15 	stw	r2,-4(fp)
 d0453a8:	00001006 	br	d0453ec <udp_socket+0xa0>
   {
      if (tmp->u_lport == usocket)
 d0453ac:	e0bfff17 	ldw	r2,-4(fp)
 d0453b0:	1080018b 	ldhu	r2,6(r2)
 d0453b4:	d0e9500b 	ldhu	r3,-23232(gp)
 d0453b8:	113fffcc 	andi	r4,r2,65535
 d0453bc:	18bfffcc 	andi	r2,r3,65535
 d0453c0:	2080071e 	bne	r4,r2,d0453e0 <udp_socket+0x94>
      {
         usocket++;     /* bump socket number */
 d0453c4:	d0a9500b 	ldhu	r2,-23232(gp)
 d0453c8:	10800044 	addi	r2,r2,1
 d0453cc:	d0a9500d 	sth	r2,-23232(gp)
         tmp = firstudp;   /* restart scan */
 d0453d0:	00834174 	movhi	r2,3333
 d0453d4:	109b3904 	addi	r2,r2,27876
 d0453d8:	10800017 	ldw	r2,0(r2)
 d0453dc:	e0bfff15 	stw	r2,-4(fp)
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d0453e0:	e0bfff17 	ldw	r2,-4(fp)
 d0453e4:	10800017 	ldw	r2,0(r2)
 d0453e8:	e0bfff15 	stw	r2,-4(fp)
 d0453ec:	e0bfff17 	ldw	r2,-4(fp)
 d0453f0:	1004c03a 	cmpne	r2,r2,zero
 d0453f4:	103fed1e 	bne	r2,zero,d0453ac <udp_socket+0x60>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 d0453f8:	d0a9500b 	ldhu	r2,-23232(gp)
 d0453fc:	10ffffcc 	andi	r3,r2,65535
 d045400:	10800044 	addi	r2,r2,1
 d045404:	d0a9500d 	sth	r2,-23232(gp)
 d045408:	1805883a 	mov	r2,r3
}
 d04540c:	e037883a 	mov	sp,fp
 d045410:	df000017 	ldw	fp,0(sp)
 d045414:	dec00104 	addi	sp,sp,4
 d045418:	f800283a 	ret

0d04541c <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 d04541c:	defffa04 	addi	sp,sp,-24
 d045420:	dfc00515 	stw	ra,20(sp)
 d045424:	df000415 	stw	fp,16(sp)
 d045428:	df000404 	addi	fp,sp,16
 d04542c:	e13ffe15 	stw	r4,-8(fp)
 d045430:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 d045434:	e0bffe17 	ldw	r2,-8(fp)
 d045438:	10800244 	addi	r2,r2,9
 d04543c:	1007883a 	mov	r3,r2
 d045440:	00bfff84 	movi	r2,-2
 d045444:	1884703a 	and	r2,r3,r2
 d045448:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d04544c:	01000084 	movi	r4,2
 d045450:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 d045454:	e0fffd17 	ldw	r3,-12(fp)
 d045458:	e0bfff17 	ldw	r2,-4(fp)
 d04545c:	1885883a 	add	r2,r3,r2
 d045460:	10800904 	addi	r2,r2,36
 d045464:	1009883a 	mov	r4,r2
 d045468:	d024e0c0 	call	d024e0c <pk_alloc>
 d04546c:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d045470:	01000084 	movi	r4,2
 d045474:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 d045478:	e0bffc17 	ldw	r2,-16(fp)
 d04547c:	1005003a 	cmpeq	r2,r2,zero
 d045480:	1000101e 	bne	r2,zero,d0454c4 <udp_alloc+0xa8>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 d045484:	e0bfff17 	ldw	r2,-4(fp)
 d045488:	1005d0ba 	srai	r2,r2,2
 d04548c:	10800704 	addi	r2,r2,28
 d045490:	e0bffd15 	stw	r2,-12(fp)
      p->nb_prot += len;
 d045494:	e0bffc17 	ldw	r2,-16(fp)
 d045498:	10c00317 	ldw	r3,12(r2)
 d04549c:	e0bffd17 	ldw	r2,-12(fp)
 d0454a0:	1887883a 	add	r3,r3,r2
 d0454a4:	e0bffc17 	ldw	r2,-16(fp)
 d0454a8:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 d0454ac:	e0bffc17 	ldw	r2,-16(fp)
 d0454b0:	10c00417 	ldw	r3,16(r2)
 d0454b4:	e0bffd17 	ldw	r2,-12(fp)
 d0454b8:	1887c83a 	sub	r3,r3,r2
 d0454bc:	e0bffc17 	ldw	r2,-16(fp)
 d0454c0:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 d0454c4:	e0bffc17 	ldw	r2,-16(fp)
}
 d0454c8:	e037883a 	mov	sp,fp
 d0454cc:	dfc00117 	ldw	ra,4(sp)
 d0454d0:	df000017 	ldw	fp,0(sp)
 d0454d4:	dec00204 	addi	sp,sp,8
 d0454d8:	f800283a 	ret

0d0454dc <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 d0454dc:	deffff04 	addi	sp,sp,-4
 d0454e0:	df000015 	stw	fp,0(sp)
 d0454e4:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 d0454e8:	00834174 	movhi	r2,3333
 d0454ec:	10925704 	addi	r2,r2,18780
 d0454f0:	10800017 	ldw	r2,0(r2)
 d0454f4:	10bff704 	addi	r2,r2,-36
#endif
}
 d0454f8:	e037883a 	mov	sp,fp
 d0454fc:	df000017 	ldw	fp,0(sp)
 d045500:	dec00104 	addi	sp,sp,4
 d045504:	f800283a 	ret

0d045508 <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 d045508:	defffd04 	addi	sp,sp,-12
 d04550c:	dfc00215 	stw	ra,8(sp)
 d045510:	df000115 	stw	fp,4(sp)
 d045514:	df000104 	addi	fp,sp,4
 d045518:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d04551c:	01000084 	movi	r4,2
 d045520:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p);
 d045524:	e13fff17 	ldw	r4,-4(fp)
 d045528:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04552c:	01000084 	movi	r4,2
 d045530:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
}
 d045534:	e037883a 	mov	sp,fp
 d045538:	dfc00117 	ldw	ra,4(sp)
 d04553c:	df000017 	ldw	fp,0(sp)
 d045540:	dec00204 	addi	sp,sp,8
 d045544:	f800283a 	ret

0d045548 <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 d045548:	defff704 	addi	sp,sp,-36
 d04554c:	dfc00815 	stw	ra,32(sp)
 d045550:	df000715 	stw	fp,28(sp)
 d045554:	df000704 	addi	fp,sp,28
 d045558:	e13ffe15 	stw	r4,-8(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 d04555c:	e0bffe17 	ldw	r2,-8(fp)
 d045560:	10800617 	ldw	r2,24(r2)
 d045564:	e0bffa15 	stw	r2,-24(fp)
   int rc;
         
   pip = ip_head (p);
 d045568:	e0bffe17 	ldw	r2,-8(fp)
 d04556c:	10800317 	ldw	r2,12(r2)
 d045570:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));
 d045574:	e0bffc17 	ldw	r2,-16(fp)
 d045578:	10800003 	ldbu	r2,0(r2)
 d04557c:	10803fcc 	andi	r2,r2,255
 d045580:	108003cc 	andi	r2,r2,15
 d045584:	1085883a 	add	r2,r2,r2
 d045588:	1085883a 	add	r2,r2,r2
 d04558c:	1007883a 	mov	r3,r2
 d045590:	e0bffc17 	ldw	r2,-16(fp)
 d045594:	1885883a 	add	r2,r3,r2
 d045598:	e0bffd15 	stw	r2,-12(fp)

   switch (igmp->igmp_type) 
 d04559c:	e0bffd17 	ldw	r2,-12(fp)
 d0455a0:	10800003 	ldbu	r2,0(r2)
 d0455a4:	10803fcc 	andi	r2,r2,255
 d0455a8:	e0bfff15 	stw	r2,-4(fp)
 d0455ac:	e0ffff17 	ldw	r3,-4(fp)
 d0455b0:	18800460 	cmpeqi	r2,r3,17
 d0455b4:	1000041e 	bne	r2,zero,d0455c8 <igmpv1_input+0x80>
 d0455b8:	e0ffff17 	ldw	r3,-4(fp)
 d0455bc:	188004a0 	cmpeqi	r2,r3,18
 d0455c0:	1000611e 	bne	r2,zero,d045748 <igmpv1_input+0x200>
 d0455c4:	00008506 	br	d0457dc <igmpv1_input+0x294>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 d0455c8:	008341b4 	movhi	r2,3334
 d0455cc:	10831e04 	addi	r2,r2,3192
 d0455d0:	10800117 	ldw	r2,4(r2)
 d0455d4:	10c00044 	addi	r3,r2,1
 d0455d8:	008341b4 	movhi	r2,3334
 d0455dc:	10831e04 	addi	r2,r2,3192
 d0455e0:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d0455e4:	e0bffa17 	ldw	r2,-24(fp)
 d0455e8:	10802c17 	ldw	r2,176(r2)
 d0455ec:	e0bffb15 	stw	r2,-20(fp)
 d0455f0:	00005006 	br	d045734 <igmpv1_input+0x1ec>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 d0455f4:	e0bffb17 	ldw	r2,-20(fp)
 d0455f8:	10800017 	ldw	r2,0(r2)
 d0455fc:	1005003a 	cmpeq	r2,r2,zero
 d045600:	1000491e 	bne	r2,zero,d045728 <igmpv1_input+0x1e0>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 d045604:	e0bffb17 	ldw	r2,-20(fp)
 d045608:	10c00017 	ldw	r3,0(r2)
 d04560c:	00834174 	movhi	r2,3333
 d045610:	109b2504 	addi	r2,r2,27796
 d045614:	10800017 	ldw	r2,0(r2)
 d045618:	18804326 	beq	r3,r2,d045728 <igmpv1_input+0x1e0>
         {
            if (inm->inm_timer == 0)
 d04561c:	e0bffb17 	ldw	r2,-20(fp)
 d045620:	10800317 	ldw	r2,12(r2)
 d045624:	1004c03a 	cmpne	r2,r2,zero
 d045628:	10003f1e 	bne	r2,zero,d045728 <igmpv1_input+0x1e0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 d04562c:	008341b4 	movhi	r2,3334
 d045630:	10856804 	addi	r2,r2,5536
 d045634:	11000217 	ldw	r4,8(r2)
 d045638:	008341b4 	movhi	r2,3334
 d04563c:	10831a04 	addi	r2,r2,3176
 d045640:	10800017 	ldw	r2,0(r2)
 d045644:	10800a17 	ldw	r2,40(r2)
 d045648:	1004d63a 	srli	r2,r2,24
 d04564c:	10c03fcc 	andi	r3,r2,255
 d045650:	008341b4 	movhi	r2,3334
 d045654:	10831a04 	addi	r2,r2,3176
 d045658:	10800017 	ldw	r2,0(r2)
 d04565c:	10800a17 	ldw	r2,40(r2)
 d045660:	1004d23a 	srli	r2,r2,8
 d045664:	10bfc00c 	andi	r2,r2,65280
 d045668:	1886b03a 	or	r3,r3,r2
 d04566c:	008341b4 	movhi	r2,3334
 d045670:	10831a04 	addi	r2,r2,3176
 d045674:	10800017 	ldw	r2,0(r2)
 d045678:	10800a17 	ldw	r2,40(r2)
 d04567c:	10bfc00c 	andi	r2,r2,65280
 d045680:	1004923a 	slli	r2,r2,8
 d045684:	1886b03a 	or	r3,r3,r2
 d045688:	008341b4 	movhi	r2,3334
 d04568c:	10831a04 	addi	r2,r2,3176
 d045690:	10800017 	ldw	r2,0(r2)
 d045694:	10800a17 	ldw	r2,40(r2)
 d045698:	10803fcc 	andi	r2,r2,255
 d04569c:	1004963a 	slli	r2,r2,24
 d0456a0:	1884b03a 	or	r2,r3,r2
 d0456a4:	2089883a 	add	r4,r4,r2
 d0456a8:	e0bffb17 	ldw	r2,-20(fp)
 d0456ac:	10800017 	ldw	r2,0(r2)
 d0456b0:	1004d63a 	srli	r2,r2,24
 d0456b4:	10c03fcc 	andi	r3,r2,255
 d0456b8:	e0bffb17 	ldw	r2,-20(fp)
 d0456bc:	10800017 	ldw	r2,0(r2)
 d0456c0:	1004d23a 	srli	r2,r2,8
 d0456c4:	10bfc00c 	andi	r2,r2,65280
 d0456c8:	1886b03a 	or	r3,r3,r2
 d0456cc:	e0bffb17 	ldw	r2,-20(fp)
 d0456d0:	10800017 	ldw	r2,0(r2)
 d0456d4:	10bfc00c 	andi	r2,r2,65280
 d0456d8:	1004923a 	slli	r2,r2,8
 d0456dc:	1886b03a 	or	r3,r3,r2
 d0456e0:	e0bffb17 	ldw	r2,-20(fp)
 d0456e4:	10800017 	ldw	r2,0(r2)
 d0456e8:	10803fcc 	andi	r2,r2,255
 d0456ec:	1004963a 	slli	r2,r2,24
 d0456f0:	1884b03a 	or	r2,r3,r2
 d0456f4:	2089883a 	add	r4,r4,r2
 d0456f8:	01400c84 	movi	r5,50
 d0456fc:	d00c9140 	call	d00c914 <__umodsi3>
 d045700:	10c00044 	addi	r3,r2,1
 d045704:	e0bffb17 	ldw	r2,-20(fp)
 d045708:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 d04570c:	00834174 	movhi	r2,3333
 d045710:	109b2304 	addi	r2,r2,27788
 d045714:	10800017 	ldw	r2,0(r2)
 d045718:	10c00044 	addi	r3,r2,1
 d04571c:	00834174 	movhi	r2,3333
 d045720:	109b2304 	addi	r2,r2,27788
 d045724:	10c00015 	stw	r3,0(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d045728:	e0bffb17 	ldw	r2,-20(fp)
 d04572c:	10800517 	ldw	r2,20(r2)
 d045730:	e0bffb15 	stw	r2,-20(fp)
 d045734:	e0bffb17 	ldw	r2,-20(fp)
 d045738:	1004c03a 	cmpne	r2,r2,zero
 d04573c:	103fad1e 	bne	r2,zero,d0455f4 <igmpv1_input+0xac>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 d045740:	e03ff915 	stw	zero,-28(fp)
      break;
 d045744:	00002e06 	br	d045800 <igmpv1_input+0x2b8>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 d045748:	008341b4 	movhi	r2,3334
 d04574c:	10831e04 	addi	r2,r2,3192
 d045750:	10800217 	ldw	r2,8(r2)
 d045754:	10c00044 	addi	r3,r2,1
 d045758:	008341b4 	movhi	r2,3334
 d04575c:	10831e04 	addi	r2,r2,3192
 d045760:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 d045764:	e0bffd17 	ldw	r2,-12(fp)
 d045768:	11000117 	ldw	r4,4(r2)
 d04576c:	e17ffa17 	ldw	r5,-24(fp)
 d045770:	d0439640 	call	d043964 <lookup_mcast>
 d045774:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL) 
 d045778:	e0bffb17 	ldw	r2,-20(fp)
 d04577c:	1005003a 	cmpeq	r2,r2,zero
 d045780:	1000141e 	bne	r2,zero,d0457d4 <igmpv1_input+0x28c>
      {
         if (inm->inm_timer > 0)
 d045784:	e0bffb17 	ldw	r2,-20(fp)
 d045788:	10800317 	ldw	r2,12(r2)
 d04578c:	1005003a 	cmpeq	r2,r2,zero
 d045790:	1000101e 	bne	r2,zero,d0457d4 <igmpv1_input+0x28c>
         {
            inm->inm_timer = 0;
 d045794:	e0bffb17 	ldw	r2,-20(fp)
 d045798:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 d04579c:	00834174 	movhi	r2,3333
 d0457a0:	109b2304 	addi	r2,r2,27788
 d0457a4:	10800017 	ldw	r2,0(r2)
 d0457a8:	10ffffc4 	addi	r3,r2,-1
 d0457ac:	00834174 	movhi	r2,3333
 d0457b0:	109b2304 	addi	r2,r2,27788
 d0457b4:	10c00015 	stw	r3,0(r2)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 d0457b8:	008341b4 	movhi	r2,3334
 d0457bc:	10831e04 	addi	r2,r2,3192
 d0457c0:	10800317 	ldw	r2,12(r2)
 d0457c4:	10c00044 	addi	r3,r2,1
 d0457c8:	008341b4 	movhi	r2,3334
 d0457cc:	10831e04 	addi	r2,r2,3192
 d0457d0:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 d0457d4:	e03ff915 	stw	zero,-28(fp)
      break;
 d0457d8:	00000906 	br	d045800 <igmpv1_input+0x2b8>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 d0457dc:	008341b4 	movhi	r2,3334
 d0457e0:	10831e04 	addi	r2,r2,3192
 d0457e4:	10801017 	ldw	r2,64(r2)
 d0457e8:	10c00044 	addi	r3,r2,1
 d0457ec:	008341b4 	movhi	r2,3334
 d0457f0:	10831e04 	addi	r2,r2,3192
 d0457f4:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 d0457f8:	00bfffc4 	movi	r2,-1
 d0457fc:	e0bff915 	stw	r2,-28(fp)
      break;   
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d045800:	01000084 	movi	r4,2
 d045804:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p);
 d045808:	e13ffe17 	ldw	r4,-8(fp)
 d04580c:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d045810:	01000084 	movi	r4,2
 d045814:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      
   return rc;
 d045818:	e0bff917 	ldw	r2,-28(fp)
}
 d04581c:	e037883a 	mov	sp,fp
 d045820:	dfc00117 	ldw	ra,4(sp)
 d045824:	df000017 	ldw	fp,0(sp)
 d045828:	dec00204 	addi	sp,sp,8
 d04582c:	f800283a 	ret

0d045830 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 d045830:	defff704 	addi	sp,sp,-36
 d045834:	dfc00815 	stw	ra,32(sp)
 d045838:	df000715 	stw	fp,28(sp)
 d04583c:	df000704 	addi	fp,sp,28
 d045840:	e13ffe15 	stw	r4,-8(fp)
   struct ip * pip;
   int igmplen;
   u_char type;
   int rc;

   pip = ip_head (p);    
 d045844:	e0bffe17 	ldw	r2,-8(fp)
 d045848:	10800317 	ldw	r2,12(r2)
 d04584c:	e0bffc15 	stw	r2,-16(fp)
   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */   
   igmplen = p->nb_plen - ip_hlen (pip);
 d045850:	e0bffe17 	ldw	r2,-8(fp)
 d045854:	10c00417 	ldw	r3,16(r2)
 d045858:	e0bffc17 	ldw	r2,-16(fp)
 d04585c:	10800003 	ldbu	r2,0(r2)
 d045860:	10803fcc 	andi	r2,r2,255
 d045864:	108003cc 	andi	r2,r2,15
 d045868:	1085883a 	add	r2,r2,r2
 d04586c:	1085883a 	add	r2,r2,r2
 d045870:	1885c83a 	sub	r2,r3,r2
 d045874:	e0bffb15 	stw	r2,-20(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 d045878:	e0bffc17 	ldw	r2,-16(fp)
 d04587c:	10800003 	ldbu	r2,0(r2)
 d045880:	10803fcc 	andi	r2,r2,255
 d045884:	108003cc 	andi	r2,r2,15
 d045888:	1085883a 	add	r2,r2,r2
 d04588c:	1085883a 	add	r2,r2,r2
 d045890:	1007883a 	mov	r3,r2
 d045894:	e0bffc17 	ldw	r2,-16(fp)
 d045898:	1885883a 	add	r2,r3,r2
 d04589c:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 d0458a0:	e0bffd17 	ldw	r2,-12(fp)
 d0458a4:	10800003 	ldbu	r2,0(r2)
 d0458a8:	e0bffa05 	stb	r2,-24(fp)

   switch (type) 
 d0458ac:	e0bffa03 	ldbu	r2,-24(fp)
 d0458b0:	e0bfff15 	stw	r2,-4(fp)
 d0458b4:	e0ffff17 	ldw	r3,-4(fp)
 d0458b8:	188004a0 	cmpeqi	r2,r3,18
 d0458bc:	1000121e 	bne	r2,zero,d045908 <igmpv2_input+0xd8>
 d0458c0:	e0ffff17 	ldw	r3,-4(fp)
 d0458c4:	188004c8 	cmpgei	r2,r3,19
 d0458c8:	1000041e 	bne	r2,zero,d0458dc <igmpv2_input+0xac>
 d0458cc:	e0ffff17 	ldw	r3,-4(fp)
 d0458d0:	18800460 	cmpeqi	r2,r3,17
 d0458d4:	1000081e 	bne	r2,zero,d0458f8 <igmpv2_input+0xc8>
 d0458d8:	00001806 	br	d04593c <igmpv2_input+0x10c>
 d0458dc:	e0ffff17 	ldw	r3,-4(fp)
 d0458e0:	188005a0 	cmpeqi	r2,r3,22
 d0458e4:	1000081e 	bne	r2,zero,d045908 <igmpv2_input+0xd8>
 d0458e8:	e0ffff17 	ldw	r3,-4(fp)
 d0458ec:	188005e0 	cmpeqi	r2,r3,23
 d0458f0:	1000091e 	bne	r2,zero,d045918 <igmpv2_input+0xe8>
 d0458f4:	00001106 	br	d04593c <igmpv2_input+0x10c>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 d0458f8:	e13ffe17 	ldw	r4,-8(fp)
 d0458fc:	d045adc0 	call	d045adc <igmpv2_process_query>
 d045900:	e0bff915 	stw	r2,-28(fp)
         break;
 d045904:	00001606 	br	d045960 <igmpv2_input+0x130>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 d045908:	e13ffe17 	ldw	r4,-8(fp)
 d04590c:	d0459900 	call	d045990 <igmpv2_process_report>
 d045910:	e0bff915 	stw	r2,-28(fp)
         break;
 d045914:	00001206 	br	d045960 <igmpv2_input+0x130>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 d045918:	008341b4 	movhi	r2,3334
 d04591c:	10831e04 	addi	r2,r2,3192
 d045920:	10800917 	ldw	r2,36(r2)
 d045924:	10c00044 	addi	r3,r2,1
 d045928:	008341b4 	movhi	r2,3334
 d04592c:	10831e04 	addi	r2,r2,3192
 d045930:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 d045934:	e03ff915 	stw	zero,-28(fp)
         break;               
 d045938:	00000906 	br	d045960 <igmpv2_input+0x130>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 d04593c:	008341b4 	movhi	r2,3334
 d045940:	10831e04 	addi	r2,r2,3192
 d045944:	10801517 	ldw	r2,84(r2)
 d045948:	10c00044 	addi	r3,r2,1
 d04594c:	008341b4 	movhi	r2,3334
 d045950:	10831e04 	addi	r2,r2,3192
 d045954:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 d045958:	00bfffc4 	movi	r2,-1
 d04595c:	e0bff915 	stw	r2,-28(fp)
         break;
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d045960:	01000084 	movi	r4,2
 d045964:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   pk_free(p);
 d045968:	e13ffe17 	ldw	r4,-8(fp)
 d04596c:	d0251a00 	call	d0251a0 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d045970:	01000084 	movi	r4,2
 d045974:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
   
   return rc;
 d045978:	e0bff917 	ldw	r2,-28(fp)
}
 d04597c:	e037883a 	mov	sp,fp
 d045980:	dfc00117 	ldw	ra,4(sp)
 d045984:	df000017 	ldw	fp,0(sp)
 d045988:	dec00204 	addi	sp,sp,8
 d04598c:	f800283a 	ret

0d045990 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 d045990:	defff904 	addi	sp,sp,-28
 d045994:	dfc00615 	stw	ra,24(sp)
 d045998:	df000515 	stw	fp,20(sp)
 d04599c:	df000504 	addi	fp,sp,20
 d0459a0:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 d0459a4:	e0bfff17 	ldw	r2,-4(fp)
 d0459a8:	10800617 	ldw	r2,24(r2)
 d0459ac:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 d0459b0:	e0bfff17 	ldw	r2,-4(fp)
 d0459b4:	10800317 	ldw	r2,12(r2)
 d0459b8:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 d0459bc:	e0bffd17 	ldw	r2,-12(fp)
 d0459c0:	10800003 	ldbu	r2,0(r2)
 d0459c4:	10803fcc 	andi	r2,r2,255
 d0459c8:	108003cc 	andi	r2,r2,15
 d0459cc:	1085883a 	add	r2,r2,r2
 d0459d0:	1085883a 	add	r2,r2,r2
 d0459d4:	1007883a 	mov	r3,r2
 d0459d8:	e0bffd17 	ldw	r2,-12(fp)
 d0459dc:	1885883a 	add	r2,r3,r2
 d0459e0:	e0bffe15 	stw	r2,-8(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 d0459e4:	e0bffe17 	ldw	r2,-8(fp)
 d0459e8:	11000117 	ldw	r4,4(r2)
 d0459ec:	e17ffc17 	ldw	r5,-16(fp)
 d0459f0:	d0439640 	call	d043964 <lookup_mcast>
 d0459f4:	e0bffb15 	stw	r2,-20(fp)
   if (inm != NULL) 
 d0459f8:	e0bffb17 	ldw	r2,-20(fp)
 d0459fc:	1005003a 	cmpeq	r2,r2,zero
 d045a00:	1000291e 	bne	r2,zero,d045aa8 <igmpv2_process_report+0x118>
   {
      if (inm->inm_timer != 0)
 d045a04:	e0bffb17 	ldw	r2,-20(fp)
 d045a08:	10800317 	ldw	r2,12(r2)
 d045a0c:	1005003a 	cmpeq	r2,r2,zero
 d045a10:	10001d1e 	bne	r2,zero,d045a88 <igmpv2_process_report+0xf8>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 d045a14:	e0bffc17 	ldw	r2,-16(fp)
 d045a18:	10802d03 	ldbu	r2,180(r2)
 d045a1c:	10803fcc 	andi	r2,r2,255
 d045a20:	1005003a 	cmpeq	r2,r2,zero
 d045a24:	1000051e 	bne	r2,zero,d045a3c <igmpv2_process_report+0xac>
 d045a28:	e0bffe17 	ldw	r2,-8(fp)
 d045a2c:	10800003 	ldbu	r2,0(r2)
 d045a30:	10803fcc 	andi	r2,r2,255
 d045a34:	108005a0 	cmpeqi	r2,r2,22
 d045a38:	1000221e 	bne	r2,zero,d045ac4 <igmpv2_process_report+0x134>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 d045a3c:	e0bffb17 	ldw	r2,-20(fp)
 d045a40:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 d045a44:	00834174 	movhi	r2,3333
 d045a48:	109b2304 	addi	r2,r2,27788
 d045a4c:	10800017 	ldw	r2,0(r2)
 d045a50:	10ffffc4 	addi	r3,r2,-1
 d045a54:	00834174 	movhi	r2,3333
 d045a58:	109b2304 	addi	r2,r2,27788
 d045a5c:	10c00015 	stw	r3,0(r2)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 d045a60:	e0bffb17 	ldw	r2,-20(fp)
 d045a64:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 d045a68:	008341b4 	movhi	r2,3334
 d045a6c:	10831e04 	addi	r2,r2,3192
 d045a70:	10800717 	ldw	r2,28(r2)
 d045a74:	10c00044 	addi	r3,r2,1
 d045a78:	008341b4 	movhi	r2,3334
 d045a7c:	10831e04 	addi	r2,r2,3192
 d045a80:	10c00715 	stw	r3,28(r2)
 d045a84:	00000f06 	br	d045ac4 <igmpv2_process_report+0x134>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 d045a88:	008341b4 	movhi	r2,3334
 d045a8c:	10831e04 	addi	r2,r2,3192
 d045a90:	10800817 	ldw	r2,32(r2)
 d045a94:	10c00044 	addi	r3,r2,1
 d045a98:	008341b4 	movhi	r2,3334
 d045a9c:	10831e04 	addi	r2,r2,3192
 d045aa0:	10c00815 	stw	r3,32(r2)
 d045aa4:	00000706 	br	d045ac4 <igmpv2_process_report+0x134>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 d045aa8:	008341b4 	movhi	r2,3334
 d045aac:	10831e04 	addi	r2,r2,3192
 d045ab0:	10801317 	ldw	r2,76(r2)
 d045ab4:	10c00044 	addi	r3,r2,1
 d045ab8:	008341b4 	movhi	r2,3334
 d045abc:	10831e04 	addi	r2,r2,3192
 d045ac0:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 d045ac4:	0005883a 	mov	r2,zero
}
 d045ac8:	e037883a 	mov	sp,fp
 d045acc:	dfc00117 	ldw	ra,4(sp)
 d045ad0:	df000017 	ldw	fp,0(sp)
 d045ad4:	dec00204 	addi	sp,sp,8
 d045ad8:	f800283a 	ret

0d045adc <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 d045adc:	defff704 	addi	sp,sp,-36
 d045ae0:	dfc00815 	stw	ra,32(sp)
 d045ae4:	df000715 	stw	fp,28(sp)
 d045ae8:	df000704 	addi	fp,sp,28
 d045aec:	e13fff15 	stw	r4,-4(fp)
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;
   ip_addr mcgrp_addr;

   netp = p->net;
 d045af0:	e0bfff17 	ldw	r2,-4(fp)
 d045af4:	10800617 	ldw	r2,24(r2)
 d045af8:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 d045afc:	e0bfff17 	ldw	r2,-4(fp)
 d045b00:	10800317 	ldw	r2,12(r2)
 d045b04:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 d045b08:	e0bffd17 	ldw	r2,-12(fp)
 d045b0c:	10800003 	ldbu	r2,0(r2)
 d045b10:	10803fcc 	andi	r2,r2,255
 d045b14:	108003cc 	andi	r2,r2,15
 d045b18:	1085883a 	add	r2,r2,r2
 d045b1c:	1085883a 	add	r2,r2,r2
 d045b20:	1007883a 	mov	r3,r2
 d045b24:	e0bffd17 	ldw	r2,-12(fp)
 d045b28:	1885883a 	add	r2,r3,r2
 d045b2c:	e0bffe15 	stw	r2,-8(fp)
   mcgrp_addr = ntohl(igmp->igmp_group);
 d045b30:	e0bffe17 	ldw	r2,-8(fp)
 d045b34:	10800117 	ldw	r2,4(r2)
 d045b38:	1004d63a 	srli	r2,r2,24
 d045b3c:	10c03fcc 	andi	r3,r2,255
 d045b40:	e0bffe17 	ldw	r2,-8(fp)
 d045b44:	10800117 	ldw	r2,4(r2)
 d045b48:	1004d23a 	srli	r2,r2,8
 d045b4c:	10bfc00c 	andi	r2,r2,65280
 d045b50:	1886b03a 	or	r3,r3,r2
 d045b54:	e0bffe17 	ldw	r2,-8(fp)
 d045b58:	10800117 	ldw	r2,4(r2)
 d045b5c:	10bfc00c 	andi	r2,r2,65280
 d045b60:	1004923a 	slli	r2,r2,8
 d045b64:	1886b03a 	or	r3,r3,r2
 d045b68:	e0bffe17 	ldw	r2,-8(fp)
 d045b6c:	10800117 	ldw	r2,4(r2)
 d045b70:	10803fcc 	andi	r2,r2,255
 d045b74:	1004963a 	slli	r2,r2,24
 d045b78:	1884b03a 	or	r2,r3,r2
 d045b7c:	e0bff915 	stw	r2,-28(fp)

   if (igmp->igmp_code == 0)
 d045b80:	e0bffe17 	ldw	r2,-8(fp)
 d045b84:	10800043 	ldbu	r2,1(r2)
 d045b88:	10803fcc 	andi	r2,r2,255
 d045b8c:	1004c03a 	cmpne	r2,r2,zero
 d045b90:	1000141e 	bne	r2,zero,d045be4 <igmpv2_process_query+0x108>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 d045b94:	e0fffc17 	ldw	r3,-16(fp)
 d045b98:	00800044 	movi	r2,1
 d045b9c:	18802d05 	stb	r2,180(r3)
      netp->igmpv1_query_rcvd_time = cticks;      
 d045ba0:	00834174 	movhi	r2,3333
 d045ba4:	109b4504 	addi	r2,r2,27924
 d045ba8:	10c00017 	ldw	r3,0(r2)
 d045bac:	e0bffc17 	ldw	r2,-16(fp)
 d045bb0:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 d045bb4:	008341b4 	movhi	r2,3334
 d045bb8:	10831e04 	addi	r2,r2,3192
 d045bbc:	10800417 	ldw	r2,16(r2)
 d045bc0:	10c00044 	addi	r3,r2,1
 d045bc4:	008341b4 	movhi	r2,3334
 d045bc8:	10831e04 	addi	r2,r2,3192
 d045bcc:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 d045bd0:	00800c84 	movi	r2,50
 d045bd4:	e0bffb8d 	sth	r2,-18(fp)
      process_all = IGMP_TRUE;
 d045bd8:	00800044 	movi	r2,1
 d045bdc:	e0bffb05 	stb	r2,-20(fp)
 d045be0:	00001d06 	br	d045c58 <igmpv2_process_query+0x17c>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 d045be4:	e0bffe17 	ldw	r2,-8(fp)
 d045be8:	10800117 	ldw	r2,4(r2)
 d045bec:	1004c03a 	cmpne	r2,r2,zero
 d045bf0:	10000a1e 	bne	r2,zero,d045c1c <igmpv2_process_query+0x140>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 d045bf4:	008341b4 	movhi	r2,3334
 d045bf8:	10831e04 	addi	r2,r2,3192
 d045bfc:	10800517 	ldw	r2,20(r2)
 d045c00:	10c00044 	addi	r3,r2,1
 d045c04:	008341b4 	movhi	r2,3334
 d045c08:	10831e04 	addi	r2,r2,3192
 d045c0c:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 d045c10:	00800044 	movi	r2,1
 d045c14:	e0bffb05 	stb	r2,-20(fp)
 d045c18:	00000806 	br	d045c3c <igmpv2_process_query+0x160>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 d045c1c:	008341b4 	movhi	r2,3334
 d045c20:	10831e04 	addi	r2,r2,3192
 d045c24:	10800617 	ldw	r2,24(r2)
 d045c28:	10c00044 	addi	r3,r2,1
 d045c2c:	008341b4 	movhi	r2,3334
 d045c30:	10831e04 	addi	r2,r2,3192
 d045c34:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 d045c38:	e03ffb05 	stb	zero,-20(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 d045c3c:	e0bffe17 	ldw	r2,-8(fp)
 d045c40:	10800043 	ldbu	r2,1(r2)
 d045c44:	10c03fcc 	andi	r3,r2,255
 d045c48:	1804d7fa 	srli	r2,r3,31
 d045c4c:	10c5883a 	add	r2,r2,r3
 d045c50:	1005d07a 	srai	r2,r2,1
 d045c54:	e0bffb8d 	sth	r2,-18(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 d045c58:	e0bffb03 	ldbu	r2,-20(fp)
 d045c5c:	1005003a 	cmpeq	r2,r2,zero
 d045c60:	1000181e 	bne	r2,zero,d045cc4 <igmpv2_process_query+0x1e8>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d045c64:	e0bffc17 	ldw	r2,-16(fp)
 d045c68:	10802c17 	ldw	r2,176(r2)
 d045c6c:	e0bffa15 	stw	r2,-24(fp)
 d045c70:	00001006 	br	d045cb4 <igmpv2_process_query+0x1d8>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 d045c74:	e0bffa17 	ldw	r2,-24(fp)
 d045c78:	10800017 	ldw	r2,0(r2)
 d045c7c:	1005003a 	cmpeq	r2,r2,zero
 d045c80:	1000091e 	bne	r2,zero,d045ca8 <igmpv2_process_query+0x1cc>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 d045c84:	e0bffa17 	ldw	r2,-24(fp)
 d045c88:	10c00017 	ldw	r3,0(r2)
 d045c8c:	00834174 	movhi	r2,3333
 d045c90:	109b2504 	addi	r2,r2,27796
 d045c94:	10800017 	ldw	r2,0(r2)
 d045c98:	18800326 	beq	r3,r2,d045ca8 <igmpv2_process_query+0x1cc>
            igmpv2_chk_set_timer (inm, max_resp_time);
 d045c9c:	e17ffb8b 	ldhu	r5,-18(fp)
 d045ca0:	e13ffa17 	ldw	r4,-24(fp)
 d045ca4:	d045d280 	call	d045d28 <igmpv2_chk_set_timer>
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d045ca8:	e0bffa17 	ldw	r2,-24(fp)
 d045cac:	10800517 	ldw	r2,20(r2)
 d045cb0:	e0bffa15 	stw	r2,-24(fp)
 d045cb4:	e0bffa17 	ldw	r2,-24(fp)
 d045cb8:	1004c03a 	cmpne	r2,r2,zero
 d045cbc:	103fed1e 	bne	r2,zero,d045c74 <igmpv2_process_query+0x198>
 d045cc0:	00001306 	br	d045d10 <igmpv2_process_query+0x234>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 d045cc4:	e0bffe17 	ldw	r2,-8(fp)
 d045cc8:	11000117 	ldw	r4,4(r2)
 d045ccc:	e17ffc17 	ldw	r5,-16(fp)
 d045cd0:	d0439640 	call	d043964 <lookup_mcast>
 d045cd4:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL)
 d045cd8:	e0bffa17 	ldw	r2,-24(fp)
 d045cdc:	1005003a 	cmpeq	r2,r2,zero
 d045ce0:	1000041e 	bne	r2,zero,d045cf4 <igmpv2_process_query+0x218>
         igmpv2_chk_set_timer (inm, max_resp_time);
 d045ce4:	e17ffb8b 	ldhu	r5,-18(fp)
 d045ce8:	e13ffa17 	ldw	r4,-24(fp)
 d045cec:	d045d280 	call	d045d28 <igmpv2_chk_set_timer>
 d045cf0:	00000706 	br	d045d10 <igmpv2_process_query+0x234>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 d045cf4:	008341b4 	movhi	r2,3334
 d045cf8:	10831e04 	addi	r2,r2,3192
 d045cfc:	10801217 	ldw	r2,72(r2)
 d045d00:	10c00044 	addi	r3,r2,1
 d045d04:	008341b4 	movhi	r2,3334
 d045d08:	10831e04 	addi	r2,r2,3192
 d045d0c:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 d045d10:	0005883a 	mov	r2,zero
}
 d045d14:	e037883a 	mov	sp,fp
 d045d18:	dfc00117 	ldw	ra,4(sp)
 d045d1c:	df000017 	ldw	fp,0(sp)
 d045d20:	dec00204 	addi	sp,sp,8
 d045d24:	f800283a 	ret

0d045d28 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 d045d28:	defffc04 	addi	sp,sp,-16
 d045d2c:	dfc00315 	stw	ra,12(sp)
 d045d30:	df000215 	stw	fp,8(sp)
 d045d34:	df000204 	addi	fp,sp,8
 d045d38:	e13ffe15 	stw	r4,-8(fp)
 d045d3c:	e17fff0d 	sth	r5,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 d045d40:	e0bffe17 	ldw	r2,-8(fp)
 d045d44:	10c00317 	ldw	r3,12(r2)
 d045d48:	e0bfff0b 	ldhu	r2,-4(fp)
 d045d4c:	10c00436 	bltu	r2,r3,d045d60 <igmpv2_chk_set_timer+0x38>
 d045d50:	e0bffe17 	ldw	r2,-8(fp)
 d045d54:	10800317 	ldw	r2,12(r2)
 d045d58:	1004c03a 	cmpne	r2,r2,zero
 d045d5c:	1000431e 	bne	r2,zero,d045e6c <igmpv2_chk_set_timer+0x144>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 d045d60:	e0bffe17 	ldw	r2,-8(fp)
 d045d64:	10800317 	ldw	r2,12(r2)
 d045d68:	1004c03a 	cmpne	r2,r2,zero
 d045d6c:	1000071e 	bne	r2,zero,d045d8c <igmpv2_chk_set_timer+0x64>
 d045d70:	00834174 	movhi	r2,3333
 d045d74:	109b2304 	addi	r2,r2,27788
 d045d78:	10800017 	ldw	r2,0(r2)
 d045d7c:	10c00044 	addi	r3,r2,1
 d045d80:	00834174 	movhi	r2,3333
 d045d84:	109b2304 	addi	r2,r2,27788
 d045d88:	10c00015 	stw	r3,0(r2)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 d045d8c:	008341b4 	movhi	r2,3334
 d045d90:	10856804 	addi	r2,r2,5536
 d045d94:	11000217 	ldw	r4,8(r2)
 d045d98:	008341b4 	movhi	r2,3334
 d045d9c:	10831a04 	addi	r2,r2,3176
 d045da0:	10800017 	ldw	r2,0(r2)
 d045da4:	10800a17 	ldw	r2,40(r2)
 d045da8:	1004d63a 	srli	r2,r2,24
 d045dac:	10c03fcc 	andi	r3,r2,255
 d045db0:	008341b4 	movhi	r2,3334
 d045db4:	10831a04 	addi	r2,r2,3176
 d045db8:	10800017 	ldw	r2,0(r2)
 d045dbc:	10800a17 	ldw	r2,40(r2)
 d045dc0:	1004d23a 	srli	r2,r2,8
 d045dc4:	10bfc00c 	andi	r2,r2,65280
 d045dc8:	1886b03a 	or	r3,r3,r2
 d045dcc:	008341b4 	movhi	r2,3334
 d045dd0:	10831a04 	addi	r2,r2,3176
 d045dd4:	10800017 	ldw	r2,0(r2)
 d045dd8:	10800a17 	ldw	r2,40(r2)
 d045ddc:	10bfc00c 	andi	r2,r2,65280
 d045de0:	1004923a 	slli	r2,r2,8
 d045de4:	1886b03a 	or	r3,r3,r2
 d045de8:	008341b4 	movhi	r2,3334
 d045dec:	10831a04 	addi	r2,r2,3176
 d045df0:	10800017 	ldw	r2,0(r2)
 d045df4:	10800a17 	ldw	r2,40(r2)
 d045df8:	10803fcc 	andi	r2,r2,255
 d045dfc:	1004963a 	slli	r2,r2,24
 d045e00:	1884b03a 	or	r2,r3,r2
 d045e04:	2089883a 	add	r4,r4,r2
 d045e08:	e0bffe17 	ldw	r2,-8(fp)
 d045e0c:	10800017 	ldw	r2,0(r2)
 d045e10:	1004d63a 	srli	r2,r2,24
 d045e14:	10c03fcc 	andi	r3,r2,255
 d045e18:	e0bffe17 	ldw	r2,-8(fp)
 d045e1c:	10800017 	ldw	r2,0(r2)
 d045e20:	1004d23a 	srli	r2,r2,8
 d045e24:	10bfc00c 	andi	r2,r2,65280
 d045e28:	1886b03a 	or	r3,r3,r2
 d045e2c:	e0bffe17 	ldw	r2,-8(fp)
 d045e30:	10800017 	ldw	r2,0(r2)
 d045e34:	10bfc00c 	andi	r2,r2,65280
 d045e38:	1004923a 	slli	r2,r2,8
 d045e3c:	1886b03a 	or	r3,r3,r2
 d045e40:	e0bffe17 	ldw	r2,-8(fp)
 d045e44:	10800017 	ldw	r2,0(r2)
 d045e48:	10803fcc 	andi	r2,r2,255
 d045e4c:	1004963a 	slli	r2,r2,24
 d045e50:	1884b03a 	or	r2,r3,r2
 d045e54:	2089883a 	add	r4,r4,r2
 d045e58:	e17fff0b 	ldhu	r5,-4(fp)
 d045e5c:	d00c9140 	call	d00c914 <__umodsi3>
 d045e60:	10c00044 	addi	r3,r2,1
 d045e64:	e0bffe17 	ldw	r2,-8(fp)
 d045e68:	10c00315 	stw	r3,12(r2)
   }

   return;
}
 d045e6c:	e037883a 	mov	sp,fp
 d045e70:	dfc00117 	ldw	ra,4(sp)
 d045e74:	df000017 	ldw	fp,0(sp)
 d045e78:	dec00204 	addi	sp,sp,8
 d045e7c:	f800283a 	ret

0d045e80 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 d045e80:	defff904 	addi	sp,sp,-28
 d045e84:	df000615 	stw	fp,24(sp)
 d045e88:	df000604 	addi	fp,sp,24
 d045e8c:	e13ffd15 	stw	r4,-12(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 d045e90:	e0bffd17 	ldw	r2,-12(fp)
 d045e94:	10800003 	ldbu	r2,0(r2)
 d045e98:	108003cc 	andi	r2,r2,15
 d045e9c:	1085883a 	add	r2,r2,r2
 d045ea0:	1085883a 	add	r2,r2,r2
 d045ea4:	10bffb04 	addi	r2,r2,-20
 d045ea8:	e0bffa85 	stb	r2,-22(fp)

   if (total_optlen > 0)
 d045eac:	e0bffa83 	ldbu	r2,-22(fp)
 d045eb0:	1005003a 	cmpeq	r2,r2,zero
 d045eb4:	1000481e 	bne	r2,zero,d045fd8 <igmpv2_chk4_rtr_alert_opt+0x158>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 d045eb8:	e0bffd17 	ldw	r2,-12(fp)
 d045ebc:	10800504 	addi	r2,r2,20
 d045ec0:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 d045ec4:	00004106 	br	d045fcc <igmpv2_chk4_rtr_alert_opt+0x14c>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 d045ec8:	e0bffc17 	ldw	r2,-16(fp)
 d045ecc:	10800003 	ldbu	r2,0(r2)
 d045ed0:	108007cc 	andi	r2,r2,31
 d045ed4:	e0bffa05 	stb	r2,-24(fp)
         switch (optval)
 d045ed8:	e0bffa03 	ldbu	r2,-24(fp)
 d045edc:	e0bfff15 	stw	r2,-4(fp)
 d045ee0:	e0ffff17 	ldw	r3,-4(fp)
 d045ee4:	18800060 	cmpeqi	r2,r3,1
 d045ee8:	10000b1e 	bne	r2,zero,d045f18 <igmpv2_chk4_rtr_alert_opt+0x98>
 d045eec:	e0ffff17 	ldw	r3,-4(fp)
 d045ef0:	18800520 	cmpeqi	r2,r3,20
 d045ef4:	10000b1e 	bne	r2,zero,d045f24 <igmpv2_chk4_rtr_alert_opt+0xa4>
 d045ef8:	e0ffff17 	ldw	r3,-4(fp)
 d045efc:	1805003a 	cmpeq	r2,r3,zero
 d045f00:	1000011e 	bne	r2,zero,d045f08 <igmpv2_chk4_rtr_alert_opt+0x88>
 d045f04:	00002306 	br	d045f94 <igmpv2_chk4_rtr_alert_opt+0x114>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 d045f08:	00800044 	movi	r2,1
 d045f0c:	e0bffa45 	stb	r2,-23(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 d045f10:	e03ffe15 	stw	zero,-8(fp)
 d045f14:	00003106 	br	d045fdc <igmpv2_chk4_rtr_alert_opt+0x15c>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 d045f18:	00800044 	movi	r2,1
 d045f1c:	e0bffa45 	stb	r2,-23(fp)
               break;
 d045f20:	00002106 	br	d045fa8 <igmpv2_chk4_rtr_alert_opt+0x128>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 d045f24:	e0bffc17 	ldw	r2,-16(fp)
 d045f28:	e0bffb15 	stw	r2,-20(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 d045f2c:	e0bffb17 	ldw	r2,-20(fp)
 d045f30:	10800017 	ldw	r2,0(r2)
 d045f34:	1004d63a 	srli	r2,r2,24
 d045f38:	10c03fcc 	andi	r3,r2,255
 d045f3c:	e0bffb17 	ldw	r2,-20(fp)
 d045f40:	10800017 	ldw	r2,0(r2)
 d045f44:	1004d23a 	srli	r2,r2,8
 d045f48:	10bfc00c 	andi	r2,r2,65280
 d045f4c:	1886b03a 	or	r3,r3,r2
 d045f50:	e0bffb17 	ldw	r2,-20(fp)
 d045f54:	10800017 	ldw	r2,0(r2)
 d045f58:	10bfc00c 	andi	r2,r2,65280
 d045f5c:	1004923a 	slli	r2,r2,8
 d045f60:	1886b03a 	or	r3,r3,r2
 d045f64:	e0bffb17 	ldw	r2,-20(fp)
 d045f68:	10800017 	ldw	r2,0(r2)
 d045f6c:	10803fcc 	andi	r2,r2,255
 d045f70:	1004963a 	slli	r2,r2,24
 d045f74:	1886b03a 	or	r3,r3,r2
 d045f78:	00a50134 	movhi	r2,37892
 d045f7c:	1880031e 	bne	r3,r2,d045f8c <igmpv2_chk4_rtr_alert_opt+0x10c>
                  /* found the option, return success */
                  return IGMP_TRUE;
 d045f80:	00800044 	movi	r2,1
 d045f84:	e0bffe15 	stw	r2,-8(fp)
 d045f88:	00001406 	br	d045fdc <igmpv2_chk4_rtr_alert_opt+0x15c>
               else return IGMP_FALSE;
 d045f8c:	e03ffe15 	stw	zero,-8(fp)
 d045f90:	00001206 	br	d045fdc <igmpv2_chk4_rtr_alert_opt+0x15c>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 d045f94:	e0bffc17 	ldw	r2,-16(fp)
 d045f98:	10800044 	addi	r2,r2,1
 d045f9c:	10800003 	ldbu	r2,0(r2)
 d045fa0:	10800084 	addi	r2,r2,2
 d045fa4:	e0bffa45 	stb	r2,-23(fp)
               break;
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 d045fa8:	e0bffa43 	ldbu	r2,-23(fp)
 d045fac:	1007883a 	mov	r3,r2
 d045fb0:	e0bffc17 	ldw	r2,-16(fp)
 d045fb4:	10c5883a 	add	r2,r2,r3
 d045fb8:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 d045fbc:	e0fffa83 	ldbu	r3,-22(fp)
 d045fc0:	e0bffa43 	ldbu	r2,-23(fp)
 d045fc4:	1885c83a 	sub	r2,r3,r2
 d045fc8:	e0bffa85 	stb	r2,-22(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 d045fcc:	e0bffa83 	ldbu	r2,-22(fp)
 d045fd0:	1004c03a 	cmpne	r2,r2,zero
 d045fd4:	103fbc1e 	bne	r2,zero,d045ec8 <igmpv2_chk4_rtr_alert_opt+0x48>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 d045fd8:	e03ffe15 	stw	zero,-8(fp)
 d045fdc:	e0bffe17 	ldw	r2,-8(fp)
}
 d045fe0:	e037883a 	mov	sp,fp
 d045fe4:	df000017 	ldw	fp,0(sp)
 d045fe8:	dec00104 	addi	sp,sp,4
 d045fec:	f800283a 	ret

0d045ff0 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 d045ff0:	defffc04 	addi	sp,sp,-16
 d045ff4:	df000315 	stw	fp,12(sp)
 d045ff8:	df000304 	addi	fp,sp,12
 d045ffc:	e13ffe15 	stw	r4,-8(fp)
 d046000:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 d046004:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 d046008:	e0bffd0b 	ldhu	r2,-12(fp)
 d04600c:	00c341b4 	movhi	r3,3334
 d046010:	18c31a04 	addi	r3,r3,3176
 d046014:	1085883a 	add	r2,r2,r2
 d046018:	1085883a 	add	r2,r2,r2
 d04601c:	10c5883a 	add	r2,r2,r3
 d046020:	10c00017 	ldw	r3,0(r2)
 d046024:	e0bfff17 	ldw	r2,-4(fp)
 d046028:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 d04602c:	e0bffe17 	ldw	r2,-8(fp)
 d046030:	1004c03a 	cmpne	r2,r2,zero
 d046034:	1000331e 	bne	r2,zero,d046104 <IPADDR_TO_NETP+0x114>
   {
      for (idx = 0; idx < ifNumber; idx++)
 d046038:	e03ffd0d 	sth	zero,-12(fp)
 d04603c:	00001706 	br	d04609c <IPADDR_TO_NETP+0xac>
      {
         if (nets[idx]->n_mcastlist)
 d046040:	e0bffd0b 	ldhu	r2,-12(fp)
 d046044:	00c341b4 	movhi	r3,3334
 d046048:	18c31a04 	addi	r3,r3,3176
 d04604c:	1085883a 	add	r2,r2,r2
 d046050:	1085883a 	add	r2,r2,r2
 d046054:	10c5883a 	add	r2,r2,r3
 d046058:	10800017 	ldw	r2,0(r2)
 d04605c:	10802b17 	ldw	r2,172(r2)
 d046060:	1005003a 	cmpeq	r2,r2,zero
 d046064:	10000a1e 	bne	r2,zero,d046090 <IPADDR_TO_NETP+0xa0>
         {
            *netp = nets[idx];
 d046068:	e0bffd0b 	ldhu	r2,-12(fp)
 d04606c:	00c341b4 	movhi	r3,3334
 d046070:	18c31a04 	addi	r3,r3,3176
 d046074:	1085883a 	add	r2,r2,r2
 d046078:	1085883a 	add	r2,r2,r2
 d04607c:	10c5883a 	add	r2,r2,r3
 d046080:	10c00017 	ldw	r3,0(r2)
 d046084:	e0bfff17 	ldw	r2,-4(fp)
 d046088:	10c00015 	stw	r3,0(r2)
            break;
 d04608c:	00002606 	br	d046128 <IPADDR_TO_NETP+0x138>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 d046090:	e0bffd0b 	ldhu	r2,-12(fp)
 d046094:	10800044 	addi	r2,r2,1
 d046098:	e0bffd0d 	sth	r2,-12(fp)
 d04609c:	e0bffd0b 	ldhu	r2,-12(fp)
 d0460a0:	00c34174 	movhi	r3,3333
 d0460a4:	18db2104 	addi	r3,r3,27780
 d0460a8:	18c00017 	ldw	r3,0(r3)
 d0460ac:	10ffe436 	bltu	r2,r3,d046040 <IPADDR_TO_NETP+0x50>
 d0460b0:	00001d06 	br	d046128 <IPADDR_TO_NETP+0x138>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 d0460b4:	e0bffd0b 	ldhu	r2,-12(fp)
 d0460b8:	10800044 	addi	r2,r2,1
 d0460bc:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 d0460c0:	e0fffd0b 	ldhu	r3,-12(fp)
 d0460c4:	00834174 	movhi	r2,3333
 d0460c8:	109b2104 	addi	r2,r2,27780
 d0460cc:	10800017 	ldw	r2,0(r2)
 d0460d0:	18800336 	bltu	r3,r2,d0460e0 <IPADDR_TO_NETP+0xf0>
         {
            *netp = NULL;
 d0460d4:	e0bfff17 	ldw	r2,-4(fp)
 d0460d8:	10000015 	stw	zero,0(r2)
            break;
 d0460dc:	00001206 	br	d046128 <IPADDR_TO_NETP+0x138>
         }
         else
            *netp = nets[idx];
 d0460e0:	e0bffd0b 	ldhu	r2,-12(fp)
 d0460e4:	00c341b4 	movhi	r3,3334
 d0460e8:	18c31a04 	addi	r3,r3,3176
 d0460ec:	1085883a 	add	r2,r2,r2
 d0460f0:	1085883a 	add	r2,r2,r2
 d0460f4:	10c5883a 	add	r2,r2,r3
 d0460f8:	10c00017 	ldw	r3,0(r2)
 d0460fc:	e0bfff17 	ldw	r2,-4(fp)
 d046100:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 d046104:	e0bfff17 	ldw	r2,-4(fp)
 d046108:	10800017 	ldw	r2,0(r2)
 d04610c:	1005003a 	cmpeq	r2,r2,zero
 d046110:	1000051e 	bne	r2,zero,d046128 <IPADDR_TO_NETP+0x138>
 d046114:	e0bfff17 	ldw	r2,-4(fp)
 d046118:	10800017 	ldw	r2,0(r2)
 d04611c:	10c00a17 	ldw	r3,40(r2)
 d046120:	e0bffe17 	ldw	r2,-8(fp)
 d046124:	18bfe31e 	bne	r3,r2,d0460b4 <IPADDR_TO_NETP+0xc4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 d046128:	e037883a 	mov	sp,fp
 d04612c:	df000017 	ldw	fp,0(sp)
 d046130:	dec00104 	addi	sp,sp,4
 d046134:	f800283a 	ret

0d046138 <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 d046138:	defff104 	addi	sp,sp,-60
 d04613c:	dfc00e15 	stw	ra,56(sp)
 d046140:	df000d15 	stw	fp,52(sp)
 d046144:	dc000c15 	stw	r16,48(sp)
 d046148:	df000c04 	addi	fp,sp,48
 d04614c:	e13ffb15 	stw	r4,-20(fp)
 d046150:	e17ffc15 	stw	r5,-16(fp)
 d046154:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 d046158:	e03ff915 	stw	zero,-28(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 d04615c:	e03ffa15 	stw	zero,-24(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 d046160:	e0bffc17 	ldw	r2,-16(fp)
 d046164:	10800317 	ldw	r2,12(r2)
 d046168:	e0bff615 	stw	r2,-40(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 d04616c:	e0bffc17 	ldw	r2,-16(fp)
 d046170:	10800304 	addi	r2,r2,12
 d046174:	e0bff515 	stw	r2,-44(fp)
   ip_addr addr;


   if (imo == NULL) 
 d046178:	e0bff617 	ldw	r2,-40(fp)
 d04617c:	1004c03a 	cmpne	r2,r2,zero
 d046180:	1000161e 	bne	r2,zero,d0461dc <ip_setmoptions+0xa4>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 d046184:	01001604 	movi	r4,88
 d046188:	d0264b80 	call	d0264b8 <npalloc>
 d04618c:	e0bff615 	stw	r2,-40(fp)

      if (imo == NULL)
 d046190:	e0bff617 	ldw	r2,-40(fp)
 d046194:	1004c03a 	cmpne	r2,r2,zero
 d046198:	1000031e 	bne	r2,zero,d0461a8 <ip_setmoptions+0x70>
         return (ENOBUFS);
 d04619c:	00801a44 	movi	r2,105
 d0461a0:	e0bffe15 	stw	r2,-8(fp)
 d0461a4:	00015906 	br	d04670c <ip_setmoptions+0x5d4>
      *imop = imo;
 d0461a8:	e0fff517 	ldw	r3,-44(fp)
 d0461ac:	e0bff617 	ldw	r2,-40(fp)
 d0461b0:	18800015 	stw	r2,0(r3)
      imo->imo_multicast_netp = NULL;
 d0461b4:	e0bff617 	ldw	r2,-40(fp)
 d0461b8:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 d0461bc:	e0fff617 	ldw	r3,-40(fp)
 d0461c0:	00800044 	movi	r2,1
 d0461c4:	18800105 	stb	r2,4(r3)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 d0461c8:	e0fff617 	ldw	r3,-40(fp)
 d0461cc:	00800044 	movi	r2,1
 d0461d0:	18800145 	stb	r2,5(r3)
      imo->imo_num_memberships = 0;
 d0461d4:	e0bff617 	ldw	r2,-40(fp)
 d0461d8:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 d0461dc:	e0bffb17 	ldw	r2,-20(fp)
 d0461e0:	10bffdc4 	addi	r2,r2,-9
 d0461e4:	e0bfff15 	stw	r2,-4(fp)
 d0461e8:	e0ffff17 	ldw	r3,-4(fp)
 d0461ec:	18800168 	cmpgeui	r2,r3,5
 d0461f0:	10012a1e 	bne	r2,zero,d04669c <ip_setmoptions+0x564>
 d0461f4:	e13fff17 	ldw	r4,-4(fp)
 d0461f8:	e13fff17 	ldw	r4,-4(fp)
 d0461fc:	2105883a 	add	r2,r4,r4
 d046200:	1087883a 	add	r3,r2,r2
 d046204:	00834134 	movhi	r2,3332
 d046208:	10988604 	addi	r2,r2,25112
 d04620c:	1885883a 	add	r2,r3,r2
 d046210:	10800017 	ldw	r2,0(r2)
 d046214:	1000683a 	jmp	r2
 d046218:	0d04622c 	andhi	r20,at,4488
 d04621c:	0d0462a0 	cmpeqi	r20,at,4490
 d046220:	0d0462b4 	orhi	r20,at,4490
 d046224:	0d0462e8 	cmpgeui	r20,at,4491
 d046228:	0d0464b8 	rdprs	r20,at,4498

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 d04622c:	e0bffd17 	ldw	r2,-12(fp)
 d046230:	10800017 	ldw	r2,0(r2)
 d046234:	e0bff415 	stw	r2,-48(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 d046238:	e0bff417 	ldw	r2,-48(fp)
 d04623c:	1004c03a 	cmpne	r2,r2,zero
 d046240:	1000031e 	bne	r2,zero,d046250 <ip_setmoptions+0x118>
      {
         imo->imo_multicast_netp = NULL;
 d046244:	e0bff617 	ldw	r2,-40(fp)
 d046248:	10000015 	stw	zero,0(r2)
         break;
 d04624c:	00011506 	br	d0466a4 <ip_setmoptions+0x56c>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 d046250:	e17ffa04 	addi	r5,fp,-24
 d046254:	e13ff417 	ldw	r4,-48(fp)
 d046258:	d045ff00 	call	d045ff0 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 d04625c:	e0bffa17 	ldw	r2,-24(fp)
 d046260:	1005003a 	cmpeq	r2,r2,zero
 d046264:	1000041e 	bne	r2,zero,d046278 <ip_setmoptions+0x140>
 d046268:	e0bffa17 	ldw	r2,-24(fp)
 d04626c:	10802b17 	ldw	r2,172(r2)
 d046270:	1004c03a 	cmpne	r2,r2,zero
 d046274:	1000031e 	bne	r2,zero,d046284 <ip_setmoptions+0x14c>
      {
         error = EADDRNOTAVAIL;
 d046278:	00801f44 	movi	r2,125
 d04627c:	e0bff915 	stw	r2,-28(fp)
         break;
 d046280:	00010806 	br	d0466a4 <ip_setmoptions+0x56c>
      }
      if (addr != AADDR) 
 d046284:	e0bff417 	ldw	r2,-48(fp)
 d046288:	1005003a 	cmpeq	r2,r2,zero
 d04628c:	1001051e 	bne	r2,zero,d0466a4 <ip_setmoptions+0x56c>
         imo->imo_multicast_netp = netp;
 d046290:	e0fffa17 	ldw	r3,-24(fp)
 d046294:	e0bff617 	ldw	r2,-40(fp)
 d046298:	10c00015 	stw	r3,0(r2)
      break;
 d04629c:	00010106 	br	d0466a4 <ip_setmoptions+0x56c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 d0462a0:	e0bffd17 	ldw	r2,-12(fp)
 d0462a4:	10c00003 	ldbu	r3,0(r2)
 d0462a8:	e0bff617 	ldw	r2,-40(fp)
 d0462ac:	10c00105 	stb	r3,4(r2)
      break;
 d0462b0:	0000fc06 	br	d0466a4 <ip_setmoptions+0x56c>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 d0462b4:	e0bffd17 	ldw	r2,-12(fp)
 d0462b8:	10800003 	ldbu	r2,0(r2)
 d0462bc:	10803fcc 	andi	r2,r2,255
 d0462c0:	108000b0 	cmpltui	r2,r2,2
 d0462c4:	1000031e 	bne	r2,zero,d0462d4 <ip_setmoptions+0x19c>
      {
         error = EINVAL;
 d0462c8:	00800584 	movi	r2,22
 d0462cc:	e0bff915 	stw	r2,-28(fp)
         break;
 d0462d0:	0000f406 	br	d0466a4 <ip_setmoptions+0x56c>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 d0462d4:	e0bffd17 	ldw	r2,-12(fp)
 d0462d8:	10c00003 	ldbu	r3,0(r2)
 d0462dc:	e0bff617 	ldw	r2,-40(fp)
 d0462e0:	10c00145 	stb	r3,5(r2)
      break;
 d0462e4:	0000ef06 	br	d0466a4 <ip_setmoptions+0x56c>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 d0462e8:	e0bffd17 	ldw	r2,-12(fp)
 d0462ec:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 d0462f0:	e0bff717 	ldw	r2,-36(fp)
 d0462f4:	10800017 	ldw	r2,0(r2)
 d0462f8:	1004d63a 	srli	r2,r2,24
 d0462fc:	10c03fcc 	andi	r3,r2,255
 d046300:	e0bff717 	ldw	r2,-36(fp)
 d046304:	10800017 	ldw	r2,0(r2)
 d046308:	1004d23a 	srli	r2,r2,8
 d04630c:	10bfc00c 	andi	r2,r2,65280
 d046310:	1886b03a 	or	r3,r3,r2
 d046314:	e0bff717 	ldw	r2,-36(fp)
 d046318:	10800017 	ldw	r2,0(r2)
 d04631c:	10bfc00c 	andi	r2,r2,65280
 d046320:	1004923a 	slli	r2,r2,8
 d046324:	1886b03a 	or	r3,r3,r2
 d046328:	e0bff717 	ldw	r2,-36(fp)
 d04632c:	10800017 	ldw	r2,0(r2)
 d046330:	10803fcc 	andi	r2,r2,255
 d046334:	1004963a 	slli	r2,r2,24
 d046338:	1884b03a 	or	r2,r3,r2
 d04633c:	10fc002c 	andhi	r3,r2,61440
 d046340:	00b80034 	movhi	r2,57344
 d046344:	18800326 	beq	r3,r2,d046354 <ip_setmoptions+0x21c>
      {
         error = EINVAL;
 d046348:	00800584 	movi	r2,22
 d04634c:	e0bff915 	stw	r2,-28(fp)
         break;
 d046350:	0000d406 	br	d0466a4 <ip_setmoptions+0x56c>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 d046354:	e0bff717 	ldw	r2,-36(fp)
 d046358:	11000117 	ldw	r4,4(r2)
 d04635c:	e17ffa04 	addi	r5,fp,-24
 d046360:	d045ff00 	call	d045ff0 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 d046364:	e0bffa17 	ldw	r2,-24(fp)
 d046368:	1005003a 	cmpeq	r2,r2,zero
 d04636c:	1000041e 	bne	r2,zero,d046380 <ip_setmoptions+0x248>
 d046370:	e0bffa17 	ldw	r2,-24(fp)
 d046374:	10802b17 	ldw	r2,172(r2)
 d046378:	1004c03a 	cmpne	r2,r2,zero
 d04637c:	1000031e 	bne	r2,zero,d04638c <ip_setmoptions+0x254>
      {
         error = EADDRNOTAVAIL;
 d046380:	00801f44 	movi	r2,125
 d046384:	e0bff915 	stw	r2,-28(fp)
         break;
 d046388:	0000c606 	br	d0466a4 <ip_setmoptions+0x56c>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d04638c:	e03ff80d 	sth	zero,-32(fp)
 d046390:	00001806 	br	d0463f4 <ip_setmoptions+0x2bc>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 d046394:	e0bff80b 	ldhu	r2,-32(fp)
 d046398:	e0fff617 	ldw	r3,-40(fp)
 d04639c:	1085883a 	add	r2,r2,r2
 d0463a0:	1085883a 	add	r2,r2,r2
 d0463a4:	10c5883a 	add	r2,r2,r3
 d0463a8:	10800204 	addi	r2,r2,8
 d0463ac:	10800017 	ldw	r2,0(r2)
 d0463b0:	10c00117 	ldw	r3,4(r2)
 d0463b4:	e0bffa17 	ldw	r2,-24(fp)
 d0463b8:	18800b1e 	bne	r3,r2,d0463e8 <ip_setmoptions+0x2b0>
 d0463bc:	e0bff80b 	ldhu	r2,-32(fp)
 d0463c0:	e0fff617 	ldw	r3,-40(fp)
 d0463c4:	1085883a 	add	r2,r2,r2
 d0463c8:	1085883a 	add	r2,r2,r2
 d0463cc:	10c5883a 	add	r2,r2,r3
 d0463d0:	10800204 	addi	r2,r2,8
 d0463d4:	10800017 	ldw	r2,0(r2)
 d0463d8:	10c00017 	ldw	r3,0(r2)
 d0463dc:	e0bff717 	ldw	r2,-36(fp)
 d0463e0:	10800017 	ldw	r2,0(r2)
 d0463e4:	18800826 	beq	r3,r2,d046408 <ip_setmoptions+0x2d0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d0463e8:	e0bff80b 	ldhu	r2,-32(fp)
 d0463ec:	10800044 	addi	r2,r2,1
 d0463f0:	e0bff80d 	sth	r2,-32(fp)
 d0463f4:	e0bff617 	ldw	r2,-40(fp)
 d0463f8:	1080018b 	ldhu	r2,6(r2)
 d0463fc:	10ffffcc 	andi	r3,r2,65535
 d046400:	e0bff80b 	ldhu	r2,-32(fp)
 d046404:	10ffe336 	bltu	r2,r3,d046394 <ip_setmoptions+0x25c>
             == mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i < imo->imo_num_memberships) 
 d046408:	e0bff617 	ldw	r2,-40(fp)
 d04640c:	1080018b 	ldhu	r2,6(r2)
 d046410:	10ffffcc 	andi	r3,r2,65535
 d046414:	e0bff80b 	ldhu	r2,-32(fp)
 d046418:	10c0032e 	bgeu	r2,r3,d046428 <ip_setmoptions+0x2f0>
      {
         error = EADDRINUSE;
 d04641c:	00801c04 	movi	r2,112
 d046420:	e0bff915 	stw	r2,-28(fp)
         break;
 d046424:	00009f06 	br	d0466a4 <ip_setmoptions+0x56c>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 d046428:	e0bff80b 	ldhu	r2,-32(fp)
 d04642c:	10800518 	cmpnei	r2,r2,20
 d046430:	1000031e 	bne	r2,zero,d046440 <ip_setmoptions+0x308>
      {
         error = ETOOMANYREFS;
 d046434:	00802044 	movi	r2,129
 d046438:	e0bff915 	stw	r2,-28(fp)
         break;
 d04643c:	00009906 	br	d0466a4 <ip_setmoptions+0x56c>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 d046440:	e43ff80b 	ldhu	r16,-32(fp)
 d046444:	e13ff717 	ldw	r4,-36(fp)
 d046448:	e17ffa17 	ldw	r5,-24(fp)
 d04644c:	01800104 	movi	r6,4
 d046450:	d0436e40 	call	d0436e4 <in_addmulti>
 d046454:	1009883a 	mov	r4,r2
 d046458:	e0fff617 	ldw	r3,-40(fp)
 d04645c:	8405883a 	add	r2,r16,r16
 d046460:	1085883a 	add	r2,r2,r2
 d046464:	10c5883a 	add	r2,r2,r3
 d046468:	10800204 	addi	r2,r2,8
 d04646c:	11000015 	stw	r4,0(r2)
 d046470:	e0fff617 	ldw	r3,-40(fp)
 d046474:	8405883a 	add	r2,r16,r16
 d046478:	1085883a 	add	r2,r2,r2
 d04647c:	10c5883a 	add	r2,r2,r3
 d046480:	10800204 	addi	r2,r2,8
 d046484:	10800017 	ldw	r2,0(r2)
 d046488:	1004c03a 	cmpne	r2,r2,zero
 d04648c:	1000031e 	bne	r2,zero,d04649c <ip_setmoptions+0x364>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 d046490:	00801a44 	movi	r2,105
 d046494:	e0bff915 	stw	r2,-28(fp)
         break;
 d046498:	00008206 	br	d0466a4 <ip_setmoptions+0x56c>
      }
      ++imo->imo_num_memberships;
 d04649c:	e0bff617 	ldw	r2,-40(fp)
 d0464a0:	1080018b 	ldhu	r2,6(r2)
 d0464a4:	10800044 	addi	r2,r2,1
 d0464a8:	1007883a 	mov	r3,r2
 d0464ac:	e0bff617 	ldw	r2,-40(fp)
 d0464b0:	10c0018d 	sth	r3,6(r2)
      break;
 d0464b4:	00007b06 	br	d0466a4 <ip_setmoptions+0x56c>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 d0464b8:	e0bffd17 	ldw	r2,-12(fp)
 d0464bc:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 d0464c0:	e0bff717 	ldw	r2,-36(fp)
 d0464c4:	10800017 	ldw	r2,0(r2)
 d0464c8:	1004d63a 	srli	r2,r2,24
 d0464cc:	10c03fcc 	andi	r3,r2,255
 d0464d0:	e0bff717 	ldw	r2,-36(fp)
 d0464d4:	10800017 	ldw	r2,0(r2)
 d0464d8:	1004d23a 	srli	r2,r2,8
 d0464dc:	10bfc00c 	andi	r2,r2,65280
 d0464e0:	1886b03a 	or	r3,r3,r2
 d0464e4:	e0bff717 	ldw	r2,-36(fp)
 d0464e8:	10800017 	ldw	r2,0(r2)
 d0464ec:	10bfc00c 	andi	r2,r2,65280
 d0464f0:	1004923a 	slli	r2,r2,8
 d0464f4:	1886b03a 	or	r3,r3,r2
 d0464f8:	e0bff717 	ldw	r2,-36(fp)
 d0464fc:	10800017 	ldw	r2,0(r2)
 d046500:	10803fcc 	andi	r2,r2,255
 d046504:	1004963a 	slli	r2,r2,24
 d046508:	1884b03a 	or	r2,r3,r2
 d04650c:	10fc002c 	andhi	r3,r2,61440
 d046510:	00b80034 	movhi	r2,57344
 d046514:	18800326 	beq	r3,r2,d046524 <ip_setmoptions+0x3ec>
      {
         error = EINVAL;
 d046518:	00800584 	movi	r2,22
 d04651c:	e0bff915 	stw	r2,-28(fp)
         break;
 d046520:	00006006 	br	d0466a4 <ip_setmoptions+0x56c>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 d046524:	e0bff717 	ldw	r2,-36(fp)
 d046528:	11000117 	ldw	r4,4(r2)
 d04652c:	e17ffa04 	addi	r5,fp,-24
 d046530:	d045ff00 	call	d045ff0 <IPADDR_TO_NETP>
      if (netp == NULL) 
 d046534:	e0bffa17 	ldw	r2,-24(fp)
 d046538:	1004c03a 	cmpne	r2,r2,zero
 d04653c:	1000031e 	bne	r2,zero,d04654c <ip_setmoptions+0x414>
      {
         error = EADDRNOTAVAIL;
 d046540:	00801f44 	movi	r2,125
 d046544:	e0bff915 	stw	r2,-28(fp)
         break;
 d046548:	00005606 	br	d0466a4 <ip_setmoptions+0x56c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d04654c:	e03ff80d 	sth	zero,-32(fp)
 d046550:	00001b06 	br	d0465c0 <ip_setmoptions+0x488>
      {
         if ((netp == NULL ||
 d046554:	e0bffa17 	ldw	r2,-24(fp)
 d046558:	1005003a 	cmpeq	r2,r2,zero
 d04655c:	10000a1e 	bne	r2,zero,d046588 <ip_setmoptions+0x450>
 d046560:	e0bff80b 	ldhu	r2,-32(fp)
 d046564:	e0fff617 	ldw	r3,-40(fp)
 d046568:	1085883a 	add	r2,r2,r2
 d04656c:	1085883a 	add	r2,r2,r2
 d046570:	10c5883a 	add	r2,r2,r3
 d046574:	10800204 	addi	r2,r2,8
 d046578:	10800017 	ldw	r2,0(r2)
 d04657c:	10c00117 	ldw	r3,4(r2)
 d046580:	e0bffa17 	ldw	r2,-24(fp)
 d046584:	18800b1e 	bne	r3,r2,d0465b4 <ip_setmoptions+0x47c>
 d046588:	e0bff80b 	ldhu	r2,-32(fp)
 d04658c:	e0fff617 	ldw	r3,-40(fp)
 d046590:	1085883a 	add	r2,r2,r2
 d046594:	1085883a 	add	r2,r2,r2
 d046598:	10c5883a 	add	r2,r2,r3
 d04659c:	10800204 	addi	r2,r2,8
 d0465a0:	10800017 	ldw	r2,0(r2)
 d0465a4:	10c00017 	ldw	r3,0(r2)
 d0465a8:	e0bff717 	ldw	r2,-36(fp)
 d0465ac:	10800017 	ldw	r2,0(r2)
 d0465b0:	18800826 	beq	r3,r2,d0465d4 <ip_setmoptions+0x49c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d0465b4:	e0bff80b 	ldhu	r2,-32(fp)
 d0465b8:	10800044 	addi	r2,r2,1
 d0465bc:	e0bff80d 	sth	r2,-32(fp)
 d0465c0:	e0bff617 	ldw	r2,-40(fp)
 d0465c4:	1080018b 	ldhu	r2,6(r2)
 d0465c8:	10ffffcc 	andi	r3,r2,65535
 d0465cc:	e0bff80b 	ldhu	r2,-32(fp)
 d0465d0:	10ffe036 	bltu	r2,r3,d046554 <ip_setmoptions+0x41c>
             mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i == imo->imo_num_memberships) 
 d0465d4:	e0bff617 	ldw	r2,-40(fp)
 d0465d8:	1080018b 	ldhu	r2,6(r2)
 d0465dc:	10ffffcc 	andi	r3,r2,65535
 d0465e0:	e0bff80b 	ldhu	r2,-32(fp)
 d0465e4:	1880031e 	bne	r3,r2,d0465f4 <ip_setmoptions+0x4bc>
      {
         error = EADDRNOTAVAIL;
 d0465e8:	00801f44 	movi	r2,125
 d0465ec:	e0bff915 	stw	r2,-28(fp)
         break;
 d0465f0:	00002c06 	br	d0466a4 <ip_setmoptions+0x56c>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 d0465f4:	e0bff80b 	ldhu	r2,-32(fp)
 d0465f8:	e0fff617 	ldw	r3,-40(fp)
 d0465fc:	1085883a 	add	r2,r2,r2
 d046600:	1085883a 	add	r2,r2,r2
 d046604:	10c5883a 	add	r2,r2,r3
 d046608:	10800204 	addi	r2,r2,8
 d04660c:	11000017 	ldw	r4,0(r2)
 d046610:	d04384c0 	call	d04384c <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 d046614:	e0bff80b 	ldhu	r2,-32(fp)
 d046618:	10800044 	addi	r2,r2,1
 d04661c:	e0bff80d 	sth	r2,-32(fp)
 d046620:	00001206 	br	d04666c <ip_setmoptions+0x534>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 d046624:	e0bff80b 	ldhu	r2,-32(fp)
 d046628:	113fffc4 	addi	r4,r2,-1
 d04662c:	e0bff80b 	ldhu	r2,-32(fp)
 d046630:	e0fff617 	ldw	r3,-40(fp)
 d046634:	1085883a 	add	r2,r2,r2
 d046638:	1085883a 	add	r2,r2,r2
 d04663c:	10c5883a 	add	r2,r2,r3
 d046640:	10800204 	addi	r2,r2,8
 d046644:	11400017 	ldw	r5,0(r2)
 d046648:	e0fff617 	ldw	r3,-40(fp)
 d04664c:	2105883a 	add	r2,r4,r4
 d046650:	1085883a 	add	r2,r2,r2
 d046654:	10c5883a 	add	r2,r2,r3
 d046658:	10800204 	addi	r2,r2,8
 d04665c:	11400015 	stw	r5,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 d046660:	e0bff80b 	ldhu	r2,-32(fp)
 d046664:	10800044 	addi	r2,r2,1
 d046668:	e0bff80d 	sth	r2,-32(fp)
 d04666c:	e0bff617 	ldw	r2,-40(fp)
 d046670:	1080018b 	ldhu	r2,6(r2)
 d046674:	10ffffcc 	andi	r3,r2,65535
 d046678:	e0bff80b 	ldhu	r2,-32(fp)
 d04667c:	10ffe936 	bltu	r2,r3,d046624 <ip_setmoptions+0x4ec>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 d046680:	e0bff617 	ldw	r2,-40(fp)
 d046684:	1080018b 	ldhu	r2,6(r2)
 d046688:	10bfffc4 	addi	r2,r2,-1
 d04668c:	1007883a 	mov	r3,r2
 d046690:	e0bff617 	ldw	r2,-40(fp)
 d046694:	10c0018d 	sth	r3,6(r2)
      break;
 d046698:	00000206 	br	d0466a4 <ip_setmoptions+0x56c>

      default:
      error = EOPNOTSUPP;
 d04669c:	008017c4 	movi	r2,95
 d0466a0:	e0bff915 	stw	r2,-28(fp)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 d0466a4:	e0bff617 	ldw	r2,-40(fp)
 d0466a8:	10800017 	ldw	r2,0(r2)
 d0466ac:	1004c03a 	cmpne	r2,r2,zero
 d0466b0:	1000141e 	bne	r2,zero,d046704 <ip_setmoptions+0x5cc>
 d0466b4:	e0bff617 	ldw	r2,-40(fp)
 d0466b8:	10800103 	ldbu	r2,4(r2)
 d0466bc:	10803fcc 	andi	r2,r2,255
 d0466c0:	10800058 	cmpnei	r2,r2,1
 d0466c4:	10000f1e 	bne	r2,zero,d046704 <ip_setmoptions+0x5cc>
 d0466c8:	e0bff617 	ldw	r2,-40(fp)
 d0466cc:	10800143 	ldbu	r2,5(r2)
 d0466d0:	10803fcc 	andi	r2,r2,255
 d0466d4:	10800058 	cmpnei	r2,r2,1
 d0466d8:	10000a1e 	bne	r2,zero,d046704 <ip_setmoptions+0x5cc>
 d0466dc:	e0bff617 	ldw	r2,-40(fp)
 d0466e0:	1080018b 	ldhu	r2,6(r2)
 d0466e4:	10bfffcc 	andi	r2,r2,65535
 d0466e8:	1004c03a 	cmpne	r2,r2,zero
 d0466ec:	1000051e 	bne	r2,zero,d046704 <ip_setmoptions+0x5cc>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 d0466f0:	e0bff517 	ldw	r2,-44(fp)
 d0466f4:	11000017 	ldw	r4,0(r2)
 d0466f8:	d0265ac0 	call	d0265ac <npfree>
      *imop = NULL;
 d0466fc:	e0bff517 	ldw	r2,-44(fp)
 d046700:	10000015 	stw	zero,0(r2)
   }
   return (error);
 d046704:	e0bff917 	ldw	r2,-28(fp)
 d046708:	e0bffe15 	stw	r2,-8(fp)
 d04670c:	e0bffe17 	ldw	r2,-8(fp)
}
 d046710:	e037883a 	mov	sp,fp
 d046714:	dfc00217 	ldw	ra,8(sp)
 d046718:	df000117 	ldw	fp,4(sp)
 d04671c:	dc000017 	ldw	r16,0(sp)
 d046720:	dec00304 	addi	sp,sp,12
 d046724:	f800283a 	ret

0d046728 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 d046728:	defff604 	addi	sp,sp,-40
 d04672c:	df000915 	stw	fp,36(sp)
 d046730:	df000904 	addi	fp,sp,36
 d046734:	e13ffb15 	stw	r4,-20(fp)
 d046738:	e17ffc15 	stw	r5,-16(fp)
 d04673c:	e1bffd15 	stw	r6,-12(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 d046740:	e0bffc17 	ldw	r2,-16(fp)
 d046744:	10800317 	ldw	r2,12(r2)
 d046748:	e0bff715 	stw	r2,-36(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 d04674c:	e0bffb17 	ldw	r2,-20(fp)
 d046750:	e0bfff15 	stw	r2,-4(fp)
 d046754:	e0ffff17 	ldw	r3,-4(fp)
 d046758:	18800260 	cmpeqi	r2,r3,9
 d04675c:	10000a1e 	bne	r2,zero,d046788 <ip_getmoptions+0x60>
 d046760:	e0ffff17 	ldw	r3,-4(fp)
 d046764:	18800250 	cmplti	r2,r3,9
 d046768:	1000381e 	bne	r2,zero,d04684c <ip_getmoptions+0x124>
 d04676c:	e0ffff17 	ldw	r3,-4(fp)
 d046770:	188002a0 	cmpeqi	r2,r3,10
 d046774:	1000171e 	bne	r2,zero,d0467d4 <ip_getmoptions+0xac>
 d046778:	e0ffff17 	ldw	r3,-4(fp)
 d04677c:	188002e0 	cmpeqi	r2,r3,11
 d046780:	1000231e 	bne	r2,zero,d046810 <ip_getmoptions+0xe8>
 d046784:	00003106 	br	d04684c <ip_getmoptions+0x124>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 d046788:	e0bffd17 	ldw	r2,-12(fp)
 d04678c:	e0bff815 	stw	r2,-32(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 d046790:	e0bff717 	ldw	r2,-36(fp)
 d046794:	1005003a 	cmpeq	r2,r2,zero
 d046798:	1000041e 	bne	r2,zero,d0467ac <ip_getmoptions+0x84>
 d04679c:	e0bff717 	ldw	r2,-36(fp)
 d0467a0:	10800017 	ldw	r2,0(r2)
 d0467a4:	1004c03a 	cmpne	r2,r2,zero
 d0467a8:	1000031e 	bne	r2,zero,d0467b8 <ip_getmoptions+0x90>
         *addr = AADDR;
 d0467ac:	e0bff817 	ldw	r2,-32(fp)
 d0467b0:	10000015 	stw	zero,0(r2)
   switch (optname) 
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 d0467b4:	00000506 	br	d0467cc <ip_getmoptions+0xa4>
         *addr = AADDR;
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 d0467b8:	e0bff717 	ldw	r2,-36(fp)
 d0467bc:	10800017 	ldw	r2,0(r2)
 d0467c0:	10c00a17 	ldw	r3,40(r2)
 d0467c4:	e0bff817 	ldw	r2,-32(fp)
 d0467c8:	10c00015 	stw	r3,0(r2)
      return (0);
 d0467cc:	e03ffe15 	stw	zero,-8(fp)
 d0467d0:	00002006 	br	d046854 <ip_getmoptions+0x12c>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 d0467d4:	e0bffd17 	ldw	r2,-12(fp)
 d0467d8:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL)
 d0467dc:	e0bff717 	ldw	r2,-36(fp)
 d0467e0:	1004c03a 	cmpne	r2,r2,zero
 d0467e4:	1000041e 	bne	r2,zero,d0467f8 <ip_getmoptions+0xd0>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 d0467e8:	e0fffa17 	ldw	r3,-24(fp)
 d0467ec:	00800044 	movi	r2,1
 d0467f0:	18800005 	stb	r2,0(r3)
 d0467f4:	00000406 	br	d046808 <ip_getmoptions+0xe0>
      else
         *ttl = imo->imo_multicast_ttl;
 d0467f8:	e0bff717 	ldw	r2,-36(fp)
 d0467fc:	10c00103 	ldbu	r3,4(r2)
 d046800:	e0bffa17 	ldw	r2,-24(fp)
 d046804:	10c00005 	stb	r3,0(r2)
      return (0);
 d046808:	e03ffe15 	stw	zero,-8(fp)
 d04680c:	00001106 	br	d046854 <ip_getmoptions+0x12c>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 d046810:	e0bffd17 	ldw	r2,-12(fp)
 d046814:	e0bff915 	stw	r2,-28(fp)
      if (imo == NULL)
 d046818:	e0bff717 	ldw	r2,-36(fp)
 d04681c:	1004c03a 	cmpne	r2,r2,zero
 d046820:	1000041e 	bne	r2,zero,d046834 <ip_getmoptions+0x10c>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 d046824:	e0fff917 	ldw	r3,-28(fp)
 d046828:	00800044 	movi	r2,1
 d04682c:	18800005 	stb	r2,0(r3)
 d046830:	00000406 	br	d046844 <ip_getmoptions+0x11c>
      else
         *loop = imo->imo_multicast_loop;
 d046834:	e0bff717 	ldw	r2,-36(fp)
 d046838:	10c00143 	ldbu	r3,5(r2)
 d04683c:	e0bff917 	ldw	r2,-28(fp)
 d046840:	10c00005 	stb	r3,0(r2)
      return (0);
 d046844:	e03ffe15 	stw	zero,-8(fp)
 d046848:	00000206 	br	d046854 <ip_getmoptions+0x12c>

      default:
      return (EOPNOTSUPP);
 d04684c:	008017c4 	movi	r2,95
 d046850:	e0bffe15 	stw	r2,-8(fp)
 d046854:	e0bffe17 	ldw	r2,-8(fp)
   }
}
 d046858:	e037883a 	mov	sp,fp
 d04685c:	df000017 	ldw	fp,0(sp)
 d046860:	dec00104 	addi	sp,sp,4
 d046864:	f800283a 	ret

0d046868 <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 d046868:	defffc04 	addi	sp,sp,-16
 d04686c:	dfc00315 	stw	ra,12(sp)
 d046870:	df000215 	stw	fp,8(sp)
 d046874:	df000204 	addi	fp,sp,8
 d046878:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 d04687c:	e0bfff17 	ldw	r2,-4(fp)
 d046880:	1005003a 	cmpeq	r2,r2,zero
 d046884:	1000141e 	bne	r2,zero,d0468d8 <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 d046888:	e03ffe0d 	sth	zero,-8(fp)
 d04688c:	00000b06 	br	d0468bc <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 d046890:	e0bffe0b 	ldhu	r2,-8(fp)
 d046894:	e0ffff17 	ldw	r3,-4(fp)
 d046898:	1085883a 	add	r2,r2,r2
 d04689c:	1085883a 	add	r2,r2,r2
 d0468a0:	10c5883a 	add	r2,r2,r3
 d0468a4:	10800204 	addi	r2,r2,8
 d0468a8:	11000017 	ldw	r4,0(r2)
 d0468ac:	d04384c0 	call	d04384c <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 d0468b0:	e0bffe0b 	ldhu	r2,-8(fp)
 d0468b4:	10800044 	addi	r2,r2,1
 d0468b8:	e0bffe0d 	sth	r2,-8(fp)
 d0468bc:	e0bfff17 	ldw	r2,-4(fp)
 d0468c0:	1080018b 	ldhu	r2,6(r2)
 d0468c4:	10ffffcc 	andi	r3,r2,65535
 d0468c8:	e0bffe0b 	ldhu	r2,-8(fp)
 d0468cc:	10fff036 	bltu	r2,r3,d046890 <ip_freemoptions+0x28>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 d0468d0:	e13fff17 	ldw	r4,-4(fp)
 d0468d4:	d0265ac0 	call	d0265ac <npfree>
   }
}
 d0468d8:	e037883a 	mov	sp,fp
 d0468dc:	dfc00117 	ldw	ra,4(sp)
 d0468e0:	df000017 	ldw	fp,0(sp)
 d0468e4:	dec00204 	addi	sp,sp,8
 d0468e8:	f800283a 	ret

0d0468ec <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 d0468ec:	defffe04 	addi	sp,sp,-8
 d0468f0:	dfc00115 	stw	ra,4(sp)
 d0468f4:	df000015 	stw	fp,0(sp)
 d0468f8:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 d0468fc:	01034174 	movhi	r4,3333
 d046900:	21080c04 	addi	r4,r4,8240
 d046904:	d002bc80 	call	d002bc8 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 d046908:	e037883a 	mov	sp,fp
 d04690c:	dfc00117 	ldw	ra,4(sp)
 d046910:	df000017 	ldw	fp,0(sp)
 d046914:	dec00204 	addi	sp,sp,8
 d046918:	f800283a 	ret

0d04691c <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 d04691c:	defede04 	addi	sp,sp,-1160
 d046920:	dfc12115 	stw	ra,1156(sp)
 d046924:	df012015 	stw	fp,1152(sp)
 d046928:	df012004 	addi	fp,sp,1152
 d04692c:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 d046930:	00c34174 	movhi	r3,3333
 d046934:	18c8b804 	addi	r3,r3,8928
 d046938:	18800017 	ldw	r2,0(r3)
 d04693c:	e0bff215 	stw	r2,-56(fp)
 d046940:	18800117 	ldw	r2,4(r3)
 d046944:	e0bff315 	stw	r2,-52(fp)
 d046948:	18800217 	ldw	r2,8(r3)
 d04694c:	e0bff415 	stw	r2,-48(fp)
 d046950:	18800317 	ldw	r2,12(r3)
 d046954:	e0bff515 	stw	r2,-44(fp)
 d046958:	18800417 	ldw	r2,16(r3)
 d04695c:	e0bff615 	stw	r2,-40(fp)
 d046960:	18800517 	ldw	r2,20(r3)
 d046964:	e0bff715 	stw	r2,-36(fp)
 d046968:	18800617 	ldw	r2,24(r3)
 d04696c:	e0bff815 	stw	r2,-32(fp)
 d046970:	1880070b 	ldhu	r2,28(r3)
 d046974:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 d046978:	01000084 	movi	r4,2
 d04697c:	01400084 	movi	r5,2
 d046980:	000d883a 	mov	r6,zero
 d046984:	d028af80 	call	d028af8 <t_socket>
 d046988:	e0bee515 	stw	r2,-1132(fp)

   if (s == INVALID_SOCKET) 
 d04698c:	e0bee517 	ldw	r2,-1132(fp)
 d046990:	10bfffd8 	cmpnei	r2,r2,-1
 d046994:	1000091e 	bne	r2,zero,d0469bc <u_mctest_run+0xa0>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 d046998:	e13ee517 	ldw	r4,-1132(fp)
 d04699c:	d02a20c0 	call	d02a20c <t_errno>
 d0469a0:	100d883a 	mov	r6,r2
 d0469a4:	e13fff17 	ldw	r4,-4(fp)
 d0469a8:	01434174 	movhi	r5,3333
 d0469ac:	29481104 	addi	r5,r5,8260
 d0469b0:	d020b640 	call	d020b64 <ns_printf>
      exit(1);
 d0469b4:	01000044 	movi	r4,1
 d0469b8:	d04bde40 	call	d04bde4 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 d0469bc:	00800044 	movi	r2,1
 d0469c0:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 d0469c4:	e1fffa04 	addi	r7,fp,-24
 d0469c8:	00800104 	movi	r2,4
 d0469cc:	d8800015 	stw	r2,0(sp)
 d0469d0:	e13ee517 	ldw	r4,-1132(fp)
 d0469d4:	017fffc4 	movi	r5,-1
 d0469d8:	01800104 	movi	r6,4
 d0469dc:	d0295ac0 	call	d0295ac <t_setsockopt>
 d0469e0:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d0469e4:	e0bee317 	ldw	r2,-1140(fp)
 d0469e8:	10bfffd8 	cmpnei	r2,r2,-1
 d0469ec:	1000071e 	bne	r2,zero,d046a0c <u_mctest_run+0xf0>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 d0469f0:	e13ee517 	ldw	r4,-1132(fp)
 d0469f4:	d02a20c0 	call	d02a20c <t_errno>
 d0469f8:	100d883a 	mov	r6,r2
 d0469fc:	e13fff17 	ldw	r4,-4(fp)
 d046a00:	01434174 	movhi	r5,3333
 d046a04:	29481804 	addi	r5,r5,8288
 d046a08:	d020b640 	call	d020b64 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 d046a0c:	00800084 	movi	r2,2
 d046a10:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 d046a14:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 d046a18:	00a00344 	movi	r2,-32755
 d046a1c:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 d046a20:	e17ee604 	addi	r5,fp,-1128
 d046a24:	e13ee517 	ldw	r4,-1132(fp)
 d046a28:	01800404 	movi	r6,16
 d046a2c:	d028b880 	call	d028b88 <t_bind>
 d046a30:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d046a34:	e0bee317 	ldw	r2,-1140(fp)
 d046a38:	10bfffd8 	cmpnei	r2,r2,-1
 d046a3c:	1000061e 	bne	r2,zero,d046a58 <u_mctest_run+0x13c>
   {
      printf ("t_bind() failed, Err: %d\n",
 d046a40:	e13ee517 	ldw	r4,-1132(fp)
 d046a44:	d02a20c0 	call	d02a20c <t_errno>
 d046a48:	100b883a 	mov	r5,r2
 d046a4c:	01034174 	movhi	r4,3333
 d046a50:	21082404 	addi	r4,r4,8336
 d046a54:	d0028a00 	call	d0028a0 <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 d046a58:	e13fff17 	ldw	r4,-4(fp)
 d046a5c:	01434174 	movhi	r5,3333
 d046a60:	29482b04 	addi	r5,r5,8364
 d046a64:	01834174 	movhi	r6,3333
 d046a68:	31883304 	addi	r6,r6,8396
 d046a6c:	d020b640 	call	d020b64 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 d046a70:	01034174 	movhi	r4,3333
 d046a74:	21083304 	addi	r4,r4,8396
 d046a78:	d047a640 	call	d047a64 <inet_addr>
 d046a7c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d046a80:	008341b4 	movhi	r2,3334
 d046a84:	10825a04 	addi	r2,r2,2408
 d046a88:	10800a17 	ldw	r2,40(r2)
 d046a8c:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 d046a90:	e1fffb04 	addi	r7,fp,-20
 d046a94:	00800204 	movi	r2,8
 d046a98:	d8800015 	stw	r2,0(sp)
 d046a9c:	e13ee517 	ldw	r4,-1132(fp)
 d046aa0:	000b883a 	mov	r5,zero
 d046aa4:	01800304 	movi	r6,12
 d046aa8:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046aac:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 d046ab0:	e0bee317 	ldw	r2,-1140(fp)
 d046ab4:	10bfffd8 	cmpnei	r2,r2,-1
 d046ab8:	1000071e 	bne	r2,zero,d046ad8 <u_mctest_run+0x1bc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 d046abc:	e13ee517 	ldw	r4,-1132(fp)
 d046ac0:	d02a20c0 	call	d02a20c <t_errno>
 d046ac4:	100d883a 	mov	r6,r2
 d046ac8:	e13fff17 	ldw	r4,-4(fp)
 d046acc:	01434174 	movhi	r5,3333
 d046ad0:	29483604 	addi	r5,r5,8408
 d046ad4:	d020b640 	call	d020b64 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 d046ad8:	d0216100 	call	d021610 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 d046adc:	e13fff17 	ldw	r4,-4(fp)
 d046ae0:	01434174 	movhi	r5,3333
 d046ae4:	29482b04 	addi	r5,r5,8364
 d046ae8:	01834174 	movhi	r6,3333
 d046aec:	31884304 	addi	r6,r6,8460
 d046af0:	d020b640 	call	d020b64 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 d046af4:	01034174 	movhi	r4,3333
 d046af8:	21084304 	addi	r4,r4,8460
 d046afc:	d047a640 	call	d047a64 <inet_addr>
 d046b00:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d046b04:	008341b4 	movhi	r2,3334
 d046b08:	10825a04 	addi	r2,r2,2408
 d046b0c:	10800a17 	ldw	r2,40(r2)
 d046b10:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 d046b14:	e1fffb04 	addi	r7,fp,-20
 d046b18:	00800204 	movi	r2,8
 d046b1c:	d8800015 	stw	r2,0(sp)
 d046b20:	e13ee517 	ldw	r4,-1132(fp)
 d046b24:	000b883a 	mov	r5,zero
 d046b28:	01800304 	movi	r6,12
 d046b2c:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046b30:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 d046b34:	e0bee317 	ldw	r2,-1140(fp)
 d046b38:	10bfffd8 	cmpnei	r2,r2,-1
 d046b3c:	1000071e 	bne	r2,zero,d046b5c <u_mctest_run+0x240>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 d046b40:	e13ee517 	ldw	r4,-1132(fp)
 d046b44:	d02a20c0 	call	d02a20c <t_errno>
 d046b48:	100d883a 	mov	r6,r2
 d046b4c:	e13fff17 	ldw	r4,-4(fp)
 d046b50:	01434174 	movhi	r5,3333
 d046b54:	29483604 	addi	r5,r5,8408
 d046b58:	d020b640 	call	d020b64 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 d046b5c:	d0216100 	call	d021610 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 d046b60:	e13fff17 	ldw	r4,-4(fp)
 d046b64:	01434174 	movhi	r5,3333
 d046b68:	29482b04 	addi	r5,r5,8364
 d046b6c:	01834174 	movhi	r6,3333
 d046b70:	31884604 	addi	r6,r6,8472
 d046b74:	d020b640 	call	d020b64 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 d046b78:	01034174 	movhi	r4,3333
 d046b7c:	21084604 	addi	r4,r4,8472
 d046b80:	d047a640 	call	d047a64 <inet_addr>
 d046b84:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d046b88:	008341b4 	movhi	r2,3334
 d046b8c:	10825a04 	addi	r2,r2,2408
 d046b90:	10800a17 	ldw	r2,40(r2)
 d046b94:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 d046b98:	e1fffb04 	addi	r7,fp,-20
 d046b9c:	00800204 	movi	r2,8
 d046ba0:	d8800015 	stw	r2,0(sp)
 d046ba4:	e13ee517 	ldw	r4,-1132(fp)
 d046ba8:	000b883a 	mov	r5,zero
 d046bac:	01800304 	movi	r6,12
 d046bb0:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046bb4:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 d046bb8:	e0bee317 	ldw	r2,-1140(fp)
 d046bbc:	10bfffd8 	cmpnei	r2,r2,-1
 d046bc0:	1000071e 	bne	r2,zero,d046be0 <u_mctest_run+0x2c4>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 d046bc4:	e13ee517 	ldw	r4,-1132(fp)
 d046bc8:	d02a20c0 	call	d02a20c <t_errno>
 d046bcc:	100d883a 	mov	r6,r2
 d046bd0:	e13fff17 	ldw	r4,-4(fp)
 d046bd4:	01434174 	movhi	r5,3333
 d046bd8:	29483604 	addi	r5,r5,8408
 d046bdc:	d020b640 	call	d020b64 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 d046be0:	d0216100 	call	d021610 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 d046be4:	00800084 	movi	r2,2
 d046be8:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 d046bec:	e1fffd04 	addi	r7,fp,-12
 d046bf0:	00800044 	movi	r2,1
 d046bf4:	d8800015 	stw	r2,0(sp)
 d046bf8:	e13ee517 	ldw	r4,-1132(fp)
 d046bfc:	000b883a 	mov	r5,zero
 d046c00:	01800284 	movi	r6,10
 d046c04:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046c08:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d046c0c:	e0bee317 	ldw	r2,-1140(fp)
 d046c10:	10bfffd8 	cmpnei	r2,r2,-1
 d046c14:	1000071e 	bne	r2,zero,d046c34 <u_mctest_run+0x318>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 d046c18:	e13ee517 	ldw	r4,-1132(fp)
 d046c1c:	d02a20c0 	call	d02a20c <t_errno>
 d046c20:	100d883a 	mov	r6,r2
 d046c24:	e13fff17 	ldw	r4,-4(fp)
 d046c28:	01434174 	movhi	r5,3333
 d046c2c:	29484904 	addi	r5,r5,8484
 d046c30:	d020b640 	call	d020b64 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 d046c34:	00800044 	movi	r2,1
 d046c38:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 d046c3c:	e1fffd04 	addi	r7,fp,-12
 d046c40:	00800044 	movi	r2,1
 d046c44:	d8800015 	stw	r2,0(sp)
 d046c48:	e13ee517 	ldw	r4,-1132(fp)
 d046c4c:	000b883a 	mov	r5,zero
 d046c50:	018002c4 	movi	r6,11
 d046c54:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046c58:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d046c5c:	e0bee317 	ldw	r2,-1140(fp)
 d046c60:	10bfffd8 	cmpnei	r2,r2,-1
 d046c64:	1000071e 	bne	r2,zero,d046c84 <u_mctest_run+0x368>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 d046c68:	e13ee517 	ldw	r4,-1132(fp)
 d046c6c:	d02a20c0 	call	d02a20c <t_errno>
 d046c70:	100d883a 	mov	r6,r2
 d046c74:	e13fff17 	ldw	r4,-4(fp)
 d046c78:	01434174 	movhi	r5,3333
 d046c7c:	29485604 	addi	r5,r5,8536
 d046c80:	d020b640 	call	d020b64 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 d046c84:	00800084 	movi	r2,2
 d046c88:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 d046c8c:	01034174 	movhi	r4,3333
 d046c90:	21084304 	addi	r4,r4,8460
 d046c94:	d047a640 	call	d047a64 <inet_addr>
 d046c98:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 d046c9c:	00a00344 	movi	r2,-32755
 d046ca0:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 d046ca4:	e13fff17 	ldw	r4,-4(fp)
 d046ca8:	01434174 	movhi	r5,3333
 d046cac:	29486304 	addi	r5,r5,8588
 d046cb0:	01834174 	movhi	r6,3333
 d046cb4:	31884304 	addi	r6,r6,8460
 d046cb8:	d020b640 	call	d020b64 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 d046cbc:	e03ee415 	stw	zero,-1136(fp)
 d046cc0:	00008506 	br	d046ed8 <u_mctest_run+0x5bc>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 d046cc4:	e0bff204 	addi	r2,fp,-56
 d046cc8:	11000404 	addi	r4,r2,16
 d046ccc:	d0a05217 	ldw	r2,-32440(gp)
 d046cd0:	100d883a 	mov	r6,r2
 d046cd4:	10800044 	addi	r2,r2,1
 d046cd8:	d0a05215 	stw	r2,-32440(gp)
 d046cdc:	01434174 	movhi	r5,3333
 d046ce0:	29487204 	addi	r5,r5,8648
 d046ce4:	d002c3c0 	call	d002c3c <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 d046ce8:	e0beea04 	addi	r2,fp,-1112
 d046cec:	e17ff204 	addi	r5,fp,-56
 d046cf0:	d8800015 	stw	r2,0(sp)
 d046cf4:	00800404 	movi	r2,16
 d046cf8:	d8800115 	stw	r2,4(sp)
 d046cfc:	e13ee517 	ldw	r4,-1132(fp)
 d046d00:	01800784 	movi	r6,30
 d046d04:	000f883a 	mov	r7,zero
 d046d08:	d029b6c0 	call	d029b6c <t_sendto>
 d046d0c:	e0bee315 	stw	r2,-1140(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 d046d10:	e0bee317 	ldw	r2,-1140(fp)
 d046d14:	1004403a 	cmpge	r2,r2,zero
 d046d18:	1000081e 	bne	r2,zero,d046d3c <u_mctest_run+0x420>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 d046d1c:	e13ee517 	ldw	r4,-1132(fp)
 d046d20:	d02a20c0 	call	d02a20c <t_errno>
 d046d24:	100d883a 	mov	r6,r2
 d046d28:	e13fff17 	ldw	r4,-4(fp)
 d046d2c:	01434174 	movhi	r5,3333
 d046d30:	29487304 	addi	r5,r5,8652
 d046d34:	d020b640 	call	d020b64 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 d046d38:	00006a06 	br	d046ee4 <u_mctest_run+0x5c8>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 d046d3c:	00800044 	movi	r2,1
 d046d40:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 d046d44:	e1fffa04 	addi	r7,fp,-24
 d046d48:	00800104 	movi	r2,4
 d046d4c:	d8800015 	stw	r2,0(sp)
 d046d50:	e13ee517 	ldw	r4,-1132(fp)
 d046d54:	017fffc4 	movi	r5,-1
 d046d58:	01840584 	movi	r6,4118
 d046d5c:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046d60:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 d046d64:	e0bee317 	ldw	r2,-1140(fp)
 d046d68:	10bfffd8 	cmpnei	r2,r2,-1
 d046d6c:	1000071e 	bne	r2,zero,d046d8c <u_mctest_run+0x470>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 d046d70:	e13ee517 	ldw	r4,-1132(fp)
 d046d74:	d02a20c0 	call	d02a20c <t_errno>
 d046d78:	100d883a 	mov	r6,r2
 d046d7c:	e13fff17 	ldw	r4,-4(fp)
 d046d80:	01434174 	movhi	r5,3333
 d046d84:	29487b04 	addi	r5,r5,8684
 d046d88:	d020b640 	call	d020b64 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 d046d8c:	00834174 	movhi	r2,3333
 d046d90:	109b4504 	addi	r2,r2,27924
 d046d94:	10800017 	ldw	r2,0(r2)
 d046d98:	10807d04 	addi	r2,r2,500
 d046d9c:	e0bee215 	stw	r2,-1144(fp)

      while (cticks < endtime)
 d046da0:	00003206 	br	d046e6c <u_mctest_run+0x550>
      {
         int sa_size = sizeof(struct sockaddr_in);
 d046da4:	00800404 	movi	r2,16
 d046da8:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 d046dac:	d0216100 	call	d021610 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 d046db0:	e0beee04 	addi	r2,fp,-1096
 d046db4:	e17ef204 	addi	r5,fp,-1080
 d046db8:	d8800015 	stw	r2,0(sp)
 d046dbc:	e0bffe04 	addi	r2,fp,-8
 d046dc0:	d8800115 	stw	r2,4(sp)
 d046dc4:	e13ee517 	ldw	r4,-1132(fp)
 d046dc8:	01810004 	movi	r6,1024
 d046dcc:	000f883a 	mov	r7,zero
 d046dd0:	d029a1c0 	call	d029a1c <t_recvfrom>
 d046dd4:	e0bee315 	stw	r2,-1140(fp)
         if (iRet < 0) 
 d046dd8:	e0bee317 	ldw	r2,-1140(fp)
 d046ddc:	1004403a 	cmpge	r2,r2,zero
 d046de0:	10000c1e 	bne	r2,zero,d046e14 <u_mctest_run+0x4f8>
         {
            if (t_errno(s) != EWOULDBLOCK)
 d046de4:	e13ee517 	ldw	r4,-1132(fp)
 d046de8:	d02a20c0 	call	d02a20c <t_errno>
 d046dec:	108002e0 	cmpeqi	r2,r2,11
 d046df0:	1000081e 	bne	r2,zero,d046e14 <u_mctest_run+0x4f8>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 d046df4:	e13ee517 	ldw	r4,-1132(fp)
 d046df8:	d02a20c0 	call	d02a20c <t_errno>
 d046dfc:	100d883a 	mov	r6,r2
 d046e00:	e13fff17 	ldw	r4,-4(fp)
 d046e04:	01434174 	movhi	r5,3333
 d046e08:	29488704 	addi	r5,r5,8732
 d046e0c:	d020b640 	call	d020b64 <ns_printf>
               /*     exit(1); */
               goto exitloop;
 d046e10:	00003406 	br	d046ee4 <u_mctest_run+0x5c8>
            }
         }
         if (iRet > 0)
 d046e14:	e0bee317 	ldw	r2,-1140(fp)
 d046e18:	10800050 	cmplti	r2,r2,1
 d046e1c:	1000131e 	bne	r2,zero,d046e6c <u_mctest_run+0x550>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 d046e20:	e13eef17 	ldw	r4,-1092(fp)
 d046e24:	d02079c0 	call	d02079c <print_ipad>
 d046e28:	100d883a 	mov	r6,r2
 d046e2c:	e0beee8b 	ldhu	r2,-1094(fp)
 d046e30:	10bfffcc 	andi	r2,r2,65535
 d046e34:	1004d23a 	srli	r2,r2,8
 d046e38:	10bfffcc 	andi	r2,r2,65535
 d046e3c:	10c03fcc 	andi	r3,r2,255
 d046e40:	e0beee8b 	ldhu	r2,-1094(fp)
 d046e44:	10bfffcc 	andi	r2,r2,65535
 d046e48:	1004923a 	slli	r2,r2,8
 d046e4c:	10bfc00c 	andi	r2,r2,65280
 d046e50:	188eb03a 	or	r7,r3,r2
 d046e54:	e0bef204 	addi	r2,fp,-1080
 d046e58:	d8800015 	stw	r2,0(sp)
 d046e5c:	e13fff17 	ldw	r4,-4(fp)
 d046e60:	01434174 	movhi	r5,3333
 d046e64:	29488f04 	addi	r5,r5,8764
 d046e68:	d020b640 	call	d020b64 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 d046e6c:	00834174 	movhi	r2,3333
 d046e70:	109b4504 	addi	r2,r2,27924
 d046e74:	10c00017 	ldw	r3,0(r2)
 d046e78:	e0bee217 	ldw	r2,-1144(fp)
 d046e7c:	18bfc936 	bltu	r3,r2,d046da4 <u_mctest_run+0x488>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 d046e80:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 d046e84:	e1fffd04 	addi	r7,fp,-12
 d046e88:	00800044 	movi	r2,1
 d046e8c:	d8800015 	stw	r2,0(sp)
 d046e90:	e13ee517 	ldw	r4,-1132(fp)
 d046e94:	017fffc4 	movi	r5,-1
 d046e98:	01840584 	movi	r6,4118
 d046e9c:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046ea0:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 d046ea4:	e0bee317 	ldw	r2,-1140(fp)
 d046ea8:	10bfffd8 	cmpnei	r2,r2,-1
 d046eac:	1000071e 	bne	r2,zero,d046ecc <u_mctest_run+0x5b0>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 d046eb0:	e13ee517 	ldw	r4,-1132(fp)
 d046eb4:	d02a20c0 	call	d02a20c <t_errno>
 d046eb8:	100d883a 	mov	r6,r2
 d046ebc:	e13fff17 	ldw	r4,-4(fp)
 d046ec0:	01434174 	movhi	r5,3333
 d046ec4:	29489604 	addi	r5,r5,8792
 d046ec8:	d020b640 	call	d020b64 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 d046ecc:	e0bee417 	ldw	r2,-1136(fp)
 d046ed0:	10800044 	addi	r2,r2,1
 d046ed4:	e0bee415 	stw	r2,-1136(fp)
 d046ed8:	e0bee417 	ldw	r2,-1136(fp)
 d046edc:	108000d0 	cmplti	r2,r2,3
 d046ee0:	103f781e 	bne	r2,zero,d046cc4 <u_mctest_run+0x3a8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 d046ee4:	01034174 	movhi	r4,3333
 d046ee8:	21083304 	addi	r4,r4,8396
 d046eec:	d047a640 	call	d047a64 <inet_addr>
 d046ef0:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d046ef4:	008341b4 	movhi	r2,3334
 d046ef8:	10825a04 	addi	r2,r2,2408
 d046efc:	10800a17 	ldw	r2,40(r2)
 d046f00:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 d046f04:	e1fffb04 	addi	r7,fp,-20
 d046f08:	00800204 	movi	r2,8
 d046f0c:	d8800015 	stw	r2,0(sp)
 d046f10:	e13ee517 	ldw	r4,-1132(fp)
 d046f14:	000b883a 	mov	r5,zero
 d046f18:	01800344 	movi	r6,13
 d046f1c:	d0295ac0 	call	d0295ac <t_setsockopt>
 d046f20:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d046f24:	e0bee317 	ldw	r2,-1140(fp)
 d046f28:	10bfffd8 	cmpnei	r2,r2,-1
 d046f2c:	1000071e 	bne	r2,zero,d046f4c <u_mctest_run+0x630>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 d046f30:	e13ee517 	ldw	r4,-1132(fp)
 d046f34:	d02a20c0 	call	d02a20c <t_errno>
 d046f38:	100d883a 	mov	r6,r2
 d046f3c:	e13fff17 	ldw	r4,-4(fp)
 d046f40:	01434174 	movhi	r5,3333
 d046f44:	2948a204 	addi	r5,r5,8840
 d046f48:	d020b640 	call	d020b64 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 d046f4c:	e13ee517 	ldw	r4,-1132(fp)
 d046f50:	d02a0a40 	call	d02a0a4 <t_socketclose>
 d046f54:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d046f58:	e0bee317 	ldw	r2,-1140(fp)
 d046f5c:	10bfffd8 	cmpnei	r2,r2,-1
 d046f60:	1000071e 	bne	r2,zero,d046f80 <u_mctest_run+0x664>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 d046f64:	e13ee517 	ldw	r4,-1132(fp)
 d046f68:	d02a20c0 	call	d02a20c <t_errno>
 d046f6c:	100d883a 	mov	r6,r2
 d046f70:	e13fff17 	ldw	r4,-4(fp)
 d046f74:	01434174 	movhi	r5,3333
 d046f78:	2948af04 	addi	r5,r5,8892
 d046f7c:	d020b640 	call	d020b64 <ns_printf>
   }

   return(0);
 d046f80:	0005883a 	mov	r2,zero
}  /* end main() */  
 d046f84:	e037883a 	mov	sp,fp
 d046f88:	dfc00117 	ldw	ra,4(sp)
 d046f8c:	df000017 	ldw	fp,0(sp)
 d046f90:	dec00204 	addi	sp,sp,8
 d046f94:	f800283a 	ret

0d046f98 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 d046f98:	defff504 	addi	sp,sp,-44
 d046f9c:	dfc00a15 	stw	ra,40(sp)
 d046fa0:	df000915 	stw	fp,36(sp)
 d046fa4:	dc000815 	stw	r16,32(sp)
 d046fa8:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 d046fac:	e03ff815 	stw	zero,-32(fp)

   e = dhc_init();
 d046fb0:	d0218d40 	call	d0218d4 <dhc_init>
 d046fb4:	e0bff915 	stw	r2,-28(fp)

   if (e)
 d046fb8:	e0bff917 	ldw	r2,-28(fp)
 d046fbc:	1005003a 	cmpeq	r2,r2,zero
 d046fc0:	1000051e 	bne	r2,zero,d046fd8 <dhc_setup+0x40>
   {
      printf("Error starting DHCP client code.\n");
 d046fc4:	01034174 	movhi	r4,3333
 d046fc8:	2108c004 	addi	r4,r4,8960
 d046fcc:	d002bc80 	call	d002bc8 <puts>
      netexit(1);
 d046fd0:	01000044 	movi	r4,1
 d046fd4:	d043a680 	call	d043a68 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 d046fd8:	00834174 	movhi	r2,3333
 d046fdc:	109b4504 	addi	r2,r2,27924
 d046fe0:	10800017 	ldw	r2,0(r2)
 d046fe4:	e0bffa15 	stw	r2,-24(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 d046fe8:	e03ffb15 	stw	zero,-20(fp)
 d046fec:	00005206 	br	d047138 <dhc_setup+0x1a0>
   {
      if (!nets[iface])
 d046ff0:	e0bffb17 	ldw	r2,-20(fp)
 d046ff4:	00c341b4 	movhi	r3,3334
 d046ff8:	18c31a04 	addi	r3,r3,3176
 d046ffc:	1085883a 	add	r2,r2,r2
 d047000:	1085883a 	add	r2,r2,r2
 d047004:	10c5883a 	add	r2,r2,r3
 d047008:	10800017 	ldw	r2,0(r2)
 d04700c:	1005003a 	cmpeq	r2,r2,zero
 d047010:	1000461e 	bne	r2,zero,d04712c <dhc_setup+0x194>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 d047014:	e0bffb17 	ldw	r2,-20(fp)
 d047018:	00c341b4 	movhi	r3,3334
 d04701c:	18c31a04 	addi	r3,r3,3176
 d047020:	1085883a 	add	r2,r2,r2
 d047024:	1085883a 	add	r2,r2,r2
 d047028:	10c5883a 	add	r2,r2,r3
 d04702c:	10800017 	ldw	r2,0(r2)
 d047030:	10802a17 	ldw	r2,168(r2)
 d047034:	1080400c 	andi	r2,r2,256
 d047038:	1005003a 	cmpeq	r2,r2,zero
 d04703c:	10003b1e 	bne	r2,zero,d04712c <dhc_setup+0x194>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 d047040:	e13ffb17 	ldw	r4,-20(fp)
 d047044:	040341b4 	movhi	r16,3334
 d047048:	84034004 	addi	r16,r16,3328
 d04704c:	01400f04 	movi	r5,60
 d047050:	d00235c0 	call	d00235c <__mulsi3>
 d047054:	1405883a 	add	r2,r2,r16
 d047058:	10800e04 	addi	r2,r2,56
 d04705c:	10800017 	ldw	r2,0(r2)
 d047060:	1004c03a 	cmpne	r2,r2,zero
 d047064:	1000041e 	bne	r2,zero,d047078 <dhc_setup+0xe0>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 d047068:	e13ffb17 	ldw	r4,-20(fp)
 d04706c:	01434134 	movhi	r5,3332
 d047070:	295c8a04 	addi	r5,r5,29224
 d047074:	d0219a00 	call	d0219a0 <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 d047078:	e13ffb17 	ldw	r4,-20(fp)
 d04707c:	e0bffb17 	ldw	r2,-20(fp)
 d047080:	00c341b4 	movhi	r3,3334
 d047084:	18c31a04 	addi	r3,r3,3176
 d047088:	1085883a 	add	r2,r2,r2
 d04708c:	1085883a 	add	r2,r2,r2
 d047090:	10c5883a 	add	r2,r2,r3
 d047094:	10800017 	ldw	r2,0(r2)
 d047098:	10c00a17 	ldw	r3,40(r2)
 d04709c:	2105883a 	add	r2,r4,r4
 d0470a0:	1085883a 	add	r2,r2,r2
 d0470a4:	e13ff804 	addi	r4,fp,-32
 d0470a8:	1105883a 	add	r2,r2,r4
 d0470ac:	10800404 	addi	r2,r2,16
 d0470b0:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 d0470b4:	e0bffb17 	ldw	r2,-20(fp)
 d0470b8:	1085883a 	add	r2,r2,r2
 d0470bc:	1085883a 	add	r2,r2,r2
 d0470c0:	e0fff804 	addi	r3,fp,-32
 d0470c4:	10c5883a 	add	r2,r2,r3
 d0470c8:	10800404 	addi	r2,r2,16
 d0470cc:	10800017 	ldw	r2,0(r2)
 d0470d0:	1004c03a 	cmpne	r2,r2,zero
 d0470d4:	1000041e 	bne	r2,zero,d0470e8 <dhc_setup+0x150>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 d0470d8:	e13ffb17 	ldw	r4,-20(fp)
 d0470dc:	01400044 	movi	r5,1
 d0470e0:	d02484c0 	call	d02484c <dhc_state_init>
 d0470e4:	00000306 	br	d0470f4 <dhc_setup+0x15c>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 d0470e8:	e13ffb17 	ldw	r4,-20(fp)
 d0470ec:	000b883a 	mov	r5,zero
 d0470f0:	d02484c0 	call	d02484c <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 d0470f4:	d023f980 	call	d023f98 <dhc_second>
 d0470f8:	e0bff915 	stw	r2,-28(fp)
      if (e)
 d0470fc:	e0bff917 	ldw	r2,-28(fp)
 d047100:	1005003a 	cmpeq	r2,r2,zero
 d047104:	1000061e 	bne	r2,zero,d047120 <dhc_setup+0x188>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 d047108:	01034174 	movhi	r4,3333
 d04710c:	2108c904 	addi	r4,r4,8996
 d047110:	e17ffb17 	ldw	r5,-20(fp)
 d047114:	d0028a00 	call	d0028a0 <printf>
         netexit(1);
 d047118:	01000044 	movi	r4,1
 d04711c:	d043a680 	call	d043a68 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 d047120:	e0bff817 	ldw	r2,-32(fp)
 d047124:	10800044 	addi	r2,r2,1
 d047128:	e0bff815 	stw	r2,-32(fp)
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 d04712c:	e0bffb17 	ldw	r2,-20(fp)
 d047130:	10800044 	addi	r2,r2,1
 d047134:	e0bffb15 	stw	r2,-20(fp)
 d047138:	e0bffb17 	ldw	r2,-20(fp)
 d04713c:	10800110 	cmplti	r2,r2,4
 d047140:	103fab1e 	bne	r2,zero,d046ff0 <dhc_setup+0x58>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 d047144:	e0bff817 	ldw	r2,-32(fp)
 d047148:	1005003a 	cmpeq	r2,r2,zero
 d04714c:	1000301e 	bne	r2,zero,d047210 <dhc_setup+0x278>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 d047150:	00000206 	br	d04715c <dhc_setup+0x1c4>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 d047154:	d0216100 	call	d021610 <tk_yield>
      pktdemux();
 d047158:	d01de180 	call	d01de18 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 d04715c:	00834174 	movhi	r2,3333
 d047160:	109b4504 	addi	r2,r2,27924
 d047164:	10c00017 	ldw	r3,0(r2)
 d047168:	e0bffa17 	ldw	r2,-24(fp)
 d04716c:	1885c83a 	sub	r2,r3,r2
 d047170:	108cb228 	cmpgeui	r2,r2,13000
 d047174:	1000031e 	bne	r2,zero,d047184 <dhc_setup+0x1ec>
 d047178:	d0248ac0 	call	d0248ac <dhc_alldone>
 d04717c:	1005003a 	cmpeq	r2,r2,zero
 d047180:	103ff41e 	bne	r2,zero,d047154 <dhc_setup+0x1bc>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 d047184:	d0248ac0 	call	d0248ac <dhc_alldone>
 d047188:	1004c03a 	cmpne	r2,r2,zero
 d04718c:	1000201e 	bne	r2,zero,d047210 <dhc_setup+0x278>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 d047190:	01034174 	movhi	r4,3333
 d047194:	2108d304 	addi	r4,r4,9036
 d047198:	d002bc80 	call	d002bc8 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 d04719c:	e03ffb15 	stw	zero,-20(fp)
 d0471a0:	00001806 	br	d047204 <dhc_setup+0x26c>
      {
         if (dhc_ifacedone(iface) == FALSE)
 d0471a4:	e13ffb17 	ldw	r4,-20(fp)
 d0471a8:	d0249540 	call	d024954 <dhc_ifacedone>
 d0471ac:	1004c03a 	cmpne	r2,r2,zero
 d0471b0:	1000111e 	bne	r2,zero,d0471f8 <dhc_setup+0x260>
         {
            dhc_halt(iface);
 d0471b4:	e13ffb17 	ldw	r4,-20(fp)
 d0471b8:	d0245b40 	call	d0245b4 <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 d0471bc:	e0bffb17 	ldw	r2,-20(fp)
 d0471c0:	00c341b4 	movhi	r3,3334
 d0471c4:	18c31a04 	addi	r3,r3,3176
 d0471c8:	1085883a 	add	r2,r2,r2
 d0471cc:	1085883a 	add	r2,r2,r2
 d0471d0:	10c5883a 	add	r2,r2,r3
 d0471d4:	10c00017 	ldw	r3,0(r2)
 d0471d8:	e0bffb17 	ldw	r2,-20(fp)
 d0471dc:	1085883a 	add	r2,r2,r2
 d0471e0:	1085883a 	add	r2,r2,r2
 d0471e4:	e13ff804 	addi	r4,fp,-32
 d0471e8:	1105883a 	add	r2,r2,r4
 d0471ec:	10800404 	addi	r2,r2,16
 d0471f0:	10800017 	ldw	r2,0(r2)
 d0471f4:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 d0471f8:	e0bffb17 	ldw	r2,-20(fp)
 d0471fc:	10800044 	addi	r2,r2,1
 d047200:	e0bffb15 	stw	r2,-20(fp)
 d047204:	e0bffb17 	ldw	r2,-20(fp)
 d047208:	10800110 	cmplti	r2,r2,4
 d04720c:	103fe51e 	bne	r2,zero,d0471a4 <dhc_setup+0x20c>
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 d047210:	e037883a 	mov	sp,fp
 d047214:	dfc00217 	ldw	ra,8(sp)
 d047218:	df000117 	ldw	fp,4(sp)
 d04721c:	dc000017 	ldw	r16,0(sp)
 d047220:	dec00304 	addi	sp,sp,12
 d047224:	f800283a 	ret

0d047228 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 d047228:	defffc04 	addi	sp,sp,-16
 d04722c:	dfc00315 	stw	ra,12(sp)
 d047230:	df000215 	stw	fp,8(sp)
 d047234:	df000204 	addi	fp,sp,8
 d047238:	e13ffe15 	stw	r4,-8(fp)
 d04723c:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 d047240:	e0bfff17 	ldw	r2,-4(fp)
 d047244:	10800198 	cmpnei	r2,r2,6
 d047248:	1000321e 	bne	r2,zero,d047314 <dhc_main_ipset+0xec>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 d04724c:	e0bffe17 	ldw	r2,-8(fp)
 d047250:	00c341b4 	movhi	r3,3334
 d047254:	18c31a04 	addi	r3,r3,3176
 d047258:	1085883a 	add	r2,r2,r2
 d04725c:	1085883a 	add	r2,r2,r2
 d047260:	10c5883a 	add	r2,r2,r3
 d047264:	10800017 	ldw	r2,0(r2)
 d047268:	11400104 	addi	r5,r2,4
 d04726c:	01034174 	movhi	r4,3333
 d047270:	2108e104 	addi	r4,r4,9092
 d047274:	d0028a00 	call	d0028a0 <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 d047278:	e0bffe17 	ldw	r2,-8(fp)
 d04727c:	00c341b4 	movhi	r3,3334
 d047280:	18c31a04 	addi	r3,r3,3176
 d047284:	1085883a 	add	r2,r2,r2
 d047288:	1085883a 	add	r2,r2,r2
 d04728c:	10c5883a 	add	r2,r2,r3
 d047290:	10800017 	ldw	r2,0(r2)
 d047294:	11000a17 	ldw	r4,40(r2)
 d047298:	d02079c0 	call	d02079c <print_ipad>
 d04729c:	100b883a 	mov	r5,r2
 d0472a0:	01034174 	movhi	r4,3333
 d0472a4:	2108ef04 	addi	r4,r4,9148
 d0472a8:	d0028a00 	call	d0028a0 <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 d0472ac:	e0bffe17 	ldw	r2,-8(fp)
 d0472b0:	00c341b4 	movhi	r3,3334
 d0472b4:	18c31a04 	addi	r3,r3,3176
 d0472b8:	1085883a 	add	r2,r2,r2
 d0472bc:	1085883a 	add	r2,r2,r2
 d0472c0:	10c5883a 	add	r2,r2,r3
 d0472c4:	10800017 	ldw	r2,0(r2)
 d0472c8:	11000c17 	ldw	r4,48(r2)
 d0472cc:	d02079c0 	call	d02079c <print_ipad>
 d0472d0:	100b883a 	mov	r5,r2
 d0472d4:	01034174 	movhi	r4,3333
 d0472d8:	2108f404 	addi	r4,r4,9168
 d0472dc:	d0028a00 	call	d0028a0 <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 d0472e0:	e0bffe17 	ldw	r2,-8(fp)
 d0472e4:	00c341b4 	movhi	r3,3334
 d0472e8:	18c31a04 	addi	r3,r3,3176
 d0472ec:	1085883a 	add	r2,r2,r2
 d0472f0:	1085883a 	add	r2,r2,r2
 d0472f4:	10c5883a 	add	r2,r2,r3
 d0472f8:	10800017 	ldw	r2,0(r2)
 d0472fc:	11000d17 	ldw	r4,52(r2)
 d047300:	d02079c0 	call	d02079c <print_ipad>
 d047304:	100b883a 	mov	r5,r2
 d047308:	01034174 	movhi	r4,3333
 d04730c:	2108f904 	addi	r4,r4,9188
 d047310:	d0028a00 	call	d0028a0 <printf>
   }
   return 0;
 d047314:	0005883a 	mov	r2,zero
}
 d047318:	e037883a 	mov	sp,fp
 d04731c:	dfc00117 	ldw	ra,4(sp)
 d047320:	df000017 	ldw	fp,0(sp)
 d047324:	dec00204 	addi	sp,sp,8
 d047328:	f800283a 	ret

0d04732c <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 d04732c:	deffff04 	addi	sp,sp,-4
 d047330:	df000015 	stw	fp,0(sp)
 d047334:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 d047338:	00834174 	movhi	r2,3333
 d04733c:	109b7204 	addi	r2,r2,28104
 d047340:	10c00017 	ldw	r3,0(r2)
 d047344:	00834174 	movhi	r2,3333
 d047348:	1091c404 	addi	r2,r2,18192
 d04734c:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 d047350:	00c34174 	movhi	r3,3333
 d047354:	18db7204 	addi	r3,r3,28104
 d047358:	00834174 	movhi	r2,3333
 d04735c:	1091c404 	addi	r2,r2,18192
 d047360:	18800015 	stw	r2,0(r3)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 d047364:	00834174 	movhi	r2,3333
 d047368:	109b7404 	addi	r2,r2,28112
 d04736c:	10c00017 	ldw	r3,0(r2)
 d047370:	00834174 	movhi	r2,3333
 d047374:	1091cd04 	addi	r2,r2,18228
 d047378:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 d04737c:	00c34174 	movhi	r3,3333
 d047380:	18d1ee04 	addi	r3,r3,18360
 d047384:	00834174 	movhi	r2,3333
 d047388:	109b7404 	addi	r2,r2,28112
 d04738c:	10c00015 	stw	r3,0(r2)

   return 0;
 d047390:	0005883a 	mov	r2,zero
}
 d047394:	e037883a 	mov	sp,fp
 d047398:	df000017 	ldw	fp,0(sp)
 d04739c:	dec00104 	addi	sp,sp,4
 d0473a0:	f800283a 	ret

0d0473a4 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 d0473a4:	defffd04 	addi	sp,sp,-12
 d0473a8:	df000215 	stw	fp,8(sp)
 d0473ac:	df000204 	addi	fp,sp,8
 d0473b0:	e13ffe15 	stw	r4,-8(fp)
 d0473b4:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 d0473b8:	0005883a 	mov	r2,zero
}
 d0473bc:	e037883a 	mov	sp,fp
 d0473c0:	df000017 	ldw	fp,0(sp)
 d0473c4:	dec00104 	addi	sp,sp,4
 d0473c8:	f800283a 	ret

0d0473cc <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 d0473cc:	defffe04 	addi	sp,sp,-8
 d0473d0:	df000115 	stw	fp,4(sp)
 d0473d4:	df000104 	addi	fp,sp,4
 d0473d8:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 d0473dc:	e037883a 	mov	sp,fp
 d0473e0:	df000017 	ldw	fp,0(sp)
 d0473e4:	dec00104 	addi	sp,sp,4
 d0473e8:	f800283a 	ret

0d0473ec <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d0473ec:	defff604 	addi	sp,sp,-40
 d0473f0:	dfc00915 	stw	ra,36(sp)
 d0473f4:	df000815 	stw	fp,32(sp)
 d0473f8:	df000804 	addi	fp,sp,32
 d0473fc:	e13ffb15 	stw	r4,-20(fp)
 d047400:	e17ffc15 	stw	r5,-16(fp)
 d047404:	e1bffd15 	stw	r6,-12(fp)
 d047408:	e1fffe15 	stw	r7,-8(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 d04740c:	00800834 	movhi	r2,32
 d047410:	e0bff815 	stw	r2,-32(fp)
   if(vfd && vfd->file)
 d047414:	e0bffe17 	ldw	r2,-8(fp)
 d047418:	1005003a 	cmpeq	r2,r2,zero
 d04741c:	1000081e 	bne	r2,zero,d047440 <md_fread+0x54>
 d047420:	e0bffe17 	ldw	r2,-8(fp)
 d047424:	10800117 	ldw	r2,4(r2)
 d047428:	1005003a 	cmpeq	r2,r2,zero
 d04742c:	1000041e 	bne	r2,zero,d047440 <md_fread+0x54>
   {
      file_size = vfd->file->real_size; 
 d047430:	e0bffe17 	ldw	r2,-8(fp)
 d047434:	10800117 	ldw	r2,4(r2)
 d047438:	10800717 	ldw	r2,28(r2)
 d04743c:	e0bff815 	stw	r2,-32(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 d047440:	e0bffe17 	ldw	r2,-8(fp)
 d047444:	10800217 	ldw	r2,8(r2)
 d047448:	1007883a 	mov	r3,r2
 d04744c:	e0bffe17 	ldw	r2,-8(fp)
 d047450:	10800117 	ldw	r2,4(r2)
 d047454:	10800617 	ldw	r2,24(r2)
 d047458:	1885c83a 	sub	r2,r3,r2
 d04745c:	e0bff915 	stw	r2,-28(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 d047460:	e13ffd17 	ldw	r4,-12(fp)
 d047464:	e17ffc17 	ldw	r5,-16(fp)
 d047468:	d00235c0 	call	d00235c <__mulsi3>
 d04746c:	e0bffa15 	stw	r2,-24(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 d047470:	e0fff917 	ldw	r3,-28(fp)
 d047474:	e0bffa17 	ldw	r2,-24(fp)
 d047478:	1887883a 	add	r3,r3,r2
 d04747c:	e0bff817 	ldw	r2,-32(fp)
 d047480:	10c0042e 	bgeu	r2,r3,d047494 <md_fread+0xa8>
      bcount = ((u_long)file_size - location);
 d047484:	e0bff817 	ldw	r2,-32(fp)
 d047488:	e0fff917 	ldw	r3,-28(fp)
 d04748c:	10c5c83a 	sub	r2,r2,r3
 d047490:	e0bffa15 	stw	r2,-24(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 d047494:	e0fff917 	ldw	r3,-28(fp)
 d047498:	e0bff817 	ldw	r2,-32(fp)
 d04749c:	1880072e 	bgeu	r3,r2,d0474bc <md_fread+0xd0>
 d0474a0:	e0bffa17 	ldw	r2,-24(fp)
 d0474a4:	10bfffec 	andhi	r2,r2,65535
 d0474a8:	1004c03a 	cmpne	r2,r2,zero
 d0474ac:	1000031e 	bne	r2,zero,d0474bc <md_fread+0xd0>
 d0474b0:	e0bffa17 	ldw	r2,-24(fp)
 d0474b4:	1004c03a 	cmpne	r2,r2,zero
 d0474b8:	1000021e 	bne	r2,zero,d0474c4 <md_fread+0xd8>
      (bcount  & 0xFFFF0000) ||
      (bcount == 0))
   {
      return 0;
 d0474bc:	e03fff15 	stw	zero,-4(fp)
 d0474c0:	00002406 	br	d047554 <md_fread+0x168>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 d0474c4:	e0bffe17 	ldw	r2,-8(fp)
 d0474c8:	10800117 	ldw	r2,4(r2)
 d0474cc:	1080058b 	ldhu	r2,22(r2)
 d0474d0:	10bfffcc 	andi	r2,r2,65535
 d0474d4:	10a0001c 	xori	r2,r2,32768
 d0474d8:	10a00004 	addi	r2,r2,-32768
 d0474dc:	1004803a 	cmplt	r2,r2,zero
 d0474e0:	1000111e 	bne	r2,zero,d047528 <md_fread+0x13c>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 d0474e4:	e0bffe17 	ldw	r2,-8(fp)
 d0474e8:	10800117 	ldw	r2,4(r2)
 d0474ec:	10800103 	ldbu	r2,4(r2)
 d0474f0:	10803fcc 	andi	r2,r2,255
 d0474f4:	1080201c 	xori	r2,r2,128
 d0474f8:	10bfe004 	addi	r2,r2,-128
 d0474fc:	10801b58 	cmpnei	r2,r2,109
 d047500:	1000091e 	bne	r2,zero,d047528 <md_fread+0x13c>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 d047504:	e0bffe17 	ldw	r2,-8(fp)
 d047508:	10c00217 	ldw	r3,8(r2)
 d04750c:	00800834 	movhi	r2,32
 d047510:	1887883a 	add	r3,r3,r2
 d047514:	e0bffb17 	ldw	r2,-20(fp)
 d047518:	1009883a 	mov	r4,r2
 d04751c:	180b883a 	mov	r5,r3
 d047520:	e1bffa17 	ldw	r6,-24(fp)
 d047524:	d0026080 	call	d002608 <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 d047528:	e0bffe17 	ldw	r2,-8(fp)
 d04752c:	10c00217 	ldw	r3,8(r2)
 d047530:	e0bffa17 	ldw	r2,-24(fp)
 d047534:	1887883a 	add	r3,r3,r2
 d047538:	e0bffe17 	ldw	r2,-8(fp)
 d04753c:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 d047540:	e0bffa17 	ldw	r2,-24(fp)
 d047544:	1009883a 	mov	r4,r2
 d047548:	e17ffc17 	ldw	r5,-16(fp)
 d04754c:	d00c90c0 	call	d00c90c <__udivsi3>
 d047550:	e0bfff15 	stw	r2,-4(fp)
 d047554:	e0bfff17 	ldw	r2,-4(fp)
}
 d047558:	e037883a 	mov	sp,fp
 d04755c:	dfc00117 	ldw	ra,4(sp)
 d047560:	df000017 	ldw	fp,0(sp)
 d047564:	dec00204 	addi	sp,sp,8
 d047568:	f800283a 	ret

0d04756c <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d04756c:	defff804 	addi	sp,sp,-32
 d047570:	dfc00715 	stw	ra,28(sp)
 d047574:	df000615 	stw	fp,24(sp)
 d047578:	dc000515 	stw	r16,20(sp)
 d04757c:	df000504 	addi	fp,sp,20
 d047580:	e13ffb15 	stw	r4,-20(fp)
 d047584:	e17ffc15 	stw	r5,-16(fp)
 d047588:	e1bffd15 	stw	r6,-12(fp)
 d04758c:	e1fffe15 	stw	r7,-8(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 d047590:	e0bffe17 	ldw	r2,-8(fp)
 d047594:	10800117 	ldw	r2,4(r2)
 d047598:	10800103 	ldbu	r2,4(r2)
 d04759c:	10803fcc 	andi	r2,r2,255
 d0475a0:	1080201c 	xori	r2,r2,128
 d0475a4:	10bfe004 	addi	r2,r2,-128
 d0475a8:	10801b58 	cmpnei	r2,r2,109
 d0475ac:	1000021e 	bne	r2,zero,d0475b8 <md_fwrite+0x4c>
      return 0;   /* not writable device */
 d0475b0:	e03fff15 	stw	zero,-4(fp)
 d0475b4:	00000a06 	br	d0475e0 <md_fwrite+0x74>

   vfd->cmploc += (items * size);   /* adjust location */
 d0475b8:	e0bffe17 	ldw	r2,-8(fp)
 d0475bc:	14000217 	ldw	r16,8(r2)
 d0475c0:	e13ffd17 	ldw	r4,-12(fp)
 d0475c4:	e17ffc17 	ldw	r5,-16(fp)
 d0475c8:	d00235c0 	call	d00235c <__mulsi3>
 d0475cc:	8087883a 	add	r3,r16,r2
 d0475d0:	e0bffe17 	ldw	r2,-8(fp)
 d0475d4:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 d0475d8:	e0bffd17 	ldw	r2,-12(fp)
 d0475dc:	e0bfff15 	stw	r2,-4(fp)
 d0475e0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0475e4:	e037883a 	mov	sp,fp
 d0475e8:	dfc00217 	ldw	ra,8(sp)
 d0475ec:	df000117 	ldw	fp,4(sp)
 d0475f0:	dc000017 	ldw	r16,0(sp)
 d0475f4:	dec00304 	addi	sp,sp,12
 d0475f8:	f800283a 	ret

0d0475fc <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 d0475fc:	defffc04 	addi	sp,sp,-16
 d047600:	df000315 	stw	fp,12(sp)
 d047604:	df000304 	addi	fp,sp,12
 d047608:	e13ffd15 	stw	r4,-12(fp)
 d04760c:	e17ffe15 	stw	r5,-8(fp)
 d047610:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 d047614:	0005883a 	mov	r2,zero
}
 d047618:	e037883a 	mov	sp,fp
 d04761c:	df000017 	ldw	fp,0(sp)
 d047620:	dec00104 	addi	sp,sp,4
 d047624:	f800283a 	ret

0d047628 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 d047628:	defffe04 	addi	sp,sp,-8
 d04762c:	df000115 	stw	fp,4(sp)
 d047630:	df000104 	addi	fp,sp,4
 d047634:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 d047638:	00800834 	movhi	r2,32
}
 d04763c:	e037883a 	mov	sp,fp
 d047640:	df000017 	ldw	fp,0(sp)
 d047644:	dec00104 	addi	sp,sp,4
 d047648:	f800283a 	ret

0d04764c <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 d04764c:	defffb04 	addi	sp,sp,-20
 d047650:	df000415 	stw	fp,16(sp)
 d047654:	df000404 	addi	fp,sp,16
 d047658:	e13ffe15 	stw	r4,-8(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 d04765c:	e03ffc15 	stw	zero,-16(fp)

   location = vfd->cmploc - vfd->file->data;
 d047660:	e0bffe17 	ldw	r2,-8(fp)
 d047664:	10800217 	ldw	r2,8(r2)
 d047668:	1007883a 	mov	r3,r2
 d04766c:	e0bffe17 	ldw	r2,-8(fp)
 d047670:	10800117 	ldw	r2,4(r2)
 d047674:	10800617 	ldw	r2,24(r2)
 d047678:	1885c83a 	sub	r2,r3,r2
 d04767c:	e0bffd15 	stw	r2,-12(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 d047680:	e0bffe17 	ldw	r2,-8(fp)
 d047684:	10800117 	ldw	r2,4(r2)
 d047688:	10c00717 	ldw	r3,28(r2)
 d04768c:	e0bffd17 	ldw	r2,-12(fp)
 d047690:	10c00336 	bltu	r2,r3,d0476a0 <md_fgetc+0x54>
      return EOF;
 d047694:	00bfffc4 	movi	r2,-1
 d047698:	e0bfff15 	stw	r2,-4(fp)
 d04769c:	00001c06 	br	d047710 <md_fgetc+0xc4>

   if (!(vfd->file->flags & VF_NODATA))
 d0476a0:	e0bffe17 	ldw	r2,-8(fp)
 d0476a4:	10800117 	ldw	r2,4(r2)
 d0476a8:	1080058b 	ldhu	r2,22(r2)
 d0476ac:	10bfffcc 	andi	r2,r2,65535
 d0476b0:	10a0001c 	xori	r2,r2,32768
 d0476b4:	10a00004 	addi	r2,r2,-32768
 d0476b8:	1004803a 	cmplt	r2,r2,zero
 d0476bc:	10000d1e 	bne	r2,zero,d0476f4 <md_fgetc+0xa8>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 d0476c0:	e0bffe17 	ldw	r2,-8(fp)
 d0476c4:	10800117 	ldw	r2,4(r2)
 d0476c8:	10800103 	ldbu	r2,4(r2)
 d0476cc:	10803fcc 	andi	r2,r2,255
 d0476d0:	1080201c 	xori	r2,r2,128
 d0476d4:	10bfe004 	addi	r2,r2,-128
 d0476d8:	10801b58 	cmpnei	r2,r2,109
 d0476dc:	1000051e 	bne	r2,zero,d0476f4 <md_fgetc+0xa8>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 d0476e0:	e0bffe17 	ldw	r2,-8(fp)
 d0476e4:	10800217 	ldw	r2,8(r2)
 d0476e8:	10800003 	ldbu	r2,0(r2)
 d0476ec:	10803fcc 	andi	r2,r2,255
 d0476f0:	e0bffc15 	stw	r2,-16(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 d0476f4:	e0bffe17 	ldw	r2,-8(fp)
 d0476f8:	10800217 	ldw	r2,8(r2)
 d0476fc:	10c00044 	addi	r3,r2,1
 d047700:	e0bffe17 	ldw	r2,-8(fp)
 d047704:	10c00215 	stw	r3,8(r2)
   return retval;
 d047708:	e0bffc17 	ldw	r2,-16(fp)
 d04770c:	e0bfff15 	stw	r2,-4(fp)
 d047710:	e0bfff17 	ldw	r2,-4(fp)
}
 d047714:	e037883a 	mov	sp,fp
 d047718:	df000017 	ldw	fp,0(sp)
 d04771c:	dec00104 	addi	sp,sp,4
 d047720:	f800283a 	ret

0d047724 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 d047724:	defffe04 	addi	sp,sp,-8
 d047728:	df000115 	stw	fp,4(sp)
 d04772c:	df000104 	addi	fp,sp,4
 d047730:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 d047734:	0005883a 	mov	r2,zero
}
 d047738:	e037883a 	mov	sp,fp
 d04773c:	df000017 	ldw	fp,0(sp)
 d047740:	dec00104 	addi	sp,sp,4
 d047744:	f800283a 	ret

0d047748 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 d047748:	defff504 	addi	sp,sp,-44
 d04774c:	dfc00a15 	stw	ra,40(sp)
 d047750:	df000915 	stw	fp,36(sp)
 d047754:	df000904 	addi	fp,sp,36
 d047758:	e13ffc15 	stw	r4,-16(fp)
 d04775c:	e17ffd15 	stw	r5,-12(fp)
 d047760:	e1bffe15 	stw	r6,-8(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 d047764:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 d047768:	00834174 	movhi	r2,3333
 d04776c:	1088fe04 	addi	r2,r2,9208
 d047770:	e0bff715 	stw	r2,-36(fp)

   cp = stringin;
 d047774:	e0bffe17 	ldw	r2,-8(fp)
 d047778:	e0bffa15 	stw	r2,-24(fp)
   while (*cp)
 d04777c:	00002606 	br	d047818 <parse_ipad+0xd0>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 d047780:	e0bffa17 	ldw	r2,-24(fp)
 d047784:	10800003 	ldbu	r2,0(r2)
 d047788:	10803fcc 	andi	r2,r2,255
 d04778c:	1080201c 	xori	r2,r2,128
 d047790:	10bfe004 	addi	r2,r2,-128
 d047794:	10800e88 	cmpgei	r2,r2,58
 d047798:	10000e1e 	bne	r2,zero,d0477d4 <parse_ipad+0x8c>
 d04779c:	e0bffa17 	ldw	r2,-24(fp)
 d0477a0:	10800003 	ldbu	r2,0(r2)
 d0477a4:	10803fcc 	andi	r2,r2,255
 d0477a8:	1080201c 	xori	r2,r2,128
 d0477ac:	10bfe004 	addi	r2,r2,-128
 d0477b0:	10800b90 	cmplti	r2,r2,46
 d0477b4:	1000071e 	bne	r2,zero,d0477d4 <parse_ipad+0x8c>
 d0477b8:	e0bffa17 	ldw	r2,-24(fp)
 d0477bc:	10800003 	ldbu	r2,0(r2)
 d0477c0:	10803fcc 	andi	r2,r2,255
 d0477c4:	1080201c 	xori	r2,r2,128
 d0477c8:	10bfe004 	addi	r2,r2,-128
 d0477cc:	10800bd8 	cmpnei	r2,r2,47
 d0477d0:	1000041e 	bne	r2,zero,d0477e4 <parse_ipad+0x9c>
         return("all chars must be digits (0-9) or dots (.)");
 d0477d4:	00834174 	movhi	r2,3333
 d0477d8:	10890704 	addi	r2,r2,9244
 d0477dc:	e0bfff15 	stw	r2,-4(fp)
 d0477e0:	00009a06 	br	d047a4c <parse_ipad+0x304>
      if (*cp == '.')dots++;
 d0477e4:	e0bffa17 	ldw	r2,-24(fp)
 d0477e8:	10800003 	ldbu	r2,0(r2)
 d0477ec:	10803fcc 	andi	r2,r2,255
 d0477f0:	1080201c 	xori	r2,r2,128
 d0477f4:	10bfe004 	addi	r2,r2,-128
 d0477f8:	10800b98 	cmpnei	r2,r2,46
 d0477fc:	1000031e 	bne	r2,zero,d04780c <parse_ipad+0xc4>
 d047800:	e0bff917 	ldw	r2,-28(fp)
 d047804:	10800044 	addi	r2,r2,1
 d047808:	e0bff915 	stw	r2,-28(fp)
         cp++;
 d04780c:	e0bffa17 	ldw	r2,-24(fp)
 d047810:	10800044 	addi	r2,r2,1
 d047814:	e0bffa15 	stw	r2,-24(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 d047818:	e0bffa17 	ldw	r2,-24(fp)
 d04781c:	10800003 	ldbu	r2,0(r2)
 d047820:	10803fcc 	andi	r2,r2,255
 d047824:	1080201c 	xori	r2,r2,128
 d047828:	10bfe004 	addi	r2,r2,-128
 d04782c:	1004c03a 	cmpne	r2,r2,zero
 d047830:	103fd31e 	bne	r2,zero,d047780 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 d047834:	e0bff917 	ldw	r2,-28(fp)
 d047838:	10800050 	cmplti	r2,r2,1
 d04783c:	1000031e 	bne	r2,zero,d04784c <parse_ipad+0x104>
 d047840:	e0bff917 	ldw	r2,-28(fp)
 d047844:	10800110 	cmplti	r2,r2,4
 d047848:	1000041e 	bne	r2,zero,d04785c <parse_ipad+0x114>
      return("string must contain 1 - 3 dots (.)");
 d04784c:	00834174 	movhi	r2,3333
 d047850:	10891204 	addi	r2,r2,9288
 d047854:	e0bfff15 	stw	r2,-4(fp)
 d047858:	00007c06 	br	d047a4c <parse_ipad+0x304>

   cp = stringin;
 d04785c:	e0bffe17 	ldw	r2,-8(fp)
 d047860:	e0bffa15 	stw	r2,-24(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 d047864:	e13ffa17 	ldw	r4,-24(fp)
 d047868:	d04bdbc0 	call	d04bdbc <atoi>
 d04786c:	e0bff815 	stw	r2,-32(fp)
 d047870:	e0bff817 	ldw	r2,-32(fp)
 d047874:	10804010 	cmplti	r2,r2,256
 d047878:	1000031e 	bne	r2,zero,d047888 <parse_ipad+0x140>
      return(toobig);
 d04787c:	e0bff717 	ldw	r2,-36(fp)
 d047880:	e0bfff15 	stw	r2,-4(fp)
 d047884:	00007106 	br	d047a4c <parse_ipad+0x304>

   retval.c[0] = (u_char)number;
 d047888:	e0bff817 	ldw	r2,-32(fp)
 d04788c:	e0bffb05 	stb	r2,-20(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 d047890:	00000306 	br	d0478a0 <parse_ipad+0x158>
 d047894:	e0bffa17 	ldw	r2,-24(fp)
 d047898:	10800044 	addi	r2,r2,1
 d04789c:	e0bffa15 	stw	r2,-24(fp)
 d0478a0:	e0bffa17 	ldw	r2,-24(fp)
 d0478a4:	10800003 	ldbu	r2,0(r2)
 d0478a8:	10803fcc 	andi	r2,r2,255
 d0478ac:	1080201c 	xori	r2,r2,128
 d0478b0:	10bfe004 	addi	r2,r2,-128
 d0478b4:	10800b98 	cmpnei	r2,r2,46
 d0478b8:	103ff61e 	bne	r2,zero,d047894 <parse_ipad+0x14c>
      cp++;             /* point past dot */
 d0478bc:	e0bffa17 	ldw	r2,-24(fp)
 d0478c0:	10800044 	addi	r2,r2,1
 d0478c4:	e0bffa15 	stw	r2,-24(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 d0478c8:	e0bff917 	ldw	r2,-28(fp)
 d0478cc:	10800060 	cmpeqi	r2,r2,1
 d0478d0:	1000031e 	bne	r2,zero,d0478e0 <parse_ipad+0x198>
 d0478d4:	e0bff917 	ldw	r2,-28(fp)
 d0478d8:	10800098 	cmpnei	r2,r2,2
 d0478dc:	1000021e 	bne	r2,zero,d0478e8 <parse_ipad+0x1a0>
 d0478e0:	e03ffb45 	stb	zero,-19(fp)
 d0478e4:	00001906 	br	d04794c <parse_ipad+0x204>
      else
   {
      number = atoi(cp);
 d0478e8:	e13ffa17 	ldw	r4,-24(fp)
 d0478ec:	d04bdbc0 	call	d04bdbc <atoi>
 d0478f0:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 d0478f4:	00000306 	br	d047904 <parse_ipad+0x1bc>
 d0478f8:	e0bffa17 	ldw	r2,-24(fp)
 d0478fc:	10800044 	addi	r2,r2,1
 d047900:	e0bffa15 	stw	r2,-24(fp)
 d047904:	e0bffa17 	ldw	r2,-24(fp)
 d047908:	10800003 	ldbu	r2,0(r2)
 d04790c:	10803fcc 	andi	r2,r2,255
 d047910:	1080201c 	xori	r2,r2,128
 d047914:	10bfe004 	addi	r2,r2,-128
 d047918:	10800b98 	cmpnei	r2,r2,46
 d04791c:	103ff61e 	bne	r2,zero,d0478f8 <parse_ipad+0x1b0>
         cp++;             /* point past dot */
 d047920:	e0bffa17 	ldw	r2,-24(fp)
 d047924:	10800044 	addi	r2,r2,1
 d047928:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 d04792c:	e0bff817 	ldw	r2,-32(fp)
 d047930:	10804010 	cmplti	r2,r2,256
 d047934:	1000031e 	bne	r2,zero,d047944 <parse_ipad+0x1fc>
 d047938:	e0bff717 	ldw	r2,-36(fp)
 d04793c:	e0bfff15 	stw	r2,-4(fp)
 d047940:	00004206 	br	d047a4c <parse_ipad+0x304>
         retval.c[1] = (u_char)number;
 d047944:	e0bff817 	ldw	r2,-32(fp)
 d047948:	e0bffb45 	stb	r2,-19(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 d04794c:	e0bff917 	ldw	r2,-28(fp)
 d047950:	10800058 	cmpnei	r2,r2,1
 d047954:	1000021e 	bne	r2,zero,d047960 <parse_ipad+0x218>
 d047958:	e03ffb85 	stb	zero,-18(fp)
 d04795c:	00001906 	br	d0479c4 <parse_ipad+0x27c>
      else
   {
      number = atoi(cp);
 d047960:	e13ffa17 	ldw	r4,-24(fp)
 d047964:	d04bdbc0 	call	d04bdbc <atoi>
 d047968:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 d04796c:	00000306 	br	d04797c <parse_ipad+0x234>
 d047970:	e0bffa17 	ldw	r2,-24(fp)
 d047974:	10800044 	addi	r2,r2,1
 d047978:	e0bffa15 	stw	r2,-24(fp)
 d04797c:	e0bffa17 	ldw	r2,-24(fp)
 d047980:	10800003 	ldbu	r2,0(r2)
 d047984:	10803fcc 	andi	r2,r2,255
 d047988:	1080201c 	xori	r2,r2,128
 d04798c:	10bfe004 	addi	r2,r2,-128
 d047990:	10800b98 	cmpnei	r2,r2,46
 d047994:	103ff61e 	bne	r2,zero,d047970 <parse_ipad+0x228>
         cp++;             /* point past dot */
 d047998:	e0bffa17 	ldw	r2,-24(fp)
 d04799c:	10800044 	addi	r2,r2,1
 d0479a0:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 d0479a4:	e0bff817 	ldw	r2,-32(fp)
 d0479a8:	10804010 	cmplti	r2,r2,256
 d0479ac:	1000031e 	bne	r2,zero,d0479bc <parse_ipad+0x274>
 d0479b0:	e0bff717 	ldw	r2,-36(fp)
 d0479b4:	e0bfff15 	stw	r2,-4(fp)
 d0479b8:	00002406 	br	d047a4c <parse_ipad+0x304>
         retval.c[2] = (u_char)number;
 d0479bc:	e0bff817 	ldw	r2,-32(fp)
 d0479c0:	e0bffb85 	stb	r2,-18(fp)
   }

   if ((number = atoi(cp)) > 255)
 d0479c4:	e13ffa17 	ldw	r4,-24(fp)
 d0479c8:	d04bdbc0 	call	d04bdbc <atoi>
 d0479cc:	e0bff815 	stw	r2,-32(fp)
 d0479d0:	e0bff817 	ldw	r2,-32(fp)
 d0479d4:	10804010 	cmplti	r2,r2,256
 d0479d8:	1000031e 	bne	r2,zero,d0479e8 <parse_ipad+0x2a0>
      return(toobig);
 d0479dc:	e0bff717 	ldw	r2,-36(fp)
 d0479e0:	e0bfff15 	stw	r2,-4(fp)
 d0479e4:	00001906 	br	d047a4c <parse_ipad+0x304>
   retval.c[3] = (u_char)number;
 d0479e8:	e0bff817 	ldw	r2,-32(fp)
 d0479ec:	e0bffbc5 	stb	r2,-17(fp)

   if (retval.c[0] < 128) *sbits = 8;
 d0479f0:	e0bffb03 	ldbu	r2,-20(fp)
 d0479f4:	10803fcc 	andi	r2,r2,255
 d0479f8:	10802028 	cmpgeui	r2,r2,128
 d0479fc:	1000041e 	bne	r2,zero,d047a10 <parse_ipad+0x2c8>
 d047a00:	e0fffd17 	ldw	r3,-12(fp)
 d047a04:	00800204 	movi	r2,8
 d047a08:	18800015 	stw	r2,0(r3)
 d047a0c:	00000b06 	br	d047a3c <parse_ipad+0x2f4>
      else if(retval.c[0] < 192) *sbits = 16;
 d047a10:	e0bffb03 	ldbu	r2,-20(fp)
 d047a14:	10803fcc 	andi	r2,r2,255
 d047a18:	10803028 	cmpgeui	r2,r2,192
 d047a1c:	1000041e 	bne	r2,zero,d047a30 <parse_ipad+0x2e8>
 d047a20:	e0fffd17 	ldw	r3,-12(fp)
 d047a24:	00800404 	movi	r2,16
 d047a28:	18800015 	stw	r2,0(r3)
 d047a2c:	00000306 	br	d047a3c <parse_ipad+0x2f4>
      else *sbits = 24;
 d047a30:	e0fffd17 	ldw	r3,-12(fp)
 d047a34:	00800604 	movi	r2,24
 d047a38:	18800015 	stw	r2,0(r3)

      *ipout = retval.l;      /* everything went OK, return number */
 d047a3c:	e0fffb17 	ldw	r3,-20(fp)
 d047a40:	e0bffc17 	ldw	r2,-16(fp)
 d047a44:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 d047a48:	e03fff15 	stw	zero,-4(fp)
 d047a4c:	e0bfff17 	ldw	r2,-4(fp)
}
 d047a50:	e037883a 	mov	sp,fp
 d047a54:	dfc00117 	ldw	ra,4(sp)
 d047a58:	df000017 	ldw	fp,0(sp)
 d047a5c:	dec00204 	addi	sp,sp,8
 d047a60:	f800283a 	ret

0d047a64 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 d047a64:	defffa04 	addi	sp,sp,-24
 d047a68:	dfc00515 	stw	ra,20(sp)
 d047a6c:	df000415 	stw	fp,16(sp)
 d047a70:	df000404 	addi	fp,sp,16
 d047a74:	e13ffe15 	stw	r4,-8(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 d047a78:	01034174 	movhi	r4,3333
 d047a7c:	211d1604 	addi	r4,r4,29784
 d047a80:	e17ffe17 	ldw	r5,-8(fp)
 d047a84:	d04beb80 	call	d04beb8 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 d047a88:	e17ffd04 	addi	r5,fp,-12
 d047a8c:	e13ffc04 	addi	r4,fp,-16
 d047a90:	01834174 	movhi	r6,3333
 d047a94:	319d1604 	addi	r6,r6,29784
 d047a98:	d0477480 	call	d047748 <parse_ipad>
 d047a9c:	1004c03a 	cmpne	r2,r2,zero
 d047aa0:	1000031e 	bne	r2,zero,d047ab0 <inet_addr+0x4c>
   {
      return ipaddr ;
 d047aa4:	e0bffc17 	ldw	r2,-16(fp)
 d047aa8:	e0bfff15 	stw	r2,-4(fp)
 d047aac:	00000106 	br	d047ab4 <inet_addr+0x50>
   }
   else
   {
      return (u_long)NULL ;
 d047ab0:	e03fff15 	stw	zero,-4(fp)
 d047ab4:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d047ab8:	e037883a 	mov	sp,fp
 d047abc:	dfc00117 	ldw	ra,4(sp)
 d047ac0:	df000017 	ldw	fp,0(sp)
 d047ac4:	dec00204 	addi	sp,sp,8
 d047ac8:	f800283a 	ret

0d047acc <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 d047acc:	defffd04 	addi	sp,sp,-12
 d047ad0:	df000215 	stw	fp,8(sp)
 d047ad4:	df000204 	addi	fp,sp,8
 d047ad8:	e13ffe15 	stw	r4,-8(fp)
   val &= 0x0f;
 d047adc:	e0bffe17 	ldw	r2,-8(fp)
 d047ae0:	108003cc 	andi	r2,r2,15
 d047ae4:	e0bffe15 	stw	r2,-8(fp)
   if(val < 10)
 d047ae8:	e0bffe17 	ldw	r2,-8(fp)
 d047aec:	10800288 	cmpgei	r2,r2,10
 d047af0:	1000071e 	bne	r2,zero,d047b10 <hextoa+0x44>
      return (char)(val + '0');
 d047af4:	e0bffe17 	ldw	r2,-8(fp)
 d047af8:	10800c04 	addi	r2,r2,48
 d047afc:	10803fcc 	andi	r2,r2,255
 d047b00:	1080201c 	xori	r2,r2,128
 d047b04:	10bfe004 	addi	r2,r2,-128
 d047b08:	e0bfff15 	stw	r2,-4(fp)
 d047b0c:	00000606 	br	d047b28 <hextoa+0x5c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 d047b10:	e0bffe17 	ldw	r2,-8(fp)
 d047b14:	10800dc4 	addi	r2,r2,55
 d047b18:	10803fcc 	andi	r2,r2,255
 d047b1c:	1080201c 	xori	r2,r2,128
 d047b20:	10bfe004 	addi	r2,r2,-128
 d047b24:	e0bfff15 	stw	r2,-4(fp)
 d047b28:	e0bfff17 	ldw	r2,-4(fp)
}
 d047b2c:	e037883a 	mov	sp,fp
 d047b30:	df000017 	ldw	fp,0(sp)
 d047b34:	dec00104 	addi	sp,sp,4
 d047b38:	f800283a 	ret

0d047b3c <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 d047b3c:	defff704 	addi	sp,sp,-36
 d047b40:	dfc00815 	stw	ra,32(sp)
 d047b44:	df000715 	stw	fp,28(sp)
 d047b48:	df000704 	addi	fp,sp,28
 d047b4c:	e13ffc15 	stw	r4,-16(fp)
 d047b50:	e17ffd15 	stw	r5,-12(fp)
 d047b54:	e1bffe15 	stw	r6,-8(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 d047b58:	e0bffc17 	ldw	r2,-16(fp)
 d047b5c:	10800098 	cmpnei	r2,r2,2
 d047b60:	10001a1e 	bne	r2,zero,d047bcc <inet_pton+0x90>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 d047b64:	e13ffa04 	addi	r4,fp,-24
 d047b68:	e17ffb04 	addi	r5,fp,-20
 d047b6c:	e1bffd17 	ldw	r6,-12(fp)
 d047b70:	d0477480 	call	d047748 <parse_ipad>
 d047b74:	e0bff915 	stw	r2,-28(fp)
      if(err == NULL)
 d047b78:	e0bff917 	ldw	r2,-28(fp)
 d047b7c:	1004c03a 	cmpne	r2,r2,zero
 d047b80:	10000c1e 	bne	r2,zero,d047bb4 <inet_pton+0x78>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 d047b84:	e13ffe17 	ldw	r4,-8(fp)
 d047b88:	e0fffa04 	addi	r3,fp,-24
 d047b8c:	18800003 	ldbu	r2,0(r3)
 d047b90:	20800005 	stb	r2,0(r4)
 d047b94:	18800043 	ldbu	r2,1(r3)
 d047b98:	20800045 	stb	r2,1(r4)
 d047b9c:	18800083 	ldbu	r2,2(r3)
 d047ba0:	20800085 	stb	r2,2(r4)
 d047ba4:	188000c3 	ldbu	r2,3(r3)
 d047ba8:	208000c5 	stb	r2,3(r4)
         return 0;
 d047bac:	e03fff15 	stw	zero,-4(fp)
 d047bb0:	00000706 	br	d047bd0 <inet_pton+0x94>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 d047bb4:	00834174 	movhi	r2,3333
 d047bb8:	10891c04 	addi	r2,r2,9328
 d047bbc:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 d047bc0:	00800044 	movi	r2,1
 d047bc4:	e0bfff15 	stw	r2,-4(fp)
 d047bc8:	00000106 	br	d047bd0 <inet_pton+0x94>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 d047bcc:	e03fff15 	stw	zero,-4(fp)
 d047bd0:	e0bfff17 	ldw	r2,-4(fp)
}
 d047bd4:	e037883a 	mov	sp,fp
 d047bd8:	dfc00117 	ldw	ra,4(sp)
 d047bdc:	df000017 	ldw	fp,0(sp)
 d047be0:	dec00204 	addi	sp,sp,8
 d047be4:	f800283a 	ret

0d047be8 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 d047be8:	defff704 	addi	sp,sp,-36
 d047bec:	dfc00815 	stw	ra,32(sp)
 d047bf0:	df000715 	stw	fp,28(sp)
 d047bf4:	df000704 	addi	fp,sp,28
 d047bf8:	e13ffb15 	stw	r4,-20(fp)
 d047bfc:	e17ffc15 	stw	r5,-16(fp)
 d047c00:	e1bffd15 	stw	r6,-12(fp)
 d047c04:	e1fffe15 	stw	r7,-8(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 d047c08:	e0bffb17 	ldw	r2,-20(fp)
 d047c0c:	10800098 	cmpnei	r2,r2,2
 d047c10:	1000111e 	bne	r2,zero,d047c58 <inet_ntop+0x70>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 d047c14:	e0bffc17 	ldw	r2,-16(fp)
 d047c18:	10800017 	ldw	r2,0(r2)
 d047c1c:	e0bff915 	stw	r2,-28(fp)
      cp = print_ipad(ip4addr);
 d047c20:	e13ff917 	ldw	r4,-28(fp)
 d047c24:	d02079c0 	call	d02079c <print_ipad>
 d047c28:	e0bffa15 	stw	r2,-24(fp)
      if (strlen(cp) < size)
 d047c2c:	e13ffa17 	ldw	r4,-24(fp)
 d047c30:	d0034640 	call	d003464 <strlen>
 d047c34:	1007883a 	mov	r3,r2
 d047c38:	e0bffe17 	ldw	r2,-8(fp)
 d047c3c:	1880062e 	bgeu	r3,r2,d047c58 <inet_ntop+0x70>
      {
         strcpy(str, cp);
 d047c40:	e13ffd17 	ldw	r4,-12(fp)
 d047c44:	e17ffa17 	ldw	r5,-24(fp)
 d047c48:	d04beb80 	call	d04beb8 <strcpy>
         return (str);
 d047c4c:	e0bffd17 	ldw	r2,-12(fp)
 d047c50:	e0bfff15 	stw	r2,-4(fp)
 d047c54:	00000106 	br	d047c5c <inet_ntop+0x74>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 d047c58:	e03fff15 	stw	zero,-4(fp)
 d047c5c:	e0bfff17 	ldw	r2,-4(fp)
}
 d047c60:	e037883a 	mov	sp,fp
 d047c64:	dfc00117 	ldw	ra,4(sp)
 d047c68:	df000017 	ldw	fp,0(sp)
 d047c6c:	dec00204 	addi	sp,sp,8
 d047c70:	f800283a 	ret

0d047c74 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 d047c74:	defffb04 	addi	sp,sp,-20
 d047c78:	dfc00415 	stw	ra,16(sp)
 d047c7c:	df000315 	stw	fp,12(sp)
 d047c80:	df000304 	addi	fp,sp,12
 d047c84:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr->sa_family == AF_INET)
 d047c88:	e0bffe17 	ldw	r2,-8(fp)
 d047c8c:	1080000b 	ldhu	r2,0(r2)
 d047c90:	10bfffcc 	andi	r2,r2,65535
 d047c94:	10800098 	cmpnei	r2,r2,2
 d047c98:	1000071e 	bne	r2,zero,d047cb8 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 d047c9c:	e0bffe17 	ldw	r2,-8(fp)
 d047ca0:	e0bffd15 	stw	r2,-12(fp)
      return print_ipad(addr->sin_addr.s_addr);
 d047ca4:	e0bffd17 	ldw	r2,-12(fp)
 d047ca8:	11000117 	ldw	r4,4(r2)
 d047cac:	d02079c0 	call	d02079c <print_ipad>
 d047cb0:	e0bfff15 	stw	r2,-4(fp)
 d047cb4:	00000106 	br	d047cbc <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 d047cb8:	e03fff15 	stw	zero,-4(fp)
 d047cbc:	e0bfff17 	ldw	r2,-4(fp)
}
 d047cc0:	e037883a 	mov	sp,fp
 d047cc4:	dfc00117 	ldw	ra,4(sp)
 d047cc8:	df000017 	ldw	fp,0(sp)
 d047ccc:	dec00204 	addi	sp,sp,8
 d047cd0:	f800283a 	ret

0d047cd4 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 d047cd4:	defffb04 	addi	sp,sp,-20
 d047cd8:	dfc00415 	stw	ra,16(sp)
 d047cdc:	df000315 	stw	fp,12(sp)
 d047ce0:	df000304 	addi	fp,sp,12
 d047ce4:	e13ffe15 	stw	r4,-8(fp)
 d047ce8:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 d047cec:	e0ffff17 	ldw	r3,-4(fp)
 d047cf0:	00800084 	movi	r2,2
 d047cf4:	1880000d 	sth	r2,0(r3)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 d047cf8:	e0bffe17 	ldw	r2,-8(fp)
 d047cfc:	10800044 	addi	r2,r2,1
 d047d00:	10800003 	ldbu	r2,0(r2)
 d047d04:	10803fcc 	andi	r2,r2,255
 d047d08:	1080201c 	xori	r2,r2,128
 d047d0c:	10bfe004 	addi	r2,r2,-128
 d047d10:	10800ba0 	cmpeqi	r2,r2,46
 d047d14:	1000101e 	bne	r2,zero,d047d58 <inet46_addr+0x84>
 d047d18:	e0bffe17 	ldw	r2,-8(fp)
 d047d1c:	10800084 	addi	r2,r2,2
 d047d20:	10800003 	ldbu	r2,0(r2)
 d047d24:	10803fcc 	andi	r2,r2,255
 d047d28:	1080201c 	xori	r2,r2,128
 d047d2c:	10bfe004 	addi	r2,r2,-128
 d047d30:	10800ba0 	cmpeqi	r2,r2,46
 d047d34:	1000081e 	bne	r2,zero,d047d58 <inet46_addr+0x84>
 d047d38:	e0bffe17 	ldw	r2,-8(fp)
 d047d3c:	108000c4 	addi	r2,r2,3
 d047d40:	10800003 	ldbu	r2,0(r2)
 d047d44:	10803fcc 	andi	r2,r2,255
 d047d48:	1080201c 	xori	r2,r2,128
 d047d4c:	10bfe004 	addi	r2,r2,-128
 d047d50:	10800b98 	cmpnei	r2,r2,46
 d047d54:	10000a1e 	bne	r2,zero,d047d80 <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 d047d58:	e0bfff17 	ldw	r2,-4(fp)
 d047d5c:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 d047d60:	e13ffe17 	ldw	r4,-8(fp)
 d047d64:	d047a640 	call	d047a64 <inet_addr>
 d047d68:	1007883a 	mov	r3,r2
 d047d6c:	e0bffd17 	ldw	r2,-12(fp)
 d047d70:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 d047d74:	e0fffd17 	ldw	r3,-12(fp)
 d047d78:	00800084 	movi	r2,2
 d047d7c:	1880000d 	sth	r2,0(r3)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 d047d80:	0005883a 	mov	r2,zero
}
 d047d84:	e037883a 	mov	sp,fp
 d047d88:	dfc00117 	ldw	ra,4(sp)
 d047d8c:	df000017 	ldw	fp,0(sp)
 d047d90:	dec00204 	addi	sp,sp,8
 d047d94:	f800283a 	ret

0d047d98 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 d047d98:	defffc04 	addi	sp,sp,-16
 d047d9c:	df000315 	stw	fp,12(sp)
 d047da0:	df000304 	addi	fp,sp,12
 d047da4:	e13ffe15 	stw	r4,-8(fp)
 d047da8:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 d047dac:	e0bffe17 	ldw	r2,-8(fp)
 d047db0:	1080000b 	ldhu	r2,0(r2)
 d047db4:	10bfffcc 	andi	r2,r2,65535
 d047db8:	10800098 	cmpnei	r2,r2,2
 d047dbc:	10000f1e 	bne	r2,zero,d047dfc <inet_setport+0x64>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 d047dc0:	e0bffe17 	ldw	r2,-8(fp)
 d047dc4:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 d047dc8:	e0bfff17 	ldw	r2,-4(fp)
 d047dcc:	1005d23a 	srai	r2,r2,8
 d047dd0:	10803fcc 	andi	r2,r2,255
 d047dd4:	1009883a 	mov	r4,r2
 d047dd8:	e0bfff17 	ldw	r2,-4(fp)
 d047ddc:	1004923a 	slli	r2,r2,8
 d047de0:	1007883a 	mov	r3,r2
 d047de4:	00bfc004 	movi	r2,-256
 d047de8:	1884703a 	and	r2,r3,r2
 d047dec:	2084b03a 	or	r2,r4,r2
 d047df0:	1007883a 	mov	r3,r2
 d047df4:	e0bffd17 	ldw	r2,-12(fp)
 d047df8:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 d047dfc:	e037883a 	mov	sp,fp
 d047e00:	df000017 	ldw	fp,0(sp)
 d047e04:	dec00104 	addi	sp,sp,4
 d047e08:	f800283a 	ret

0d047e0c <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 d047e0c:	defff704 	addi	sp,sp,-36
 d047e10:	dfc00815 	stw	ra,32(sp)
 d047e14:	df000715 	stw	fp,28(sp)
 d047e18:	df000704 	addi	fp,sp,28
 d047e1c:	e13ffe15 	stw	r4,-8(fp)
   const char *cp = p;
 d047e20:	e0bffe17 	ldw	r2,-8(fp)
 d047e24:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 d047e28:	e0bffd04 	addi	r2,fp,-12
 d047e2c:	e0bffb15 	stw	r2,-20(fp)
   int n = 0;
 d047e30:	e03ffa15 	stw	zero,-24(fp)
   unsigned short v = 0;
 d047e34:	e03ff90d 	sth	zero,-28(fp)
   dw = 0;
 d047e38:	e03ffd15 	stw	zero,-12(fp)
   while(*cp)
 d047e3c:	00003406 	br	d047f10 <convert_ip+0x104>
   {
      if( *cp == '.')
 d047e40:	e0bffc17 	ldw	r2,-16(fp)
 d047e44:	10800003 	ldbu	r2,0(r2)
 d047e48:	10803fcc 	andi	r2,r2,255
 d047e4c:	1080201c 	xori	r2,r2,128
 d047e50:	10bfe004 	addi	r2,r2,-128
 d047e54:	10800b98 	cmpnei	r2,r2,46
 d047e58:	1000101e 	bne	r2,zero,d047e9c <convert_ip+0x90>
      {
         lpb[n] = (unsigned char) v;
 d047e5c:	e0bffa17 	ldw	r2,-24(fp)
 d047e60:	1007883a 	mov	r3,r2
 d047e64:	e0bffb17 	ldw	r2,-20(fp)
 d047e68:	1887883a 	add	r3,r3,r2
 d047e6c:	e0bff90b 	ldhu	r2,-28(fp)
 d047e70:	18800005 	stb	r2,0(r3)
         v = 0;
 d047e74:	e03ff90d 	sth	zero,-28(fp)
         n++;
 d047e78:	e0bffa17 	ldw	r2,-24(fp)
 d047e7c:	10800044 	addi	r2,r2,1
 d047e80:	e0bffa15 	stw	r2,-24(fp)
         if(n > 3)
 d047e84:	e0bffa17 	ldw	r2,-24(fp)
 d047e88:	10800110 	cmplti	r2,r2,4
 d047e8c:	10001d1e 	bne	r2,zero,d047f04 <convert_ip+0xf8>
         {
            return dw;
 d047e90:	e0bffd17 	ldw	r2,-12(fp)
 d047e94:	e0bfff15 	stw	r2,-4(fp)
 d047e98:	00002c06 	br	d047f4c <convert_ip+0x140>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 d047e9c:	e0bffc17 	ldw	r2,-16(fp)
 d047ea0:	10800003 	ldbu	r2,0(r2)
 d047ea4:	10803fcc 	andi	r2,r2,255
 d047ea8:	1080201c 	xori	r2,r2,128
 d047eac:	10bfe004 	addi	r2,r2,-128
 d047eb0:	10800c10 	cmplti	r2,r2,48
 d047eb4:	1000131e 	bne	r2,zero,d047f04 <convert_ip+0xf8>
 d047eb8:	e0bffc17 	ldw	r2,-16(fp)
 d047ebc:	10800003 	ldbu	r2,0(r2)
 d047ec0:	10803fcc 	andi	r2,r2,255
 d047ec4:	1080201c 	xori	r2,r2,128
 d047ec8:	10bfe004 	addi	r2,r2,-128
 d047ecc:	10800e88 	cmpgei	r2,r2,58
 d047ed0:	10000c1e 	bne	r2,zero,d047f04 <convert_ip+0xf8>
      {
         v = (v * 10) + (*cp - '0');
 d047ed4:	e13ff90b 	ldhu	r4,-28(fp)
 d047ed8:	01400284 	movi	r5,10
 d047edc:	d00235c0 	call	d00235c <__mulsi3>
 d047ee0:	1007883a 	mov	r3,r2
 d047ee4:	e0bffc17 	ldw	r2,-16(fp)
 d047ee8:	10800003 	ldbu	r2,0(r2)
 d047eec:	10803fcc 	andi	r2,r2,255
 d047ef0:	1080201c 	xori	r2,r2,128
 d047ef4:	10bfe004 	addi	r2,r2,-128
 d047ef8:	1885883a 	add	r2,r3,r2
 d047efc:	10bff404 	addi	r2,r2,-48
 d047f00:	e0bff90d 	sth	r2,-28(fp)
      }
      cp++;
 d047f04:	e0bffc17 	ldw	r2,-16(fp)
 d047f08:	10800044 	addi	r2,r2,1
 d047f0c:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 d047f10:	e0bffc17 	ldw	r2,-16(fp)
 d047f14:	10800003 	ldbu	r2,0(r2)
 d047f18:	10803fcc 	andi	r2,r2,255
 d047f1c:	1080201c 	xori	r2,r2,128
 d047f20:	10bfe004 	addi	r2,r2,-128
 d047f24:	1004c03a 	cmpne	r2,r2,zero
 d047f28:	103fc51e 	bne	r2,zero,d047e40 <convert_ip+0x34>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 d047f2c:	e0bffa17 	ldw	r2,-24(fp)
 d047f30:	1007883a 	mov	r3,r2
 d047f34:	e0bffb17 	ldw	r2,-20(fp)
 d047f38:	1887883a 	add	r3,r3,r2
 d047f3c:	e0bff90b 	ldhu	r2,-28(fp)
 d047f40:	18800005 	stb	r2,0(r3)
   return dw;
 d047f44:	e0bffd17 	ldw	r2,-12(fp)
 d047f48:	e0bfff15 	stw	r2,-4(fp)
 d047f4c:	e0bfff17 	ldw	r2,-4(fp)
}  /* convert_ip() */
 d047f50:	e037883a 	mov	sp,fp
 d047f54:	dfc00117 	ldw	ra,4(sp)
 d047f58:	df000017 	ldw	fp,0(sp)
 d047f5c:	dec00204 	addi	sp,sp,8
 d047f60:	f800283a 	ret

0d047f64 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 d047f64:	defff804 	addi	sp,sp,-32
 d047f68:	dfc00715 	stw	ra,28(sp)
 d047f6c:	df000615 	stw	fp,24(sp)
 d047f70:	df000604 	addi	fp,sp,24
 d047f74:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 d047f78:	e03ffd15 	stw	zero,-12(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 d047f7c:	e03ffc05 	stb	zero,-16(fp)

   iphlen = (unshort)ip_hlen(pip);
 d047f80:	e0bfff17 	ldw	r2,-4(fp)
 d047f84:	10800003 	ldbu	r2,0(r2)
 d047f88:	10803fcc 	andi	r2,r2,255
 d047f8c:	108003cc 	andi	r2,r2,15
 d047f90:	1085883a 	add	r2,r2,r2
 d047f94:	1085883a 	add	r2,r2,r2
 d047f98:	e0bffe8d 	sth	r2,-6(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 d047f9c:	e0bfff17 	ldw	r2,-4(fp)
 d047fa0:	1080008b 	ldhu	r2,2(r2)
 d047fa4:	10bfffcc 	andi	r2,r2,65535
 d047fa8:	1004d23a 	srli	r2,r2,8
 d047fac:	10803fcc 	andi	r2,r2,255
 d047fb0:	1009883a 	mov	r4,r2
 d047fb4:	e0bfff17 	ldw	r2,-4(fp)
 d047fb8:	1080008b 	ldhu	r2,2(r2)
 d047fbc:	10bfffcc 	andi	r2,r2,65535
 d047fc0:	1004923a 	slli	r2,r2,8
 d047fc4:	1007883a 	mov	r3,r2
 d047fc8:	00bfc004 	movi	r2,-256
 d047fcc:	1884703a 	and	r2,r3,r2
 d047fd0:	2084b03a 	or	r2,r4,r2
 d047fd4:	1007883a 	mov	r3,r2
 d047fd8:	e0bffe8b 	ldhu	r2,-6(fp)
 d047fdc:	1885c83a 	sub	r2,r3,r2
 d047fe0:	e0bffe0d 	sth	r2,-8(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 d047fe4:	e0bfff17 	ldw	r2,-4(fp)
 d047fe8:	10800003 	ldbu	r2,0(r2)
 d047fec:	10803fcc 	andi	r2,r2,255
 d047ff0:	108003cc 	andi	r2,r2,15
 d047ff4:	1085883a 	add	r2,r2,r2
 d047ff8:	1085883a 	add	r2,r2,r2
 d047ffc:	1007883a 	mov	r3,r2
 d048000:	e0bfff17 	ldw	r2,-4(fp)
 d048004:	1885883a 	add	r2,r3,r2
 d048008:	e0bffa15 	stw	r2,-24(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 d04800c:	e0bffa17 	ldw	r2,-24(fp)
 d048010:	1080040b 	ldhu	r2,16(r2)
 d048014:	e0bffb8d 	sth	r2,-18(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 d048018:	e0bffe0b 	ldhu	r2,-8(fp)
 d04801c:	10800184 	addi	r2,r2,6
 d048020:	1005d23a 	srai	r2,r2,8
 d048024:	10803fcc 	andi	r2,r2,255
 d048028:	1009883a 	mov	r4,r2
 d04802c:	e0bffe0b 	ldhu	r2,-8(fp)
 d048030:	10800184 	addi	r2,r2,6
 d048034:	1004923a 	slli	r2,r2,8
 d048038:	1007883a 	mov	r3,r2
 d04803c:	00bfc004 	movi	r2,-256
 d048040:	1884703a 	and	r2,r3,r2
 d048044:	2084b03a 	or	r2,r4,r2
 d048048:	1007883a 	mov	r3,r2
 d04804c:	e0bffa17 	ldw	r2,-24(fp)
 d048050:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 d048054:	e0bffe0b 	ldhu	r2,-8(fp)
 d048058:	1080004c 	andi	r2,r2,1
 d04805c:	10803fcc 	andi	r2,r2,255
 d048060:	1005003a 	cmpeq	r2,r2,zero
 d048064:	10000f1e 	bne	r2,zero,d0480a4 <tcp_cksum+0x140>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 d048068:	e0bffe8b 	ldhu	r2,-6(fp)
 d04806c:	1007883a 	mov	r3,r2
 d048070:	e0bfff17 	ldw	r2,-4(fp)
 d048074:	1887883a 	add	r3,r3,r2
 d048078:	e0bffe0b 	ldhu	r2,-8(fp)
 d04807c:	1885883a 	add	r2,r3,r2
 d048080:	e0bffd15 	stw	r2,-12(fp)
      oddchar = *tcpdata;
 d048084:	e0bffd17 	ldw	r2,-12(fp)
 d048088:	10800003 	ldbu	r2,0(r2)
 d04808c:	e0bffc05 	stb	r2,-16(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 d048090:	e0bffd17 	ldw	r2,-12(fp)
 d048094:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 d048098:	e0bffe0b 	ldhu	r2,-8(fp)
 d04809c:	10800044 	addi	r2,r2,1
 d0480a0:	e0bffe0d 	sth	r2,-8(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 d0480a4:	e0bffa17 	ldw	r2,-24(fp)
 d0480a8:	113ffe04 	addi	r4,r2,-8
 d0480ac:	e0bffe0b 	ldhu	r2,-8(fp)
 d0480b0:	10800204 	addi	r2,r2,8
 d0480b4:	1005d07a 	srai	r2,r2,1
 d0480b8:	100b883a 	mov	r5,r2
 d0480bc:	d0205440 	call	d020544 <cksum>
 d0480c0:	0084303a 	nor	r2,zero,r2
 d0480c4:	e0bffb0d 	sth	r2,-20(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 d0480c8:	e0fffb0b 	ldhu	r3,-20(fp)
 d0480cc:	e0bffb8b 	ldhu	r2,-18(fp)
 d0480d0:	18800826 	beq	r3,r2,d0480f4 <tcp_cksum+0x190>
 d0480d4:	e0fffb8b 	ldhu	r3,-18(fp)
 d0480d8:	00bfffd4 	movui	r2,65535
 d0480dc:	1880051e 	bne	r3,r2,d0480f4 <tcp_cksum+0x190>
 d0480e0:	e0bffb0b 	ldhu	r2,-20(fp)
 d0480e4:	1004c03a 	cmpne	r2,r2,zero
 d0480e8:	1000021e 	bne	r2,zero,d0480f4 <tcp_cksum+0x190>
      newsum = 0xffff;
 d0480ec:	00bfffc4 	movi	r2,-1
 d0480f0:	e0bffb0d 	sth	r2,-20(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 d0480f4:	e0fffa17 	ldw	r3,-24(fp)
 d0480f8:	e0bffb8b 	ldhu	r2,-18(fp)
 d0480fc:	1880040d 	sth	r2,16(r3)
   if (oddchar)
 d048100:	e0bffc07 	ldb	r2,-16(fp)
 d048104:	1005003a 	cmpeq	r2,r2,zero
 d048108:	1000031e 	bne	r2,zero,d048118 <tcp_cksum+0x1b4>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 d04810c:	e0fffd17 	ldw	r3,-12(fp)
 d048110:	e0bffc03 	ldbu	r2,-16(fp)
 d048114:	18800005 	stb	r2,0(r3)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 d048118:	e0bffb0b 	ldhu	r2,-20(fp)
}
 d04811c:	e037883a 	mov	sp,fp
 d048120:	dfc00117 	ldw	ra,4(sp)
 d048124:	df000017 	ldw	fp,0(sp)
 d048128:	dec00204 	addi	sp,sp,8
 d04812c:	f800283a 	ret

0d048130 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 d048130:	defffa04 	addi	sp,sp,-24
 d048134:	dfc00515 	stw	ra,20(sp)
 d048138:	df000415 	stw	fp,16(sp)
 d04813c:	df000404 	addi	fp,sp,16
 d048140:	e13ffd15 	stw	r4,-12(fp)
 d048144:	e17ffe15 	stw	r5,-8(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 d048148:	01000b04 	movi	r4,44
 d04814c:	d0264b80 	call	d0264b8 <npalloc>
 d048150:	e0bffc15 	stw	r2,-16(fp)
   if (inp == 0)
 d048154:	e0bffc17 	ldw	r2,-16(fp)
 d048158:	1004c03a 	cmpne	r2,r2,zero
 d04815c:	1000031e 	bne	r2,zero,d04816c <in_pcballoc+0x3c>
      return ENOMEM;
 d048160:	00800304 	movi	r2,12
 d048164:	e0bfff15 	stw	r2,-4(fp)
 d048168:	00001006 	br	d0481ac <in_pcballoc+0x7c>
   inp->inp_head = head;
 d04816c:	e0fffc17 	ldw	r3,-16(fp)
 d048170:	e0bffe17 	ldw	r2,-8(fp)
 d048174:	18800215 	stw	r2,8(r3)
   inp->inp_socket = so;
 d048178:	e0fffc17 	ldw	r3,-16(fp)
 d04817c:	e0bffd17 	ldw	r2,-12(fp)
 d048180:	18800815 	stw	r2,32(r3)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 d048184:	e0fffc17 	ldw	r3,-16(fp)
 d048188:	00808004 	movi	r2,512
 d04818c:	18800615 	stw	r2,24(r3)
   insque(inp, head);
 d048190:	e13ffc17 	ldw	r4,-16(fp)
 d048194:	e17ffe17 	ldw	r5,-8(fp)
 d048198:	d0271f80 	call	d0271f8 <insque>
   so->so_pcb = inp;
 d04819c:	e0fffd17 	ldw	r3,-12(fp)
 d0481a0:	e0bffc17 	ldw	r2,-16(fp)
 d0481a4:	18800115 	stw	r2,4(r3)
   return 0;
 d0481a8:	e03fff15 	stw	zero,-4(fp)
 d0481ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d0481b0:	e037883a 	mov	sp,fp
 d0481b4:	dfc00117 	ldw	ra,4(sp)
 d0481b8:	df000017 	ldw	fp,0(sp)
 d0481bc:	dec00204 	addi	sp,sp,8
 d0481c0:	f800283a 	ret

0d0481c4 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 d0481c4:	defffc04 	addi	sp,sp,-16
 d0481c8:	dfc00315 	stw	ra,12(sp)
 d0481cc:	df000215 	stw	fp,8(sp)
 d0481d0:	df000204 	addi	fp,sp,8
 d0481d4:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 d0481d8:	e0bfff17 	ldw	r2,-4(fp)
 d0481dc:	10800817 	ldw	r2,32(r2)
 d0481e0:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 d0481e4:	e0bffe17 	ldw	r2,-8(fp)
 d0481e8:	10000115 	stw	zero,4(r2)
   sofree(so);
 d0481ec:	e13ffe17 	ldw	r4,-8(fp)
 d0481f0:	d02a5c00 	call	d02a5c0 <sofree>
   remque(inp);
 d0481f4:	e13fff17 	ldw	r4,-4(fp)
 d0481f8:	d0271880 	call	d027188 <remque>
   INP_FREE (inp);
 d0481fc:	e13fff17 	ldw	r4,-4(fp)
 d048200:	d0265ac0 	call	d0265ac <npfree>
}
 d048204:	e037883a 	mov	sp,fp
 d048208:	dfc00117 	ldw	ra,4(sp)
 d04820c:	df000017 	ldw	fp,0(sp)
 d048210:	dec00204 	addi	sp,sp,8
 d048214:	f800283a 	ret

0d048218 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 d048218:	defff404 	addi	sp,sp,-48
 d04821c:	dfc00b15 	stw	ra,44(sp)
 d048220:	df000a15 	stw	fp,40(sp)
 d048224:	df000a04 	addi	fp,sp,40
 d048228:	e13ffd15 	stw	r4,-12(fp)
 d04822c:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so =  inp->inp_socket;
 d048230:	e0bffd17 	ldw	r2,-12(fp)
 d048234:	10800817 	ldw	r2,32(r2)
 d048238:	e0bffc15 	stw	r2,-16(fp)
   struct inpcb * head  =  inp->inp_head;
 d04823c:	e0bffd17 	ldw	r2,-12(fp)
 d048240:	10800217 	ldw	r2,8(r2)
 d048244:	e0bffb15 	stw	r2,-20(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 d048248:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 d04824c:	e0bffd17 	ldw	r2,-12(fp)
 d048250:	1080078b 	ldhu	r2,30(r2)
 d048254:	10bfffcc 	andi	r2,r2,65535
 d048258:	1004c03a 	cmpne	r2,r2,zero
 d04825c:	1000041e 	bne	r2,zero,d048270 <in_pcbbind+0x58>
 d048260:	e0bffd17 	ldw	r2,-12(fp)
 d048264:	10800417 	ldw	r2,16(r2)
 d048268:	1005003a 	cmpeq	r2,r2,zero
 d04826c:	1000031e 	bne	r2,zero,d04827c <in_pcbbind+0x64>
      return (EINVAL);
 d048270:	00800584 	movi	r2,22
 d048274:	e0bfff15 	stw	r2,-4(fp)
 d048278:	00007606 	br	d048454 <in_pcbbind+0x23c>
   if (nam == 0)
 d04827c:	e0bffe17 	ldw	r2,-8(fp)
 d048280:	1005003a 	cmpeq	r2,r2,zero
 d048284:	10003e1e 	bne	r2,zero,d048380 <in_pcbbind+0x168>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 d048288:	e0bffe17 	ldw	r2,-8(fp)
 d04828c:	10800317 	ldw	r2,12(r2)
 d048290:	e0bffa15 	stw	r2,-24(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 d048294:	e0bffa17 	ldw	r2,-24(fp)
 d048298:	10800117 	ldw	r2,4(r2)
 d04829c:	1005003a 	cmpeq	r2,r2,zero
 d0482a0:	10000a1e 	bne	r2,zero,d0482cc <in_pcbbind+0xb4>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 d0482a4:	e0bffa17 	ldw	r2,-24(fp)
 d0482a8:	11000117 	ldw	r4,4(r2)
 d0482ac:	d0404040 	call	d040404 <ip_mymach>
 d0482b0:	1007883a 	mov	r3,r2
 d0482b4:	e0bffa17 	ldw	r2,-24(fp)
 d0482b8:	10800117 	ldw	r2,4(r2)
 d0482bc:	18800326 	beq	r3,r2,d0482cc <in_pcbbind+0xb4>
      return (EADDRNOTAVAIL);
 d0482c0:	00801f44 	movi	r2,125
 d0482c4:	e0bfff15 	stw	r2,-4(fp)
 d0482c8:	00006206 	br	d048454 <in_pcbbind+0x23c>
   }
   lport = sin->sin_port;
 d0482cc:	e0bffa17 	ldw	r2,-24(fp)
 d0482d0:	1080008b 	ldhu	r2,2(r2)
 d0482d4:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 d0482d8:	e0bff90b 	ldhu	r2,-28(fp)
 d0482dc:	1005003a 	cmpeq	r2,r2,zero
 d0482e0:	1000231e 	bne	r2,zero,d048370 <in_pcbbind+0x158>
   {
      int   wild  =  0;
 d0482e4:	e03ff815 	stw	zero,-32(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 d0482e8:	e0bffc17 	ldw	r2,-16(fp)
 d0482ec:	10800417 	ldw	r2,16(r2)
 d0482f0:	1080010c 	andi	r2,r2,4
 d0482f4:	1004c03a 	cmpne	r2,r2,zero
 d0482f8:	10000e1e 	bne	r2,zero,d048334 <in_pcbbind+0x11c>
 d0482fc:	e0bffc17 	ldw	r2,-16(fp)
 d048300:	10800217 	ldw	r2,8(r2)
 d048304:	1080010b 	ldhu	r2,4(r2)
 d048308:	10bfffcc 	andi	r2,r2,65535
 d04830c:	1080010c 	andi	r2,r2,4
 d048310:	1005003a 	cmpeq	r2,r2,zero
 d048314:	1000051e 	bne	r2,zero,d04832c <in_pcbbind+0x114>
 d048318:	e0bffc17 	ldw	r2,-16(fp)
 d04831c:	10800417 	ldw	r2,16(r2)
 d048320:	1080008c 	andi	r2,r2,2
 d048324:	1004c03a 	cmpne	r2,r2,zero
 d048328:	1000021e 	bne	r2,zero,d048334 <in_pcbbind+0x11c>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 d04832c:	00800044 	movi	r2,1
 d048330:	e0bff815 	stw	r2,-32(fp)
      }
      if (in_pcblookup(head,
 d048334:	e0bffa17 	ldw	r2,-24(fp)
 d048338:	11c00117 	ldw	r7,4(r2)
 d04833c:	e0bff90b 	ldhu	r2,-28(fp)
 d048340:	d8800015 	stw	r2,0(sp)
 d048344:	e0bff817 	ldw	r2,-32(fp)
 d048348:	d8800115 	stw	r2,4(sp)
 d04834c:	e13ffb17 	ldw	r4,-20(fp)
 d048350:	000b883a 	mov	r5,zero
 d048354:	000d883a 	mov	r6,zero
 d048358:	d0487d40 	call	d0487d4 <in_pcblookup>
 d04835c:	1005003a 	cmpeq	r2,r2,zero
 d048360:	1000031e 	bne	r2,zero,d048370 <in_pcbbind+0x158>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 d048364:	00801c04 	movi	r2,112
 d048368:	e0bfff15 	stw	r2,-4(fp)
 d04836c:	00003906 	br	d048454 <in_pcbbind+0x23c>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 d048370:	e0bffa17 	ldw	r2,-24(fp)
 d048374:	10c00117 	ldw	r3,4(r2)
 d048378:	e0bffd17 	ldw	r2,-12(fp)
 d04837c:	10c00415 	stw	r3,16(r2)
noname:
   if (lport == 0)
 d048380:	e0bff90b 	ldhu	r2,-28(fp)
 d048384:	1004c03a 	cmpne	r2,r2,zero
 d048388:	10002e1e 	bne	r2,zero,d048444 <in_pcbbind+0x22c>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 d04838c:	e0bffb17 	ldw	r2,-20(fp)
 d048390:	10c0078b 	ldhu	r3,30(r2)
 d048394:	18bfffcc 	andi	r2,r3,65535
 d048398:	10810030 	cmpltui	r2,r2,1024
 d04839c:	1009883a 	mov	r4,r2
 d0483a0:	18800044 	addi	r2,r3,1
 d0483a4:	1007883a 	mov	r3,r2
 d0483a8:	e0bffb17 	ldw	r2,-20(fp)
 d0483ac:	10c0078d 	sth	r3,30(r2)
 d0483b0:	20803fcc 	andi	r2,r4,255
 d0483b4:	1004c03a 	cmpne	r2,r2,zero
 d0483b8:	1000051e 	bne	r2,zero,d0483d0 <in_pcbbind+0x1b8>
 d0483bc:	e0bffb17 	ldw	r2,-20(fp)
 d0483c0:	1080078b 	ldhu	r2,30(r2)
 d0483c4:	10bfffcc 	andi	r2,r2,65535
 d0483c8:	1084e270 	cmpltui	r2,r2,5001
 d0483cc:	1000031e 	bne	r2,zero,d0483dc <in_pcbbind+0x1c4>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 d0483d0:	e0fffb17 	ldw	r3,-20(fp)
 d0483d4:	00810004 	movi	r2,1024
 d0483d8:	1880078d 	sth	r2,30(r3)
         }
         lport = htons(head->inp_lport);
 d0483dc:	e0bffb17 	ldw	r2,-20(fp)
 d0483e0:	1080078b 	ldhu	r2,30(r2)
 d0483e4:	10bfffcc 	andi	r2,r2,65535
 d0483e8:	1004d23a 	srli	r2,r2,8
 d0483ec:	10803fcc 	andi	r2,r2,255
 d0483f0:	1009883a 	mov	r4,r2
 d0483f4:	e0bffb17 	ldw	r2,-20(fp)
 d0483f8:	1080078b 	ldhu	r2,30(r2)
 d0483fc:	10bfffcc 	andi	r2,r2,65535
 d048400:	1004923a 	slli	r2,r2,8
 d048404:	1007883a 	mov	r3,r2
 d048408:	00bfc004 	movi	r2,-256
 d04840c:	1884703a 	and	r2,r3,r2
 d048410:	2084b03a 	or	r2,r4,r2
 d048414:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 d048418:	e0bffd17 	ldw	r2,-12(fp)
 d04841c:	11c00417 	ldw	r7,16(r2)
 d048420:	e0bff90b 	ldhu	r2,-28(fp)
 d048424:	d8800015 	stw	r2,0(sp)
 d048428:	d8000115 	stw	zero,4(sp)
 d04842c:	e13ffb17 	ldw	r4,-20(fp)
 d048430:	000b883a 	mov	r5,zero
 d048434:	000d883a 	mov	r6,zero
 d048438:	d0487d40 	call	d0487d4 <in_pcblookup>
 d04843c:	1004c03a 	cmpne	r2,r2,zero
 d048440:	103fd21e 	bne	r2,zero,d04838c <in_pcbbind+0x174>
   }
   inp->inp_lport = lport;
 d048444:	e0fffd17 	ldw	r3,-12(fp)
 d048448:	e0bff90b 	ldhu	r2,-28(fp)
 d04844c:	1880078d 	sth	r2,30(r3)
   return (0);
 d048450:	e03fff15 	stw	zero,-4(fp)
 d048454:	e0bfff17 	ldw	r2,-4(fp)
}
 d048458:	e037883a 	mov	sp,fp
 d04845c:	dfc00117 	ldw	ra,4(sp)
 d048460:	df000017 	ldw	fp,0(sp)
 d048464:	dec00204 	addi	sp,sp,8
 d048468:	f800283a 	ret

0d04846c <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 d04846c:	defff504 	addi	sp,sp,-44
 d048470:	dfc00a15 	stw	ra,40(sp)
 d048474:	df000915 	stw	fp,36(sp)
 d048478:	df000904 	addi	fp,sp,36
 d04847c:	e13ffd15 	stw	r4,-12(fp)
 d048480:	e17ffe15 	stw	r5,-8(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 d048484:	e0bffe17 	ldw	r2,-8(fp)
 d048488:	10800317 	ldw	r2,12(r2)
 d04848c:	e0bffa15 	stw	r2,-24(fp)

   if (nam->m_len < sizeof (*sin))
 d048490:	e0bffe17 	ldw	r2,-8(fp)
 d048494:	10800217 	ldw	r2,8(r2)
 d048498:	10800428 	cmpgeui	r2,r2,16
 d04849c:	1000031e 	bne	r2,zero,d0484ac <in_pcbconnect+0x40>
      return (EINVAL);
 d0484a0:	00800584 	movi	r2,22
 d0484a4:	e0bfff15 	stw	r2,-4(fp)
 d0484a8:	00006e06 	br	d048664 <in_pcbconnect+0x1f8>
   if (sin->sin_family != AF_INET)
 d0484ac:	e0bffa17 	ldw	r2,-24(fp)
 d0484b0:	1080000b 	ldhu	r2,0(r2)
 d0484b4:	10bfffcc 	andi	r2,r2,65535
 d0484b8:	10a0001c 	xori	r2,r2,32768
 d0484bc:	10a00004 	addi	r2,r2,-32768
 d0484c0:	108000a0 	cmpeqi	r2,r2,2
 d0484c4:	1000031e 	bne	r2,zero,d0484d4 <in_pcbconnect+0x68>
      return (EAFNOSUPPORT);
 d0484c8:	00801a84 	movi	r2,106
 d0484cc:	e0bfff15 	stw	r2,-4(fp)
 d0484d0:	00006406 	br	d048664 <in_pcbconnect+0x1f8>
   if (sin->sin_port == 0)
 d0484d4:	e0bffa17 	ldw	r2,-24(fp)
 d0484d8:	1080008b 	ldhu	r2,2(r2)
 d0484dc:	10bfffcc 	andi	r2,r2,65535
 d0484e0:	1004c03a 	cmpne	r2,r2,zero
 d0484e4:	1000031e 	bne	r2,zero,d0484f4 <in_pcbconnect+0x88>
      return (EADDRNOTAVAIL);
 d0484e8:	00801f44 	movi	r2,125
 d0484ec:	e0bfff15 	stw	r2,-4(fp)
 d0484f0:	00005c06 	br	d048664 <in_pcbconnect+0x1f8>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 d0484f4:	e0bffa17 	ldw	r2,-24(fp)
 d0484f8:	10800117 	ldw	r2,4(r2)
 d0484fc:	1004c03a 	cmpne	r2,r2,zero
 d048500:	1000101e 	bne	r2,zero,d048544 <in_pcbconnect+0xd8>
   {
      if (inp && inp->ifp)
 d048504:	e0bffd17 	ldw	r2,-12(fp)
 d048508:	1005003a 	cmpeq	r2,r2,zero
 d04850c:	10000a1e 	bne	r2,zero,d048538 <in_pcbconnect+0xcc>
 d048510:	e0bffd17 	ldw	r2,-12(fp)
 d048514:	10800a17 	ldw	r2,40(r2)
 d048518:	1005003a 	cmpeq	r2,r2,zero
 d04851c:	1000061e 	bne	r2,zero,d048538 <in_pcbconnect+0xcc>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 d048520:	e0bffd17 	ldw	r2,-12(fp)
 d048524:	10800a17 	ldw	r2,40(r2)
 d048528:	10c00a17 	ldw	r3,40(r2)
 d04852c:	e0bffa17 	ldw	r2,-24(fp)
 d048530:	10c00115 	stw	r3,4(r2)
 d048534:	00000a06 	br	d048560 <in_pcbconnect+0xf4>
      else
         return (EADDRNOTAVAIL);
 d048538:	00801f44 	movi	r2,125
 d04853c:	e0bfff15 	stw	r2,-4(fp)
 d048540:	00004806 	br	d048664 <in_pcbconnect+0x1f8>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 d048544:	e0bffa17 	ldw	r2,-24(fp)
 d048548:	10800117 	ldw	r2,4(r2)
 d04854c:	10bfffd8 	cmpnei	r2,r2,-1
 d048550:	1000031e 	bne	r2,zero,d048560 <in_pcbconnect+0xf4>
      return (EADDRNOTAVAIL);
 d048554:	00801f44 	movi	r2,125
 d048558:	e0bfff15 	stw	r2,-4(fp)
 d04855c:	00004106 	br	d048664 <in_pcbconnect+0x1f8>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 d048560:	e0bffd17 	ldw	r2,-12(fp)
 d048564:	10800417 	ldw	r2,16(r2)
 d048568:	1004c03a 	cmpne	r2,r2,zero
 d04856c:	10000f1e 	bne	r2,zero,d0485ac <in_pcbconnect+0x140>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 d048570:	e0bffa17 	ldw	r2,-24(fp)
 d048574:	11000117 	ldw	r4,4(r2)
 d048578:	e17ffc04 	addi	r5,fp,-16
 d04857c:	d0407680 	call	d040768 <iproute>
 d048580:	e0bff915 	stw	r2,-28(fp)
      if (!npnet)
 d048584:	e0bff917 	ldw	r2,-28(fp)
 d048588:	1004c03a 	cmpne	r2,r2,zero
 d04858c:	1000031e 	bne	r2,zero,d04859c <in_pcbconnect+0x130>
         return EADDRNOTAVAIL;
 d048590:	00801f44 	movi	r2,125
 d048594:	e0bfff15 	stw	r2,-4(fp)
 d048598:	00003206 	br	d048664 <in_pcbconnect+0x1f8>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 d04859c:	e0bff917 	ldw	r2,-28(fp)
 d0485a0:	10800a17 	ldw	r2,40(r2)
 d0485a4:	e0bffb15 	stw	r2,-20(fp)
 d0485a8:	00000306 	br	d0485b8 <in_pcbconnect+0x14c>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 d0485ac:	e0bffd17 	ldw	r2,-12(fp)
 d0485b0:	10800417 	ldw	r2,16(r2)
 d0485b4:	e0bffb15 	stw	r2,-20(fp)

   if (in_pcblookup(inp->inp_head,
 d0485b8:	e0bffd17 	ldw	r2,-12(fp)
 d0485bc:	11000217 	ldw	r4,8(r2)
 d0485c0:	e0bffa17 	ldw	r2,-24(fp)
 d0485c4:	11400117 	ldw	r5,4(r2)
 d0485c8:	e0bffa17 	ldw	r2,-24(fp)
 d0485cc:	1080008b 	ldhu	r2,2(r2)
 d0485d0:	11bfffcc 	andi	r6,r2,65535
 d0485d4:	e0bffd17 	ldw	r2,-12(fp)
 d0485d8:	1080078b 	ldhu	r2,30(r2)
 d0485dc:	10bfffcc 	andi	r2,r2,65535
 d0485e0:	d8800015 	stw	r2,0(sp)
 d0485e4:	d8000115 	stw	zero,4(sp)
 d0485e8:	e1fffb17 	ldw	r7,-20(fp)
 d0485ec:	d0487d40 	call	d0487d4 <in_pcblookup>
 d0485f0:	1005003a 	cmpeq	r2,r2,zero
 d0485f4:	1000031e 	bne	r2,zero,d048604 <in_pcbconnect+0x198>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 d0485f8:	00801c04 	movi	r2,112
 d0485fc:	e0bfff15 	stw	r2,-4(fp)
 d048600:	00001806 	br	d048664 <in_pcbconnect+0x1f8>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 d048604:	e0bffd17 	ldw	r2,-12(fp)
 d048608:	10800417 	ldw	r2,16(r2)
 d04860c:	1004c03a 	cmpne	r2,r2,zero
 d048610:	10000b1e 	bne	r2,zero,d048640 <in_pcbconnect+0x1d4>
   {
      if (inp->inp_lport == 0)
 d048614:	e0bffd17 	ldw	r2,-12(fp)
 d048618:	1080078b 	ldhu	r2,30(r2)
 d04861c:	10bfffcc 	andi	r2,r2,65535
 d048620:	1004c03a 	cmpne	r2,r2,zero
 d048624:	1000031e 	bne	r2,zero,d048634 <in_pcbconnect+0x1c8>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 d048628:	e13ffd17 	ldw	r4,-12(fp)
 d04862c:	000b883a 	mov	r5,zero
 d048630:	d0482180 	call	d048218 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 d048634:	e0fffd17 	ldw	r3,-12(fp)
 d048638:	e0bffb17 	ldw	r2,-20(fp)
 d04863c:	18800415 	stw	r2,16(r3)
   }
   inp->inp_faddr = sin->sin_addr;
 d048640:	e0bffa17 	ldw	r2,-24(fp)
 d048644:	10c00117 	ldw	r3,4(r2)
 d048648:	e0bffd17 	ldw	r2,-12(fp)
 d04864c:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 d048650:	e0bffa17 	ldw	r2,-24(fp)
 d048654:	10c0008b 	ldhu	r3,2(r2)
 d048658:	e0bffd17 	ldw	r2,-12(fp)
 d04865c:	10c0070d 	sth	r3,28(r2)
   return 0;
 d048660:	e03fff15 	stw	zero,-4(fp)
 d048664:	e0bfff17 	ldw	r2,-4(fp)
}
 d048668:	e037883a 	mov	sp,fp
 d04866c:	dfc00117 	ldw	ra,4(sp)
 d048670:	df000017 	ldw	fp,0(sp)
 d048674:	dec00204 	addi	sp,sp,8
 d048678:	f800283a 	ret

0d04867c <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 d04867c:	defffd04 	addi	sp,sp,-12
 d048680:	dfc00215 	stw	ra,8(sp)
 d048684:	df000115 	stw	fp,4(sp)
 d048688:	df000104 	addi	fp,sp,4
 d04868c:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 d048690:	e0bfff17 	ldw	r2,-4(fp)
 d048694:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 d048698:	e0bfff17 	ldw	r2,-4(fp)
 d04869c:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 d0486a0:	e0bfff17 	ldw	r2,-4(fp)
 d0486a4:	10800817 	ldw	r2,32(r2)
 d0486a8:	1080088b 	ldhu	r2,34(r2)
 d0486ac:	10bfffcc 	andi	r2,r2,65535
 d0486b0:	1080004c 	andi	r2,r2,1
 d0486b4:	10803fcc 	andi	r2,r2,255
 d0486b8:	1005003a 	cmpeq	r2,r2,zero
 d0486bc:	1000021e 	bne	r2,zero,d0486c8 <in_pcbdisconnect+0x4c>
      in_pcbdetach (inp);
 d0486c0:	e13fff17 	ldw	r4,-4(fp)
 d0486c4:	d0481c40 	call	d0481c4 <in_pcbdetach>
}
 d0486c8:	e037883a 	mov	sp,fp
 d0486cc:	dfc00117 	ldw	ra,4(sp)
 d0486d0:	df000017 	ldw	fp,0(sp)
 d0486d4:	dec00204 	addi	sp,sp,8
 d0486d8:	f800283a 	ret

0d0486dc <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 d0486dc:	defffc04 	addi	sp,sp,-16
 d0486e0:	df000315 	stw	fp,12(sp)
 d0486e4:	df000304 	addi	fp,sp,12
 d0486e8:	e13ffe15 	stw	r4,-8(fp)
 d0486ec:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 d0486f0:	e0ffff17 	ldw	r3,-4(fp)
 d0486f4:	00800404 	movi	r2,16
 d0486f8:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 d0486fc:	e0bfff17 	ldw	r2,-4(fp)
 d048700:	10800317 	ldw	r2,12(r2)
 d048704:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 d048708:	e0bffd17 	ldw	r2,-12(fp)
 d04870c:	10000015 	stw	zero,0(r2)
 d048710:	10000115 	stw	zero,4(r2)
 d048714:	10000215 	stw	zero,8(r2)
 d048718:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 d04871c:	e0fffd17 	ldw	r3,-12(fp)
 d048720:	00800084 	movi	r2,2
 d048724:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_lport;
 d048728:	e0bffe17 	ldw	r2,-8(fp)
 d04872c:	10c0078b 	ldhu	r3,30(r2)
 d048730:	e0bffd17 	ldw	r2,-12(fp)
 d048734:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 d048738:	e0bffe17 	ldw	r2,-8(fp)
 d04873c:	10c00417 	ldw	r3,16(r2)
 d048740:	e0bffd17 	ldw	r2,-12(fp)
 d048744:	10c00115 	stw	r3,4(r2)
}
 d048748:	e037883a 	mov	sp,fp
 d04874c:	df000017 	ldw	fp,0(sp)
 d048750:	dec00104 	addi	sp,sp,4
 d048754:	f800283a 	ret

0d048758 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 d048758:	defffc04 	addi	sp,sp,-16
 d04875c:	df000315 	stw	fp,12(sp)
 d048760:	df000304 	addi	fp,sp,12
 d048764:	e13ffe15 	stw	r4,-8(fp)
 d048768:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 d04876c:	e0ffff17 	ldw	r3,-4(fp)
 d048770:	00800404 	movi	r2,16
 d048774:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 d048778:	e0bfff17 	ldw	r2,-4(fp)
 d04877c:	10800317 	ldw	r2,12(r2)
 d048780:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 d048784:	e0bffd17 	ldw	r2,-12(fp)
 d048788:	10000015 	stw	zero,0(r2)
 d04878c:	10000115 	stw	zero,4(r2)
 d048790:	10000215 	stw	zero,8(r2)
 d048794:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 d048798:	e0fffd17 	ldw	r3,-12(fp)
 d04879c:	00800084 	movi	r2,2
 d0487a0:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_fport;
 d0487a4:	e0bffe17 	ldw	r2,-8(fp)
 d0487a8:	10c0070b 	ldhu	r3,28(r2)
 d0487ac:	e0bffd17 	ldw	r2,-12(fp)
 d0487b0:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 d0487b4:	e0bffe17 	ldw	r2,-8(fp)
 d0487b8:	10c00317 	ldw	r3,12(r2)
 d0487bc:	e0bffd17 	ldw	r2,-12(fp)
 d0487c0:	10c00115 	stw	r3,4(r2)
}
 d0487c4:	e037883a 	mov	sp,fp
 d0487c8:	df000017 	ldw	fp,0(sp)
 d0487cc:	dec00104 	addi	sp,sp,4
 d0487d0:	f800283a 	ret

0d0487d4 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 d0487d4:	defff404 	addi	sp,sp,-48
 d0487d8:	df000b15 	stw	fp,44(sp)
 d0487dc:	df000b04 	addi	fp,sp,44
 d0487e0:	e13ffa15 	stw	r4,-24(fp)
 d0487e4:	e17ffb15 	stw	r5,-20(fp)
 d0487e8:	e1fffd15 	stw	r7,-12(fp)
 d0487ec:	e0800117 	ldw	r2,4(fp)
 d0487f0:	e1bffc0d 	sth	r6,-16(fp)
 d0487f4:	e0bffe0d 	sth	r2,-8(fp)
   struct inpcb * inp, *   match =  0;
 d0487f8:	e03ff815 	stw	zero,-32(fp)
   unshort  fport =  xfport; 
 d0487fc:	e0bffc0b 	ldhu	r2,-16(fp)
 d048800:	e0bff78d 	sth	r2,-34(fp)
   unshort  lport =  xlport;
 d048804:	e0bffe0b 	ldhu	r2,-8(fp)
 d048808:	e0bff70d 	sth	r2,-36(fp)
   int   matchwild   =  3;
 d04880c:	008000c4 	movi	r2,3
 d048810:	e0bff615 	stw	r2,-40(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 d048814:	e0bffa17 	ldw	r2,-24(fp)
 d048818:	10800017 	ldw	r2,0(r2)
 d04881c:	e0bff915 	stw	r2,-28(fp)
 d048820:	00005006 	br	d048964 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 d048824:	e0bff917 	ldw	r2,-28(fp)
 d048828:	1080078b 	ldhu	r2,30(r2)
 d04882c:	10ffffcc 	andi	r3,r2,65535
 d048830:	e0bff70b 	ldhu	r2,-36(fp)
 d048834:	1880481e 	bne	r3,r2,d048958 <in_pcblookup+0x184>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 d048838:	e0bff917 	ldw	r2,-28(fp)
 d04883c:	10800817 	ldw	r2,32(r2)
 d048840:	10800517 	ldw	r2,20(r2)
 d048844:	10800098 	cmpnei	r2,r2,2
 d048848:	1000431e 	bne	r2,zero,d048958 <in_pcblookup+0x184>
         continue;

      wildcard = 0;
 d04884c:	e03ff515 	stw	zero,-44(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 d048850:	e0bff917 	ldw	r2,-28(fp)
 d048854:	10800417 	ldw	r2,16(r2)
 d048858:	1005003a 	cmpeq	r2,r2,zero
 d04885c:	10000c1e 	bne	r2,zero,d048890 <in_pcblookup+0xbc>
      {
         if (laddr == INADDR_ANY)
 d048860:	e0bffd17 	ldw	r2,-12(fp)
 d048864:	1004c03a 	cmpne	r2,r2,zero
 d048868:	1000041e 	bne	r2,zero,d04887c <in_pcblookup+0xa8>
            wildcard++;
 d04886c:	e0bff517 	ldw	r2,-44(fp)
 d048870:	10800044 	addi	r2,r2,1
 d048874:	e0bff515 	stw	r2,-44(fp)
 d048878:	00000b06 	br	d0488a8 <in_pcblookup+0xd4>
         else if (inp->inp_laddr.s_addr != laddr)
 d04887c:	e0bff917 	ldw	r2,-28(fp)
 d048880:	10c00417 	ldw	r3,16(r2)
 d048884:	e0bffd17 	ldw	r2,-12(fp)
 d048888:	1880331e 	bne	r3,r2,d048958 <in_pcblookup+0x184>
            continue;
 d04888c:	00000606 	br	d0488a8 <in_pcblookup+0xd4>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 d048890:	e0bffd17 	ldw	r2,-12(fp)
 d048894:	1005003a 	cmpeq	r2,r2,zero
 d048898:	1000031e 	bne	r2,zero,d0488a8 <in_pcblookup+0xd4>
            wildcard++;
 d04889c:	e0bff517 	ldw	r2,-44(fp)
 d0488a0:	10800044 	addi	r2,r2,1
 d0488a4:	e0bff515 	stw	r2,-44(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 d0488a8:	e0bff917 	ldw	r2,-28(fp)
 d0488ac:	10800317 	ldw	r2,12(r2)
 d0488b0:	1005003a 	cmpeq	r2,r2,zero
 d0488b4:	1000111e 	bne	r2,zero,d0488fc <in_pcblookup+0x128>
      {
         if (faddr == INADDR_ANY)
 d0488b8:	e0bffb17 	ldw	r2,-20(fp)
 d0488bc:	1004c03a 	cmpne	r2,r2,zero
 d0488c0:	1000041e 	bne	r2,zero,d0488d4 <in_pcblookup+0x100>
            wildcard++;
 d0488c4:	e0bff517 	ldw	r2,-44(fp)
 d0488c8:	10800044 	addi	r2,r2,1
 d0488cc:	e0bff515 	stw	r2,-44(fp)
 d0488d0:	00001006 	br	d048914 <in_pcblookup+0x140>
         else if (inp->inp_faddr.s_addr != faddr ||
 d0488d4:	e0bff917 	ldw	r2,-28(fp)
 d0488d8:	10c00317 	ldw	r3,12(r2)
 d0488dc:	e0bffb17 	ldw	r2,-20(fp)
 d0488e0:	18801d1e 	bne	r3,r2,d048958 <in_pcblookup+0x184>
 d0488e4:	e0bff917 	ldw	r2,-28(fp)
 d0488e8:	1080070b 	ldhu	r2,28(r2)
 d0488ec:	10ffffcc 	andi	r3,r2,65535
 d0488f0:	e0bff78b 	ldhu	r2,-34(fp)
 d0488f4:	1880181e 	bne	r3,r2,d048958 <in_pcblookup+0x184>
 d0488f8:	00000606 	br	d048914 <in_pcblookup+0x140>
         {
            continue;
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 d0488fc:	e0bffb17 	ldw	r2,-20(fp)
 d048900:	1005003a 	cmpeq	r2,r2,zero
 d048904:	1000031e 	bne	r2,zero,d048914 <in_pcblookup+0x140>
            wildcard++;
 d048908:	e0bff517 	ldw	r2,-44(fp)
 d04890c:	10800044 	addi	r2,r2,1
 d048910:	e0bff515 	stw	r2,-44(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 d048914:	e0bff517 	ldw	r2,-44(fp)
 d048918:	1005003a 	cmpeq	r2,r2,zero
 d04891c:	1000041e 	bne	r2,zero,d048930 <in_pcblookup+0x15c>
 d048920:	e0800217 	ldw	r2,8(fp)
 d048924:	1080004c 	andi	r2,r2,1
 d048928:	1005003a 	cmpeq	r2,r2,zero
 d04892c:	10000a1e 	bne	r2,zero,d048958 <in_pcblookup+0x184>
         continue;
      if (wildcard < matchwild) 
 d048930:	e0fff517 	ldw	r3,-44(fp)
 d048934:	e0bff617 	ldw	r2,-40(fp)
 d048938:	1880070e 	bge	r3,r2,d048958 <in_pcblookup+0x184>
      {
         match = inp;
 d04893c:	e0bff917 	ldw	r2,-28(fp)
 d048940:	e0bff815 	stw	r2,-32(fp)
         matchwild = wildcard;
 d048944:	e0bff517 	ldw	r2,-44(fp)
 d048948:	e0bff615 	stw	r2,-40(fp)
         if (matchwild == 0)
 d04894c:	e0bff617 	ldw	r2,-40(fp)
 d048950:	1005003a 	cmpeq	r2,r2,zero
 d048954:	1000061e 	bne	r2,zero,d048970 <in_pcblookup+0x19c>
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 d048958:	e0bff917 	ldw	r2,-28(fp)
 d04895c:	10800017 	ldw	r2,0(r2)
 d048960:	e0bff915 	stw	r2,-28(fp)
 d048964:	e0fff917 	ldw	r3,-28(fp)
 d048968:	e0bffa17 	ldw	r2,-24(fp)
 d04896c:	18bfad1e 	bne	r3,r2,d048824 <in_pcblookup+0x50>
         matchwild = wildcard;
         if (matchwild == 0)
            break;
      }
   }
   if (match == NULL)
 d048970:	e0bff817 	ldw	r2,-32(fp)
 d048974:	1004c03a 	cmpne	r2,r2,zero
 d048978:	1000031e 	bne	r2,zero,d048988 <in_pcblookup+0x1b4>
      return match;
 d04897c:	e0bff817 	ldw	r2,-32(fp)
 d048980:	e0bfff15 	stw	r2,-4(fp)
 d048984:	00002506 	br	d048a1c <in_pcblookup+0x248>

   if (head->inp_next == match)  /* got cache hit? */
 d048988:	e0bffa17 	ldw	r2,-24(fp)
 d04898c:	10c00017 	ldw	r3,0(r2)
 d048990:	e0bff817 	ldw	r2,-32(fp)
 d048994:	1880041e 	bne	r3,r2,d0489a8 <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 d048998:	d0a95117 	ldw	r2,-23228(gp)
 d04899c:	10800044 	addi	r2,r2,1
 d0489a0:	d0a95115 	stw	r2,-23228(gp)
 d0489a4:	00001b06 	br	d048a14 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 d0489a8:	d0a95217 	ldw	r2,-23224(gp)
 d0489ac:	10800044 	addi	r2,r2,1
 d0489b0:	d0a95215 	stw	r2,-23224(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 d0489b4:	e0bff817 	ldw	r2,-32(fp)
 d0489b8:	10c00017 	ldw	r3,0(r2)
 d0489bc:	e0bff817 	ldw	r2,-32(fp)
 d0489c0:	10800117 	ldw	r2,4(r2)
 d0489c4:	18800115 	stw	r2,4(r3)
      match->inp_prev->inp_next = match->inp_next;
 d0489c8:	e0bff817 	ldw	r2,-32(fp)
 d0489cc:	10c00117 	ldw	r3,4(r2)
 d0489d0:	e0bff817 	ldw	r2,-32(fp)
 d0489d4:	10800017 	ldw	r2,0(r2)
 d0489d8:	18800015 	stw	r2,0(r3)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 d0489dc:	e0bffa17 	ldw	r2,-24(fp)
 d0489e0:	10c00017 	ldw	r3,0(r2)
 d0489e4:	e0bff817 	ldw	r2,-32(fp)
 d0489e8:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 d0489ec:	e0fffa17 	ldw	r3,-24(fp)
 d0489f0:	e0bff817 	ldw	r2,-32(fp)
 d0489f4:	18800015 	stw	r2,0(r3)
      match->inp_prev = head;
 d0489f8:	e0fff817 	ldw	r3,-32(fp)
 d0489fc:	e0bffa17 	ldw	r2,-24(fp)
 d048a00:	18800115 	stw	r2,4(r3)
      match->inp_next->inp_prev = match;
 d048a04:	e0bff817 	ldw	r2,-32(fp)
 d048a08:	10c00017 	ldw	r3,0(r2)
 d048a0c:	e0bff817 	ldw	r2,-32(fp)
 d048a10:	18800115 	stw	r2,4(r3)
   }
   return (match);
 d048a14:	e0bff817 	ldw	r2,-32(fp)
 d048a18:	e0bfff15 	stw	r2,-4(fp)
 d048a1c:	e0bfff17 	ldw	r2,-4(fp)
}
 d048a20:	e037883a 	mov	sp,fp
 d048a24:	df000017 	ldw	fp,0(sp)
 d048a28:	dec00104 	addi	sp,sp,4
 d048a2c:	f800283a 	ret

0d048a30 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 d048a30:	defffe04 	addi	sp,sp,-8
 d048a34:	df000115 	stw	fp,4(sp)
 d048a38:	df000104 	addi	fp,sp,4
 d048a3c:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 d048a40:	e0bfff17 	ldw	r2,-4(fp)
 d048a44:	d0a95615 	stw	r2,-23208(gp)
}
 d048a48:	e037883a 	mov	sp,fp
 d048a4c:	df000017 	ldw	fp,0(sp)
 d048a50:	dec00104 	addi	sp,sp,4
 d048a54:	f800283a 	ret

0d048a58 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 d048a58:	deffff04 	addi	sp,sp,-4
 d048a5c:	df000015 	stw	fp,0(sp)
 d048a60:	d839883a 	mov	fp,sp
   return vfopen_error;
 d048a64:	d0a95617 	ldw	r2,-23208(gp)
}
 d048a68:	e037883a 	mov	sp,fp
 d048a6c:	df000017 	ldw	fp,0(sp)
 d048a70:	dec00104 	addi	sp,sp,4
 d048a74:	f800283a 	ret

0d048a78 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 d048a78:	defffc04 	addi	sp,sp,-16
 d048a7c:	dfc00315 	stw	ra,12(sp)
 d048a80:	df000215 	stw	fp,8(sp)
 d048a84:	df000204 	addi	fp,sp,8
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 d048a88:	d0a95817 	ldw	r2,-23200(gp)
 d048a8c:	10803ff0 	cmpltui	r2,r2,255
 d048a90:	1000021e 	bne	r2,zero,d048a9c <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 d048a94:	e03fff15 	stw	zero,-4(fp)
 d048a98:	00001006 	br	d048adc <vf_alloc_and_link_vop+0x64>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 d048a9c:	01000504 	movi	r4,20
 d048aa0:	d0264b80 	call	d0264b8 <npalloc>
 d048aa4:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (vop)
 d048aa8:	e0bffe17 	ldw	r2,-8(fp)
 d048aac:	1005003a 	cmpeq	r2,r2,zero
 d048ab0:	1000081e 	bne	r2,zero,d048ad4 <vf_alloc_and_link_vop+0x5c>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 d048ab4:	d0e95417 	ldw	r3,-23216(gp)
 d048ab8:	e0bffe17 	ldw	r2,-8(fp)
 d048abc:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 d048ac0:	e0bffe17 	ldw	r2,-8(fp)
 d048ac4:	d0a95415 	stw	r2,-23216(gp)
      /* increment the count of open files */
      vfs_open_files++;
 d048ac8:	d0a95817 	ldw	r2,-23200(gp)
 d048acc:	10800044 	addi	r2,r2,1
 d048ad0:	d0a95815 	stw	r2,-23200(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 d048ad4:	e0bffe17 	ldw	r2,-8(fp)
 d048ad8:	e0bfff15 	stw	r2,-4(fp)
 d048adc:	e0bfff17 	ldw	r2,-4(fp)
}
 d048ae0:	e037883a 	mov	sp,fp
 d048ae4:	dfc00117 	ldw	ra,4(sp)
 d048ae8:	df000017 	ldw	fp,0(sp)
 d048aec:	dec00204 	addi	sp,sp,8
 d048af0:	f800283a 	ret

0d048af4 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 d048af4:	defff804 	addi	sp,sp,-32
 d048af8:	dfc00715 	stw	ra,28(sp)
 d048afc:	df000615 	stw	fp,24(sp)
 d048b00:	df000604 	addi	fp,sp,24
 d048b04:	e13ffe15 	stw	r4,-8(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 d048b08:	d0e95917 	ldw	r3,-23196(gp)
 d048b0c:	e0bffe17 	ldw	r2,-8(fp)
 d048b10:	1887883a 	add	r3,r3,r2
 d048b14:	00bfffd4 	movui	r2,65535
 d048b18:	10c0022e 	bgeu	r2,r3,d048b24 <vf_alloc_buffer+0x30>
      return NULL;
 d048b1c:	e03fff15 	stw	zero,-4(fp)
 d048b20:	00002406 	br	d048bb4 <vf_alloc_buffer+0xc0>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 d048b24:	00800104 	movi	r2,4
 d048b28:	e0bffc15 	stw	r2,-16(fp)
   int_size = sizeof(unsigned int);
 d048b2c:	00800104 	movi	r2,4
 d048b30:	e0bffb15 	stw	r2,-20(fp)
   if (long_size > int_size)
 d048b34:	e0fffc17 	ldw	r3,-16(fp)
 d048b38:	e0bffb17 	ldw	r2,-20(fp)
 d048b3c:	10c0112e 	bgeu	r2,r3,d048b84 <vf_alloc_buffer+0x90>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 d048b40:	e0bffb17 	ldw	r2,-20(fp)
 d048b44:	108000a0 	cmpeqi	r2,r2,2
 d048b48:	1000011e 	bne	r2,zero,d048b50 <vf_alloc_buffer+0x5c>
 d048b4c:	00000806 	br	d048b70 <vf_alloc_buffer+0x7c>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 d048b50:	00bffff4 	movhi	r2,65535
 d048b54:	e0bffa15 	stw	r2,-24(fp)
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 d048b58:	e0fffe17 	ldw	r3,-8(fp)
 d048b5c:	e0bffa17 	ldw	r2,-24(fp)
 d048b60:	1884703a 	and	r2,r3,r2
 d048b64:	1004c03a 	cmpne	r2,r2,zero
 d048b68:	1000041e 	bne	r2,zero,d048b7c <vf_alloc_buffer+0x88>
 d048b6c:	00000506 	br	d048b84 <vf_alloc_buffer+0x90>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 d048b70:	d025a500 	call	d025a50 <dtrap>
         return NULL;
 d048b74:	e03fff15 	stw	zero,-4(fp)
 d048b78:	00000e06 	br	d048bb4 <vf_alloc_buffer+0xc0>
      }

      if (size & mem_mask)
         return NULL;
 d048b7c:	e03fff15 	stw	zero,-4(fp)
 d048b80:	00000c06 	br	d048bb4 <vf_alloc_buffer+0xc0>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 d048b84:	e13ffe17 	ldw	r4,-8(fp)
 d048b88:	d0264b80 	call	d0264b8 <npalloc>
 d048b8c:	e0bffd15 	stw	r2,-12(fp)

   /* if the allocation succeeded */
   if (buffer)
 d048b90:	e0bffd17 	ldw	r2,-12(fp)
 d048b94:	1005003a 	cmpeq	r2,r2,zero
 d048b98:	1000041e 	bne	r2,zero,d048bac <vf_alloc_buffer+0xb8>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 d048b9c:	d0a95917 	ldw	r2,-23196(gp)
 d048ba0:	e0fffe17 	ldw	r3,-8(fp)
 d048ba4:	10c5883a 	add	r2,r2,r3
 d048ba8:	d0a95915 	stw	r2,-23196(gp)
   }

   return buffer;
 d048bac:	e0bffd17 	ldw	r2,-12(fp)
 d048bb0:	e0bfff15 	stw	r2,-4(fp)
 d048bb4:	e0bfff17 	ldw	r2,-4(fp)
}
 d048bb8:	e037883a 	mov	sp,fp
 d048bbc:	dfc00117 	ldw	ra,4(sp)
 d048bc0:	df000017 	ldw	fp,0(sp)
 d048bc4:	dec00204 	addi	sp,sp,8
 d048bc8:	f800283a 	ret

0d048bcc <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 d048bcc:	defffc04 	addi	sp,sp,-16
 d048bd0:	dfc00315 	stw	ra,12(sp)
 d048bd4:	df000215 	stw	fp,8(sp)
 d048bd8:	df000204 	addi	fp,sp,8
 d048bdc:	e13ffe15 	stw	r4,-8(fp)
 d048be0:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 d048be4:	e0bffe17 	ldw	r2,-8(fp)
 d048be8:	1005003a 	cmpeq	r2,r2,zero
 d048bec:	1000021e 	bne	r2,zero,d048bf8 <vf_free_buffer+0x2c>
      npfree(buffer);
 d048bf0:	e13ffe17 	ldw	r4,-8(fp)
 d048bf4:	d0265ac0 	call	d0265ac <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 d048bf8:	d0a95917 	ldw	r2,-23196(gp)
 d048bfc:	e0ffff17 	ldw	r3,-4(fp)
 d048c00:	10c5c83a 	sub	r2,r2,r3
 d048c04:	d0a95915 	stw	r2,-23196(gp)
}
 d048c08:	e037883a 	mov	sp,fp
 d048c0c:	dfc00117 	ldw	ra,4(sp)
 d048c10:	df000017 	ldw	fp,0(sp)
 d048c14:	dec00204 	addi	sp,sp,8
 d048c18:	f800283a 	ret

0d048c1c <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 d048c1c:	defff804 	addi	sp,sp,-32
 d048c20:	dfc00715 	stw	ra,28(sp)
 d048c24:	df000615 	stw	fp,24(sp)
 d048c28:	df000604 	addi	fp,sp,24
 d048c2c:	e13ffd15 	stw	r4,-12(fp)
 d048c30:	e17ffe15 	stw	r5,-8(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 d048c34:	0009883a 	mov	r4,zero
 d048c38:	d048a300 	call	d048a30 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 d048c3c:	e13ffd17 	ldw	r4,-12(fp)
 d048c40:	01400fc4 	movi	r5,63
 d048c44:	d002d100 	call	d002d10 <strchr>
 d048c48:	1005003a 	cmpeq	r2,r2,zero
 d048c4c:	1000031e 	bne	r2,zero,d048c5c <vfopen_locked+0x40>
   {
      dtrap();
 d048c50:	d025a500 	call	d025a50 <dtrap>
      return NULL;
 d048c54:	e03fff15 	stw	zero,-4(fp)
 d048c58:	0000c406 	br	d048f6c <vfopen_locked+0x350>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 d048c5c:	e13ffd17 	ldw	r4,-12(fp)
 d048c60:	d049fc80 	call	d049fc8 <vfslookup_locked>
 d048c64:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 d048c68:	e0bffc17 	ldw	r2,-16(fp)
 d048c6c:	1005003a 	cmpeq	r2,r2,zero
 d048c70:	10004e1e 	bne	r2,zero,d048dac <vfopen_locked+0x190>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 d048c74:	e0bffe17 	ldw	r2,-8(fp)
 d048c78:	10800003 	ldbu	r2,0(r2)
 d048c7c:	10803fcc 	andi	r2,r2,255
 d048c80:	1080201c 	xori	r2,r2,128
 d048c84:	10bfe004 	addi	r2,r2,-128
 d048c88:	10801dd8 	cmpnei	r2,r2,119
 d048c8c:	10000a1e 	bne	r2,zero,d048cb8 <vfopen_locked+0x9c>
 d048c90:	e0bffc17 	ldw	r2,-16(fp)
 d048c94:	1080058b 	ldhu	r2,22(r2)
 d048c98:	10bfffcc 	andi	r2,r2,65535
 d048c9c:	1080080c 	andi	r2,r2,32
 d048ca0:	1004c03a 	cmpne	r2,r2,zero
 d048ca4:	1000041e 	bne	r2,zero,d048cb8 <vfopen_locked+0x9c>
      {
         set_vfopen_error(ENP_FILEIO);
 d048ca8:	013ff984 	movi	r4,-26
 d048cac:	d048a300 	call	d048a30 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d048cb0:	e03fff15 	stw	zero,-4(fp)
 d048cb4:	0000ad06 	br	d048f6c <vfopen_locked+0x350>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 d048cb8:	d048a780 	call	d048a78 <vf_alloc_and_link_vop>
 d048cbc:	e0bffb15 	stw	r2,-20(fp)

      /* check for failure */
      if (!vop)
 d048cc0:	e0bffb17 	ldw	r2,-20(fp)
 d048cc4:	1004c03a 	cmpne	r2,r2,zero
 d048cc8:	1000041e 	bne	r2,zero,d048cdc <vfopen_locked+0xc0>
      {
         set_vfopen_error(ENP_NOMEM);
 d048ccc:	013ffb04 	movi	r4,-20
 d048cd0:	d048a300 	call	d048a30 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d048cd4:	e03fff15 	stw	zero,-4(fp)
 d048cd8:	0000a406 	br	d048f6c <vfopen_locked+0x350>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 d048cdc:	e0fffb17 	ldw	r3,-20(fp)
 d048ce0:	e0bffc17 	ldw	r2,-16(fp)
 d048ce4:	18800115 	stw	r2,4(r3)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 d048ce8:	e0bffc17 	ldw	r2,-16(fp)
 d048cec:	10c00617 	ldw	r3,24(r2)
 d048cf0:	e0bffb17 	ldw	r2,-20(fp)
 d048cf4:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 d048cf8:	e0bffe17 	ldw	r2,-8(fp)
 d048cfc:	10800003 	ldbu	r2,0(r2)
 d048d00:	10803fcc 	andi	r2,r2,255
 d048d04:	1080201c 	xori	r2,r2,128
 d048d08:	10bfe004 	addi	r2,r2,-128
 d048d0c:	10801858 	cmpnei	r2,r2,97
 d048d10:	10000b1e 	bne	r2,zero,d048d40 <vfopen_locked+0x124>
      {
         if (vfp->data)
 d048d14:	e0bffc17 	ldw	r2,-16(fp)
 d048d18:	10800617 	ldw	r2,24(r2)
 d048d1c:	1005003a 	cmpeq	r2,r2,zero
 d048d20:	1000071e 	bne	r2,zero,d048d40 <vfopen_locked+0x124>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 d048d24:	e0bffc17 	ldw	r2,-16(fp)
 d048d28:	10c00617 	ldw	r3,24(r2)
 d048d2c:	e0bffc17 	ldw	r2,-16(fp)
 d048d30:	10800817 	ldw	r2,32(r2)
 d048d34:	1887883a 	add	r3,r3,r2
 d048d38:	e0bffb17 	ldw	r2,-20(fp)
 d048d3c:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 d048d40:	e0bffe17 	ldw	r2,-8(fp)
 d048d44:	10800003 	ldbu	r2,0(r2)
 d048d48:	10803fcc 	andi	r2,r2,255
 d048d4c:	1080201c 	xori	r2,r2,128
 d048d50:	10bfe004 	addi	r2,r2,-128
 d048d54:	10801dd8 	cmpnei	r2,r2,119
 d048d58:	1000111e 	bne	r2,zero,d048da0 <vfopen_locked+0x184>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 d048d5c:	e0bffc17 	ldw	r2,-16(fp)
 d048d60:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 d048d64:	e0bffc17 	ldw	r2,-16(fp)
 d048d68:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 d048d6c:	e0bffc17 	ldw	r2,-16(fp)
 d048d70:	1080058b 	ldhu	r2,22(r2)
 d048d74:	10808014 	ori	r2,r2,512
 d048d78:	1007883a 	mov	r3,r2
 d048d7c:	e0bffc17 	ldw	r2,-16(fp)
 d048d80:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 d048d84:	e0bffc17 	ldw	r2,-16(fp)
 d048d88:	10c0058b 	ldhu	r3,22(r2)
 d048d8c:	00bfff84 	movi	r2,-2
 d048d90:	1884703a 	and	r2,r3,r2
 d048d94:	1007883a 	mov	r3,r2
 d048d98:	e0bffc17 	ldw	r2,-16(fp)
 d048d9c:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 d048da0:	e0bffb17 	ldw	r2,-20(fp)
 d048da4:	e0bfff15 	stw	r2,-4(fp)
 d048da8:	00007006 	br	d048f6c <vfopen_locked+0x350>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 d048dac:	e0bffe17 	ldw	r2,-8(fp)
 d048db0:	10800003 	ldbu	r2,0(r2)
 d048db4:	10803fcc 	andi	r2,r2,255
 d048db8:	1080201c 	xori	r2,r2,128
 d048dbc:	10bfe004 	addi	r2,r2,-128
 d048dc0:	10801ca0 	cmpeqi	r2,r2,114
 d048dc4:	1000151e 	bne	r2,zero,d048e1c <vfopen_locked+0x200>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 d048dc8:	d0a95317 	ldw	r2,-23220(gp)
 d048dcc:	e0bffa15 	stw	r2,-24(fp)
 d048dd0:	00000f06 	br	d048e10 <vfopen_locked+0x1f4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 d048dd4:	e0bffa17 	ldw	r2,-24(fp)
 d048dd8:	10800117 	ldw	r2,4(r2)
 d048ddc:	e13ffd17 	ldw	r4,-12(fp)
 d048de0:	e17ffe17 	ldw	r5,-8(fp)
 d048de4:	103ee83a 	callr	r2
 d048de8:	e0bffb15 	stw	r2,-20(fp)
 d048dec:	e0bffb17 	ldw	r2,-20(fp)
 d048df0:	1005003a 	cmpeq	r2,r2,zero
 d048df4:	1000031e 	bne	r2,zero,d048e04 <vfopen_locked+0x1e8>
         {
            return vop;
 d048df8:	e0bffb17 	ldw	r2,-20(fp)
 d048dfc:	e0bfff15 	stw	r2,-4(fp)
 d048e00:	00005a06 	br	d048f6c <vfopen_locked+0x350>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 d048e04:	e0bffa17 	ldw	r2,-24(fp)
 d048e08:	10800017 	ldw	r2,0(r2)
 d048e0c:	e0bffa15 	stw	r2,-24(fp)
 d048e10:	e0bffa17 	ldw	r2,-24(fp)
 d048e14:	1004c03a 	cmpne	r2,r2,zero
 d048e18:	103fee1e 	bne	r2,zero,d048dd4 <vfopen_locked+0x1b8>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 d048e1c:	e0bffe17 	ldw	r2,-8(fp)
 d048e20:	10800003 	ldbu	r2,0(r2)
 d048e24:	10803fcc 	andi	r2,r2,255
 d048e28:	1080201c 	xori	r2,r2,128
 d048e2c:	10bfe004 	addi	r2,r2,-128
 d048e30:	10801ca0 	cmpeqi	r2,r2,114
 d048e34:	10004a1e 	bne	r2,zero,d048f60 <vfopen_locked+0x344>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 d048e38:	d0a95a17 	ldw	r2,-23192(gp)
 d048e3c:	10803ff0 	cmpltui	r2,r2,255
 d048e40:	1000041e 	bne	r2,zero,d048e54 <vfopen_locked+0x238>
      {
         set_vfopen_error(ENP_NOMEM);
 d048e44:	013ffb04 	movi	r4,-20
 d048e48:	d048a300 	call	d048a30 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d048e4c:	e03fff15 	stw	zero,-4(fp)
 d048e50:	00004606 	br	d048f6c <vfopen_locked+0x350>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 d048e54:	e13ffd17 	ldw	r4,-12(fp)
 d048e58:	d0034640 	call	d003464 <strlen>
 d048e5c:	10800470 	cmpltui	r2,r2,17
 d048e60:	1000041e 	bne	r2,zero,d048e74 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_PARAM);
 d048e64:	013ffd84 	movi	r4,-10
 d048e68:	d048a300 	call	d048a30 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d048e6c:	e03fff15 	stw	zero,-4(fp)
 d048e70:	00003e06 	br	d048f6c <vfopen_locked+0x350>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 d048e74:	01000b04 	movi	r4,44
 d048e78:	d0264b80 	call	d0264b8 <npalloc>
 d048e7c:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 d048e80:	e0bffc17 	ldw	r2,-16(fp)
 d048e84:	1004c03a 	cmpne	r2,r2,zero
 d048e88:	1000041e 	bne	r2,zero,d048e9c <vfopen_locked+0x280>
      {
         set_vfopen_error(ENP_NOMEM);
 d048e8c:	013ffb04 	movi	r4,-20
 d048e90:	d048a300 	call	d048a30 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d048e94:	e03fff15 	stw	zero,-4(fp)
 d048e98:	00003406 	br	d048f6c <vfopen_locked+0x350>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 d048e9c:	d048a780 	call	d048a78 <vf_alloc_and_link_vop>
 d048ea0:	e0bffb15 	stw	r2,-20(fp)

      /* check for memory allocation failure */
      if (!vop)
 d048ea4:	e0bffb17 	ldw	r2,-20(fp)
 d048ea8:	1004c03a 	cmpne	r2,r2,zero
 d048eac:	1000061e 	bne	r2,zero,d048ec8 <vfopen_locked+0x2ac>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 d048eb0:	e13ffc17 	ldw	r4,-16(fp)
 d048eb4:	d0265ac0 	call	d0265ac <npfree>
         set_vfopen_error(ENP_NOMEM);
 d048eb8:	013ffb04 	movi	r4,-20
 d048ebc:	d048a300 	call	d048a30 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d048ec0:	e03fff15 	stw	zero,-4(fp)
 d048ec4:	00002906 	br	d048f6c <vfopen_locked+0x350>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 d048ec8:	d0e95517 	ldw	r3,-23212(gp)
 d048ecc:	e0bffc17 	ldw	r2,-16(fp)
 d048ed0:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 d048ed4:	e0bffc17 	ldw	r2,-16(fp)
 d048ed8:	d0a95515 	stw	r2,-23212(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 d048edc:	d0a95a17 	ldw	r2,-23192(gp)
 d048ee0:	10800044 	addi	r2,r2,1
 d048ee4:	d0a95a15 	stw	r2,-23192(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 d048ee8:	e0bffd17 	ldw	r2,-12(fp)
 d048eec:	10800003 	ldbu	r2,0(r2)
 d048ef0:	10803fcc 	andi	r2,r2,255
 d048ef4:	1080201c 	xori	r2,r2,128
 d048ef8:	10bfe004 	addi	r2,r2,-128
 d048efc:	10800be0 	cmpeqi	r2,r2,47
 d048f00:	1000071e 	bne	r2,zero,d048f20 <vfopen_locked+0x304>
 d048f04:	e0bffd17 	ldw	r2,-12(fp)
 d048f08:	10800003 	ldbu	r2,0(r2)
 d048f0c:	10803fcc 	andi	r2,r2,255
 d048f10:	1080201c 	xori	r2,r2,128
 d048f14:	10bfe004 	addi	r2,r2,-128
 d048f18:	10801718 	cmpnei	r2,r2,92
 d048f1c:	1000031e 	bne	r2,zero,d048f2c <vfopen_locked+0x310>
         name++;
 d048f20:	e0bffd17 	ldw	r2,-12(fp)
 d048f24:	10800044 	addi	r2,r2,1
 d048f28:	e0bffd15 	stw	r2,-12(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 d048f2c:	e0bffc17 	ldw	r2,-16(fp)
 d048f30:	11000104 	addi	r4,r2,4
 d048f34:	e17ffd17 	ldw	r5,-12(fp)
 d048f38:	d04beb80 	call	d04beb8 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 d048f3c:	e0fffc17 	ldw	r3,-16(fp)
 d048f40:	0080d804 	movi	r2,864
 d048f44:	1880058d 	sth	r2,22(r3)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 d048f48:	e0fffb17 	ldw	r3,-20(fp)
 d048f4c:	e0bffc17 	ldw	r2,-16(fp)
 d048f50:	18800115 	stw	r2,4(r3)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 d048f54:	e0bffb17 	ldw	r2,-20(fp)
 d048f58:	e0bfff15 	stw	r2,-4(fp)
 d048f5c:	00000306 	br	d048f6c <vfopen_locked+0x350>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 d048f60:	013ff9c4 	movi	r4,-25
 d048f64:	d048a300 	call	d048a30 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 d048f68:	e03fff15 	stw	zero,-4(fp)
 d048f6c:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_LOCALFS */
}
 d048f70:	e037883a 	mov	sp,fp
 d048f74:	dfc00117 	ldw	ra,4(sp)
 d048f78:	df000017 	ldw	fp,0(sp)
 d048f7c:	dec00204 	addi	sp,sp,8
 d048f80:	f800283a 	ret

0d048f84 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 d048f84:	defffb04 	addi	sp,sp,-20
 d048f88:	dfc00415 	stw	ra,16(sp)
 d048f8c:	df000315 	stw	fp,12(sp)
 d048f90:	df000304 	addi	fp,sp,12
 d048f94:	e13ffe15 	stw	r4,-8(fp)
 d048f98:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 d048f9c:	01000144 	movi	r4,5
 d048fa0:	d02604c0 	call	d02604c <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 d048fa4:	e13ffe17 	ldw	r4,-8(fp)
 d048fa8:	e17fff17 	ldw	r5,-4(fp)
 d048fac:	d048c1c0 	call	d048c1c <vfopen_locked>
 d048fb0:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 d048fb4:	01000144 	movi	r4,5
 d048fb8:	d0261000 	call	d026100 <post_app_sem>

   return vfd;
 d048fbc:	e0bffd17 	ldw	r2,-12(fp)
}
 d048fc0:	e037883a 	mov	sp,fp
 d048fc4:	dfc00117 	ldw	ra,4(sp)
 d048fc8:	df000017 	ldw	fp,0(sp)
 d048fcc:	dec00204 	addi	sp,sp,8
 d048fd0:	f800283a 	ret

0d048fd4 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 d048fd4:	defff804 	addi	sp,sp,-32
 d048fd8:	dfc00715 	stw	ra,28(sp)
 d048fdc:	df000615 	stw	fp,24(sp)
 d048fe0:	df000604 	addi	fp,sp,24
 d048fe4:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 d048fe8:	e03ffd15 	stw	zero,-12(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 d048fec:	d0a95417 	ldw	r2,-23216(gp)
 d048ff0:	e0bffe15 	stw	r2,-8(fp)
   while (vtmp)
 d048ff4:	00000806 	br	d049018 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 d048ff8:	e0ffff17 	ldw	r3,-4(fp)
 d048ffc:	e0bffe17 	ldw	r2,-8(fp)
 d049000:	18800826 	beq	r3,r2,d049024 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 d049004:	e0bffe17 	ldw	r2,-8(fp)
 d049008:	e0bffd15 	stw	r2,-12(fp)
      vtmp = vtmp->next;
 d04900c:	e0bffe17 	ldw	r2,-8(fp)
 d049010:	10800017 	ldw	r2,0(r2)
 d049014:	e0bffe15 	stw	r2,-8(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 d049018:	e0bffe17 	ldw	r2,-8(fp)
 d04901c:	1004c03a 	cmpne	r2,r2,zero
 d049020:	103ff51e 	bne	r2,zero,d048ff8 <vfclose_locked+0x24>
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 d049024:	e0ffff17 	ldw	r3,-4(fp)
 d049028:	e0bffe17 	ldw	r2,-8(fp)
 d04902c:	18804e1e 	bne	r3,r2,d049168 <vfclose_locked+0x194>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 d049030:	e0bfff17 	ldw	r2,-4(fp)
 d049034:	10800117 	ldw	r2,4(r2)
 d049038:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 d04903c:	e0bffc17 	ldw	r2,-16(fp)
 d049040:	1005003a 	cmpeq	r2,r2,zero
 d049044:	1000381e 	bne	r2,zero,d049128 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 d049048:	e0bffc17 	ldw	r2,-16(fp)
 d04904c:	10800a17 	ldw	r2,40(r2)
 d049050:	1005003a 	cmpeq	r2,r2,zero
 d049054:	1000081e 	bne	r2,zero,d049078 <vfclose_locked+0xa4>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 d049058:	e0bffc17 	ldw	r2,-16(fp)
 d04905c:	10800a17 	ldw	r2,40(r2)
 d049060:	e0bffa15 	stw	r2,-24(fp)

         vfs->r_fclose(vfd);
 d049064:	e0bffa17 	ldw	r2,-24(fp)
 d049068:	10800217 	ldw	r2,8(r2)
 d04906c:	e13fff17 	ldw	r4,-4(fp)
 d049070:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 d049074:	00002c06 	br	d049128 <vfclose_locked+0x154>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 d049078:	e0bffc17 	ldw	r2,-16(fp)
 d04907c:	1080058b 	ldhu	r2,22(r2)
 d049080:	10bfffcc 	andi	r2,r2,65535
 d049084:	1080200c 	andi	r2,r2,128
 d049088:	1005003a 	cmpeq	r2,r2,zero
 d04908c:	1000261e 	bne	r2,zero,d049128 <vfclose_locked+0x154>
 d049090:	e0bffc17 	ldw	r2,-16(fp)
 d049094:	10c00917 	ldw	r3,36(r2)
 d049098:	e0bffc17 	ldw	r2,-16(fp)
 d04909c:	10800817 	ldw	r2,32(r2)
 d0490a0:	1885c83a 	sub	r2,r3,r2
 d0490a4:	10804030 	cmpltui	r2,r2,256
 d0490a8:	10001f1e 	bne	r2,zero,d049128 <vfclose_locked+0x154>
 d0490ac:	e0bffc17 	ldw	r2,-16(fp)
 d0490b0:	10800617 	ldw	r2,24(r2)
 d0490b4:	1005003a 	cmpeq	r2,r2,zero
 d0490b8:	10001b1e 	bne	r2,zero,d049128 <vfclose_locked+0x154>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 d0490bc:	e0bffc17 	ldw	r2,-16(fp)
 d0490c0:	11000817 	ldw	r4,32(r2)
 d0490c4:	d048af40 	call	d048af4 <vf_alloc_buffer>
 d0490c8:	e0bffb15 	stw	r2,-20(fp)

         /* if the allocation worked */
         if (new_buffer)
 d0490cc:	e0bffb17 	ldw	r2,-20(fp)
 d0490d0:	1005003a 	cmpeq	r2,r2,zero
 d0490d4:	1000141e 	bne	r2,zero,d049128 <vfclose_locked+0x154>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 d0490d8:	e0bffc17 	ldw	r2,-16(fp)
 d0490dc:	10c00617 	ldw	r3,24(r2)
 d0490e0:	e0bffc17 	ldw	r2,-16(fp)
 d0490e4:	11800817 	ldw	r6,32(r2)
 d0490e8:	e0bffb17 	ldw	r2,-20(fp)
 d0490ec:	1009883a 	mov	r4,r2
 d0490f0:	180b883a 	mov	r5,r3
 d0490f4:	d0026080 	call	d002608 <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 d0490f8:	e0bffc17 	ldw	r2,-16(fp)
 d0490fc:	11000617 	ldw	r4,24(r2)
 d049100:	e0bffc17 	ldw	r2,-16(fp)
 d049104:	11400917 	ldw	r5,36(r2)
 d049108:	d048bcc0 	call	d048bcc <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 d04910c:	e0fffc17 	ldw	r3,-16(fp)
 d049110:	e0bffb17 	ldw	r2,-20(fp)
 d049114:	18800615 	stw	r2,24(r3)
            vfp->buf_size = vfp->comp_size;
 d049118:	e0bffc17 	ldw	r2,-16(fp)
 d04911c:	10c00817 	ldw	r3,32(r2)
 d049120:	e0bffc17 	ldw	r2,-16(fp)
 d049124:	10c00915 	stw	r3,36(r2)
      /* break to list deletion code below */
      break;

   }

   if (vlast)  /* unlink from list of open files */
 d049128:	e0bffd17 	ldw	r2,-12(fp)
 d04912c:	1005003a 	cmpeq	r2,r2,zero
 d049130:	1000051e 	bne	r2,zero,d049148 <vfclose_locked+0x174>
      vlast->next = vtmp->next;
 d049134:	e0bffe17 	ldw	r2,-8(fp)
 d049138:	10c00017 	ldw	r3,0(r2)
 d04913c:	e0bffd17 	ldw	r2,-12(fp)
 d049140:	10c00015 	stw	r3,0(r2)
 d049144:	00000306 	br	d049154 <vfclose_locked+0x180>
   else
      vfiles = vtmp->next;
 d049148:	e0bffe17 	ldw	r2,-8(fp)
 d04914c:	10800017 	ldw	r2,0(r2)
 d049150:	d0a95415 	stw	r2,-23216(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 d049154:	e13ffe17 	ldw	r4,-8(fp)
 d049158:	d0265ac0 	call	d0265ac <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 d04915c:	d0a95817 	ldw	r2,-23200(gp)
 d049160:	10bfffc4 	addi	r2,r2,-1
 d049164:	d0a95815 	stw	r2,-23200(gp)
   return;
}
 d049168:	e037883a 	mov	sp,fp
 d04916c:	dfc00117 	ldw	ra,4(sp)
 d049170:	df000017 	ldw	fp,0(sp)
 d049174:	dec00204 	addi	sp,sp,8
 d049178:	f800283a 	ret

0d04917c <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 d04917c:	defffd04 	addi	sp,sp,-12
 d049180:	dfc00215 	stw	ra,8(sp)
 d049184:	df000115 	stw	fp,4(sp)
 d049188:	df000104 	addi	fp,sp,4
 d04918c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 d049190:	01000144 	movi	r4,5
 d049194:	d02604c0 	call	d02604c <wait_app_sem>

   vfclose_locked(vfd);
 d049198:	e13fff17 	ldw	r4,-4(fp)
 d04919c:	d048fd40 	call	d048fd4 <vfclose_locked>

   vfs_unlock();
 d0491a0:	01000144 	movi	r4,5
 d0491a4:	d0261000 	call	d026100 <post_app_sem>
}
 d0491a8:	e037883a 	mov	sp,fp
 d0491ac:	dfc00117 	ldw	ra,4(sp)
 d0491b0:	df000017 	ldw	fp,0(sp)
 d0491b4:	dec00204 	addi	sp,sp,8
 d0491b8:	f800283a 	ret

0d0491bc <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 d0491bc:	defffd04 	addi	sp,sp,-12
 d0491c0:	dfc00215 	stw	ra,8(sp)
 d0491c4:	df000115 	stw	fp,4(sp)
 d0491c8:	df000104 	addi	fp,sp,4
 d0491cc:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 d0491d0:	01000144 	movi	r4,5
 d0491d4:	d02604c0 	call	d02604c <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 d0491d8:	01034174 	movhi	r4,3333
 d0491dc:	21092304 	addi	r4,r4,9356
 d0491e0:	d002bc80 	call	d002bc8 <puts>

   vfs_unlock();
 d0491e4:	01000144 	movi	r4,5
 d0491e8:	d0261000 	call	d026100 <post_app_sem>
   return(0);
 d0491ec:	0005883a 	mov	r2,zero
}
 d0491f0:	e037883a 	mov	sp,fp
 d0491f4:	dfc00117 	ldw	ra,4(sp)
 d0491f8:	df000017 	ldw	fp,0(sp)
 d0491fc:	dec00204 	addi	sp,sp,8
 d049200:	f800283a 	ret

0d049204 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 d049204:	defff804 	addi	sp,sp,-32
 d049208:	dfc00715 	stw	ra,28(sp)
 d04920c:	df000615 	stw	fp,24(sp)
 d049210:	df000604 	addi	fp,sp,24
 d049214:	e13ffc15 	stw	r4,-16(fp)
 d049218:	e17ffd15 	stw	r5,-12(fp)
 d04921c:	e1bffe15 	stw	r6,-8(fp)
   int c;
   char * ret;

   ret = s;
 d049220:	e0bffc17 	ldw	r2,-16(fp)
 d049224:	e0bffa15 	stw	r2,-24(fp)
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 d049228:	00001106 	br	d049270 <vfgets+0x6c>
      if (( *ret ++ = c) == '\n')
 d04922c:	e0bffb17 	ldw	r2,-20(fp)
 d049230:	1007883a 	mov	r3,r2
 d049234:	e0bffa17 	ldw	r2,-24(fp)
 d049238:	10c00005 	stb	r3,0(r2)
 d04923c:	e0bffa17 	ldw	r2,-24(fp)
 d049240:	10800003 	ldbu	r2,0(r2)
 d049244:	10803fcc 	andi	r2,r2,255
 d049248:	1080201c 	xori	r2,r2,128
 d04924c:	10bfe004 	addi	r2,r2,-128
 d049250:	108002a0 	cmpeqi	r2,r2,10
 d049254:	1007883a 	mov	r3,r2
 d049258:	e0bffa17 	ldw	r2,-24(fp)
 d04925c:	10800044 	addi	r2,r2,1
 d049260:	e0bffa15 	stw	r2,-24(fp)
 d049264:	18803fcc 	andi	r2,r3,255
 d049268:	1004c03a 	cmpne	r2,r2,zero
 d04926c:	10000c1e 	bne	r2,zero,d0492a0 <vfgets+0x9c>
{
   int c;
   char * ret;

   ret = s;
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 d049270:	e0bffd17 	ldw	r2,-12(fp)
 d049274:	10bfffc4 	addi	r2,r2,-1
 d049278:	e0bffd15 	stw	r2,-12(fp)
 d04927c:	e0bffd17 	ldw	r2,-12(fp)
 d049280:	10800050 	cmplti	r2,r2,1
 d049284:	1000061e 	bne	r2,zero,d0492a0 <vfgets+0x9c>
 d049288:	e13ffe17 	ldw	r4,-8(fp)
 d04928c:	d049f800 	call	d049f80 <vgetc>
 d049290:	e0bffb15 	stw	r2,-20(fp)
 d049294:	e0bffb17 	ldw	r2,-20(fp)
 d049298:	10bfffd8 	cmpnei	r2,r2,-1
 d04929c:	103fe31e 	bne	r2,zero,d04922c <vfgets+0x28>
      if (( *ret ++ = c) == '\n')
         break;
   *ret = '\0';
 d0492a0:	e0bffa17 	ldw	r2,-24(fp)
 d0492a4:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 d0492a8:	e0bffb17 	ldw	r2,-20(fp)
 d0492ac:	10bfffd8 	cmpnei	r2,r2,-1
 d0492b0:	1000031e 	bne	r2,zero,d0492c0 <vfgets+0xbc>
 d0492b4:	e0fffa17 	ldw	r3,-24(fp)
 d0492b8:	e0bffc17 	ldw	r2,-16(fp)
 d0492bc:	18800326 	beq	r3,r2,d0492cc <vfgets+0xc8>
 d0492c0:	e0bffc17 	ldw	r2,-16(fp)
 d0492c4:	e0bfff15 	stw	r2,-4(fp)
 d0492c8:	00000106 	br	d0492d0 <vfgets+0xcc>
 d0492cc:	e03fff15 	stw	zero,-4(fp)
 d0492d0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0492d4:	e037883a 	mov	sp,fp
 d0492d8:	dfc00117 	ldw	ra,4(sp)
 d0492dc:	df000017 	ldw	fp,0(sp)
 d0492e0:	dec00204 	addi	sp,sp,8
 d0492e4:	f800283a 	ret

0d0492e8 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 d0492e8:	defffb04 	addi	sp,sp,-20
 d0492ec:	dfc00415 	stw	ra,16(sp)
 d0492f0:	df000315 	stw	fp,12(sp)
 d0492f4:	df000304 	addi	fp,sp,12
 d0492f8:	e13ffe15 	stw	r4,-8(fp)
   int c = 0;
 d0492fc:	e03ffd15 	stw	zero,-12(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 d049300:	e13ffe17 	ldw	r4,-8(fp)
 d049304:	d049f800 	call	d049f80 <vgetc>
 d049308:	e0bffd15 	stw	r2,-12(fp)
 d04930c:	e0bffd17 	ldw	r2,-12(fp)
 d049310:	10bfffd8 	cmpnei	r2,r2,-1
 d049314:	1000031e 	bne	r2,zero,d049324 <vfeof+0x3c>
   {
      return 1;
 d049318:	00800044 	movi	r2,1
 d04931c:	e0bfff15 	stw	r2,-4(fp)
 d049320:	00000106 	br	d049328 <vfeof+0x40>
   }   
   return 0;
 d049324:	e03fff15 	stw	zero,-4(fp)
 d049328:	e0bfff17 	ldw	r2,-4(fp)
}
 d04932c:	e037883a 	mov	sp,fp
 d049330:	dfc00117 	ldw	ra,4(sp)
 d049334:	df000017 	ldw	fp,0(sp)
 d049338:	dec00204 	addi	sp,sp,8
 d04933c:	f800283a 	ret

0d049340 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 d049340:	defffd04 	addi	sp,sp,-12
 d049344:	df000215 	stw	fp,8(sp)
 d049348:	df000204 	addi	fp,sp,8
 d04934c:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d049350:	d0a95417 	ldw	r2,-23216(gp)
 d049354:	e0bffe15 	stw	r2,-8(fp)
 d049358:	00000906 	br	d049380 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 d04935c:	e0bffe17 	ldw	r2,-8(fp)
 d049360:	10c00117 	ldw	r3,4(r2)
 d049364:	e0bfff17 	ldw	r2,-4(fp)
 d049368:	1880021e 	bne	r3,r2,d049374 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 d04936c:	e0bffe17 	ldw	r2,-8(fp)
 d049370:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d049374:	e0bffe17 	ldw	r2,-8(fp)
 d049378:	10800017 	ldw	r2,0(r2)
 d04937c:	e0bffe15 	stw	r2,-8(fp)
 d049380:	e0bffe17 	ldw	r2,-8(fp)
 d049384:	1004c03a 	cmpne	r2,r2,zero
 d049388:	103ff41e 	bne	r2,zero,d04935c <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 d04938c:	e037883a 	mov	sp,fp
 d049390:	df000017 	ldw	fp,0(sp)
 d049394:	dec00104 	addi	sp,sp,4
 d049398:	f800283a 	ret

0d04939c <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 d04939c:	defff504 	addi	sp,sp,-44
 d0493a0:	dfc00a15 	stw	ra,40(sp)
 d0493a4:	df000915 	stw	fp,36(sp)
 d0493a8:	df000904 	addi	fp,sp,36
 d0493ac:	e13ffe15 	stw	r4,-8(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 d0493b0:	e03ffc15 	stw	zero,-16(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name));
 d0493b4:	e13ffe17 	ldw	r4,-8(fp)
 d0493b8:	d0034640 	call	d003464 <strlen>
 d0493bc:	1009883a 	mov	r4,r2
 d0493c0:	d04be300 	call	d04be30 <malloc>
 d0493c4:	e0bff815 	stw	r2,-32(fp)
   strcpy(name, const_name);
 d0493c8:	e13ff817 	ldw	r4,-32(fp)
 d0493cc:	e17ffe17 	ldw	r5,-8(fp)
 d0493d0:	d04beb80 	call	d04beb8 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 d0493d4:	01000144 	movi	r4,5
 d0493d8:	d02604c0 	call	d02604c <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 d0493dc:	e13ff817 	ldw	r4,-32(fp)
 d0493e0:	d049fc80 	call	d049fc8 <vfslookup_locked>
 d0493e4:	e0bffd15 	stw	r2,-12(fp)
 d0493e8:	e0bffd17 	ldw	r2,-12(fp)
 d0493ec:	1004c03a 	cmpne	r2,r2,zero
 d0493f0:	1000071e 	bne	r2,zero,d049410 <vunlink+0x74>
   {
      vfs_unlock();
 d0493f4:	01000144 	movi	r4,5
 d0493f8:	d0261000 	call	d026100 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 d0493fc:	e13ff817 	ldw	r4,-32(fp)
 d049400:	d04be1c0 	call	d04be1c <free>
      return -1;
 d049404:	00bfffc4 	movi	r2,-1
 d049408:	e0bfff15 	stw	r2,-4(fp)
 d04940c:	00006506 	br	d0495a4 <vunlink+0x208>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 d049410:	e0bffd17 	ldw	r2,-12(fp)
 d049414:	10800017 	ldw	r2,0(r2)
 d049418:	e0bff915 	stw	r2,-28(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 d04941c:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 d049420:	d0a95517 	ldw	r2,-23212(gp)
 d049424:	e0bffb15 	stw	r2,-20(fp)
 d049428:	00000806 	br	d04944c <vunlink+0xb0>
   {
      if (vtmp == vfp)
 d04942c:	e0fffb17 	ldw	r3,-20(fp)
 d049430:	e0bffd17 	ldw	r2,-12(fp)
 d049434:	18800826 	beq	r3,r2,d049458 <vunlink+0xbc>
         break;
      vflast = vtmp;
 d049438:	e0bffb17 	ldw	r2,-20(fp)
 d04943c:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 d049440:	e0bffb17 	ldw	r2,-20(fp)
 d049444:	10800017 	ldw	r2,0(r2)
 d049448:	e0bffb15 	stw	r2,-20(fp)
 d04944c:	e0bffb17 	ldw	r2,-20(fp)
 d049450:	1004c03a 	cmpne	r2,r2,zero
 d049454:	103ff51e 	bne	r2,zero,d04942c <vunlink+0x90>
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 d049458:	e0bffb17 	ldw	r2,-20(fp)
 d04945c:	1004c03a 	cmpne	r2,r2,zero
 d049460:	1000081e 	bne	r2,zero,d049484 <vunlink+0xe8>
   {
      dtrap();
 d049464:	d025a500 	call	d025a50 <dtrap>
      vfs_unlock();
 d049468:	01000144 	movi	r4,5
 d04946c:	d0261000 	call	d026100 <post_app_sem>
      free(name);
 d049470:	e13ff817 	ldw	r4,-32(fp)
 d049474:	d04be1c0 	call	d04be1c <free>
      return -1;
 d049478:	00bfffc4 	movi	r2,-1
 d04947c:	e0bfff15 	stw	r2,-4(fp)
 d049480:	00004806 	br	d0495a4 <vunlink+0x208>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 d049484:	e0bffd17 	ldw	r2,-12(fp)
 d049488:	10800a17 	ldw	r2,40(r2)
 d04948c:	1005003a 	cmpeq	r2,r2,zero
 d049490:	1000091e 	bne	r2,zero,d0494b8 <vunlink+0x11c>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 d049494:	e0bffd17 	ldw	r2,-12(fp)
 d049498:	10800a17 	ldw	r2,40(r2)
 d04949c:	e0bff715 	stw	r2,-36(fp)

         rc = vfs->r_unlink(name);
 d0494a0:	e0bff717 	ldw	r2,-36(fp)
 d0494a4:	10800817 	ldw	r2,32(r2)
 d0494a8:	e13ff817 	ldw	r4,-32(fp)
 d0494ac:	103ee83a 	callr	r2
 d0494b0:	e0bffc15 	stw	r2,-16(fp)
         break;   /* break to list deletion code after end of phoney loop */
 d0494b4:	00002806 	br	d049558 <vunlink+0x1bc>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 d0494b8:	e0bffd17 	ldw	r2,-12(fp)
 d0494bc:	1080058b 	ldhu	r2,22(r2)
 d0494c0:	10bfffcc 	andi	r2,r2,65535
 d0494c4:	1080080c 	andi	r2,r2,32
 d0494c8:	1004c03a 	cmpne	r2,r2,zero
 d0494cc:	1000071e 	bne	r2,zero,d0494ec <vunlink+0x150>
      {
         vfs_unlock();
 d0494d0:	01000144 	movi	r4,5
 d0494d4:	d0261000 	call	d026100 <post_app_sem>
         free(name);
 d0494d8:	e13ff817 	ldw	r4,-32(fp)
 d0494dc:	d04be1c0 	call	d04be1c <free>
         return -1;
 d0494e0:	00bfffc4 	movi	r2,-1
 d0494e4:	e0bfff15 	stw	r2,-4(fp)
 d0494e8:	00002e06 	br	d0495a4 <vunlink+0x208>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 d0494ec:	e0bffd17 	ldw	r2,-12(fp)
 d0494f0:	1080058b 	ldhu	r2,22(r2)
 d0494f4:	10bfffcc 	andi	r2,r2,65535
 d0494f8:	1080200c 	andi	r2,r2,128
 d0494fc:	1005003a 	cmpeq	r2,r2,zero
 d049500:	1000091e 	bne	r2,zero,d049528 <vunlink+0x18c>
 d049504:	e0bffd17 	ldw	r2,-12(fp)
 d049508:	10800617 	ldw	r2,24(r2)
 d04950c:	1005003a 	cmpeq	r2,r2,zero
 d049510:	1000051e 	bne	r2,zero,d049528 <vunlink+0x18c>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 d049514:	e0bffd17 	ldw	r2,-12(fp)
 d049518:	11000617 	ldw	r4,24(r2)
 d04951c:	e0bffd17 	ldw	r2,-12(fp)
 d049520:	11400917 	ldw	r5,36(r2)
 d049524:	d048bcc0 	call	d048bcc <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 d049528:	e0bffd17 	ldw	r2,-12(fp)
 d04952c:	1080058b 	ldhu	r2,22(r2)
 d049530:	10bfffcc 	andi	r2,r2,65535
 d049534:	1080100c 	andi	r2,r2,64
 d049538:	1005003a 	cmpeq	r2,r2,zero
 d04953c:	1000051e 	bne	r2,zero,d049554 <vunlink+0x1b8>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 d049540:	d0a95a17 	ldw	r2,-23192(gp)
 d049544:	10bfffc4 	addi	r2,r2,-1
 d049548:	d0a95a15 	stw	r2,-23192(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 d04954c:	e13ffd17 	ldw	r4,-12(fp)
 d049550:	d0265ac0 	call	d0265ac <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 d049554:	e03ffc15 	stw	zero,-16(fp)

      break;
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 d049558:	e0bffa17 	ldw	r2,-24(fp)
 d04955c:	1005003a 	cmpeq	r2,r2,zero
 d049560:	1000041e 	bne	r2,zero,d049574 <vunlink+0x1d8>
      vflast->next = vfnext;
 d049564:	e0fffa17 	ldw	r3,-24(fp)
 d049568:	e0bff917 	ldw	r2,-28(fp)
 d04956c:	18800015 	stw	r2,0(r3)
 d049570:	00000206 	br	d04957c <vunlink+0x1e0>
   else
      vfsfiles = vfnext;
 d049574:	e0bff917 	ldw	r2,-28(fp)
 d049578:	d0a95515 	stw	r2,-23212(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 d04957c:	e13ffd17 	ldw	r4,-12(fp)
 d049580:	d0493400 	call	d049340 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 d049584:	00800044 	movi	r2,1
 d049588:	d0a95715 	stw	r2,-23204(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 d04958c:	01000144 	movi	r4,5
 d049590:	d0261000 	call	d026100 <post_app_sem>
   free(name);
 d049594:	e13ff817 	ldw	r4,-32(fp)
 d049598:	d04be1c0 	call	d04be1c <free>
   return rc;
 d04959c:	e0bffc17 	ldw	r2,-16(fp)
 d0495a0:	e0bfff15 	stw	r2,-4(fp)
 d0495a4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0495a8:	e037883a 	mov	sp,fp
 d0495ac:	dfc00117 	ldw	ra,4(sp)
 d0495b0:	df000017 	ldw	fp,0(sp)
 d0495b4:	dec00204 	addi	sp,sp,8
 d0495b8:	f800283a 	ret

0d0495bc <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d0495bc:	defff504 	addi	sp,sp,-44
 d0495c0:	dfc00a15 	stw	ra,40(sp)
 d0495c4:	df000915 	stw	fp,36(sp)
 d0495c8:	df000904 	addi	fp,sp,36
 d0495cc:	e13ffb15 	stw	r4,-20(fp)
 d0495d0:	e17ffc15 	stw	r5,-16(fp)
 d0495d4:	e1bffd15 	stw	r6,-12(fp)
 d0495d8:	e1fffe15 	stw	r7,-8(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 d0495dc:	01000144 	movi	r4,5
 d0495e0:	d02604c0 	call	d02604c <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 d0495e4:	e13ffe17 	ldw	r4,-8(fp)
 d0495e8:	d04a3300 	call	d04a330 <isvfile_locked>
 d0495ec:	1005003a 	cmpeq	r2,r2,zero
 d0495f0:	1000541e 	bne	r2,zero,d049744 <vfread+0x188>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 d0495f4:	e0bffe17 	ldw	r2,-8(fp)
 d0495f8:	10800117 	ldw	r2,4(r2)
 d0495fc:	1004c03a 	cmpne	r2,r2,zero
 d049600:	1000041e 	bne	r2,zero,d049614 <vfread+0x58>
      {
         vfs_unlock();
 d049604:	01000144 	movi	r4,5
 d049608:	d0261000 	call	d026100 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 d04960c:	e03fff15 	stw	zero,-4(fp)
 d049610:	00004f06 	br	d049750 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 d049614:	e0bffe17 	ldw	r2,-8(fp)
 d049618:	10800117 	ldw	r2,4(r2)
 d04961c:	10800a17 	ldw	r2,40(r2)
 d049620:	1005003a 	cmpeq	r2,r2,zero
 d049624:	1000111e 	bne	r2,zero,d04966c <vfread+0xb0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 d049628:	e0bffe17 	ldw	r2,-8(fp)
 d04962c:	10800117 	ldw	r2,4(r2)
 d049630:	10800a17 	ldw	r2,40(r2)
 d049634:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 d049638:	e0bff917 	ldw	r2,-28(fp)
 d04963c:	10800317 	ldw	r2,12(r2)
 d049640:	e13ffb17 	ldw	r4,-20(fp)
 d049644:	e17ffc17 	ldw	r5,-16(fp)
 d049648:	e1bffd17 	ldw	r6,-12(fp)
 d04964c:	e1fffe17 	ldw	r7,-8(fp)
 d049650:	103ee83a 	callr	r2
 d049654:	e0bff815 	stw	r2,-32(fp)
         vfs_unlock();
 d049658:	01000144 	movi	r4,5
 d04965c:	d0261000 	call	d026100 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 d049660:	e0bff817 	ldw	r2,-32(fp)
 d049664:	e0bfff15 	stw	r2,-4(fp)
 d049668:	00003906 	br	d049750 <vfread+0x194>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 d04966c:	e0bffe17 	ldw	r2,-8(fp)
 d049670:	10800117 	ldw	r2,4(r2)
 d049674:	10800617 	ldw	r2,24(r2)
 d049678:	1004c03a 	cmpne	r2,r2,zero
 d04967c:	1000041e 	bne	r2,zero,d049690 <vfread+0xd4>
      {
         vfs_unlock();
 d049680:	01000144 	movi	r4,5
 d049684:	d0261000 	call	d026100 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 d049688:	e03fff15 	stw	zero,-4(fp)
 d04968c:	00003006 	br	d049750 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 d049690:	e13ffd17 	ldw	r4,-12(fp)
 d049694:	e17ffc17 	ldw	r5,-16(fp)
 d049698:	d00235c0 	call	d00235c <__mulsi3>
 d04969c:	e0bffa15 	stw	r2,-24(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 d0496a0:	e0bffe17 	ldw	r2,-8(fp)
 d0496a4:	10800217 	ldw	r2,8(r2)
 d0496a8:	1007883a 	mov	r3,r2
 d0496ac:	e0bffe17 	ldw	r2,-8(fp)
 d0496b0:	10800117 	ldw	r2,4(r2)
 d0496b4:	10800617 	ldw	r2,24(r2)
 d0496b8:	1885c83a 	sub	r2,r3,r2
 d0496bc:	e0bff715 	stw	r2,-36(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 d0496c0:	e0fff717 	ldw	r3,-36(fp)
 d0496c4:	e0bffa17 	ldw	r2,-24(fp)
 d0496c8:	1887883a 	add	r3,r3,r2
 d0496cc:	e0bffe17 	ldw	r2,-8(fp)
 d0496d0:	10800117 	ldw	r2,4(r2)
 d0496d4:	10800817 	ldw	r2,32(r2)
 d0496d8:	10c0062e 	bgeu	r2,r3,d0496f4 <vfread+0x138>
            bcount = (unsigned)(vfd->file->comp_size - location);
 d0496dc:	e0bffe17 	ldw	r2,-8(fp)
 d0496e0:	10800117 	ldw	r2,4(r2)
 d0496e4:	10c00817 	ldw	r3,32(r2)
 d0496e8:	e0bff717 	ldw	r2,-36(fp)
 d0496ec:	1885c83a 	sub	r2,r3,r2
 d0496f0:	e0bffa15 	stw	r2,-24(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 d0496f4:	e0bffe17 	ldw	r2,-8(fp)
 d0496f8:	10c00217 	ldw	r3,8(r2)
 d0496fc:	e0bffb17 	ldw	r2,-20(fp)
 d049700:	1009883a 	mov	r4,r2
 d049704:	180b883a 	mov	r5,r3
 d049708:	e1bffa17 	ldw	r6,-24(fp)
 d04970c:	d0026080 	call	d002608 <memcpy>
         vfd->cmploc += bcount;
 d049710:	e0bffe17 	ldw	r2,-8(fp)
 d049714:	10c00217 	ldw	r3,8(r2)
 d049718:	e0bffa17 	ldw	r2,-24(fp)
 d04971c:	1887883a 	add	r3,r3,r2
 d049720:	e0bffe17 	ldw	r2,-8(fp)
 d049724:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 d049728:	01000144 	movi	r4,5
 d04972c:	d0261000 	call	d026100 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 d049730:	e13ffa17 	ldw	r4,-24(fp)
 d049734:	e17ffc17 	ldw	r5,-16(fp)
 d049738:	d00c90c0 	call	d00c90c <__udivsi3>
 d04973c:	e0bfff15 	stw	r2,-4(fp)
 d049740:	00000306 	br	d049750 <vfread+0x194>
   }

   vfs_unlock();
 d049744:	01000144 	movi	r4,5
 d049748:	d0261000 	call	d026100 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 d04974c:	e03fff15 	stw	zero,-4(fp)
 d049750:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d049754:	e037883a 	mov	sp,fp
 d049758:	dfc00117 	ldw	ra,4(sp)
 d04975c:	df000017 	ldw	fp,0(sp)
 d049760:	dec00204 	addi	sp,sp,8
 d049764:	f800283a 	ret

0d049768 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d049768:	defff104 	addi	sp,sp,-60
 d04976c:	dfc00e15 	stw	ra,56(sp)
 d049770:	df000d15 	stw	fp,52(sp)
 d049774:	df000d04 	addi	fp,sp,52
 d049778:	e13ffb15 	stw	r4,-20(fp)
 d04977c:	e17ffc15 	stw	r5,-16(fp)
 d049780:	e1bffd15 	stw	r6,-12(fp)
 d049784:	e1fffe15 	stw	r7,-8(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 d049788:	e13ffe17 	ldw	r4,-8(fp)
 d04978c:	d04a3300 	call	d04a330 <isvfile_locked>
 d049790:	1004c03a 	cmpne	r2,r2,zero
 d049794:	1000031e 	bne	r2,zero,d0497a4 <vfwrite_locked+0x3c>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 d049798:	00800244 	movi	r2,9
 d04979c:	e0bfff15 	stw	r2,-4(fp)
 d0497a0:	0000e506 	br	d049b38 <vfwrite_locked+0x3d0>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 d0497a4:	e0bffe17 	ldw	r2,-8(fp)
 d0497a8:	10800117 	ldw	r2,4(r2)
 d0497ac:	10800a17 	ldw	r2,40(r2)
 d0497b0:	1005003a 	cmpeq	r2,r2,zero
 d0497b4:	10000f1e 	bne	r2,zero,d0497f4 <vfwrite_locked+0x8c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 d0497b8:	e0bffe17 	ldw	r2,-8(fp)
 d0497bc:	10800117 	ldw	r2,4(r2)
 d0497c0:	10800a17 	ldw	r2,40(r2)
 d0497c4:	e0bff715 	stw	r2,-36(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 d0497c8:	e0bff717 	ldw	r2,-36(fp)
 d0497cc:	10800417 	ldw	r2,16(r2)
 d0497d0:	e13ffb17 	ldw	r4,-20(fp)
 d0497d4:	e17ffc17 	ldw	r5,-16(fp)
 d0497d8:	e1bffd17 	ldw	r6,-12(fp)
 d0497dc:	e1fffe17 	ldw	r7,-8(fp)
 d0497e0:	103ee83a 	callr	r2
 d0497e4:	e0bff615 	stw	r2,-40(fp)
      return rc;
 d0497e8:	e0bff617 	ldw	r2,-40(fp)
 d0497ec:	e0bfff15 	stw	r2,-4(fp)
 d0497f0:	0000d106 	br	d049b38 <vfwrite_locked+0x3d0>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 d0497f4:	e0bffe17 	ldw	r2,-8(fp)
 d0497f8:	10800117 	ldw	r2,4(r2)
 d0497fc:	1004c03a 	cmpne	r2,r2,zero
 d049800:	1000021e 	bne	r2,zero,d04980c <vfwrite_locked+0xa4>
   {
      return 0;
 d049804:	e03fff15 	stw	zero,-4(fp)
 d049808:	0000cb06 	br	d049b38 <vfwrite_locked+0x3d0>
   }

   vfp = vfd->file;
 d04980c:	e0bffe17 	ldw	r2,-8(fp)
 d049810:	10800117 	ldw	r2,4(r2)
 d049814:	e0bff815 	stw	r2,-32(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 d049818:	e0bff817 	ldw	r2,-32(fp)
 d04981c:	1080058b 	ldhu	r2,22(r2)
 d049820:	10bfffcc 	andi	r2,r2,65535
 d049824:	1080080c 	andi	r2,r2,32
 d049828:	1004c03a 	cmpne	r2,r2,zero
 d04982c:	1000051e 	bne	r2,zero,d049844 <vfwrite_locked+0xdc>
   {
      vfd->error = ENP_FILEIO;
 d049830:	e0fffe17 	ldw	r3,-8(fp)
 d049834:	00bff984 	movi	r2,-26
 d049838:	18800415 	stw	r2,16(r3)
      return 0;
 d04983c:	e03fff15 	stw	zero,-4(fp)
 d049840:	0000bd06 	br	d049b38 <vfwrite_locked+0x3d0>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 d049844:	e13ffc17 	ldw	r4,-16(fp)
 d049848:	e17ffd17 	ldw	r5,-12(fp)
 d04984c:	d00235c0 	call	d00235c <__mulsi3>
 d049850:	e0bffa15 	stw	r2,-24(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 d049854:	e0bffa17 	ldw	r2,-24(fp)
 d049858:	1004c03a 	cmpne	r2,r2,zero
 d04985c:	1000021e 	bne	r2,zero,d049868 <vfwrite_locked+0x100>
   {
      return 0;
 d049860:	e03fff15 	stw	zero,-4(fp)
 d049864:	0000b406 	br	d049b38 <vfwrite_locked+0x3d0>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 d049868:	e0bff817 	ldw	r2,-32(fp)
 d04986c:	10800617 	ldw	r2,24(r2)
 d049870:	1004c03a 	cmpne	r2,r2,zero
 d049874:	1000401e 	bne	r2,zero,d049978 <vfwrite_locked+0x210>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 d049878:	e0bffa17 	ldw	r2,-24(fp)
 d04987c:	10bfffc4 	addi	r2,r2,-1
 d049880:	1004d37a 	srli	r2,r2,13
 d049884:	1004937a 	slli	r2,r2,13
 d049888:	10880004 	addi	r2,r2,8192
 d04988c:	e0bff515 	stw	r2,-44(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 d049890:	e13ff517 	ldw	r4,-44(fp)
 d049894:	d048af40 	call	d048af4 <vf_alloc_buffer>
 d049898:	1007883a 	mov	r3,r2
 d04989c:	e0bff817 	ldw	r2,-32(fp)
 d0498a0:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 d0498a4:	e0bff817 	ldw	r2,-32(fp)
 d0498a8:	10800617 	ldw	r2,24(r2)
 d0498ac:	1004c03a 	cmpne	r2,r2,zero
 d0498b0:	1000051e 	bne	r2,zero,d0498c8 <vfwrite_locked+0x160>
      {
         vfd->error = ENP_NOMEM;
 d0498b4:	e0fffe17 	ldw	r3,-8(fp)
 d0498b8:	00bffb04 	movi	r2,-20
 d0498bc:	18800415 	stw	r2,16(r3)
         return 0;
 d0498c0:	e03fff15 	stw	zero,-4(fp)
 d0498c4:	00009c06 	br	d049b38 <vfwrite_locked+0x3d0>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 d0498c8:	e0fff817 	ldw	r3,-32(fp)
 d0498cc:	e0bff517 	ldw	r2,-44(fp)
 d0498d0:	18800915 	stw	r2,36(r3)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 d0498d4:	e0fff817 	ldw	r3,-32(fp)
 d0498d8:	e0bffa17 	ldw	r2,-24(fp)
 d0498dc:	18800715 	stw	r2,28(r3)
      vfp->comp_size = bcount;
 d0498e0:	e0fff817 	ldw	r3,-32(fp)
 d0498e4:	e0bffa17 	ldw	r2,-24(fp)
 d0498e8:	18800815 	stw	r2,32(r3)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 d0498ec:	e0bff817 	ldw	r2,-32(fp)
 d0498f0:	10c00617 	ldw	r3,24(r2)
 d0498f4:	e0bffa17 	ldw	r2,-24(fp)
 d0498f8:	1887883a 	add	r3,r3,r2
 d0498fc:	e0bffe17 	ldw	r2,-8(fp)
 d049900:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 d049904:	e0bff817 	ldw	r2,-32(fp)
 d049908:	10c0058b 	ldhu	r3,22(r2)
 d04990c:	00bfff84 	movi	r2,-2
 d049910:	1884703a 	and	r2,r3,r2
 d049914:	1007883a 	mov	r3,r2
 d049918:	e0bff817 	ldw	r2,-32(fp)
 d04991c:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 d049920:	e0bff817 	ldw	r2,-32(fp)
 d049924:	1080058b 	ldhu	r2,22(r2)
 d049928:	10808014 	ori	r2,r2,512
 d04992c:	1007883a 	mov	r3,r2
 d049930:	e0bff817 	ldw	r2,-32(fp)
 d049934:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 d049938:	e0bff817 	ldw	r2,-32(fp)
 d04993c:	1080058b 	ldhu	r2,22(r2)
 d049940:	10802014 	ori	r2,r2,128
 d049944:	1007883a 	mov	r3,r2
 d049948:	e0bff817 	ldw	r2,-32(fp)
 d04994c:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 d049950:	e0bff817 	ldw	r2,-32(fp)
 d049954:	10800617 	ldw	r2,24(r2)
 d049958:	e0fffb17 	ldw	r3,-20(fp)
 d04995c:	1009883a 	mov	r4,r2
 d049960:	180b883a 	mov	r5,r3
 d049964:	e1bffa17 	ldw	r6,-24(fp)
 d049968:	d0026080 	call	d002608 <memcpy>

      /* return the number of "items" written */
      return items;
 d04996c:	e0bffd17 	ldw	r2,-12(fp)
 d049970:	e0bfff15 	stw	r2,-4(fp)
 d049974:	00007006 	br	d049b38 <vfwrite_locked+0x3d0>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 d049978:	e0bffe17 	ldw	r2,-8(fp)
 d04997c:	10800217 	ldw	r2,8(r2)
 d049980:	1007883a 	mov	r3,r2
 d049984:	e0bff817 	ldw	r2,-32(fp)
 d049988:	10800617 	ldw	r2,24(r2)
 d04998c:	1885c83a 	sub	r2,r3,r2
 d049990:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 d049994:	e0fff917 	ldw	r3,-28(fp)
 d049998:	e0bffa17 	ldw	r2,-24(fp)
 d04999c:	1887883a 	add	r3,r3,r2
 d0499a0:	e0bff817 	ldw	r2,-32(fp)
 d0499a4:	10800917 	ldw	r2,36(r2)
 d0499a8:	10c0382e 	bgeu	r2,r3,d049a8c <vfwrite_locked+0x324>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 d0499ac:	e0fff917 	ldw	r3,-28(fp)
 d0499b0:	e0bffa17 	ldw	r2,-24(fp)
 d0499b4:	1885883a 	add	r2,r3,r2
 d0499b8:	10bfffc4 	addi	r2,r2,-1
 d0499bc:	1004d37a 	srli	r2,r2,13
 d0499c0:	1004937a 	slli	r2,r2,13
 d0499c4:	10880004 	addi	r2,r2,8192
 d0499c8:	e0bff415 	stw	r2,-48(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 d0499cc:	e13ff417 	ldw	r4,-48(fp)
 d0499d0:	d048af40 	call	d048af4 <vf_alloc_buffer>
 d0499d4:	e0bff315 	stw	r2,-52(fp)

      /* check for allocation failure */
      if (!new_buffer)
 d0499d8:	e0bff317 	ldw	r2,-52(fp)
 d0499dc:	1004c03a 	cmpne	r2,r2,zero
 d0499e0:	1000051e 	bne	r2,zero,d0499f8 <vfwrite_locked+0x290>
      {
         vfd->error = ENP_NOMEM;
 d0499e4:	e0fffe17 	ldw	r3,-8(fp)
 d0499e8:	00bffb04 	movi	r2,-20
 d0499ec:	18800415 	stw	r2,16(r3)
         return 0;
 d0499f0:	e03fff15 	stw	zero,-4(fp)
 d0499f4:	00005006 	br	d049b38 <vfwrite_locked+0x3d0>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 d0499f8:	e0bff817 	ldw	r2,-32(fp)
 d0499fc:	10c00617 	ldw	r3,24(r2)
 d049a00:	e0bff817 	ldw	r2,-32(fp)
 d049a04:	11800817 	ldw	r6,32(r2)
 d049a08:	e0bff317 	ldw	r2,-52(fp)
 d049a0c:	1009883a 	mov	r4,r2
 d049a10:	180b883a 	mov	r5,r3
 d049a14:	d0026080 	call	d002608 <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 d049a18:	e0bff817 	ldw	r2,-32(fp)
 d049a1c:	1080058b 	ldhu	r2,22(r2)
 d049a20:	10bfffcc 	andi	r2,r2,65535
 d049a24:	1080200c 	andi	r2,r2,128
 d049a28:	1005003a 	cmpeq	r2,r2,zero
 d049a2c:	1000051e 	bne	r2,zero,d049a44 <vfwrite_locked+0x2dc>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 d049a30:	e0bff817 	ldw	r2,-32(fp)
 d049a34:	11000617 	ldw	r4,24(r2)
 d049a38:	e0bff817 	ldw	r2,-32(fp)
 d049a3c:	11400917 	ldw	r5,36(r2)
 d049a40:	d048bcc0 	call	d048bcc <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 d049a44:	e0fff817 	ldw	r3,-32(fp)
 d049a48:	e0bff317 	ldw	r2,-52(fp)
 d049a4c:	18800615 	stw	r2,24(r3)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 d049a50:	e0fff817 	ldw	r3,-32(fp)
 d049a54:	e0bff417 	ldw	r2,-48(fp)
 d049a58:	18800915 	stw	r2,36(r3)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 d049a5c:	e0bff817 	ldw	r2,-32(fp)
 d049a60:	1080058b 	ldhu	r2,22(r2)
 d049a64:	10802014 	ori	r2,r2,128
 d049a68:	1007883a 	mov	r3,r2
 d049a6c:	e0bff817 	ldw	r2,-32(fp)
 d049a70:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 d049a74:	e0bff817 	ldw	r2,-32(fp)
 d049a78:	10c00617 	ldw	r3,24(r2)
 d049a7c:	e0bff917 	ldw	r2,-28(fp)
 d049a80:	1887883a 	add	r3,r3,r2
 d049a84:	e0bffe17 	ldw	r2,-8(fp)
 d049a88:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 d049a8c:	e0bffe17 	ldw	r2,-8(fp)
 d049a90:	10800217 	ldw	r2,8(r2)
 d049a94:	e0fffb17 	ldw	r3,-20(fp)
 d049a98:	1009883a 	mov	r4,r2
 d049a9c:	180b883a 	mov	r5,r3
 d049aa0:	e1bffa17 	ldw	r6,-24(fp)
 d049aa4:	d0026080 	call	d002608 <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 d049aa8:	e0bffe17 	ldw	r2,-8(fp)
 d049aac:	10c00217 	ldw	r3,8(r2)
 d049ab0:	e0bffa17 	ldw	r2,-24(fp)
 d049ab4:	1887883a 	add	r3,r3,r2
 d049ab8:	e0bffe17 	ldw	r2,-8(fp)
 d049abc:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 d049ac0:	e0fff917 	ldw	r3,-28(fp)
 d049ac4:	e0bffa17 	ldw	r2,-24(fp)
 d049ac8:	1887883a 	add	r3,r3,r2
 d049acc:	e0bff817 	ldw	r2,-32(fp)
 d049ad0:	10800817 	ldw	r2,32(r2)
 d049ad4:	10c0052e 	bgeu	r2,r3,d049aec <vfwrite_locked+0x384>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 d049ad8:	e0fff917 	ldw	r3,-28(fp)
 d049adc:	e0bffa17 	ldw	r2,-24(fp)
 d049ae0:	1887883a 	add	r3,r3,r2
 d049ae4:	e0bff817 	ldw	r2,-32(fp)
 d049ae8:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 d049aec:	e0bff817 	ldw	r2,-32(fp)
 d049af0:	10c00817 	ldw	r3,32(r2)
 d049af4:	e0bff817 	ldw	r2,-32(fp)
 d049af8:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 d049afc:	e0bff817 	ldw	r2,-32(fp)
 d049b00:	10c0058b 	ldhu	r3,22(r2)
 d049b04:	00bfff84 	movi	r2,-2
 d049b08:	1884703a 	and	r2,r3,r2
 d049b0c:	1007883a 	mov	r3,r2
 d049b10:	e0bff817 	ldw	r2,-32(fp)
 d049b14:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 d049b18:	e0bff817 	ldw	r2,-32(fp)
 d049b1c:	1080058b 	ldhu	r2,22(r2)
 d049b20:	10808014 	ori	r2,r2,512
 d049b24:	1007883a 	mov	r3,r2
 d049b28:	e0bff817 	ldw	r2,-32(fp)
 d049b2c:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 d049b30:	e0bffd17 	ldw	r2,-12(fp)
 d049b34:	e0bfff15 	stw	r2,-4(fp)
 d049b38:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_RWVFS */
}
 d049b3c:	e037883a 	mov	sp,fp
 d049b40:	dfc00117 	ldw	ra,4(sp)
 d049b44:	df000017 	ldw	fp,0(sp)
 d049b48:	dec00204 	addi	sp,sp,8
 d049b4c:	f800283a 	ret

0d049b50 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d049b50:	defff904 	addi	sp,sp,-28
 d049b54:	dfc00615 	stw	ra,24(sp)
 d049b58:	df000515 	stw	fp,20(sp)
 d049b5c:	df000504 	addi	fp,sp,20
 d049b60:	e13ffc15 	stw	r4,-16(fp)
 d049b64:	e17ffd15 	stw	r5,-12(fp)
 d049b68:	e1bffe15 	stw	r6,-8(fp)
 d049b6c:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 d049b70:	01000144 	movi	r4,5
 d049b74:	d02604c0 	call	d02604c <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 d049b78:	e13ffc17 	ldw	r4,-16(fp)
 d049b7c:	e17ffd17 	ldw	r5,-12(fp)
 d049b80:	e1bffe17 	ldw	r6,-8(fp)
 d049b84:	e1ffff17 	ldw	r7,-4(fp)
 d049b88:	d0497680 	call	d049768 <vfwrite_locked>
 d049b8c:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 d049b90:	01000144 	movi	r4,5
 d049b94:	d0261000 	call	d026100 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 d049b98:	e0bffb17 	ldw	r2,-20(fp)
}
 d049b9c:	e037883a 	mov	sp,fp
 d049ba0:	dfc00117 	ldw	ra,4(sp)
 d049ba4:	df000017 	ldw	fp,0(sp)
 d049ba8:	dec00204 	addi	sp,sp,8
 d049bac:	f800283a 	ret

0d049bb0 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 d049bb0:	defff704 	addi	sp,sp,-36
 d049bb4:	dfc00815 	stw	ra,32(sp)
 d049bb8:	df000715 	stw	fp,28(sp)
 d049bbc:	df000704 	addi	fp,sp,28
 d049bc0:	e13ffb15 	stw	r4,-20(fp)
 d049bc4:	e17ffc15 	stw	r5,-16(fp)
 d049bc8:	e1bffd15 	stw	r6,-12(fp)
   /* lock the VFS */
   vfs_lock();
 d049bcc:	01000144 	movi	r4,5
 d049bd0:	d02604c0 	call	d02604c <wait_app_sem>

   if (isvfile_locked(vfd))
 d049bd4:	e13ffb17 	ldw	r4,-20(fp)
 d049bd8:	d04a3300 	call	d04a330 <isvfile_locked>
 d049bdc:	1005003a 	cmpeq	r2,r2,zero
 d049be0:	1000481e 	bne	r2,zero,d049d04 <vfseek+0x154>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 d049be4:	e0bffb17 	ldw	r2,-20(fp)
 d049be8:	10800117 	ldw	r2,4(r2)
 d049bec:	1004c03a 	cmpne	r2,r2,zero
 d049bf0:	1000051e 	bne	r2,zero,d049c08 <vfseek+0x58>
      {
         vfs_unlock();
 d049bf4:	01000144 	movi	r4,5
 d049bf8:	d0261000 	call	d026100 <post_app_sem>
         return -1;
 d049bfc:	00bfffc4 	movi	r2,-1
 d049c00:	e0bffe15 	stw	r2,-8(fp)
 d049c04:	00004306 	br	d049d14 <vfseek+0x164>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 d049c08:	e0bffb17 	ldw	r2,-20(fp)
 d049c0c:	10800117 	ldw	r2,4(r2)
 d049c10:	10800a17 	ldw	r2,40(r2)
 d049c14:	1005003a 	cmpeq	r2,r2,zero
 d049c18:	1000101e 	bne	r2,zero,d049c5c <vfseek+0xac>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 d049c1c:	e0bffb17 	ldw	r2,-20(fp)
 d049c20:	10800117 	ldw	r2,4(r2)
 d049c24:	10800a17 	ldw	r2,40(r2)
 d049c28:	e0bffa15 	stw	r2,-24(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 d049c2c:	e0bffa17 	ldw	r2,-24(fp)
 d049c30:	10800517 	ldw	r2,20(r2)
 d049c34:	e13ffb17 	ldw	r4,-20(fp)
 d049c38:	e17ffc17 	ldw	r5,-16(fp)
 d049c3c:	e1bffd17 	ldw	r6,-12(fp)
 d049c40:	103ee83a 	callr	r2
 d049c44:	e0bff915 	stw	r2,-28(fp)
         vfs_unlock();
 d049c48:	01000144 	movi	r4,5
 d049c4c:	d0261000 	call	d026100 <post_app_sem>
         return rc;
 d049c50:	e0fff917 	ldw	r3,-28(fp)
 d049c54:	e0fffe15 	stw	r3,-8(fp)
 d049c58:	00002e06 	br	d049d14 <vfseek+0x164>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 d049c5c:	e0bffd17 	ldw	r2,-12(fp)
 d049c60:	e0bfff15 	stw	r2,-4(fp)
 d049c64:	e0ffff17 	ldw	r3,-4(fp)
 d049c68:	18800060 	cmpeqi	r2,r3,1
 d049c6c:	10000f1e 	bne	r2,zero,d049cac <vfseek+0xfc>
 d049c70:	e0ffff17 	ldw	r3,-4(fp)
 d049c74:	188000a0 	cmpeqi	r2,r3,2
 d049c78:	1000131e 	bne	r2,zero,d049cc8 <vfseek+0x118>
 d049c7c:	e0ffff17 	ldw	r3,-4(fp)
 d049c80:	1805003a 	cmpeq	r2,r3,zero
 d049c84:	1000011e 	bne	r2,zero,d049c8c <vfseek+0xdc>
 d049c88:	00001a06 	br	d049cf4 <vfseek+0x144>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 d049c8c:	e0bffb17 	ldw	r2,-20(fp)
 d049c90:	10800117 	ldw	r2,4(r2)
 d049c94:	10c00617 	ldw	r3,24(r2)
 d049c98:	e0bffc17 	ldw	r2,-16(fp)
 d049c9c:	1887883a 	add	r3,r3,r2
 d049ca0:	e0bffb17 	ldw	r2,-20(fp)
 d049ca4:	10c00215 	stw	r3,8(r2)
         break;
 d049ca8:	00001206 	br	d049cf4 <vfseek+0x144>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 d049cac:	e0bffb17 	ldw	r2,-20(fp)
 d049cb0:	10c00217 	ldw	r3,8(r2)
 d049cb4:	e0bffc17 	ldw	r2,-16(fp)
 d049cb8:	1887883a 	add	r3,r3,r2
 d049cbc:	e0bffb17 	ldw	r2,-20(fp)
 d049cc0:	10c00215 	stw	r3,8(r2)
         break;
 d049cc4:	00000b06 	br	d049cf4 <vfseek+0x144>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 d049cc8:	e0bffb17 	ldw	r2,-20(fp)
 d049ccc:	10800117 	ldw	r2,4(r2)
 d049cd0:	10c00617 	ldw	r3,24(r2)
 d049cd4:	e0bffb17 	ldw	r2,-20(fp)
 d049cd8:	10800117 	ldw	r2,4(r2)
 d049cdc:	10800817 	ldw	r2,32(r2)
 d049ce0:	1887883a 	add	r3,r3,r2
 d049ce4:	e0bffc17 	ldw	r2,-16(fp)
 d049ce8:	1887883a 	add	r3,r3,r2
 d049cec:	e0bffb17 	ldw	r2,-20(fp)
 d049cf0:	10c00215 	stw	r3,8(r2)
         break;
      }
      vfs_unlock();
 d049cf4:	01000144 	movi	r4,5
 d049cf8:	d0261000 	call	d026100 <post_app_sem>
      return(0);
 d049cfc:	e03ffe15 	stw	zero,-8(fp)
 d049d00:	00000406 	br	d049d14 <vfseek+0x164>
   }

   vfs_unlock();
 d049d04:	01000144 	movi	r4,5
 d049d08:	d0261000 	call	d026100 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 d049d0c:	00bfffc4 	movi	r2,-1
 d049d10:	e0bffe15 	stw	r2,-8(fp)
 d049d14:	e0bffe17 	ldw	r2,-8(fp)
#endif   /* HT_LOCALFS */
}
 d049d18:	e037883a 	mov	sp,fp
 d049d1c:	dfc00117 	ldw	ra,4(sp)
 d049d20:	df000017 	ldw	fp,0(sp)
 d049d24:	dec00204 	addi	sp,sp,8
 d049d28:	f800283a 	ret

0d049d2c <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 d049d2c:	defffa04 	addi	sp,sp,-24
 d049d30:	dfc00515 	stw	ra,20(sp)
 d049d34:	df000415 	stw	fp,16(sp)
 d049d38:	df000404 	addi	fp,sp,16
 d049d3c:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 d049d40:	01000144 	movi	r4,5
 d049d44:	d02604c0 	call	d02604c <wait_app_sem>

   if (isvfile_locked(vfd))
 d049d48:	e13ffe17 	ldw	r4,-8(fp)
 d049d4c:	d04a3300 	call	d04a330 <isvfile_locked>
 d049d50:	1005003a 	cmpeq	r2,r2,zero
 d049d54:	1000381e 	bne	r2,zero,d049e38 <vftell+0x10c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 d049d58:	e0bffe17 	ldw	r2,-8(fp)
 d049d5c:	10800117 	ldw	r2,4(r2)
 d049d60:	1004c03a 	cmpne	r2,r2,zero
 d049d64:	1000051e 	bne	r2,zero,d049d7c <vftell+0x50>
      {
         vfs_unlock();
 d049d68:	01000144 	movi	r4,5
 d049d6c:	d0261000 	call	d026100 <post_app_sem>
         return -1;
 d049d70:	00bfffc4 	movi	r2,-1
 d049d74:	e0bfff15 	stw	r2,-4(fp)
 d049d78:	00003306 	br	d049e48 <vftell+0x11c>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 d049d7c:	e0bffe17 	ldw	r2,-8(fp)
 d049d80:	10800117 	ldw	r2,4(r2)
 d049d84:	10800a17 	ldw	r2,40(r2)
 d049d88:	1005003a 	cmpeq	r2,r2,zero
 d049d8c:	10000e1e 	bne	r2,zero,d049dc8 <vftell+0x9c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 d049d90:	e0bffe17 	ldw	r2,-8(fp)
 d049d94:	10800117 	ldw	r2,4(r2)
 d049d98:	10800a17 	ldw	r2,40(r2)
 d049d9c:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 d049da0:	e0bffd17 	ldw	r2,-12(fp)
 d049da4:	10800617 	ldw	r2,24(r2)
 d049da8:	e13ffe17 	ldw	r4,-8(fp)
 d049dac:	103ee83a 	callr	r2
 d049db0:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 d049db4:	01000144 	movi	r4,5
 d049db8:	d0261000 	call	d026100 <post_app_sem>
         return rc;
 d049dbc:	e0bffc17 	ldw	r2,-16(fp)
 d049dc0:	e0bfff15 	stw	r2,-4(fp)
 d049dc4:	00002006 	br	d049e48 <vftell+0x11c>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 d049dc8:	e0bffe17 	ldw	r2,-8(fp)
 d049dcc:	11000217 	ldw	r4,8(r2)
 d049dd0:	e0bffe17 	ldw	r2,-8(fp)
 d049dd4:	10800117 	ldw	r2,4(r2)
 d049dd8:	10c00617 	ldw	r3,24(r2)
 d049ddc:	e0bffe17 	ldw	r2,-8(fp)
 d049de0:	10800117 	ldw	r2,4(r2)
 d049de4:	10800817 	ldw	r2,32(r2)
 d049de8:	1885883a 	add	r2,r3,r2
 d049dec:	2080071e 	bne	r4,r2,d049e0c <vftell+0xe0>
      {
         vfs_unlock();
 d049df0:	01000144 	movi	r4,5
 d049df4:	d0261000 	call	d026100 <post_app_sem>

         return vfd->file->comp_size;
 d049df8:	e0bffe17 	ldw	r2,-8(fp)
 d049dfc:	10800117 	ldw	r2,4(r2)
 d049e00:	10800817 	ldw	r2,32(r2)
 d049e04:	e0bfff15 	stw	r2,-4(fp)
 d049e08:	00000f06 	br	d049e48 <vftell+0x11c>
      }
      else
      {
         vfs_unlock();
 d049e0c:	01000144 	movi	r4,5
 d049e10:	d0261000 	call	d026100 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 d049e14:	e0bffe17 	ldw	r2,-8(fp)
 d049e18:	10800217 	ldw	r2,8(r2)
 d049e1c:	1007883a 	mov	r3,r2
 d049e20:	e0bffe17 	ldw	r2,-8(fp)
 d049e24:	10800117 	ldw	r2,4(r2)
 d049e28:	10800617 	ldw	r2,24(r2)
 d049e2c:	1887c83a 	sub	r3,r3,r2
 d049e30:	e0ffff15 	stw	r3,-4(fp)
 d049e34:	00000406 	br	d049e48 <vftell+0x11c>
      }
   }

   vfs_unlock();
 d049e38:	01000144 	movi	r4,5
 d049e3c:	d0261000 	call	d026100 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 d049e40:	00800244 	movi	r2,9
 d049e44:	e0bfff15 	stw	r2,-4(fp)
 d049e48:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d049e4c:	e037883a 	mov	sp,fp
 d049e50:	dfc00117 	ldw	ra,4(sp)
 d049e54:	df000017 	ldw	fp,0(sp)
 d049e58:	dec00204 	addi	sp,sp,8
 d049e5c:	f800283a 	ret

0d049e60 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 d049e60:	defffa04 	addi	sp,sp,-24
 d049e64:	dfc00515 	stw	ra,20(sp)
 d049e68:	df000415 	stw	fp,16(sp)
 d049e6c:	df000404 	addi	fp,sp,16
 d049e70:	e13ffe15 	stw	r4,-8(fp)
   int   chr;

   if (isvfile_locked(vfd))
 d049e74:	e13ffe17 	ldw	r4,-8(fp)
 d049e78:	d04a3300 	call	d04a330 <isvfile_locked>
 d049e7c:	1005003a 	cmpeq	r2,r2,zero
 d049e80:	1000361e 	bne	r2,zero,d049f5c <vgetc_locked+0xfc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 d049e84:	e0bffe17 	ldw	r2,-8(fp)
 d049e88:	10800117 	ldw	r2,4(r2)
 d049e8c:	1004c03a 	cmpne	r2,r2,zero
 d049e90:	1000031e 	bne	r2,zero,d049ea0 <vgetc_locked+0x40>
      {
         return EOF;
 d049e94:	00bfffc4 	movi	r2,-1
 d049e98:	e0bfff15 	stw	r2,-4(fp)
 d049e9c:	00003206 	br	d049f68 <vgetc_locked+0x108>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 d049ea0:	e0bffe17 	ldw	r2,-8(fp)
 d049ea4:	10800117 	ldw	r2,4(r2)
 d049ea8:	10800a17 	ldw	r2,40(r2)
 d049eac:	1005003a 	cmpeq	r2,r2,zero
 d049eb0:	10000a1e 	bne	r2,zero,d049edc <vgetc_locked+0x7c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 d049eb4:	e0bffe17 	ldw	r2,-8(fp)
 d049eb8:	10800117 	ldw	r2,4(r2)
 d049ebc:	10800a17 	ldw	r2,40(r2)
 d049ec0:	e0bffc15 	stw	r2,-16(fp)
         return (vfp->r_fgetc(vfd));
 d049ec4:	e0bffc17 	ldw	r2,-16(fp)
 d049ec8:	10800717 	ldw	r2,28(r2)
 d049ecc:	e13ffe17 	ldw	r4,-8(fp)
 d049ed0:	103ee83a 	callr	r2
 d049ed4:	e0bfff15 	stw	r2,-4(fp)
 d049ed8:	00002306 	br	d049f68 <vgetc_locked+0x108>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 d049edc:	e0bffe17 	ldw	r2,-8(fp)
 d049ee0:	10800117 	ldw	r2,4(r2)
 d049ee4:	10800617 	ldw	r2,24(r2)
 d049ee8:	1004c03a 	cmpne	r2,r2,zero
 d049eec:	1000031e 	bne	r2,zero,d049efc <vgetc_locked+0x9c>
         return EOF;
 d049ef0:	00bfffc4 	movi	r2,-1
 d049ef4:	e0bfff15 	stw	r2,-4(fp)
 d049ef8:	00001b06 	br	d049f68 <vgetc_locked+0x108>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 d049efc:	e0bffe17 	ldw	r2,-8(fp)
 d049f00:	11000217 	ldw	r4,8(r2)
 d049f04:	e0bffe17 	ldw	r2,-8(fp)
 d049f08:	10800117 	ldw	r2,4(r2)
 d049f0c:	10c00617 	ldw	r3,24(r2)
 d049f10:	e0bffe17 	ldw	r2,-8(fp)
 d049f14:	10800117 	ldw	r2,4(r2)
 d049f18:	10800817 	ldw	r2,32(r2)
 d049f1c:	1885883a 	add	r2,r3,r2
 d049f20:	20800336 	bltu	r4,r2,d049f30 <vgetc_locked+0xd0>
            chr = EOF;
 d049f24:	00bfffc4 	movi	r2,-1
 d049f28:	e0bffd15 	stw	r2,-12(fp)
 d049f2c:	00000806 	br	d049f50 <vgetc_locked+0xf0>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 d049f30:	e0bffe17 	ldw	r2,-8(fp)
 d049f34:	10c00217 	ldw	r3,8(r2)
 d049f38:	18800003 	ldbu	r2,0(r3)
 d049f3c:	10803fcc 	andi	r2,r2,255
 d049f40:	e0bffd15 	stw	r2,-12(fp)
 d049f44:	18c00044 	addi	r3,r3,1
 d049f48:	e0bffe17 	ldw	r2,-8(fp)
 d049f4c:	10c00215 	stw	r3,8(r2)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 d049f50:	e0bffd17 	ldw	r2,-12(fp)
 d049f54:	e0bfff15 	stw	r2,-4(fp)
 d049f58:	00000306 	br	d049f68 <vgetc_locked+0x108>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 d049f5c:	d025a500 	call	d025a50 <dtrap>
   return EOF;
 d049f60:	00bfffc4 	movi	r2,-1
 d049f64:	e0bfff15 	stw	r2,-4(fp)
 d049f68:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d049f6c:	e037883a 	mov	sp,fp
 d049f70:	dfc00117 	ldw	ra,4(sp)
 d049f74:	df000017 	ldw	fp,0(sp)
 d049f78:	dec00204 	addi	sp,sp,8
 d049f7c:	f800283a 	ret

0d049f80 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 d049f80:	defffc04 	addi	sp,sp,-16
 d049f84:	dfc00315 	stw	ra,12(sp)
 d049f88:	df000215 	stw	fp,8(sp)
 d049f8c:	df000204 	addi	fp,sp,8
 d049f90:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 d049f94:	01000144 	movi	r4,5
 d049f98:	d02604c0 	call	d02604c <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 d049f9c:	e13fff17 	ldw	r4,-4(fp)
 d049fa0:	d049e600 	call	d049e60 <vgetc_locked>
 d049fa4:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 d049fa8:	01000144 	movi	r4,5
 d049fac:	d0261000 	call	d026100 <post_app_sem>
   return rc;
 d049fb0:	e0bffe17 	ldw	r2,-8(fp)
}
 d049fb4:	e037883a 	mov	sp,fp
 d049fb8:	dfc00117 	ldw	ra,4(sp)
 d049fbc:	df000017 	ldw	fp,0(sp)
 d049fc0:	dec00204 	addi	sp,sp,8
 d049fc4:	f800283a 	ret

0d049fc8 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 d049fc8:	defffa04 	addi	sp,sp,-24
 d049fcc:	dfc00515 	stw	ra,20(sp)
 d049fd0:	df000415 	stw	fp,16(sp)
 d049fd4:	df000404 	addi	fp,sp,16
 d049fd8:	e13ffe15 	stw	r4,-8(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 d049fdc:	e0bffe17 	ldw	r2,-8(fp)
 d049fe0:	10800003 	ldbu	r2,0(r2)
 d049fe4:	10803fcc 	andi	r2,r2,255
 d049fe8:	1080201c 	xori	r2,r2,128
 d049fec:	10bfe004 	addi	r2,r2,-128
 d049ff0:	10800be0 	cmpeqi	r2,r2,47
 d049ff4:	1000071e 	bne	r2,zero,d04a014 <vfslookup_locked+0x4c>
 d049ff8:	e0bffe17 	ldw	r2,-8(fp)
 d049ffc:	10800003 	ldbu	r2,0(r2)
 d04a000:	10803fcc 	andi	r2,r2,255
 d04a004:	1080201c 	xori	r2,r2,128
 d04a008:	10bfe004 	addi	r2,r2,-128
 d04a00c:	10801718 	cmpnei	r2,r2,92
 d04a010:	10001a1e 	bne	r2,zero,d04a07c <vfslookup_locked+0xb4>
   {
      cp = strippath(name);
 d04a014:	e13ffe17 	ldw	r4,-8(fp)
 d04a018:	d04a1480 	call	d04a148 <strippath>
 d04a01c:	e0bffc15 	stw	r2,-16(fp)

      if (!cp) /* strippath coundn't match our path */
 d04a020:	e0bffc17 	ldw	r2,-16(fp)
 d04a024:	1004c03a 	cmpne	r2,r2,zero
 d04a028:	1000121e 	bne	r2,zero,d04a074 <vfslookup_locked+0xac>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 d04a02c:	e0bffe17 	ldw	r2,-8(fp)
 d04a030:	10800003 	ldbu	r2,0(r2)
 d04a034:	10803fcc 	andi	r2,r2,255
 d04a038:	1080201c 	xori	r2,r2,128
 d04a03c:	10bfe004 	addi	r2,r2,-128
 d04a040:	10800be0 	cmpeqi	r2,r2,47
 d04a044:	1000071e 	bne	r2,zero,d04a064 <vfslookup_locked+0x9c>
 d04a048:	e0bffe17 	ldw	r2,-8(fp)
 d04a04c:	10800003 	ldbu	r2,0(r2)
 d04a050:	10803fcc 	andi	r2,r2,255
 d04a054:	1080201c 	xori	r2,r2,128
 d04a058:	10bfe004 	addi	r2,r2,-128
 d04a05c:	10801718 	cmpnei	r2,r2,92
 d04a060:	1000061e 	bne	r2,zero,d04a07c <vfslookup_locked+0xb4>
            name++;
 d04a064:	e0bffe17 	ldw	r2,-8(fp)
 d04a068:	10800044 	addi	r2,r2,1
 d04a06c:	e0bffe15 	stw	r2,-8(fp)
 d04a070:	00000206 	br	d04a07c <vfslookup_locked+0xb4>
      }
      else
         name = cp ;
 d04a074:	e0bffc17 	ldw	r2,-16(fp)
 d04a078:	e0bffe15 	stw	r2,-8(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 d04a07c:	e13ffe17 	ldw	r4,-8(fp)
 d04a080:	01400fc4 	movi	r5,63
 d04a084:	d002d100 	call	d002d10 <strchr>
 d04a088:	1005003a 	cmpeq	r2,r2,zero
 d04a08c:	1000031e 	bne	r2,zero,d04a09c <vfslookup_locked+0xd4>
   {
      dtrap(); /* is this still allowed? */
 d04a090:	d025a500 	call	d025a50 <dtrap>
      return NULL;
 d04a094:	e03fff15 	stw	zero,-4(fp)
 d04a098:	00001306 	br	d04a0e8 <vfslookup_locked+0x120>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 d04a09c:	d0a95517 	ldw	r2,-23212(gp)
 d04a0a0:	e0bffd15 	stw	r2,-12(fp)
 d04a0a4:	00000c06 	br	d04a0d8 <vfslookup_locked+0x110>
   {
      if (strcmp(name, vp->name) == 0)
 d04a0a8:	e0bffd17 	ldw	r2,-12(fp)
 d04a0ac:	11400104 	addi	r5,r2,4
 d04a0b0:	e13ffe17 	ldw	r4,-8(fp)
 d04a0b4:	d00a4740 	call	d00a474 <strcmp>
 d04a0b8:	1004c03a 	cmpne	r2,r2,zero
 d04a0bc:	1000031e 	bne	r2,zero,d04a0cc <vfslookup_locked+0x104>
         return vp;
 d04a0c0:	e0bffd17 	ldw	r2,-12(fp)
 d04a0c4:	e0bfff15 	stw	r2,-4(fp)
 d04a0c8:	00000706 	br	d04a0e8 <vfslookup_locked+0x120>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 d04a0cc:	e0bffd17 	ldw	r2,-12(fp)
 d04a0d0:	10800017 	ldw	r2,0(r2)
 d04a0d4:	e0bffd15 	stw	r2,-12(fp)
 d04a0d8:	e0bffd17 	ldw	r2,-12(fp)
 d04a0dc:	1004c03a 	cmpne	r2,r2,zero
 d04a0e0:	103ff11e 	bne	r2,zero,d04a0a8 <vfslookup_locked+0xe0>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 d04a0e4:	e03fff15 	stw	zero,-4(fp)
 d04a0e8:	e0bfff17 	ldw	r2,-4(fp)
}
 d04a0ec:	e037883a 	mov	sp,fp
 d04a0f0:	dfc00117 	ldw	ra,4(sp)
 d04a0f4:	df000017 	ldw	fp,0(sp)
 d04a0f8:	dec00204 	addi	sp,sp,8
 d04a0fc:	f800283a 	ret

0d04a100 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 d04a100:	defffc04 	addi	sp,sp,-16
 d04a104:	dfc00315 	stw	ra,12(sp)
 d04a108:	df000215 	stw	fp,8(sp)
 d04a10c:	df000204 	addi	fp,sp,8
 d04a110:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 d04a114:	01000144 	movi	r4,5
 d04a118:	d02604c0 	call	d02604c <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 d04a11c:	e13fff17 	ldw	r4,-4(fp)
 d04a120:	d049fc80 	call	d049fc8 <vfslookup_locked>
 d04a124:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 d04a128:	01000144 	movi	r4,5
 d04a12c:	d0261000 	call	d026100 <post_app_sem>
   return vp;
 d04a130:	e0bffe17 	ldw	r2,-8(fp)
}
 d04a134:	e037883a 	mov	sp,fp
 d04a138:	dfc00117 	ldw	ra,4(sp)
 d04a13c:	df000017 	ldw	fp,0(sp)
 d04a140:	dec00204 	addi	sp,sp,8
 d04a144:	f800283a 	ret

0d04a148 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 d04a148:	defff804 	addi	sp,sp,-32
 d04a14c:	dfc00715 	stw	ra,28(sp)
 d04a150:	df000615 	stw	fp,24(sp)
 d04a154:	df000604 	addi	fp,sp,24
 d04a158:	e13ffe15 	stw	r4,-8(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 d04a15c:	e13ffe17 	ldw	r4,-8(fp)
 d04a160:	d020ae40 	call	d020ae4 <uslash>
 d04a164:	e0bffb15 	stw	r2,-20(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 d04a168:	d0a05517 	ldw	r2,-32428(gp)
 d04a16c:	e0bffd15 	stw	r2,-12(fp)
   while (*path && *ntmp)
 d04a170:	00003e06 	br	d04a26c <strippath+0x124>
   {
      while (*path == '/') path++;   /* strip leading slash */
 d04a174:	e0bffd17 	ldw	r2,-12(fp)
 d04a178:	10800044 	addi	r2,r2,1
 d04a17c:	e0bffd15 	stw	r2,-12(fp)
 d04a180:	e0bffd17 	ldw	r2,-12(fp)
 d04a184:	10800003 	ldbu	r2,0(r2)
 d04a188:	10803fcc 	andi	r2,r2,255
 d04a18c:	1080201c 	xori	r2,r2,128
 d04a190:	10bfe004 	addi	r2,r2,-128
 d04a194:	10800be0 	cmpeqi	r2,r2,47
 d04a198:	103ff61e 	bne	r2,zero,d04a174 <strippath+0x2c>
         if (*path == 0)
 d04a19c:	e0bffd17 	ldw	r2,-12(fp)
 d04a1a0:	10800003 	ldbu	r2,0(r2)
 d04a1a4:	10803fcc 	andi	r2,r2,255
 d04a1a8:	1080201c 	xori	r2,r2,128
 d04a1ac:	10bfe004 	addi	r2,r2,-128
 d04a1b0:	1005003a 	cmpeq	r2,r2,zero
 d04a1b4:	10003b1e 	bne	r2,zero,d04a2a4 <strippath+0x15c>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 d04a1b8:	e13ffd17 	ldw	r4,-12(fp)
 d04a1bc:	01400bc4 	movi	r5,47
 d04a1c0:	d002d100 	call	d002d10 <strchr>
 d04a1c4:	e0bffc15 	stw	r2,-16(fp)
      if (ptmp)
 d04a1c8:	e0bffc17 	ldw	r2,-16(fp)
 d04a1cc:	1005003a 	cmpeq	r2,r2,zero
 d04a1d0:	1000051e 	bne	r2,zero,d04a1e8 <strippath+0xa0>
         dirlen = ptmp - path;
 d04a1d4:	e0bffc17 	ldw	r2,-16(fp)
 d04a1d8:	e0fffd17 	ldw	r3,-12(fp)
 d04a1dc:	10c5c83a 	sub	r2,r2,r3
 d04a1e0:	e0bffa15 	stw	r2,-24(fp)
 d04a1e4:	00000706 	br	d04a204 <strippath+0xbc>
      else
         dirlen = strlen(path);
 d04a1e8:	e13ffd17 	ldw	r4,-12(fp)
 d04a1ec:	d0034640 	call	d003464 <strlen>
 d04a1f0:	e0bffa15 	stw	r2,-24(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 d04a1f4:	00000306 	br	d04a204 <strippath+0xbc>
 d04a1f8:	e0bffb17 	ldw	r2,-20(fp)
 d04a1fc:	10800044 	addi	r2,r2,1
 d04a200:	e0bffb15 	stw	r2,-20(fp)
 d04a204:	e0bffb17 	ldw	r2,-20(fp)
 d04a208:	10800003 	ldbu	r2,0(r2)
 d04a20c:	10803fcc 	andi	r2,r2,255
 d04a210:	1080201c 	xori	r2,r2,128
 d04a214:	10bfe004 	addi	r2,r2,-128
 d04a218:	10800be0 	cmpeqi	r2,r2,47
 d04a21c:	103ff61e 	bne	r2,zero,d04a1f8 <strippath+0xb0>
         if (strncmp(ntmp, path, dirlen) == 0)
 d04a220:	e1bffa17 	ldw	r6,-24(fp)
 d04a224:	e13ffb17 	ldw	r4,-20(fp)
 d04a228:	e17ffd17 	ldw	r5,-12(fp)
 d04a22c:	d04bf440 	call	d04bf44 <strncmp>
 d04a230:	1004c03a 	cmpne	r2,r2,zero
 d04a234:	10000b1e 	bne	r2,zero,d04a264 <strippath+0x11c>
      {
         path += dirlen;
 d04a238:	e0bffa17 	ldw	r2,-24(fp)
 d04a23c:	1007883a 	mov	r3,r2
 d04a240:	e0bffd17 	ldw	r2,-12(fp)
 d04a244:	10c5883a 	add	r2,r2,r3
 d04a248:	e0bffd15 	stw	r2,-12(fp)
         ntmp += dirlen;
 d04a24c:	e0bffa17 	ldw	r2,-24(fp)
 d04a250:	1007883a 	mov	r3,r2
 d04a254:	e0bffb17 	ldw	r2,-20(fp)
 d04a258:	10c5883a 	add	r2,r2,r3
 d04a25c:	e0bffb15 	stw	r2,-20(fp)
 d04a260:	00000206 	br	d04a26c <strippath+0x124>
      }
      else
         return NULL;   /* didn't match */
 d04a264:	e03fff15 	stw	zero,-4(fp)
 d04a268:	00002b06 	br	d04a318 <strippath+0x1d0>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 d04a26c:	e0bffd17 	ldw	r2,-12(fp)
 d04a270:	10800003 	ldbu	r2,0(r2)
 d04a274:	10803fcc 	andi	r2,r2,255
 d04a278:	1080201c 	xori	r2,r2,128
 d04a27c:	10bfe004 	addi	r2,r2,-128
 d04a280:	1005003a 	cmpeq	r2,r2,zero
 d04a284:	1000071e 	bne	r2,zero,d04a2a4 <strippath+0x15c>
 d04a288:	e0bffb17 	ldw	r2,-20(fp)
 d04a28c:	10800003 	ldbu	r2,0(r2)
 d04a290:	10803fcc 	andi	r2,r2,255
 d04a294:	1080201c 	xori	r2,r2,128
 d04a298:	10bfe004 	addi	r2,r2,-128
 d04a29c:	1004c03a 	cmpne	r2,r2,zero
 d04a2a0:	103fb71e 	bne	r2,zero,d04a180 <strippath+0x38>
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 d04a2a4:	e0bffd17 	ldw	r2,-12(fp)
 d04a2a8:	10800003 	ldbu	r2,0(r2)
 d04a2ac:	10803fcc 	andi	r2,r2,255
 d04a2b0:	1080201c 	xori	r2,r2,128
 d04a2b4:	10bfe004 	addi	r2,r2,-128
 d04a2b8:	1004c03a 	cmpne	r2,r2,zero
 d04a2bc:	1000151e 	bne	r2,zero,d04a314 <strippath+0x1cc>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 d04a2c0:	00000306 	br	d04a2d0 <strippath+0x188>
         ntmp++;
 d04a2c4:	e0bffb17 	ldw	r2,-20(fp)
 d04a2c8:	10800044 	addi	r2,r2,1
 d04a2cc:	e0bffb15 	stw	r2,-20(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 d04a2d0:	e0bffb17 	ldw	r2,-20(fp)
 d04a2d4:	10800003 	ldbu	r2,0(r2)
 d04a2d8:	10803fcc 	andi	r2,r2,255
 d04a2dc:	1080201c 	xori	r2,r2,128
 d04a2e0:	10bfe004 	addi	r2,r2,-128
 d04a2e4:	10801720 	cmpeqi	r2,r2,92
 d04a2e8:	103ff61e 	bne	r2,zero,d04a2c4 <strippath+0x17c>
 d04a2ec:	e0bffb17 	ldw	r2,-20(fp)
 d04a2f0:	10800003 	ldbu	r2,0(r2)
 d04a2f4:	10803fcc 	andi	r2,r2,255
 d04a2f8:	1080201c 	xori	r2,r2,128
 d04a2fc:	10bfe004 	addi	r2,r2,-128
 d04a300:	10800be0 	cmpeqi	r2,r2,47
 d04a304:	103fef1e 	bne	r2,zero,d04a2c4 <strippath+0x17c>
         ntmp++;
      return ntmp;
 d04a308:	e0bffb17 	ldw	r2,-20(fp)
 d04a30c:	e0bfff15 	stw	r2,-4(fp)
 d04a310:	00000106 	br	d04a318 <strippath+0x1d0>
   }
   else
      return NULL;
 d04a314:	e03fff15 	stw	zero,-4(fp)
 d04a318:	e0bfff17 	ldw	r2,-4(fp)
}
 d04a31c:	e037883a 	mov	sp,fp
 d04a320:	dfc00117 	ldw	ra,4(sp)
 d04a324:	df000017 	ldw	fp,0(sp)
 d04a328:	dec00204 	addi	sp,sp,8
 d04a32c:	f800283a 	ret

0d04a330 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 d04a330:	defffc04 	addi	sp,sp,-16
 d04a334:	df000315 	stw	fp,12(sp)
 d04a338:	df000304 	addi	fp,sp,12
 d04a33c:	e13ffe15 	stw	r4,-8(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d04a340:	d0a95417 	ldw	r2,-23216(gp)
 d04a344:	e0bffd15 	stw	r2,-12(fp)
 d04a348:	00000906 	br	d04a370 <isvfile_locked+0x40>
      if (vtmp == vfp)
 d04a34c:	e0fffd17 	ldw	r3,-12(fp)
 d04a350:	e0bffe17 	ldw	r2,-8(fp)
 d04a354:	1880031e 	bne	r3,r2,d04a364 <isvfile_locked+0x34>
      return TRUE;
 d04a358:	00800044 	movi	r2,1
 d04a35c:	e0bfff15 	stw	r2,-4(fp)
 d04a360:	00000706 	br	d04a380 <isvfile_locked+0x50>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d04a364:	e0bffd17 	ldw	r2,-12(fp)
 d04a368:	10800017 	ldw	r2,0(r2)
 d04a36c:	e0bffd15 	stw	r2,-12(fp)
 d04a370:	e0bffd17 	ldw	r2,-12(fp)
 d04a374:	1004c03a 	cmpne	r2,r2,zero
 d04a378:	103ff41e 	bne	r2,zero,d04a34c <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 d04a37c:	e03fff15 	stw	zero,-4(fp)
 d04a380:	e0bfff17 	ldw	r2,-4(fp)
}
 d04a384:	e037883a 	mov	sp,fp
 d04a388:	df000017 	ldw	fp,0(sp)
 d04a38c:	dec00104 	addi	sp,sp,4
 d04a390:	f800283a 	ret

0d04a394 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 d04a394:	defffc04 	addi	sp,sp,-16
 d04a398:	dfc00315 	stw	ra,12(sp)
 d04a39c:	df000215 	stw	fp,8(sp)
 d04a3a0:	df000204 	addi	fp,sp,8
 d04a3a4:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 d04a3a8:	01000144 	movi	r4,5
 d04a3ac:	d02604c0 	call	d02604c <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 d04a3b0:	e13fff17 	ldw	r4,-4(fp)
 d04a3b4:	d04a3300 	call	d04a330 <isvfile_locked>
 d04a3b8:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 d04a3bc:	01000144 	movi	r4,5
 d04a3c0:	d0261000 	call	d026100 <post_app_sem>
   return rc;
 d04a3c4:	e0bffe17 	ldw	r2,-8(fp)
}
 d04a3c8:	e037883a 	mov	sp,fp
 d04a3cc:	dfc00117 	ldw	ra,4(sp)
 d04a3d0:	df000017 	ldw	fp,0(sp)
 d04a3d4:	dec00204 	addi	sp,sp,8
 d04a3d8:	f800283a 	ret

0d04a3dc <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 d04a3dc:	defffc04 	addi	sp,sp,-16
 d04a3e0:	dfc00315 	stw	ra,12(sp)
 d04a3e4:	df000215 	stw	fp,8(sp)
 d04a3e8:	df000204 	addi	fp,sp,8
 d04a3ec:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 d04a3f0:	01000144 	movi	r4,5
 d04a3f4:	d02604c0 	call	d02604c <wait_app_sem>

   if (isvfile_locked(vfd))
 d04a3f8:	e13ffe17 	ldw	r4,-8(fp)
 d04a3fc:	d04a3300 	call	d04a330 <isvfile_locked>
 d04a400:	1005003a 	cmpeq	r2,r2,zero
 d04a404:	1000061e 	bne	r2,zero,d04a420 <vferror+0x44>
   {
      vfs_unlock();
 d04a408:	01000144 	movi	r4,5
 d04a40c:	d0261000 	call	d026100 <post_app_sem>

      return vfd->error;
 d04a410:	e0bffe17 	ldw	r2,-8(fp)
 d04a414:	10800417 	ldw	r2,16(r2)
 d04a418:	e0bfff15 	stw	r2,-4(fp)
 d04a41c:	00000406 	br	d04a430 <vferror+0x54>
   }

   vfs_unlock();
 d04a420:	01000144 	movi	r4,5
 d04a424:	d0261000 	call	d026100 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 d04a428:	00bfffc4 	movi	r2,-1
 d04a42c:	e0bfff15 	stw	r2,-4(fp)
 d04a430:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d04a434:	e037883a 	mov	sp,fp
 d04a438:	dfc00117 	ldw	ra,4(sp)
 d04a43c:	df000017 	ldw	fp,0(sp)
 d04a440:	dec00204 	addi	sp,sp,8
 d04a444:	f800283a 	ret

0d04a448 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 d04a448:	defffd04 	addi	sp,sp,-12
 d04a44c:	dfc00215 	stw	ra,8(sp)
 d04a450:	df000115 	stw	fp,4(sp)
 d04a454:	df000104 	addi	fp,sp,4
 d04a458:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 d04a45c:	01000144 	movi	r4,5
 d04a460:	d02604c0 	call	d02604c <wait_app_sem>

   if (isvfile_locked(vfd))
 d04a464:	e13fff17 	ldw	r4,-4(fp)
 d04a468:	d04a3300 	call	d04a330 <isvfile_locked>
 d04a46c:	1005003a 	cmpeq	r2,r2,zero
 d04a470:	1000051e 	bne	r2,zero,d04a488 <vclearerr+0x40>
   {
      vfs_unlock();
 d04a474:	01000144 	movi	r4,5
 d04a478:	d0261000 	call	d026100 <post_app_sem>

      vfd->error = 0;
 d04a47c:	e0bfff17 	ldw	r2,-4(fp)
 d04a480:	10000415 	stw	zero,16(r2)
      return;
 d04a484:	00000206 	br	d04a490 <vclearerr+0x48>
   }

   vfs_unlock();
 d04a488:	01000144 	movi	r4,5
 d04a48c:	d0261000 	call	d026100 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 d04a490:	e037883a 	mov	sp,fp
 d04a494:	dfc00117 	ldw	ra,4(sp)
 d04a498:	df000017 	ldw	fp,0(sp)
 d04a49c:	dec00204 	addi	sp,sp,8
 d04a4a0:	f800283a 	ret

0d04a4a4 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 d04a4a4:	defffe04 	addi	sp,sp,-8
 d04a4a8:	df000115 	stw	fp,4(sp)
 d04a4ac:	df000104 	addi	fp,sp,4
int e = 0;
 d04a4b0:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 d04a4b4:	e0bfff17 	ldw	r2,-4(fp)
}
 d04a4b8:	e037883a 	mov	sp,fp
 d04a4bc:	df000017 	ldw	fp,0(sp)
 d04a4c0:	dec00104 	addi	sp,sp,4
 d04a4c4:	f800283a 	ret

0d04a4c8 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 d04a4c8:	defffa04 	addi	sp,sp,-24
 d04a4cc:	dfc00515 	stw	ra,20(sp)
 d04a4d0:	df000415 	stw	fp,16(sp)
 d04a4d4:	df000404 	addi	fp,sp,16
 d04a4d8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 d04a4dc:	008000c4 	movi	r2,3
 d04a4e0:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 d04a4e4:	e13ffc17 	ldw	r4,-16(fp)
 d04a4e8:	014003f4 	movhi	r5,15
 d04a4ec:	29509004 	addi	r5,r5,16960
 d04a4f0:	d00235c0 	call	d00235c <__mulsi3>
 d04a4f4:	100b883a 	mov	r5,r2
 d04a4f8:	0100bef4 	movhi	r4,763
 d04a4fc:	213c2004 	addi	r4,r4,-3968
 d04a500:	d00c90c0 	call	d00c90c <__udivsi3>
 d04a504:	100b883a 	mov	r5,r2
 d04a508:	01200034 	movhi	r4,32768
 d04a50c:	213fffc4 	addi	r4,r4,-1
 d04a510:	d00c90c0 	call	d00c90c <__udivsi3>
 d04a514:	100b883a 	mov	r5,r2
 d04a518:	e13fff17 	ldw	r4,-4(fp)
 d04a51c:	d00c90c0 	call	d00c90c <__udivsi3>
 d04a520:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 d04a524:	e0bffd17 	ldw	r2,-12(fp)
 d04a528:	1005003a 	cmpeq	r2,r2,zero
 d04a52c:	10002a1e 	bne	r2,zero,d04a5d8 <alt_busy_sleep+0x110>
  {
    for(i=0;i<big_loops;i++)
 d04a530:	e03ffe15 	stw	zero,-8(fp)
 d04a534:	00001706 	br	d04a594 <alt_busy_sleep+0xcc>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 d04a538:	00a00034 	movhi	r2,32768
 d04a53c:	10bfffc4 	addi	r2,r2,-1
 d04a540:	10bfffc4 	addi	r2,r2,-1
 d04a544:	103ffe1e 	bne	r2,zero,d04a540 <alt_busy_sleep+0x78>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 d04a548:	e13ffc17 	ldw	r4,-16(fp)
 d04a54c:	014003f4 	movhi	r5,15
 d04a550:	29509004 	addi	r5,r5,16960
 d04a554:	d00235c0 	call	d00235c <__mulsi3>
 d04a558:	100b883a 	mov	r5,r2
 d04a55c:	0100bef4 	movhi	r4,763
 d04a560:	213c2004 	addi	r4,r4,-3968
 d04a564:	d00c90c0 	call	d00c90c <__udivsi3>
 d04a568:	100b883a 	mov	r5,r2
 d04a56c:	01200034 	movhi	r4,32768
 d04a570:	213fffc4 	addi	r4,r4,-1
 d04a574:	d00c90c0 	call	d00c90c <__udivsi3>
 d04a578:	1007883a 	mov	r3,r2
 d04a57c:	e0bfff17 	ldw	r2,-4(fp)
 d04a580:	10c5c83a 	sub	r2,r2,r3
 d04a584:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 d04a588:	e0bffe17 	ldw	r2,-8(fp)
 d04a58c:	10800044 	addi	r2,r2,1
 d04a590:	e0bffe15 	stw	r2,-8(fp)
 d04a594:	e0fffe17 	ldw	r3,-8(fp)
 d04a598:	e0bffd17 	ldw	r2,-12(fp)
 d04a59c:	18bfe616 	blt	r3,r2,d04a538 <alt_busy_sleep+0x70>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 d04a5a0:	e13ffc17 	ldw	r4,-16(fp)
 d04a5a4:	014003f4 	movhi	r5,15
 d04a5a8:	29509004 	addi	r5,r5,16960
 d04a5ac:	d00235c0 	call	d00235c <__mulsi3>
 d04a5b0:	100b883a 	mov	r5,r2
 d04a5b4:	0100bef4 	movhi	r4,763
 d04a5b8:	213c2004 	addi	r4,r4,-3968
 d04a5bc:	d00c90c0 	call	d00c90c <__udivsi3>
 d04a5c0:	1009883a 	mov	r4,r2
 d04a5c4:	e17fff17 	ldw	r5,-4(fp)
 d04a5c8:	d00235c0 	call	d00235c <__mulsi3>
 d04a5cc:	10bfffc4 	addi	r2,r2,-1
 d04a5d0:	103ffe1e 	bne	r2,zero,d04a5cc <alt_busy_sleep+0x104>
 d04a5d4:	00000d06 	br	d04a60c <alt_busy_sleep+0x144>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 d04a5d8:	e13ffc17 	ldw	r4,-16(fp)
 d04a5dc:	014003f4 	movhi	r5,15
 d04a5e0:	29509004 	addi	r5,r5,16960
 d04a5e4:	d00235c0 	call	d00235c <__mulsi3>
 d04a5e8:	100b883a 	mov	r5,r2
 d04a5ec:	0100bef4 	movhi	r4,763
 d04a5f0:	213c2004 	addi	r4,r4,-3968
 d04a5f4:	d00c90c0 	call	d00c90c <__udivsi3>
 d04a5f8:	1009883a 	mov	r4,r2
 d04a5fc:	e17fff17 	ldw	r5,-4(fp)
 d04a600:	d00235c0 	call	d00235c <__mulsi3>
 d04a604:	10bfffc4 	addi	r2,r2,-1
 d04a608:	00bffe16 	blt	zero,r2,d04a604 <alt_busy_sleep+0x13c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 d04a60c:	0005883a 	mov	r2,zero
}
 d04a610:	e037883a 	mov	sp,fp
 d04a614:	dfc00117 	ldw	ra,4(sp)
 d04a618:	df000017 	ldw	fp,0(sp)
 d04a61c:	dec00204 	addi	sp,sp,8
 d04a620:	f800283a 	ret

0d04a624 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 d04a624:	defff404 	addi	sp,sp,-48
 d04a628:	dfc00915 	stw	ra,36(sp)
 d04a62c:	df000815 	stw	fp,32(sp)
 d04a630:	df000804 	addi	fp,sp,32
 d04a634:	e13ffb15 	stw	r4,-20(fp)
 d04a638:	e1800215 	stw	r6,8(fp)
 d04a63c:	e1c00315 	stw	r7,12(fp)
 d04a640:	e17ffc15 	stw	r5,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d04a644:	e0bffb17 	ldw	r2,-20(fp)
 d04a648:	1004803a 	cmplt	r2,r2,zero
 d04a64c:	1000091e 	bne	r2,zero,d04a674 <alt_fcntl+0x50>
 d04a650:	e13ffb17 	ldw	r4,-20(fp)
 d04a654:	01400304 	movi	r5,12
 d04a658:	d00235c0 	call	d00235c <__mulsi3>
 d04a65c:	1007883a 	mov	r3,r2
 d04a660:	00834174 	movhi	r2,3333
 d04a664:	10915b04 	addi	r2,r2,17772
 d04a668:	1887883a 	add	r3,r3,r2
 d04a66c:	e0fffe15 	stw	r3,-8(fp)
 d04a670:	00000106 	br	d04a678 <alt_fcntl+0x54>
 d04a674:	e03ffe15 	stw	zero,-8(fp)
 d04a678:	e0bffe17 	ldw	r2,-8(fp)
 d04a67c:	e0bff915 	stw	r2,-28(fp)
  
  if (fd)
 d04a680:	e0bff917 	ldw	r2,-28(fp)
 d04a684:	1005003a 	cmpeq	r2,r2,zero
 d04a688:	1000301e 	bne	r2,zero,d04a74c <alt_fcntl+0x128>
  {
    switch (cmd)
 d04a68c:	e0fffc17 	ldw	r3,-16(fp)
 d04a690:	e0ffff15 	stw	r3,-4(fp)
 d04a694:	e0ffff17 	ldw	r3,-4(fp)
 d04a698:	188000e0 	cmpeqi	r2,r3,3
 d04a69c:	1000041e 	bne	r2,zero,d04a6b0 <alt_fcntl+0x8c>
 d04a6a0:	e0ffff17 	ldw	r3,-4(fp)
 d04a6a4:	18800120 	cmpeqi	r2,r3,4
 d04a6a8:	1000081e 	bne	r2,zero,d04a6cc <alt_fcntl+0xa8>
 d04a6ac:	00002006 	br	d04a730 <alt_fcntl+0x10c>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 d04a6b0:	e0bff917 	ldw	r2,-28(fp)
 d04a6b4:	10c00217 	ldw	r3,8(r2)
 d04a6b8:	00900034 	movhi	r2,16384
 d04a6bc:	10bfffc4 	addi	r2,r2,-1
 d04a6c0:	1886703a 	and	r3,r3,r2
 d04a6c4:	e0fffd15 	stw	r3,-12(fp)
 d04a6c8:	00002606 	br	d04a764 <alt_fcntl+0x140>
    case F_SETFL:
      va_start(argp, cmd);
 d04a6cc:	e0800204 	addi	r2,fp,8
 d04a6d0:	e0bffa15 	stw	r2,-24(fp)
      flags = va_arg(argp, long);
 d04a6d4:	e0fffa17 	ldw	r3,-24(fp)
 d04a6d8:	18800104 	addi	r2,r3,4
 d04a6dc:	e0bffa15 	stw	r2,-24(fp)
 d04a6e0:	1805883a 	mov	r2,r3
 d04a6e4:	10800017 	ldw	r2,0(r2)
 d04a6e8:	e0bff815 	stw	r2,-32(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 d04a6ec:	e0bff917 	ldw	r2,-28(fp)
 d04a6f0:	10c00217 	ldw	r3,8(r2)
 d04a6f4:	00affdc4 	movi	r2,-16393
 d04a6f8:	1886703a 	and	r3,r3,r2
 d04a6fc:	e0bff917 	ldw	r2,-28(fp)
 d04a700:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 d04a704:	e0bff917 	ldw	r2,-28(fp)
 d04a708:	10800217 	ldw	r2,8(r2)
 d04a70c:	1007883a 	mov	r3,r2
 d04a710:	e0bff817 	ldw	r2,-32(fp)
 d04a714:	1090020c 	andi	r2,r2,16392
 d04a718:	1884b03a 	or	r2,r3,r2
 d04a71c:	1007883a 	mov	r3,r2
 d04a720:	e0bff917 	ldw	r2,-28(fp)
 d04a724:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 d04a728:	e03ffd15 	stw	zero,-12(fp)
 d04a72c:	00000d06 	br	d04a764 <alt_fcntl+0x140>
    default:
      ALT_ERRNO = EINVAL;
 d04a730:	d04a77c0 	call	d04a77c <alt_get_errno>
 d04a734:	1007883a 	mov	r3,r2
 d04a738:	00800584 	movi	r2,22
 d04a73c:	18800015 	stw	r2,0(r3)
      return -1;
 d04a740:	00bfffc4 	movi	r2,-1
 d04a744:	e0bffd15 	stw	r2,-12(fp)
 d04a748:	00000606 	br	d04a764 <alt_fcntl+0x140>
    }
  }

  ALT_ERRNO = EBADFD;
 d04a74c:	d04a77c0 	call	d04a77c <alt_get_errno>
 d04a750:	1007883a 	mov	r3,r2
 d04a754:	00801444 	movi	r2,81
 d04a758:	18800015 	stw	r2,0(r3)
  return -1;
 d04a75c:	00ffffc4 	movi	r3,-1
 d04a760:	e0fffd15 	stw	r3,-12(fp)
 d04a764:	e0bffd17 	ldw	r2,-12(fp)
}
 d04a768:	e037883a 	mov	sp,fp
 d04a76c:	dfc00117 	ldw	ra,4(sp)
 d04a770:	df000017 	ldw	fp,0(sp)
 d04a774:	dec00404 	addi	sp,sp,16
 d04a778:	f800283a 	ret

0d04a77c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d04a77c:	defffd04 	addi	sp,sp,-12
 d04a780:	dfc00215 	stw	ra,8(sp)
 d04a784:	df000115 	stw	fp,4(sp)
 d04a788:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d04a78c:	00834174 	movhi	r2,3333
 d04a790:	10926504 	addi	r2,r2,18836
 d04a794:	10800017 	ldw	r2,0(r2)
 d04a798:	1005003a 	cmpeq	r2,r2,zero
 d04a79c:	1000061e 	bne	r2,zero,d04a7b8 <alt_get_errno+0x3c>
 d04a7a0:	00834174 	movhi	r2,3333
 d04a7a4:	10926504 	addi	r2,r2,18836
 d04a7a8:	10800017 	ldw	r2,0(r2)
 d04a7ac:	103ee83a 	callr	r2
 d04a7b0:	e0bfff15 	stw	r2,-4(fp)
 d04a7b4:	00000306 	br	d04a7c4 <alt_get_errno+0x48>
 d04a7b8:	00834174 	movhi	r2,3333
 d04a7bc:	109b0104 	addi	r2,r2,27652
 d04a7c0:	e0bfff15 	stw	r2,-4(fp)
 d04a7c4:	e0bfff17 	ldw	r2,-4(fp)
}
 d04a7c8:	e037883a 	mov	sp,fp
 d04a7cc:	dfc00117 	ldw	ra,4(sp)
 d04a7d0:	df000017 	ldw	fp,0(sp)
 d04a7d4:	dec00204 	addi	sp,sp,8
 d04a7d8:	f800283a 	ret

0d04a7dc <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 d04a7dc:	defffa04 	addi	sp,sp,-24
 d04a7e0:	dfc00515 	stw	ra,20(sp)
 d04a7e4:	df000415 	stw	fp,16(sp)
 d04a7e8:	df000404 	addi	fp,sp,16
 d04a7ec:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 d04a7f0:	00834174 	movhi	r2,3333
 d04a7f4:	10926004 	addi	r2,r2,18816
 d04a7f8:	10800017 	ldw	r2,0(r2)
 d04a7fc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 d04a800:	00003306 	br	d04a8d0 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 d04a804:	e0bffd17 	ldw	r2,-12(fp)
 d04a808:	11000217 	ldw	r4,8(r2)
 d04a80c:	d0034640 	call	d003464 <strlen>
 d04a810:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 d04a814:	e0bffd17 	ldw	r2,-12(fp)
 d04a818:	10c00217 	ldw	r3,8(r2)
 d04a81c:	e0bffc17 	ldw	r2,-16(fp)
 d04a820:	1885883a 	add	r2,r3,r2
 d04a824:	10bfffc4 	addi	r2,r2,-1
 d04a828:	10800003 	ldbu	r2,0(r2)
 d04a82c:	10803fcc 	andi	r2,r2,255
 d04a830:	1080201c 	xori	r2,r2,128
 d04a834:	10bfe004 	addi	r2,r2,-128
 d04a838:	10800bd8 	cmpnei	r2,r2,47
 d04a83c:	1000031e 	bne	r2,zero,d04a84c <alt_find_file+0x70>
    {
      len -= 1;
 d04a840:	e0bffc17 	ldw	r2,-16(fp)
 d04a844:	10bfffc4 	addi	r2,r2,-1
 d04a848:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 d04a84c:	e0bffc17 	ldw	r2,-16(fp)
 d04a850:	1007883a 	mov	r3,r2
 d04a854:	e0bffe17 	ldw	r2,-8(fp)
 d04a858:	1885883a 	add	r2,r3,r2
 d04a85c:	10800003 	ldbu	r2,0(r2)
 d04a860:	10803fcc 	andi	r2,r2,255
 d04a864:	1080201c 	xori	r2,r2,128
 d04a868:	10bfe004 	addi	r2,r2,-128
 d04a86c:	10800be0 	cmpeqi	r2,r2,47
 d04a870:	10000a1e 	bne	r2,zero,d04a89c <alt_find_file+0xc0>
 d04a874:	e0bffc17 	ldw	r2,-16(fp)
 d04a878:	1007883a 	mov	r3,r2
 d04a87c:	e0bffe17 	ldw	r2,-8(fp)
 d04a880:	1885883a 	add	r2,r3,r2
 d04a884:	10800003 	ldbu	r2,0(r2)
 d04a888:	10803fcc 	andi	r2,r2,255
 d04a88c:	1080201c 	xori	r2,r2,128
 d04a890:	10bfe004 	addi	r2,r2,-128
 d04a894:	1004c03a 	cmpne	r2,r2,zero
 d04a898:	10000a1e 	bne	r2,zero,d04a8c4 <alt_find_file+0xe8>
 d04a89c:	e0bffd17 	ldw	r2,-12(fp)
 d04a8a0:	11000217 	ldw	r4,8(r2)
 d04a8a4:	e1bffc17 	ldw	r6,-16(fp)
 d04a8a8:	e17ffe17 	ldw	r5,-8(fp)
 d04a8ac:	d04be440 	call	d04be44 <memcmp>
 d04a8b0:	1004c03a 	cmpne	r2,r2,zero
 d04a8b4:	1000031e 	bne	r2,zero,d04a8c4 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 d04a8b8:	e0bffd17 	ldw	r2,-12(fp)
 d04a8bc:	e0bfff15 	stw	r2,-4(fp)
 d04a8c0:	00000806 	br	d04a8e4 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 d04a8c4:	e0bffd17 	ldw	r2,-12(fp)
 d04a8c8:	10800017 	ldw	r2,0(r2)
 d04a8cc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 d04a8d0:	00c34174 	movhi	r3,3333
 d04a8d4:	18d26004 	addi	r3,r3,18816
 d04a8d8:	e0bffd17 	ldw	r2,-12(fp)
 d04a8dc:	10ffc91e 	bne	r2,r3,d04a804 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 d04a8e0:	e03fff15 	stw	zero,-4(fp)
 d04a8e4:	e0bfff17 	ldw	r2,-4(fp)
}
 d04a8e8:	e037883a 	mov	sp,fp
 d04a8ec:	dfc00117 	ldw	ra,4(sp)
 d04a8f0:	df000017 	ldw	fp,0(sp)
 d04a8f4:	dec00204 	addi	sp,sp,8
 d04a8f8:	f800283a 	ret

0d04a8fc <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 d04a8fc:	defff704 	addi	sp,sp,-36
 d04a900:	dfc00815 	stw	ra,32(sp)
 d04a904:	df000715 	stw	fp,28(sp)
 d04a908:	dc000615 	stw	r16,24(sp)
 d04a90c:	df000604 	addi	fp,sp,24
 d04a910:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 d04a914:	00bffa04 	movi	r2,-24
 d04a918:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 d04a91c:	00834174 	movhi	r2,3333
 d04a920:	109b5304 	addi	r2,r2,27980
 d04a924:	10800017 	ldw	r2,0(r2)
 d04a928:	e0bffa15 	stw	r2,-24(fp)
 d04a92c:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 d04a930:	e17ffb0b 	ldhu	r5,-20(fp)
 d04a934:	e1bffe04 	addi	r6,fp,-8
 d04a938:	e13ffa17 	ldw	r4,-24(fp)
 d04a93c:	d0135480 	call	d013548 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 d04a940:	e03ffd15 	stw	zero,-12(fp)
 d04a944:	00002006 	br	d04a9c8 <alt_get_fd+0xcc>
  {
    if (!alt_fd_list[i].dev)
 d04a948:	e13ffd17 	ldw	r4,-12(fp)
 d04a94c:	04034174 	movhi	r16,3333
 d04a950:	84115b04 	addi	r16,r16,17772
 d04a954:	01400304 	movi	r5,12
 d04a958:	d00235c0 	call	d00235c <__mulsi3>
 d04a95c:	1405883a 	add	r2,r2,r16
 d04a960:	10800017 	ldw	r2,0(r2)
 d04a964:	1004c03a 	cmpne	r2,r2,zero
 d04a968:	1000141e 	bne	r2,zero,d04a9bc <alt_get_fd+0xc0>
    {
      alt_fd_list[i].dev = dev;
 d04a96c:	e13ffd17 	ldw	r4,-12(fp)
 d04a970:	04034174 	movhi	r16,3333
 d04a974:	84115b04 	addi	r16,r16,17772
 d04a978:	01400304 	movi	r5,12
 d04a97c:	d00235c0 	call	d00235c <__mulsi3>
 d04a980:	1407883a 	add	r3,r2,r16
 d04a984:	e0bfff17 	ldw	r2,-4(fp)
 d04a988:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 d04a98c:	00834174 	movhi	r2,3333
 d04a990:	10926404 	addi	r2,r2,18832
 d04a994:	10c00017 	ldw	r3,0(r2)
 d04a998:	e0bffd17 	ldw	r2,-12(fp)
 d04a99c:	1880040e 	bge	r3,r2,d04a9b0 <alt_get_fd+0xb4>
      {
        alt_max_fd = i;
 d04a9a0:	00c34174 	movhi	r3,3333
 d04a9a4:	18d26404 	addi	r3,r3,18832
 d04a9a8:	e0bffd17 	ldw	r2,-12(fp)
 d04a9ac:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 d04a9b0:	e0bffd17 	ldw	r2,-12(fp)
 d04a9b4:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 d04a9b8:	00000606 	br	d04a9d4 <alt_get_fd+0xd8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 d04a9bc:	e0bffd17 	ldw	r2,-12(fp)
 d04a9c0:	10800044 	addi	r2,r2,1
 d04a9c4:	e0bffd15 	stw	r2,-12(fp)
 d04a9c8:	e0bffd17 	ldw	r2,-12(fp)
 d04a9cc:	10800810 	cmplti	r2,r2,32
 d04a9d0:	103fdd1e 	bne	r2,zero,d04a948 <alt_get_fd+0x4c>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 d04a9d4:	00834174 	movhi	r2,3333
 d04a9d8:	109b5304 	addi	r2,r2,27980
 d04a9dc:	11000017 	ldw	r4,0(r2)
 d04a9e0:	d0139400 	call	d013940 <OSSemPost>

  return rc;
 d04a9e4:	e0bffc17 	ldw	r2,-16(fp)
}
 d04a9e8:	e037883a 	mov	sp,fp
 d04a9ec:	dfc00217 	ldw	ra,8(sp)
 d04a9f0:	df000117 	ldw	fp,4(sp)
 d04a9f4:	dc000017 	ldw	r16,0(sp)
 d04a9f8:	dec00304 	addi	sp,sp,12
 d04a9fc:	f800283a 	ret

0d04aa00 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 d04aa00:	defffb04 	addi	sp,sp,-20
 d04aa04:	df000415 	stw	fp,16(sp)
 d04aa08:	df000404 	addi	fp,sp,16
 d04aa0c:	e13ffe15 	stw	r4,-8(fp)
 d04aa10:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 d04aa14:	e0bfff17 	ldw	r2,-4(fp)
 d04aa18:	10808070 	cmpltui	r2,r2,513
 d04aa1c:	1000021e 	bne	r2,zero,d04aa28 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 d04aa20:	00808004 	movi	r2,512
 d04aa24:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 d04aa28:	e0fffe17 	ldw	r3,-8(fp)
 d04aa2c:	e0bfff17 	ldw	r2,-4(fp)
 d04aa30:	1885883a 	add	r2,r3,r2
 d04aa34:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 d04aa38:	e0bffe17 	ldw	r2,-8(fp)
 d04aa3c:	e0bffd15 	stw	r2,-12(fp)
 d04aa40:	00000506 	br	d04aa58 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 d04aa44:	e0bffd17 	ldw	r2,-12(fp)
 d04aa48:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 d04aa4c:	e0bffd17 	ldw	r2,-12(fp)
 d04aa50:	10800804 	addi	r2,r2,32
 d04aa54:	e0bffd15 	stw	r2,-12(fp)
 d04aa58:	e0fffd17 	ldw	r3,-12(fp)
 d04aa5c:	e0bffc17 	ldw	r2,-16(fp)
 d04aa60:	18bff836 	bltu	r3,r2,d04aa44 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 d04aa64:	e0bffe17 	ldw	r2,-8(fp)
 d04aa68:	108007cc 	andi	r2,r2,31
 d04aa6c:	1005003a 	cmpeq	r2,r2,zero
 d04aa70:	1000021e 	bne	r2,zero,d04aa7c <alt_icache_flush+0x7c>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 d04aa74:	e0bffd17 	ldw	r2,-12(fp)
 d04aa78:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 d04aa7c:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 d04aa80:	e037883a 	mov	sp,fp
 d04aa84:	df000017 	ldw	fp,0(sp)
 d04aa88:	dec00104 	addi	sp,sp,4
 d04aa8c:	f800283a 	ret

0d04aa90 <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 d04aa90:	deffed04 	addi	sp,sp,-76
 d04aa94:	dfc01215 	stw	ra,72(sp)
 d04aa98:	df001115 	stw	fp,68(sp)
 d04aa9c:	dc401015 	stw	r17,64(sp)
 d04aaa0:	dc000f15 	stw	r16,60(sp)
 d04aaa4:	df000f04 	addi	fp,sp,60
 d04aaa8:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 d04aaac:	e03ff505 	stb	zero,-44(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 d04aab0:	008341b4 	movhi	r2,3334
 d04aab4:	10858604 	addi	r2,r2,5656
 d04aab8:	10800017 	ldw	r2,0(r2)
 d04aabc:	10c00044 	addi	r3,r2,1
 d04aac0:	008341b4 	movhi	r2,3334
 d04aac4:	10858604 	addi	r2,r2,5656
 d04aac8:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 d04aacc:	e0bffd17 	ldw	r2,-12(fp)
 d04aad0:	10800317 	ldw	r2,12(r2)
 d04aad4:	e0bffa15 	stw	r2,-24(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 d04aad8:	e0bffd17 	ldw	r2,-12(fp)
 d04aadc:	10c00417 	ldw	r3,16(r2)
 d04aae0:	e0bffa17 	ldw	r2,-24(fp)
 d04aae4:	10800003 	ldbu	r2,0(r2)
 d04aae8:	10803fcc 	andi	r2,r2,255
 d04aaec:	108003cc 	andi	r2,r2,15
 d04aaf0:	1085883a 	add	r2,r2,r2
 d04aaf4:	1085883a 	add	r2,r2,r2
 d04aaf8:	1885c83a 	sub	r2,r3,r2
 d04aafc:	e0bffc15 	stw	r2,-16(fp)
   host = p->fhost;                       /* filled in by IP layer */
 d04ab00:	e0bffd17 	ldw	r2,-12(fp)
 d04ab04:	10800717 	ldw	r2,28(r2)
 d04ab08:	e0bffb15 	stw	r2,-20(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d04ab0c:	00834174 	movhi	r2,3333
 d04ab10:	109b2004 	addi	r2,r2,27776
 d04ab14:	10800017 	ldw	r2,0(r2)
 d04ab18:	1081000c 	andi	r2,r2,1024
 d04ab1c:	1005003a 	cmpeq	r2,r2,zero
 d04ab20:	1000161e 	bne	r2,zero,d04ab7c <icmprcv+0xec>
 d04ab24:	00834174 	movhi	r2,3333
 d04ab28:	109b2004 	addi	r2,r2,27776
 d04ab2c:	10800017 	ldw	r2,0(r2)
 d04ab30:	1080800c 	andi	r2,r2,512
 d04ab34:	1005003a 	cmpeq	r2,r2,zero
 d04ab38:	1000101e 	bne	r2,zero,d04ab7c <icmprcv+0xec>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 d04ab3c:	e0bffb17 	ldw	r2,-20(fp)
 d04ab40:	11803fcc 	andi	r6,r2,255
 d04ab44:	e0bffb17 	ldw	r2,-20(fp)
 d04ab48:	1004d23a 	srli	r2,r2,8
 d04ab4c:	11c03fcc 	andi	r7,r2,255
 d04ab50:	e0bffb17 	ldw	r2,-20(fp)
 d04ab54:	1004d43a 	srli	r2,r2,16
 d04ab58:	10c03fcc 	andi	r3,r2,255
 d04ab5c:	e0bffb17 	ldw	r2,-20(fp)
 d04ab60:	1004d63a 	srli	r2,r2,24
 d04ab64:	d8c00015 	stw	r3,0(sp)
 d04ab68:	d8800115 	stw	r2,4(sp)
 d04ab6c:	01034174 	movhi	r4,3333
 d04ab70:	21093004 	addi	r4,r4,9408
 d04ab74:	e17ffc17 	ldw	r5,-16(fp)
 d04ab78:	d0028a00 	call	d0028a0 <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 d04ab7c:	e0bffa17 	ldw	r2,-24(fp)
 d04ab80:	10800003 	ldbu	r2,0(r2)
 d04ab84:	10803fcc 	andi	r2,r2,255
 d04ab88:	108003cc 	andi	r2,r2,15
 d04ab8c:	1085883a 	add	r2,r2,r2
 d04ab90:	1085883a 	add	r2,r2,r2
 d04ab94:	1007883a 	mov	r3,r2
 d04ab98:	e0bffa17 	ldw	r2,-24(fp)
 d04ab9c:	1885883a 	add	r2,r3,r2
 d04aba0:	e0bff915 	stw	r2,-28(fp)

   osum = e->pchksum;
 d04aba4:	e0bff917 	ldw	r2,-28(fp)
 d04aba8:	1080008b 	ldhu	r2,2(r2)
 d04abac:	e0bff88d 	sth	r2,-30(fp)
   e->pchksum = 0;
 d04abb0:	e0bff917 	ldw	r2,-28(fp)
 d04abb4:	1000008d 	sth	zero,2(r2)

   if (len&1)
 d04abb8:	e0bffc17 	ldw	r2,-16(fp)
 d04abbc:	1080004c 	andi	r2,r2,1
 d04abc0:	10803fcc 	andi	r2,r2,255
 d04abc4:	1005003a 	cmpeq	r2,r2,zero
 d04abc8:	1000091e 	bne	r2,zero,d04abf0 <icmprcv+0x160>
   {
      sav_ch = *(((char *) e) + len);
 d04abcc:	e0fff917 	ldw	r3,-28(fp)
 d04abd0:	e0bffc17 	ldw	r2,-16(fp)
 d04abd4:	1885883a 	add	r2,r3,r2
 d04abd8:	10800003 	ldbu	r2,0(r2)
 d04abdc:	e0bff505 	stb	r2,-44(fp)
      ((char *)e)[len] = 0;
 d04abe0:	e0fff917 	ldw	r3,-28(fp)
 d04abe4:	e0bffc17 	ldw	r2,-16(fp)
 d04abe8:	1885883a 	add	r2,r3,r2
 d04abec:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 d04abf0:	e0bffc17 	ldw	r2,-16(fp)
 d04abf4:	10800044 	addi	r2,r2,1
 d04abf8:	100ad07a 	srli	r5,r2,1
 d04abfc:	e13ff917 	ldw	r4,-28(fp)
 d04ac00:	d0205440 	call	d020544 <cksum>
 d04ac04:	0084303a 	nor	r2,zero,r2
 d04ac08:	e0bff80d 	sth	r2,-32(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 d04ac0c:	e0bffc17 	ldw	r2,-16(fp)
 d04ac10:	1080004c 	andi	r2,r2,1
 d04ac14:	10803fcc 	andi	r2,r2,255
 d04ac18:	1005003a 	cmpeq	r2,r2,zero
 d04ac1c:	1000051e 	bne	r2,zero,d04ac34 <icmprcv+0x1a4>
 d04ac20:	e0fff917 	ldw	r3,-28(fp)
 d04ac24:	e0bffc17 	ldw	r2,-16(fp)
 d04ac28:	1887883a 	add	r3,r3,r2
 d04ac2c:	e0bff503 	ldbu	r2,-44(fp)
 d04ac30:	18800005 	stb	r2,0(r3)
   if (xsum != osum)
 d04ac34:	e0fff80b 	ldhu	r3,-32(fp)
 d04ac38:	e0bff88b 	ldhu	r2,-30(fp)
 d04ac3c:	18802c26 	beq	r3,r2,d04acf0 <icmprcv+0x260>
   {
      e->pchksum = osum;
 d04ac40:	e0fff917 	ldw	r3,-28(fp)
 d04ac44:	e0bff88b 	ldhu	r2,-30(fp)
 d04ac48:	1880008d 	sth	r2,2(r3)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d04ac4c:	00834174 	movhi	r2,3333
 d04ac50:	109b2004 	addi	r2,r2,27776
 d04ac54:	10800017 	ldw	r2,0(r2)
 d04ac58:	1081000c 	andi	r2,r2,1024
 d04ac5c:	1005003a 	cmpeq	r2,r2,zero
 d04ac60:	1000131e 	bne	r2,zero,d04acb0 <icmprcv+0x220>
 d04ac64:	00834174 	movhi	r2,3333
 d04ac68:	109b2004 	addi	r2,r2,27776
 d04ac6c:	10800017 	ldw	r2,0(r2)
 d04ac70:	1080800c 	andi	r2,r2,512
 d04ac74:	1005003a 	cmpeq	r2,r2,zero
 d04ac78:	10000d1e 	bne	r2,zero,d04acb0 <icmprcv+0x220>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 d04ac7c:	e17ff88b 	ldhu	r5,-30(fp)
 d04ac80:	e1bff80b 	ldhu	r6,-32(fp)
 d04ac84:	01034174 	movhi	r4,3333
 d04ac88:	21093804 	addi	r4,r4,9440
 d04ac8c:	d0028a00 	call	d0028a0 <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 d04ac90:	00834174 	movhi	r2,3333
 d04ac94:	109b2004 	addi	r2,r2,27776
 d04ac98:	10800017 	ldw	r2,0(r2)
 d04ac9c:	1080008c 	andi	r2,r2,2
 d04aca0:	1005003a 	cmpeq	r2,r2,zero
 d04aca4:	1000021e 	bne	r2,zero,d04acb0 <icmprcv+0x220>
 d04aca8:	e13ffd17 	ldw	r4,-12(fp)
 d04acac:	d0404b00 	call	d0404b0 <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 d04acb0:	008341b4 	movhi	r2,3334
 d04acb4:	10858604 	addi	r2,r2,5656
 d04acb8:	10800117 	ldw	r2,4(r2)
 d04acbc:	10c00044 	addi	r3,r2,1
 d04acc0:	008341b4 	movhi	r2,3334
 d04acc4:	10858604 	addi	r2,r2,5656
 d04acc8:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d04accc:	01000084 	movi	r4,2
 d04acd0:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04acd4:	e13ffd17 	ldw	r4,-12(fp)
 d04acd8:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04acdc:	01000084 	movi	r4,2
 d04ace0:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 d04ace4:	00bff804 	movi	r2,-32
 d04ace8:	e0bfff15 	stw	r2,-4(fp)
 d04acec:	00026d06 	br	d04b6a4 <icmprcv+0xc14>
   }

   e->pchksum = osum;
 d04acf0:	e0fff917 	ldw	r3,-28(fp)
 d04acf4:	e0bff88b 	ldhu	r2,-30(fp)
 d04acf8:	1880008d 	sth	r2,2(r3)

   switch (e->ptype) 
 d04acfc:	e0bff917 	ldw	r2,-28(fp)
 d04ad00:	10800003 	ldbu	r2,0(r2)
 d04ad04:	10803fcc 	andi	r2,r2,255
 d04ad08:	1080201c 	xori	r2,r2,128
 d04ad0c:	10bfe004 	addi	r2,r2,-128
 d04ad10:	e0bffe15 	stw	r2,-8(fp)
 d04ad14:	e0fffe17 	ldw	r3,-8(fp)
 d04ad18:	18800428 	cmpgeui	r2,r3,16
 d04ad1c:	1002401e 	bne	r2,zero,d04b620 <icmprcv+0xb90>
 d04ad20:	e13ffe17 	ldw	r4,-8(fp)
 d04ad24:	e13ffe17 	ldw	r4,-8(fp)
 d04ad28:	2105883a 	add	r2,r4,r4
 d04ad2c:	1087883a 	add	r3,r2,r2
 d04ad30:	00834174 	movhi	r2,3333
 d04ad34:	10ab5104 	addi	r2,r2,-21180
 d04ad38:	1885883a 	add	r2,r3,r2
 d04ad3c:	10800017 	ldw	r2,0(r2)
 d04ad40:	1000683a 	jmp	r2
 d04ad44:	0d04b028 	cmpgeui	r20,at,4800
 d04ad48:	0d04b620 	cmpeqi	r20,at,4824
 d04ad4c:	0d04b620 	cmpeqi	r20,at,4824
 d04ad50:	0d04b054 	ori	r20,at,4801
 d04ad54:	0d04b144 	addi	r20,at,4805
 d04ad58:	0d04b1ec 	andhi	r20,at,4807
 d04ad5c:	0d04b620 	cmpeqi	r20,at,4824
 d04ad60:	0d04b620 	cmpeqi	r20,at,4824
 d04ad64:	0d04ad84 	addi	r20,at,4790
 d04ad68:	0d04b620 	cmpeqi	r20,at,4824
 d04ad6c:	0d04b620 	cmpeqi	r20,at,4824
 d04ad70:	0d04b30c 	andi	r20,at,4812
 d04ad74:	0d04b414 	ori	r20,at,4816
 d04ad78:	0d04b490 	cmplti	r20,at,4818
 d04ad7c:	0d04b620 	cmpeqi	r20,at,4824
 d04ad80:	0d04b5e0 	cmpeqi	r20,at,4823
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 d04ad84:	008341b4 	movhi	r2,3334
 d04ad88:	10858604 	addi	r2,r2,5656
 d04ad8c:	10800717 	ldw	r2,28(r2)
 d04ad90:	10c00044 	addi	r3,r2,1
 d04ad94:	008341b4 	movhi	r2,3334
 d04ad98:	10858604 	addi	r2,r2,5656
 d04ad9c:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d04ada0:	00834174 	movhi	r2,3333
 d04ada4:	109b2004 	addi	r2,r2,27776
 d04ada8:	10800017 	ldw	r2,0(r2)
 d04adac:	1081000c 	andi	r2,r2,1024
 d04adb0:	1005003a 	cmpeq	r2,r2,zero
 d04adb4:	1000141e 	bne	r2,zero,d04ae08 <icmprcv+0x378>
 d04adb8:	00834174 	movhi	r2,3333
 d04adbc:	109b2004 	addi	r2,r2,27776
 d04adc0:	10800017 	ldw	r2,0(r2)
 d04adc4:	1080800c 	andi	r2,r2,512
 d04adc8:	1005003a 	cmpeq	r2,r2,zero
 d04adcc:	10000e1e 	bne	r2,zero,d04ae08 <icmprcv+0x378>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d04add0:	e0bffb17 	ldw	r2,-20(fp)
 d04add4:	11403fcc 	andi	r5,r2,255
 d04add8:	e0bffb17 	ldw	r2,-20(fp)
 d04addc:	1004d23a 	srli	r2,r2,8
 d04ade0:	11803fcc 	andi	r6,r2,255
 d04ade4:	e0bffb17 	ldw	r2,-20(fp)
 d04ade8:	1004d43a 	srli	r2,r2,16
 d04adec:	11c03fcc 	andi	r7,r2,255
 d04adf0:	e0bffb17 	ldw	r2,-20(fp)
 d04adf4:	1004d63a 	srli	r2,r2,24
 d04adf8:	d8800015 	stw	r2,0(sp)
 d04adfc:	01034174 	movhi	r4,3333
 d04ae00:	21094304 	addi	r4,r4,9484
 d04ae04:	d0028a00 	call	d0028a0 <printf>
#endif
      e->ptype = ECHOREP;
 d04ae08:	e0bff917 	ldw	r2,-28(fp)
 d04ae0c:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 d04ae10:	e0bff917 	ldw	r2,-28(fp)
 d04ae14:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 d04ae18:	e0bffc17 	ldw	r2,-16(fp)
 d04ae1c:	1080004c 	andi	r2,r2,1
 d04ae20:	10803fcc 	andi	r2,r2,255
 d04ae24:	1005003a 	cmpeq	r2,r2,zero
 d04ae28:	1000091e 	bne	r2,zero,d04ae50 <icmprcv+0x3c0>
      {
         sav_ch = *(((char *) e) + len);
 d04ae2c:	e0fff917 	ldw	r3,-28(fp)
 d04ae30:	e0bffc17 	ldw	r2,-16(fp)
 d04ae34:	1885883a 	add	r2,r3,r2
 d04ae38:	10800003 	ldbu	r2,0(r2)
 d04ae3c:	e0bff505 	stb	r2,-44(fp)
         ((char *)e)[len] = 0;
 d04ae40:	e0fff917 	ldw	r3,-28(fp)
 d04ae44:	e0bffc17 	ldw	r2,-16(fp)
 d04ae48:	1885883a 	add	r2,r3,r2
 d04ae4c:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 d04ae50:	e0bffc17 	ldw	r2,-16(fp)
 d04ae54:	10800044 	addi	r2,r2,1
 d04ae58:	100ad07a 	srli	r5,r2,1
 d04ae5c:	e13ff917 	ldw	r4,-28(fp)
 d04ae60:	d0205440 	call	d020544 <cksum>
 d04ae64:	0084303a 	nor	r2,zero,r2
 d04ae68:	1007883a 	mov	r3,r2
 d04ae6c:	e0bff917 	ldw	r2,-28(fp)
 d04ae70:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 d04ae74:	e0bffc17 	ldw	r2,-16(fp)
 d04ae78:	1080004c 	andi	r2,r2,1
 d04ae7c:	10803fcc 	andi	r2,r2,255
 d04ae80:	1005003a 	cmpeq	r2,r2,zero
 d04ae84:	1000051e 	bne	r2,zero,d04ae9c <icmprcv+0x40c>
 d04ae88:	e0fff917 	ldw	r3,-28(fp)
 d04ae8c:	e0bffc17 	ldw	r2,-16(fp)
 d04ae90:	1887883a 	add	r3,r3,r2
 d04ae94:	e0bff503 	ldbu	r2,-44(fp)
 d04ae98:	18800005 	stb	r2,0(r3)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 d04ae9c:	e0bffa17 	ldw	r2,-24(fp)
 d04aea0:	10800417 	ldw	r2,16(r2)
 d04aea4:	10bfffe0 	cmpeqi	r2,r2,-1
 d04aea8:	1000211e 	bne	r2,zero,d04af30 <icmprcv+0x4a0>
 d04aeac:	e0bffa17 	ldw	r2,-24(fp)
 d04aeb0:	10800417 	ldw	r2,16(r2)
 d04aeb4:	1004d63a 	srli	r2,r2,24
 d04aeb8:	10c03fcc 	andi	r3,r2,255
 d04aebc:	e0bffa17 	ldw	r2,-24(fp)
 d04aec0:	10800417 	ldw	r2,16(r2)
 d04aec4:	1004d23a 	srli	r2,r2,8
 d04aec8:	10bfc00c 	andi	r2,r2,65280
 d04aecc:	1886b03a 	or	r3,r3,r2
 d04aed0:	e0bffa17 	ldw	r2,-24(fp)
 d04aed4:	10800417 	ldw	r2,16(r2)
 d04aed8:	10bfc00c 	andi	r2,r2,65280
 d04aedc:	1004923a 	slli	r2,r2,8
 d04aee0:	1886b03a 	or	r3,r3,r2
 d04aee4:	e0bffa17 	ldw	r2,-24(fp)
 d04aee8:	10800417 	ldw	r2,16(r2)
 d04aeec:	10803fcc 	andi	r2,r2,255
 d04aef0:	1004963a 	slli	r2,r2,24
 d04aef4:	1884b03a 	or	r2,r3,r2
 d04aef8:	10fc002c 	andhi	r3,r2,61440
 d04aefc:	00b80034 	movhi	r2,57344
 d04af00:	18800b26 	beq	r3,r2,d04af30 <icmprcv+0x4a0>
 d04af04:	e0bffa17 	ldw	r2,-24(fp)
 d04af08:	11000417 	ldw	r4,16(r2)
 d04af0c:	e0bffd17 	ldw	r2,-12(fp)
 d04af10:	10800617 	ldw	r2,24(r2)
 d04af14:	10c00a17 	ldw	r3,40(r2)
 d04af18:	e0bffd17 	ldw	r2,-12(fp)
 d04af1c:	10800617 	ldw	r2,24(r2)
 d04af20:	10800c17 	ldw	r2,48(r2)
 d04af24:	0084303a 	nor	r2,zero,r2
 d04af28:	1884b03a 	or	r2,r3,r2
 d04af2c:	2080061e 	bne	r4,r2,d04af48 <icmprcv+0x4b8>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 d04af30:	e0bffd17 	ldw	r2,-12(fp)
 d04af34:	10800617 	ldw	r2,24(r2)
 d04af38:	10c00a17 	ldw	r3,40(r2)
 d04af3c:	e0bffa17 	ldw	r2,-24(fp)
 d04af40:	10c00315 	stw	r3,12(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 d04af44:	00000406 	br	d04af58 <icmprcv+0x4c8>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
      }
      else pip->ip_src = pip->ip_dest;
 d04af48:	e0bffa17 	ldw	r2,-24(fp)
 d04af4c:	10c00417 	ldw	r3,16(r2)
 d04af50:	e0bffa17 	ldw	r2,-24(fp)
 d04af54:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 d04af58:	e0fffa17 	ldw	r3,-24(fp)
 d04af5c:	e0bffb17 	ldw	r2,-20(fp)
 d04af60:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutEchoReps++;
 d04af64:	008341b4 	movhi	r2,3334
 d04af68:	10858604 	addi	r2,r2,5656
 d04af6c:	10801517 	ldw	r2,84(r2)
 d04af70:	10c00044 	addi	r3,r2,1
 d04af74:	008341b4 	movhi	r2,3334
 d04af78:	10858604 	addi	r2,r2,5656
 d04af7c:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 d04af80:	008341b4 	movhi	r2,3334
 d04af84:	10858604 	addi	r2,r2,5656
 d04af88:	10800d17 	ldw	r2,52(r2)
 d04af8c:	10c00044 	addi	r3,r2,1
 d04af90:	008341b4 	movhi	r2,3334
 d04af94:	10858604 	addi	r2,r2,5656
 d04af98:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 d04af9c:	e0fffd17 	ldw	r3,-12(fp)
 d04afa0:	e0bffb17 	ldw	r2,-20(fp)
 d04afa4:	18800715 	stw	r2,28(r3)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 d04afa8:	e0bffd17 	ldw	r2,-12(fp)
 d04afac:	10c00317 	ldw	r3,12(r2)
 d04afb0:	e0bffa17 	ldw	r2,-24(fp)
 d04afb4:	10800003 	ldbu	r2,0(r2)
 d04afb8:	10803fcc 	andi	r2,r2,255
 d04afbc:	108003cc 	andi	r2,r2,15
 d04afc0:	1085883a 	add	r2,r2,r2
 d04afc4:	1085883a 	add	r2,r2,r2
 d04afc8:	1887883a 	add	r3,r3,r2
 d04afcc:	e0bffd17 	ldw	r2,-12(fp)
 d04afd0:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 d04afd4:	e0fffd17 	ldw	r3,-12(fp)
 d04afd8:	e0bffc17 	ldw	r2,-16(fp)
 d04afdc:	18800415 	stw	r2,16(r3)

      i = ip_write(ICMP_PROT, p);
 d04afe0:	01000044 	movi	r4,1
 d04afe4:	e17ffd17 	ldw	r5,-12(fp)
 d04afe8:	d03f2780 	call	d03f278 <ip_write>
 d04afec:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 d04aff0:	e0bff417 	ldw	r2,-48(fp)
 d04aff4:	1004403a 	cmpge	r2,r2,zero
 d04aff8:	1000091e 	bne	r2,zero,d04b020 <icmprcv+0x590>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 d04affc:	00834174 	movhi	r2,3333
 d04b000:	109b2004 	addi	r2,r2,27776
 d04b004:	10800017 	ldw	r2,0(r2)
 d04b008:	1081000c 	andi	r2,r2,1024
 d04b00c:	1005003a 	cmpeq	r2,r2,zero
 d04b010:	1000031e 	bne	r2,zero,d04b020 <icmprcv+0x590>
            dprintf("icmp: reply failed\n");
 d04b014:	01034174 	movhi	r4,3333
 d04b018:	21094c04 	addi	r4,r4,9520
 d04b01c:	d002bc80 	call	d002bc8 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 d04b020:	e03fff15 	stw	zero,-4(fp)
 d04b024:	00019f06 	br	d04b6a4 <icmprcv+0xc14>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 d04b028:	008341b4 	movhi	r2,3334
 d04b02c:	10858604 	addi	r2,r2,5656
 d04b030:	10800817 	ldw	r2,32(r2)
 d04b034:	10c00044 	addi	r3,r2,1
 d04b038:	008341b4 	movhi	r2,3334
 d04b03c:	10858604 	addi	r2,r2,5656
 d04b040:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 d04b044:	e13ffd17 	ldw	r4,-12(fp)
 d04b048:	d043c680 	call	d043c68 <ip_raw_input>
 d04b04c:	e0bfff15 	stw	r2,-4(fp)
 d04b050:	00019406 	br	d04b6a4 <icmprcv+0xc14>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 d04b054:	008341b4 	movhi	r2,3334
 d04b058:	10858604 	addi	r2,r2,5656
 d04b05c:	10800217 	ldw	r2,8(r2)
 d04b060:	10c00044 	addi	r3,r2,1
 d04b064:	008341b4 	movhi	r2,3334
 d04b068:	10858604 	addi	r2,r2,5656
 d04b06c:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 d04b070:	e0bff917 	ldw	r2,-28(fp)
 d04b074:	e0bff615 	stw	r2,-40(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b078:	00834174 	movhi	r2,3333
 d04b07c:	109b2004 	addi	r2,r2,27776
 d04b080:	10800017 	ldw	r2,0(r2)
 d04b084:	1081000c 	andi	r2,r2,1024
 d04b088:	1005003a 	cmpeq	r2,r2,zero
 d04b08c:	1000291e 	bne	r2,zero,d04b134 <icmprcv+0x6a4>
      {
         dprintf("ICMP: got dest unreachable type ");
 d04b090:	01034174 	movhi	r4,3333
 d04b094:	21095104 	addi	r4,r4,9540
 d04b098:	d0028a00 	call	d0028a0 <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 d04b09c:	e0bff617 	ldw	r2,-40(fp)
 d04b0a0:	10800043 	ldbu	r2,1(r2)
 d04b0a4:	11403fcc 	andi	r5,r2,255
 d04b0a8:	2940201c 	xori	r5,r5,128
 d04b0ac:	297fe004 	addi	r5,r5,-128
 d04b0b0:	e0bff617 	ldw	r2,-40(fp)
 d04b0b4:	10800617 	ldw	r2,24(r2)
 d04b0b8:	11803fcc 	andi	r6,r2,255
 d04b0bc:	e0bff617 	ldw	r2,-40(fp)
 d04b0c0:	10800617 	ldw	r2,24(r2)
 d04b0c4:	1004d23a 	srli	r2,r2,8
 d04b0c8:	11c03fcc 	andi	r7,r2,255
 d04b0cc:	e0bff617 	ldw	r2,-40(fp)
 d04b0d0:	10800617 	ldw	r2,24(r2)
 d04b0d4:	1004d43a 	srli	r2,r2,16
 d04b0d8:	10c03fcc 	andi	r3,r2,255
 d04b0dc:	e0bff617 	ldw	r2,-40(fp)
 d04b0e0:	10800617 	ldw	r2,24(r2)
 d04b0e4:	1004d63a 	srli	r2,r2,24
 d04b0e8:	d8c00015 	stw	r3,0(sp)
 d04b0ec:	d8800115 	stw	r2,4(sp)
 d04b0f0:	01034174 	movhi	r4,3333
 d04b0f4:	21095a04 	addi	r4,r4,9576
 d04b0f8:	d0028a00 	call	d0028a0 <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d04b0fc:	e0bffb17 	ldw	r2,-20(fp)
 d04b100:	11403fcc 	andi	r5,r2,255
 d04b104:	e0bffb17 	ldw	r2,-20(fp)
 d04b108:	1004d23a 	srli	r2,r2,8
 d04b10c:	11803fcc 	andi	r6,r2,255
 d04b110:	e0bffb17 	ldw	r2,-20(fp)
 d04b114:	1004d43a 	srli	r2,r2,16
 d04b118:	11c03fcc 	andi	r7,r2,255
 d04b11c:	e0bffb17 	ldw	r2,-20(fp)
 d04b120:	1004d63a 	srli	r2,r2,24
 d04b124:	d8800015 	stw	r2,0(sp)
 d04b128:	01034174 	movhi	r4,3333
 d04b12c:	21095f04 	addi	r4,r4,9596
 d04b130:	d0028a00 	call	d0028a0 <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 d04b134:	e13ffd17 	ldw	r4,-12(fp)
 d04b138:	e17ff617 	ldw	r5,-40(fp)
 d04b13c:	d04bd480 	call	d04bd48 <icmp_du>
      break;
 d04b140:	00015606 	br	d04b69c <icmprcv+0xc0c>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 d04b144:	008341b4 	movhi	r2,3334
 d04b148:	10858604 	addi	r2,r2,5656
 d04b14c:	10800517 	ldw	r2,20(r2)
 d04b150:	10c00044 	addi	r3,r2,1
 d04b154:	008341b4 	movhi	r2,3334
 d04b158:	10858604 	addi	r2,r2,5656
 d04b15c:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b160:	00834174 	movhi	r2,3333
 d04b164:	109b2004 	addi	r2,r2,27776
 d04b168:	10800017 	ldw	r2,0(r2)
 d04b16c:	1081000c 	andi	r2,r2,1024
 d04b170:	1005003a 	cmpeq	r2,r2,zero
 d04b174:	1000161e 	bne	r2,zero,d04b1d0 <icmprcv+0x740>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d04b178:	e0bffb17 	ldw	r2,-20(fp)
 d04b17c:	11403fcc 	andi	r5,r2,255
 d04b180:	e0bffb17 	ldw	r2,-20(fp)
 d04b184:	1004d23a 	srli	r2,r2,8
 d04b188:	11803fcc 	andi	r6,r2,255
 d04b18c:	e0bffb17 	ldw	r2,-20(fp)
 d04b190:	1004d43a 	srli	r2,r2,16
 d04b194:	11c03fcc 	andi	r7,r2,255
 d04b198:	e0bffb17 	ldw	r2,-20(fp)
 d04b19c:	1004d63a 	srli	r2,r2,24
 d04b1a0:	d8800015 	stw	r2,0(sp)
 d04b1a4:	01034174 	movhi	r4,3333
 d04b1a8:	21096404 	addi	r4,r4,9616
 d04b1ac:	d0028a00 	call	d0028a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d04b1b0:	00834174 	movhi	r2,3333
 d04b1b4:	109b2004 	addi	r2,r2,27776
 d04b1b8:	10800017 	ldw	r2,0(r2)
 d04b1bc:	1080008c 	andi	r2,r2,2
 d04b1c0:	1005003a 	cmpeq	r2,r2,zero
 d04b1c4:	1000021e 	bne	r2,zero,d04b1d0 <icmprcv+0x740>
 d04b1c8:	e13ffd17 	ldw	r4,-12(fp)
 d04b1cc:	d0404b00 	call	d0404b0 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d04b1d0:	01000084 	movi	r4,2
 d04b1d4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04b1d8:	e13ffd17 	ldw	r4,-12(fp)
 d04b1dc:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04b1e0:	01000084 	movi	r4,2
 d04b1e4:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      break;
 d04b1e8:	00012c06 	br	d04b69c <icmprcv+0xc0c>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 d04b1ec:	008341b4 	movhi	r2,3334
 d04b1f0:	10858604 	addi	r2,r2,5656
 d04b1f4:	10800617 	ldw	r2,24(r2)
 d04b1f8:	10c00044 	addi	r3,r2,1
 d04b1fc:	008341b4 	movhi	r2,3334
 d04b200:	10858604 	addi	r2,r2,5656
 d04b204:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 d04b208:	e0bff917 	ldw	r2,-28(fp)
 d04b20c:	e0bff715 	stw	r2,-36(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b210:	00834174 	movhi	r2,3333
 d04b214:	109b2004 	addi	r2,r2,27776
 d04b218:	10800017 	ldw	r2,0(r2)
 d04b21c:	1081000c 	andi	r2,r2,1024
 d04b220:	1005003a 	cmpeq	r2,r2,zero
 d04b224:	1000241e 	bne	r2,zero,d04b2b8 <icmprcv+0x828>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 d04b228:	e0bff717 	ldw	r2,-36(fp)
 d04b22c:	10800617 	ldw	r2,24(r2)
 d04b230:	11403fcc 	andi	r5,r2,255
 d04b234:	e0bff717 	ldw	r2,-36(fp)
 d04b238:	10800617 	ldw	r2,24(r2)
 d04b23c:	1004d23a 	srli	r2,r2,8
 d04b240:	11803fcc 	andi	r6,r2,255
 d04b244:	e0bff717 	ldw	r2,-36(fp)
 d04b248:	10800617 	ldw	r2,24(r2)
 d04b24c:	1004d43a 	srli	r2,r2,16
 d04b250:	11c03fcc 	andi	r7,r2,255
 d04b254:	e0bff717 	ldw	r2,-36(fp)
 d04b258:	10800617 	ldw	r2,24(r2)
 d04b25c:	1004d63a 	srli	r2,r2,24
 d04b260:	d8800015 	stw	r2,0(sp)
 d04b264:	01034174 	movhi	r4,3333
 d04b268:	21096e04 	addi	r4,r4,9656
 d04b26c:	d0028a00 	call	d0028a0 <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 d04b270:	e0bff717 	ldw	r2,-36(fp)
 d04b274:	10800117 	ldw	r2,4(r2)
 d04b278:	11403fcc 	andi	r5,r2,255
 d04b27c:	e0bff717 	ldw	r2,-36(fp)
 d04b280:	10800117 	ldw	r2,4(r2)
 d04b284:	1004d23a 	srli	r2,r2,8
 d04b288:	11803fcc 	andi	r6,r2,255
 d04b28c:	e0bff717 	ldw	r2,-36(fp)
 d04b290:	10800117 	ldw	r2,4(r2)
 d04b294:	1004d43a 	srli	r2,r2,16
 d04b298:	11c03fcc 	andi	r7,r2,255
 d04b29c:	e0bff717 	ldw	r2,-36(fp)
 d04b2a0:	10800117 	ldw	r2,4(r2)
 d04b2a4:	1004d63a 	srli	r2,r2,24
 d04b2a8:	d8800015 	stw	r2,0(sp)
 d04b2ac:	01034174 	movhi	r4,3333
 d04b2b0:	21097804 	addi	r4,r4,9696
 d04b2b4:	d0028a00 	call	d0028a0 <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 d04b2b8:	e0bff717 	ldw	r2,-36(fp)
 d04b2bc:	14000617 	ldw	r16,24(r2)
 d04b2c0:	e0bff717 	ldw	r2,-36(fp)
 d04b2c4:	14400117 	ldw	r17,4(r2)
 d04b2c8:	e0bffd17 	ldw	r2,-12(fp)
 d04b2cc:	11000617 	ldw	r4,24(r2)
 d04b2d0:	d01e88c0 	call	d01e88c <if_netnumber>
 d04b2d4:	100f883a 	mov	r7,r2
 d04b2d8:	00800104 	movi	r2,4
 d04b2dc:	d8800015 	stw	r2,0(sp)
 d04b2e0:	8009883a 	mov	r4,r16
 d04b2e4:	017fffc4 	movi	r5,-1
 d04b2e8:	880d883a 	mov	r6,r17
 d04b2ec:	d0441980 	call	d044198 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d04b2f0:	01000084 	movi	r4,2
 d04b2f4:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04b2f8:	e13ffd17 	ldw	r4,-12(fp)
 d04b2fc:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04b300:	01000084 	movi	r4,2
 d04b304:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      break;
 d04b308:	0000e406 	br	d04b69c <icmprcv+0xc0c>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 d04b30c:	008341b4 	movhi	r2,3334
 d04b310:	10858604 	addi	r2,r2,5656
 d04b314:	10800317 	ldw	r2,12(r2)
 d04b318:	10c00044 	addi	r3,r2,1
 d04b31c:	008341b4 	movhi	r2,3334
 d04b320:	10858604 	addi	r2,r2,5656
 d04b324:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b328:	00834174 	movhi	r2,3333
 d04b32c:	109b2004 	addi	r2,r2,27776
 d04b330:	10800017 	ldw	r2,0(r2)
 d04b334:	1081000c 	andi	r2,r2,1024
 d04b338:	1005003a 	cmpeq	r2,r2,zero
 d04b33c:	10002e1e 	bne	r2,zero,d04b3f8 <icmprcv+0x968>
      {
         struct timex * pt =  (struct  timex *)e;
 d04b340:	e0bff917 	ldw	r2,-28(fp)
 d04b344:	e0bff315 	stw	r2,-52(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 d04b348:	e0bffd17 	ldw	r2,-12(fp)
 d04b34c:	10800717 	ldw	r2,28(r2)
 d04b350:	11403fcc 	andi	r5,r2,255
 d04b354:	e0bffd17 	ldw	r2,-12(fp)
 d04b358:	10800717 	ldw	r2,28(r2)
 d04b35c:	1004d23a 	srli	r2,r2,8
 d04b360:	11803fcc 	andi	r6,r2,255
 d04b364:	e0bffd17 	ldw	r2,-12(fp)
 d04b368:	10800717 	ldw	r2,28(r2)
 d04b36c:	1004d43a 	srli	r2,r2,16
 d04b370:	11c03fcc 	andi	r7,r2,255
 d04b374:	e0bffd17 	ldw	r2,-12(fp)
 d04b378:	10800717 	ldw	r2,28(r2)
 d04b37c:	1004d63a 	srli	r2,r2,24
 d04b380:	d8800015 	stw	r2,0(sp)
 d04b384:	01034174 	movhi	r4,3333
 d04b388:	21097c04 	addi	r4,r4,9712
 d04b38c:	d0028a00 	call	d0028a0 <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 d04b390:	e0bff317 	ldw	r2,-52(fp)
 d04b394:	10800617 	ldw	r2,24(r2)
 d04b398:	11403fcc 	andi	r5,r2,255
 d04b39c:	e0bff317 	ldw	r2,-52(fp)
 d04b3a0:	10800617 	ldw	r2,24(r2)
 d04b3a4:	1004d23a 	srli	r2,r2,8
 d04b3a8:	11803fcc 	andi	r6,r2,255
 d04b3ac:	e0bff317 	ldw	r2,-52(fp)
 d04b3b0:	10800617 	ldw	r2,24(r2)
 d04b3b4:	1004d43a 	srli	r2,r2,16
 d04b3b8:	11c03fcc 	andi	r7,r2,255
 d04b3bc:	e0bff317 	ldw	r2,-52(fp)
 d04b3c0:	10800617 	ldw	r2,24(r2)
 d04b3c4:	1004d63a 	srli	r2,r2,24
 d04b3c8:	d8800015 	stw	r2,0(sp)
 d04b3cc:	01034174 	movhi	r4,3333
 d04b3d0:	21098504 	addi	r4,r4,9748
 d04b3d4:	d0028a00 	call	d0028a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d04b3d8:	00834174 	movhi	r2,3333
 d04b3dc:	109b2004 	addi	r2,r2,27776
 d04b3e0:	10800017 	ldw	r2,0(r2)
 d04b3e4:	1080008c 	andi	r2,r2,2
 d04b3e8:	1005003a 	cmpeq	r2,r2,zero
 d04b3ec:	1000021e 	bne	r2,zero,d04b3f8 <icmprcv+0x968>
 d04b3f0:	e13ffd17 	ldw	r4,-12(fp)
 d04b3f4:	d0404b00 	call	d0404b0 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d04b3f8:	01000084 	movi	r4,2
 d04b3fc:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04b400:	e13ffd17 	ldw	r4,-12(fp)
 d04b404:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04b408:	01000084 	movi	r4,2
 d04b40c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      break;
 d04b410:	0000a206 	br	d04b69c <icmprcv+0xc0c>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 d04b414:	008341b4 	movhi	r2,3334
 d04b418:	10858604 	addi	r2,r2,5656
 d04b41c:	10800417 	ldw	r2,16(r2)
 d04b420:	10c00044 	addi	r3,r2,1
 d04b424:	008341b4 	movhi	r2,3334
 d04b428:	10858604 	addi	r2,r2,5656
 d04b42c:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b430:	00834174 	movhi	r2,3333
 d04b434:	109b2004 	addi	r2,r2,27776
 d04b438:	10800017 	ldw	r2,0(r2)
 d04b43c:	1081000c 	andi	r2,r2,1024
 d04b440:	1005003a 	cmpeq	r2,r2,zero
 d04b444:	1000031e 	bne	r2,zero,d04b454 <icmprcv+0x9c4>
         dprintf("ICMP: got param problem message\n");
 d04b448:	01034174 	movhi	r4,3333
 d04b44c:	21098a04 	addi	r4,r4,9768
 d04b450:	d002bc80 	call	d002bc8 <puts>
      if (NDEBUG & DUMP)
 d04b454:	00834174 	movhi	r2,3333
 d04b458:	109b2004 	addi	r2,r2,27776
 d04b45c:	10800017 	ldw	r2,0(r2)
 d04b460:	1080008c 	andi	r2,r2,2
 d04b464:	1005003a 	cmpeq	r2,r2,zero
 d04b468:	1000021e 	bne	r2,zero,d04b474 <icmprcv+0x9e4>
      {
         ip_dump(p);
 d04b46c:	e13ffd17 	ldw	r4,-12(fp)
 d04b470:	d0404b00 	call	d0404b0 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d04b474:	01000084 	movi	r4,2
 d04b478:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04b47c:	e13ffd17 	ldw	r4,-12(fp)
 d04b480:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04b484:	01000084 	movi	r4,2
 d04b488:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      break;
 d04b48c:	00008306 	br	d04b69c <icmprcv+0xc0c>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 d04b490:	008341b4 	movhi	r2,3334
 d04b494:	10858604 	addi	r2,r2,5656
 d04b498:	10800917 	ldw	r2,36(r2)
 d04b49c:	10c00044 	addi	r3,r2,1
 d04b4a0:	008341b4 	movhi	r2,3334
 d04b4a4:	10858604 	addi	r2,r2,5656
 d04b4a8:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b4ac:	00834174 	movhi	r2,3333
 d04b4b0:	109b2004 	addi	r2,r2,27776
 d04b4b4:	10800017 	ldw	r2,0(r2)
 d04b4b8:	1081000c 	andi	r2,r2,1024
 d04b4bc:	1005003a 	cmpeq	r2,r2,zero
 d04b4c0:	1000031e 	bne	r2,zero,d04b4d0 <icmprcv+0xa40>
         dprintf("ICMP: got timestamp request\n");
 d04b4c4:	01034174 	movhi	r4,3333
 d04b4c8:	21099204 	addi	r4,r4,9800
 d04b4cc:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 d04b4d0:	e0fff917 	ldw	r3,-28(fp)
 d04b4d4:	00800384 	movi	r2,14
 d04b4d8:	18800005 	stb	r2,0(r3)
      e->pchksum = 0;
 d04b4dc:	e0bff917 	ldw	r2,-28(fp)
 d04b4e0:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 d04b4e4:	e13ff917 	ldw	r4,-28(fp)
 d04b4e8:	01400284 	movi	r5,10
 d04b4ec:	d0205440 	call	d020544 <cksum>
 d04b4f0:	0084303a 	nor	r2,zero,r2
 d04b4f4:	1007883a 	mov	r3,r2
 d04b4f8:	e0bff917 	ldw	r2,-28(fp)
 d04b4fc:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 d04b500:	e0bffa17 	ldw	r2,-24(fp)
 d04b504:	10c00417 	ldw	r3,16(r2)
 d04b508:	e0bffa17 	ldw	r2,-24(fp)
 d04b50c:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 d04b510:	e0fffa17 	ldw	r3,-24(fp)
 d04b514:	e0bffb17 	ldw	r2,-20(fp)
 d04b518:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutMsgs++;
 d04b51c:	008341b4 	movhi	r2,3334
 d04b520:	10858604 	addi	r2,r2,5656
 d04b524:	10800d17 	ldw	r2,52(r2)
 d04b528:	10c00044 	addi	r3,r2,1
 d04b52c:	008341b4 	movhi	r2,3334
 d04b530:	10858604 	addi	r2,r2,5656
 d04b534:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 d04b538:	008341b4 	movhi	r2,3334
 d04b53c:	10858604 	addi	r2,r2,5656
 d04b540:	10801717 	ldw	r2,92(r2)
 d04b544:	10c00044 	addi	r3,r2,1
 d04b548:	008341b4 	movhi	r2,3334
 d04b54c:	10858604 	addi	r2,r2,5656
 d04b550:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 d04b554:	e0bffd17 	ldw	r2,-12(fp)
 d04b558:	10c00317 	ldw	r3,12(r2)
 d04b55c:	e0bffa17 	ldw	r2,-24(fp)
 d04b560:	10800003 	ldbu	r2,0(r2)
 d04b564:	10803fcc 	andi	r2,r2,255
 d04b568:	108003cc 	andi	r2,r2,15
 d04b56c:	1085883a 	add	r2,r2,r2
 d04b570:	1085883a 	add	r2,r2,r2
 d04b574:	1887883a 	add	r3,r3,r2
 d04b578:	e0bffd17 	ldw	r2,-12(fp)
 d04b57c:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 d04b580:	e0fffd17 	ldw	r3,-12(fp)
 d04b584:	00800504 	movi	r2,20
 d04b588:	18800415 	stw	r2,16(r3)
      p->fhost = host;
 d04b58c:	e0fffd17 	ldw	r3,-12(fp)
 d04b590:	e0bffb17 	ldw	r2,-20(fp)
 d04b594:	18800715 	stw	r2,28(r3)
      i = ip_write(ICMP_PROT, p);
 d04b598:	01000044 	movi	r4,1
 d04b59c:	e17ffd17 	ldw	r5,-12(fp)
 d04b5a0:	d03f2780 	call	d03f278 <ip_write>
 d04b5a4:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 d04b5a8:	e0bff417 	ldw	r2,-48(fp)
 d04b5ac:	1004403a 	cmpge	r2,r2,zero
 d04b5b0:	1000091e 	bne	r2,zero,d04b5d8 <icmprcv+0xb48>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 d04b5b4:	00834174 	movhi	r2,3333
 d04b5b8:	109b2004 	addi	r2,r2,27776
 d04b5bc:	10800017 	ldw	r2,0(r2)
 d04b5c0:	1081000c 	andi	r2,r2,1024
 d04b5c4:	1005003a 	cmpeq	r2,r2,zero
 d04b5c8:	1000031e 	bne	r2,zero,d04b5d8 <icmprcv+0xb48>
            dprintf("icmp: can't send timestamp reply\n");
 d04b5cc:	01034174 	movhi	r4,3333
 d04b5d0:	21099904 	addi	r4,r4,9828
 d04b5d4:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 d04b5d8:	e03fff15 	stw	zero,-4(fp)
 d04b5dc:	00003106 	br	d04b6a4 <icmprcv+0xc14>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b5e0:	00834174 	movhi	r2,3333
 d04b5e4:	109b2004 	addi	r2,r2,27776
 d04b5e8:	10800017 	ldw	r2,0(r2)
 d04b5ec:	1081000c 	andi	r2,r2,1024
 d04b5f0:	1005003a 	cmpeq	r2,r2,zero
 d04b5f4:	1000031e 	bne	r2,zero,d04b604 <icmprcv+0xb74>
         dprintf("icmp: got info request\n");
 d04b5f8:	01034174 	movhi	r4,3333
 d04b5fc:	2109a204 	addi	r4,r4,9864
 d04b600:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d04b604:	01000084 	movi	r4,2
 d04b608:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04b60c:	e13ffd17 	ldw	r4,-12(fp)
 d04b610:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04b614:	01000084 	movi	r4,2
 d04b618:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      break;
 d04b61c:	00001f06 	br	d04b69c <icmprcv+0xc0c>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04b620:	00834174 	movhi	r2,3333
 d04b624:	109b2004 	addi	r2,r2,27776
 d04b628:	10800017 	ldw	r2,0(r2)
 d04b62c:	1081000c 	andi	r2,r2,1024
 d04b630:	1005003a 	cmpeq	r2,r2,zero
 d04b634:	1000101e 	bne	r2,zero,d04b678 <icmprcv+0xbe8>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 d04b638:	e0bff917 	ldw	r2,-28(fp)
 d04b63c:	10800003 	ldbu	r2,0(r2)
 d04b640:	11403fcc 	andi	r5,r2,255
 d04b644:	2940201c 	xori	r5,r5,128
 d04b648:	297fe004 	addi	r5,r5,-128
 d04b64c:	01034174 	movhi	r4,3333
 d04b650:	2109a804 	addi	r4,r4,9888
 d04b654:	d0028a00 	call	d0028a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d04b658:	00834174 	movhi	r2,3333
 d04b65c:	109b2004 	addi	r2,r2,27776
 d04b660:	10800017 	ldw	r2,0(r2)
 d04b664:	1080008c 	andi	r2,r2,2
 d04b668:	1005003a 	cmpeq	r2,r2,zero
 d04b66c:	1000021e 	bne	r2,zero,d04b678 <icmprcv+0xbe8>
 d04b670:	e13ffd17 	ldw	r4,-12(fp)
 d04b674:	d0404b00 	call	d0404b0 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d04b678:	01000084 	movi	r4,2
 d04b67c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04b680:	e13ffd17 	ldw	r4,-12(fp)
 d04b684:	d0251a00 	call	d0251a0 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04b688:	01000084 	movi	r4,2
 d04b68c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 d04b690:	00800084 	movi	r2,2
 d04b694:	e0bfff15 	stw	r2,-4(fp)
 d04b698:	00000206 	br	d04b6a4 <icmprcv+0xc14>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 d04b69c:	00c00084 	movi	r3,2
 d04b6a0:	e0ffff15 	stw	r3,-4(fp)
 d04b6a4:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* FULL_ICMP */
}
 d04b6a8:	e037883a 	mov	sp,fp
 d04b6ac:	dfc00317 	ldw	ra,12(sp)
 d04b6b0:	df000217 	ldw	fp,8(sp)
 d04b6b4:	dc400117 	ldw	r17,4(sp)
 d04b6b8:	dc000017 	ldw	r16,0(sp)
 d04b6bc:	dec00404 	addi	sp,sp,16
 d04b6c0:	f800283a 	ret

0d04b6c4 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 d04b6c4:	defff404 	addi	sp,sp,-48
 d04b6c8:	dfc00b15 	stw	ra,44(sp)
 d04b6cc:	df000a15 	stw	fp,40(sp)
 d04b6d0:	df000a04 	addi	fp,sp,40
 d04b6d4:	e13ffc15 	stw	r4,-16(fp)
 d04b6d8:	e17ffd15 	stw	r5,-12(fp)
 d04b6dc:	e1bffe15 	stw	r6,-8(fp)
 d04b6e0:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 d04b6e4:	00834174 	movhi	r2,3333
 d04b6e8:	109b2004 	addi	r2,r2,27776
 d04b6ec:	10800017 	ldw	r2,0(r2)
 d04b6f0:	1080040c 	andi	r2,r2,16
 d04b6f4:	1005003a 	cmpeq	r2,r2,zero
 d04b6f8:	1000171e 	bne	r2,zero,d04b758 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 d04b6fc:	e0bfff17 	ldw	r2,-4(fp)
 d04b700:	10803fcc 	andi	r2,r2,255
 d04b704:	00c34174 	movhi	r3,3333
 d04b708:	18d21904 	addi	r3,r3,18532
 d04b70c:	1085883a 	add	r2,r2,r2
 d04b710:	1085883a 	add	r2,r2,r2
 d04b714:	10c5883a 	add	r2,r2,r3
 d04b718:	11400017 	ldw	r5,0(r2)
 d04b71c:	e0bffc17 	ldw	r2,-16(fp)
 d04b720:	11803fcc 	andi	r6,r2,255
 d04b724:	e0bffc17 	ldw	r2,-16(fp)
 d04b728:	1004d23a 	srli	r2,r2,8
 d04b72c:	11c03fcc 	andi	r7,r2,255
 d04b730:	e0bffc17 	ldw	r2,-16(fp)
 d04b734:	1004d43a 	srli	r2,r2,16
 d04b738:	10c03fcc 	andi	r3,r2,255
 d04b73c:	e0bffc17 	ldw	r2,-16(fp)
 d04b740:	1004d63a 	srli	r2,r2,24
 d04b744:	d8c00015 	stw	r3,0(sp)
 d04b748:	d8800115 	stw	r2,4(sp)
 d04b74c:	01034174 	movhi	r4,3333
 d04b750:	2109c204 	addi	r4,r4,9992
 d04b754:	d0028a00 	call	d0028a0 <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d04b758:	01000084 	movi	r4,2
 d04b75c:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 d04b760:	01008504 	movi	r4,532
 d04b764:	d024e0c0 	call	d024e0c <pk_alloc>
 d04b768:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04b76c:	01000084 	movi	r4,2
 d04b770:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 d04b774:	e0bffb17 	ldw	r2,-20(fp)
 d04b778:	1004c03a 	cmpne	r2,r2,zero
 d04b77c:	1000111e 	bne	r2,zero,d04b7c4 <icmp_destun+0x100>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 d04b780:	00834174 	movhi	r2,3333
 d04b784:	109b2004 	addi	r2,r2,27776
 d04b788:	10800017 	ldw	r2,0(r2)
 d04b78c:	1080800c 	andi	r2,r2,512
 d04b790:	1005003a 	cmpeq	r2,r2,zero
 d04b794:	1000031e 	bne	r2,zero,d04b7a4 <icmp_destun+0xe0>
         dprintf("icmp: can't alloc pkt\n");
 d04b798:	01034174 	movhi	r4,3333
 d04b79c:	2109cf04 	addi	r4,r4,10044
 d04b7a0:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 d04b7a4:	008341b4 	movhi	r2,3334
 d04b7a8:	10858604 	addi	r2,r2,5656
 d04b7ac:	10800e17 	ldw	r2,56(r2)
 d04b7b0:	10c00044 	addi	r3,r2,1
 d04b7b4:	008341b4 	movhi	r2,3334
 d04b7b8:	10858604 	addi	r2,r2,5656
 d04b7bc:	10c00e15 	stw	r3,56(r2)
      return;
 d04b7c0:	00008f06 	br	d04ba00 <icmp_destun+0x33c>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 d04b7c4:	e0bffb17 	ldw	r2,-20(fp)
 d04b7c8:	10800317 	ldw	r2,12(r2)
 d04b7cc:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 d04b7d0:	e0fff917 	ldw	r3,-28(fp)
 d04b7d4:	e0bffd17 	ldw	r2,-12(fp)
 d04b7d8:	18800315 	stw	r2,12(r3)
   pip->ip_dest = host;
 d04b7dc:	e0fff917 	ldw	r3,-28(fp)
 d04b7e0:	e0bffc17 	ldw	r2,-16(fp)
 d04b7e4:	18800415 	stw	r2,16(r3)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 d04b7e8:	e0bffb17 	ldw	r2,-20(fp)
 d04b7ec:	10800317 	ldw	r2,12(r2)
 d04b7f0:	10c00504 	addi	r3,r2,20
 d04b7f4:	e0bffb17 	ldw	r2,-20(fp)
 d04b7f8:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 d04b7fc:	e0bffb17 	ldw	r2,-20(fp)
 d04b800:	10800417 	ldw	r2,16(r2)
 d04b804:	10fffb04 	addi	r3,r2,-20
 d04b808:	e0bffb17 	ldw	r2,-20(fp)
 d04b80c:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 d04b810:	e0fffb17 	ldw	r3,-20(fp)
 d04b814:	e0800217 	ldw	r2,8(fp)
 d04b818:	18800615 	stw	r2,24(r3)

   d = (struct destun *)p->nb_prot;
 d04b81c:	e0bffb17 	ldw	r2,-20(fp)
 d04b820:	10800317 	ldw	r2,12(r2)
 d04b824:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 d04b828:	e0bfff17 	ldw	r2,-4(fp)
 d04b82c:	10bfc00c 	andi	r2,r2,65280
 d04b830:	1005003a 	cmpeq	r2,r2,zero
 d04b834:	1000061e 	bne	r2,zero,d04b850 <icmp_destun+0x18c>
      d->dtype = (char)(typecode >>8);  /* then use it */
 d04b838:	e0bfff17 	ldw	r2,-4(fp)
 d04b83c:	1004d23a 	srli	r2,r2,8
 d04b840:	1007883a 	mov	r3,r2
 d04b844:	e0bffa17 	ldw	r2,-24(fp)
 d04b848:	10c00005 	stb	r3,0(r2)
 d04b84c:	00000306 	br	d04b85c <icmp_destun+0x198>
   else                                 /* else use default */
      d->dtype = DESTIN;
 d04b850:	e0fffa17 	ldw	r3,-24(fp)
 d04b854:	008000c4 	movi	r2,3
 d04b858:	18800005 	stb	r2,0(r3)
   d->dcode = (char)(typecode & 0xFF);
 d04b85c:	e0bfff17 	ldw	r2,-4(fp)
 d04b860:	1007883a 	mov	r3,r2
 d04b864:	e0bffa17 	ldw	r2,-24(fp)
 d04b868:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 d04b86c:	e0bffa17 	ldw	r2,-24(fp)
 d04b870:	1000018d 	sth	zero,6(r2)
 d04b874:	e0bffa17 	ldw	r2,-24(fp)
 d04b878:	10c0018b 	ldhu	r3,6(r2)
 d04b87c:	e0bffa17 	ldw	r2,-24(fp)
 d04b880:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 d04b884:	e0bfff17 	ldw	r2,-4(fp)
 d04b888:	10803fcc 	andi	r2,r2,255
 d04b88c:	10800118 	cmpnei	r2,r2,4
 d04b890:	1000151e 	bne	r2,zero,d04b8e8 <icmp_destun+0x224>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 d04b894:	e0800217 	ldw	r2,8(fp)
 d04b898:	10c00917 	ldw	r3,36(r2)
 d04b89c:	e0800217 	ldw	r2,8(fp)
 d04b8a0:	10800817 	ldw	r2,32(r2)
 d04b8a4:	1885c83a 	sub	r2,r3,r2
 d04b8a8:	1005d23a 	srai	r2,r2,8
 d04b8ac:	10803fcc 	andi	r2,r2,255
 d04b8b0:	1009883a 	mov	r4,r2
 d04b8b4:	e0800217 	ldw	r2,8(fp)
 d04b8b8:	10c00917 	ldw	r3,36(r2)
 d04b8bc:	e0800217 	ldw	r2,8(fp)
 d04b8c0:	10800817 	ldw	r2,32(r2)
 d04b8c4:	1885c83a 	sub	r2,r3,r2
 d04b8c8:	1004923a 	slli	r2,r2,8
 d04b8cc:	1007883a 	mov	r3,r2
 d04b8d0:	00bfc004 	movi	r2,-256
 d04b8d4:	1884703a 	and	r2,r3,r2
 d04b8d8:	2084b03a 	or	r2,r4,r2
 d04b8dc:	1007883a 	mov	r3,r2
 d04b8e0:	e0bffa17 	ldw	r2,-24(fp)
 d04b8e4:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 d04b8e8:	e0bffa17 	ldw	r2,-24(fp)
 d04b8ec:	11000204 	addi	r4,r2,8
 d04b8f0:	e0fffe17 	ldw	r3,-8(fp)
 d04b8f4:	18800017 	ldw	r2,0(r3)
 d04b8f8:	20800015 	stw	r2,0(r4)
 d04b8fc:	18800117 	ldw	r2,4(r3)
 d04b900:	20800115 	stw	r2,4(r4)
 d04b904:	18800217 	ldw	r2,8(r3)
 d04b908:	20800215 	stw	r2,8(r4)
 d04b90c:	18800317 	ldw	r2,12(r3)
 d04b910:	20800315 	stw	r2,12(r4)
 d04b914:	18800417 	ldw	r2,16(r3)
 d04b918:	20800415 	stw	r2,16(r4)
 d04b91c:	18800517 	ldw	r2,20(r3)
 d04b920:	20800515 	stw	r2,20(r4)
 d04b924:	18800617 	ldw	r2,24(r3)
 d04b928:	20800615 	stw	r2,24(r4)

   d->dchksum = 0;
 d04b92c:	e0bffa17 	ldw	r2,-24(fp)
 d04b930:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 d04b934:	e13ffa17 	ldw	r4,-24(fp)
 d04b938:	01400484 	movi	r5,18
 d04b93c:	d0205440 	call	d020544 <cksum>
 d04b940:	0084303a 	nor	r2,zero,r2
 d04b944:	1007883a 	mov	r3,r2
 d04b948:	e0bffa17 	ldw	r2,-24(fp)
 d04b94c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 d04b950:	e0fffb17 	ldw	r3,-20(fp)
 d04b954:	00800904 	movi	r2,36
 d04b958:	18800415 	stw	r2,16(r3)
   p->fhost = host;
 d04b95c:	e0fffb17 	ldw	r3,-20(fp)
 d04b960:	e0bffc17 	ldw	r2,-16(fp)
 d04b964:	18800715 	stw	r2,28(r3)
   i = ip_write(ICMP_PROT, p);
 d04b968:	01000044 	movi	r4,1
 d04b96c:	e17ffb17 	ldw	r5,-20(fp)
 d04b970:	d03f2780 	call	d03f278 <ip_write>
 d04b974:	e0bff815 	stw	r2,-32(fp)
   if (i < 0)
 d04b978:	e0bff817 	ldw	r2,-32(fp)
 d04b97c:	1004403a 	cmpge	r2,r2,zero
 d04b980:	1000111e 	bne	r2,zero,d04b9c8 <icmp_destun+0x304>
   {
      icmp_mib.icmpOutErrors++;
 d04b984:	008341b4 	movhi	r2,3334
 d04b988:	10858604 	addi	r2,r2,5656
 d04b98c:	10800e17 	ldw	r2,56(r2)
 d04b990:	10c00044 	addi	r3,r2,1
 d04b994:	008341b4 	movhi	r2,3334
 d04b998:	10858604 	addi	r2,r2,5656
 d04b99c:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 d04b9a0:	00834174 	movhi	r2,3333
 d04b9a4:	109b2004 	addi	r2,r2,27776
 d04b9a8:	10800017 	ldw	r2,0(r2)
 d04b9ac:	1080860c 	andi	r2,r2,536
 d04b9b0:	1005003a 	cmpeq	r2,r2,zero
 d04b9b4:	1000121e 	bne	r2,zero,d04ba00 <icmp_destun+0x33c>
         dprintf("ICMP: Can't send dest unreachable\n");
 d04b9b8:	01034174 	movhi	r4,3333
 d04b9bc:	2109d504 	addi	r4,r4,10068
 d04b9c0:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG  */
      return;
 d04b9c4:	00000e06 	br	d04ba00 <icmp_destun+0x33c>
   }
   icmp_mib.icmpOutMsgs++;
 d04b9c8:	008341b4 	movhi	r2,3334
 d04b9cc:	10858604 	addi	r2,r2,5656
 d04b9d0:	10800d17 	ldw	r2,52(r2)
 d04b9d4:	10c00044 	addi	r3,r2,1
 d04b9d8:	008341b4 	movhi	r2,3334
 d04b9dc:	10858604 	addi	r2,r2,5656
 d04b9e0:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 d04b9e4:	008341b4 	movhi	r2,3334
 d04b9e8:	10858604 	addi	r2,r2,5656
 d04b9ec:	10800f17 	ldw	r2,60(r2)
 d04b9f0:	10c00044 	addi	r3,r2,1
 d04b9f4:	008341b4 	movhi	r2,3334
 d04b9f8:	10858604 	addi	r2,r2,5656
 d04b9fc:	10c00f15 	stw	r3,60(r2)
   return;
}
 d04ba00:	e037883a 	mov	sp,fp
 d04ba04:	dfc00117 	ldw	ra,4(sp)
 d04ba08:	df000017 	ldw	fp,0(sp)
 d04ba0c:	dec00204 	addi	sp,sp,8
 d04ba10:	f800283a 	ret

0d04ba14 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 d04ba14:	defff504 	addi	sp,sp,-44
 d04ba18:	dfc00a15 	stw	ra,40(sp)
 d04ba1c:	df000915 	stw	fp,36(sp)
 d04ba20:	df000904 	addi	fp,sp,36
 d04ba24:	e13ffe15 	stw	r4,-8(fp)
 d04ba28:	e17fff05 	stb	r5,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 d04ba2c:	00834174 	movhi	r2,3333
 d04ba30:	109b2004 	addi	r2,r2,27776
 d04ba34:	10800017 	ldw	r2,0(r2)
 d04ba38:	1080040c 	andi	r2,r2,16
 d04ba3c:	1005003a 	cmpeq	r2,r2,zero
 d04ba40:	1000301e 	bne	r2,zero,d04bb04 <icmp_timex+0xf0>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 d04ba44:	e17fff07 	ldb	r5,-4(fp)
 d04ba48:	e0bffe17 	ldw	r2,-8(fp)
 d04ba4c:	10800317 	ldw	r2,12(r2)
 d04ba50:	1004d23a 	srli	r2,r2,8
 d04ba54:	10c03fcc 	andi	r3,r2,255
 d04ba58:	e0bffe17 	ldw	r2,-8(fp)
 d04ba5c:	10800317 	ldw	r2,12(r2)
 d04ba60:	1004923a 	slli	r2,r2,8
 d04ba64:	10bfc00c 	andi	r2,r2,65280
 d04ba68:	1884b03a 	or	r2,r3,r2
 d04ba6c:	11803fcc 	andi	r6,r2,255
 d04ba70:	e0bffe17 	ldw	r2,-8(fp)
 d04ba74:	10800317 	ldw	r2,12(r2)
 d04ba78:	1004d23a 	srli	r2,r2,8
 d04ba7c:	10c03fcc 	andi	r3,r2,255
 d04ba80:	e0bffe17 	ldw	r2,-8(fp)
 d04ba84:	10800317 	ldw	r2,12(r2)
 d04ba88:	1004923a 	slli	r2,r2,8
 d04ba8c:	10bfc00c 	andi	r2,r2,65280
 d04ba90:	1884b03a 	or	r2,r3,r2
 d04ba94:	1004d23a 	srli	r2,r2,8
 d04ba98:	11c03fcc 	andi	r7,r2,255
 d04ba9c:	e0bffe17 	ldw	r2,-8(fp)
 d04baa0:	10800317 	ldw	r2,12(r2)
 d04baa4:	1004d23a 	srli	r2,r2,8
 d04baa8:	10c03fcc 	andi	r3,r2,255
 d04baac:	e0bffe17 	ldw	r2,-8(fp)
 d04bab0:	10800317 	ldw	r2,12(r2)
 d04bab4:	1004923a 	slli	r2,r2,8
 d04bab8:	10bfc00c 	andi	r2,r2,65280
 d04babc:	1884b03a 	or	r2,r3,r2
 d04bac0:	1004d43a 	srli	r2,r2,16
 d04bac4:	11003fcc 	andi	r4,r2,255
 d04bac8:	e0bffe17 	ldw	r2,-8(fp)
 d04bacc:	10800317 	ldw	r2,12(r2)
 d04bad0:	1004d23a 	srli	r2,r2,8
 d04bad4:	10c03fcc 	andi	r3,r2,255
 d04bad8:	e0bffe17 	ldw	r2,-8(fp)
 d04badc:	10800317 	ldw	r2,12(r2)
 d04bae0:	1004923a 	slli	r2,r2,8
 d04bae4:	10bfc00c 	andi	r2,r2,65280
 d04bae8:	1884b03a 	or	r2,r3,r2
 d04baec:	1004d63a 	srli	r2,r2,24
 d04baf0:	d9000015 	stw	r4,0(sp)
 d04baf4:	d8800115 	stw	r2,4(sp)
 d04baf8:	01034174 	movhi	r4,3333
 d04bafc:	2109de04 	addi	r4,r4,10104
 d04bb00:	d0028a00 	call	d0028a0 <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 d04bb04:	e0bffe17 	ldw	r2,-8(fp)
 d04bb08:	10800003 	ldbu	r2,0(r2)
 d04bb0c:	108003cc 	andi	r2,r2,15
 d04bb10:	1085883a 	add	r2,r2,r2
 d04bb14:	1085883a 	add	r2,r2,r2
 d04bb18:	10800404 	addi	r2,r2,16
 d04bb1c:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d04bb20:	01000084 	movi	r4,2
 d04bb24:	d025cf00 	call	d025cf0 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 d04bb28:	e0fff903 	ldbu	r3,-28(fp)
 d04bb2c:	00834174 	movhi	r2,3333
 d04bb30:	109b1e04 	addi	r2,r2,27768
 d04bb34:	10800017 	ldw	r2,0(r2)
 d04bb38:	1885883a 	add	r2,r3,r2
 d04bb3c:	11000504 	addi	r4,r2,20
 d04bb40:	d024e0c0 	call	d024e0c <pk_alloc>
 d04bb44:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04bb48:	01000084 	movi	r4,2
 d04bb4c:	d025db00 	call	d025db0 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 d04bb50:	e0bffd17 	ldw	r2,-12(fp)
 d04bb54:	1004c03a 	cmpne	r2,r2,zero
 d04bb58:	1000111e 	bne	r2,zero,d04bba0 <icmp_timex+0x18c>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 d04bb5c:	00834174 	movhi	r2,3333
 d04bb60:	109b2004 	addi	r2,r2,27776
 d04bb64:	10800017 	ldw	r2,0(r2)
 d04bb68:	1080800c 	andi	r2,r2,512
 d04bb6c:	1005003a 	cmpeq	r2,r2,zero
 d04bb70:	1000031e 	bne	r2,zero,d04bb80 <icmp_timex+0x16c>
         dprintf("icmp: can't alloc pkt\n");
 d04bb74:	01034174 	movhi	r4,3333
 d04bb78:	2109cf04 	addi	r4,r4,10044
 d04bb7c:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 d04bb80:	008341b4 	movhi	r2,3334
 d04bb84:	10858604 	addi	r2,r2,5656
 d04bb88:	10800e17 	ldw	r2,56(r2)
 d04bb8c:	10c00044 	addi	r3,r2,1
 d04bb90:	008341b4 	movhi	r2,3334
 d04bb94:	10858604 	addi	r2,r2,5656
 d04bb98:	10c00e15 	stw	r3,56(r2)
      return;
 d04bb9c:	00006506 	br	d04bd34 <icmp_timex+0x320>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 d04bba0:	e0bffd17 	ldw	r2,-12(fp)
 d04bba4:	10800317 	ldw	r2,12(r2)
 d04bba8:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 d04bbac:	e0bffe17 	ldw	r2,-8(fp)
 d04bbb0:	10c00417 	ldw	r3,16(r2)
 d04bbb4:	e0bffb17 	ldw	r2,-20(fp)
 d04bbb8:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 d04bbbc:	e0bffe17 	ldw	r2,-8(fp)
 d04bbc0:	10c00317 	ldw	r3,12(r2)
 d04bbc4:	e0bffb17 	ldw	r2,-20(fp)
 d04bbc8:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 d04bbcc:	e0bffd17 	ldw	r2,-12(fp)
 d04bbd0:	10800317 	ldw	r2,12(r2)
 d04bbd4:	10c00504 	addi	r3,r2,20
 d04bbd8:	e0bffd17 	ldw	r2,-12(fp)
 d04bbdc:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 d04bbe0:	e0bffd17 	ldw	r2,-12(fp)
 d04bbe4:	10800317 	ldw	r2,12(r2)
 d04bbe8:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 d04bbec:	e0fffc17 	ldw	r3,-16(fp)
 d04bbf0:	008002c4 	movi	r2,11
 d04bbf4:	18800005 	stb	r2,0(r3)
   tx->tcode = code;
 d04bbf8:	e0fffc17 	ldw	r3,-16(fp)
 d04bbfc:	e0bfff03 	ldbu	r2,-4(fp)
 d04bc00:	18800045 	stb	r2,1(r3)
   tx->tno1 = tx->tno2 = 0;
 d04bc04:	e0bffc17 	ldw	r2,-16(fp)
 d04bc08:	1000018d 	sth	zero,6(r2)
 d04bc0c:	e0bffc17 	ldw	r2,-16(fp)
 d04bc10:	10c0018b 	ldhu	r3,6(r2)
 d04bc14:	e0bffc17 	ldw	r2,-16(fp)
 d04bc18:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 d04bc1c:	e0bffc17 	ldw	r2,-16(fp)
 d04bc20:	11000204 	addi	r4,r2,8
 d04bc24:	e0bffe17 	ldw	r2,-8(fp)
 d04bc28:	10800003 	ldbu	r2,0(r2)
 d04bc2c:	10803fcc 	andi	r2,r2,255
 d04bc30:	108003cc 	andi	r2,r2,15
 d04bc34:	1085883a 	add	r2,r2,r2
 d04bc38:	1085883a 	add	r2,r2,r2
 d04bc3c:	10800204 	addi	r2,r2,8
 d04bc40:	1007883a 	mov	r3,r2
 d04bc44:	e0bffe17 	ldw	r2,-8(fp)
 d04bc48:	100b883a 	mov	r5,r2
 d04bc4c:	180d883a 	mov	r6,r3
 d04bc50:	d0026080 	call	d002608 <memcpy>

   tx->tchksum = 0;
 d04bc54:	e0bffc17 	ldw	r2,-16(fp)
 d04bc58:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 d04bc5c:	e0bff903 	ldbu	r2,-28(fp)
 d04bc60:	1004d07a 	srli	r2,r2,1
 d04bc64:	11403fcc 	andi	r5,r2,255
 d04bc68:	e13ffc17 	ldw	r4,-16(fp)
 d04bc6c:	d0205440 	call	d020544 <cksum>
 d04bc70:	0084303a 	nor	r2,zero,r2
 d04bc74:	1007883a 	mov	r3,r2
 d04bc78:	e0bffc17 	ldw	r2,-16(fp)
 d04bc7c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 d04bc80:	e0fff903 	ldbu	r3,-28(fp)
 d04bc84:	e0bffd17 	ldw	r2,-12(fp)
 d04bc88:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 d04bc8c:	e0bffb17 	ldw	r2,-20(fp)
 d04bc90:	10c00417 	ldw	r3,16(r2)
 d04bc94:	e0bffd17 	ldw	r2,-12(fp)
 d04bc98:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 d04bc9c:	01000044 	movi	r4,1
 d04bca0:	e17ffd17 	ldw	r5,-12(fp)
 d04bca4:	d03f2780 	call	d03f278 <ip_write>
 d04bca8:	e0bffa15 	stw	r2,-24(fp)
   if (i < 0)
 d04bcac:	e0bffa17 	ldw	r2,-24(fp)
 d04bcb0:	1004403a 	cmpge	r2,r2,zero
 d04bcb4:	1000111e 	bne	r2,zero,d04bcfc <icmp_timex+0x2e8>
   {
      icmp_mib.icmpOutErrors++;
 d04bcb8:	008341b4 	movhi	r2,3334
 d04bcbc:	10858604 	addi	r2,r2,5656
 d04bcc0:	10800e17 	ldw	r2,56(r2)
 d04bcc4:	10c00044 	addi	r3,r2,1
 d04bcc8:	008341b4 	movhi	r2,3334
 d04bccc:	10858604 	addi	r2,r2,5656
 d04bcd0:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 d04bcd4:	00834174 	movhi	r2,3333
 d04bcd8:	109b2004 	addi	r2,r2,27776
 d04bcdc:	10800017 	ldw	r2,0(r2)
 d04bce0:	1080860c 	andi	r2,r2,536
 d04bce4:	1005003a 	cmpeq	r2,r2,zero
 d04bce8:	1000121e 	bne	r2,zero,d04bd34 <icmp_timex+0x320>
         dprintf("ICMP: Can't send Time Exceeded\n");
 d04bcec:	01034174 	movhi	r4,3333
 d04bcf0:	2109ee04 	addi	r4,r4,10168
 d04bcf4:	d002bc80 	call	d002bc8 <puts>
#endif   /* NPDEBUG  */
      return;
 d04bcf8:	00000e06 	br	d04bd34 <icmp_timex+0x320>
   }
   icmp_mib.icmpOutMsgs++;
 d04bcfc:	008341b4 	movhi	r2,3334
 d04bd00:	10858604 	addi	r2,r2,5656
 d04bd04:	10800d17 	ldw	r2,52(r2)
 d04bd08:	10c00044 	addi	r3,r2,1
 d04bd0c:	008341b4 	movhi	r2,3334
 d04bd10:	10858604 	addi	r2,r2,5656
 d04bd14:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 d04bd18:	008341b4 	movhi	r2,3334
 d04bd1c:	10858604 	addi	r2,r2,5656
 d04bd20:	10801017 	ldw	r2,64(r2)
 d04bd24:	10c00044 	addi	r3,r2,1
 d04bd28:	008341b4 	movhi	r2,3334
 d04bd2c:	10858604 	addi	r2,r2,5656
 d04bd30:	10c01015 	stw	r3,64(r2)
   return;
}
 d04bd34:	e037883a 	mov	sp,fp
 d04bd38:	dfc00117 	ldw	ra,4(sp)
 d04bd3c:	df000017 	ldw	fp,0(sp)
 d04bd40:	dec00204 	addi	sp,sp,8
 d04bd44:	f800283a 	ret

0d04bd48 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 d04bd48:	defffc04 	addi	sp,sp,-16
 d04bd4c:	dfc00315 	stw	ra,12(sp)
 d04bd50:	df000215 	stw	fp,8(sp)
 d04bd54:	df000204 	addi	fp,sp,8
 d04bd58:	e13ffe15 	stw	r4,-8(fp)
 d04bd5c:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 d04bd60:	d0a95b17 	ldw	r2,-23188(gp)
 d04bd64:	1005003a 	cmpeq	r2,r2,zero
 d04bd68:	1000041e 	bne	r2,zero,d04bd7c <icmp_du+0x34>
      icmpdu_hook(p, pdp);
 d04bd6c:	d0a95b17 	ldw	r2,-23188(gp)
 d04bd70:	e13ffe17 	ldw	r4,-8(fp)
 d04bd74:	e17fff17 	ldw	r5,-4(fp)
 d04bd78:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 d04bd7c:	e13ffe17 	ldw	r4,-8(fp)
 d04bd80:	e17fff17 	ldw	r5,-4(fp)
 d04bd84:	d027ca40 	call	d027ca4 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 d04bd88:	e037883a 	mov	sp,fp
 d04bd8c:	dfc00117 	ldw	ra,4(sp)
 d04bd90:	df000017 	ldw	fp,0(sp)
 d04bd94:	dec00204 	addi	sp,sp,8
 d04bd98:	f800283a 	ret

0d04bd9c <atexit>:
 d04bd9c:	200b883a 	mov	r5,r4
 d04bda0:	000d883a 	mov	r6,zero
 d04bda4:	0009883a 	mov	r4,zero
 d04bda8:	000f883a 	mov	r7,zero
 d04bdac:	d04c40c1 	jmpi	d04c40c <__register_exitproc>

0d04bdb0 <_atoi_r>:
 d04bdb0:	000d883a 	mov	r6,zero
 d04bdb4:	01c00284 	movi	r7,10
 d04bdb8:	d04c0f01 	jmpi	d04c0f0 <_strtol_r>

0d04bdbc <atoi>:
 d04bdbc:	000b883a 	mov	r5,zero
 d04bdc0:	01800284 	movi	r6,10
 d04bdc4:	d04c3401 	jmpi	d04c340 <strtol>

0d04bdc8 <calloc>:
 d04bdc8:	01834174 	movhi	r6,3333
 d04bdcc:	31922004 	addi	r6,r6,18560
 d04bdd0:	2007883a 	mov	r3,r4
 d04bdd4:	31000017 	ldw	r4,0(r6)
 d04bdd8:	280d883a 	mov	r6,r5
 d04bddc:	180b883a 	mov	r5,r3
 d04bde0:	d00a5a81 	jmpi	d00a5a8 <_calloc_r>

0d04bde4 <exit>:
 d04bde4:	defffe04 	addi	sp,sp,-8
 d04bde8:	000b883a 	mov	r5,zero
 d04bdec:	dc000015 	stw	r16,0(sp)
 d04bdf0:	dfc00115 	stw	ra,4(sp)
 d04bdf4:	2021883a 	mov	r16,r4
 d04bdf8:	d04c5440 	call	d04c544 <__call_exitprocs>
 d04bdfc:	00834174 	movhi	r2,3333
 d04be00:	10922104 	addi	r2,r2,18564
 d04be04:	11000017 	ldw	r4,0(r2)
 d04be08:	20800f17 	ldw	r2,60(r4)
 d04be0c:	10000126 	beq	r2,zero,d04be14 <exit+0x30>
 d04be10:	103ee83a 	callr	r2
 d04be14:	8009883a 	mov	r4,r16
 d04be18:	d04c7340 	call	d04c734 <_exit>

0d04be1c <free>:
 d04be1c:	00834174 	movhi	r2,3333
 d04be20:	10922004 	addi	r2,r2,18560
 d04be24:	200b883a 	mov	r5,r4
 d04be28:	11000017 	ldw	r4,0(r2)
 d04be2c:	d00763c1 	jmpi	d00763c <_free_r>

0d04be30 <malloc>:
 d04be30:	00834174 	movhi	r2,3333
 d04be34:	10922004 	addi	r2,r2,18560
 d04be38:	200b883a 	mov	r5,r4
 d04be3c:	11000017 	ldw	r4,0(r2)
 d04be40:	d0081c41 	jmpi	d0081c4 <_malloc_r>

0d04be44 <memcmp>:
 d04be44:	00c000c4 	movi	r3,3
 d04be48:	1980032e 	bgeu	r3,r6,d04be58 <memcmp+0x14>
 d04be4c:	2144b03a 	or	r2,r4,r5
 d04be50:	10c4703a 	and	r2,r2,r3
 d04be54:	10000f26 	beq	r2,zero,d04be94 <memcmp+0x50>
 d04be58:	31ffffc4 	addi	r7,r6,-1
 d04be5c:	3000061e 	bne	r6,zero,d04be78 <memcmp+0x34>
 d04be60:	00000a06 	br	d04be8c <memcmp+0x48>
 d04be64:	39ffffc4 	addi	r7,r7,-1
 d04be68:	00bfffc4 	movi	r2,-1
 d04be6c:	21000044 	addi	r4,r4,1
 d04be70:	29400044 	addi	r5,r5,1
 d04be74:	38800526 	beq	r7,r2,d04be8c <memcmp+0x48>
 d04be78:	20c00003 	ldbu	r3,0(r4)
 d04be7c:	28800003 	ldbu	r2,0(r5)
 d04be80:	18bff826 	beq	r3,r2,d04be64 <memcmp+0x20>
 d04be84:	1885c83a 	sub	r2,r3,r2
 d04be88:	f800283a 	ret
 d04be8c:	0005883a 	mov	r2,zero
 d04be90:	f800283a 	ret
 d04be94:	180f883a 	mov	r7,r3
 d04be98:	20c00017 	ldw	r3,0(r4)
 d04be9c:	28800017 	ldw	r2,0(r5)
 d04bea0:	18bfed1e 	bne	r3,r2,d04be58 <memcmp+0x14>
 d04bea4:	31bfff04 	addi	r6,r6,-4
 d04bea8:	21000104 	addi	r4,r4,4
 d04beac:	29400104 	addi	r5,r5,4
 d04beb0:	39bff936 	bltu	r7,r6,d04be98 <memcmp+0x54>
 d04beb4:	003fe806 	br	d04be58 <memcmp+0x14>

0d04beb8 <strcpy>:
 d04beb8:	2904b03a 	or	r2,r5,r4
 d04bebc:	108000cc 	andi	r2,r2,3
 d04bec0:	10000826 	beq	r2,zero,d04bee4 <strcpy+0x2c>
 d04bec4:	2007883a 	mov	r3,r4
 d04bec8:	28800003 	ldbu	r2,0(r5)
 d04becc:	29400044 	addi	r5,r5,1
 d04bed0:	18800005 	stb	r2,0(r3)
 d04bed4:	18c00044 	addi	r3,r3,1
 d04bed8:	103ffb1e 	bne	r2,zero,d04bec8 <strcpy+0x10>
 d04bedc:	2005883a 	mov	r2,r4
 d04bee0:	f800283a 	ret
 d04bee4:	29800017 	ldw	r6,0(r5)
 d04bee8:	023fbff4 	movhi	r8,65279
 d04beec:	423fbfc4 	addi	r8,r8,-257
 d04bef0:	02a02074 	movhi	r10,32897
 d04bef4:	52a02004 	addi	r10,r10,-32640
 d04bef8:	3205883a 	add	r2,r6,r8
 d04befc:	0186303a 	nor	r3,zero,r6
 d04bf00:	10c4703a 	and	r2,r2,r3
 d04bf04:	1284703a 	and	r2,r2,r10
 d04bf08:	200f883a 	mov	r7,r4
 d04bf0c:	10000b1e 	bne	r2,zero,d04bf3c <strcpy+0x84>
 d04bf10:	4013883a 	mov	r9,r8
 d04bf14:	5011883a 	mov	r8,r10
 d04bf18:	39800015 	stw	r6,0(r7)
 d04bf1c:	29400104 	addi	r5,r5,4
 d04bf20:	29800017 	ldw	r6,0(r5)
 d04bf24:	39c00104 	addi	r7,r7,4
 d04bf28:	3245883a 	add	r2,r6,r9
 d04bf2c:	0186303a 	nor	r3,zero,r6
 d04bf30:	10c4703a 	and	r2,r2,r3
 d04bf34:	1204703a 	and	r2,r2,r8
 d04bf38:	103ff726 	beq	r2,zero,d04bf18 <strcpy+0x60>
 d04bf3c:	3807883a 	mov	r3,r7
 d04bf40:	003fe106 	br	d04bec8 <strcpy+0x10>

0d04bf44 <strncmp>:
 d04bf44:	30003926 	beq	r6,zero,d04c02c <strncmp+0xe8>
 d04bf48:	2144b03a 	or	r2,r4,r5
 d04bf4c:	108000cc 	andi	r2,r2,3
 d04bf50:	028000c4 	movi	r10,3
 d04bf54:	1000241e 	bne	r2,zero,d04bfe8 <strncmp+0xa4>
 d04bf58:	2011883a 	mov	r8,r4
 d04bf5c:	280f883a 	mov	r7,r5
 d04bf60:	51801f2e 	bgeu	r10,r6,d04bfe0 <strncmp+0x9c>
 d04bf64:	21000017 	ldw	r4,0(r4)
 d04bf68:	28800017 	ldw	r2,0(r5)
 d04bf6c:	20801c1e 	bne	r4,r2,d04bfe0 <strncmp+0x9c>
 d04bf70:	31bfff04 	addi	r6,r6,-4
 d04bf74:	30002d26 	beq	r6,zero,d04c02c <strncmp+0xe8>
 d04bf78:	027fbff4 	movhi	r9,65279
 d04bf7c:	4a7fbfc4 	addi	r9,r9,-257
 d04bf80:	2247883a 	add	r3,r4,r9
 d04bf84:	01602074 	movhi	r5,32897
 d04bf88:	29602004 	addi	r5,r5,-32640
 d04bf8c:	1946703a 	and	r3,r3,r5
 d04bf90:	0104303a 	nor	r2,zero,r4
 d04bf94:	10c4703a 	and	r2,r2,r3
 d04bf98:	1000241e 	bne	r2,zero,d04c02c <strncmp+0xe8>
 d04bf9c:	5017883a 	mov	r11,r10
 d04bfa0:	4815883a 	mov	r10,r9
 d04bfa4:	2813883a 	mov	r9,r5
 d04bfa8:	00000a06 	br	d04bfd4 <strncmp+0x90>
 d04bfac:	41000017 	ldw	r4,0(r8)
 d04bfb0:	39400017 	ldw	r5,0(r7)
 d04bfb4:	2285883a 	add	r2,r4,r10
 d04bfb8:	1244703a 	and	r2,r2,r9
 d04bfbc:	0106303a 	nor	r3,zero,r4
 d04bfc0:	1886703a 	and	r3,r3,r2
 d04bfc4:	2140061e 	bne	r4,r5,d04bfe0 <strncmp+0x9c>
 d04bfc8:	31bfff04 	addi	r6,r6,-4
 d04bfcc:	30001726 	beq	r6,zero,d04c02c <strncmp+0xe8>
 d04bfd0:	1800161e 	bne	r3,zero,d04c02c <strncmp+0xe8>
 d04bfd4:	42000104 	addi	r8,r8,4
 d04bfd8:	39c00104 	addi	r7,r7,4
 d04bfdc:	59bff336 	bltu	r11,r6,d04bfac <strncmp+0x68>
 d04bfe0:	4009883a 	mov	r4,r8
 d04bfe4:	380b883a 	mov	r5,r7
 d04bfe8:	31bfffc4 	addi	r6,r6,-1
 d04bfec:	01ffffc4 	movi	r7,-1
 d04bff0:	31c00a1e 	bne	r6,r7,d04c01c <strncmp+0xd8>
 d04bff4:	20c00003 	ldbu	r3,0(r4)
 d04bff8:	28800003 	ldbu	r2,0(r5)
 d04bffc:	1885c83a 	sub	r2,r3,r2
 d04c000:	f800283a 	ret
 d04c004:	30000926 	beq	r6,zero,d04c02c <strncmp+0xe8>
 d04c008:	18000826 	beq	r3,zero,d04c02c <strncmp+0xe8>
 d04c00c:	31bfffc4 	addi	r6,r6,-1
 d04c010:	21000044 	addi	r4,r4,1
 d04c014:	29400044 	addi	r5,r5,1
 d04c018:	31fff626 	beq	r6,r7,d04bff4 <strncmp+0xb0>
 d04c01c:	20c00007 	ldb	r3,0(r4)
 d04c020:	28800007 	ldb	r2,0(r5)
 d04c024:	18bff726 	beq	r3,r2,d04c004 <strncmp+0xc0>
 d04c028:	003ff206 	br	d04bff4 <strncmp+0xb0>
 d04c02c:	0005883a 	mov	r2,zero
 d04c030:	f800283a 	ret

0d04c034 <strncpy>:
 d04c034:	2904b03a 	or	r2,r5,r4
 d04c038:	108000cc 	andi	r2,r2,3
 d04c03c:	00c000c4 	movi	r3,3
 d04c040:	1000291e 	bne	r2,zero,d04c0e8 <strncpy+0xb4>
 d04c044:	1980282e 	bgeu	r3,r6,d04c0e8 <strncpy+0xb4>
 d04c048:	1817883a 	mov	r11,r3
 d04c04c:	2011883a 	mov	r8,r4
 d04c050:	02bfbff4 	movhi	r10,65279
 d04c054:	52bfbfc4 	addi	r10,r10,-257
 d04c058:	02602074 	movhi	r9,32897
 d04c05c:	4a602004 	addi	r9,r9,-32640
 d04c060:	29c00017 	ldw	r7,0(r5)
 d04c064:	3a85883a 	add	r2,r7,r10
 d04c068:	01c6303a 	nor	r3,zero,r7
 d04c06c:	10c4703a 	and	r2,r2,r3
 d04c070:	1244703a 	and	r2,r2,r9
 d04c074:	1000051e 	bne	r2,zero,d04c08c <strncpy+0x58>
 d04c078:	31bfff04 	addi	r6,r6,-4
 d04c07c:	41c00015 	stw	r7,0(r8)
 d04c080:	29400104 	addi	r5,r5,4
 d04c084:	42000104 	addi	r8,r8,4
 d04c088:	59bff536 	bltu	r11,r6,d04c060 <strncpy+0x2c>
 d04c08c:	400f883a 	mov	r7,r8
 d04c090:	30001326 	beq	r6,zero,d04c0e0 <strncpy+0xac>
 d04c094:	28800003 	ldbu	r2,0(r5)
 d04c098:	31bfffc4 	addi	r6,r6,-1
 d04c09c:	38c00044 	addi	r3,r7,1
 d04c0a0:	38800005 	stb	r2,0(r7)
 d04c0a4:	10000826 	beq	r2,zero,d04c0c8 <strncpy+0x94>
 d04c0a8:	29400044 	addi	r5,r5,1
 d04c0ac:	30000c26 	beq	r6,zero,d04c0e0 <strncpy+0xac>
 d04c0b0:	28800003 	ldbu	r2,0(r5)
 d04c0b4:	31bfffc4 	addi	r6,r6,-1
 d04c0b8:	29400044 	addi	r5,r5,1
 d04c0bc:	18800005 	stb	r2,0(r3)
 d04c0c0:	18c00044 	addi	r3,r3,1
 d04c0c4:	103ff91e 	bne	r2,zero,d04c0ac <strncpy+0x78>
 d04c0c8:	30000526 	beq	r6,zero,d04c0e0 <strncpy+0xac>
 d04c0cc:	1805883a 	mov	r2,r3
 d04c0d0:	30cd883a 	add	r6,r6,r3
 d04c0d4:	10000005 	stb	zero,0(r2)
 d04c0d8:	10800044 	addi	r2,r2,1
 d04c0dc:	30bffd1e 	bne	r6,r2,d04c0d4 <strncpy+0xa0>
 d04c0e0:	2005883a 	mov	r2,r4
 d04c0e4:	f800283a 	ret
 d04c0e8:	200f883a 	mov	r7,r4
 d04c0ec:	003fe806 	br	d04c090 <strncpy+0x5c>

0d04c0f0 <_strtol_r>:
 d04c0f0:	defff304 	addi	sp,sp,-52
 d04c0f4:	00834174 	movhi	r2,3333
 d04c0f8:	10921f04 	addi	r2,r2,18556
 d04c0fc:	dd000715 	stw	r20,28(sp)
 d04c100:	15000017 	ldw	r20,0(r2)
 d04c104:	ddc00a15 	stw	r23,40(sp)
 d04c108:	dc800515 	stw	r18,20(sp)
 d04c10c:	dc400415 	stw	r17,16(sp)
 d04c110:	dfc00c15 	stw	ra,48(sp)
 d04c114:	df000b15 	stw	fp,44(sp)
 d04c118:	dd800915 	stw	r22,36(sp)
 d04c11c:	dd400815 	stw	r21,32(sp)
 d04c120:	dcc00615 	stw	r19,24(sp)
 d04c124:	dc000315 	stw	r16,12(sp)
 d04c128:	282f883a 	mov	r23,r5
 d04c12c:	d9000115 	stw	r4,4(sp)
 d04c130:	d9800215 	stw	r6,8(sp)
 d04c134:	3825883a 	mov	r18,r7
 d04c138:	2823883a 	mov	r17,r5
 d04c13c:	8c000007 	ldb	r16,0(r17)
 d04c140:	8c400044 	addi	r17,r17,1
 d04c144:	a407883a 	add	r3,r20,r16
 d04c148:	18800003 	ldbu	r2,0(r3)
 d04c14c:	1080020c 	andi	r2,r2,8
 d04c150:	103ffa1e 	bne	r2,zero,d04c13c <_strtol_r+0x4c>
 d04c154:	00800b44 	movi	r2,45
 d04c158:	80805c26 	beq	r16,r2,d04c2cc <_strtol_r+0x1dc>
 d04c15c:	00800ac4 	movi	r2,43
 d04c160:	80805726 	beq	r16,r2,d04c2c0 <_strtol_r+0x1d0>
 d04c164:	d8000015 	stw	zero,0(sp)
 d04c168:	9007003a 	cmpeq	r3,r18,zero
 d04c16c:	1800431e 	bne	r3,zero,d04c27c <_strtol_r+0x18c>
 d04c170:	00800404 	movi	r2,16
 d04c174:	90804126 	beq	r18,r2,d04c27c <_strtol_r+0x18c>
 d04c178:	902b883a 	mov	r21,r18
 d04c17c:	d8c00017 	ldw	r3,0(sp)
 d04c180:	1838c03a 	cmpne	fp,r3,zero
 d04c184:	e0004a1e 	bne	fp,zero,d04c2b0 <_strtol_r+0x1c0>
 d04c188:	04e00034 	movhi	r19,32768
 d04c18c:	9cffffc4 	addi	r19,r19,-1
 d04c190:	9809883a 	mov	r4,r19
 d04c194:	a80b883a 	mov	r5,r21
 d04c198:	d00c9140 	call	d00c914 <__umodsi3>
 d04c19c:	9809883a 	mov	r4,r19
 d04c1a0:	a80b883a 	mov	r5,r21
 d04c1a4:	102d883a 	mov	r22,r2
 d04c1a8:	d00c90c0 	call	d00c90c <__udivsi3>
 d04c1ac:	1027883a 	mov	r19,r2
 d04c1b0:	a405883a 	add	r2,r20,r16
 d04c1b4:	11400003 	ldbu	r5,0(r2)
 d04c1b8:	0009883a 	mov	r4,zero
 d04c1bc:	000d883a 	mov	r6,zero
 d04c1c0:	28c0010c 	andi	r3,r5,4
 d04c1c4:	18000f26 	beq	r3,zero,d04c204 <_strtol_r+0x114>
 d04c1c8:	843ff404 	addi	r16,r16,-48
 d04c1cc:	8480150e 	bge	r16,r18,d04c224 <_strtol_r+0x134>
 d04c1d0:	30003216 	blt	r6,zero,d04c29c <_strtol_r+0x1ac>
 d04c1d4:	99003136 	bltu	r19,r4,d04c29c <_strtol_r+0x1ac>
 d04c1d8:	24c02f26 	beq	r4,r19,d04c298 <_strtol_r+0x1a8>
 d04c1dc:	a80b883a 	mov	r5,r21
 d04c1e0:	d00235c0 	call	d00235c <__mulsi3>
 d04c1e4:	1409883a 	add	r4,r2,r16
 d04c1e8:	01800044 	movi	r6,1
 d04c1ec:	8c000007 	ldb	r16,0(r17)
 d04c1f0:	8c400044 	addi	r17,r17,1
 d04c1f4:	a405883a 	add	r2,r20,r16
 d04c1f8:	11400003 	ldbu	r5,0(r2)
 d04c1fc:	28c0010c 	andi	r3,r5,4
 d04c200:	183ff11e 	bne	r3,zero,d04c1c8 <_strtol_r+0xd8>
 d04c204:	288000cc 	andi	r2,r5,3
 d04c208:	10000626 	beq	r2,zero,d04c224 <_strtol_r+0x134>
 d04c20c:	2880004c 	andi	r2,r5,1
 d04c210:	1005003a 	cmpeq	r2,r2,zero
 d04c214:	1000231e 	bne	r2,zero,d04c2a4 <_strtol_r+0x1b4>
 d04c218:	00800dc4 	movi	r2,55
 d04c21c:	80a1c83a 	sub	r16,r16,r2
 d04c220:	84bfeb16 	blt	r16,r18,d04c1d0 <_strtol_r+0xe0>
 d04c224:	30002e16 	blt	r6,zero,d04c2e0 <_strtol_r+0x1f0>
 d04c228:	e000231e 	bne	fp,zero,d04c2b8 <_strtol_r+0x1c8>
 d04c22c:	2007883a 	mov	r3,r4
 d04c230:	d8800217 	ldw	r2,8(sp)
 d04c234:	10000426 	beq	r2,zero,d04c248 <_strtol_r+0x158>
 d04c238:	30000126 	beq	r6,zero,d04c240 <_strtol_r+0x150>
 d04c23c:	8dffffc4 	addi	r23,r17,-1
 d04c240:	d9000217 	ldw	r4,8(sp)
 d04c244:	25c00015 	stw	r23,0(r4)
 d04c248:	1805883a 	mov	r2,r3
 d04c24c:	dfc00c17 	ldw	ra,48(sp)
 d04c250:	df000b17 	ldw	fp,44(sp)
 d04c254:	ddc00a17 	ldw	r23,40(sp)
 d04c258:	dd800917 	ldw	r22,36(sp)
 d04c25c:	dd400817 	ldw	r21,32(sp)
 d04c260:	dd000717 	ldw	r20,28(sp)
 d04c264:	dcc00617 	ldw	r19,24(sp)
 d04c268:	dc800517 	ldw	r18,20(sp)
 d04c26c:	dc400417 	ldw	r17,16(sp)
 d04c270:	dc000317 	ldw	r16,12(sp)
 d04c274:	dec00d04 	addi	sp,sp,52
 d04c278:	f800283a 	ret
 d04c27c:	00800c04 	movi	r2,48
 d04c280:	80801f26 	beq	r16,r2,d04c300 <_strtol_r+0x210>
 d04c284:	183fbc26 	beq	r3,zero,d04c178 <_strtol_r+0x88>
 d04c288:	00800c04 	movi	r2,48
 d04c28c:	80802926 	beq	r16,r2,d04c334 <_strtol_r+0x244>
 d04c290:	04800284 	movi	r18,10
 d04c294:	003fb806 	br	d04c178 <_strtol_r+0x88>
 d04c298:	b43fd00e 	bge	r22,r16,d04c1dc <_strtol_r+0xec>
 d04c29c:	01bfffc4 	movi	r6,-1
 d04c2a0:	003fd206 	br	d04c1ec <_strtol_r+0xfc>
 d04c2a4:	008015c4 	movi	r2,87
 d04c2a8:	80a1c83a 	sub	r16,r16,r2
 d04c2ac:	003fdc06 	br	d04c220 <_strtol_r+0x130>
 d04c2b0:	04e00034 	movhi	r19,32768
 d04c2b4:	003fb606 	br	d04c190 <_strtol_r+0xa0>
 d04c2b8:	0107c83a 	sub	r3,zero,r4
 d04c2bc:	003fdc06 	br	d04c230 <_strtol_r+0x140>
 d04c2c0:	8c000007 	ldb	r16,0(r17)
 d04c2c4:	8c400044 	addi	r17,r17,1
 d04c2c8:	003fa606 	br	d04c164 <_strtol_r+0x74>
 d04c2cc:	8c000007 	ldb	r16,0(r17)
 d04c2d0:	00800044 	movi	r2,1
 d04c2d4:	8c400044 	addi	r17,r17,1
 d04c2d8:	d8800015 	stw	r2,0(sp)
 d04c2dc:	003fa206 	br	d04c168 <_strtol_r+0x78>
 d04c2e0:	d9000017 	ldw	r4,0(sp)
 d04c2e4:	2005003a 	cmpeq	r2,r4,zero
 d04c2e8:	10000f1e 	bne	r2,zero,d04c328 <_strtol_r+0x238>
 d04c2ec:	00e00034 	movhi	r3,32768
 d04c2f0:	d9000117 	ldw	r4,4(sp)
 d04c2f4:	00800884 	movi	r2,34
 d04c2f8:	20800015 	stw	r2,0(r4)
 d04c2fc:	003fcc06 	br	d04c230 <_strtol_r+0x140>
 d04c300:	89000007 	ldb	r4,0(r17)
 d04c304:	00801e04 	movi	r2,120
 d04c308:	20800226 	beq	r4,r2,d04c314 <_strtol_r+0x224>
 d04c30c:	00801604 	movi	r2,88
 d04c310:	20bfdc1e 	bne	r4,r2,d04c284 <_strtol_r+0x194>
 d04c314:	8c000047 	ldb	r16,1(r17)
 d04c318:	04800404 	movi	r18,16
 d04c31c:	8c400084 	addi	r17,r17,2
 d04c320:	902b883a 	mov	r21,r18
 d04c324:	003f9506 	br	d04c17c <_strtol_r+0x8c>
 d04c328:	00e00034 	movhi	r3,32768
 d04c32c:	18ffffc4 	addi	r3,r3,-1
 d04c330:	003fef06 	br	d04c2f0 <_strtol_r+0x200>
 d04c334:	04800204 	movi	r18,8
 d04c338:	902b883a 	mov	r21,r18
 d04c33c:	003f8f06 	br	d04c17c <_strtol_r+0x8c>

0d04c340 <strtol>:
 d04c340:	00834174 	movhi	r2,3333
 d04c344:	10922004 	addi	r2,r2,18560
 d04c348:	2013883a 	mov	r9,r4
 d04c34c:	11000017 	ldw	r4,0(r2)
 d04c350:	2805883a 	mov	r2,r5
 d04c354:	300f883a 	mov	r7,r6
 d04c358:	480b883a 	mov	r5,r9
 d04c35c:	100d883a 	mov	r6,r2
 d04c360:	d04c0f01 	jmpi	d04c0f0 <_strtol_r>

0d04c364 <_vprintf_r>:
 d04c364:	2807883a 	mov	r3,r5
 d04c368:	21400217 	ldw	r5,8(r4)
 d04c36c:	300f883a 	mov	r7,r6
 d04c370:	180d883a 	mov	r6,r3
 d04c374:	d0035381 	jmpi	d003538 <___vfprintf_internal_r>

0d04c378 <vprintf>:
 d04c378:	00834174 	movhi	r2,3333
 d04c37c:	10922004 	addi	r2,r2,18560
 d04c380:	12000017 	ldw	r8,0(r2)
 d04c384:	280f883a 	mov	r7,r5
 d04c388:	200d883a 	mov	r6,r4
 d04c38c:	41400217 	ldw	r5,8(r8)
 d04c390:	4009883a 	mov	r4,r8
 d04c394:	d0035381 	jmpi	d003538 <___vfprintf_internal_r>

0d04c398 <_vsprintf_r>:
 d04c398:	deffe804 	addi	sp,sp,-96
 d04c39c:	00808204 	movi	r2,520
 d04c3a0:	2811883a 	mov	r8,r5
 d04c3a4:	02600034 	movhi	r9,32768
 d04c3a8:	4a7fffc4 	addi	r9,r9,-1
 d04c3ac:	d880030d 	sth	r2,12(sp)
 d04c3b0:	d80b883a 	mov	r5,sp
 d04c3b4:	00bfffc4 	movi	r2,-1
 d04c3b8:	dfc01715 	stw	ra,92(sp)
 d04c3bc:	da000415 	stw	r8,16(sp)
 d04c3c0:	da400515 	stw	r9,20(sp)
 d04c3c4:	d880038d 	sth	r2,14(sp)
 d04c3c8:	da000015 	stw	r8,0(sp)
 d04c3cc:	da400215 	stw	r9,8(sp)
 d04c3d0:	d0035380 	call	d003538 <___vfprintf_internal_r>
 d04c3d4:	d8c00017 	ldw	r3,0(sp)
 d04c3d8:	18000005 	stb	zero,0(r3)
 d04c3dc:	dfc01717 	ldw	ra,92(sp)
 d04c3e0:	dec01804 	addi	sp,sp,96
 d04c3e4:	f800283a 	ret

0d04c3e8 <vsprintf>:
 d04c3e8:	00834174 	movhi	r2,3333
 d04c3ec:	10922004 	addi	r2,r2,18560
 d04c3f0:	2013883a 	mov	r9,r4
 d04c3f4:	11000017 	ldw	r4,0(r2)
 d04c3f8:	2805883a 	mov	r2,r5
 d04c3fc:	300f883a 	mov	r7,r6
 d04c400:	480b883a 	mov	r5,r9
 d04c404:	100d883a 	mov	r6,r2
 d04c408:	d04c3981 	jmpi	d04c398 <_vsprintf_r>

0d04c40c <__register_exitproc>:
 d04c40c:	defffa04 	addi	sp,sp,-24
 d04c410:	00834174 	movhi	r2,3333
 d04c414:	10922104 	addi	r2,r2,18564
 d04c418:	dc000015 	stw	r16,0(sp)
 d04c41c:	14000017 	ldw	r16,0(r2)
 d04c420:	dd000415 	stw	r20,16(sp)
 d04c424:	2829883a 	mov	r20,r5
 d04c428:	81405217 	ldw	r5,328(r16)
 d04c42c:	dcc00315 	stw	r19,12(sp)
 d04c430:	dc800215 	stw	r18,8(sp)
 d04c434:	dc400115 	stw	r17,4(sp)
 d04c438:	dfc00515 	stw	ra,20(sp)
 d04c43c:	2023883a 	mov	r17,r4
 d04c440:	3027883a 	mov	r19,r6
 d04c444:	3825883a 	mov	r18,r7
 d04c448:	28002526 	beq	r5,zero,d04c4e0 <__register_exitproc+0xd4>
 d04c44c:	29000117 	ldw	r4,4(r5)
 d04c450:	008007c4 	movi	r2,31
 d04c454:	11002716 	blt	r2,r4,d04c4f4 <__register_exitproc+0xe8>
 d04c458:	8800101e 	bne	r17,zero,d04c49c <__register_exitproc+0x90>
 d04c45c:	2105883a 	add	r2,r4,r4
 d04c460:	1085883a 	add	r2,r2,r2
 d04c464:	20c00044 	addi	r3,r4,1
 d04c468:	1145883a 	add	r2,r2,r5
 d04c46c:	0009883a 	mov	r4,zero
 d04c470:	15000215 	stw	r20,8(r2)
 d04c474:	28c00115 	stw	r3,4(r5)
 d04c478:	2005883a 	mov	r2,r4
 d04c47c:	dfc00517 	ldw	ra,20(sp)
 d04c480:	dd000417 	ldw	r20,16(sp)
 d04c484:	dcc00317 	ldw	r19,12(sp)
 d04c488:	dc800217 	ldw	r18,8(sp)
 d04c48c:	dc400117 	ldw	r17,4(sp)
 d04c490:	dc000017 	ldw	r16,0(sp)
 d04c494:	dec00604 	addi	sp,sp,24
 d04c498:	f800283a 	ret
 d04c49c:	29802204 	addi	r6,r5,136
 d04c4a0:	00800044 	movi	r2,1
 d04c4a4:	110e983a 	sll	r7,r2,r4
 d04c4a8:	30c04017 	ldw	r3,256(r6)
 d04c4ac:	2105883a 	add	r2,r4,r4
 d04c4b0:	1085883a 	add	r2,r2,r2
 d04c4b4:	1185883a 	add	r2,r2,r6
 d04c4b8:	19c6b03a 	or	r3,r3,r7
 d04c4bc:	14802015 	stw	r18,128(r2)
 d04c4c0:	14c00015 	stw	r19,0(r2)
 d04c4c4:	00800084 	movi	r2,2
 d04c4c8:	30c04015 	stw	r3,256(r6)
 d04c4cc:	88bfe31e 	bne	r17,r2,d04c45c <__register_exitproc+0x50>
 d04c4d0:	30804117 	ldw	r2,260(r6)
 d04c4d4:	11c4b03a 	or	r2,r2,r7
 d04c4d8:	30804115 	stw	r2,260(r6)
 d04c4dc:	003fdf06 	br	d04c45c <__register_exitproc+0x50>
 d04c4e0:	008341b4 	movhi	r2,3334
 d04c4e4:	1085a004 	addi	r2,r2,5760
 d04c4e8:	100b883a 	mov	r5,r2
 d04c4ec:	80805215 	stw	r2,328(r16)
 d04c4f0:	003fd606 	br	d04c44c <__register_exitproc+0x40>
 d04c4f4:	00834174 	movhi	r2,3333
 d04c4f8:	10af8c04 	addi	r2,r2,-16848
 d04c4fc:	1000021e 	bne	r2,zero,d04c508 <__register_exitproc+0xfc>
 d04c500:	013fffc4 	movi	r4,-1
 d04c504:	003fdc06 	br	d04c478 <__register_exitproc+0x6c>
 d04c508:	01006404 	movi	r4,400
 d04c50c:	103ee83a 	callr	r2
 d04c510:	1007883a 	mov	r3,r2
 d04c514:	103ffa26 	beq	r2,zero,d04c500 <__register_exitproc+0xf4>
 d04c518:	80805217 	ldw	r2,328(r16)
 d04c51c:	180b883a 	mov	r5,r3
 d04c520:	18000115 	stw	zero,4(r3)
 d04c524:	18800015 	stw	r2,0(r3)
 d04c528:	80c05215 	stw	r3,328(r16)
 d04c52c:	18006215 	stw	zero,392(r3)
 d04c530:	18006315 	stw	zero,396(r3)
 d04c534:	0009883a 	mov	r4,zero
 d04c538:	883fc826 	beq	r17,zero,d04c45c <__register_exitproc+0x50>
 d04c53c:	003fd706 	br	d04c49c <__register_exitproc+0x90>

0d04c540 <register_fini>:
 d04c540:	f800283a 	ret

0d04c544 <__call_exitprocs>:
 d04c544:	00834174 	movhi	r2,3333
 d04c548:	10922104 	addi	r2,r2,18564
 d04c54c:	10800017 	ldw	r2,0(r2)
 d04c550:	defff304 	addi	sp,sp,-52
 d04c554:	df000b15 	stw	fp,44(sp)
 d04c558:	d8800115 	stw	r2,4(sp)
 d04c55c:	00834174 	movhi	r2,3333
 d04c560:	10af8704 	addi	r2,r2,-16868
 d04c564:	1005003a 	cmpeq	r2,r2,zero
 d04c568:	d8800215 	stw	r2,8(sp)
 d04c56c:	d8800117 	ldw	r2,4(sp)
 d04c570:	dd400815 	stw	r21,32(sp)
 d04c574:	dd000715 	stw	r20,28(sp)
 d04c578:	10805204 	addi	r2,r2,328
 d04c57c:	dfc00c15 	stw	ra,48(sp)
 d04c580:	ddc00a15 	stw	r23,40(sp)
 d04c584:	dd800915 	stw	r22,36(sp)
 d04c588:	dcc00615 	stw	r19,24(sp)
 d04c58c:	dc800515 	stw	r18,20(sp)
 d04c590:	dc400415 	stw	r17,16(sp)
 d04c594:	dc000315 	stw	r16,12(sp)
 d04c598:	282b883a 	mov	r21,r5
 d04c59c:	2039883a 	mov	fp,r4
 d04c5a0:	d8800015 	stw	r2,0(sp)
 d04c5a4:	2829003a 	cmpeq	r20,r5,zero
 d04c5a8:	d8800117 	ldw	r2,4(sp)
 d04c5ac:	14405217 	ldw	r17,328(r2)
 d04c5b0:	88001026 	beq	r17,zero,d04c5f4 <__call_exitprocs+0xb0>
 d04c5b4:	ddc00017 	ldw	r23,0(sp)
 d04c5b8:	88800117 	ldw	r2,4(r17)
 d04c5bc:	8c802204 	addi	r18,r17,136
 d04c5c0:	143fffc4 	addi	r16,r2,-1
 d04c5c4:	80000916 	blt	r16,zero,d04c5ec <__call_exitprocs+0xa8>
 d04c5c8:	05bfffc4 	movi	r22,-1
 d04c5cc:	a000151e 	bne	r20,zero,d04c624 <__call_exitprocs+0xe0>
 d04c5d0:	8409883a 	add	r4,r16,r16
 d04c5d4:	2105883a 	add	r2,r4,r4
 d04c5d8:	1485883a 	add	r2,r2,r18
 d04c5dc:	10c02017 	ldw	r3,128(r2)
 d04c5e0:	a8c01126 	beq	r21,r3,d04c628 <__call_exitprocs+0xe4>
 d04c5e4:	843fffc4 	addi	r16,r16,-1
 d04c5e8:	85bff81e 	bne	r16,r22,d04c5cc <__call_exitprocs+0x88>
 d04c5ec:	d8800217 	ldw	r2,8(sp)
 d04c5f0:	10003126 	beq	r2,zero,d04c6b8 <__call_exitprocs+0x174>
 d04c5f4:	dfc00c17 	ldw	ra,48(sp)
 d04c5f8:	df000b17 	ldw	fp,44(sp)
 d04c5fc:	ddc00a17 	ldw	r23,40(sp)
 d04c600:	dd800917 	ldw	r22,36(sp)
 d04c604:	dd400817 	ldw	r21,32(sp)
 d04c608:	dd000717 	ldw	r20,28(sp)
 d04c60c:	dcc00617 	ldw	r19,24(sp)
 d04c610:	dc800517 	ldw	r18,20(sp)
 d04c614:	dc400417 	ldw	r17,16(sp)
 d04c618:	dc000317 	ldw	r16,12(sp)
 d04c61c:	dec00d04 	addi	sp,sp,52
 d04c620:	f800283a 	ret
 d04c624:	8409883a 	add	r4,r16,r16
 d04c628:	88c00117 	ldw	r3,4(r17)
 d04c62c:	2105883a 	add	r2,r4,r4
 d04c630:	1445883a 	add	r2,r2,r17
 d04c634:	18ffffc4 	addi	r3,r3,-1
 d04c638:	11800217 	ldw	r6,8(r2)
 d04c63c:	1c001526 	beq	r3,r16,d04c694 <__call_exitprocs+0x150>
 d04c640:	10000215 	stw	zero,8(r2)
 d04c644:	303fe726 	beq	r6,zero,d04c5e4 <__call_exitprocs+0xa0>
 d04c648:	00c00044 	movi	r3,1
 d04c64c:	1c06983a 	sll	r3,r3,r16
 d04c650:	90804017 	ldw	r2,256(r18)
 d04c654:	8cc00117 	ldw	r19,4(r17)
 d04c658:	1884703a 	and	r2,r3,r2
 d04c65c:	10001426 	beq	r2,zero,d04c6b0 <__call_exitprocs+0x16c>
 d04c660:	90804117 	ldw	r2,260(r18)
 d04c664:	1884703a 	and	r2,r3,r2
 d04c668:	10000c1e 	bne	r2,zero,d04c69c <__call_exitprocs+0x158>
 d04c66c:	2105883a 	add	r2,r4,r4
 d04c670:	1485883a 	add	r2,r2,r18
 d04c674:	11400017 	ldw	r5,0(r2)
 d04c678:	e009883a 	mov	r4,fp
 d04c67c:	303ee83a 	callr	r6
 d04c680:	88800117 	ldw	r2,4(r17)
 d04c684:	98bfc81e 	bne	r19,r2,d04c5a8 <__call_exitprocs+0x64>
 d04c688:	b8800017 	ldw	r2,0(r23)
 d04c68c:	147fd526 	beq	r2,r17,d04c5e4 <__call_exitprocs+0xa0>
 d04c690:	003fc506 	br	d04c5a8 <__call_exitprocs+0x64>
 d04c694:	8c000115 	stw	r16,4(r17)
 d04c698:	003fea06 	br	d04c644 <__call_exitprocs+0x100>
 d04c69c:	2105883a 	add	r2,r4,r4
 d04c6a0:	1485883a 	add	r2,r2,r18
 d04c6a4:	11000017 	ldw	r4,0(r2)
 d04c6a8:	303ee83a 	callr	r6
 d04c6ac:	003ff406 	br	d04c680 <__call_exitprocs+0x13c>
 d04c6b0:	303ee83a 	callr	r6
 d04c6b4:	003ff206 	br	d04c680 <__call_exitprocs+0x13c>
 d04c6b8:	88800117 	ldw	r2,4(r17)
 d04c6bc:	1000081e 	bne	r2,zero,d04c6e0 <__call_exitprocs+0x19c>
 d04c6c0:	89000017 	ldw	r4,0(r17)
 d04c6c4:	20000726 	beq	r4,zero,d04c6e4 <__call_exitprocs+0x1a0>
 d04c6c8:	b9000015 	stw	r4,0(r23)
 d04c6cc:	8809883a 	mov	r4,r17
 d04c6d0:	d04be1c0 	call	d04be1c <free>
 d04c6d4:	bc400017 	ldw	r17,0(r23)
 d04c6d8:	883fb71e 	bne	r17,zero,d04c5b8 <__call_exitprocs+0x74>
 d04c6dc:	003fc506 	br	d04c5f4 <__call_exitprocs+0xb0>
 d04c6e0:	89000017 	ldw	r4,0(r17)
 d04c6e4:	882f883a 	mov	r23,r17
 d04c6e8:	2023883a 	mov	r17,r4
 d04c6ec:	883fb21e 	bne	r17,zero,d04c5b8 <__call_exitprocs+0x74>
 d04c6f0:	003fc006 	br	d04c5f4 <__call_exitprocs+0xb0>

0d04c6f4 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 d04c6f4:	defffd04 	addi	sp,sp,-12
 d04c6f8:	df000215 	stw	fp,8(sp)
 d04c6fc:	df000204 	addi	fp,sp,8
 d04c700:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 d04c704:	e0bfff17 	ldw	r2,-4(fp)
 d04c708:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 d04c70c:	e0bffe17 	ldw	r2,-8(fp)
 d04c710:	1005003a 	cmpeq	r2,r2,zero
 d04c714:	1000021e 	bne	r2,zero,d04c720 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 d04c718:	002af070 	cmpltui	zero,zero,43969
 d04c71c:	00000106 	br	d04c724 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 d04c720:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 d04c724:	e037883a 	mov	sp,fp
 d04c728:	df000017 	ldw	fp,0(sp)
 d04c72c:	dec00104 	addi	sp,sp,4
 d04c730:	f800283a 	ret

0d04c734 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 d04c734:	defffd04 	addi	sp,sp,-12
 d04c738:	dfc00215 	stw	ra,8(sp)
 d04c73c:	df000115 	stw	fp,4(sp)
 d04c740:	df000104 	addi	fp,sp,4
 d04c744:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 d04c748:	00834174 	movhi	r2,3333
 d04c74c:	109b0944 	addi	r2,r2,27685
 d04c750:	10000005 	stb	zero,0(r2)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 d04c754:	e13fff17 	ldw	r4,-4(fp)
 d04c758:	d04c6f40 	call	d04c6f4 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 d04c75c:	003fff06 	br	d04c75c <_exit+0x28>
 d04c760:	0d04c540 	call	d04c54 <__ram_exceptions_end+0xc84a58>
